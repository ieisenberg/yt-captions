[
  {
    "start": "0",
    "end": "65000"
  },
  {
    "text": "i'm frederick i'm the founder of polar signals and today we want to talk about",
    "start": "80",
    "end": "7520"
  },
  {
    "text": "cloud native ebpf beyond the hype as you can probably imagine",
    "start": "7520",
    "end": "13840"
  },
  {
    "text": "we use ebpf at polar signals and that's essentially why i'm here but the idea of this talk is to kind of",
    "start": "13840",
    "end": "22080"
  },
  {
    "text": "take this technology this hit that has been hyped over the last couple of years and see how we can",
    "start": "22080",
    "end": "29039"
  },
  {
    "text": "kind of connect it in a meaningful way to the cloud native ecosystem",
    "start": "29039",
    "end": "34160"
  },
  {
    "text": "to create some useful things so hopefully you'll walk out of this talk understanding ebpf a little bit",
    "start": "34160",
    "end": "41200"
  },
  {
    "text": "more understanding uh kind of the the state of development with ebpf a little bit",
    "start": "41200",
    "end": "47440"
  },
  {
    "text": "more and lastly um how to connect potential ebpf programs",
    "start": "47440",
    "end": "55039"
  },
  {
    "text": "with the kubernetes or cloud native ecosystem more broadly",
    "start": "55039",
    "end": "60320"
  },
  {
    "text": "and i'll show an example of what that could potentially look like so without further ado let's have",
    "start": "60320",
    "end": "68080"
  },
  {
    "start": "65000",
    "end": "566000"
  },
  {
    "text": "a really quick introduction to ebpf now this won't be completely",
    "start": "68080",
    "end": "73439"
  },
  {
    "text": "exhaustive of an explanation but i just want to lay a little bit of kind",
    "start": "73439",
    "end": "79119"
  },
  {
    "text": "of information down so that as we progress in the talk we have a foundation that we",
    "start": "79119",
    "end": "86400"
  },
  {
    "text": "can work off of so essentially what is ebpf ebpf",
    "start": "86400",
    "end": "93600"
  },
  {
    "text": "allows us to run certain programs in kernel space",
    "start": "93600",
    "end": "100400"
  },
  {
    "text": "and we can attach these programs to particular events or hooks so",
    "start": "100400",
    "end": "105920"
  },
  {
    "text": "some things that people may be familiar with are k-probes or u-probes essentially what you're saying is",
    "start": "105920",
    "end": "111840"
  },
  {
    "text": "you wanna run this program every time a particular thing happens in the kernel",
    "start": "111840",
    "end": "117280"
  },
  {
    "text": "for example a syscall gets executed and the reason why",
    "start": "117280",
    "end": "125118"
  },
  {
    "text": "we do this is so that we don't have this really expensive context",
    "start": "125840",
    "end": "133599"
  },
  {
    "text": "switch when we whenever we go from kernel space to user space this is a like widely known fact that this",
    "start": "133599",
    "end": "139840"
  },
  {
    "text": "transition is like something really expensive and",
    "start": "139840",
    "end": "145040"
  },
  {
    "text": "the reason why we're doing this as well ebpf or the kernel and the operating",
    "start": "145040",
    "end": "151040"
  },
  {
    "text": "system has traditionally always been a really great place to do observability security and networking",
    "start": "151040",
    "end": "158080"
  },
  {
    "text": "but uh the reason why ebpf was necessary here was that",
    "start": "158080",
    "end": "163519"
  },
  {
    "text": "with ebpf we can now have a really flexible development model where",
    "start": "163519",
    "end": "169519"
  },
  {
    "text": "we hot load this this code into the kernel and execute it as part of kernel space without having to you know load a",
    "start": "169519",
    "end": "177599"
  },
  {
    "text": "kernel module which we had to compile to a wide array wide array of",
    "start": "177599",
    "end": "183680"
  },
  {
    "text": "architectures and kernels and so on um and even even though it used to be really",
    "start": "183680",
    "end": "189920"
  },
  {
    "text": "hard some companies even still did that right like cystic started that way um",
    "start": "189920",
    "end": "196000"
  },
  {
    "text": "and um only eventually when ebpf came around uh adopted ebpf as a technology",
    "start": "196000",
    "end": "202000"
  },
  {
    "text": "so sometimes it was even then already worth it but with ebpf we're kind of um",
    "start": "202000",
    "end": "209120"
  },
  {
    "text": "supercharging this possibility and",
    "start": "209120",
    "end": "214720"
  },
  {
    "text": "i just want to give a really quick uh and it's really high level but a really quick overview of how",
    "start": "215680",
    "end": "221760"
  },
  {
    "text": "this actually works so ebpf as i said is kind of code that we can hot load into the kernel",
    "start": "221760",
    "end": "228560"
  },
  {
    "text": "and um it gets executed on hooks and if you're uh maybe new to this uh this",
    "start": "228560",
    "end": "236159"
  },
  {
    "text": "sounds kind of dangerous right like we're running something highly privileged in like with kernel",
    "start": "236159",
    "end": "241760"
  },
  {
    "text": "privileges effectively um in inside the kernel",
    "start": "241760",
    "end": "246959"
  },
  {
    "text": "and so something that was created in order to",
    "start": "246959",
    "end": "252720"
  },
  {
    "text": "allow this is a spec special just in time compiler uh that is part of the",
    "start": "252720",
    "end": "258239"
  },
  {
    "text": "kernel um that uh kind of transforms evpf code um like ebpf",
    "start": "258239",
    "end": "265199"
  },
  {
    "text": "bytecode to um actually executable code on that host",
    "start": "265199",
    "end": "270880"
  },
  {
    "text": "and before we even do that before we even kind of load this program we verify that it will actually halt and",
    "start": "270880",
    "end": "278560"
  },
  {
    "text": "in order to do this effectively we restrict what this code",
    "start": "278560",
    "end": "284479"
  },
  {
    "text": "can do if you maybe remember from [Music] computer science classes or if you've",
    "start": "284479",
    "end": "290479"
  },
  {
    "text": "kind of seen seen this particular class of problem called the whole halting problem it's actually kind of an",
    "start": "290479",
    "end": "296560"
  },
  {
    "text": "unsolvable problem without diving too much into it and",
    "start": "296560",
    "end": "301600"
  },
  {
    "text": "the way that evpf kind of makes this a solvable problem is by",
    "start": "301600",
    "end": "307759"
  },
  {
    "text": "reducing the things that the pro program can do and so things like endless loop",
    "start": "307759",
    "end": "313440"
  },
  {
    "text": "potentially endless loops or stuff like that are not allowed or it's everything in an ebpf program",
    "start": "313440",
    "end": "319919"
  },
  {
    "text": "essentially needs to be restricted in a way to make sure that it will actually hot and it will only",
    "start": "319919",
    "end": "326080"
  },
  {
    "text": "use a def predefined amount of memory now we can still do bad enough things that will crash a",
    "start": "326080",
    "end": "333039"
  },
  {
    "text": "kernel um or we'll crash a an operating system but um the point is",
    "start": "333039",
    "end": "338960"
  },
  {
    "text": "that we um can't essentially escape um",
    "start": "338960",
    "end": "344400"
  },
  {
    "text": "the the security boundaries and as we all know uh and as we probably some of you may have",
    "start": "344400",
    "end": "350320"
  },
  {
    "text": "heard this already even that's not entirely safe there have been bugs in the verifier they have been",
    "start": "350320",
    "end": "355600"
  },
  {
    "text": "bugs in various pieces of this so we're not totally safe but i guess that's the nature of all",
    "start": "355600",
    "end": "361600"
  },
  {
    "text": "programs but nevertheless this is still really really powerful and it's only getting",
    "start": "361600",
    "end": "368240"
  },
  {
    "text": "more traction um but uh going back to this once we've actually",
    "start": "368240",
    "end": "374160"
  },
  {
    "text": "loaded our ebpf programs and once they're executing on these hooks the way that we then communicate with our ebpf",
    "start": "374160",
    "end": "381520"
  },
  {
    "text": "program or from our ebpf program to user space where our like typical processes",
    "start": "381520",
    "end": "386720"
  },
  {
    "text": "are is through bpf maps and these are essentially",
    "start": "386720",
    "end": "393280"
  },
  {
    "text": "think of it as just kind of shared um spaces of memory that both the user",
    "start": "393280",
    "end": "398960"
  },
  {
    "text": "space program as well as the ebpf program program can write and read",
    "start": "398960",
    "end": "404080"
  },
  {
    "text": "from write to and read from and that's essentially all the moving pieces on",
    "start": "404080",
    "end": "409919"
  },
  {
    "text": "again a really high level but this is also where the problem kind of started in the",
    "start": "409919",
    "end": "416880"
  },
  {
    "text": "early days of evpf even though we are compiling our ebpf programs to this",
    "start": "416880",
    "end": "425039"
  },
  {
    "text": "generic bytecode there have been portability problems because even though this is just c code",
    "start": "425039",
    "end": "431360"
  },
  {
    "text": "that we're compiling to ebpf um bytecode",
    "start": "431360",
    "end": "438000"
  },
  {
    "text": "we still had to bring all the dependencies or we had to bring the kernel headers that we were going to",
    "start": "438000",
    "end": "444880"
  },
  {
    "text": "access because at the end of the day we're doing this to do something in the kernel right so most likely we're interested in",
    "start": "444880",
    "end": "451599"
  },
  {
    "text": "something in the kernel so we needed that those type of informations and so",
    "start": "451599",
    "end": "457599"
  },
  {
    "text": "the problem that this kind of created is that we either had to compile our ebpf",
    "start": "457599",
    "end": "463199"
  },
  {
    "text": "programs for all the possible kernels that we could think of that we would want to run our ebpf program on",
    "start": "463199",
    "end": "470800"
  },
  {
    "text": "or we needed to ship a c compiler with our",
    "start": "470800",
    "end": "475919"
  },
  {
    "text": "user space program that would compile the c code at startup",
    "start": "475919",
    "end": "481360"
  },
  {
    "text": "and and then essentially require the",
    "start": "481360",
    "end": "486879"
  },
  {
    "text": "the kernel headers to be present on that host so that we could be sure that",
    "start": "486879",
    "end": "492400"
  },
  {
    "text": "um kind of what we compiled is actually compatible with that host now that kind of brings multiple",
    "start": "492400",
    "end": "497840"
  },
  {
    "text": "problems with it we actually require the kernel headers to be present on that host",
    "start": "497840",
    "end": "504160"
  },
  {
    "text": "and ultimately that results in really large artifacts if we for example put all of",
    "start": "504160",
    "end": "510160"
  },
  {
    "text": "this into a container image that means that not only are we shipping our user space program we're also shipping",
    "start": "510160",
    "end": "517919"
  },
  {
    "text": "our c compiler so llvm for example and then not only that",
    "start": "517919",
    "end": "524080"
  },
  {
    "text": "we're also we also require to actually compile our program every time at startup right",
    "start": "524080",
    "end": "530240"
  },
  {
    "text": "or every time we create that container and aside from all of this being really",
    "start": "530240",
    "end": "535680"
  },
  {
    "text": "expensive it's kind of potentially dangerous right because what we're doing is we're taking some arbitrary",
    "start": "535680",
    "end": "542080"
  },
  {
    "text": "string that we're then compiling um and then putting into kernel space to be",
    "start": "542080",
    "end": "549760"
  },
  {
    "text": "executed right so you can imagine like even aside from potential",
    "start": "549760",
    "end": "554800"
  },
  {
    "text": "vulnerabilities in the kernel about this uh now we're adding a bunch of potential attack",
    "start": "554800",
    "end": "561680"
  },
  {
    "text": "surface in our program so this is obviously something that the the",
    "start": "561680",
    "end": "568320"
  },
  {
    "text": "community has worked on and i'm going to try to explain to you how the community",
    "start": "568320",
    "end": "574399"
  },
  {
    "text": "is has essentially solved this um again i'm i'm a user of this i didn't",
    "start": "574399",
    "end": "580320"
  },
  {
    "text": "create these mechanisms so i'm going to try to explain them in the best possible way from my experience",
    "start": "580320",
    "end": "586880"
  },
  {
    "text": "of using this and researching it and so on but essentially what the community",
    "start": "586880",
    "end": "592800"
  },
  {
    "text": "has come up with is the a combination of this bpf type format",
    "start": "592800",
    "end": "599120"
  },
  {
    "text": "and an overall initiative of that's called compile ones run everywhere kind",
    "start": "599120",
    "end": "604399"
  },
  {
    "text": "of the mantra of what we just talked about in terms of portability right the the goal of all of this is that we can",
    "start": "604399",
    "end": "611279"
  },
  {
    "text": "just compile this once on you know your my machine and then essentially run it on any",
    "start": "611279",
    "end": "617279"
  },
  {
    "text": "kernel that's that's the goal and so what the btf um the bpf type format essentially",
    "start": "617279",
    "end": "625839"
  },
  {
    "text": "is is it's a highly compressed version of the debug information so essentially",
    "start": "625839",
    "end": "631279"
  },
  {
    "text": "the all of the information that we need from kernel headers um and it puts that",
    "start": "631279",
    "end": "638640"
  },
  {
    "text": "by default into the kernel and so essentially what we're kind of removing in terms of requirements now is that the",
    "start": "638640",
    "end": "645040"
  },
  {
    "text": "kernel headers theoret interior at least all of the information is present on",
    "start": "645040",
    "end": "650720"
  },
  {
    "text": "every kernel um granted that they actually have uh",
    "start": "650720",
    "end": "657040"
  },
  {
    "text": "our new enough kernel to support this right and the way that we can think of this is",
    "start": "657040",
    "end": "663839"
  },
  {
    "text": "essentially that btf is kind of an abstraction on top of our",
    "start": "663839",
    "end": "670320"
  },
  {
    "text": "actual data structures right and that's kind of one piece of the puzzle and then the other piece of the",
    "start": "670320",
    "end": "675760"
  },
  {
    "text": "puzzle is this new library um called lib bpf so if you've heard of ebpf before",
    "start": "675760",
    "end": "683920"
  },
  {
    "text": "maybe you've heard of bcc the bpf compiler collection",
    "start": "683920",
    "end": "689839"
  },
  {
    "text": "this is essentially the next evolution of this and it works really closely with btf",
    "start": "689839",
    "end": "696959"
  },
  {
    "text": "and effectively what it does is when we load a an ebpf program on a",
    "start": "696959",
    "end": "704959"
  },
  {
    "text": "kernel that has btf enabled and the ebpf program was actually compiled with btf",
    "start": "704959",
    "end": "710320"
  },
  {
    "text": "support then it kind of rearranges and replaces the",
    "start": "710320",
    "end": "717040"
  },
  {
    "text": "kernel structs that the ebpf program was compiled with with the ones that are actually available on the host right and",
    "start": "717040",
    "end": "724160"
  },
  {
    "text": "there's a lot of really complicated like relocating stuff and kind of backward",
    "start": "724160",
    "end": "729440"
  },
  {
    "text": "compatibility stuff that's going on here um but essentially what we can um",
    "start": "729440",
    "end": "736240"
  },
  {
    "text": "the the thing that the thing that is important for us as users about this is that now if we use all of this we have",
    "start": "736240",
    "end": "743040"
  },
  {
    "text": "actually portable ebpf programs that we do not need to recompile when we start",
    "start": "743040",
    "end": "748880"
  },
  {
    "text": "um start our our user space program but we can truly um",
    "start": "748880",
    "end": "754399"
  },
  {
    "text": "compile once and run it everywhere so this is really",
    "start": "754399",
    "end": "759920"
  },
  {
    "text": "amazing and this is essentially possible um on i",
    "start": "759920",
    "end": "765519"
  },
  {
    "text": "think the the earliest things about btf landed in",
    "start": "765519",
    "end": "771040"
  },
  {
    "text": "the 4.4.18 kernel but effectively",
    "start": "771040",
    "end": "776160"
  },
  {
    "text": "if you actually want to make use of it the recommendation are",
    "start": "776160",
    "end": "781519"
  },
  {
    "text": "distributions of these versions or higher and essentially what we do is when we",
    "start": "781519",
    "end": "788320"
  },
  {
    "text": "compile our ebpf program we generate this stub essentially this vm linux.h",
    "start": "788320",
    "end": "794079"
  },
  {
    "text": "these are kind of our headers that we're compiling our ebpf program on you know",
    "start": "794079",
    "end": "800320"
  },
  {
    "text": "our machines with with ac compiler with target equals",
    "start": "800320",
    "end": "805440"
  },
  {
    "text": "bpf and when we then load it via lib bpf then",
    "start": "805440",
    "end": "811120"
  },
  {
    "text": "all of this gets rearranged and it actually works on that kernel so this is pretty magic and i'm thankful that all",
    "start": "811120",
    "end": "817440"
  },
  {
    "text": "of this work has been done by the community now we're at kubecon and pretty much",
    "start": "817440",
    "end": "825040"
  },
  {
    "text": "everything in in the cloud native ecosystem or at least predominantly things are written and go so",
    "start": "825040",
    "end": "832639"
  },
  {
    "text": "we at polar signals exclusively do go as well and so",
    "start": "832639",
    "end": "837680"
  },
  {
    "text": "we went on the lookout for if anyone has written a library like that and thankfully there was a start",
    "start": "837680",
    "end": "844720"
  },
  {
    "text": "written uh by aqua security um now uh this when we started uh working",
    "start": "844720",
    "end": "852160"
  },
  {
    "text": "with the akrasek people not everything that we needed was necessarily implemented but they had a",
    "start": "852160",
    "end": "858160"
  },
  {
    "text": "really awesome start so we contributed and a lot and it's been a really great",
    "start": "858160",
    "end": "863519"
  },
  {
    "text": "um collaboration and we hope to do a lot more together with them on this library",
    "start": "863519",
    "end": "869040"
  },
  {
    "text": "but let me give you a really quick intro [Music]",
    "start": "869040",
    "end": "874240"
  },
  {
    "text": "essentially lip bpf go is you know just like many other",
    "start": "874240",
    "end": "880639"
  },
  {
    "text": "c wrappers it's just a really thin wrapper around the c bindings",
    "start": "880639",
    "end": "887120"
  },
  {
    "text": "and then you know a thin layer of gold that essentially makes using all",
    "start": "887279",
    "end": "893360"
  },
  {
    "text": "of this go native and then uh to get kind of the entire",
    "start": "893360",
    "end": "898880"
  },
  {
    "text": "end-to-end experience we uh you know as we said before we pre-compile our ebpf",
    "start": "898880",
    "end": "904480"
  },
  {
    "text": "program using btf um and uh we embed that into our",
    "start": "904480",
    "end": "912160"
  },
  {
    "text": "resulting go binary using goes 1.16 built and embedding",
    "start": "912160",
    "end": "918079"
  },
  {
    "text": "functionality and if we now take all of this and statically link lip bpf",
    "start": "918079",
    "end": "923600"
  },
  {
    "text": "into our resulting binary we truly have an actually portable by ebpf",
    "start": "923600",
    "end": "930639"
  },
  {
    "text": "like user space program right and um our ebpf program embedded into this",
    "start": "930639",
    "end": "935680"
  },
  {
    "text": "so that we can then load it on any kernel so now we've achieved true",
    "start": "935680",
    "end": "941199"
  },
  {
    "text": "um kind of portability of both our user space programs",
    "start": "941199",
    "end": "946720"
  },
  {
    "text": "as well as our ebpf programs right so this is this is really awesome",
    "start": "946720",
    "end": "952560"
  },
  {
    "text": "just for the portability aspect but uh we have multiple other uh kind of",
    "start": "952560",
    "end": "957600"
  },
  {
    "text": "advantages from this strategy of course we don't need to ship a um",
    "start": "957600",
    "end": "964160"
  },
  {
    "text": "c compiler anymore we don't have to have you know the extra kernel header packages installed on our hosts",
    "start": "964160",
    "end": "972240"
  },
  {
    "text": "and maybe most importantly we have the comfort and safety of go so",
    "start": "972240",
    "end": "978399"
  },
  {
    "text": "that we can you know create programs that are memory safe",
    "start": "978399",
    "end": "983680"
  },
  {
    "text": "around our ebpf programs which by the way the verifier has been",
    "start": "983680",
    "end": "989120"
  },
  {
    "text": "tremendously helpful for us as well to make sure that the things that we're doing in c are actually safe so this is",
    "start": "989120",
    "end": "995279"
  },
  {
    "text": "a really cool combination so now i want to walk you through an actual example that we do at polar",
    "start": "995279",
    "end": "1002320"
  },
  {
    "start": "997000",
    "end": "1088000"
  },
  {
    "text": "signals so at polar signals we do continuous profiling and i won't go into too much",
    "start": "1002320",
    "end": "1008800"
  },
  {
    "text": "about this but essentially you can think of it as just normal cpu profiling",
    "start": "1008800",
    "end": "1014800"
  },
  {
    "text": "and so what is profiling essentially profiling is finding out what our",
    "start": "1014800",
    "end": "1021759"
  },
  {
    "text": "program is doing and we do that essentially by measuring",
    "start": "1021759",
    "end": "1027760"
  },
  {
    "text": "where cpu memory or io resources are being spent and this works by",
    "start": "1027760",
    "end": "1034000"
  },
  {
    "text": "kind of capturing the stack traces um",
    "start": "1034000",
    "end": "1039600"
  },
  {
    "text": "that our program is you know currently in a number of times per second so let's",
    "start": "1039600",
    "end": "1045438"
  },
  {
    "text": "say 100 times per second we're taking these member or cpu profiles",
    "start": "1045439",
    "end": "1052400"
  },
  {
    "text": "and if 10 of those observations were in one particular function well then we know um",
    "start": "1052400",
    "end": "1058240"
  },
  {
    "text": "statistically speaking 10 of our time was spent in this function and so effectively that's how",
    "start": "1058240",
    "end": "1065679"
  },
  {
    "text": "like sampling profiling of cpus works and then we typically",
    "start": "1065679",
    "end": "1072400"
  },
  {
    "text": "visualize them using something like flame graphs or icicle graphs that's what we call them when they are upside",
    "start": "1072400",
    "end": "1078400"
  },
  {
    "text": "down essentially or other visualizations but this is just a really super quick",
    "start": "1078400",
    "end": "1085760"
  },
  {
    "text": "intro to profiling in general and there is prior art for profiling in",
    "start": "1085760",
    "end": "1092840"
  },
  {
    "start": "1088000",
    "end": "1216000"
  },
  {
    "text": "linux so um there's it's not entirely new and i think this is also something",
    "start": "1092840",
    "end": "1098960"
  },
  {
    "text": "really important to understand about ebpf a lot of evpf is not necessarily something that's entirely new as i said",
    "start": "1098960",
    "end": "1106320"
  },
  {
    "text": "earlier there have been kernel modules around for similar things that we're doing with",
    "start": "1106320",
    "end": "1111760"
  },
  {
    "text": "ibpf today but just kind of um",
    "start": "1111760",
    "end": "1117120"
  },
  {
    "text": "like the hooks have always been there like k-probes have been there you probes have been there a lot of these things",
    "start": "1117120",
    "end": "1123039"
  },
  {
    "text": "have already been there but ebpf allows us to write really specific things that",
    "start": "1123039",
    "end": "1129120"
  },
  {
    "text": "now are also thanks to compile ones run everywhere portable to every kernel right and so",
    "start": "1129120",
    "end": "1135760"
  },
  {
    "text": "in linux there has for a while been the perf subsystem um there's kind of a lot of things uh",
    "start": "1135760",
    "end": "1143840"
  },
  {
    "text": "that are all called perf so there's the actual linux subsystem perf event and there's the user space tool to interact",
    "start": "1143840",
    "end": "1151360"
  },
  {
    "text": "with the subsystem essentially and do you know useful profiling things",
    "start": "1151360",
    "end": "1157600"
  },
  {
    "text": "and then there's the actual syscall called perf event open which",
    "start": "1157600",
    "end": "1163600"
  },
  {
    "text": "you can which essentially the perf user space tool uses and interacts with to do all",
    "start": "1163600",
    "end": "1169520"
  },
  {
    "text": "these useful things um and this is something that has existed i believe since the",
    "start": "1169520",
    "end": "1175600"
  },
  {
    "text": "since the linux 2.6 something so this has been around for a while",
    "start": "1175600",
    "end": "1181919"
  },
  {
    "text": "and this is one of the kind of tools and then another format that we really love at polar signals is",
    "start": "1181919",
    "end": "1188320"
  },
  {
    "text": "pprof pbrof is a standard of how you can represent stack traces and as i said",
    "start": "1188320",
    "end": "1196000"
  },
  {
    "text": "essentially profiles are nothing but observations of stack traces and prof is a format",
    "start": "1196000",
    "end": "1202000"
  },
  {
    "text": "in protobuf that represents stack prices in an optimized way essentially",
    "start": "1202000",
    "end": "1208960"
  },
  {
    "text": "um with all of its metadata that you actually need to you know make make",
    "start": "1208960",
    "end": "1214000"
  },
  {
    "text": "sense of the data ever afterwards so how do we actually build an ebpf",
    "start": "1214000",
    "end": "1220320"
  },
  {
    "start": "1216000",
    "end": "1378000"
  },
  {
    "text": "profiler and maybe even in go right because uh",
    "start": "1220320",
    "end": "1226240"
  },
  {
    "text": "as i said at polar signals everything we do is go so we use the bpf go and this",
    "start": "1226240",
    "end": "1231760"
  },
  {
    "text": "is actually one of those things that we implemented in libby pf go",
    "start": "1231760",
    "end": "1236880"
  },
  {
    "text": "when we started the aquasec folks didn't really have a use case for profiling so they had",
    "start": "1236880",
    "end": "1244080"
  },
  {
    "text": "never implemented this particular syscall that was required",
    "start": "1244080",
    "end": "1249360"
  },
  {
    "text": "sorry not cisco this particular function in libpf called attach perf event",
    "start": "1249360",
    "end": "1256559"
  },
  {
    "text": "because they just had no need for it but kind of this is the awesome thing about a community they had implemented",
    "start": "1256559",
    "end": "1263840"
  },
  {
    "text": "large other parts of the bpf go wrapper and we just had to go in and do a couple",
    "start": "1263840",
    "end": "1270559"
  },
  {
    "text": "of these contributions and you know everybody kind of profited from that but",
    "start": "1270559",
    "end": "1276400"
  },
  {
    "text": "effectively on a high level how our ebpf profiler works is that we",
    "start": "1276400",
    "end": "1282080"
  },
  {
    "text": "have a c group because remember containers essentially are nothing other",
    "start": "1282080",
    "end": "1288320"
  },
  {
    "text": "than c groups and name spaces these are two kind of mechanisms of",
    "start": "1288320",
    "end": "1294799"
  },
  {
    "text": "of the linux kernel c groups allow us to",
    "start": "1294799",
    "end": "1300480"
  },
  {
    "text": "to limit how much resources um a set of processes can",
    "start": "1301120",
    "end": "1307120"
  },
  {
    "text": "use and namespaces are essentially to limit how much they can see",
    "start": "1307120",
    "end": "1313440"
  },
  {
    "text": "and so together these essentially make up what we usually refer to as containers and so if we want to profile",
    "start": "1313440",
    "end": "1320720"
  },
  {
    "text": "a container we need to just understand which c group we want to profile",
    "start": "1320720",
    "end": "1325919"
  },
  {
    "text": "and so we essentially assume in this case that we already have our c group",
    "start": "1325919",
    "end": "1332400"
  },
  {
    "text": "and we open a perf event on this c group and we tell it the frequency so as i said earlier let's say",
    "start": "1332400",
    "end": "1338960"
  },
  {
    "text": "100 times per second we want to get an event from this right and what we then do is we get a file",
    "start": "1338960",
    "end": "1346720"
  },
  {
    "text": "descriptor back from this perf event and we pass that file descriptor into",
    "start": "1346720",
    "end": "1353760"
  },
  {
    "text": "attaching our ebpf program to this event right so now what we've essentially done with",
    "start": "1353760",
    "end": "1359919"
  },
  {
    "text": "these two things is that we've created a perv event that triggers 100 times per",
    "start": "1359919",
    "end": "1365280"
  },
  {
    "text": "second let's say and we have told it that it should run",
    "start": "1365280",
    "end": "1370799"
  },
  {
    "text": "our ebpf program every time this event fires and so now all that we essentially need to do",
    "start": "1370799",
    "end": "1378159"
  },
  {
    "text": "in our ebpf program is um we grab the stack traces",
    "start": "1378159",
    "end": "1385360"
  },
  {
    "text": "at that point in time right we see uh let's walk through it for",
    "start": "1385360",
    "end": "1391600"
  },
  {
    "text": "one of those events triggering right the first thing we do is we read the process id",
    "start": "1391600",
    "end": "1397440"
  },
  {
    "text": "that the stack trace is from then we retrieve the user space stack so",
    "start": "1397440",
    "end": "1403200"
  },
  {
    "text": "essentially what is happening in the user space program then what is the kernel space stack and then",
    "start": "1403200",
    "end": "1409760"
  },
  {
    "text": "we take all of this and we put it into our ebpf maps and we have two maps in",
    "start": "1409760",
    "end": "1415120"
  },
  {
    "text": "this case one map just to identify our stack traces so there's an id for our",
    "start": "1415120",
    "end": "1421440"
  },
  {
    "text": "stack traces and they're the actual memory addresses that you know make up this uh the stack trace because",
    "start": "1421440",
    "end": "1428720"
  },
  {
    "text": "in the case of native binaries so like compiled languages like go rust c plus",
    "start": "1428720",
    "end": "1434720"
  },
  {
    "text": "it's truly that representation of the memory addresses that map back to our",
    "start": "1434720",
    "end": "1440640"
  },
  {
    "text": "actual binary and that's how we can at the end make sense of what is being executed",
    "start": "1440640",
    "end": "1446000"
  },
  {
    "text": "so that's our first ebpf map and then our second eppf map is essentially that",
    "start": "1446000",
    "end": "1451039"
  },
  {
    "text": "triple of process id user space stack and kernel",
    "start": "1451039",
    "end": "1456480"
  },
  {
    "text": "stack that is kind of the unique identifier for this stack trace right it's the",
    "start": "1456480",
    "end": "1463679"
  },
  {
    "text": "process the stack within that process and the stack within the kernel",
    "start": "1463679",
    "end": "1469360"
  },
  {
    "text": "and then we say how often have we seen this particular",
    "start": "1469360",
    "end": "1474480"
  },
  {
    "text": "this particular combination and this is all the information that we",
    "start": "1475039",
    "end": "1480080"
  },
  {
    "text": "need to build a cpu profile and so all our users space program at the top here",
    "start": "1480080",
    "end": "1486400"
  },
  {
    "text": "needs to do every 10 seconds it just takes all of the data from these ebpf maps",
    "start": "1486400",
    "end": "1492960"
  },
  {
    "text": "puts them into a format that our tools understand in this case we chose",
    "start": "1492960",
    "end": "1499360"
  },
  {
    "text": "to do pprov and then we can just throw away all of the data and do it again in 10 seconds",
    "start": "1499360",
    "end": "1505279"
  },
  {
    "text": "after you know the avpf program has filled up our ebpf maps again",
    "start": "1505279",
    "end": "1511200"
  },
  {
    "start": "1510000",
    "end": "1648000"
  },
  {
    "text": "so let's have a look at a little bit",
    "start": "1511200",
    "end": "1517120"
  },
  {
    "text": "simplified version of this ebpf program so at the very top we see this",
    "start": "1517120",
    "end": "1523200"
  },
  {
    "text": "key that i was talking about right we have our process id we have our user space stack id our kernel space stack id",
    "start": "1523200",
    "end": "1531279"
  },
  {
    "text": "then what we're doing is we're defining our two ebpf maps",
    "start": "1531279",
    "end": "1537039"
  },
  {
    "text": "now there are some helper functions that i omitted here but essentially what we're doing is we're",
    "start": "1537039",
    "end": "1545278"
  },
  {
    "text": "defining a map where we have our key from above as the key",
    "start": "1545440",
    "end": "1552880"
  },
  {
    "text": "and then u and 64. so just literally our count that we are going to keep",
    "start": "1552880",
    "end": "1558640"
  },
  {
    "text": "incrementing and then we have a map of stack traces and this is kind of a built-in type in",
    "start": "1558640",
    "end": "1565279"
  },
  {
    "text": "ebpf and we just say we have stack traces in",
    "start": "1565279",
    "end": "1570480"
  },
  {
    "text": "this map and our stack traces are allowed to be this max stack addresses",
    "start": "1570480",
    "end": "1577440"
  },
  {
    "text": "long because as i said in the beginning ebpf cares a lot about everything being",
    "start": "1577440",
    "end": "1585440"
  },
  {
    "text": "limited to some to some degree right so that we can be sure within these",
    "start": "1585440",
    "end": "1590480"
  },
  {
    "text": "parameters the ebpf program will succeed and will halt and then",
    "start": "1590480",
    "end": "1596640"
  },
  {
    "text": "the function that we have defined here is literally what's going to be executed whenever that",
    "start": "1596640",
    "end": "1603360"
  },
  {
    "text": "that event triggers so first we retrieve our process id we put that process id as the first",
    "start": "1603919",
    "end": "1611919"
  },
  {
    "text": "field into our key we then retrieve our stack",
    "start": "1611919",
    "end": "1617840"
  },
  {
    "text": "our user space stack id then our kernel space stack id and then we take this key",
    "start": "1618000",
    "end": "1623279"
  },
  {
    "text": "we look it up in our counts map right if it exists",
    "start": "1623279",
    "end": "1630000"
  },
  {
    "text": "we we just take the count that we already have if not we initialize it and then we do an atomic increment on that",
    "start": "1630000",
    "end": "1637520"
  },
  {
    "text": "on that number and that's really it right like that's all we're doing",
    "start": "1637520",
    "end": "1643120"
  },
  {
    "text": "i i simplified this a little bit but effectively this is what we do",
    "start": "1643120",
    "end": "1649440"
  },
  {
    "start": "1648000",
    "end": "1788000"
  },
  {
    "text": "now i said earlier and i simplified that all we needed was",
    "start": "1649440",
    "end": "1654960"
  },
  {
    "text": "the c group right because all that containers are are c groups and",
    "start": "1654960",
    "end": "1661120"
  },
  {
    "text": "namespaces now how do we actually find",
    "start": "1661120",
    "end": "1667279"
  },
  {
    "text": "the c group right we we you may know uh in kubernetes we have",
    "start": "1667279",
    "end": "1672720"
  },
  {
    "text": "the concept of pods and there can be multiple containers in a pod and so we",
    "start": "1672720",
    "end": "1677919"
  },
  {
    "text": "have all of this metadata in the kubernetes api so it must be possible to get the right",
    "start": "1677919",
    "end": "1684240"
  },
  {
    "text": "c group for the right container right and it turns out when we have the",
    "start": "1684240",
    "end": "1689760"
  },
  {
    "text": "process id this is actually fairly simple the procfss actually has all of this",
    "start": "1689760",
    "end": "1695679"
  },
  {
    "text": "information and can tell us all of this information and when i was researching this i was",
    "start": "1695679",
    "end": "1702640"
  },
  {
    "text": "like wait a minute there is a tool that abstracts container runtimes and",
    "start": "1702640",
    "end": "1708240"
  },
  {
    "text": "i'm sure this tool would be able to help me with this however the problem is",
    "start": "1708240",
    "end": "1714799"
  },
  {
    "text": "even though it's called container runtime interface cri it's not actually specific to running",
    "start": "1714799",
    "end": "1722159"
  },
  {
    "text": "linux containers what it does is it abstracts away sandboxing and so the reason why this",
    "start": "1722159",
    "end": "1729440"
  },
  {
    "text": "was done is so that we can have hypervisors like virtual machines instead of containers",
    "start": "1729440",
    "end": "1736240"
  },
  {
    "text": "and so that's why there's actually no first class support for process ids because we're",
    "start": "1736240",
    "end": "1742080"
  },
  {
    "text": "not actually a hundred percent certain that there is going to be a process id involved here right",
    "start": "1742080",
    "end": "1748559"
  },
  {
    "text": "so this left us in this somewhat unfortunate situation where the only thing that",
    "start": "1748559",
    "end": "1756080"
  },
  {
    "text": "the cri has specified is this kind of additional information",
    "start": "1756080",
    "end": "1761279"
  },
  {
    "text": "map of strings to strings where the container runtime is",
    "start": "1761279",
    "end": "1766480"
  },
  {
    "text": "recommended to put the process id into",
    "start": "1766480",
    "end": "1771360"
  },
  {
    "text": "now this is really precisely specified right well no it's really really not and the",
    "start": "1772240",
    "end": "1780080"
  },
  {
    "text": "unfortunately because it's so vaguely specified uh that's kind of what it resulted in in container runtimes as",
    "start": "1780080",
    "end": "1787760"
  },
  {
    "text": "well and so even though there's this recommendation unfortunately each every cri that we've",
    "start": "1787760",
    "end": "1795039"
  },
  {
    "start": "1788000",
    "end": "1861000"
  },
  {
    "text": "worked with so far behaves very subtly different um",
    "start": "1795039",
    "end": "1800320"
  },
  {
    "text": "and so just a couple of examples here uh cryo uh a container runtime that was",
    "start": "1800320",
    "end": "1806799"
  },
  {
    "text": "specifically designed for the cri standard specification",
    "start": "1806799",
    "end": "1812559"
  },
  {
    "text": "has the string key info in the info field that is a json object that has",
    "start": "1812559",
    "end": "1819360"
  },
  {
    "text": "pid as a field that then actually contains the process id docker actually asks you to use the",
    "start": "1819360",
    "end": "1826399"
  },
  {
    "text": "docker api to to retrieve this and the docker api has this because docker is",
    "start": "1826399",
    "end": "1831600"
  },
  {
    "text": "actually specific to linux containers right so this is kind of cool however it's not the cri",
    "start": "1831600",
    "end": "1838720"
  },
  {
    "text": "and then container d is kind of similar to cryo except that there isn't an entire json object in",
    "start": "1838720",
    "end": "1845360"
  },
  {
    "text": "there there's just a string that is an integer and you need to parse it to be the process id",
    "start": "1845360",
    "end": "1852640"
  },
  {
    "text": "and then this is essentially what you need to do to find the process id for each individual container",
    "start": "1852640",
    "end": "1859600"
  },
  {
    "text": "in kubernetes and this was a little bit painful but you",
    "start": "1859600",
    "end": "1864799"
  },
  {
    "start": "1861000",
    "end": "2030000"
  },
  {
    "text": "know after implementing all of it it does work um although it would have been nice if there was something a little bit more",
    "start": "1864799",
    "end": "1870880"
  },
  {
    "text": "specified so if we now put all of this together we can retrieve the containers that are",
    "start": "1870880",
    "end": "1877440"
  },
  {
    "text": "running on a host from the kubernetes api we can figure out uh through the cri and",
    "start": "1877440",
    "end": "1884799"
  },
  {
    "text": "through all of what we just talked about we can figure out the actual c group from that container",
    "start": "1884799",
    "end": "1891440"
  },
  {
    "text": "we can attach our ebpf program to that c group and then we can",
    "start": "1891440",
    "end": "1896640"
  },
  {
    "text": "go through what we talked about earlier we wait 10 seconds for our bpf program",
    "start": "1896640",
    "end": "1902159"
  },
  {
    "text": "to fill up the maps we can then read all of this information we can transform it",
    "start": "1902159",
    "end": "1907440"
  },
  {
    "text": "to the ppra format that we know and love and then at this point we can send this",
    "start": "1907440",
    "end": "1913840"
  },
  {
    "text": "data away to a remote location um or we can save it to a file or something right",
    "start": "1913840",
    "end": "1919039"
  },
  {
    "text": "but um then we can just clear all of this data and you know until eternity do this um",
    "start": "1919039",
    "end": "1925840"
  },
  {
    "text": "again wait for 10 seconds transform it to p profit and so on and so now what",
    "start": "1925840",
    "end": "1931360"
  },
  {
    "text": "we've essentially implemented is a really low overhead cpu profiler in ebpf",
    "start": "1931360",
    "end": "1939279"
  },
  {
    "text": "and the reason why this is really cool is using ebpf we can do this with extremely",
    "start": "1939279",
    "end": "1944559"
  },
  {
    "text": "low overhead because we can already save this data in our maps in a way that is",
    "start": "1944559",
    "end": "1951039"
  },
  {
    "text": "useful in our ppr format and that way we can create something that can just",
    "start": "1951039",
    "end": "1957600"
  },
  {
    "text": "always be on and always be profiling all of our containers and this is exactly what we did at polar signals",
    "start": "1957600",
    "end": "1964080"
  },
  {
    "text": "and open sourced as a an open source project called parka agent as part of the wider parka",
    "start": "1964080",
    "end": "1970320"
  },
  {
    "text": "project which essentially is a storage for profiling data it's also open source and so",
    "start": "1970320",
    "end": "1977279"
  },
  {
    "text": "um i encourage you to try out this project but um even even if not i hope you enjoyed this",
    "start": "1977279",
    "end": "1985360"
  },
  {
    "text": "this talk and i hope you learned something about how you can make use of ebpf",
    "start": "1985360",
    "end": "1990880"
  },
  {
    "text": "how you can create portable programs with ebpf how you can make use of it from go",
    "start": "1990880",
    "end": "1996880"
  },
  {
    "text": "and ultimately how you could maybe put some of these things together and even connect it to the wider cloud native",
    "start": "1996880",
    "end": "2003679"
  },
  {
    "text": "ecosystem if you're interested in checking out some of this check out the website or if you're interested in the",
    "start": "2003679",
    "end": "2008880"
  },
  {
    "text": "profiling storage we have a talk by my colleagues matthias and kamal as",
    "start": "2008880",
    "end": "2014559"
  },
  {
    "text": "well about this and if you have any questions feel free to reach out",
    "start": "2014559",
    "end": "2019919"
  },
  {
    "text": "via email or twitter and if you're interested at all in any of these topics we are hiring so",
    "start": "2019919",
    "end": "2026000"
  },
  {
    "text": "feel free to reach out for that as well thank you so much",
    "start": "2026000",
    "end": "2031240"
  }
]