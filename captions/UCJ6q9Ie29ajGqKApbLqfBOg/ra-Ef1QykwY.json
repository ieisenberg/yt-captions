[
  {
    "text": "hello everyone so welcome to my talk all your secrets belong to us leveraging firmware bucks to break tees little bit",
    "start": "3240",
    "end": "10080"
  },
  {
    "text": "about me my name is Tom dman I love doing lowl stuff so if I have a chance to talk directly to the hardware that's",
    "start": "10080",
    "end": "15480"
  },
  {
    "text": "I want what I want to do I really enjoy writing code but I also enjoy breaking code and today we'll mostly be doing the",
    "start": "15480",
    "end": "21480"
  },
  {
    "text": "letter okay so what will we be talking about today um first off we'll give give",
    "start": "21480",
    "end": "27359"
  },
  {
    "text": "a little bit of an introduction about what a te is any way um then we'll talk about one specific implementation um the",
    "start": "27359",
    "end": "33719"
  },
  {
    "text": "one by AMD which is called amdv S&P um then we'll talk about some of the implementation details that we need to",
    "start": "33719",
    "end": "40079"
  },
  {
    "text": "understand the bucks um then we actually talk about our first bug then we'll talk about the maybe most obvious but not",
    "start": "40079",
    "end": "46199"
  },
  {
    "text": "necessarily best way to exploit such a bug um then we'll come up with an even better way um to exploit this bug then",
    "start": "46199",
    "end": "53480"
  },
  {
    "text": "we'll talk about a second Buck then we'll also talk about how to exploit that one and in the end we'll have some rep up and takeaways",
    "start": "53480",
    "end": "61480"
  },
  {
    "text": "so what is a te anyway te stands for trusted execution environment the basic",
    "start": "61480",
    "end": "67320"
  },
  {
    "text": "idea is to have a secure part of the main processor where applications can run securely even if other parts of the",
    "start": "67320",
    "end": "73240"
  },
  {
    "text": "software stack have been compromised notably this also includes the kernel or the hypervisor so even if either of",
    "start": "73240",
    "end": "79840"
  },
  {
    "text": "those have been compromised the application should still run securely and so this threat model is",
    "start": "79840",
    "end": "87079"
  },
  {
    "text": "also very different compared to a lot of other applications for tees the main threat really is leakage of secrets so",
    "start": "87079",
    "end": "93360"
  },
  {
    "text": "if you have an info leak this is pretty much as bad as it gets the reason for that is that once you have the secrets",
    "start": "93360",
    "end": "98759"
  },
  {
    "text": "you can impersonate impersonate the te and you can just run the application outside of the te where it's not",
    "start": "98759",
    "end": "104680"
  },
  {
    "text": "protected and so of course if you can achieve arbitrary code execution that's one way of getting the secrets out but",
    "start": "104680",
    "end": "110719"
  },
  {
    "text": "really the the main part that you want to protect is the secrets there are a lot of different",
    "start": "110719",
    "end": "116479"
  },
  {
    "text": "implementations by a lot of different Hardware renders um some of them are a bit older but some of them are also",
    "start": "116479",
    "end": "121520"
  },
  {
    "text": "quite new um and that's what why there's also another talk um so today we'll just talk about amdv but later this afternoon",
    "start": "121520",
    "end": "129080"
  },
  {
    "text": "there's also another talk about Intel TDX um so maybe if you enjoy this talk you might also want to check out that",
    "start": "129080",
    "end": "134160"
  },
  {
    "text": "other talk okay but as I said for today we'll just focus on AMD SCV S&P um so",
    "start": "134160",
    "end": "141200"
  },
  {
    "text": "obviously this technology implements at te and SCV stands for secure enry",
    "start": "141200",
    "end": "146319"
  },
  {
    "text": "encrypted virtualization and from this you can already gather that the whole point of this is to protect entire",
    "start": "146319",
    "end": "152400"
  },
  {
    "text": "virtual machines from a potentially malicious hypervisor and so the way this works",
    "start": "152400",
    "end": "158120"
  },
  {
    "text": "with conventional VMS is that the hypervisor has access to all of the memory that's owned by the VM however",
    "start": "158120",
    "end": "164239"
  },
  {
    "text": "amdv S&P actually implements a hardware extension directly in the CPU that makes",
    "start": "164239",
    "end": "169959"
  },
  {
    "text": "sure that all of the memory that's owned by the VM is first of all encrypted so that the hypervisor can't just read the",
    "start": "169959",
    "end": "175400"
  },
  {
    "text": "secrets but all of the memory is also Integrity protected and yeah that's way the hypervisor can't temper with the",
    "start": "175400",
    "end": "182120"
  },
  {
    "text": "guest like it would could potentially do with a regular VM and what's also",
    "start": "182120",
    "end": "187360"
  },
  {
    "text": "interesting is that when the VM is first booted up all of the memory contracts are actually measured and then later",
    "start": "187360",
    "end": "192480"
  },
  {
    "text": "those can be attested through attestation reports so if you're familiar with TPMS the basic idea is the",
    "start": "192480",
    "end": "197519"
  },
  {
    "text": "same um while this platform is or the operating system is booted up you load",
    "start": "197519",
    "end": "203080"
  },
  {
    "text": "in all of the additional code and in the end you can remotely attest that okay so um let's actually talk",
    "start": "203080",
    "end": "211000"
  },
  {
    "text": "about a little bit about how thises this actually implemented and the first thing we have to talk about is the platform security processor so the platform",
    "start": "211000",
    "end": "217519"
  },
  {
    "text": "security processor actually exists on all AMD CPUs it exists outside of the context for SCV and and it's responsible",
    "start": "217519",
    "end": "224560"
  },
  {
    "text": "for a lot of stuff during early boot stuff so for example before the x86 course even start running um the PSP is",
    "start": "224560",
    "end": "230959"
  },
  {
    "text": "already running and doing like a lot lot of a lot of setup and in order to get the machine to boot so if you're",
    "start": "230959",
    "end": "237400"
  },
  {
    "text": "familiar with intell management engine this is sort of the same thing but for AMD um however uh in order to do all of",
    "start": "237400",
    "end": "245280"
  },
  {
    "text": "that things all of those things the PSP needs to be very privileged and this is also why it's uh very natural for the",
    "start": "245280",
    "end": "252760"
  },
  {
    "text": "PSP to also play an important role in SCV um so basically the way you can think of it is that the CPU itself can",
    "start": "252760",
    "end": "259759"
  },
  {
    "text": "run the virtual machines but for everything but running the virtual machines you need the PSP so notably",
    "start": "259759",
    "end": "265400"
  },
  {
    "text": "this includes a lot of management stuff so if you want to create the VM if you want to delete the M um but also if you",
    "start": "265400",
    "end": "271039"
  },
  {
    "text": "want to like attest the VM you need the PSP to do that and so the PSP also holds a lot of the cryptographic material that",
    "start": "271039",
    "end": "277800"
  },
  {
    "text": "that's actually used to uh securely attest the VT uh the VM um today we'll",
    "start": "277800",
    "end": "284400"
  },
  {
    "text": "just be talking about SCV S&P but there have actually been two other Breer Technologies and those actually use the",
    "start": "284400",
    "end": "290440"
  },
  {
    "text": "same firmware because even though there are a lot of big differences they also share a lot and that's why the same",
    "start": "290440",
    "end": "295759"
  },
  {
    "text": "frameware is used what's really interesting though is that at the end of last August AMD actually published large",
    "start": "295759",
    "end": "302039"
  },
  {
    "text": "parts of this firmware and this is what first uh this was the first time that a lot of researchers like me could",
    "start": "302039",
    "end": "307919"
  },
  {
    "text": "actually take a look at the firmware and uh yeah verify those claims made by",
    "start": "307919",
    "end": "315240"
  },
  {
    "text": "IMD okay so next up we'll talk about the reverse map table so I already told you",
    "start": "315240",
    "end": "321440"
  },
  {
    "text": "that all of the memory is integrity protected and it's also encrypted and for now we'll just talk about the",
    "start": "321440",
    "end": "326479"
  },
  {
    "text": "Integrity protection part and we'll talk about the encryption later but yeah so the reverse map table is really",
    "start": "326479",
    "end": "333960"
  },
  {
    "text": "large table that is used to track the ownership state of every 4 kiloby chunk of memory on the system the basic idea",
    "start": "333960",
    "end": "341319"
  },
  {
    "text": "is that most memory starts out as being owned by the hypervisor but as the hypervisor wants to launch different VMS",
    "start": "341319",
    "end": "347479"
  },
  {
    "text": "it can actually assign memory to those VMS by changing the rmp to reflect that",
    "start": "347479",
    "end": "353120"
  },
  {
    "text": "and then for every single right to memory the CPU internally checks the rmp",
    "start": "353120",
    "end": "359000"
  },
  {
    "text": "to make sure that that the entity that is currently running is actually an entity that owns that memory and so this",
    "start": "359000",
    "end": "364120"
  },
  {
    "text": "all is done to make sure that yeah no memory um is written to by the hypervisor to a guest that doesn't yeah",
    "start": "364120",
    "end": "371759"
  },
  {
    "text": "so yeah also a guest can't write to another guest's memory so that this is",
    "start": "371759",
    "end": "377120"
  },
  {
    "text": "also tracked in the rmp interestingly for the CPU this happens automatically",
    "start": "377120",
    "end": "382599"
  },
  {
    "text": "for all access levels however for the firmware this is not always the case the reason for that is that as I already",
    "start": "382599",
    "end": "388160"
  },
  {
    "text": "mentioned in the beginning the PSP is very privileged and so in principle it can write to any me memory it wants",
    "start": "388160",
    "end": "394520"
  },
  {
    "text": "however in practice um the PSP actually does a lot of access checks um to make sure that the PSP also only rights to",
    "start": "394520",
    "end": "400840"
  },
  {
    "text": "memory that it owns So memory can not only be owned by the hypervisor or by the firmware some memory memory is also",
    "start": "400840",
    "end": "407240"
  },
  {
    "text": "actually owned by the firmware and so the firmware also does those checks at this point you might be asking",
    "start": "407240",
    "end": "413199"
  },
  {
    "text": "how is this r&p actually managed there are two ways to do that the first one is for the most simple and obvious cases",
    "start": "413199",
    "end": "420160"
  },
  {
    "text": "um this is actually done using special CPU instructions so for example if the hypervisor wants to assign some memory",
    "start": "420160",
    "end": "425639"
  },
  {
    "text": "to a guest this is fairly straightforward and so there's a very simple CPU instruction to do that um",
    "start": "425639",
    "end": "431160"
  },
  {
    "text": "however for more complicated stuff like um if you want to do memory swapping or if you want to move memory around you",
    "start": "431160",
    "end": "436680"
  },
  {
    "text": "actually need the SCV firmware for that so that it can handle some of those more complex cases and so in the end um a lot of",
    "start": "436680",
    "end": "443319"
  },
  {
    "text": "sensitive information that shouldn't be tampered with is actually stored in just regular memory that is protected by the",
    "start": "443319",
    "end": "448879"
  },
  {
    "text": "rmp and so this whole system also places a lot of trust into the r&p checks um",
    "start": "448879",
    "end": "454479"
  },
  {
    "text": "being enforced correctly and this is also where where things will go wrong today um and we we'll see where that",
    "start": "454479",
    "end": "460759"
  },
  {
    "text": "leads to okay um just another quick",
    "start": "460759",
    "end": "465879"
  },
  {
    "text": "visualization on the right hand on the right hand you can see a lot of uh different memory chunks and on the left",
    "start": "465879",
    "end": "471520"
  },
  {
    "text": "hand you can see uh the r&p um so the rmp tracks um the ownership state for",
    "start": "471520",
    "end": "477520"
  },
  {
    "text": "every chunk of memory in practice chunks are usually a lot smaller but doesn't really matter um so you can see most",
    "start": "477520",
    "end": "483599"
  },
  {
    "text": "memory is owned by the hypervisor some of this is owned by different guests and some of it is actually owned by the firmware interestingly though because",
    "start": "483599",
    "end": "490840"
  },
  {
    "text": "the rmp is just stored in regular memory um the rmp itself um also has an r&p",
    "start": "490840",
    "end": "496199"
  },
  {
    "text": "entry and this is actually a really good example for memory that's owned by the firmware um the reason that it's owned",
    "start": "496199",
    "end": "501520"
  },
  {
    "text": "by the firmware is that we don't want the hypervisor or the guest to directly write to the r&p we only want to allow",
    "start": "501520",
    "end": "507120"
  },
  {
    "text": "accesses using those special CPU instructions and we want to forid forbid all other right",
    "start": "507120",
    "end": "513800"
  },
  {
    "text": "accesses okay and so with that we actually have all the necessary prerequisites to talk about our first",
    "start": "513800",
    "end": "519200"
  },
  {
    "text": "buck and okay so let's do that so this first buck is related to command",
    "start": "519200",
    "end": "525160"
  },
  {
    "text": "dispatch um as you might remember um the hypervisor asks the firmware to do a lot",
    "start": "525160",
    "end": "530680"
  },
  {
    "text": "of stuff on its behalf that it can do using CPU instructions and it obviously needs some way to tell the firmware what",
    "start": "530680",
    "end": "536519"
  },
  {
    "text": "to do and so we briefly work how we will we briefly walk through how that works",
    "start": "536519",
    "end": "541640"
  },
  {
    "text": "so the first step is that the hypervisor actually writ writes the request somewhere to memory that is owned by",
    "start": "541640",
    "end": "547000"
  },
  {
    "text": "itself immediately after writing that request the hypervisor then donates that page to the firmware it does that using",
    "start": "547000",
    "end": "553680"
  },
  {
    "text": "one of those special CPU instructions that can be used to change the r&p the hypervisor then tells the",
    "start": "553680",
    "end": "559480"
  },
  {
    "text": "firmware about that request the firmware reads the request executes it and writes",
    "start": "559480",
    "end": "564519"
  },
  {
    "text": "it back um at this point the firmware tells the hypervisor that it's done processing the hypervisor reads back the",
    "start": "564519",
    "end": "570440"
  },
  {
    "text": "response and the last step is that the hypervisor asks the firmware to reclaim that page so that we don't just leak out",
    "start": "570440",
    "end": "576640"
  },
  {
    "text": "a page to the firmware state for every request and so the long story short is that just commands and requests are just",
    "start": "576640",
    "end": "583600"
  },
  {
    "text": "written to regular memory however there's one thing that's sort of important which is that during step six",
    "start": "583600",
    "end": "589440"
  },
  {
    "text": "the firmware really needs to make sure that the memory is actually owned by itself um because once again every",
    "start": "589440",
    "end": "594839"
  },
  {
    "text": "entity is only allowed to write to memory that is owned by itself okay so this is all very nice um however",
    "start": "594839",
    "end": "603360"
  },
  {
    "text": "it turns out there are actually a lot of commands that just don't have a response the firmware has nothing important to",
    "start": "603360",
    "end": "609600"
  },
  {
    "text": "report back and so this allows us to skip a few steps um so the first step is just like regular the hyper buer still",
    "start": "609600",
    "end": "616920"
  },
  {
    "text": "writes the request to that memory location um however then it doesn't need to donate the page to the firmware St",
    "start": "616920",
    "end": "623680"
  },
  {
    "text": "State we'll see in a second why it doesn't need to do that um most of the stuff continues like normal um until the",
    "start": "623680",
    "end": "630000"
  },
  {
    "text": "firmware processes the respon respon request but then importantly the",
    "start": "630000",
    "end": "635600"
  },
  {
    "text": "hypervisor the firmware doesn't write back a response that's sort of the whole point for some commands you just don't have a response and so you don't need to",
    "start": "635600",
    "end": "642200"
  },
  {
    "text": "to write back a response and that's also why the page never had to be donated to the firmware in the first place the",
    "start": "642200",
    "end": "648200"
  },
  {
    "text": "firmware never does a right to it and so the firmware doesn't need to own that memory okay and so most of the other",
    "start": "648200",
    "end": "654600"
  },
  {
    "text": "stuff is like normal um hypervisor obviously doesn't need to read your response back and it also doesn't need to reclaim the page and so in the end",
    "start": "654600",
    "end": "661079"
  },
  {
    "text": "this is a really nice optimization that allows us to skip four of the nine steps and yeah g gain some nice performance",
    "start": "661079",
    "end": "668600"
  },
  {
    "text": "improvements and so the conclusion from this is that well it's a bit complicated in some cases the firmware actually",
    "start": "668600",
    "end": "675040"
  },
  {
    "text": "needs to check that it owns that memory and in some cases it doesn't it really depends on the command and the way this",
    "start": "675040",
    "end": "681600"
  },
  {
    "text": "is actually implemented is that the firmware has a big table for every command it lists the buffer type and",
    "start": "681600",
    "end": "688560"
  },
  {
    "text": "whether or not AR write checks need to be done and so for example for the init command which is used to initialize the",
    "start": "688560",
    "end": "693920"
  },
  {
    "text": "platform this command only reads an input it doesn't write back an output and so no rmp check checks need to be",
    "start": "693920",
    "end": "700680"
  },
  {
    "text": "done because the firmware never does any rights but for example the platform status command only writes back an",
    "start": "700680",
    "end": "706079"
  },
  {
    "text": "output it obviously writes back the status of the platform and so because the firmware is now do doing right um it",
    "start": "706079",
    "end": "712680"
  },
  {
    "text": "needs to check the r&p to make sure that the firmware is actually allowed to do that and so this is all very nice and",
    "start": "712680",
    "end": "718639"
  },
  {
    "text": "well and works quite good for most of the commands however if you look at this table there is one exception to this rule which is",
    "start": "718639",
    "end": "725040"
  },
  {
    "text": "that for some reason the attestation command doesn't do rmp write checks the table just says false there however the",
    "start": "725040",
    "end": "731760"
  },
  {
    "text": "attestation command still writes back an output um I'm not quite sure why this is",
    "start": "731760",
    "end": "737480"
  },
  {
    "text": "um I guess is either it's a typo or copy paste mistake but either way let's look at what we can do with",
    "start": "737480",
    "end": "743760"
  },
  {
    "text": "that so instead of using normal memory that's owned by hypervisor the first the",
    "start": "743760",
    "end": "749519"
  },
  {
    "text": "hypervisor can actually point the firmware to memory that's owned by a guest and remember all memory that's",
    "start": "749519",
    "end": "755160"
  },
  {
    "text": "owned by a guest is supposed to be encrypted uh Integrity protected so obviously the hypervisor",
    "start": "755160",
    "end": "761880"
  },
  {
    "text": "can't write the requests to that location because it can't do wrs um it also can donate the page to the firmware",
    "start": "761880",
    "end": "768399"
  },
  {
    "text": "but none of those cases uh none of those things really matter here the important thing is that the hypervisor can still",
    "start": "768399",
    "end": "773560"
  },
  {
    "text": "tell the firmware that there is a request there that it should execute um and the firmware will just do just that",
    "start": "773560",
    "end": "780240"
  },
  {
    "text": "um and importantly it will write back a response to that memory that's owned by the guest and this is this is really the bad",
    "start": "780240",
    "end": "787480"
  },
  {
    "text": "thing here because the hyper buer was just able to trick the firmware into writing to memory that it wasn't",
    "start": "787480",
    "end": "793360"
  },
  {
    "text": "supposed to write to um the firmware doesn't the hypervisor doesn't have right access to that page and the",
    "start": "793360",
    "end": "798480"
  },
  {
    "text": "firmware shouldn't have right access to that page also and so this this is really",
    "start": "798480",
    "end": "804320"
  },
  {
    "text": "bad okay but yeah so once again diaper",
    "start": "804320",
    "end": "809560"
  },
  {
    "text": "veror can send a malicious adastation command to the firmware and then write some memory back to the guest memory a",
    "start": "809560",
    "end": "816560"
  },
  {
    "text": "little bit about this memory corruption um so the attestation command is is the name might suggest used to",
    "start": "816560",
    "end": "824240"
  },
  {
    "text": "generate attestation reports and so the actual body of the interation report is written somewhere completely else and the only thing that's written back in",
    "start": "824240",
    "end": "830480"
  },
  {
    "text": "the request and response buffer is actually the size of the registation report because that's the only thing that's of fixed size and so in practice",
    "start": "830480",
    "end": "838320"
  },
  {
    "text": "um the adastation report will always have a fixed value and so the value that's actually written back into guest",
    "start": "838320",
    "end": "843519"
  },
  {
    "text": "memory is also always fixed it's also always hex D Zer um and so yeah however",
    "start": "843519",
    "end": "850160"
  },
  {
    "text": "what is quite nice is that we can actually choose the location so we can just shift the request and response",
    "start": "850160",
    "end": "855360"
  },
  {
    "text": "buffer over a couple of bites and so we have some leeway in that regard um but unfortunately the value is",
    "start": "855360",
    "end": "861880"
  },
  {
    "text": "fixed okay but if you remember all the way to beginning um I told you that the",
    "start": "861880",
    "end": "867440"
  },
  {
    "text": "main threat for for tees is leakage of Secrets and so far we've done like the",
    "start": "867440",
    "end": "873959"
  },
  {
    "text": "opposite we can potentially destroy Secrets but so far we have no way to really get out the secrets and that's of",
    "start": "873959",
    "end": "879680"
  },
  {
    "text": "course what we want to do okay so um there are a couple of",
    "start": "879680",
    "end": "885560"
  },
  {
    "text": "problems um with attacking a guest directly um so if you want to attack guest memory uh the first most obvious",
    "start": "885560",
    "end": "892519"
  },
  {
    "text": "thing that we need to know is that well what kind of memory do we want to attack and this is made really difficult by the",
    "start": "892519",
    "end": "898320"
  },
  {
    "text": "fact that well All Guest memory is encrypted and so we have no way of actually knowing what the memory is",
    "start": "898320",
    "end": "903519"
  },
  {
    "text": "being used for by the guest there are pro probably some ways to like guest that based on the access patterns but",
    "start": "903519",
    "end": "909839"
  },
  {
    "text": "it's by no means trivial and we'll probably also have to depend on the specific guest that that's running so",
    "start": "909839",
    "end": "916600"
  },
  {
    "text": "yeah next up and this is perhaps the even bigger problem is that well I told you that all guest memory is encrypted",
    "start": "916600",
    "end": "923920"
  },
  {
    "text": "and this memory corruption that we have here only allows us to write to the cipher text uh of that encrypted memory",
    "start": "923920",
    "end": "930079"
  },
  {
    "text": "and so the big problem is that this is using AES encryption and we have no way of knowing what the corresponding plane",
    "start": "930079",
    "end": "935480"
  },
  {
    "text": "text will be for that uh corrupted memory and this once again makes targeted attacks really difficult um and",
    "start": "935480",
    "end": "943199"
  },
  {
    "text": "definitely not easy to pull off and so this all leads me to conclude",
    "start": "943199",
    "end": "948360"
  },
  {
    "text": "that attacking a guest directly by attacking its memory is probably possible however it's not easy um and",
    "start": "948360",
    "end": "956000"
  },
  {
    "text": "exploits will also likely have to be tyed to specific workload so if you want to attack Windows you have to use",
    "start": "956000",
    "end": "961279"
  },
  {
    "text": "different strategies compared to when you want to attack Linux and so on and so forth and this lead led me to another",
    "start": "961279",
    "end": "968160"
  },
  {
    "text": "idea what if attacking the guest directly um we attack memory that's actually owned by the SCV firmware so we",
    "start": "968160",
    "end": "975160"
  },
  {
    "text": "already talked about how the r&p is owned by the firmware but the firmware actually uses some other memory at well",
    "start": "975160",
    "end": "981399"
  },
  {
    "text": "as well and we'll talk about some of that now so one of the really important things that's owned by the firmware is",
    "start": "981399",
    "end": "988959"
  },
  {
    "text": "so-called guest context page so for every single uh virtual machine that's launched up by the firmware the firmware",
    "start": "988959",
    "end": "995600"
  },
  {
    "text": "also separately maintains a so-called guest contact page this guest contact page mainly contains metadata about the",
    "start": "995600",
    "end": "1002199"
  },
  {
    "text": "guest so for example is the guest currently running um one of what are some of the field um Flags what are some",
    "start": "1002199",
    "end": "1007800"
  },
  {
    "text": "of the like encryption keys and so on and yeah so obviously guest context",
    "start": "1007800",
    "end": "1013399"
  },
  {
    "text": "pages are encrypted U owned by the SCV firmware that's why we're talking about them um and they're also denoted using a",
    "start": "1013399",
    "end": "1020160"
  },
  {
    "text": "special state in the r&p to make sure that the fo doesn't confuse it with other memory that is owned by itself",
    "start": "1020160",
    "end": "1027199"
  },
  {
    "text": "also what's really interesting is that guest context pages are encrypted and they're actually using encrypted using a",
    "start": "1027199",
    "end": "1032520"
  },
  {
    "text": "special key that is only accessible to the firmware so neither the guest nor any of and neither the hypervisor nor",
    "start": "1032520",
    "end": "1039400"
  },
  {
    "text": "any of the guests have access to the special key and really there is no",
    "start": "1039400",
    "end": "1044678"
  },
  {
    "text": "there's no need for them um to access this page so it makes sense to use a separate key just for guest context",
    "start": "1044679",
    "end": "1052720"
  },
  {
    "text": "pages okay and so let's actually take a look at some of the fields um contained in such a guest contact page um as I",
    "start": "1052799",
    "end": "1058720"
  },
  {
    "text": "already told you there's a lot of crypto stuff in there some states and some some Flags but for for now we'll just focus",
    "start": "1058720",
    "end": "1065600"
  },
  {
    "text": "on one of the fields and which happens to be the very first field and that is the UMC context SE uh seed so UMC stands",
    "start": "1065600",
    "end": "1073160"
  },
  {
    "text": "for unified memory controller and basically when the firmware launches the guest um it randomly populates this UMC",
    "start": "1073160",
    "end": "1079960"
  },
  {
    "text": "key seat with random values later during the boot stages the firmware then actually uses this key",
    "start": "1079960",
    "end": "1086320"
  },
  {
    "text": "seat um to tell the memory controllers the unified memory controllers um about",
    "start": "1086320",
    "end": "1093039"
  },
  {
    "text": "the key and then the memory controllers will use this key seat to deterministically derive um the",
    "start": "1093039",
    "end": "1099360"
  },
  {
    "text": "encryption key that's used by the guest um yeah so it turns out that a lot of",
    "start": "1099360",
    "end": "1105120"
  },
  {
    "text": "CPUs actually have multiple memory controllers and so the firmware needs to tell all of them about the CMC key seed",
    "start": "1105120",
    "end": "1110480"
  },
  {
    "text": "um so that they share the same encryption key and that's also why they need to deterministically derive the",
    "start": "1110480",
    "end": "1115919"
  },
  {
    "text": "actual key from this key seat what's really interesting though is",
    "start": "1115919",
    "end": "1121000"
  },
  {
    "text": "that if we use this memory vulnerability I talked about um and we point a request",
    "start": "1121000",
    "end": "1126799"
  },
  {
    "text": "and response buffer in such a way that it points just at the beginning of the UMC key seat we can actually crop the",
    "start": "1126799",
    "end": "1133240"
  },
  {
    "text": "UMC key seed and so if we just do this once we can crop the first four bytes",
    "start": "1133240",
    "end": "1139240"
  },
  {
    "text": "but however we can as I told you adjust the um location of the M corruption and",
    "start": "1139240",
    "end": "1145559"
  },
  {
    "text": "so if we do the same thing one bite over we can actually corrupt another bite and",
    "start": "1145559",
    "end": "1150919"
  },
  {
    "text": "if we do that a couple of more times we can actually set the whole UMC key seed",
    "start": "1150919",
    "end": "1156280"
  },
  {
    "text": "to a fixed value and this is interesting for the following reason if we have two",
    "start": "1156280",
    "end": "1162400"
  },
  {
    "text": "identical guests with two identical UMC key seats the encryption Keys used by",
    "start": "1162400",
    "end": "1168080"
  },
  {
    "text": "both of those guest guests are also the same usually every guest is launched with a unique encryption key for obvious",
    "start": "1168080",
    "end": "1174720"
  },
  {
    "text": "reasons but if we use this vulnerability and Target the UMC key seed field in the",
    "start": "1174720",
    "end": "1179799"
  },
  {
    "text": "guest context page we can force multiple guests use the same encryption keys and",
    "start": "1179799",
    "end": "1184840"
  },
  {
    "text": "so the idea then is to have on normal victim guest that we can use for all the attestation stuff and for this guest we",
    "start": "1184840",
    "end": "1190799"
  },
  {
    "text": "don't enable debugging however then we also have a second guest and for this guest we actually enable debugging and",
    "start": "1190799",
    "end": "1196480"
  },
  {
    "text": "the idea then is then because both of the guest use the same encryption Keys we can use this attacker guest to",
    "start": "1196480",
    "end": "1203039"
  },
  {
    "text": "decrypt the memory that is owned by the victim guest and that way we can leak",
    "start": "1203039",
    "end": "1208520"
  },
  {
    "text": "Secrets okay so this all sounds very nice um however there are actually some",
    "start": "1208520",
    "end": "1214679"
  },
  {
    "text": "problems with that um some challenges and the first one is that well I just told you guest context pages are",
    "start": "1214679",
    "end": "1220600"
  },
  {
    "text": "encrypted and so once again we can only write to the cipher text and if we write",
    "start": "1220600",
    "end": "1225640"
  },
  {
    "text": "to the UMC key seed we can only write to the cipher text and we have no way of knowing what the plane text will be this",
    "start": "1225640",
    "end": "1231440"
  },
  {
    "text": "is made even worse by the fact that well encryption is actually dependent on the location of the memory um so this is",
    "start": "1231440",
    "end": "1238880"
  },
  {
    "text": "very similar to like dis encryption you don't want the same data encrypted at two different locations to have the same",
    "start": "1238880",
    "end": "1244440"
  },
  {
    "text": "Cipher text so you have an initialization Vector that's dependent on the location and so depending on the",
    "start": "1244440",
    "end": "1250400"
  },
  {
    "text": "location the cipher text and plain text pairs will be different and this sort of throws off our whole exploit um because",
    "start": "1250400",
    "end": "1257480"
  },
  {
    "text": "the whole point was to have the pl text of the UMC keyc to be the same um however if we do this at different",
    "start": "1257480",
    "end": "1263280"
  },
  {
    "text": "locations um this won't work and so the the takeaway from this is that well if",
    "start": "1263280",
    "end": "1268559"
  },
  {
    "text": "we want to do this we have to S use the same location for both guest context Pages um however obviously there is no",
    "start": "1268559",
    "end": "1275480"
  },
  {
    "text": "way to have two things at the same location and so what we really have to do is that we first have to shut down the victim guest and only after it's",
    "start": "1275480",
    "end": "1282440"
  },
  {
    "text": "been shut down can we create a second guest context page at that same location so that the location",
    "start": "1282440",
    "end": "1289200"
  },
  {
    "text": "uh location dependent enry encryption is the same and so that we get the same fixed plane text",
    "start": "1289200",
    "end": "1295960"
  },
  {
    "text": "out okay and with that we actually have all of the steps that we need um so the",
    "start": "1295960",
    "end": "1301039"
  },
  {
    "text": "first step is that we launch the guest night normal um but immediately after doing that we issue malicious ATT",
    "start": "1301039",
    "end": "1306360"
  },
  {
    "text": "station commands and point them at the UMC key seat in that guest's guest context page we then run the guest and",
    "start": "1306360",
    "end": "1313840"
  },
  {
    "text": "while it's running we record some of the memory that we potentially want to decrypt later eventually the guest has",
    "start": "1313840",
    "end": "1319159"
  },
  {
    "text": "been shut down at this point we can launch a second attacker guest at the same location during the launch process",
    "start": "1319159",
    "end": "1324960"
  },
  {
    "text": "for this guest we actually enable debugging um then once again we use the same malicious adastation commands to",
    "start": "1324960",
    "end": "1331520"
  },
  {
    "text": "corrupt dumc key seed with the same fixed values because the values are now the same for both of the guests they",
    "start": "1331520",
    "end": "1338640"
  },
  {
    "text": "share the same encryption keys and so if we issue debug commands to that attacker guest we can actually successfully",
    "start": "1338640",
    "end": "1344960"
  },
  {
    "text": "decrypt the memory that was owned by the victim guest and so actually written some proof of concept code for this um",
    "start": "1344960",
    "end": "1350720"
  },
  {
    "text": "it's partially implemented using some hypervisor patches but there's also user space component for this and for this",
    "start": "1350720",
    "end": "1356159"
  },
  {
    "text": "proof of concept I've just uh told the uh the user space component to decrypt",
    "start": "1356159",
    "end": "1362520"
  },
  {
    "text": "some memory at a location that was previously used um to store a so-called Secrets page um so this is not really",
    "start": "1362520",
    "end": "1368559"
  },
  {
    "text": "that important but basically when the firw launches each guest it is um creates a special Secrets page that's",
    "start": "1368559",
    "end": "1375000"
  },
  {
    "text": "entirely secret just to R guest and the reason that I've chosen to do uh to attack this page is that first of all",
    "start": "1375000",
    "end": "1381880"
  },
  {
    "text": "it's very important in the context of SCV and second of all it's also very recognizable so for example you can see",
    "start": "1381880",
    "end": "1387279"
  },
  {
    "text": "the first bite is always a three um there are also a lot of zeros and this really uh seems to confirm that we were",
    "start": "1387279",
    "end": "1392799"
  },
  {
    "text": "able to successfully exploit all of this um also if we par out some of the fields",
    "start": "1392799",
    "end": "1398559"
  },
  {
    "text": "um they they make a lot of sense so for example in the third row you can see the FMS field which stands for family model",
    "start": "1398559",
    "end": "1404960"
  },
  {
    "text": "and stepping and this matches the value that you would you would expect for an epic Milan CPU which is the CPU I used",
    "start": "1404960",
    "end": "1412000"
  },
  {
    "text": "to test this with and so really this this this works very",
    "start": "1412000",
    "end": "1417159"
  },
  {
    "text": "well okay so with that done um let's",
    "start": "1417159",
    "end": "1422240"
  },
  {
    "text": "actually talk about a second exploit uh about the second bug and the second exploit so this bug is not related to",
    "start": "1422240",
    "end": "1429080"
  },
  {
    "text": "command dispatch at all it's talks about some about something completely else this bug is all uh related to",
    "start": "1429080",
    "end": "1435279"
  },
  {
    "text": "certificate storage um so the firmware store some certificates and it wants those certificates to survive across",
    "start": "1435279",
    "end": "1442200"
  },
  {
    "text": "reboots and so usually it would store those certificates on an SPI flash",
    "start": "1442200",
    "end": "1447400"
  },
  {
    "text": "however for a lot of reasons you don't really want to use an SPI Flash and as you have to they are like sort of slow",
    "start": "1447400",
    "end": "1452440"
  },
  {
    "text": "and have limited ride cycles and So eventually AMD added an extended uh version of the inet command uh that",
    "start": "1452440",
    "end": "1459520"
  },
  {
    "text": "could be used by the hypervisor to tell the firmware to use regular memory instead of the SPI flash um after this",
    "start": "1459520",
    "end": "1466840"
  },
  {
    "text": "has been done it's then the responsibility of the hypervisor to save and restore this memory and by doing this we can",
    "start": "1466840",
    "end": "1473039"
  },
  {
    "text": "skip the SPI flash completely of course because this memory will then be owned",
    "start": "1473039",
    "end": "1478200"
  },
  {
    "text": "by the firmware the rmp also needs to reflect that and so once again before",
    "start": "1478200",
    "end": "1483360"
  },
  {
    "text": "this command is actually executed the hypervisor issues those special CPU instructions um to make sure that the",
    "start": "1483360",
    "end": "1490159"
  },
  {
    "text": "memory is owned by the firmware so that the firmware can actually write to it and so as you might expect um during the",
    "start": "1490159",
    "end": "1496720"
  },
  {
    "text": "initialization command The Firm also does those checks and enforces them and if the state isn't correct it",
    "start": "1496720",
    "end": "1503760"
  },
  {
    "text": "fails what's interesting though is that those checks are only done once and so for all subsequent accesses the firmware",
    "start": "1503760",
    "end": "1510919"
  },
  {
    "text": "doesn't check the permissions anymore and this yeah once again this is",
    "start": "1510919",
    "end": "1516640"
  },
  {
    "text": "just done for performance reason the firmware knows that it owns that memory and so there's really no reason for it",
    "start": "1516640",
    "end": "1521720"
  },
  {
    "text": "to dust those checks again okay um on a completely unrelated",
    "start": "1521720",
    "end": "1528120"
  },
  {
    "text": "note um there's actually a command that the hypervisor can issue to reclaim memory so the prime use case for this is",
    "start": "1528120",
    "end": "1534440"
  },
  {
    "text": "that for example after a VM has been shut down the guest context page that used to be associated with that guest is",
    "start": "1534440",
    "end": "1541080"
  },
  {
    "text": "no longer being used and so in theory it could be used by the hypervisor again but because it's still owned by the",
    "start": "1541080",
    "end": "1546360"
  },
  {
    "text": "firmware it can't just do that however is if the hypervisor asks nicely um the",
    "start": "1546360",
    "end": "1551960"
  },
  {
    "text": "firmware will just give that memory back to the hypervisor um of course the firmware doesn't just blindly trust the",
    "start": "1551960",
    "end": "1557960"
  },
  {
    "text": "hyper so it actually does a lot of permission checks to make sure that for example if it's a g context page that the guest",
    "start": "1557960",
    "end": "1563440"
  },
  {
    "text": "really isn't running anymore and so all of this is is supposed to be secure",
    "start": "1563440",
    "end": "1569440"
  },
  {
    "text": "however there's one big caveat um which you might have guessed at this point and which is that well the page reclaim",
    "start": "1569440",
    "end": "1574720"
  },
  {
    "text": "command forgot to check whether or not the memory is being used to store",
    "start": "1574720",
    "end": "1579760"
  },
  {
    "text": "certificates and this is really bad because the firmware still thinks that it owns that memory however it just gave",
    "start": "1579760",
    "end": "1587039"
  },
  {
    "text": "back access to that memory to the hypervisor to do whatever it wants with that and so this allows us to do the",
    "start": "1587039",
    "end": "1593559"
  },
  {
    "text": "following the first two steps are just like normal um the hypervisor donates some memory to the firmware and then us",
    "start": "1593559",
    "end": "1599799"
  },
  {
    "text": "it it uses it to tell the firmware to use it it to S certificates um however",
    "start": "1599799",
    "end": "1605520"
  },
  {
    "text": "immediately after doing that it does something bad which is that it can use the page reclaim command um to reclaim",
    "start": "1605520",
    "end": "1612279"
  },
  {
    "text": "that memory from the firmware to the hypervisor this isn't supposed to happen because the firmware is actually still",
    "start": "1612279",
    "end": "1618240"
  },
  {
    "text": "using that memory because but because that check doesn't exist the firmware just allows this once the hypervisor",
    "start": "1618240",
    "end": "1624840"
  },
  {
    "text": "actually owns that memory um it can do whatever it wants with that and one of the things that it can do is that it can",
    "start": "1624840",
    "end": "1630760"
  },
  {
    "text": "assign the memory to a guest um and then the the the worst part of all of this is",
    "start": "1630760",
    "end": "1636559"
  },
  {
    "text": "that the hypervisor can is actually issue some commands to the firmware to refresh some certificates and by doing",
    "start": "1636559",
    "end": "1642799"
  },
  {
    "text": "that the firmare will write to that uh storage location and of course because that memory is now owned by guest the",
    "start": "1642799",
    "end": "1648919"
  },
  {
    "text": "hypervisor will write to memory that's owned by guest once again this is really bad the hypervisor the firmware really",
    "start": "1648919",
    "end": "1655399"
  },
  {
    "text": "isn't supposed to uh write to memory that's not owned by itself and it isn't supposed to write to memory that is",
    "start": "1655399",
    "end": "1661360"
  },
  {
    "text": "owned by guest um and also the hypervisor isn't supposed to be able to trick the firmware into doing",
    "start": "1661360",
    "end": "1667880"
  },
  {
    "text": "so okay so the interesting question is though can we do better than last time um so",
    "start": "1667880",
    "end": "1673880"
  },
  {
    "text": "last time we were really limited by two things the first one is that um we could only write a fixed value and the second",
    "start": "1673880",
    "end": "1680480"
  },
  {
    "text": "one is that we could only write four bytes at a time and even though we could choose the location of that memory",
    "start": "1680480",
    "end": "1686200"
  },
  {
    "text": "corruption to some degree there are also some limitations and some of the fields in the guest contact page that we just",
    "start": "1686200",
    "end": "1691519"
  },
  {
    "text": "couldn't reach however this time around um when the certificates are refreshed",
    "start": "1691519",
    "end": "1696919"
  },
  {
    "text": "they are also encrypted and so in practice the data that is written is completely random um and also the",
    "start": "1696919",
    "end": "1702840"
  },
  {
    "text": "firmware writes a lot more data so it writes roughly three pages worth of data um to that nonvolatile storage area to",
    "start": "1702840",
    "end": "1709919"
  },
  {
    "text": "store all certificates so once again um we don't want to attack the guest directly for",
    "start": "1709919",
    "end": "1715880"
  },
  {
    "text": "all of the reasons that I went to uh in into earlier um and we want to attack",
    "start": "1715880",
    "end": "1721000"
  },
  {
    "text": "guest context page ideally last time we attack the UMC key seat however this",
    "start": "1721000",
    "end": "1726480"
  },
  {
    "text": "time around this won't really work and the reason for that is that the UMC key seat is already random to begin with and",
    "start": "1726480",
    "end": "1732960"
  },
  {
    "text": "we can only override it with a new random value and there's really no point in doing that um because like all of the",
    "start": "1732960",
    "end": "1739919"
  },
  {
    "text": "guests will have random values and last time we could only exploit this if we can could get two guests to share the",
    "start": "1739919",
    "end": "1745760"
  },
  {
    "text": "same encryption key which we can't do using this vulnerability so we actually need to",
    "start": "1745760",
    "end": "1751600"
  },
  {
    "text": "take a look at some of the other fields and one of the fields that's really interesting is the so-called edress space identifier so after the UMC key",
    "start": "1751600",
    "end": "1759480"
  },
  {
    "text": "seed has been programmed into the unified memory controllers um each of the VMS is associated with an encryption",
    "start": "1759480",
    "end": "1765799"
  },
  {
    "text": "key using the so-called ospace identifier um and what's interesting is that if we",
    "start": "1765799",
    "end": "1772200"
  },
  {
    "text": "can corrupt the guest context page and in particular if we can corrupt the Ed",
    "start": "1772200",
    "end": "1777720"
  },
  {
    "text": "space identifier we can potentially trick the firmware and the memory controllers into using the encryption",
    "start": "1777720",
    "end": "1784279"
  },
  {
    "text": "keys of another guest and so the idea then is that we don't need two guests to",
    "start": "1784279",
    "end": "1789480"
  },
  {
    "text": "have the same encryption key if we can just crop the guest context page from one guest to just point to that",
    "start": "1789480",
    "end": "1795039"
  },
  {
    "text": "encryption key of that other guest over there and and so that's where we don't need to have two guests share the same",
    "start": "1795039",
    "end": "1801000"
  },
  {
    "text": "encryption key um also because we need to corrupt the whole guest context page um that's",
    "start": "1801000",
    "end": "1806919"
  },
  {
    "text": "just how the vulnerability works we also need to corrupt the policy field and ideally we want to corrupt it in such",
    "start": "1806919",
    "end": "1812960"
  },
  {
    "text": "way that it has the PO debug flag enabled okay so um once again there are",
    "start": "1812960",
    "end": "1819760"
  },
  {
    "text": "problems um the first one is that there are only a very few number of valid",
    "start": "1819760",
    "end": "1824799"
  },
  {
    "text": "edress space identifiers and the reason for that is that the um see the unified memory controllers of course has to",
    "start": "1824799",
    "end": "1830720"
  },
  {
    "text": "store all of those encryption keys and it doesn't just have unlimited storage to store encryption keys and so",
    "start": "1830720",
    "end": "1836480"
  },
  {
    "text": "depending on the CPU model CPU model there are roughly 500 or 1,000 valid",
    "start": "1836480",
    "end": "1841919"
  },
  {
    "text": "encryption Keys um and so this is also the number of address space identifiers that is valid um the address space",
    "start": "1841919",
    "end": "1848120"
  },
  {
    "text": "identifier is a 32-bit values so the chances of getting a valid address space identifier are actually fairly low um",
    "start": "1848120",
    "end": "1855679"
  },
  {
    "text": "another big problem is that well once again guest context pages are encrypted and so the atress space identifier field",
    "start": "1855679",
    "end": "1862720"
  },
  {
    "text": "and the policy field are also encrypted and so this makes it so that the hypervisor can just look at them and",
    "start": "1862720",
    "end": "1868279"
  },
  {
    "text": "figure out what they actually contain however for this there's actually a very nice solution which is that amdv S&P",
    "start": "1868279",
    "end": "1876080"
  },
  {
    "text": "conveniently has a command to just decrypt both of those fields in addition to a few other ones um and the reason",
    "start": "1876080",
    "end": "1883000"
  },
  {
    "text": "this is allowed to work is that none of those fields are really sensitive and if the hypervisor wants to know about those",
    "start": "1883000",
    "end": "1888080"
  },
  {
    "text": "fields the hyper The Firm will happily tell the hypervisor about them okay so what we can do then is that",
    "start": "1888080",
    "end": "1896360"
  },
  {
    "text": "we can repeatedly um uh ask the firmware to refresh the",
    "start": "1896360",
    "end": "1903039"
  },
  {
    "text": "certificates and every time it does that it will corrupt the guest context page using new random values and we do this",
    "start": "1903039",
    "end": "1910880"
  },
  {
    "text": "until we hit a very specific set of conditions the first one is that once again the address space identifier needs",
    "start": "1910880",
    "end": "1916559"
  },
  {
    "text": "to be valid and the policy field needs to have the debug flag enabled there are actually also a couple other um",
    "start": "1916559",
    "end": "1923600"
  },
  {
    "text": "conditions but they're not as interesting so I won't go into them but in the end the chances of getting all of the conditions right are roughly one in",
    "start": "1923600",
    "end": "1930399"
  },
  {
    "text": "12 million um furthermore we can corrupt around 300 guest contact Pates per",
    "start": "1930399",
    "end": "1935679"
  },
  {
    "text": "second if we just Hammer the firmware all the time this might seem kind of slow and this has a reason um refreshing",
    "start": "1935679",
    "end": "1942480"
  },
  {
    "text": "the certificates is a fairly slow operation and so this is also why we can only corrupt such a low number of guest",
    "start": "1942480",
    "end": "1948639"
  },
  {
    "text": "contact pages per second but in the end if you do the math and all of that and if you just continuously Hammer the",
    "start": "1948639",
    "end": "1954760"
  },
  {
    "text": "firmware all all the time and we expect to get the right conditions about every once a day I mean in the end it's",
    "start": "1954760",
    "end": "1961279"
  },
  {
    "text": "completely random so you might get lucky you might get not lucky but um that that's what we would expect um what's",
    "start": "1961279",
    "end": "1968080"
  },
  {
    "text": "really nice though is that we can actually do this before we launch the victim guest um so we just need a guest",
    "start": "1968080",
    "end": "1973200"
  },
  {
    "text": "context page to point to some other guest we don't need that guest to be already running and so we don't need our",
    "start": "1973200",
    "end": "1978720"
  },
  {
    "text": "victim guests to stay around for a whole day while we Hammer the firmware and we can actually do this well in advance and",
    "start": "1978720",
    "end": "1984159"
  },
  {
    "text": "once we've done that we can actually use the same corrupted guest context page for multiple guests if they happen to",
    "start": "1984159",
    "end": "1989480"
  },
  {
    "text": "use the same address space identifier as the one that's in the guest context page",
    "start": "1989480",
    "end": "1995320"
  },
  {
    "text": "here and so in the end once again I've written proof of concept for this um for",
    "start": "1995320",
    "end": "2001480"
  },
  {
    "text": "this particular run it took like one day and 19 hours and it took like 1.4 million um yeah I needed to crop the",
    "start": "2001480",
    "end": "2009840"
  },
  {
    "text": "guest contact Pages 1.4 million times but in the end we actually got a very small Ed space identifier so it didn't",
    "start": "2009840",
    "end": "2014880"
  },
  {
    "text": "need to be that small in this case it happened to be 31 and once again I've used this vulnerability to then decrypt",
    "start": "2014880",
    "end": "2021559"
  },
  {
    "text": "a Secrets page so once again if you look at the first bite and you can see that it's three and you can also see some of",
    "start": "2021559",
    "end": "2027760"
  },
  {
    "text": "the structures are very similar and yeah okay and so uh this leads me to my",
    "start": "2027760",
    "end": "2035399"
  },
  {
    "text": "last point which is that I believe that those exploit strategies that are showed you here today are actually fairly",
    "start": "2035399",
    "end": "2041240"
  },
  {
    "text": "reusable um if there are my my congest is that if there are other memory",
    "start": "2041240",
    "end": "2047519"
  },
  {
    "text": "corruption vulnerabilities that allow a hypervisor to corrupt memory that's covered by the rmp um they will use be",
    "start": "2047519",
    "end": "2055520"
  },
  {
    "text": "able to use either of those strategies to actually turn us into something that can be used to leak secrets from the te",
    "start": "2055520",
    "end": "2061919"
  },
  {
    "text": "the reason that for why I believe that is that first off we can corrupt fixed riots but we can also corrupt uh exploit",
    "start": "2061919",
    "end": "2069000"
  },
  {
    "text": "random rights it doesn't really matter um also the exploits are completely",
    "start": "2069000",
    "end": "2074040"
  },
  {
    "text": "workout independent so it doesn't matter if it's running Windows or Linux or a database or whatever it works for all of",
    "start": "2074040",
    "end": "2079320"
  },
  {
    "text": "them and another point is that I actually discovered a third bu that I didn't have",
    "start": "2079320",
    "end": "2084878"
  },
  {
    "text": "time to go into today um it turns out that this P can be exploited using the very same strategy as exploit number one",
    "start": "2084879",
    "end": "2092320"
  },
  {
    "text": "um the basic there are a few changes that need to be done but the very basic idea of forcing to guests to have the",
    "start": "2092320",
    "end": "2098760"
  },
  {
    "text": "same yum key seed and then in the end have two of those guests to um the same",
    "start": "2098760",
    "end": "2105000"
  },
  {
    "text": "encryption Keys is completely identical even to the Last Detail where we had to like use the same location and all of",
    "start": "2105000",
    "end": "2112040"
  },
  {
    "text": "that okay so this leads me to my takeaways um the first one is that the",
    "start": "2112040",
    "end": "2117280"
  },
  {
    "text": "hypervisor is very powerful um even though it's constrained by um by the",
    "start": "2117280",
    "end": "2123079"
  },
  {
    "text": "hardware and and so the result of that is that because the hypervisor has a lot of control over like the setup for",
    "start": "2123079",
    "end": "2129560"
  },
  {
    "text": "different um vulnerabilities even very simple bugs can have a large security",
    "start": "2129560",
    "end": "2134720"
  },
  {
    "text": "impact impact so for example the last bug I didn't have time to talk about today is actually n pointd reference and",
    "start": "2134720",
    "end": "2140920"
  },
  {
    "text": "well it turns out that we can actually turn this into something very useful even though like n pointer references",
    "start": "2140920",
    "end": "2146160"
  },
  {
    "text": "typically aren't exploitable um the next takeaway is that",
    "start": "2146160",
    "end": "2151200"
  },
  {
    "text": "I believe that firmware that's used by SV but also other tees really deserves a lot more attention um so when when it",
    "start": "2151200",
    "end": "2157760"
  },
  {
    "text": "comes to tees there has been a lot of research on like CPUs and like microarchitecture and that is definitely",
    "start": "2157760",
    "end": "2162800"
  },
  {
    "text": "very important research but if you want to evaluate the entire security of uh tees we also need to look at the code",
    "start": "2162800",
    "end": "2169400"
  },
  {
    "text": "that's actually running to support the hardware in doing all the stuff that's it's supposed to do and so this brings",
    "start": "2169400",
    "end": "2176040"
  },
  {
    "text": "me to my last takeaway which is that in order to assess the security of all of",
    "start": "2176040",
    "end": "2181480"
  },
  {
    "text": "those systems you should really demand as much transparency as possible of all parts of the St so obviously includes",
    "start": "2181480",
    "end": "2187960"
  },
  {
    "text": "the hardware um your CPU priner probably probably won't give you like the schematics for the CPU but if they can",
    "start": "2187960",
    "end": "2194119"
  },
  {
    "text": "give you the firmware that's really great um but this also um applies to the",
    "start": "2194119",
    "end": "2200359"
  },
  {
    "text": "software that's actually running inside of the guests so there are some people and like some clouds that don't want to",
    "start": "2200359",
    "end": "2206680"
  },
  {
    "text": "give you access to all of the code but ideally if you want to te want to use a te and you want to trust that te you",
    "start": "2206680",
    "end": "2213599"
  },
  {
    "text": "should demand as much transparency as possible okay so with that thank you",
    "start": "2213599",
    "end": "2219640"
  },
  {
    "text": "very much all of the proof of concepts are available on GitHub um the propos stories are actually still on private",
    "start": "2219640",
    "end": "2225040"
  },
  {
    "text": "but I'll set them to public within the next hour and with that thank you very much for coming to my talk and enjoy blackhead",
    "start": "2225040",
    "end": "2233040"
  }
]