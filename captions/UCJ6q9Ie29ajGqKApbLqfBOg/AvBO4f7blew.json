[
  {
    "text": "hello and welcome to the pool party you will never forget today I will show you how I",
    "start": "4799",
    "end": "10160"
  },
  {
    "text": "managed to find new process injection technique that are fully undetectable",
    "start": "10160",
    "end": "15280"
  },
  {
    "text": "and they're all abuse a legitimate Windows component which is the windows user mode",
    "start": "15280",
    "end": "22119"
  },
  {
    "text": "threadpool my name is alone L and I'm a security researcher at safe brid I'm 21",
    "start": "22119",
    "end": "27519"
  },
  {
    "text": "years old and mainly self-taught my main interest and focus include operating system internals reverse",
    "start": "27519",
    "end": "34480"
  },
  {
    "text": "engineering and vulnerability research and before I joining the security fi I was a professional Brazilian jiu-jitsu",
    "start": "34480",
    "end": "40920"
  },
  {
    "text": "atlet where I won several world and European titles so this is what we'll be talking",
    "start": "40920",
    "end": "47280"
  },
  {
    "text": "about today first up we'll start with some research background followed by research motivation and research",
    "start": "47280",
    "end": "54520"
  },
  {
    "text": "goals next I'll take you behind the scenes of the research process and we'll Deep dive into the internals the windows",
    "start": "54520",
    "end": "60440"
  },
  {
    "text": "us of thread pool followed by an introduction to the pool party tool and I'll sum up with the research",
    "start": "60440",
    "end": "67479"
  },
  {
    "text": "implications and takeaways so for those of you who does",
    "start": "67479",
    "end": "73040"
  },
  {
    "text": "not know process injection is an invasion technique used to execute arbitrary code in a Target process it",
    "start": "73040",
    "end": "79439"
  },
  {
    "text": "usually consists a chain of three Primitives the first one would be an allocation primitive used to allocate",
    "start": "79439",
    "end": "84960"
  },
  {
    "text": "memory on the target process the second primitive would be a writing primitive used to write memory malicious me",
    "start": "84960",
    "end": "91079"
  },
  {
    "text": "malicious shell code to the previously allocated memory and the third primitive would be the execution primitive used to",
    "start": "91079",
    "end": "97280"
  },
  {
    "text": "execute um the malicious code read now the most basic Primitives would",
    "start": "97280",
    "end": "103360"
  },
  {
    "text": "be virtal alox API for allocation the right process memory API for writing and",
    "start": "103360",
    "end": "108520"
  },
  {
    "text": "create remote thread API for execution this injection technique so-called create remote thread injection",
    "start": "108520",
    "end": "114960"
  },
  {
    "text": "is very simple and Powerful but there is only one downside it is detectable by",
    "start": "114960",
    "end": "120000"
  },
  {
    "text": "all modern edrs This research aim to discover new process injection techniques that are",
    "start": "120000",
    "end": "126399"
  },
  {
    "text": "fully undetectable now we all know the risk of process injections it can lead to",
    "start": "126399",
    "end": "132319"
  },
  {
    "text": "Serious evasive attacks making malicious actions become completely legitimate using process injections we can probably",
    "start": "132319",
    "end": "138879"
  },
  {
    "text": "perform meaningful attacks such as credential damping or even r a ransom all while staying untouched and this is",
    "start": "138879",
    "end": "145800"
  },
  {
    "text": "exactly what I managed to do and I promise you that I'll show you how",
    "start": "145800",
    "end": "151840"
  },
  {
    "text": "so the motivation for This research was derived from the fact that process injection techniques abuse legitimate",
    "start": "152200",
    "end": "157440"
  },
  {
    "text": "features of the operating system I wondered can an EDR effectively distinguish legitimate versus malicious",
    "start": "157440",
    "end": "164120"
  },
  {
    "text": "use of a feature I also wondered is the current detection approach generic enough to detect new and neverbe seen",
    "start": "164120",
    "end": "171080"
  },
  {
    "text": "process injections so to answer these questions I've had to review the corent detection",
    "start": "171080",
    "end": "177040"
  },
  {
    "text": "approach employed by edrs against process injections and experimenting with the different",
    "start": "177040",
    "end": "182680"
  },
  {
    "text": "Primitives led me to the conclusions that EDR based their detection mainly on the execution primitive on top of that",
    "start": "182680",
    "end": "189560"
  },
  {
    "text": "write and allocate Primitives on their most basic forms are not detected and as I mentioned in the",
    "start": "189560",
    "end": "195640"
  },
  {
    "text": "motivation for This research I wanted to understand how EDR distinguish legitimate and malicious use of a",
    "start": "195640",
    "end": "201080"
  },
  {
    "text": "feature so taking threat creation as an example edrs would not usually allow a",
    "start": "201080",
    "end": "206159"
  },
  {
    "text": "process to create a thread for another process another example for a similar approach by edrs would be detecting a",
    "start": "206159",
    "end": "212920"
  },
  {
    "text": "synchronous procedure call injection and I noticed that edrs will not usually allow an APC to be CU to a thread",
    "start": "212920",
    "end": "219400"
  },
  {
    "text": "belonging to processes other than the current process so in summary allocate and write",
    "start": "219400",
    "end": "225760"
  },
  {
    "text": "Primitives on their most basic forms are not detected the detection is based mainly on the execution",
    "start": "225760",
    "end": "232239"
  },
  {
    "text": "primitive and the execution Primitives are detected based on comparing the initiator versus the creator of an",
    "start": "232239",
    "end": "238720"
  },
  {
    "text": "action so with better understanding of the detection approach I could Define the research",
    "start": "238720",
    "end": "244480"
  },
  {
    "text": "goals and my ultimate goal was to find new and fully undetectable process injection techniques and I wanted it to",
    "start": "244480",
    "end": "250879"
  },
  {
    "text": "be applicable against all windows processes no prerequisites whatsoever based on the detection",
    "start": "250879",
    "end": "257359"
  },
  {
    "text": "approach Lessons Learned we know that writing and allocation Primitives are not detected so what if we created an",
    "start": "257359",
    "end": "263320"
  },
  {
    "text": "execution primitive that is based only on writing and allocation Primitives furthermore what if the",
    "start": "263320",
    "end": "269240"
  },
  {
    "text": "execution is triggered by legitimate action what if I told you that writing to an innocent file in the system could",
    "start": "269240",
    "end": "275120"
  },
  {
    "text": "trigger Shell Code in a Target process so while searching for a suitable component that will help me in",
    "start": "275120",
    "end": "280800"
  },
  {
    "text": "achieving my research goals I came across the windows usable threadpool and before I explain why the thread pool",
    "start": "280800",
    "end": "286680"
  },
  {
    "text": "ended up being the perfect Target you may wonder what even is a thread pool so to explain what is the thread",
    "start": "286680",
    "end": "294000"
  },
  {
    "text": "pool I'll use a simple metaphor imagine that you have a pile of boxes that needs to be mailed now May ing each box",
    "start": "294000",
    "end": "300680"
  },
  {
    "text": "individually can take a lot of time and effort but what if you could send boxes in parallel so to speed things up you",
    "start": "300680",
    "end": "307919"
  },
  {
    "text": "decide to create a theme of Delivery Man and those delivery Ms are responsible for taking boxes from the pile of boxes",
    "start": "307919",
    "end": "314280"
  },
  {
    "text": "and deliver them so in the world of computers this parallelism is what we call a threadpool",
    "start": "314280",
    "end": "321000"
  },
  {
    "text": "and the threadpool pile of boxes is called the work que and each box in the pile of boxes is called a work",
    "start": "321000",
    "end": "328240"
  },
  {
    "text": "item now the threadpools delivery mans are called worker threads and the goal of those worker threads is to DQ work",
    "start": "328240",
    "end": "335440"
  },
  {
    "text": "work items from the work and execute it so now that we understand what a",
    "start": "335440",
    "end": "342520"
  },
  {
    "text": "threadpool is let me tell you why I choose the thread pool as my target so first all windows processes have a",
    "start": "342520",
    "end": "348840"
  },
  {
    "text": "threat pole by default which ensures that if I find new process injection techniques they will be applicable against all windows processes in",
    "start": "348840",
    "end": "356360"
  },
  {
    "text": "addition work items and thread pools are represented by structures which increases the possibility of having an",
    "start": "356360",
    "end": "361960"
  },
  {
    "text": "execution primitive based only on allocation and writing and third multiple or adem types are supported",
    "start": "361960",
    "end": "368720"
  },
  {
    "text": "which means that we have more opportunities and generally it increases the attack surface so with that in mind let's take",
    "start": "368720",
    "end": "375440"
  },
  {
    "text": "a swim in the threadpool starting from its architecture so the threadpool comprises",
    "start": "375440",
    "end": "382280"
  },
  {
    "text": "three distinct work cues and each work CU is dedicated for a different type of work item and you can see the cues on",
    "start": "382280",
    "end": "388440"
  },
  {
    "text": "the left side of the diag the cues include a task q a timer que",
    "start": "388440",
    "end": "393800"
  },
  {
    "text": "and a nio completion que residing in the kernel the worker threads on the right",
    "start": "393800",
    "end": "398880"
  },
  {
    "text": "side of the diagram are operating on the different cues to DQ work items and execute them now lastly the thread the",
    "start": "398880",
    "end": "406520"
  },
  {
    "text": "threadpool contains a worker threads manager which is responsible for managing the worker threads and this is",
    "start": "406520",
    "end": "413160"
  },
  {
    "text": "the worker Factory object you can see um on the bottom now do not bother with memorizing",
    "start": "413160",
    "end": "419120"
  },
  {
    "text": "each part of this architecture as we'll go over the relevant Parts later on now in regards of attack surface we",
    "start": "419120",
    "end": "426639"
  },
  {
    "text": "have the different work cues and we know that an insertion of a valid work item into one of these cues will result in",
    "start": "426639",
    "end": "432560"
  },
  {
    "text": "the work item to execute other than the cues the worker threads the worker factor which s serves",
    "start": "432560",
    "end": "438800"
  },
  {
    "text": "as the worker threads manager may be used to take over the worker",
    "start": "438800",
    "end": "443960"
  },
  {
    "text": "threads now just before we move on to explore each component in the T surface",
    "start": "443960",
    "end": "449240"
  },
  {
    "text": "I i' like to introduce you to the pool party the pool party is an exclusive party that I will use to gather all the",
    "start": "449240",
    "end": "455120"
  },
  {
    "text": "injection techniques that I find now you can notice that the party is now empty but do not be intimidated by The",
    "start": "455120",
    "end": "460800"
  },
  {
    "text": "Emptiness of the party as I promise you that I'll do my best to recruit new friends to the party as we move",
    "start": "460800",
    "end": "466720"
  },
  {
    "text": "along so let's start from attacking the worker threats manager so-called a worker",
    "start": "466720",
    "end": "473039"
  },
  {
    "text": "Factory so worker Factory is a Windows object responsible for managing bread worker threads if we use the delivery",
    "start": "473039",
    "end": "480400"
  },
  {
    "text": "man manager um The Delivery Man metaphor that that we used before the work of factory is the same as the delivery man",
    "start": "480400",
    "end": "487039"
  },
  {
    "text": "manager so in case a delivery man did not send any box for like an hour the manager would probably send him home so",
    "start": "487039",
    "end": "494520"
  },
  {
    "text": "similarly the worker Factory manages the worker threads by monitoring active or blocking worker threads and based on the",
    "start": "494520",
    "end": "501520"
  },
  {
    "text": "monitoring results it creates or terminates worker threats now the worker Factory does not",
    "start": "501520",
    "end": "508039"
  },
  {
    "text": "perform any scheduling or for execution of work items on its own its only purpose is to make sure that the number",
    "start": "508039",
    "end": "513959"
  },
  {
    "text": "of worker threats is sufficient the kernel exposes few system",
    "start": "513959",
    "end": "519039"
  },
  {
    "text": "calls to interact with worker Factory objects among them who have a create and shatown system call query and set which",
    "start": "519039",
    "end": "525000"
  },
  {
    "text": "are basically a getter and Setter for the kernel object and we have radi weight and release system",
    "start": "525000",
    "end": "531480"
  },
  {
    "text": "calls with the goal of taking overw worker threats the relevant Target would be the start",
    "start": "531480",
    "end": "537160"
  },
  {
    "text": "routine and the start routine is basically the entry point of the worker threads usually this routine serves as",
    "start": "537160",
    "end": "543079"
  },
  {
    "text": "the thread scheduler responsible for deqing and executing work items now the start routine can be",
    "start": "543079",
    "end": "549440"
  },
  {
    "text": "controlled in the worker Factory creation system call and more interestingly it accepts a handle to the",
    "start": "549440",
    "end": "554640"
  },
  {
    "text": "process of which to create the work of factory for at First Look it sounds promising can we just create a work of",
    "start": "554640",
    "end": "561200"
  },
  {
    "text": "Factory on a Target process and have it start routin point to a malicious Shell",
    "start": "561200",
    "end": "566600"
  },
  {
    "text": "Code so the answer is no trying to create a work of factory for another process fails due to an incorrect",
    "start": "566600",
    "end": "573959"
  },
  {
    "text": "parameter so looking at the implementation of the system called in the kernel I noticed that there is a validation that makes sure no worker",
    "start": "573959",
    "end": "580680"
  },
  {
    "text": "factories are created for process it other than the current process and generally speaking it is a bit odd that",
    "start": "580680",
    "end": "586720"
  },
  {
    "text": "the system call accepts a parameter with only one possible value however let's move on to explore other Alternatives",
    "start": "586720",
    "end": "592920"
  },
  {
    "text": "that can lead to abusing the start routine so going back to one of the main",
    "start": "592920",
    "end": "599480"
  },
  {
    "text": "reasons that we choose the thread pool as our Target was since all windows processes have a thread pool by default",
    "start": "599480",
    "end": "604959"
  },
  {
    "text": "and consequentially a work of factory object by default so instead of going through the",
    "start": "604959",
    "end": "610640"
  },
  {
    "text": "trouble of um creating a work a factory for a Target process we can simply utilize the duplicate handle API to gain",
    "start": "610640",
    "end": "618519"
  },
  {
    "text": "access to an existing worker Factory object belonging to the Target",
    "start": "618519",
    "end": "623720"
  },
  {
    "text": "process now giv access to an existing worker Factory does not let us control the start within pointer as this pointer",
    "start": "623720",
    "end": "630959"
  },
  {
    "text": "is constant and cannot be naturally changed after the object was initialized with that said if you can",
    "start": "630959",
    "end": "637040"
  },
  {
    "text": "somehow determine the start routin value we can overwrite the routine code with our malicious Shell",
    "start": "637040",
    "end": "643440"
  },
  {
    "text": "Code so to get work of factory information the query system will can be used and it accepts a work of factory",
    "start": "643440",
    "end": "649839"
  },
  {
    "text": "handle an information class stating which information to retrieve and a buffer which the retrieved information",
    "start": "649839",
    "end": "656040"
  },
  {
    "text": "will be written to now the only information class supported by the query system call is an",
    "start": "656040",
    "end": "662040"
  },
  {
    "text": "information class retrieving basic information on the work of Factory in this case this is enough as",
    "start": "662040",
    "end": "668399"
  },
  {
    "text": "the basic information include the start routine pointer that we are targeting now given the start routine",
    "start": "668399",
    "end": "674440"
  },
  {
    "text": "pointer we can overwrite the start routin contents with a malicious Shell Code and this um the the start routin is",
    "start": "674440",
    "end": "681519"
  },
  {
    "text": "guaranteed to run at some point but it would be even better if we could trigger its execution instead of just waiting",
    "start": "681519",
    "end": "686839"
  },
  {
    "text": "for it now the spot to examine is the set system call allowing us to modify worker",
    "start": "686839",
    "end": "693680"
  },
  {
    "text": "Factory attributes the set system call is quite similar to the query system call this",
    "start": "693680",
    "end": "699839"
  },
  {
    "text": "time the buffer is an input buffer and not an output buffer the set system call also supports",
    "start": "699839",
    "end": "706760"
  },
  {
    "text": "a little more information classes than the query system call and the information class that s needs the best",
    "start": "706760",
    "end": "712560"
  },
  {
    "text": "is the work of factory thread minimum which the sets the minimum running worker threads of the worker Factory",
    "start": "712560",
    "end": "720240"
  },
  {
    "text": "so having um two worker threats currently running setting the minimum worker",
    "start": "720240",
    "end": "725959"
  },
  {
    "text": "threats number to be the current running threats number Plus One will essentially result in a new worker threat to be",
    "start": "725959",
    "end": "731920"
  },
  {
    "text": "created meaning that the start routin that we are targeting will get executed so with that let me show you",
    "start": "731920",
    "end": "738959"
  },
  {
    "text": "the first brand new and fully undetectable process injection technique of the day so we'll start off by getting",
    "start": "738959",
    "end": "745480"
  },
  {
    "text": "the handle table of the target process and we'll use antiqu information on system call to do it we'll then iterate",
    "start": "745480",
    "end": "752920"
  },
  {
    "text": "over the handle table to locate the worker Factory handle once we find the worker Factory handle we would duplicate",
    "start": "752920",
    "end": "759399"
  },
  {
    "text": "it given access to the worker Factory of the target process we query basic information from the worker",
    "start": "759399",
    "end": "766320"
  },
  {
    "text": "Factory and using the information obtained which includes the start routin we will write shell coded to the start",
    "start": "766320",
    "end": "772560"
  },
  {
    "text": "routin of the worker Factory so now all that is left to do is to trigger the malicious um the malicious start routin",
    "start": "772560",
    "end": "779199"
  },
  {
    "text": "and in order to do that we will set the minimum um worker threads number so we now have our first friend",
    "start": "779199",
    "end": "787000"
  },
  {
    "text": "in the pool party but we do not want to leave this friend all alone in the pool",
    "start": "787000",
    "end": "792639"
  },
  {
    "text": "so let's move on to explore the thread pool cues maybe we can recruit new friends to the",
    "start": "792639",
    "end": "798480"
  },
  {
    "text": "party so when attacking the threadpool my goal was to insert a work item to a Target",
    "start": "800920",
    "end": "807519"
  },
  {
    "text": "process I knew that a correctly inserted work item will get executed by the worker thread at one point or",
    "start": "807519",
    "end": "814279"
  },
  {
    "text": "another so my goal um was to my focus was on how work items are inserted into",
    "start": "814279",
    "end": "820120"
  },
  {
    "text": "the different badol cues now I also assumed that I have access to the work of factory object um",
    "start": "820120",
    "end": "826199"
  },
  {
    "text": "that the target bpool uses as we just proved that such access can be granted by duplicating the",
    "start": "826199",
    "end": "832720"
  },
  {
    "text": "handle so the thread supports multiple types of work items and they could be divided into three the regular work",
    "start": "833320",
    "end": "839839"
  },
  {
    "text": "items which are queued right away by the Qing API call the asynchronous work items which are queed based on operation",
    "start": "839839",
    "end": "846560"
  },
  {
    "text": "completion for example when right file operation was completed and the time work items which",
    "start": "846560",
    "end": "852680"
  },
  {
    "text": "are queed right away by the Qing API call but are executed once the timer expires so the timer work items are kind",
    "start": "852680",
    "end": "858880"
  },
  {
    "text": "of combination of both asynchronous um and regular work items now as for the three types of work",
    "start": "858880",
    "end": "866199"
  },
  {
    "text": "items we also have three cues the regular work items are queued into",
    "start": "866199",
    "end": "871360"
  },
  {
    "text": "the task que residing in the main reple structure which is called the TP pool",
    "start": "871360",
    "end": "876440"
  },
  {
    "text": "the as synchronous work items are cued to the iio completion queue which is actually a Windows object that we will",
    "start": "876440",
    "end": "882440"
  },
  {
    "text": "will discuss later on and the time of work items are cued to the timer queue also residing in the main threadpool",
    "start": "882440",
    "end": "890880"
  },
  {
    "text": "structure before we dive into the queuing mechanism of each work atem type it is important to note that the work",
    "start": "891639",
    "end": "897920"
  },
  {
    "text": "atem callbacks are not executed directly instead each work item has a",
    "start": "897920",
    "end": "903279"
  },
  {
    "text": "helper callback that is used to execute the work item callback the structure that is skewed to",
    "start": "903279",
    "end": "909480"
  },
  {
    "text": "the queue is the helper structure so keep that in mind as we analyze the work item skewing",
    "start": "909480",
    "end": "915959"
  },
  {
    "text": "mechanism and let's start with the regular work item the TP",
    "start": "915959",
    "end": "921240"
  },
  {
    "text": "work but looking closely at the work item structure I found its helper part called the task structure so now we know",
    "start": "921240",
    "end": "928600"
  },
  {
    "text": "that the T structure is what gets put in the task Q of the threadpool but here is the real question how does it get",
    "start": "928600",
    "end": "936800"
  },
  {
    "text": "there so the API responsible for posting a task to the rep task Q is the TP post",
    "start": "936800",
    "end": "942319"
  },
  {
    "text": "task API the triple task Q is a double elink",
    "start": "942319",
    "end": "947560"
  },
  {
    "text": "list of tasks so consider that we have a que of three tasks calling the post task",
    "start": "947560",
    "end": "953160"
  },
  {
    "text": "API on this queue will result in the task to be queed to the end of the queue",
    "start": "953160",
    "end": "959120"
  },
  {
    "text": "as you can see on the monitor so given the thread structure of the target process we can temper with its task Q to",
    "start": "959120",
    "end": "966360"
  },
  {
    "text": "inject malicious task into it and with that let me show you the",
    "start": "966360",
    "end": "972079"
  },
  {
    "text": "second brand new and fully undetectable process injection technique of the day so similar to the first variant we",
    "start": "972079",
    "end": "980399"
  },
  {
    "text": "start by getting the handle table of the target process we iterate over the table once",
    "start": "980399",
    "end": "985639"
  },
  {
    "text": "we find the work of factory handle and once once we find it we duplicate at it then we query basic information from",
    "start": "985639",
    "end": "992560"
  },
  {
    "text": "the work of factory and notice that this time we did not need the start within we need the start parameter the start",
    "start": "992560",
    "end": "998440"
  },
  {
    "text": "parameter is the pointer to the main threadpool structure then we read the the",
    "start": "998440",
    "end": "1004199"
  },
  {
    "text": "threadpool structure from the target process and we do it in order to obtain the target task",
    "start": "1004199",
    "end": "1009720"
  },
  {
    "text": "Q we're proceed by creating a malicious work adem that this call back points to a Shell",
    "start": "1009720",
    "end": "1015880"
  },
  {
    "text": "Code then we allocate memory for the malicious for item on the target process",
    "start": "1015880",
    "end": "1020920"
  },
  {
    "text": "and following the location we write the work atem to the um Target process now we can notice that the work item and the",
    "start": "1020920",
    "end": "1028038"
  },
  {
    "text": "task Q are not currently connected so our next step would be to use any writing primitive to insert the",
    "start": "1028039",
    "end": "1034798"
  },
  {
    "text": "malicious work item to the threadpool and this step essentially manipulates the task Q in a way that will have a new",
    "start": "1034799",
    "end": "1040720"
  },
  {
    "text": "work atem in its head as a result the scheduler will DQ the malicious work",
    "start": "1040720",
    "end": "1046000"
  },
  {
    "text": "item and execute it so please welcome in our second friend",
    "start": "1046000",
    "end": "1051720"
  },
  {
    "text": "in the pool party and I was pleased to have two friends in the party but it is not a",
    "start": "1051720",
    "end": "1057120"
  },
  {
    "text": "real party without at least 5 to 10 friends so let's move on to attack",
    "start": "1057120",
    "end": "1062520"
  },
  {
    "text": "asynchronous work items and hopefully we can recruit them to the party as well as synchronous work atoms are",
    "start": "1062520",
    "end": "1069880"
  },
  {
    "text": "associated with the windows object and they're executed as synchronously once an operation on the object was",
    "start": "1069880",
    "end": "1076280"
  },
  {
    "text": "completed all of these work items are C to the iio completion queue so before we dive into how a",
    "start": "1076280",
    "end": "1083720"
  },
  {
    "text": "synchronous work ads are cued let me first explain what the io completion queue is so the completion queue is a Windows",
    "start": "1083720",
    "end": "1091360"
  },
  {
    "text": "object that serves as a queue for completed I/O operations notifications are inserted",
    "start": "1091360",
    "end": "1096919"
  },
  {
    "text": "into the queue once an i operation completes so we can see the que on the",
    "start": "1096919",
    "end": "1102039"
  },
  {
    "text": "left side of the diagram and once U you can see the sorry the I operation and once the ey operation on the left side",
    "start": "1102039",
    "end": "1107320"
  },
  {
    "text": "is completed a notification is cued to the que on the right side now the thread P relies on the completion queue to",
    "start": "1107320",
    "end": "1113960"
  },
  {
    "text": "receive notification when an as synchronous work atems operation is",
    "start": "1113960",
    "end": "1119120"
  },
  {
    "text": "completed the kernel exposes few system calls to interact with um completion cues have um the create system call to",
    "start": "1119280",
    "end": "1126240"
  },
  {
    "text": "create a queue an open system call to open an existing queue also have aquari and set system calls which are again",
    "start": "1126240",
    "end": "1132320"
  },
  {
    "text": "getter and set or for kernel object and we have a remove system call used to remove an entry from the queue",
    "start": "1132320",
    "end": "1139640"
  },
  {
    "text": "now keep in mind the set system call which is used to Quee notification to the que we will get back to the system",
    "start": "1139640",
    "end": "1145200"
  },
  {
    "text": "call later on equipped with some better",
    "start": "1145200",
    "end": "1151520"
  },
  {
    "text": "understanding of fire completion cues let's jump right into the queuing mechanism of the asynchronous work items I'll use the TP work item as an",
    "start": "1151520",
    "end": "1159600"
  },
  {
    "text": "example but note that the same Concepts apply to the other asynchronous work items as well they're all CED in a very",
    "start": "1159600",
    "end": "1166080"
  },
  {
    "text": "similar manner so the TP work item is a work item that is intended to execute on",
    "start": "1166080",
    "end": "1172960"
  },
  {
    "text": "completion of file operations such as read and write the helper of the TP work item is",
    "start": "1172960",
    "end": "1179640"
  },
  {
    "text": "the direct structure so we expect this structure to be um queued into the",
    "start": "1179640",
    "end": "1184880"
  },
  {
    "text": "completion queue the function that's responsible for associating the work atoms file with",
    "start": "1184880",
    "end": "1192000"
  },
  {
    "text": "the completion queue is the TP bind file to direct function and this function sets the file completion que to be the",
    "start": "1192000",
    "end": "1198760"
  },
  {
    "text": "red plus completion q and the file completion key to be the direct structure which is the helper",
    "start": "1198760",
    "end": "1205200"
  },
  {
    "text": "structure so consider that we have a helper uh sorry so that we have a file object without a defined q and an empty",
    "start": "1205200",
    "end": "1212520"
  },
  {
    "text": "key and you can see the file object illustration on the left and we also have an empty",
    "start": "1212520",
    "end": "1218600"
  },
  {
    "text": "completion Q object which you can see on the right calling the TP bind file to direct",
    "start": "1218600",
    "end": "1224760"
  },
  {
    "text": "function will result in the completion Quee of the file object point to the thre P completion q and the completion",
    "start": "1224760",
    "end": "1231480"
  },
  {
    "text": "key pointing to the direct structure now at that point you will notice that the completion que is still",
    "start": "1231480",
    "end": "1237919"
  },
  {
    "text": "empty as no operation on the file occurred yet any operation on the file following",
    "start": "1237919",
    "end": "1244760"
  },
  {
    "text": "the function call for example right file would cause the completion key to",
    "start": "1244760",
    "end": "1250240"
  },
  {
    "text": "be cued to the completion Q so you can see that the notification was Q to the Q as a result of the right file",
    "start": "1250240",
    "end": "1257360"
  },
  {
    "text": "operation so so to conclude a synchronous work items are queued to the completion queue and the direct",
    "start": "1257360",
    "end": "1263600"
  },
  {
    "text": "structure is the field that is cued adding a handle to the completion",
    "start": "1263600",
    "end": "1268679"
  },
  {
    "text": "Quee of the target process gives us the ability to Q notifications to it so with that let me show you the",
    "start": "1268679",
    "end": "1276520"
  },
  {
    "text": "third brand new and fully undetectable process injection technique of the",
    "start": "1276520",
    "end": "1281640"
  },
  {
    "text": "day would start off by getting the handle table of the target process we then iterate over the table",
    "start": "1281640",
    "end": "1288240"
  },
  {
    "text": "and we duplicate the iio completion handle of the target thread pool notice that this time we do not need the worker",
    "start": "1288240",
    "end": "1294520"
  },
  {
    "text": "Factory objects we then create an innocent file on the",
    "start": "1294520",
    "end": "1299600"
  },
  {
    "text": "system and following the file creation we create a malicious dpio work",
    "start": "1299600",
    "end": "1305520"
  },
  {
    "text": "item we then allocate memory for the work item on the target process and following the allocation we",
    "start": "1305520",
    "end": "1312840"
  },
  {
    "text": "write the malicious work item to the Target process and at that point you will notice that the malicious work item",
    "start": "1312840",
    "end": "1317919"
  },
  {
    "text": "is not ass associated with a completion CU so next we use the set anti set",
    "start": "1317919",
    "end": "1324559"
  },
  {
    "text": "information file system call to associate the innocent file that we've just created with the target thread P",
    "start": "1324559",
    "end": "1329960"
  },
  {
    "text": "completion que we also set the completion key to point to the direct structure of the",
    "start": "1329960",
    "end": "1335480"
  },
  {
    "text": "malicious work atem that we have just written lastly we write content to the",
    "start": "1335480",
    "end": "1341440"
  },
  {
    "text": "innocent file we created which causes the malicious work item to execute so a",
    "start": "1341440",
    "end": "1346480"
  },
  {
    "text": "completely legitimate action such as writing to a file caused a malicious code shell code to get executed in a",
    "start": "1346480",
    "end": "1353080"
  },
  {
    "text": "victim process this capability is insane now you may ask yourself how we",
    "start": "1353080",
    "end": "1360679"
  },
  {
    "text": "also insert the other as synchronous work items the job alpc and weight workk",
    "start": "1360679",
    "end": "1365919"
  },
  {
    "text": "items so basically any TP direct notification CU to the completion queue",
    "start": "1365919",
    "end": "1370960"
  },
  {
    "text": "will get executed it is all a matter of how we Quee the notification to the",
    "start": "1370960",
    "end": "1377279"
  },
  {
    "text": "queue we you can achieve notification queuing in two ways the first way would be um very similar to the tpao abuse we",
    "start": "1377279",
    "end": "1384320"
  },
  {
    "text": "just showed it will involve associating the windows object with the completion queue of the target process and having",
    "start": "1384320",
    "end": "1390799"
  },
  {
    "text": "the key pointing to the malicious work item so then any operation on the object following the",
    "start": "1390799",
    "end": "1396720"
  },
  {
    "text": "association will result in the malicious work atem to execute we can also use um the anti",
    "start": "1396720",
    "end": "1404960"
  },
  {
    "text": "completion system call that we have mentioned earlier to Q notifications to to the queue um and this time we did not need",
    "start": "1404960",
    "end": "1411720"
  },
  {
    "text": "to prox it through a Windows object basically the moment that we call this API to que notification the malicious",
    "start": "1411720",
    "end": "1417600"
  },
  {
    "text": "work ad will execute so please welcome in five new",
    "start": "1417600",
    "end": "1422760"
  },
  {
    "text": "friends to the pool party and our new friends include the four synchronous work items the io LPC weight and job",
    "start": "1422760",
    "end": "1429919"
  },
  {
    "text": "work items and it also contains a TB direct insertion then directly by the anti set iio completion system",
    "start": "1429919",
    "end": "1437440"
  },
  {
    "text": "goal now our pool party is almost complete but we've got one final work item that",
    "start": "1437440",
    "end": "1444679"
  },
  {
    "text": "has not joined the fun yet we did not want to neglect the timer so let's see",
    "start": "1444679",
    "end": "1450600"
  },
  {
    "text": "if we can recruit one last friend to the party and bear with me for this one",
    "start": "1450600",
    "end": "1456080"
  },
  {
    "text": "because this one is even cooler than the last variants you would not want to miss a variant that is able to trigger after",
    "start": "1456080",
    "end": "1461960"
  },
  {
    "text": "the attacker already vanished from the system so first when looking at the",
    "start": "1461960",
    "end": "1467880"
  },
  {
    "text": "timer work atom creation and submission API I noticed an interesting fact no",
    "start": "1467880",
    "end": "1473919"
  },
  {
    "text": "timer handle is supplied we can see that the submission API set rpol timer accept some timer",
    "start": "1473919",
    "end": "1481159"
  },
  {
    "text": "configurations such as due time period but where does the actual timer object",
    "start": "1481159",
    "end": "1487960"
  },
  {
    "text": "reside it turns out that the ther work items operate on an existing timer object which resides in the timer",
    "start": "1487960",
    "end": "1495320"
  },
  {
    "text": "que and so once the submission API is called the work atem is inserted into the queue",
    "start": "1495320",
    "end": "1501279"
  },
  {
    "text": "and the timer object resting in the queue is configured accordingly accordingly to the user supplied",
    "start": "1501279",
    "end": "1507799"
  },
  {
    "text": "data then once the timer is expired a deqing function is called which dqes the timer work atem and executes",
    "start": "1507799",
    "end": "1515240"
  },
  {
    "text": "it now generally speaking timers in windows are not they do not natively",
    "start": "1515240",
    "end": "1521159"
  },
  {
    "text": "support callback execution in expiration all you need to know about it is that the threadpool implements it by",
    "start": "1521159",
    "end": "1527520"
  },
  {
    "text": "using the TP nwork item which supports timers so to conclude if we set the",
    "start": "1527520",
    "end": "1534600"
  },
  {
    "text": "timer residing in the que to expire the deqing function is called now the question is how do we",
    "start": "1534600",
    "end": "1541360"
  },
  {
    "text": "correctly insert a timer to the que so the connectors between the timer",
    "start": "1541360",
    "end": "1548600"
  },
  {
    "text": "and the timer queue are the windows end links and Windows start links fields for the sake of Simplicity you can think of",
    "start": "1548600",
    "end": "1555200"
  },
  {
    "text": "these two Fields as list entries of double link list",
    "start": "1555200",
    "end": "1560240"
  },
  {
    "text": "the function that cues the timer to the que is named TPP andq timer and it",
    "start": "1561679",
    "end": "1566760"
  },
  {
    "text": "inserts the start links to the Q Windows start field and the end links to the Q Windows end",
    "start": "1566760",
    "end": "1572880"
  },
  {
    "text": "field so given a timer and an empty timer Q calling the TPP andq timer will result",
    "start": "1572880",
    "end": "1580440"
  },
  {
    "text": "in the timer Q start and end to point to the start and end links of the timer work",
    "start": "1580440",
    "end": "1585799"
  },
  {
    "text": "item which you can see on the monitor so the work item submission API is",
    "start": "1585799",
    "end": "1591200"
  },
  {
    "text": "responsible for two things one is to CU the time of work item to the timer queue and two is to",
    "start": "1591200",
    "end": "1599000"
  },
  {
    "text": "configure the timer object residing in the queue to configure it um accordingly",
    "start": "1599000",
    "end": "1604200"
  },
  {
    "text": "to the user Supply parameters now as a result of these two actions once the timer object expires",
    "start": "1604200",
    "end": "1610880"
  },
  {
    "text": "the deqing function executes deqing and executing the work",
    "start": "1610880",
    "end": "1615960"
  },
  {
    "text": "item so with that let me let me show you the last brand new and fully undetectable process injection technique",
    "start": "1615960",
    "end": "1622440"
  },
  {
    "text": "of the day we start off as usual by getting the",
    "start": "1622440",
    "end": "1627720"
  },
  {
    "text": "handle table of the target process we proceed by duplicating the work of factory",
    "start": "1627720",
    "end": "1633120"
  },
  {
    "text": "handle and then we query basic information from the worker Factory once we have the basic",
    "start": "1633120",
    "end": "1640000"
  },
  {
    "text": "information which includes um the target thread pool pointer we read um the threadpool structure from the target",
    "start": "1640000",
    "end": "1645640"
  },
  {
    "text": "process and we do it in order to obtain the timer CU Target timer CU which you can see on the victim",
    "start": "1645640",
    "end": "1651640"
  },
  {
    "text": "process we proceed by creating a malicious work item and then we allocate memory for the",
    "start": "1651640",
    "end": "1657480"
  },
  {
    "text": "work item on the target process and following the allocation we are writing the malicious work item to",
    "start": "1657480",
    "end": "1663399"
  },
  {
    "text": "the Target process then we use any writing",
    "start": "1663399",
    "end": "1668480"
  },
  {
    "text": "primitive to insert the malicious timer work item to the timer que residing in the um threadpool structure so you can",
    "start": "1668480",
    "end": "1675200"
  },
  {
    "text": "see that now um the timer the malicious timer and the timer que are connected because we just inserted the work ad",
    "start": "1675200",
    "end": "1681559"
  },
  {
    "text": "into the queue so all that is left to do is to trigger the deqing function and in order",
    "start": "1681559",
    "end": "1687279"
  },
  {
    "text": "to do that we're getting we first get the timer handle um that the timer Q uses we duplicate his handle and then we",
    "start": "1687279",
    "end": "1694760"
  },
  {
    "text": "set the timer to expire and this is where all the magic happens once the timer expires the malicious work atem",
    "start": "1694760",
    "end": "1702559"
  },
  {
    "text": "executes now what's even more crazy about this variation is that after setting the timer that attacker can exit",
    "start": "1702559",
    "end": "1709039"
  },
  {
    "text": "the process and erase its identity from the system as a result the system appears",
    "start": "1709039",
    "end": "1715240"
  },
  {
    "text": "clean and only when the timer runs out the malicious work atom executes you can set the timer to expire in 1 minute or",
    "start": "1715240",
    "end": "1722360"
  },
  {
    "text": "in 10 hours eventually it will execute so did you ever think that",
    "start": "1722360",
    "end": "1727679"
  },
  {
    "text": "expiration of a timer will trigger a malicious malicious Shell Code in a Target process me neither so with that please",
    "start": "1727679",
    "end": "1736880"
  },
  {
    "text": "welcome in our last friend in the pool party and with eight friends in the",
    "start": "1736880",
    "end": "1742159"
  },
  {
    "text": "party let me introduce you to the pool party tool for the first time",
    "start": "1742159",
    "end": "1747640"
  },
  {
    "text": "ever so pool party supports eight variants starting from the starting abuse to the insertion of any work atem",
    "start": "1747640",
    "end": "1754399"
  },
  {
    "text": "that the threadpool supports pool party effectively bypasses",
    "start": "1754399",
    "end": "1759919"
  },
  {
    "text": "po Alto cordex Sentinel one crowd strike EDR Microsoft Defender for endpoint and",
    "start": "1759919",
    "end": "1765600"
  },
  {
    "text": "cyber reason and these vendors are leaders on endpoint protection according to Gardner's magic",
    "start": "1765600",
    "end": "1772120"
  },
  {
    "text": "quadrant P party achieved the 100% success rate as none of the edrs that I have tested was able to detect or",
    "start": "1772120",
    "end": "1778760"
  },
  {
    "text": "prevent pool party attacks now let me show you the first ever demo of pool party in",
    "start": "1778760",
    "end": "1786720"
  },
  {
    "text": "action so we start by making sure that the security solution is up and running this time we're using um cross",
    "start": "1786720",
    "end": "1792960"
  },
  {
    "text": "strike we then locate the noted process which we want to inject code into and we use create mod thread the known",
    "start": "1792960",
    "end": "1799399"
  },
  {
    "text": "injection to inject code into notepad you can see that the EDR detects it as malicious so we proceed um to use pool",
    "start": "1799399",
    "end": "1807840"
  },
  {
    "text": "party to introduce pool party you can see it supports all of date variants so we start by injecting code",
    "start": "1807840",
    "end": "1813840"
  },
  {
    "text": "using variant one the code we inject will spawn child process under noted so you can see our attack or control child",
    "start": "1813840",
    "end": "1819840"
  },
  {
    "text": "process under noted so we proceed to the second variant and the third variant and",
    "start": "1819840",
    "end": "1825679"
  },
  {
    "text": "the fourth variant and so on what's interesting here is that notepad is running as",
    "start": "1825679",
    "end": "1831640"
  },
  {
    "text": "usual and until and once we finish the attack you can see that we have H child",
    "start": "1831640",
    "end": "1837000"
  },
  {
    "text": "processes under notepad without a single detection being",
    "start": "1837000",
    "end": "1842398"
  },
  {
    "text": "raised so to conclude a party this is how we started a pretty lame party if",
    "start": "1843519",
    "end": "1849039"
  },
  {
    "text": "you ask me and this is how it is going right now much better isn't",
    "start": "1849039",
    "end": "1856039"
  },
  {
    "text": "it now before we conclude presentation I promised you that I will show you how I manage to perform evasive credential",
    "start": "1856039",
    "end": "1863000"
  },
  {
    "text": "dumping and ransomware attacks all while staying",
    "start": "1863000",
    "end": "1868200"
  },
  {
    "text": "untouched so let me demonstrate how by utilizing pool party attacks I manage to dump the memory of the sensitive elas",
    "start": "1868519",
    "end": "1875120"
  },
  {
    "text": "process without the single detection being raised so we start by making sure that",
    "start": "1875120",
    "end": "1880799"
  },
  {
    "text": "the security solution is up and running this time we're using pal to Cortex then we locate the El P and we",
    "start": "1880799",
    "end": "1889200"
  },
  {
    "text": "try to dump it using a known um a known method you can see that Paul Alta",
    "start": "1889200",
    "end": "1894720"
  },
  {
    "text": "detects it as malicious because by no means it is legitimate to dump the memory of elas from an attacker Control",
    "start": "1894720",
    "end": "1900600"
  },
  {
    "text": "process but what if it could make elas dump the memory of itself for us so we",
    "start": "1900600",
    "end": "1906080"
  },
  {
    "text": "go ahead and use pool party variant seven but basically any variant could be used to inject code into us making it",
    "start": "1906080",
    "end": "1912760"
  },
  {
    "text": "dump the memory of itself for us you can see that the dump file was created in the dumps folder",
    "start": "1912760",
    "end": "1918399"
  },
  {
    "text": "that windy buug can help us take a look on the dam",
    "start": "1918399",
    "end": "1922518"
  },
  {
    "text": "file so if we use the analyze command on the dam file you will see that it",
    "start": "1923679",
    "end": "1929320"
  },
  {
    "text": "belongs to the elas process you can see on the Monitor and such D file can be further analyzed to extract credentials",
    "start": "1929320",
    "end": "1935559"
  },
  {
    "text": "from it and other sensitive information another example of a feature",
    "start": "1935559",
    "end": "1942320"
  },
  {
    "text": "that could be completely bypassed is Windows defender's controll folder access feature this feature is used to protect",
    "start": "1942320",
    "end": "1949440"
  },
  {
    "text": "specific folders against ransomware attacks so let me show you how by utilizing pool party attacks we can",
    "start": "1949440",
    "end": "1955559"
  },
  {
    "text": "completely circumvent this feature executing a non-detectable ransomware",
    "start": "1955559",
    "end": "1961159"
  },
  {
    "text": "attack so we would start by making sure that Windows Defender is up and running and also by making sure that the control",
    "start": "1961159",
    "end": "1968159"
  },
  {
    "text": "folder access feature is enabled you can see that it is enabled and if you look at the protected folders",
    "start": "1968159",
    "end": "1974679"
  },
  {
    "text": "you can see that that the documents folder is a protected folder and if if we go ahead and look at the contents of",
    "start": "1974679",
    "end": "1979960"
  },
  {
    "text": "the documents folder you can see some sensitive data such as background checks and back bank accounts which um looks",
    "start": "1979960",
    "end": "1985799"
  },
  {
    "text": "tempting for an attacker to encrypt so we use a normal ransomware to try and go ahead and encrypt the",
    "start": "1985799",
    "end": "1992600"
  },
  {
    "text": "documents folder and once we execute the ransomware you can see that um we're",
    "start": "1992600",
    "end": "1998399"
  },
  {
    "text": "enable to access any file on the documents folder and Windows Defender is not happy about our",
    "start": "1998399",
    "end": "2004679"
  },
  {
    "text": "attempt but what if we make a trusted process to do the encryption for us so",
    "start": "2004679",
    "end": "2010279"
  },
  {
    "text": "we try to inject code into Explorer and you can see um we're again using variant",
    "start": "2010279",
    "end": "2015760"
  },
  {
    "text": "five but any variant could be used we inject code that will encrypt the documents folder for us you can see that",
    "start": "2015760",
    "end": "2022440"
  },
  {
    "text": "once that tack was completed all of the files in the documents folder are encrypted and Windows Defender does not",
    "start": "2022440",
    "end": "2029440"
  },
  {
    "text": "seem to mind so what are the takeaways for this",
    "start": "2029440",
    "end": "2036320"
  },
  {
    "text": "talk first although edrs have evolved with the years the current detection approach",
    "start": "2036320",
    "end": "2041600"
  },
  {
    "text": "employed is not strong enough to generically detect new process injection techniques the threat pool is not the",
    "start": "2041600",
    "end": "2048599"
  },
  {
    "text": "last feature to be abused for process injections and there is a need for a better and generic detection in in",
    "start": "2048599",
    "end": "2055800"
  },
  {
    "text": "place now in addition the impact of an undetectable process injection is larger than we thought it is not only about",
    "start": "2055800",
    "end": "2062760"
  },
  {
    "text": "being stealth and persistent anymore process injection could also be used for an detectable credential",
    "start": "2062760",
    "end": "2068599"
  },
  {
    "text": "dumping and ransomware file encryptions and this is just the tip of the iceberg now lastly we need to enhance",
    "start": "2068599",
    "end": "2075040"
  },
  {
    "text": "our focus on detecting anomalies rather than placing complete trust in processes based solely in their identity This",
    "start": "2075040",
    "end": "2082240"
  },
  {
    "text": "research just demonstrated that executing code on the behalf of a trusted process can go undetected and",
    "start": "2082240",
    "end": "2088200"
  },
  {
    "text": "this underscores the importance of analyzing the actions that such processes",
    "start": "2088200",
    "end": "2094638"
  },
  {
    "text": "do this is the QR code and link to the po party G up repository it is now",
    "start": "2094879",
    "end": "2100119"
  },
  {
    "text": "public and I encourage you to try it and test yourself I will be taking questions in",
    "start": "2100119",
    "end": "2105800"
  },
  {
    "text": "the hall and also feel free to reach me out on social media and with that I'd",
    "start": "2105800",
    "end": "2110839"
  },
  {
    "text": "like to thank you all for joining me today I've had a lot of fun and I hope you did too thank [Applause]",
    "start": "2110839",
    "end": "2119800"
  },
  {
    "text": "you",
    "start": "2120200",
    "end": "2123200"
  }
]