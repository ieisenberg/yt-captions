[
  {
    "text": "[Music]",
    "start": "3860",
    "end": "13658"
  },
  {
    "text": "hello everyone my name is christopher wade and we're going to talk about embedded mobile chipsets today and how you can write customer",
    "start": "15280",
    "end": "21359"
  },
  {
    "text": "firmware for them i am a security consultant at pen test partners where i mainly work with automotive hardware and maritime",
    "start": "21359",
    "end": "27840"
  },
  {
    "text": "equipment but today we're going to be talking about embedded chipsets in their entirety especially on mobile devices",
    "start": "27840",
    "end": "34239"
  },
  {
    "text": "the origin of this project was that i had rooted several phones and found that while i could modify certain aspects of the operating system i couldn't modify",
    "start": "34239",
    "end": "40879"
  },
  {
    "text": "the hardware capabilities of them in any meaningful manner while it was still possible in certain ways it was not possible in",
    "start": "40879",
    "end": "46480"
  },
  {
    "text": "their entirety so it couldn't modify certain closed-sourced enclosed hardware elements of the devices such as",
    "start": "46480",
    "end": "52879"
  },
  {
    "text": "hardware peripherals such as bluetooth while it is possible via um certain kernel modifications or changes",
    "start": "52879",
    "end": "60000"
  },
  {
    "text": "to configurations to get monitor mode it does require a custom firmware for things like broadcom chipsets",
    "start": "60000",
    "end": "66320"
  },
  {
    "text": "the usb device emulation as well is quite an interesting uh feature that can be added to on android phones with a certain amount of effort",
    "start": "66320",
    "end": "73200"
  },
  {
    "text": "if you modify your kernel so that it implements all the usb functionality modules that you want instead of just the static one",
    "start": "73200",
    "end": "79520"
  },
  {
    "text": "for android you can implement things like gadget fs which allows you to emulate any kind of usb device you want to fire",
    "start": "79520",
    "end": "85840"
  },
  {
    "text": "user space applications but i want to talk about nfc more than anything which is something i'm very",
    "start": "85840",
    "end": "91600"
  },
  {
    "text": "interested in and is quite limited on android hardware as it is for instance on android even with root",
    "start": "91600",
    "end": "98079"
  },
  {
    "text": "access you're limited to generic reading mobile payments and death communication and host card communication",
    "start": "98079",
    "end": "103600"
  },
  {
    "text": "the last of which is communication that allows you to emulate certain amounts of nfc attacks but not in their entirety",
    "start": "103600",
    "end": "109520"
  },
  {
    "text": "well this allows you to do certain things like relay attacks which may be useful for an attacker who wants to commit fraud etcetera it's not very useful for",
    "start": "109520",
    "end": "116640"
  },
  {
    "text": "other use cases if you were to make an nfc attack tool you'd want to implement",
    "start": "116640",
    "end": "121840"
  },
  {
    "text": "slightly more complex functionality such as emulation of a reader to attack cryptography on an nfc",
    "start": "121840",
    "end": "128319"
  },
  {
    "text": "tag or emulate the tag itself in order to perform attacks that are only possible from that endpoint",
    "start": "128319",
    "end": "133680"
  },
  {
    "text": "or you may want to be able to passively sniff tags like you would with a prox mark or a chameleon device",
    "start": "133680",
    "end": "138959"
  },
  {
    "text": "my first target was my samsung s6 which is quite an old phone but one i had readily available and unlocked using the standard samsung",
    "start": "138959",
    "end": "145599"
  },
  {
    "text": "oem unlocking and custom rom functionality i found that in my samsung device which was a non-us",
    "start": "145599",
    "end": "151200"
  },
  {
    "text": "phone it had a samsung semiconductor nfc chip that was completely custom and developed by samsung for their devices",
    "start": "151200",
    "end": "158160"
  },
  {
    "text": "this was called the s3fw rn5 which was a custom chip developed by samsung semiconductor",
    "start": "158160",
    "end": "164400"
  },
  {
    "text": "it has the ability to update firmware security securely and is found in samsung s6's and samsung",
    "start": "164400",
    "end": "170160"
  },
  {
    "text": "note 4 devices which are were manufactured in 2014 and 2015. it was found to use an arm sc-00 secure",
    "start": "170160",
    "end": "177360"
  },
  {
    "text": "car architecture which is a embedded arm architecture used for secure applications and was communicated",
    "start": "177360",
    "end": "182800"
  },
  {
    "text": "with on the phone via custom device drivers which communicate with the i2c and gpio interfaces of the",
    "start": "182800",
    "end": "188720"
  },
  {
    "text": "device inside communication which is how nfc chips are communicated with via",
    "start": "188720",
    "end": "194720"
  },
  {
    "text": "host devices is quite a simple protocol essentially you have a group id",
    "start": "194720",
    "end": "200800"
  },
  {
    "text": "operation id length and payload which are used in conjunction to configure certain settings or to read certain data from the device",
    "start": "200800",
    "end": "207360"
  },
  {
    "text": "in order to configure specific nfc functionality while this does make nfc quite simple it also restricts it",
    "start": "207360",
    "end": "213440"
  },
  {
    "text": "quite heavily there's also non-standard functionality built into this protocol however such as vendor group ids which are group ids",
    "start": "213440",
    "end": "220720"
  },
  {
    "text": "which allow a vendor to implement any functionality they need whatsoever they may use this for configuration of certain hardware that's not standard",
    "start": "220720",
    "end": "227120"
  },
  {
    "text": "or they may use it to add certain debugging functionality that they'd want later on in the project",
    "start": "227120",
    "end": "232480"
  },
  {
    "text": "but what this is never used for is firmware updates which is a key aspect of any embedded chipset",
    "start": "232480",
    "end": "238959"
  },
  {
    "text": "the device itself is was found to set whether it was in bootloader for firmware updates or regular mode via",
    "start": "238959",
    "end": "245599"
  },
  {
    "text": "a gpio input which could be set by the driver and i found that when you switched it into bootloader mode it had a slightly",
    "start": "245599",
    "end": "251920"
  },
  {
    "text": "different protocol than nci but only slightly different what was this was used for was to",
    "start": "251920",
    "end": "258400"
  },
  {
    "text": "differentiate differentiate itself from nci in order to allow the vendor partition",
    "start": "258400",
    "end": "265280"
  },
  {
    "text": "and the vendor implementations of certain aspects of the firmware to upload update this chipset and use it",
    "start": "265280",
    "end": "271440"
  },
  {
    "text": "to do different things this firmware update protocol was quite simple i pulled these traces from logcat just by running",
    "start": "271440",
    "end": "277680"
  },
  {
    "text": "logcat while doing a firmware update and found that it was made up of a command type which was",
    "start": "277680",
    "end": "283120"
  },
  {
    "text": "usually zero one or two a command which was uh based on what aspect of the firmware",
    "start": "283120",
    "end": "288400"
  },
  {
    "text": "update was being performed and the payload size which was two bytes but was limited to only 256 bytes in total",
    "start": "288400",
    "end": "294160"
  },
  {
    "text": "as well as a parity bit at the top of each command and type in order to set where they were in",
    "start": "294160",
    "end": "299520"
  },
  {
    "text": "the firmware update process the firmware update files used had a very basic format they had some metadata",
    "start": "299520",
    "end": "305440"
  },
  {
    "text": "highlighted in red which was the date that the firmware was made a signature which is",
    "start": "305440",
    "end": "311280"
  },
  {
    "text": "highlighted in green which was just a simple rsa signature and highlighted in blue was the start of the firmware",
    "start": "311280",
    "end": "317280"
  },
  {
    "text": "which i found to be standard arm update firmware there's a way to um",
    "start": "317280",
    "end": "323840"
  },
  {
    "text": "identify this quite quickly just by using a simple mnemonic if you run strings on a firmware update",
    "start": "323840",
    "end": "329199"
  },
  {
    "text": "that's unencrypted and search for the uh string the characters lowercase p and upcase g",
    "start": "329199",
    "end": "334479"
  },
  {
    "text": "you'll quickly find that a lot of these get dumped out if it is using some code which is the shortened architecture",
    "start": "334479",
    "end": "340960"
  },
  {
    "text": "used by arm because lowercase p and upcase g translates to 1747 in ascii",
    "start": "340960",
    "end": "346960"
  },
  {
    "text": "which is the the xlr or branch and link operation used by uh",
    "start": "346960",
    "end": "354240"
  },
  {
    "text": "armed devices in order to return from functions you can quickly identify lots of areas",
    "start": "354240",
    "end": "360319"
  },
  {
    "text": "where this has been used when this is found in large quantities it usually means that",
    "start": "360319",
    "end": "366160"
  },
  {
    "text": "it's using arm firmware a good way to implement firmware updates is just by you replaying all the",
    "start": "366160",
    "end": "371759"
  },
  {
    "text": "commands that you've dumped in sequence you don't necessarily need to know how the protocol works as long as you can send commands in exactly the same orders",
    "start": "371759",
    "end": "377440"
  },
  {
    "text": "they sent before these things are usually immutable just due to how the signature checking and hash checking are implemented what i did",
    "start": "377440",
    "end": "384319"
  },
  {
    "text": "was use that log cat made a huge number of byte arrays and cycled through them while making sure that in io controls used and pulled from the",
    "start": "384319",
    "end": "391680"
  },
  {
    "text": "open source kernel drivers for this chip were used looking at this further and looking at",
    "start": "391680",
    "end": "397840"
  },
  {
    "text": "this open source uh driver i found that it had commands well defined in there for me to",
    "start": "397840",
    "end": "403680"
  },
  {
    "text": "look at so command zero was defined as reset command one was boot info command 2 was",
    "start": "403680",
    "end": "408800"
  },
  {
    "text": "beginning the updates command 4 was to update specific sectors which included a address and the data itself and 5 which",
    "start": "408800",
    "end": "415759"
  },
  {
    "text": "verified the signature and hash together in order to complete the update because",
    "start": "415759",
    "end": "420800"
  },
  {
    "text": "there was no command 3 it made me think that there were some hidden commands that weren't used by the firmware update but may have some extra",
    "start": "420800",
    "end": "426160"
  },
  {
    "text": "functionality i could easily identify hidden bootloader commands just by seeing what errors were returned by the chip when i",
    "start": "426160",
    "end": "432400"
  },
  {
    "text": "sent certain commands if it returned to it meant that the commands were not valid at that stage of the firmware update",
    "start": "432400",
    "end": "438560"
  },
  {
    "text": "process and what i did was process through each step of the firmware update process while using these different supposed command states however if the chip",
    "start": "438560",
    "end": "445120"
  },
  {
    "text": "returned to nine i was able to see that the payload was just too small and if i increase the size eventually i'd get a different",
    "start": "445120",
    "end": "450479"
  },
  {
    "text": "error which would let me know the minimum size of the commands being sent brute forcing through this allowed me to find that command 3 was just",
    "start": "450479",
    "end": "457039"
  },
  {
    "text": "a different version of command 4. however instead of sending the 4096 blocks used by command 4 it sent 512 instead",
    "start": "457039",
    "end": "464960"
  },
  {
    "text": "however command 6 was also noted and was much more interesting command 6 was found to take eight bytes",
    "start": "464960",
    "end": "471599"
  },
  {
    "text": "of parameters which was two 32-bit values by setting random bits inside these parameters i found that it would dump",
    "start": "471599",
    "end": "477759"
  },
  {
    "text": "out arbitrary memory from the chip but and allowed me to work out that this was taking an address and under size",
    "start": "477759",
    "end": "483440"
  },
  {
    "text": "for data being returned using this i could damp ram firmware uh hidden hardware registers",
    "start": "483440",
    "end": "490080"
  },
  {
    "text": "and the secure bootloader meaning i could reverse engineer this i stitched this bootloader together and",
    "start": "490080",
    "end": "495680"
  },
  {
    "text": "found that it used a standard cortex-m firmware format so this would be the start of the first",
    "start": "495680",
    "end": "501199"
  },
  {
    "text": "bytes would be the start of the stack and the next bytes would be the reset vector used to start up the chip",
    "start": "501199",
    "end": "506800"
  },
  {
    "text": "looking at these together i could easily disassemble this in any disassembler i had however because this is a embedded",
    "start": "506800",
    "end": "513120"
  },
  {
    "text": "firmware had very few strings and i'd have to look at everything by hand statically there are a few interesting artifacts in",
    "start": "513120",
    "end": "519279"
  },
  {
    "text": "here so all the firmware was deployed was found to be stored starting at address 3000 and in",
    "start": "519279",
    "end": "525360"
  },
  {
    "text": "the firmware itself i found that the first four bytes of the firmware were always fff fff",
    "start": "525360",
    "end": "531200"
  },
  {
    "text": "however i found that the firmware update would overwrite this with 5if00fa 5 which was found to be",
    "start": "531200",
    "end": "537040"
  },
  {
    "text": "a magic number used to verify whether the firmware update was indeed valid and the signature had been checked during updates",
    "start": "537040",
    "end": "542640"
  },
  {
    "text": "i tried to stick this particular value in straight away in a completely invalid firmware and found that this didn't work",
    "start": "542640",
    "end": "548399"
  },
  {
    "text": "and that the bootloader checked whether the first value was always ffff i also found the state machine which",
    "start": "548399",
    "end": "555360"
  },
  {
    "text": "checked which commands were being received so we have zero one two and six which were the commands that were available at the start of the firmware",
    "start": "555360",
    "end": "561279"
  },
  {
    "text": "update process and i can look through to see that there were no other commands that were in use during this process",
    "start": "561279",
    "end": "567600"
  },
  {
    "text": "i also noted the rsa public key in memory which was interesting but not useful because it was quite high entropy",
    "start": "567600",
    "end": "574080"
  },
  {
    "text": "this can be easily identified by looking for zero zero zero one zero zero zero one which translates to six five five three",
    "start": "574080",
    "end": "579760"
  },
  {
    "text": "seven the exponent of our rsa public key and before this is usually 128 or a different size of high entropy",
    "start": "579760",
    "end": "587440"
  },
  {
    "text": "bytes which usually usually denote the modulus of the rsa public key",
    "start": "587440",
    "end": "593040"
  },
  {
    "text": "now because i now have the bootloader what i really wanted to do was find a memory corruption exploit in this bootloader",
    "start": "593040",
    "end": "598160"
  },
  {
    "text": "allowing me to have an immutable unchangeable way of adding custom firmware to this chip whenever i wanted to",
    "start": "598160",
    "end": "603680"
  },
  {
    "text": "now fuzzing my phone seemed like a bad idea at the time mainly due to the fact that if i broke",
    "start": "603680",
    "end": "608880"
  },
  {
    "text": "the chip i'd have to buy a new phone to look at it or find a way to unbrick it which would involve some hard work modification",
    "start": "608880",
    "end": "614079"
  },
  {
    "text": "which i didn't want to do also due to the fact that the only",
    "start": "614079",
    "end": "619200"
  },
  {
    "text": "endpoint i had into the device was i2c debugging an analysis would be very difficult due to this i decided to",
    "start": "619200",
    "end": "625040"
  },
  {
    "text": "emulate the bootloader as much as i could i decided to use the unicorn engine for this which is a library which",
    "start": "625040",
    "end": "630880"
  },
  {
    "text": "is very powerful allows one to implement different firmware types using different architectures",
    "start": "630880",
    "end": "637440"
  },
  {
    "text": "in order to assess how it works and also run functionality that wouldn't necessarily be possible",
    "start": "637440",
    "end": "642480"
  },
  {
    "text": "on the architecture you're using it's sort of like a form of qmu except inside applications rather than",
    "start": "642480",
    "end": "647680"
  },
  {
    "text": "something to run applications themselves um i loaded my bootloader into address",
    "start": "647680",
    "end": "652880"
  },
  {
    "text": "zero as it would be in the actual device i set the program counter to the reset vector which is found in the bootloader",
    "start": "652880",
    "end": "658079"
  },
  {
    "text": "and i met memory for hardware registers ram and flash ready to start fuzzing this protocol",
    "start": "658079",
    "end": "665120"
  },
  {
    "text": "however a key aspect of this was the fact that even though i'd implement i'd use unicorn engine i wouldn't be able to",
    "start": "665120",
    "end": "673839"
  },
  {
    "text": "emulate the hardware as easily because it just simply didn't exist and it was completely new and no one had ever seen it before",
    "start": "673839",
    "end": "680160"
  },
  {
    "text": "especially in this format what i did is let the firmware run until it started reading from the hardware addresses",
    "start": "680160",
    "end": "685920"
  },
  {
    "text": "which started ox 4000. i found that it started reading a specific address during startup",
    "start": "685920",
    "end": "692240"
  },
  {
    "text": "and was checking for specific bits in the firmware in this register in order to identify",
    "start": "692240",
    "end": "698560"
  },
  {
    "text": "certain aspects of the status i'd worked out that this was the status register for i2c so i made this always return randomized",
    "start": "698560",
    "end": "705040"
  },
  {
    "text": "data meaning that the status of the itc bus would be deemed to be doing something at the time and",
    "start": "705040",
    "end": "710800"
  },
  {
    "text": "would move past this state next i found the firmware continually reading bytes from another address",
    "start": "710800",
    "end": "716800"
  },
  {
    "text": "which was um close to the original and found that this was likely to be the itc fifo buffer due to the fact that it was",
    "start": "716800",
    "end": "722000"
  },
  {
    "text": "loading any bytes inputted from this into a buffer i started sending firmware update",
    "start": "722000",
    "end": "728079"
  },
  {
    "text": "commands via this register by looking into unicorn engine and found that it would then start sending data",
    "start": "728079",
    "end": "734560"
  },
  {
    "text": "on another address that was close in that area i found that this was sending responses to my i2c messages as the bootloader would",
    "start": "734560",
    "end": "741440"
  },
  {
    "text": "have because of this i had full emulation of the i2c communication of the bootloader and could start fuzzing it as needed",
    "start": "741440",
    "end": "746720"
  },
  {
    "text": "without having the potential of breaking my chip i started randomly fuzzing",
    "start": "746720",
    "end": "752160"
  },
  {
    "text": "the chip but found that it wasn't really viable and didn't do very much while commands have 16-bit sizes and",
    "start": "752160",
    "end": "757360"
  },
  {
    "text": "largely the entire contents of ram they were limited to only 256 bytes and i couldn't do much with that",
    "start": "757360",
    "end": "763040"
  },
  {
    "text": "um i did find that some commands would send additional data in chunks for instance when you were sending 4096",
    "start": "763040",
    "end": "770079"
  },
  {
    "text": "bytes of update data these were chunked into the 256 bytes that were permitted by the protocol however i also found",
    "start": "770079",
    "end": "776959"
  },
  {
    "text": "that the size of the hash and signature which was sent subsequent to the hash and signature command were defined in",
    "start": "776959",
    "end": "782240"
  },
  {
    "text": "the in this command and were modifiable by increasing the size of the hash and",
    "start": "782240",
    "end": "788240"
  },
  {
    "text": "signature sizes i could allow myself to send more and more data subsequently",
    "start": "788240",
    "end": "793360"
  },
  {
    "text": "for instance if i said that the hash the xiao1 hash was 200 bytes instead of the classic",
    "start": "793360",
    "end": "799200"
  },
  {
    "text": "amount i would be able to send that much data what i found was in my emulated chipset",
    "start": "799200",
    "end": "804320"
  },
  {
    "text": "this overwrote the stack and hit a invalid aspect of memory so over the 8k",
    "start": "804320",
    "end": "809440"
  },
  {
    "text": "of memory that was available because i could overwrite the stack i could change where the return pointers",
    "start": "809440",
    "end": "815519"
  },
  {
    "text": "were in the stack and change where the program counter would jump to after returning from these commands due to the fact that the am securecore",
    "start": "815519",
    "end": "822199"
  },
  {
    "text": "sc000 chipsets can't execute from ram i wouldn't be able to do anything simple like just write a bit of shell code",
    "start": "822199",
    "end": "828800"
  },
  {
    "text": "also because the stack was so small only being about 12 bytes at this point it was too uh small to do any complex",
    "start": "828800",
    "end": "834800"
  },
  {
    "text": "drop exploits in order to um get past this i what i did was just make it jump",
    "start": "834800",
    "end": "839920"
  },
  {
    "text": "the program counter into the signature checks at the start of the bootloader past the checks actually occurred and",
    "start": "839920",
    "end": "845360"
  },
  {
    "text": "it's the part where it loaded the address of the firmware and jumped into it which restarted the chip into the",
    "start": "845360",
    "end": "850800"
  },
  {
    "text": "core firmware i then perform this exploit on the physical chip and found that it worked",
    "start": "850800",
    "end": "856959"
  },
  {
    "text": "beautifully so i booted uh my bootloader sent my exploit and then noticed that after i'd run it",
    "start": "856959",
    "end": "865040"
  },
  {
    "text": "it would start behaving as the real firmware and i could send nci commands instead of firmware update commands",
    "start": "865040",
    "end": "870079"
  },
  {
    "text": "to the chip what i did was simply change the version number of the firmware just to",
    "start": "870079",
    "end": "875440"
  },
  {
    "text": "show that this signature checking had been bypassed and i could run my own custom firmware i then disclosed this to samsung now",
    "start": "875440",
    "end": "882079"
  },
  {
    "text": "there are two ways they could have uh fixed this now because it was a bootloader um level exploit it's a bit",
    "start": "882079",
    "end": "887120"
  },
  {
    "text": "more complicated than just updating the firmware they would have to patch the bootloader from the main firmware um",
    "start": "887120",
    "end": "892720"
  },
  {
    "text": "removing this buffer overflow uh vulnerability however while this was being undergone if",
    "start": "892720",
    "end": "898000"
  },
  {
    "text": "someone power cycled the chip or there was some kind of error the butler would loader would be left erased and they wouldn't ever be able to",
    "start": "898000",
    "end": "904880"
  },
  {
    "text": "restart it again leaving the nfc functionality of the chip completely non-functional because the chip wouldn't be able to start or they",
    "start": "904880",
    "end": "911440"
  },
  {
    "text": "could have patched the kernel to disallow large hashes and signatures however this was trivially bypassed just by kernel",
    "start": "911440",
    "end": "916800"
  },
  {
    "text": "modification if they did that i decided to look at other nfc chips that samsung had",
    "start": "916800",
    "end": "922959"
  },
  {
    "text": "used or developed rather and found that they were there were four that were in modern use the s3 and rn 74 s3 nrn81",
    "start": "922959",
    "end": "931120"
  },
  {
    "text": "s3 nrn82 and scn82ab i wanted to find these chipsets in",
    "start": "931120",
    "end": "937839"
  },
  {
    "text": "different samsung phones to see which one i should purchase in order to continue this research now because teardowns aren't always",
    "start": "937839",
    "end": "943680"
  },
  {
    "text": "available especially for um non-us devices it wouldn't be a simple task of just",
    "start": "943680",
    "end": "949440"
  },
  {
    "text": "google searching for these version numbers and phone types so what i ended up doing",
    "start": "949440",
    "end": "956880"
  },
  {
    "text": "was going to sam mobile.com which contains roms for almost every samsung device downloading them extracting them and",
    "start": "956880",
    "end": "963360"
  },
  {
    "text": "finding what um whether they had the firmware files embedded in them these are usually found in the slash",
    "start": "963360",
    "end": "969440"
  },
  {
    "text": "vendor directory and occasionally this is a separate partition but generally it's easy to find",
    "start": "969440",
    "end": "976000"
  },
  {
    "text": "looking through this i managed to find the s3n82 which is used by the samsung s9 as well as the samsung",
    "start": "976000",
    "end": "981279"
  },
  {
    "text": "s8 and that's something s10 however i decided to buy a samsung s9 for this purpose",
    "start": "981279",
    "end": "986480"
  },
  {
    "text": "um i found that had multiple chip firmware revisions just by looking at different roms which would be very helpful if i",
    "start": "986480",
    "end": "992160"
  },
  {
    "text": "needed to reverse engineer more and i found that the samsung s9 while it was secure from a routing",
    "start": "992160",
    "end": "997519"
  },
  {
    "text": "perspective you could use oem unlocking and a custom rom in order to root it appropriately to",
    "start": "997519",
    "end": "1002720"
  },
  {
    "text": "perform any attacks on it the firmware file was found to be almost exactly the same as the s3w iron five at",
    "start": "1002720",
    "end": "1008880"
  },
  {
    "text": "least in formatting so it had the same metadata signature and firmware payload however the reset vector of the firmware",
    "start": "1008880",
    "end": "1015040"
  },
  {
    "text": "which was found at the top of it was much smaller implying that the bootloader had been modified to be smaller and the firmware size were 32 kilobytes",
    "start": "1015040",
    "end": "1021759"
  },
  {
    "text": "larger which was corroborated with what was on the data sheets on samsung's website",
    "start": "1021759",
    "end": "1027199"
  },
  {
    "text": "i found that commands three and six these being the um smaller deployment of code command and the",
    "start": "1027199",
    "end": "1033120"
  },
  {
    "text": "firmware readout command no longer available however command seven was identified but all it did was",
    "start": "1033120",
    "end": "1038319"
  },
  {
    "text": "reboot the chip a new bootloader size implied that the firmware had what bootloader had been modified in some way",
    "start": "1038319",
    "end": "1044798"
  },
  {
    "text": "meaning that i'd probably have to uh do something a bit different in order to exploit this and due to the lack of",
    "start": "1044799",
    "end": "1050160"
  },
  {
    "text": "memory readout verifying what i'd done before would not be as easy and i'd have to do any expectation blind anyway",
    "start": "1050160",
    "end": "1056559"
  },
  {
    "text": "also i found that trying to upload firmware using a shower one hash was not possible anymore",
    "start": "1056559",
    "end": "1062720"
  },
  {
    "text": "because x1 because the itc communication was no longer provided by log cap i have to go looking around to see how",
    "start": "1063360",
    "end": "1069360"
  },
  {
    "text": "this was locked and found a device file called slash prog nfc log which contains sizes of all the",
    "start": "1069360",
    "end": "1075120"
  },
  {
    "text": "commands being written to the chip in sequence and found that at the start of firmer updates",
    "start": "1075120",
    "end": "1080640"
  },
  {
    "text": "um a largest hash size had written so instead of the sha1 hash size it was now sending 32",
    "start": "1080640",
    "end": "1087120"
  },
  {
    "text": "bytes plus the start the header of a command which was four bytes this implied that instead of",
    "start": "1087120",
    "end": "1092880"
  },
  {
    "text": "using sha1 hashes for firmware updates they were now using type 256 hashes which were compared against the signature",
    "start": "1092880",
    "end": "1099919"
  },
  {
    "text": "i verified this by modifying my firmware update tool because i no longer had any knowledge of",
    "start": "1099919",
    "end": "1107919"
  },
  {
    "text": "how the inner workings of the bootloader worked on this new bootloader i would have to guess quite a lot of how the exploitation worked due to the nature of device",
    "start": "1107919",
    "end": "1115120"
  },
  {
    "text": "crashes i could work this out however i decided to attempt the exact same exploit i did",
    "start": "1115120",
    "end": "1120320"
  },
  {
    "text": "before by increasing the size of the hashes until i overwrote the stack what i did",
    "start": "1120320",
    "end": "1125600"
  },
  {
    "text": "was keep adding more and more size to this stat to the size of the hash while sending more and more data now",
    "start": "1125600",
    "end": "1132799"
  },
  {
    "text": "just the nature of how the stack worked in this it would still return data even if i'd overrun the stack but then crash",
    "start": "1132799",
    "end": "1139200"
  },
  {
    "text": "however if i'd overwritten memory that being over the 12k that was now available the device wouldn't return after i sent",
    "start": "1139200",
    "end": "1144799"
  },
  {
    "text": "data to it meaning that i'd be able to work out the entire size of the memory i was accessing and overwrite it with any data i wanted",
    "start": "1144799",
    "end": "1150960"
  },
  {
    "text": "or any return pointers i wanted here's a quick demo of how this worked so because i didn't know",
    "start": "1150960",
    "end": "1157520"
  },
  {
    "text": "how where the program counter needed to jump to in the bootloader anymore but virtually the fact that i couldn't",
    "start": "1157520",
    "end": "1163360"
  },
  {
    "text": "see the bootloader what i ended up doing was processing from address one or other program counter",
    "start": "1163360",
    "end": "1168720"
  },
  {
    "text": "address zero plus one which is how thumb code addresses code in this manner and let it",
    "start": "1168720",
    "end": "1174400"
  },
  {
    "text": "run until it found an end point which a address which would allow it to jump into the raw firmware",
    "start": "1174400",
    "end": "1181760"
  },
  {
    "text": "we're hitting the end of this now so what this is doing is filling the entire stack with return pointers because i also",
    "start": "1181760",
    "end": "1187440"
  },
  {
    "text": "didn't know where the return pointers would be and what i found is when it got to address 165",
    "start": "1187440",
    "end": "1193360"
  },
  {
    "text": "that was the correct position for it to uh jump into the unsigned firmware and it",
    "start": "1193360",
    "end": "1199039"
  },
  {
    "text": "would allow me to bypass the signature checking i disclosed this vulnerability to samsung as well and they",
    "start": "1199039",
    "end": "1205520"
  },
  {
    "text": "have now patched it on all new manufactured chipsets from april 2020",
    "start": "1205520",
    "end": "1210559"
  },
  {
    "text": "and all future chipsets will be patched so that this doesn't occur however all the chipsets will still be",
    "start": "1210559",
    "end": "1217360"
  },
  {
    "text": "attackable using this approach and we'll still allow custom firmware to be developed",
    "start": "1217360",
    "end": "1223600"
  },
  {
    "text": "so because i could write custom firmware for any of these chips i decided to aim for the s3 nrn h2 as this was the",
    "start": "1223600",
    "end": "1229679"
  },
  {
    "text": "newest the fastest and had the most memory because i'd only be able to debug things very c it would be quite complex to",
    "start": "1229679",
    "end": "1235679"
  },
  {
    "text": "debug but at least i had something to work with i downloaded a firmware file that i",
    "start": "1235679",
    "end": "1240880"
  },
  {
    "text": "found inside a samsung s8 rom this being the oldest phone which used this chipset i",
    "start": "1240880",
    "end": "1246720"
  },
  {
    "text": "found that it had quite a lot of spare memory compared to the firmware that was used on the samsung s9",
    "start": "1246720",
    "end": "1252000"
  },
  {
    "text": "and i could use this to write patching machine code that i compiled as needed in order to do this",
    "start": "1252000",
    "end": "1259120"
  },
  {
    "text": "one all one needs to do is compile c functions using gcc-c all this does is create an object file",
    "start": "1259120",
    "end": "1265760"
  },
  {
    "text": "without any linking or relocation but gives you raw assembly to work with or rather raw machine code",
    "start": "1265760",
    "end": "1272480"
  },
  {
    "text": "stack handling is still handled appropriately with pushes and pops as any arm code would however you would need to implement any",
    "start": "1272480",
    "end": "1279039"
  },
  {
    "text": "c standard libraries yourself so any mem copies any string copies and comparisons would need to be done by hand",
    "start": "1279039",
    "end": "1287039"
  },
  {
    "text": "so in c function calls are all generated as branch and link instructions",
    "start": "1287280",
    "end": "1292320"
  },
  {
    "text": "so what happens is um code gets functions are called by um",
    "start": "1292320",
    "end": "1298799"
  },
  {
    "text": "jumping to a relative address compared to the current address where the program counter is and then it usually pushes some",
    "start": "1298799",
    "end": "1304640"
  },
  {
    "text": "registers and then pops them at the end to return back where it was this can be used to patch out existing",
    "start": "1304640",
    "end": "1311440"
  },
  {
    "text": "functions in the firmware or even override them completely as needed in order to change functionality",
    "start": "1311440",
    "end": "1318159"
  },
  {
    "text": "branch and link uses two complement and two's complement relative addresses which is some simple binary mathematics but um",
    "start": "1318159",
    "end": "1324400"
  },
  {
    "text": "can be used to jump relatively from the current position into where you want to be and can be patched over any",
    "start": "1324400",
    "end": "1330480"
  },
  {
    "text": "existing branch and link functions basically so if i wanted to change one specific function to do something else",
    "start": "1330480",
    "end": "1336159"
  },
  {
    "text": "i could jump to my own functions in that empty area of memory where i'd patch them into",
    "start": "1336159",
    "end": "1341600"
  },
  {
    "text": "i made a made a small build application for this which literally did all the linking and relocating for me by dumping out function calls",
    "start": "1341600",
    "end": "1347919"
  },
  {
    "text": "from my binaries and relocating them as needed as well as performing manual arm patching",
    "start": "1347919",
    "end": "1353200"
  },
  {
    "text": "as i needed to first thing i wanted to do is make a",
    "start": "1353200",
    "end": "1358559"
  },
  {
    "text": "command a itc function which would allow me to read arbitrary memory and what i did was",
    "start": "1358559",
    "end": "1363600"
  },
  {
    "text": "select a specific vendor specific command this being 2f24 in the firmware which was used by some",
    "start": "1363600",
    "end": "1371520"
  },
  {
    "text": "unknown functionality of the device but was essentially allowed essentially allowed arbitrary size of",
    "start": "1371520",
    "end": "1377840"
  },
  {
    "text": "parameters and was allowed to be run continuously as needed what i could do was modify this to do",
    "start": "1377840",
    "end": "1382880"
  },
  {
    "text": "what i wanted to i searched for morph 0x24 using regex and",
    "start": "1382880",
    "end": "1388240"
  },
  {
    "text": "ida which literally let me find exactly how this was loaded for setting up response editors and then i overrode the function that",
    "start": "1388240",
    "end": "1394480"
  },
  {
    "text": "was right before the send function in i2c um so that it would jump to my get arbitrary memory function which would",
    "start": "1394480",
    "end": "1400640"
  },
  {
    "text": "allow me to jump read memory or modify memory as needed to whenever because writing a firmware took around",
    "start": "1400640",
    "end": "1406640"
  },
  {
    "text": "20 seconds this was quite a difficult task and took a while to set up but when it did it could be expanded as needed",
    "start": "1406640",
    "end": "1413760"
  },
  {
    "text": "because i could now send data back i wanted to take parameters as well i didn't know exactly where the",
    "start": "1413840",
    "end": "1419440"
  },
  {
    "text": "parameters were stored in ram just by virtue of how complex the firmware was so what i want to do is quickly find",
    "start": "1419440",
    "end": "1424559"
  },
  {
    "text": "this out i did this by crafting an nci request which had f 2f2404 c f a c now f a c f a c is just",
    "start": "1424559",
    "end": "1432159"
  },
  {
    "text": "a nice little place holder which i could search through in ram in order to find the address of these",
    "start": "1432159",
    "end": "1437279"
  },
  {
    "text": "um parameters being sent and i use this to find exactly where this was so i can now send and receive commands as needed via",
    "start": "1437279",
    "end": "1443679"
  },
  {
    "text": "i2c with very little code changes the first thing i did was dump the bootloader which was uh",
    "start": "1443679",
    "end": "1450159"
  },
  {
    "text": "very helpful and i looked at what i was actually hitting with my exploit because i hadn't seen this",
    "start": "1450159",
    "end": "1455440"
  },
  {
    "text": "bootloader before i didn't know what i was hitting to make this work what i found that what the bootloader",
    "start": "1455440",
    "end": "1460880"
  },
  {
    "text": "was doing was loading from our zero into our zero from the address now because we jumped here directly from the",
    "start": "1460880",
    "end": "1467039"
  },
  {
    "text": "function call we had no idea what r0 was and so the fact that this worked at all was quite impressive",
    "start": "1467039",
    "end": "1474159"
  },
  {
    "text": "what i did was change this to address 173 which was exactly the same as where we put it in the original bootloader and allowed",
    "start": "1474159",
    "end": "1480880"
  },
  {
    "text": "us to jump directly into the firmware without any problems now reading out memory is very useful",
    "start": "1480880",
    "end": "1487039"
  },
  {
    "text": "but because this is an nfc chip i wanted to make it do cool nfc things because the chipset",
    "start": "1487039",
    "end": "1492400"
  },
  {
    "text": "supports multiple protocols such as iso one one four four three a iso one four four four three b and a few others that are all in",
    "start": "1492400",
    "end": "1499039"
  },
  {
    "text": "the 13.56 megahertz range i wanted to implement one of those myself i decided to emulate a myfair classic",
    "start": "1499039",
    "end": "1506320"
  },
  {
    "text": "tag that's my first project for this chip i would need to know a lot about that hardware register to make this work but",
    "start": "1506320",
    "end": "1512240"
  },
  {
    "text": "doing so would allow me to work um with the chip in ways which would allow me to emulate",
    "start": "1512240",
    "end": "1517360"
  },
  {
    "text": "any nfc tag i used to proxmox for debugging throughout as i could see how nfc was working at a very raw level",
    "start": "1517360",
    "end": "1523200"
  },
  {
    "text": "and this was very helpful i took all the nci commands that were sent by the phone to the chip usually and just",
    "start": "1523200",
    "end": "1529679"
  },
  {
    "text": "dumped them into a bite array and replayed them i then went through each one and found out any of them which weren't actually",
    "start": "1529679",
    "end": "1534880"
  },
  {
    "text": "required for the chip to run as i needed to so that i could uh reduce bloat on the commands being sent",
    "start": "1534880",
    "end": "1540720"
  },
  {
    "text": "and then i used what i discovered to be the rf discover command which is the last command sent and took away all the parameters which",
    "start": "1540720",
    "end": "1547039"
  },
  {
    "text": "set up into nfc reader mode or used different protocols and just kept it for protocol 80 which",
    "start": "1547039",
    "end": "1552480"
  },
  {
    "text": "turned out to be the uh my iso 144 3a tag emulation mode",
    "start": "1552480",
    "end": "1559760"
  },
  {
    "text": "because i had no data sheets to work with and the hardware registers were quite complicated i'd have to look around",
    "start": "1560480",
    "end": "1565760"
  },
  {
    "text": "in the firmware to see how these were used and as there weren't any strings i would have to infer anything i was",
    "start": "1565760",
    "end": "1572000"
  },
  {
    "text": "working out directly from this hardware the first thing i wanted to do was find out how enumeration works on the chip now",
    "start": "1572000",
    "end": "1578080"
  },
  {
    "text": "enumeration on nfc um works largely the same with standard communication in nfc however",
    "start": "1578080",
    "end": "1584559"
  },
  {
    "text": "there are some differences which in speed which meant that the chipset was probably doing this separately or in some hardware level",
    "start": "1584559",
    "end": "1591200"
  },
  {
    "text": "compared to just doing the standard communication um the first thing i did was search for the select command which is the second command",
    "start": "1591200",
    "end": "1597120"
  },
  {
    "text": "in enumeration just because i thought this was more likely to work just by reject searching for comparison and 93 93 being the select command this",
    "start": "1597120",
    "end": "1604720"
  },
  {
    "text": "found an immediate result loading from a hardware address four zero zero two zero two hundred and comparing on that value meaning that",
    "start": "1604720",
    "end": "1611440"
  },
  {
    "text": "i'd instantly found how this enumeration was being selected i placed the phone on a reader and let",
    "start": "1611440",
    "end": "1617600"
  },
  {
    "text": "it constantly run and then started dumping from this hardware just using the i2c function that i'd implemented earlier",
    "start": "1617600",
    "end": "1623840"
  },
  {
    "text": "this recovery replaced my results from ida i found that the reader was constantly sending wake up commands which are",
    "start": "1623840",
    "end": "1629360"
  },
  {
    "text": "hex 52 this allowed me to also work out other things about the hardware registers such as the",
    "start": "1629360",
    "end": "1634559"
  },
  {
    "text": "size and certain other configurations i could dump out later this functionality would allow me to do",
    "start": "1634559",
    "end": "1640640"
  },
  {
    "text": "one-way passive sniffing as well as some other things it was very useful for getting the emulation working",
    "start": "1640640",
    "end": "1647679"
  },
  {
    "text": "ic14443a communication works in a certain way for enumeration it requires three key aspects so what",
    "start": "1648120",
    "end": "1654960"
  },
  {
    "text": "happens is the reader sends a wake up or a request command the tag sends an atqa command which gives",
    "start": "1654960",
    "end": "1660960"
  },
  {
    "text": "initial information about how the tag is configured or what kind of tag it is the reader then select you runs the",
    "start": "1660960",
    "end": "1668000"
  },
  {
    "text": "select command which returns a uid which on phones are forced to be randomized except the first byte which is always zero eight",
    "start": "1668000",
    "end": "1673919"
  },
  {
    "text": "to prove that it's not a real tag and then a sak command to give information about whether your",
    "start": "1673919",
    "end": "1679039"
  },
  {
    "text": "id is slightly larger needs further enumeration or any other changes",
    "start": "1679039",
    "end": "1684159"
  },
  {
    "text": "wire nci could modify this to a certain amount however certain bits were set in any atqa value and stack value i sent",
    "start": "1684159",
    "end": "1689919"
  },
  {
    "text": "which meant that it was restricted to be always being known as a phone i found out later that these values are",
    "start": "1689919",
    "end": "1695840"
  },
  {
    "text": "probably stored in individual hardware registers i need to find out how this worked i sent specific values to the chip and",
    "start": "1695840",
    "end": "1702880"
  },
  {
    "text": "then searched through ram to see if i could find where they were stored in ram i then compared this to ida",
    "start": "1702880",
    "end": "1708320"
  },
  {
    "text": "and found where those the addresses of these were compared with hardware addresses",
    "start": "1708320",
    "end": "1714880"
  },
  {
    "text": "and i found this function which loaded each sac and adq and uid value into certain addresses",
    "start": "1714880",
    "end": "1721760"
  },
  {
    "text": "this would give me quite a lot of insight in out how tall that works and i could modify it as needed",
    "start": "1721760",
    "end": "1727600"
  },
  {
    "text": "i overrode this function and then called it from within the new function i made this would allow me to set up all the",
    "start": "1727600",
    "end": "1733120"
  },
  {
    "text": "hardware as i needed to without me needing to do it myself what i then did was over um",
    "start": "1733120",
    "end": "1739200"
  },
  {
    "text": "overwrote what they had implemented into the hardware so what uid value and sac and hqa values they initialized and",
    "start": "1739200",
    "end": "1745679"
  },
  {
    "text": "put my own ones in i then confirmed this using approximate readers to prove that my new uid sac and atq alpha values",
    "start": "1745679",
    "end": "1751600"
  },
  {
    "text": "had worked when i looked on the proper mark i found that sys was successful and allowed me",
    "start": "1751600",
    "end": "1758159"
  },
  {
    "text": "for modification of any enumeration so i had made a custom seven byte uid",
    "start": "1758159",
    "end": "1764000"
  },
  {
    "text": "set it up to pretend to be a myfair classic mini tag and yeah worked absolutely beautiful but",
    "start": "1764000",
    "end": "1771200"
  },
  {
    "text": "it would not allow me to do full communication it wouldn't allow me to emulate the myfair classic part of the modifier",
    "start": "1771200",
    "end": "1776240"
  },
  {
    "text": "classic communication just to pretend to be one on a superficial level i knew that the chip would respond to",
    "start": "1776240",
    "end": "1782559"
  },
  {
    "text": "halt and rats commands rats commands being some more configuration data being returned and halt commands being",
    "start": "1782559",
    "end": "1788720"
  },
  {
    "text": "a more high level communication aspect of the enumeration setup i search for the rats command using",
    "start": "1788720",
    "end": "1793760"
  },
  {
    "text": "comparison e0 which was the command by used by nfc for that",
    "start": "1793760",
    "end": "1798880"
  },
  {
    "text": "particular functionality and found four results and just looked through them and worked out which one was which",
    "start": "1798880",
    "end": "1804000"
  },
  {
    "text": "and found the specific one which was in use this led me to find the exact state machine that was used by the chip to do",
    "start": "1804000",
    "end": "1810799"
  },
  {
    "text": "further communication and also found some further valid commands further tracing of this found how it",
    "start": "1810799",
    "end": "1816720"
  },
  {
    "text": "rested responses so i found how the hardware registers were set up so i found that it was using the same hardware address",
    "start": "1816720",
    "end": "1822240"
  },
  {
    "text": "space as the rest of the nfc setup so four zero zero two zero zero zero however i found that the length was set",
    "start": "1822240",
    "end": "1828559"
  },
  {
    "text": "up at zero eight in this address space and that the data itself was set up at um hex 100 in the stress space which was",
    "start": "1828559",
    "end": "1835919"
  },
  {
    "text": "just underneath hex 200 where data was received so senders and receives were quite next to each other but also had quite a lot of",
    "start": "1835919",
    "end": "1841840"
  },
  {
    "text": "space to do what they wanted to i wrote all these registers out and dumped them into a new function which i",
    "start": "1841840",
    "end": "1847760"
  },
  {
    "text": "could then use to modify as needed",
    "start": "1847760",
    "end": "1853120"
  },
  {
    "text": "a basic read command was then implemented which is always used by uh nfc which um in my fair classic and my",
    "start": "1853120",
    "end": "1860480"
  },
  {
    "text": "fair tags in general which is three zero and then a block size and then a crc which is just a standard and",
    "start": "1860480",
    "end": "1865679"
  },
  {
    "text": "an encrypted read while my fair classic does encrypt these um requests and we'll come to that later",
    "start": "1865679",
    "end": "1872080"
  },
  {
    "text": "some my standard myfair tags do not and by implementing it i could prove that i could do full communication on",
    "start": "1872080",
    "end": "1877600"
  },
  {
    "text": "this chip in any way i needed to i overrode the entire state machine and",
    "start": "1877600",
    "end": "1882640"
  },
  {
    "text": "added my own functionality so i could add in write blocks read blocks and authentication commands used by",
    "start": "1882640",
    "end": "1887760"
  },
  {
    "text": "the myfair classic and i also re-implemented the whole command so that it called the whole command in the actual firmware",
    "start": "1887760",
    "end": "1894559"
  },
  {
    "text": "at 5e09 um so that i could didn't have to affect the internal state machine of the hardware too much because it was set up",
    "start": "1894559",
    "end": "1900559"
  },
  {
    "text": "by this i also added some non-standard debugging commands such as seven zero",
    "start": "1900559",
    "end": "1906159"
  },
  {
    "text": "which allowed me to dump out raw memory from the chip via nfc so i could do it via i2c or nfc as needed",
    "start": "1906159",
    "end": "1913679"
  },
  {
    "text": "with this full control i could emulate any iso 1443a tag i stuck with the mifa classic but i",
    "start": "1913679",
    "end": "1919679"
  },
  {
    "text": "could expand this quite a lot the full authentication mechanisms which are implemented which are quite old but",
    "start": "1919679",
    "end": "1925600"
  },
  {
    "text": "quite simple it authenticates using um sort of a standard key which that provides them a level of mutual",
    "start": "1925600",
    "end": "1930960"
  },
  {
    "text": "authentication and while it did work unfortunately because i was loading eight bit buffers into the",
    "start": "1930960",
    "end": "1936399"
  },
  {
    "text": "responses there was no space to modify the parity bit which is quite heavily used in my fair classic as part of the",
    "start": "1936399",
    "end": "1942080"
  },
  {
    "text": "encryption how this works is every eight bits it has an extra bit",
    "start": "1942080",
    "end": "1948399"
  },
  {
    "text": "in nfc communication which is used to check the parity of the previous data and just to make sure that there's no",
    "start": "1948399",
    "end": "1954080"
  },
  {
    "text": "communication errors whatsoever now this as standard was found to be implemented in the hardware of the chip so that you",
    "start": "1954080",
    "end": "1961039"
  },
  {
    "text": "didn't have to bottle with this in software however i found that this meant that i couldn't modify the um firmware at all in order to",
    "start": "1961039",
    "end": "1969360"
  },
  {
    "text": "fully implement my flair classic because no standard reader would look at this and think that the",
    "start": "1969360",
    "end": "1974559"
  },
  {
    "text": "encrypted parity bit was correct i think communication was broken however i thought it was very likely",
    "start": "1974559",
    "end": "1979760"
  },
  {
    "text": "that there was a hardware register somewhere which would allow for modifying of this parity bit um in myself however this would mean pushing",
    "start": "1979760",
    "end": "1986799"
  },
  {
    "text": "8-bit and 9-bit buffers around in some complex ways i modified each",
    "start": "1986799",
    "end": "1992320"
  },
  {
    "text": "register used by the hardware and turn and see if any responses were changed now i had a few interesting outcomes",
    "start": "1992320",
    "end": "1997360"
  },
  {
    "text": "like it increased the um sizes of the responses in weird ways or added strange crcs i've never seen",
    "start": "1997360",
    "end": "2003200"
  },
  {
    "text": "before which all had seemed to have some functionality which was unrelated to what i was trying to find however i found address four zero zero",
    "start": "2003200",
    "end": "2009919"
  },
  {
    "text": "two zero zero zero four by seven bit four thousand i could um",
    "start": "2009919",
    "end": "2015279"
  },
  {
    "text": "modify the parity bits as needed all i had to do was change the size of the responses i was sending and send an extra bit per byte",
    "start": "2015279",
    "end": "2023200"
  },
  {
    "text": "meaning i was sending nine bit values into eight bit buffers just meaning that things had to be shifted around a bit with this however",
    "start": "2023200",
    "end": "2029760"
  },
  {
    "text": "my fair classic could be fully implemented and i had access to full communication on my third classic and it",
    "start": "2029760",
    "end": "2036159"
  },
  {
    "text": "worked i also made the chip send back right to the my fair",
    "start": "2036159",
    "end": "2042240"
  },
  {
    "text": "classic tag via i2c meaning if i uploaded a file nfc tag to the chip",
    "start": "2042240",
    "end": "2047519"
  },
  {
    "text": "i could then get changes to it back so that i could have some persistent storage of this data now here's a quick demo of this all i've",
    "start": "2047519",
    "end": "2053839"
  },
  {
    "text": "done is taken a different phone using the nxp tag info tool and i've placed it on top",
    "start": "2053839",
    "end": "2059040"
  },
  {
    "text": "of my samsung s9 and what you'll see is that after a while after it's uh",
    "start": "2059040",
    "end": "2064240"
  },
  {
    "text": "checked all of its keys and checked all the authentication it will come back and show that it was in fact uh identified as a myfair",
    "start": "2064240",
    "end": "2071118"
  },
  {
    "text": "classic tag and tried to authenticate all of the nfc blocks available so there we go now i tried a different a",
    "start": "2071119",
    "end": "2078240"
  },
  {
    "text": "few different keys and a few different settings in here just to make it look more interesting but essentially this was full implementation of my fair",
    "start": "2078240",
    "end": "2084398"
  },
  {
    "text": "classic final notes on this are that with this you could spoof any 13.56 megahertz",
    "start": "2084399",
    "end": "2090960"
  },
  {
    "text": "access control while this didn't uh include 125 kilohertz access controls which is still widely used",
    "start": "2090960",
    "end": "2096800"
  },
  {
    "text": "it was quite a lot of access you could now gain by modifying this setup however you also had more esoteric uses",
    "start": "2096800",
    "end": "2103599"
  },
  {
    "text": "which uh for things like toys and games and things which use this functionality",
    "start": "2103599",
    "end": "2109520"
  },
  {
    "text": "um despite the fact that i'd patch the firmware all other nasty functionality of the chip would work as normal so if i set it back to act as a reader or",
    "start": "2109520",
    "end": "2115839"
  },
  {
    "text": "any other kind of tag it would work like that absolutely fine you'd i'd find that this",
    "start": "2115839",
    "end": "2121040"
  },
  {
    "text": "would probably be more subtle than using a prox mark as it was more subtle than a dedicated attack tool",
    "start": "2121040",
    "end": "2126079"
  },
  {
    "text": "it's a phone which no one expects to have any of this functionality built in whereas carrying around a proxy market",
    "start": "2126079",
    "end": "2131200"
  },
  {
    "text": "or antenna is slightly less subtle expansion of this functionality would allow you to dump authentication",
    "start": "2131200",
    "end": "2137920"
  },
  {
    "text": "and keys off readers just by the virtue of how some of these authentications are implemented and you could",
    "start": "2137920",
    "end": "2144720"
  },
  {
    "text": "implement on any supported protocol not just iso 1443a but also 4443b",
    "start": "2144720",
    "end": "2150079"
  },
  {
    "text": "or anyone supported by the chipset and now that the framework is in place it would be easy to develop these four",
    "start": "2150079",
    "end": "2155200"
  },
  {
    "text": "it's simply a case of combining the code now i outlined all the vulnerabilities and",
    "start": "2155200",
    "end": "2160720"
  },
  {
    "text": "the patches i'd made to samsung and they've patched this out in their current chip sets as of april",
    "start": "2160720",
    "end": "2165760"
  },
  {
    "text": "2020 that means chipsets of this version and that were manufactured after that date would no longer be available to this but there's",
    "start": "2165760",
    "end": "2172000"
  },
  {
    "text": "still plenty about that are the vulnerability did require root access which meant that the phone wouldn't be compromised by this attack",
    "start": "2172000",
    "end": "2178720"
  },
  {
    "text": "but the chip was compromised in ways that would make it much more useful than it would be as standard we have to remember that phones are",
    "start": "2178720",
    "end": "2184720"
  },
  {
    "text": "exploitable embedded devices you can treat it like any iot device you're attacking as long as you approach it the",
    "start": "2184720",
    "end": "2190240"
  },
  {
    "text": "right way while the security might be higher there's definitely some interesting things you can look at especially bootloader vulnerabilities",
    "start": "2190240",
    "end": "2197119"
  },
  {
    "text": "these are increasingly common and just by virtue of the fact that bootloader vulnerabilities are in the bootloader",
    "start": "2197119",
    "end": "2202320"
  },
  {
    "text": "they're going to remain for years because no one can patch them out you've got to think of things like the nintendo switch exploits",
    "start": "2202320",
    "end": "2207839"
  },
  {
    "text": "which had to have fuel hardware revisions and still have switches out there which are vulnerable",
    "start": "2207839",
    "end": "2213119"
  },
  {
    "text": "to bootloader-based vulnerabilities um developing custom firmware for proprietary chips like this",
    "start": "2213119",
    "end": "2219599"
  },
  {
    "text": "is interesting and challenging but it's also rewarding you can make some really interesting stuff happen with this",
    "start": "2219599",
    "end": "2225040"
  },
  {
    "text": "you've got to think about also things like broadcom chipsets where people have added wi-fi monitor mode at a later date",
    "start": "2225040",
    "end": "2230160"
  },
  {
    "text": "or modifications things like bluetooth chipsets where you could add extra debugging functionality and lastly if an undisclosed",
    "start": "2230160",
    "end": "2236160"
  },
  {
    "text": "vulnerability is found in an old chip it'll likely be in a new one thank you very much",
    "start": "2236160",
    "end": "2243838"
  },
  {
    "text": "hello everyone thank you very much for coming to my talk i hope you enjoyed it now um i've seen a couple of questions in the",
    "start": "2244720",
    "end": "2249920"
  },
  {
    "text": "chat that i'm just going to briefly go through and hopefully answer them for you firstly uh",
    "start": "2249920",
    "end": "2255760"
  },
  {
    "text": "i had a question regarding mobile payments now due to the nature of this vulnerability and the fact that you need to root a",
    "start": "2255760",
    "end": "2260800"
  },
  {
    "text": "phone to do it it's required that someone would have to intentionally be trying to do this in the first place now when you work with",
    "start": "2260800",
    "end": "2266960"
  },
  {
    "text": "mobile payments especially with samsung you have the fear of tripping knocks and all sorts of other security measures that can be bypassed but it's much more",
    "start": "2266960",
    "end": "2273280"
  },
  {
    "text": "difficult the whole purpose of bypassing this particular chip isn't really to affect mobile payments as it won't",
    "start": "2273280",
    "end": "2278720"
  },
  {
    "text": "really be affected by this but more to expand the functionality of your phone into an attack tool rather than a device for affecting",
    "start": "2278720",
    "end": "2286560"
  },
  {
    "text": "mobile payments which is something you wouldn't generally do on a uh not a rooted phone anyway",
    "start": "2286560",
    "end": "2292480"
  },
  {
    "text": "um with regards to the question about um cortex-m chips so it's used the chip itself was using a secure core architecture now this is a",
    "start": "2292480",
    "end": "2299280"
  },
  {
    "text": "more lockdown architecture developed by arm which essentially has the same capabilities of a cortex-m chip",
    "start": "2299280",
    "end": "2305359"
  },
  {
    "text": "but it's used purely for these secure applications where you don't want to be able to do things like access ram or access protected memory in",
    "start": "2305359",
    "end": "2311920"
  },
  {
    "text": "certain ways now the details about how all of this works and how it's architected is something you need to sign in nda to get from arm",
    "start": "2311920",
    "end": "2318160"
  },
  {
    "text": "to do so it's not something you'll fully be able to be capable of but you can make assumptions based on what capabilities",
    "start": "2318160",
    "end": "2324720"
  },
  {
    "text": "this particular chip had about what um capabilities you would have with a secure core now if it was a cortex",
    "start": "2324720",
    "end": "2330800"
  },
  {
    "text": "m3 or something of that type i would have been more able to write things like shell code right into the stack",
    "start": "2330800",
    "end": "2335839"
  },
  {
    "text": "and jump to it to perform things like adding that magic number to the start of the firmware so instead of doing that i could add those features into my custom firmware",
    "start": "2335839",
    "end": "2342800"
  },
  {
    "text": "which was effective as well um i think that's all the questions we have",
    "start": "2342800",
    "end": "2348960"
  },
  {
    "text": "if there are any others coming through the chat please let me know if not i am i think we are all",
    "start": "2348960",
    "end": "2354000"
  },
  {
    "text": "good and thank you for having me",
    "start": "2354000",
    "end": "2361119"
  }
]