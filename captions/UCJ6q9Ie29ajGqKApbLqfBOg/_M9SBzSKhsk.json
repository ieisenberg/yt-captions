[
  {
    "text": "[Music]",
    "start": "1180",
    "end": "14730"
  },
  {
    "text": "hello hi welcome to this virtual blackhead briefing so today we'll be talking about new new",
    "start": "16080",
    "end": "22880"
  },
  {
    "text": "methods for hypervisor detection just a few words about me",
    "start": "22880",
    "end": "28400"
  },
  {
    "text": "i work in academia i'm a postdoc in sapiens university in italy i work in",
    "start": "28400",
    "end": "34800"
  },
  {
    "text": "software and system security and uh i'm returning to blakket this",
    "start": "34800",
    "end": "40079"
  },
  {
    "text": "year last year i was presenting a system blue pill for handling invested malware",
    "start": "40079",
    "end": "46160"
  },
  {
    "text": "but this year i'm working for the other site we will be presenting new red pills",
    "start": "46160",
    "end": "53680"
  },
  {
    "text": "in particular we will be dealing with sandboxes that are able to hide",
    "start": "53680",
    "end": "60320"
  },
  {
    "text": "discrepancies of virtualization by thinking the the results of time",
    "start": "60320",
    "end": "66159"
  },
  {
    "text": "measurements made by a program so we will be building our own covert",
    "start": "66159",
    "end": "71680"
  },
  {
    "text": "time source and we will be retrofitting existing detections based on time for hypervisors and we",
    "start": "71680",
    "end": "78479"
  },
  {
    "text": "will see if now these retrofitted primitives can can detects and bosses and then the",
    "start": "78479",
    "end": "85600"
  },
  {
    "text": "other the the other attack that i'm going to present is a premium probe attack on the last level of cache to detect",
    "start": "85600",
    "end": "93920"
  },
  {
    "text": "again the presence of a virtual machine monitor let's get started i want to talk briefly",
    "start": "93920",
    "end": "101600"
  },
  {
    "text": "about the importance of hypervisors and why cannot be avoided in malware analysis today well",
    "start": "101600",
    "end": "107840"
  },
  {
    "text": "hypervisors are important for scalability of the analysis because you can run many virtual machines",
    "start": "107840",
    "end": "114880"
  },
  {
    "text": "and do your analysis on servers but also from a transparency point of view so in recent years",
    "start": "114880",
    "end": "124000"
  },
  {
    "text": "many many researchers and companies they they've proposed the signs where the",
    "start": "124000",
    "end": "129679"
  },
  {
    "text": "agent functionality of a sandbox is implemented at a hypervisor level using virtual machine introspection",
    "start": "129679",
    "end": "136000"
  },
  {
    "text": "so to reduce the number of artifacts that you have in the execution and then that an adversary can look for so",
    "start": "136000",
    "end": "143680"
  },
  {
    "text": "hypervisors are are really important and uh the problem uh with hypervisors",
    "start": "143680",
    "end": "150400"
  },
  {
    "text": "is that they introduce some discrepancies to understand these discrepancies let's let's talk a little bit of",
    "start": "150400",
    "end": "156640"
  },
  {
    "text": "how virtualization works under the hood so the cpu offers assistance",
    "start": "156640",
    "end": "164000"
  },
  {
    "text": "to hypervisors for virtualization there is the dmx operation of the cpu",
    "start": "164000",
    "end": "171760"
  },
  {
    "text": "so there is a vmx root mode it's the high privilege mode that is where your virtual machine",
    "start": "171760",
    "end": "179200"
  },
  {
    "text": "monitor resides and operates so this vmm is your host is giving your resources",
    "start": "179200",
    "end": "186239"
  },
  {
    "text": "assigning virtual processors to guests etc and then you have a new root mode where",
    "start": "186239",
    "end": "193360"
  },
  {
    "text": "your guest is running this is your virtual machine and there is a virtual machine control structure that regulates",
    "start": "193360",
    "end": "200400"
  },
  {
    "text": "this the transitions between root and root mode so this is important because there are some",
    "start": "200400",
    "end": "206319"
  },
  {
    "text": "operations in the guest that operations or events",
    "start": "206319",
    "end": "211440"
  },
  {
    "text": "that require vmx street mods so what happens is that there is a vm exit event",
    "start": "211440",
    "end": "217680"
  },
  {
    "text": "the vmm takes over and once the monitor has finished there will be a vm entry event back into the guest",
    "start": "217680",
    "end": "227280"
  },
  {
    "text": "virtualization in hardware assisted virtualization has been uh conceived for high performance and",
    "start": "227280",
    "end": "236080"
  },
  {
    "text": "compatibility there is a seminal work from gerfinkel from 13 years ago",
    "start": "236080",
    "end": "242400"
  },
  {
    "text": "where he was claiming that in the presence of a dedicated adversary",
    "start": "242400",
    "end": "247519"
  },
  {
    "text": "it's it's almost impossible to build a fully transparent virtual machine monitor",
    "start": "247519",
    "end": "253360"
  },
  {
    "text": "so there are some discrepancies and even though many enhancements have been made by cpu producers",
    "start": "253360",
    "end": "262079"
  },
  {
    "text": "think of extended page tables or other mechanisms there are still some problems",
    "start": "262079",
    "end": "270000"
  },
  {
    "text": "in terms of transparency and for instance the transitions to the virtual machine monitor are",
    "start": "270000",
    "end": "275680"
  },
  {
    "text": "inevitable let's let's start with an example the situate the instruction",
    "start": "275680",
    "end": "281280"
  },
  {
    "text": "so your cpu id reveals you properties of the processor and this will cause a",
    "start": "281280",
    "end": "288479"
  },
  {
    "text": "vm exit so the moment that you you execute cprd",
    "start": "288479",
    "end": "293919"
  },
  {
    "text": "in the guest the vmain takes over and also has the possibility of",
    "start": "293919",
    "end": "300000"
  },
  {
    "text": "changing the properties that you're exposing or for the cpu to the guest so you might be",
    "start": "300000",
    "end": "306080"
  },
  {
    "text": "changing brand string or other aspects but",
    "start": "306080",
    "end": "312080"
  },
  {
    "text": "there is also a so-called hypervisor bit that is one when you're running in a hypervisor that in a sandbox you should",
    "start": "312400",
    "end": "319280"
  },
  {
    "text": "be turning into zero but the point here is not about the data returned by cpuid",
    "start": "319280",
    "end": "325759"
  },
  {
    "text": "the point is about how long it takes for cpu id to run so if we time the execution of cpu id",
    "start": "325759",
    "end": "334400"
  },
  {
    "text": "for instance on the laptop that i'm using for recording this presentation we will see that if i do this i run the",
    "start": "334400",
    "end": "341199"
  },
  {
    "text": "sequence on the native host on the operating system",
    "start": "341199",
    "end": "346320"
  },
  {
    "text": "i will be measuring around 300 cycles while if i do it under virtualbox",
    "start": "346320",
    "end": "353840"
  },
  {
    "text": "i will be getting 10 times more because here i'm including the latency of performing a vm entry and bmx it",
    "start": "353840",
    "end": "361360"
  },
  {
    "text": "so what can i do as a sandbox architect well yeah i mean i should be tracking",
    "start": "361360",
    "end": "368160"
  },
  {
    "text": "uh those instructions like cpu id or other patterns that might be abused",
    "start": "368160",
    "end": "375440"
  },
  {
    "text": "because vm exit but that covers me only for the detection part for countering those attempts i need to",
    "start": "375440",
    "end": "382000"
  },
  {
    "text": "control the time sources i need to alter the perception of time",
    "start": "382000",
    "end": "387919"
  },
  {
    "text": "inside the guest and it's not enough to just hook the apis and change the results",
    "start": "387919",
    "end": "393199"
  },
  {
    "text": "what you need to do is you need to intercept the execution or the rdtsc instruction",
    "start": "393199",
    "end": "399520"
  },
  {
    "text": "you have to configure the virtual machine monitor to have a vm exit also for rdtsc and you",
    "start": "399520",
    "end": "406960"
  },
  {
    "text": "can keep track of the time that you spend in the bmm and you can re like subtract this time from",
    "start": "406960",
    "end": "414240"
  },
  {
    "text": "the values that rdtsc is returning during the execution",
    "start": "414240",
    "end": "420880"
  },
  {
    "text": "this problem uh like is not new in other areas either so",
    "start": "421120",
    "end": "428720"
  },
  {
    "text": "for instance in the microarchitectural attacks literature there was this",
    "start": "428720",
    "end": "434880"
  },
  {
    "text": "seminal work to spine the sandbox where they were able to to perform an llc attack from a browser",
    "start": "434880",
    "end": "442880"
  },
  {
    "text": "using javascript and the performance now primitive of javascript so to",
    "start": "442880",
    "end": "449680"
  },
  {
    "text": "to shut the door to those attacks bender said okay let's just make uh this clock much worse",
    "start": "449680",
    "end": "456400"
  },
  {
    "text": "we reduce the resolution but researchers they came up with uh",
    "start": "456400",
    "end": "461599"
  },
  {
    "text": "with two counter measures one was recovering resolution even from a",
    "start": "461599",
    "end": "466879"
  },
  {
    "text": "crippled clock and the other uh which which i will be using in in this work is to build your own",
    "start": "466879",
    "end": "474479"
  },
  {
    "text": "time source what do i mean by that timestamp counter is essentially a variable that you can",
    "start": "474479",
    "end": "481759"
  },
  {
    "text": "only read with dedicated instructions but you may say okay i want to build my own variable",
    "start": "481759",
    "end": "488000"
  },
  {
    "text": "i i can dedicate a cpu core just to increment",
    "start": "488000",
    "end": "493520"
  },
  {
    "text": "this variable and i will read it from from my main my main thread and whenever",
    "start": "493520",
    "end": "500000"
  },
  {
    "text": "i need to to time the execution of cpuid i will be reading this variable twice",
    "start": "500000",
    "end": "507280"
  },
  {
    "text": "i mean this variable how often gets incremented it is fast enough the",
    "start": "507280",
    "end": "513680"
  },
  {
    "text": "resolution is good and are those measurements reliable so let's do some tests",
    "start": "513680",
    "end": "520479"
  },
  {
    "text": "uh this is some code for computing the approximate resolution of",
    "start": "520479",
    "end": "527680"
  },
  {
    "text": "our time sources we will be comparing the timestamp counter and uh with rdtsc and our counter clock",
    "start": "527680",
    "end": "536800"
  },
  {
    "text": "so with the timestamp counter the nice thing is that in recent intel cpus",
    "start": "536800",
    "end": "542399"
  },
  {
    "text": "uh the clock ticks at the nominal frequency so it doesn't depend on the current",
    "start": "542399",
    "end": "547519"
  },
  {
    "text": "frequency of the cpu let's make some measurements and with this with this code we obtain for rdtsc",
    "start": "547519",
    "end": "554959"
  },
  {
    "text": "some values that are very very close to the nominal frequency for the cpu but for the counter thread",
    "start": "554959",
    "end": "561680"
  },
  {
    "text": "we got a much lower resolution it's not too bad it's like five six times worse",
    "start": "561680",
    "end": "569440"
  },
  {
    "text": "but it might not be enough for some attacks it's good for cpu id may not for others so",
    "start": "569440",
    "end": "576399"
  },
  {
    "text": "can we do better can we increment that variable faster",
    "start": "576399",
    "end": "581600"
  },
  {
    "text": "and uh there is some researchers in harass university take him up with a",
    "start": "581600",
    "end": "587440"
  },
  {
    "text": "clever idea they say the problem of that increment",
    "start": "587440",
    "end": "592560"
  },
  {
    "text": "is that to to update the counter you first have to read the current value",
    "start": "592560",
    "end": "598800"
  },
  {
    "text": "and then you can update it and you're reading and writing from memory so this means two",
    "start": "598800",
    "end": "605760"
  },
  {
    "text": "accesses to the l1 cache you can save one of those accesses by keeping the counter in a",
    "start": "605760",
    "end": "612000"
  },
  {
    "text": "register so you increment a register and then you copy to register contents",
    "start": "612000",
    "end": "617279"
  },
  {
    "text": "to memory this works very very well because increment is",
    "start": "617279",
    "end": "622320"
  },
  {
    "text": "like super low latency and the move is not that bad and actually you'll be surprised but you",
    "start": "622320",
    "end": "628880"
  },
  {
    "text": "can get an enhanced counter thread that can take faster",
    "start": "628880",
    "end": "634160"
  },
  {
    "text": "than the original timestamp counter thanks to instruction level parallelism and other",
    "start": "634160",
    "end": "640160"
  },
  {
    "text": "magic that happens at the microarchitectural level so the resolution problem seems",
    "start": "640160",
    "end": "647120"
  },
  {
    "text": "kind of solved let's see about reliability so we need we need a cpu core for",
    "start": "647120",
    "end": "654160"
  },
  {
    "text": "uh running this counter thread we cannot run the counter thread alongside our",
    "start": "654160",
    "end": "659920"
  },
  {
    "text": "detection on the same thread on the same core so what can we do",
    "start": "659920",
    "end": "664959"
  },
  {
    "text": "uh yeah i mean if we don't we don't want to trust what the operating system says i have",
    "start": "664959",
    "end": "671360"
  },
  {
    "text": "eight cores four cores or three cores this number can be faked we need to be sure that we're not",
    "start": "671360",
    "end": "677760"
  },
  {
    "text": "dealing with a single core machine so there is a detection method proposed in this paper",
    "start": "677760",
    "end": "683600"
  },
  {
    "text": "uh which is to to check from one thread if another thread is running and the",
    "start": "683600",
    "end": "689120"
  },
  {
    "text": "other way around so you we can use antiquary system information",
    "start": "689120",
    "end": "694160"
  },
  {
    "text": "access some internal structures or windows and check the trade state from there",
    "start": "694160",
    "end": "701440"
  },
  {
    "text": "this works but you know a sandbox architect that knows this trick can",
    "start": "701440",
    "end": "706640"
  },
  {
    "text": "fake those results so let's do it without apis so what we do is we still raise two",
    "start": "706640",
    "end": "714079"
  },
  {
    "text": "threads and the idea is that every thread has its own counter",
    "start": "714079",
    "end": "722079"
  },
  {
    "text": "and we see from from the other thread if this thread is incrementing this",
    "start": "722079",
    "end": "728320"
  },
  {
    "text": "counter so we make an observation and then we make another and we check if",
    "start": "728320",
    "end": "734320"
  },
  {
    "text": "in the meantime the the thread has increased the counter so this this",
    "start": "734320",
    "end": "739680"
  },
  {
    "text": "mechanism is yeah this is more complicated to to intercept",
    "start": "739680",
    "end": "744880"
  },
  {
    "text": "and fake for for a sandbox we we have detection methods to to",
    "start": "744880",
    "end": "750800"
  },
  {
    "text": "determine whether we have enough course to run our counter threads there's still a problem though that is",
    "start": "750800",
    "end": "758000"
  },
  {
    "text": "the workload of the machine i mean even if you have two cores there are still a possibility that",
    "start": "758000",
    "end": "765040"
  },
  {
    "text": "you might be the schedule so your clock stops sticking and you get the stale value and you",
    "start": "765040",
    "end": "771839"
  },
  {
    "text": "cannot make measurements you can say okay i'm just set a very high priority for the thread but this",
    "start": "771839",
    "end": "778639"
  },
  {
    "text": "this doesn't solve the problem i mean can improve the situation but",
    "start": "778639",
    "end": "783839"
  },
  {
    "text": "it's not a solution it's also conspicuous what you can do is you can poke the counter you can check for a",
    "start": "783839",
    "end": "791519"
  },
  {
    "text": "heartbeat you can read the counter read it again and see if the value has changed if",
    "start": "791519",
    "end": "798959"
  },
  {
    "text": "if it has changed the trade is beating so it's ticking and you can you can take that last",
    "start": "798959",
    "end": "805120"
  },
  {
    "text": "measurement and that will be your starting time otherwise you keep waiting and then it's important in general with",
    "start": "805120",
    "end": "811760"
  },
  {
    "text": "counter threads but also with the rdtlc that you serialize your measurements",
    "start": "811760",
    "end": "816959"
  },
  {
    "text": "using fences so now we have time primitive we want to",
    "start": "816959",
    "end": "823600"
  },
  {
    "text": "put it into action so we started uh",
    "start": "823600",
    "end": "829199"
  },
  {
    "text": "popular time-based detection for hypervisors and we implemented them both with rdtsc",
    "start": "829199",
    "end": "837040"
  },
  {
    "text": "and then we plugged the counterthread version in our counter threat primitives and then we compare",
    "start": "837040",
    "end": "842959"
  },
  {
    "text": "the results so i'm i will be presenting four detections one i already kind of",
    "start": "842959",
    "end": "848320"
  },
  {
    "text": "presented it to ready the latency of cpu at the instruction i mean if you fail this test it's not a",
    "start": "848320",
    "end": "855199"
  },
  {
    "text": "good sign you know sandbox but the idea is that in this test you normally",
    "start": "855199",
    "end": "862240"
  },
  {
    "text": "you can make different observations take the average value and compare it against",
    "start": "862240",
    "end": "867360"
  },
  {
    "text": "some bare metal threshold say 100 000 as tsc difference um then there is",
    "start": "867360",
    "end": "876079"
  },
  {
    "text": "another test which is a different flavor and appeared in the loki malware the",
    "start": "876079",
    "end": "884079"
  },
  {
    "text": "first time so the lucky authors had this clever idea of comparing the execution time of get",
    "start": "884079",
    "end": "891279"
  },
  {
    "text": "process hip and close handle normally get press's hip is like super fast it's just",
    "start": "891279",
    "end": "897440"
  },
  {
    "text": "three instructions and close handle takes longer however if you execute this code without",
    "start": "897440",
    "end": "904079"
  },
  {
    "text": "uh hardware assistance for your virtual machine",
    "start": "904079",
    "end": "909600"
  },
  {
    "text": "you will get a high high execution time forget process here because you're accessing",
    "start": "909600",
    "end": "915360"
  },
  {
    "text": "through the segment register you're accessing the process entry block the trade entry block",
    "start": "915360",
    "end": "921279"
  },
  {
    "text": "for uh for this operation um but also i mean you will not be detecting",
    "start": "921279",
    "end": "928000"
  },
  {
    "text": "uh virtualbox with this method but you might be detecting a custom hypervisor",
    "start": "928000",
    "end": "933199"
  },
  {
    "text": "that is intercepting uh accesses to the process entry block",
    "start": "933199",
    "end": "938560"
  },
  {
    "text": "and the thread entry block so this this detection will actually give us surprising",
    "start": "938560",
    "end": "943839"
  },
  {
    "text": "surprising results but first uh there are two more detections to present",
    "start": "943839",
    "end": "949440"
  },
  {
    "text": "that they were described in a game the paper that i referenced before so we",
    "start": "949440",
    "end": "955759"
  },
  {
    "text": "reproduced the research and the first detection is to instead of checking the absolute execution time for",
    "start": "955759",
    "end": "963120"
  },
  {
    "text": "cpuid we we make a comparison we we run a cpu id in a loop and then we",
    "start": "963120",
    "end": "971440"
  },
  {
    "text": "run another instruction in a loop we make different measurements and we compare the execution time ratio",
    "start": "971440",
    "end": "978399"
  },
  {
    "text": "because i mean the absolute times can change between different architectures and can be forged",
    "start": "978399",
    "end": "983759"
  },
  {
    "text": "but the ratio is is more reliable and you can compare cpu id to some low",
    "start": "983759",
    "end": "991120"
  },
  {
    "text": "latency structure we use knob just like the others and the the other detection is clever",
    "start": "991120",
    "end": "998720"
  },
  {
    "text": "actually this time we are not looking for a latency",
    "start": "998720",
    "end": "1004160"
  },
  {
    "text": "because of the vm mm monitor the vm monitor has to execute this time",
    "start": "1004160",
    "end": "1009440"
  },
  {
    "text": "we look for a latency that is induced by some threshing some pollution on the microarchitectural state from the",
    "start": "1009440",
    "end": "1017600"
  },
  {
    "text": "vmm execution so in this attack we uh we search for tlb andres the",
    "start": "1017600",
    "end": "1024880"
  },
  {
    "text": "transitional leukocyte buffer entries that are addicted by the vmm so we fill the tlb then we execute cpu",
    "start": "1024880",
    "end": "1033038"
  },
  {
    "text": "id or cause a vm exit in other ways and then we we analyze the latencies in",
    "start": "1033039",
    "end": "1041360"
  },
  {
    "text": "accessing some attacker control pages and yeah the advantage is that you",
    "start": "1041360",
    "end": "1047839"
  },
  {
    "text": "cannot fool this by just subtracting time because we are not measuring cpu id here",
    "start": "1047839",
    "end": "1053840"
  },
  {
    "text": "we are measuring the effects the only downside of this strategy is that filling the tlb there there is no",
    "start": "1053840",
    "end": "1062080"
  },
  {
    "text": "a unique strategy but there is the linear filling algorithm that works quite well",
    "start": "1062080",
    "end": "1067840"
  },
  {
    "text": "uh which which is that you you you guess first the tlb sites then you",
    "start": "1067840",
    "end": "1074000"
  },
  {
    "text": "allocate that many pages to to fill it you load them you take care",
    "start": "1074000",
    "end": "1080320"
  },
  {
    "text": "of caches to cancel their effects with flashing and you",
    "start": "1080320",
    "end": "1085360"
  },
  {
    "text": "measure the maximum access time that you observe for all the pages so",
    "start": "1085360",
    "end": "1092160"
  },
  {
    "text": "you make some comparison with cpu id and then you you get the same the the",
    "start": "1092160",
    "end": "1100160"
  },
  {
    "text": "baseline with for instance you run knob in a loop",
    "start": "1100160",
    "end": "1105360"
  },
  {
    "text": "and let's see the results right so yeah i mean we we obtained results on several machines",
    "start": "1105360",
    "end": "1112000"
  },
  {
    "text": "that we controlled but the interesting part is when we submitted this to",
    "start": "1112000",
    "end": "1117039"
  },
  {
    "text": "malware analysis services to send boxes so we resorted to public services and some",
    "start": "1117039",
    "end": "1124320"
  },
  {
    "text": "subscriptions that we had and also a nice thing is that many people",
    "start": "1124320",
    "end": "1130000"
  },
  {
    "text": "downloaded it from the feeds when we were submitting those from public services",
    "start": "1130000",
    "end": "1135039"
  },
  {
    "text": "we obtained um yeah around 76",
    "start": "1135039",
    "end": "1142799"
  },
  {
    "text": "results on like 76 machines completed most of our tests",
    "start": "1142799",
    "end": "1150080"
  },
  {
    "text": "let's see in detail first of all let's see how did it go with the counter thread resolution so we",
    "start": "1150080",
    "end": "1157039"
  },
  {
    "text": "observed that uh for nearly half of the machine we had a timestamp counter",
    "start": "1157039",
    "end": "1162559"
  },
  {
    "text": "uh that was slower than the counter thread which was good",
    "start": "1162559",
    "end": "1169200"
  },
  {
    "text": "and but in the other half we we didn't get a faster uh",
    "start": "1169200",
    "end": "1175840"
  },
  {
    "text": "clock but we still a pretty pretty good clock so we're sticking within 40 percent of",
    "start": "1175840",
    "end": "1181919"
  },
  {
    "text": "the of the frequency this means that there is some work to do",
    "start": "1181919",
    "end": "1186960"
  },
  {
    "text": "in finding other primitives for for incrementing the variable faster",
    "start": "1186960",
    "end": "1192080"
  },
  {
    "text": "when when using other microarchitectures but the interesting part is that we",
    "start": "1192080",
    "end": "1197440"
  },
  {
    "text": "observed in some cases that tsc frequency that we measured with our method was",
    "start": "1197440",
    "end": "1203039"
  },
  {
    "text": "significantly different than when you you would expect for the cpu model that was exposed by the",
    "start": "1203039",
    "end": "1209200"
  },
  {
    "text": "sandbox so meaning that probably that that model was fake",
    "start": "1209200",
    "end": "1214799"
  },
  {
    "text": "for cpu id uh well we we observed that only 23 machines",
    "start": "1215360",
    "end": "1222480"
  },
  {
    "text": "fail past past this test sorry 23. so we obtained this number by double",
    "start": "1222480",
    "end": "1229600"
  },
  {
    "text": "checking the latencies also with the results that we obtain with detection trees since the average",
    "start": "1229600",
    "end": "1235840"
  },
  {
    "text": "is not really a good method but so it's done in the wild and what about these 23 machines",
    "start": "1235840",
    "end": "1242799"
  },
  {
    "text": "i mean the other machines that one that failed the test you observe that also with the counter thread",
    "start": "1242799",
    "end": "1248640"
  },
  {
    "text": "we obtain high values but for those that passed the test",
    "start": "1248640",
    "end": "1253760"
  },
  {
    "text": "we saw that 14 were single core and so they are trivially detected",
    "start": "1253760",
    "end": "1260320"
  },
  {
    "text": "for six we were observing fake times 10 counter values",
    "start": "1260320",
    "end": "1265520"
  },
  {
    "text": "because the counter threats were high the counter trade measurements were high",
    "start": "1265520",
    "end": "1271520"
  },
  {
    "text": "and we're revealing the actual latency of cpuid we found one case where it was running",
    "start": "1271520",
    "end": "1277919"
  },
  {
    "text": "in qmu where the counter thread was was going super slow",
    "start": "1277919",
    "end": "1283039"
  },
  {
    "text": "and uh we we found also that in one case uh yeah it was too close to call and in",
    "start": "1283039",
    "end": "1289360"
  },
  {
    "text": "another case the sandbox timed out too fast before we could get also the counter-thread",
    "start": "1289360",
    "end": "1294480"
  },
  {
    "text": "measurements so this test is not really reassuring for",
    "start": "1294480",
    "end": "1300400"
  },
  {
    "text": "i mean for defenders perspective because only 23 passed this test",
    "start": "1300799",
    "end": "1307440"
  },
  {
    "text": "and uh we also saw that the lucky task is surprising results",
    "start": "1307760",
    "end": "1313919"
  },
  {
    "text": "again 23 machines not the same 23 but 23 were running in an emulator or they",
    "start": "1313919",
    "end": "1321280"
  },
  {
    "text": "were trapping on those memory accesses and 13 of them tested to be single core",
    "start": "1321280",
    "end": "1329360"
  },
  {
    "text": "according to our tests so this gave us surprising results because this uh",
    "start": "1329360",
    "end": "1334559"
  },
  {
    "text": "i mean we were we were expecting fewer but let's talk about detection three",
    "start": "1334559",
    "end": "1341120"
  },
  {
    "text": "which revealed two more machines 10 detection one by looking at those",
    "start": "1341120",
    "end": "1346720"
  },
  {
    "text": "results actually we saw that two were failing the loki test",
    "start": "1346720",
    "end": "1352720"
  },
  {
    "text": "seven had fake timestamp counter values so we were able to detect them with the",
    "start": "1352720",
    "end": "1359280"
  },
  {
    "text": "counter thread but for 12 of them there was just too much noise so for the knob cycle so",
    "start": "1359280",
    "end": "1366660"
  },
  {
    "text": "[Music] we wish we will try in the future to run this experiment again using another",
    "start": "1366660",
    "end": "1373200"
  },
  {
    "text": "instruction and we observe something uh very",
    "start": "1373200",
    "end": "1378320"
  },
  {
    "text": "interesting for the fourth detection which is the most effective when it when it runs",
    "start": "1378320",
    "end": "1384559"
  },
  {
    "text": "was completed by fewer machines because it takes long to execute and while for several machines the",
    "start": "1384559",
    "end": "1391600"
  },
  {
    "text": "latencies were unstable so probably the tlb feeling didn't succeed",
    "start": "1391600",
    "end": "1398240"
  },
  {
    "text": "we observed that out of 29 machines 24 were detected and there were no",
    "start": "1398240",
    "end": "1406000"
  },
  {
    "text": "discrepancies for the counter threats because i mean there was no point for sandboxes",
    "start": "1406000",
    "end": "1411440"
  },
  {
    "text": "in faking the timestamp counter in those case",
    "start": "1411440",
    "end": "1417039"
  },
  {
    "text": "in those cases unless they knew when they detected this this attack so at the end of the day we",
    "start": "1417039",
    "end": "1423360"
  },
  {
    "text": "obtained that we were able to detect many sandboxes either as a single",
    "start": "1423360",
    "end": "1428400"
  },
  {
    "text": "core machine or we could tell that they their uh time stem counters were being",
    "start": "1428400",
    "end": "1434559"
  },
  {
    "text": "forged so counter threads helped helped a lot in this regard",
    "start": "1434559",
    "end": "1439679"
  },
  {
    "text": "but it's time to to present the second contribution of this talk it's a new detection and it's based on",
    "start": "1439679",
    "end": "1446960"
  },
  {
    "text": "an llc primary probe attack so the idea is to look for effects just",
    "start": "1446960",
    "end": "1453600"
  },
  {
    "text": "like the tlb eviction but on caches which can be quite",
    "start": "1453600",
    "end": "1458640"
  },
  {
    "text": "reliable to measure especially on the llc and we will be looking for a last level",
    "start": "1458640",
    "end": "1464880"
  },
  {
    "text": "cache lines that we are evicted by the execution of a virtual machine monitor",
    "start": "1464880",
    "end": "1469919"
  },
  {
    "text": "and the llc yeah i mean they're widely used in my architectural research for",
    "start": "1469919",
    "end": "1475279"
  },
  {
    "text": "attacks um for high resolution attacks and we will mount a prime and probe attack",
    "start": "1475279",
    "end": "1482400"
  },
  {
    "text": "but first of all let me tell you just a little bit of how llc addressing works so",
    "start": "1482400",
    "end": "1489679"
  },
  {
    "text": "the idea is that they are addressed by physical addresses so if you have some data to virtual",
    "start": "1489679",
    "end": "1496559"
  },
  {
    "text": "this virtual address x in a program you need first to transform it into a physical address",
    "start": "1496559",
    "end": "1504640"
  },
  {
    "text": "right you have the mmu for that and from the bits of this physical address",
    "start": "1504640",
    "end": "1510799"
  },
  {
    "text": "you will be able to determine in which cash set and which slice of the cash you should be",
    "start": "1510799",
    "end": "1517679"
  },
  {
    "text": "putting this cash line when you are reading or writing it and uh the number of sets minutes",
    "start": "1517679",
    "end": "1524320"
  },
  {
    "text": "depends on the size of the cash but also on the associativity of the cache the number of ways which is",
    "start": "1524320",
    "end": "1530960"
  },
  {
    "text": "also the the size of the the sides of the",
    "start": "1530960",
    "end": "1536559"
  },
  {
    "text": "set so we will be mounting a primary probe attack the idea is that we will fill a",
    "start": "1536559",
    "end": "1544559"
  },
  {
    "text": "cache set entry sorry we will fill each cache set entry and with",
    "start": "1544559",
    "end": "1551200"
  },
  {
    "text": "attacker control data then we will cause a transition to the vmm",
    "start": "1551200",
    "end": "1556960"
  },
  {
    "text": "and we will try to see if this transaction evicted polluted one or more lines that",
    "start": "1556960",
    "end": "1562480"
  },
  {
    "text": "we were controlling and those lines they will see a higher latency when we try to access them",
    "start": "1562480",
    "end": "1569279"
  },
  {
    "text": "because they will cause an llc miss but how do you find eviction sets uh",
    "start": "1569279",
    "end": "1575919"
  },
  {
    "text": "for llc eviction sets if you don't know them they are some sets that",
    "start": "1575919",
    "end": "1582880"
  },
  {
    "text": "contain virtual addresses that they map to the same cache set so the optimal size is given by the",
    "start": "1582880",
    "end": "1590000"
  },
  {
    "text": "associativity of the cache so for a 16 way associative you need 16",
    "start": "1590000",
    "end": "1595840"
  },
  {
    "text": "addresses to to feel that set and you need also to build for this",
    "start": "1595840",
    "end": "1602559"
  },
  {
    "text": "attack a minimal eviction set an optimal one for all the available",
    "start": "1602559",
    "end": "1610000"
  },
  {
    "text": "callers so the color is determined by some bits",
    "start": "1610840",
    "end": "1617120"
  },
  {
    "text": "of the physical address that normally you don't control unless you're native",
    "start": "1617120",
    "end": "1622799"
  },
  {
    "text": "hardware with huge pages but uh those bits are part of the set",
    "start": "1622799",
    "end": "1628320"
  },
  {
    "text": "index that will tell you in which cash set you're ending up for this cash line and the slice is",
    "start": "1628320",
    "end": "1635440"
  },
  {
    "text": "determined also by the cash stack but the point is that in",
    "start": "1635440",
    "end": "1640960"
  },
  {
    "text": "inside the vm you have a further level of indirection so even if you know the correspondence",
    "start": "1640960",
    "end": "1647279"
  },
  {
    "text": "between the virtual addresses and the physical addresses that are available to the guests",
    "start": "1647279",
    "end": "1653679"
  },
  {
    "text": "to the operating system in the guest there is this extra level of indirection",
    "start": "1653679",
    "end": "1659840"
  },
  {
    "text": "because guest physical addresses they need to be translated to host physical addresses and those hpas are the",
    "start": "1659840",
    "end": "1667360"
  },
  {
    "text": "addresses that you use for indexing your cache and in a sandbox you can make new assumptions",
    "start": "1667360",
    "end": "1672960"
  },
  {
    "text": "on the on the mapping between virtual addresses and host physical addresses so you need techniques that can build",
    "start": "1672960",
    "end": "1679520"
  },
  {
    "text": "eviction sets without making assumptions on the mapping between virtual addresses",
    "start": "1679520",
    "end": "1684640"
  },
  {
    "text": "and cache sets so there is this uh paper",
    "start": "1684640",
    "end": "1689919"
  },
  {
    "text": "from oakland last year they presented a method and released the code which we",
    "start": "1689919",
    "end": "1694960"
  },
  {
    "text": "use to build uh eviction sets in a time that is linear in the size of",
    "start": "1694960",
    "end": "1701600"
  },
  {
    "text": "the cache and we starting from a large buffer they prune it with some clever",
    "start": "1701600",
    "end": "1708399"
  },
  {
    "text": "group thresholding heuristics and it works pretty well so we build eviction sites for all cache",
    "start": "1708399",
    "end": "1715360"
  },
  {
    "text": "callers using this method then we we do the priming part of the attack so we",
    "start": "1715360",
    "end": "1721120"
  },
  {
    "text": "preload the entries from the eviction set in the cache set",
    "start": "1721120",
    "end": "1726159"
  },
  {
    "text": "and then we prime so we we measure the access time we will see that it is",
    "start": "1726159",
    "end": "1731679"
  },
  {
    "text": "constant for every for every entry then we trigger a transition in the virtual machine monitor",
    "start": "1731679",
    "end": "1738240"
  },
  {
    "text": "and we we measure again the access time for every line in the set and the moment",
    "start": "1738240",
    "end": "1743279"
  },
  {
    "text": "that the maximum access time becomes high and yet we can tell that there was a",
    "start": "1743279",
    "end": "1750840"
  },
  {
    "text": "miss and this miss was likely caused by the vmm execution",
    "start": "1750840",
    "end": "1756320"
  },
  {
    "text": "so we we implemented this uh actually the code is agnostic you works",
    "start": "1756320",
    "end": "1762720"
  },
  {
    "text": "on linux windows mac os you only need a library functions to allocate memory and",
    "start": "1762720",
    "end": "1768880"
  },
  {
    "text": "it works with counter threads too so it's good even if you're you have a",
    "start": "1768880",
    "end": "1774080"
  },
  {
    "text": "reliable timestamp counter measurements in a sandbox you can try counter threads",
    "start": "1774080",
    "end": "1780080"
  },
  {
    "text": "we tested this code on a whole lot of intel cpus uh from old to pretty recent one",
    "start": "1780080",
    "end": "1787679"
  },
  {
    "text": "it's like whiskey lake architecture and we tried several versions of virtualbox",
    "start": "1787679",
    "end": "1793360"
  },
  {
    "text": "vmware on different host operating systems and we tried kvm and xan",
    "start": "1793360",
    "end": "1800000"
  },
  {
    "text": "i will be presenting some some of the results so on this machine we were able to try",
    "start": "1800000",
    "end": "1806640"
  },
  {
    "text": "most different combinations and we saw that this is the whisky lake",
    "start": "1806640",
    "end": "1812399"
  },
  {
    "text": "one so we saw that for instance a virtual box",
    "start": "1812399",
    "end": "1817440"
  },
  {
    "text": "on windows during a cpu id was with polluting about 20 out of the",
    "start": "1817440",
    "end": "1823840"
  },
  {
    "text": "120 way at 128 eviction sets that would be we built on linux was just a bit less",
    "start": "1823840",
    "end": "1832000"
  },
  {
    "text": "on similar numbers we saw on vmware even though we were not able to build",
    "start": "1832000",
    "end": "1837760"
  },
  {
    "text": "all the code the desired cache sets probably for some partitioning we are still",
    "start": "1837760",
    "end": "1844320"
  },
  {
    "text": "investigating uh same for kvm and uh this was done the test",
    "start": "1844320",
    "end": "1852480"
  },
  {
    "text": "took two to three minutes while on on the on the native host it took around one",
    "start": "1852480",
    "end": "1858320"
  },
  {
    "text": "minute also we we kept looking into virtualbox",
    "start": "1858320",
    "end": "1863440"
  },
  {
    "text": "and we observed that even on different machines there was a a significant increase in",
    "start": "1863440",
    "end": "1871200"
  },
  {
    "text": "the number of sets of sets that are polluted when moving from version 5",
    "start": "1871200",
    "end": "1879240"
  },
  {
    "text": "5.2 to virtualbox 6 and we we observed in general that also",
    "start": "1879240",
    "end": "1885840"
  },
  {
    "text": "another cpu and hypervisor combinations while on a native execution you don't",
    "start": "1885840",
    "end": "1892960"
  },
  {
    "text": "see evictions or you might get some one or two but evicted because some uh the system",
    "start": "1892960",
    "end": "1901279"
  },
  {
    "text": "workload was high here we consistently got several sets that were being evicted",
    "start": "1901279",
    "end": "1908240"
  },
  {
    "text": "then the interesting part is that if you're running on a custom virtual machine monitor",
    "start": "1908240",
    "end": "1913840"
  },
  {
    "text": "that performs for instance analysis at the hypervisor level you might be polluting even more",
    "start": "1913840",
    "end": "1920080"
  },
  {
    "text": "cache sets um the limitations of this technique is that",
    "start": "1920080",
    "end": "1925679"
  },
  {
    "text": "for big caches the execution time might be long longer than the timeout of your sandbox",
    "start": "1925679",
    "end": "1931840"
  },
  {
    "text": "or even worse the eviction set construction may fail for instance if you're dealing with non-inclusive caches like",
    "start": "1931840",
    "end": "1938399"
  },
  {
    "text": "on some ceo machines so right now i'm working on extending those results with the",
    "start": "1938399",
    "end": "1944799"
  },
  {
    "text": "techniques that are described in these two papers one is dealing with non-inclusive caches",
    "start": "1944799",
    "end": "1950399"
  },
  {
    "text": "for building eviction sets and the other uh improves the method that i've been",
    "start": "1950399",
    "end": "1956080"
  },
  {
    "text": "discussing before to build minimal eviction sets much quicker so there is there is uh",
    "start": "1956080",
    "end": "1964320"
  },
  {
    "text": "still some potential to explore but to to conclude my talk uh well",
    "start": "1964320",
    "end": "1970720"
  },
  {
    "text": "uh i think that this intersection uh between microarchitectural research",
    "start": "1970720",
    "end": "1976880"
  },
  {
    "text": "and malware analysis mobile revision could be a promising research area i think that from the point of view of",
    "start": "1976880",
    "end": "1984880"
  },
  {
    "text": "sandbox architects they should explore some a code analysis",
    "start": "1984880",
    "end": "1990080"
  },
  {
    "text": "to detect at least the possibility that you're dealing with um counter threads or",
    "start": "1990080",
    "end": "1997840"
  },
  {
    "text": "uh microarchitectural attacks like prime and probe patterns this is yeah this is easier say than",
    "start": "1997840",
    "end": "2004000"
  },
  {
    "text": "done but at least for counter threads for instance you can you can think of them",
    "start": "2004000",
    "end": "2009039"
  },
  {
    "text": "as a race condition on a variable between different threads in terms of code analysis",
    "start": "2009039",
    "end": "2014720"
  },
  {
    "text": "and another thing to do that is pretty uh low effort for them is to keep track of",
    "start": "2014720",
    "end": "2020559"
  },
  {
    "text": "performance counters for the detection side for instance with performance counters you will be able to",
    "start": "2020559",
    "end": "2026880"
  },
  {
    "text": "detect that the llc premium probatakis uh is going on",
    "start": "2026880",
    "end": "2032799"
  },
  {
    "text": "while for a defensive part for new aversion i think there is a lot of room to explore",
    "start": "2032799",
    "end": "2040159"
  },
  {
    "text": "uh you might be using uh these techniques for uh looking this time for specific",
    "start": "2040159",
    "end": "2048000"
  },
  {
    "text": "virtual machine monitor features and there are also several other",
    "start": "2048000",
    "end": "2054000"
  },
  {
    "text": "micro architectural attack vectors that are worth exploring and can be exposing the virtual machine",
    "start": "2054000",
    "end": "2060560"
  },
  {
    "text": "monitor in other ways so um i hope that you enjoy this talk",
    "start": "2060560",
    "end": "2067118"
  },
  {
    "text": "but before i finish i would like to to thank three guys christian pietro and federico",
    "start": "2067119",
    "end": "2072800"
  },
  {
    "text": "that helped me at different stages of this research and i want to thank you very much for the",
    "start": "2072800",
    "end": "2080320"
  },
  {
    "text": "attention and yeah feel free to hit me up with with your questions thank you very",
    "start": "2080320",
    "end": "2086839"
  },
  {
    "text": "much",
    "start": "2086839",
    "end": "2089839"
  }
]