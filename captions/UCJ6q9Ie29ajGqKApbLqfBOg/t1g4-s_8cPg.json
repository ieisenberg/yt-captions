[
  {
    "start": "0",
    "end": "254000"
  },
  {
    "text": "so my name is Shawn healin and today I'm gonna be talking about heap layout optimization for exploitation so I used",
    "start": "30",
    "end": "6180"
  },
  {
    "text": "to work as a security researcher at immunity doing predominantly exploit development and that sort of thing and",
    "start": "6180",
    "end": "11190"
  },
  {
    "text": "since then I've moved more towards into trying to automate aspects of reverse engineering bug finding and exploitation",
    "start": "11190",
    "end": "18020"
  },
  {
    "text": "so the exploit development process had a very very high level I guess you could",
    "start": "18020",
    "end": "24390"
  },
  {
    "text": "view something like this so we have some means of discovering vulnerabilities we have some means of figuring out what the",
    "start": "24390",
    "end": "31439"
  },
  {
    "text": "program's API is and then the the process of producing an exploit is",
    "start": "31439",
    "end": "36540"
  },
  {
    "text": "actually programming right so we're using available of vulnerability triggers we're using standard API and",
    "start": "36540",
    "end": "41579"
  },
  {
    "text": "we're programming the state of the target application in order to move it into a state that's advantageous to us as attackers we're gonna be looking at",
    "start": "41579",
    "end": "48719"
  },
  {
    "text": "today a program prominently focusing on is this part here so once we have vulnerability triggers and we know how",
    "start": "48719",
    "end": "55050"
  },
  {
    "text": "to interact with the program normally how do we combine these two things in order to achieve whatever ends that we",
    "start": "55050",
    "end": "61680"
  },
  {
    "text": "want so typically when we're doing",
    "start": "61680",
    "end": "66869"
  },
  {
    "text": "exploit development we want to build our own API which is separate from the standard API provided by the program around these things we call primitives",
    "start": "66869",
    "end": "73860"
  },
  {
    "text": "most of the time so we have read write or execute primitives and what they do is they provide the attacker with the ability to say read a particular memory",
    "start": "73860",
    "end": "81180"
  },
  {
    "text": "location write a memory location or execute code at a particular memory location and these along with the",
    "start": "81180",
    "end": "86280"
  },
  {
    "text": "standard API are what we'll typically consider to be the building blocks of an exploit and how we put together primitives yeah usually we'll have say",
    "start": "86280",
    "end": "93299"
  },
  {
    "text": "one or more vulnerability triggers and we have some means of manipulating the program State and we'll wrap these up in",
    "start": "93299",
    "end": "98939"
  },
  {
    "text": "a nice API and then we can use this whenever we want to say write a memory location or read a memory location so to",
    "start": "98939",
    "end": "106890"
  },
  {
    "text": "give an example say we have target program which has this user data type which is dynamically allocated on the heap we have this rename function which",
    "start": "106890",
    "end": "113280"
  },
  {
    "text": "contains a pretty obvious buffer overflow over the name buffer associated with the user and then we have this",
    "start": "113280",
    "end": "119460"
  },
  {
    "text": "display function which reads from the user object a pointer and the display is",
    "start": "119460",
    "end": "124770"
  },
  {
    "text": "in some way that we assume that the user or the attacker can access that data and we want to do is we want to construct a primitive",
    "start": "124770",
    "end": "130910"
  },
  {
    "text": "which is an API that the attacker can use such that whenever they want to read something from some location the",
    "start": "130910",
    "end": "137030"
  },
  {
    "text": "program's memory they can call that function and have that data echoed back to them so what happens we just trigger",
    "start": "137030",
    "end": "144140"
  },
  {
    "text": "the vulnerability all right so we just trigger the rename function we overflow up whatever is after the name object and",
    "start": "144140",
    "end": "150830"
  },
  {
    "text": "then we'd call display well it entirely depends on the state that the programs in when we trigger that vulnerability",
    "start": "150830",
    "end": "156319"
  },
  {
    "text": "right so whatever is directly after the username object is going to be corrupted that could be a non map page it could be",
    "start": "156319",
    "end": "162230"
  },
  {
    "text": "a locator metadata it could be some other dynamically allocated application data and sometimes we could get lucky",
    "start": "162230",
    "end": "168650"
  },
  {
    "text": "and we could corrupt the thing we actually want to corrupt and then other times we could corrupt say some point or",
    "start": "168650",
    "end": "175040"
  },
  {
    "text": "the twos and then we get a segmentation fault or whatever so if we consider like",
    "start": "175040",
    "end": "181280"
  },
  {
    "text": "this thing at the top here to be a representation of the programs heap so from lower addresses to the higher",
    "start": "181280",
    "end": "186470"
  },
  {
    "text": "addresses and we have a user object allocated on the heap and the name object is about to be allocated so we",
    "start": "186470",
    "end": "193370"
  },
  {
    "text": "our goal is we want to position the name buffer immediately prior to the user object such that when we trigger the vulnerability the user object gets",
    "start": "193370",
    "end": "199730"
  },
  {
    "text": "corrupted we can control the values of its internal members so the pointers and then we can when we call the display",
    "start": "199730",
    "end": "205190"
  },
  {
    "text": "function we can basically read whatever location we want in memory so if we",
    "start": "205190",
    "end": "210859"
  },
  {
    "text": "simply trigger the one or trigger the allocation of the user object and let's say these green things are free chunks",
    "start": "210859",
    "end": "216290"
  },
  {
    "text": "in memory the allocator will use whatever process it has for deciding where to put that name object in a",
    "start": "216290",
    "end": "221660"
  },
  {
    "text": "buffer that's of the correct size and if you anywhere so for example it could be placed directly after the user object",
    "start": "221660",
    "end": "227540"
  },
  {
    "text": "and adjacent to this on map page now if we trigger the vulnerability what's going to happen is we're simply going to end up with the process being killed",
    "start": "227540",
    "end": "234380"
  },
  {
    "text": "because the page isn't mapped however let's say first of all we fill that buffer somehow now we trigger the",
    "start": "234380",
    "end": "241459"
  },
  {
    "text": "creation of user object again in this situation this time the allocator picks the first free page or sorry the first",
    "start": "241459",
    "end": "247669"
  },
  {
    "text": "free location now in this case it's still not quite what we want because we're still going to corrupt some application data in this location here",
    "start": "247669",
    "end": "255380"
  },
  {
    "start": "254000",
    "end": "254000"
  },
  {
    "text": "so that's still not what we want so if we manage however to fill that now",
    "start": "255380",
    "end": "260780"
  },
  {
    "text": "we're left with no more free chunks of the the appropriate size we allocate the user object we allocate the name object",
    "start": "260780",
    "end": "267229"
  },
  {
    "text": "the name gets placed directly before the user and now when we trigger the vulnerability what's going to happen is",
    "start": "267229",
    "end": "272569"
  },
  {
    "text": "the user object is going to get corrupted so in this case we're going to corrupt the user object with like Oh X",
    "start": "272569",
    "end": "277940"
  },
  {
    "text": "41 41 41 now when we call the display function instead of reading the contents",
    "start": "277940",
    "end": "283220"
  },
  {
    "text": "of the name it's going to read the content to that address and everything's fine and we win so the point here is",
    "start": "283220",
    "end": "288560"
  },
  {
    "text": "that simply triggering a vulnerability isn't isn't sufficient order to achieve our ends we need to perform this",
    "start": "288560",
    "end": "294080"
  },
  {
    "text": "manipulation stage ahead of time to put the application into a stage that results in and what we want happening so",
    "start": "294080",
    "end": "301220"
  },
  {
    "text": "the final primitive might look something like this there's going to be a function say on the attacker side within their exploit where they have some way of",
    "start": "301220",
    "end": "307789"
  },
  {
    "text": "manipulating the heap then the allocate the user object trigger the vulnerability and call the display function this is wrapped up in a nice",
    "start": "307789",
    "end": "313550"
  },
  {
    "text": "function they just pass in the address and now in future anytime they want to read some address in the in the target",
    "start": "313550",
    "end": "319250"
  },
  {
    "text": "application they'll call this function and a similar idea behind like normal programming right we want abstractions",
    "start": "319250",
    "end": "324770"
  },
  {
    "text": "we want them to be self-contained in this case we wanted to see say like reusable and predictable and obviously",
    "start": "324770",
    "end": "330470"
  },
  {
    "text": "in the real world especially with remote targets and where there's non",
    "start": "330470",
    "end": "335630"
  },
  {
    "text": "determinism and those other actors interacting with a service we want to exploit it's never quite this clean but",
    "start": "335630",
    "end": "342800"
  },
  {
    "text": "this is the idea okay so for heap base buffer overflows this manipulation",
    "start": "342800",
    "end": "349550"
  },
  {
    "text": "process is typically done obviously on the heap layout itself and it's usually fairly labor-intensive task so the",
    "start": "349550",
    "end": "356150"
  },
  {
    "text": "alamos needs to understand the allocator at the manner of which the application uses the allocator and then you also",
    "start": "356150",
    "end": "361669"
  },
  {
    "text": "given a starting state you need to utilize the applications API in order to carefully craft the heap state because",
    "start": "361669",
    "end": "366800"
  },
  {
    "text": "typically you can't interact directly with the allocator itself and this is we're going to talk about automating today so in reality instead of having",
    "start": "366800",
    "end": "373820"
  },
  {
    "start": "373000",
    "end": "373000"
  },
  {
    "text": "like this kind of nice small heap state where we have three or four chunks we",
    "start": "373820",
    "end": "379099"
  },
  {
    "text": "end up having vastly more complicated things so well this is a visualization of the evolution of programs heap over",
    "start": "379099",
    "end": "384650"
  },
  {
    "text": "time the x-axis is time the y-axis is the programs memory space starting from",
    "start": "384650",
    "end": "390720"
  },
  {
    "text": "lower addresses to higher addresses so we can see is as if the application is initialized we're getting chunks",
    "start": "390720",
    "end": "396960"
  },
  {
    "text": "allocated one after the other of the green chunks represent allocated memory the gray ones represent previously",
    "start": "396960",
    "end": "402330"
  },
  {
    "text": "allocated but now freed memory and the height of a rectangle represents the amount of memory in a particular chunk so we can see is we have hundreds of",
    "start": "402330",
    "end": "409530"
  },
  {
    "text": "allocated chunks hundreds of free chunks they're all interspersed to each other and it's as if we can't just eyeball the",
    "start": "409530",
    "end": "415290"
  },
  {
    "text": "heap State and say ah we need to make say three allocations and like to freeze and then we're gonna end up in the desired end State so it's",
    "start": "415290",
    "end": "422240"
  },
  {
    "text": "it is more complicated in the previous example in reality alright so this is a",
    "start": "422240",
    "end": "427800"
  },
  {
    "start": "427000",
    "end": "427000"
  },
  {
    "text": "formally define what we're going to be doing we're gonna have a source buffer which is the buffer from which the overflow or underflow is going to say",
    "start": "427800",
    "end": "433830"
  },
  {
    "text": "flow out of a destination buffer which is the thing we want to corrupt and the heap layer optimization problem is we're",
    "start": "433830",
    "end": "440280"
  },
  {
    "text": "trying to minimize this objective function which is the absolute distance between the source and the destination obviously you could have different",
    "start": "440280",
    "end": "445980"
  },
  {
    "text": "objective functions because sometimes the data you're corrupting is okay and",
    "start": "445980",
    "end": "451860"
  },
  {
    "text": "sometimes it's not say if you're flowing into a non mapper page that's obviously worse than if you're flowing to solve for application data but the search that",
    "start": "451860",
    "end": "459180"
  },
  {
    "text": "we wanna perform is we're searching for a sequence of inputs that minimize this function so a sequence of inputs to the",
    "start": "459180",
    "end": "464190"
  },
  {
    "text": "program to put the overflow source adjacent to the overflow destination okay there are a couple of restrictions",
    "start": "464190",
    "end": "471390"
  },
  {
    "start": "469000",
    "end": "469000"
  },
  {
    "text": "for this particular for this particular talk and if you want to talk about alleviating these come see me after so",
    "start": "471390",
    "end": "477630"
  },
  {
    "text": "we're first of all we're gonna assume a deterministic setting to begin with the alligators behavior itself must be deterministic that's not a huge restriction because there aren't too",
    "start": "477630",
    "end": "483420"
  },
  {
    "text": "many alligators that use a non determinism internally on purpose the attacker must be able to set the heap",
    "start": "483420",
    "end": "489270"
  },
  {
    "text": "into a known starting state or reset it so via killing the target or something",
    "start": "489270",
    "end": "495150"
  },
  {
    "text": "like that and we also assumed in this particular case there's no other actors interacting the heap mmm so there's no",
    "start": "495150",
    "end": "501210"
  },
  {
    "text": "other entity also triggering allocations and freeze and we're also talking about",
    "start": "501210",
    "end": "506520"
  },
  {
    "text": "physical layout not logical layout and logical layout would be relevant we're talking about say used after freeze in the surgeon okay so we need to solve",
    "start": "506520",
    "end": "514260"
  },
  {
    "start": "513000",
    "end": "513000"
  },
  {
    "text": "three things first of all we need to discover how to interact with the allocator via the applications API because as I said applications typically",
    "start": "514260",
    "end": "521180"
  },
  {
    "text": "don't allow you to do that on purpose or directly or an in a convenient fashion we want to automatically discover how to",
    "start": "521180",
    "end": "527180"
  },
  {
    "text": "allocate interesting data on the heap so a corruption target ideally and then we",
    "start": "527180",
    "end": "533540"
  },
  {
    "text": "need to automatically figure out how to place the source buffer adjacent to the thing we want to corrupt using what we",
    "start": "533540",
    "end": "540050"
  },
  {
    "text": "discovered in the first two steps already so there are a few challenges with this obviously first of all",
    "start": "540050",
    "end": "545930"
  },
  {
    "start": "543000",
    "end": "543000"
  },
  {
    "text": "alligators don't provide an API which allows you to specify positioning you can't say put this thing in Jason to that thing because in the context of the",
    "start": "545930",
    "end": "551840"
  },
  {
    "text": "normal alligator usage that makes no sense alligators assemble themselves are designed to optimize different measures",
    "start": "551840",
    "end": "558530"
  },
  {
    "text": "of success in other words they use vastly different data structures and algorithms internally so if you have the",
    "start": "558530",
    "end": "564380"
  },
  {
    "text": "solution for one alligator it's not necessarily going to work for another alligator applications themselves",
    "start": "564380",
    "end": "569420"
  },
  {
    "text": "typically don't expose the direct API to the alligator so you need to figure out how to go through the applications API",
    "start": "569420",
    "end": "575180"
  },
  {
    "text": "to interact with the alligator interaction sequences which you can discover from the alligator or sorry",
    "start": "575180",
    "end": "581660"
  },
  {
    "text": "from the application typically have noise in them so in some situations you get lucky and you can inadvertently",
    "start": "581660",
    "end": "586970"
  },
  {
    "text": "trigger like a single malloc or a single free via the applications API but another time what ends up happening is",
    "start": "586970",
    "end": "592790"
  },
  {
    "text": "you can trigger the applicate the allocation you want to trigger and then you also trigger like say 27 other allocations that may or may not mess",
    "start": "592790",
    "end": "600680"
  },
  {
    "text": "with the heap state that you're working with and that finally the search space if you were to exhaustively process all",
    "start": "600680",
    "end": "607190"
  },
  {
    "text": "combinations of interactions is obviously astronomically large so we need to find some way of dealing with that okay so as I mentioned",
    "start": "607190",
    "end": "616430"
  },
  {
    "start": "614000",
    "end": "614000"
  },
  {
    "text": "alligators have vastly different design strategies and they use vastly different",
    "start": "616430",
    "end": "621830"
  },
  {
    "text": "data structures and algorithms and there are a number of different design decisions that an alligator developer",
    "start": "621830",
    "end": "627650"
  },
  {
    "text": "can make which can make the process of laying out a heap more or less difficult so there are a few here which I've",
    "start": "627650",
    "end": "635240"
  },
  {
    "text": "listed that are significant some that are less significant I'm not going to go into any of these except for one because",
    "start": "635240",
    "end": "640940"
  },
  {
    "text": "it is by far the dominant factor in determining the difficulty of a problem of this type of problem and that is",
    "start": "640940",
    "end": "647720"
  },
  {
    "text": "whether or not an alligator uses segregated storage so if you're familiar with allocator designed then you can switch off for the",
    "start": "647720",
    "end": "654130"
  },
  {
    "text": "next minute or two if you're not segregated storage is a allocator policy",
    "start": "654130",
    "end": "659500"
  },
  {
    "text": "where you first of all when you receive an allocation request for a particular size you allocate say multiple pages and",
    "start": "659500",
    "end": "666279"
  },
  {
    "text": "then you subdivide those pages into chunks of the exact same size and you",
    "start": "666279",
    "end": "671770"
  },
  {
    "text": "use those chunks to serve as future requests for the same size and the key point is these chunks are never split",
    "start": "671770",
    "end": "678760"
  },
  {
    "text": "again they're never internally coalesced so they're never internally joined together to form a bigger chunk and",
    "start": "678760",
    "end": "685060"
  },
  {
    "text": "they're only externally coalesced as a whole so you can only ever free all of them at once the key point here for in",
    "start": "685060",
    "end": "691390"
  },
  {
    "text": "terms of manipulating a heap state into a desired layout is that except for the first and the large last chunks all",
    "start": "691390",
    "end": "696459"
  },
  {
    "text": "other chunks in the in the run of pages are adjacent to chunks of the same size so if you see here in this example we",
    "start": "696459",
    "end": "702670"
  },
  {
    "text": "have a whole bunch of chunks of size 16 in segregated storage and then a whole bunch of chunks in size 32 and",
    "start": "702670",
    "end": "708790"
  },
  {
    "text": "segregated storage and if we need to get a chunk of size 16 adjacent to a chunk of size 32 it can only be the first and",
    "start": "708790",
    "end": "716140"
  },
  {
    "text": "last chunks here so we need to figure out how to do layout manipulation at the scope of the runs of pages rather than",
    "start": "716140",
    "end": "723279"
  },
  {
    "text": "just the individual chunks themselves so",
    "start": "723279",
    "end": "728670"
  },
  {
    "text": "this is an example of if we take a hundred or so allocations and freez of",
    "start": "728670",
    "end": "733750"
  },
  {
    "text": "different sizes so there are three different sizes being allocated and freed here again x-axis is time y-axis",
    "start": "733750",
    "end": "739420"
  },
  {
    "text": "is the the address space of the target program and the height of a rectangle",
    "start": "739420",
    "end": "744490"
  },
  {
    "text": "gives you the size of the chunk so you can see here is we have bigger and smaller chunks interspersed with adjacent to each other this is",
    "start": "744490",
    "end": "751420"
  },
  {
    "text": "non-segregated storage so the application is putting chunks of different sizes next to each other and if we need a chunk of the big size next",
    "start": "751420",
    "end": "757150"
  },
  {
    "text": "to the smaller size everything is fine we can do that however if we don't take that exact same sequence of interactions",
    "start": "757150",
    "end": "762730"
  },
  {
    "text": "and we replay it on top of an alligator with segregated storage what we see is we get three distinct three distinct",
    "start": "762730",
    "end": "768490"
  },
  {
    "text": "mapped locations in memory all of which only contain jumps of the same size adjacent to each other so now we have a",
    "start": "768490",
    "end": "774790"
  },
  {
    "text": "problem if we need to get chunks of say the bottom size X of chunks of the bigger size we need to fill all of that",
    "start": "774790",
    "end": "780520"
  },
  {
    "text": "space between those two areas and eventually we'll get the topmost chunk of the bottom size",
    "start": "780520",
    "end": "787100"
  },
  {
    "text": "allocated adjacent to the bottom most chunk of the the middle size so segregated storage is a pretty",
    "start": "787100",
    "end": "792290"
  },
  {
    "text": "significant factor in determining the difficulty of of these types of problems",
    "start": "792290",
    "end": "798009"
  },
  {
    "text": "okay so as mentioned these three things were usually performed manually so",
    "start": "798009",
    "end": "803989"
  },
  {
    "start": "799000",
    "end": "799000"
  },
  {
    "text": "figuring out how to allocate something interesting on the heap to corrupt figuring out how to interact with the heap via the allocators API and then",
    "start": "803989",
    "end": "812569"
  },
  {
    "text": "given a starting stage figure out how to use the program's API to put the thing we want to corrupt next to the thing that we can flow out of so let's to",
    "start": "812569",
    "end": "821209"
  },
  {
    "text": "begin with assume that we have a solution for the first two problems and we know how to interact with the heap",
    "start": "821209",
    "end": "827230"
  },
  {
    "text": "could we design a search algorithm which can minimize the distance between a source and destination because if you",
    "start": "827230",
    "end": "832730"
  },
  {
    "text": "can't do that then there's no point in solving the first two problems to begin with so ideally we'd like the search algorithm to black box we don't have to",
    "start": "832730",
    "end": "838579"
  },
  {
    "start": "836000",
    "end": "836000"
  },
  {
    "text": "customize it to the internals over a new allocator we come across or every new version of an alligator and we also",
    "start": "838579",
    "end": "845509"
  },
  {
    "text": "don't really want to be adding new API to the alligator that sort of thing so",
    "start": "845509",
    "end": "852160"
  },
  {
    "text": "ideally what we want is something which only observes the alligator and the sense of return values that comes from",
    "start": "852160",
    "end": "858860"
  },
  {
    "text": "malloc freak a lock and realloc and then OS generic things like say what pages are mapped and that sort of thing",
    "start": "858860",
    "end": "864889"
  },
  {
    "text": "and if we can do that then we can work with any alligator effectively the other design consideration is that's worth",
    "start": "864889",
    "end": "870799"
  },
  {
    "text": "considering is that random search might actually be feasible so random search in the sense in the sense is you just have",
    "start": "870799",
    "end": "875839"
  },
  {
    "text": "a random walk through the solution space you're not learning anything between instances it's effectively a brute-force search and you remember a while ago I",
    "start": "875839",
    "end": "882559"
  },
  {
    "text": "said that the search space is astronomical well it turns out there's actually huge amount of symmetry in the search space because we don't typically",
    "start": "882559",
    "end": "888169"
  },
  {
    "text": "don't care about the absolute positioning of things we only care about the relative positioning of things so if we have a source and destination buffer",
    "start": "888169",
    "end": "894110"
  },
  {
    "text": "we don't care where they're absolutely positioned in memory we just care that they're adjacent to each other similarly",
    "start": "894110",
    "end": "899360"
  },
  {
    "text": "if we need to create holes in memory in order to capture noisy allocations we don't care where those holes are specifically located in memory we just",
    "start": "899360",
    "end": "906199"
  },
  {
    "text": "care that they exist or not so there is a huge amount of symmetry as I said in the in in this",
    "start": "906199",
    "end": "911990"
  },
  {
    "text": "in space for this particular problem okay so next few slides I'm gonna go",
    "start": "911990",
    "end": "917810"
  },
  {
    "text": "over what the search algorithm actually looks like at a high level for some",
    "start": "917810",
    "end": "923420"
  },
  {
    "text": "reason I thought this would be a great way to display the actual algorithm itself but I'll walk you through it",
    "start": "923420",
    "end": "929320"
  },
  {
    "text": "effectively the key point here is all we're doing is we are randomly creating instances and instances this solution",
    "start": "929320",
    "end": "935209"
  },
  {
    "text": "we're then providing that solution to the to the program and we're getting back the distance between the source and",
    "start": "935209",
    "end": "941180"
  },
  {
    "text": "the destination if this if the distance is less than our previous best result we say this is our new best result and we",
    "start": "941180",
    "end": "946580"
  },
  {
    "text": "move on key point we're not learning anything between solutions the construct",
    "start": "946580",
    "end": "952670"
  },
  {
    "text": "instance function then is a again it's another random function which constructs",
    "start": "952670",
    "end": "958120"
  },
  {
    "text": "solutions via randomly deciding on this line here how long the solution is going",
    "start": "958120",
    "end": "963320"
  },
  {
    "text": "to be and then randomly deciding whether it wants to do an allocation or a free until it gets to the the end of solution",
    "start": "963320",
    "end": "971029"
  },
  {
    "text": "construction then returns it again key point here everything in this is purely random we're learning nothing between",
    "start": "971029",
    "end": "977290"
  },
  {
    "text": "between solutions okay so in order to",
    "start": "977290",
    "end": "983240"
  },
  {
    "text": "evaluate this there are well we did two things the first is constructed a collection of synthetic benchmarks and",
    "start": "983240",
    "end": "989810"
  },
  {
    "text": "then later we're going to talk about doing this on real programs but just to see if the algorithm itself so random",
    "start": "989810",
    "end": "995839"
  },
  {
    "start": "994000",
    "end": "994000"
  },
  {
    "text": "search applied to mainstream allocators can actually solve this positioning problem we generated a bunch of",
    "start": "995839",
    "end": "1002529"
  },
  {
    "text": "synthetic examples so the problem we're trying to solve here is given a sore spot for a size X and a destination buffer size why can we randomly generate",
    "start": "1002529",
    "end": "1010420"
  },
  {
    "text": "a sequence of inputs the target program which place the source and destination immediately adjacent to each other for",
    "start": "1010420",
    "end": "1016690"
  },
  {
    "text": "the source and destination sizes there the cross-product of these sizes here and in order to initialize the",
    "start": "1016690",
    "end": "1022740"
  },
  {
    "text": "application into kind of a realistic starting stage we captured the starting states of Ruby PHP and",
    "start": "1022740",
    "end": "1031620"
  },
  {
    "text": "the Python want two different versions of PHP so the final experimental I guess",
    "start": "1031620",
    "end": "1036779"
  },
  {
    "text": "configuration thing worth noting is this concept of noise so we are obviously",
    "start": "1036779",
    "end": "1041788"
  },
  {
    "start": "1038000",
    "end": "1038000"
  },
  {
    "text": "because these are synthetic experiments we're deciding what interactions are available for the search algorithm with",
    "start": "1041789",
    "end": "1046829"
  },
  {
    "text": "the allocator and the easiest case is obviously the search algorithm can interact directly with the allocators",
    "start": "1046829",
    "end": "1052919"
  },
  {
    "text": "api and it can trigger exactly what it wants it can free exactly what at once as I mentioned a lot of the time in reality these interaction sequences are",
    "start": "1052919",
    "end": "1060120"
  },
  {
    "text": "actually noisy so what we're going to see in the results in a few minutes is there are experiments where there's no",
    "start": "1060120",
    "end": "1065639"
  },
  {
    "text": "noise there's experiment where there's one noisy allocation there's experiments where therefore noisy allocations those noisy allocations are simply extra",
    "start": "1065639",
    "end": "1072389"
  },
  {
    "text": "allocations that are added into the interaction sequences so if when the search interacts that the allocator",
    "start": "1072389",
    "end": "1077970"
  },
  {
    "text": "can't interact with it just kind of with a single atomic allocation or free okay",
    "start": "1077970",
    "end": "1083700"
  },
  {
    "start": "1083000",
    "end": "1083000"
  },
  {
    "text": "so we're going to go through here is the solutions for running the search",
    "start": "1083700",
    "end": "1089490"
  },
  {
    "text": "algorithm on DL malloc TC malloc and something called AVR Lib C which is a drop-in Lipsy replacement for embedded",
    "start": "1089490",
    "end": "1096149"
  },
  {
    "text": "systems there are a couple of things worth explaining first of all namely the headers on this table the alligator's obviously the",
    "start": "1096149",
    "end": "1102149"
  },
  {
    "text": "allocator that the search algorithms interacting with the noise is the number of noisy allocations the und and OVF our",
    "start": "1102149",
    "end": "1110570"
  },
  {
    "text": "experiment are the results for overflow experiments and under floor experiments because it turns out the one of those",
    "start": "1110570",
    "end": "1116730"
  },
  {
    "text": "cases tends to be easier than the other for reasons that I'll go into later an optimal layout is where the source and",
    "start": "1116730",
    "end": "1123210"
  },
  {
    "text": "destination replaced immediately adjacent to each other so that's these two columns here these two columns here",
    "start": "1123210",
    "end": "1129360"
  },
  {
    "text": "represent the number of or the percentage of solutions where the source and destination were within a page of",
    "start": "1129360",
    "end": "1135690"
  },
  {
    "text": "each other so that's also worth making note of because even if we can't get the source and destination immediately",
    "start": "1135690",
    "end": "1141090"
  },
  {
    "text": "adjacent to each other if we can get them within a page of each other we know we at least won't trigger a page fault if we trigger the overflow at the",
    "start": "1141090",
    "end": "1146759"
  },
  {
    "text": "underflow and then finally the on the average underfloor error and average",
    "start": "1146759",
    "end": "1152669"
  },
  {
    "text": "overflow error is a representation of the amount of actual error for situations where we didn't actually get the two things adjacent to each other so",
    "start": "1152669",
    "end": "1159990"
  },
  {
    "text": "what we did is for each combination of allocation and destination size starting state for the heap and no number of",
    "start": "1159990",
    "end": "1166529"
  },
  {
    "text": "noise we ran five hundred thousand instances those regenerated five hundred thousand candidate solutions and these",
    "start": "1166529",
    "end": "1172379"
  },
  {
    "text": "the results from those so we can see is for every are live C and D L Malik which are both which both don't use segregated",
    "start": "1172379",
    "end": "1180059"
  },
  {
    "text": "storage we could solve almost all of the instances using random search which is",
    "start": "1180059",
    "end": "1185190"
  },
  {
    "text": "worth knowing we then add TC Malik so TC Malik is a segregated storage based",
    "start": "1185190",
    "end": "1191759"
  },
  {
    "text": "allocator and what you can see is even with no noise we first of all we get a drop in the number of optimal solutions",
    "start": "1191759",
    "end": "1197549"
  },
  {
    "text": "achieved so we can see obviously that segregated storage has this impact then",
    "start": "1197549",
    "end": "1202559"
  },
  {
    "text": "once we add noise we can see here we get a drop from previously say DL Malik we",
    "start": "1202559",
    "end": "1208529"
  },
  {
    "text": "were resolved in 97% of the instances down to 22 in this case and the others",
    "start": "1208529",
    "end": "1215220"
  },
  {
    "text": "are hovering around 50% so what this means is this in up around 50% of the solutions we're getting the source and",
    "start": "1215220",
    "end": "1221700"
  },
  {
    "text": "destination immediately adjacent to each other but one thing worth noting is that",
    "start": "1221700",
    "end": "1227220"
  },
  {
    "text": "the average error is still quite low so the average error here means is a representation of for the thing for the",
    "start": "1227220",
    "end": "1235470"
  },
  {
    "text": "solutions that weren't optimal how close they work together so again we're still it's still less than say one allocation",
    "start": "1235470",
    "end": "1241950"
  },
  {
    "text": "that we're off by effectively and then finally we add four noisy allocations and we see that this that the results",
    "start": "1241950",
    "end": "1249149"
  },
  {
    "text": "drop again so the takeaway from this effectively is this if we have no noise and cigarette and non-segregated storage",
    "start": "1249149",
    "end": "1255929"
  },
  {
    "text": "then random search works pretty much fine within less than fifteen seconds",
    "start": "1255929",
    "end": "1261809"
  },
  {
    "text": "most of these instances resolved as we increase noise and as we add segregated storage random start starts to struggle",
    "start": "1261809",
    "end": "1267179"
  },
  {
    "text": "a bit but the average error is still relatively low so we're still getting these source and destination buffers",
    "start": "1267179",
    "end": "1273450"
  },
  {
    "text": "pretty close to each other so the kind of takeaway from this is that while the",
    "start": "1273450",
    "end": "1279690"
  },
  {
    "start": "1275000",
    "end": "1275000"
  },
  {
    "text": "random search approach isn't perfect as the problems get harder it is good enough that it was worth our while",
    "start": "1279690",
    "end": "1285049"
  },
  {
    "text": "implementing a real-world system and actually trying to apply this to real bugs okay",
    "start": "1285049",
    "end": "1290759"
  },
  {
    "text": "so the random search like I said looks promising if we won't actually do this",
    "start": "1290759",
    "end": "1296369"
  },
  {
    "start": "1291000",
    "end": "1291000"
  },
  {
    "text": "on a real target we need a few different things we need to figure out how to trigger different alligator interaction sequences via the",
    "start": "1296369",
    "end": "1302780"
  },
  {
    "text": "targets API we need some way to discover how to allocate interesting target data on the heap and we need an",
    "start": "1302780",
    "end": "1308900"
  },
  {
    "text": "implementation of the search for that real program so for this I decided to",
    "start": "1308900",
    "end": "1314870"
  },
  {
    "text": "use PHP as the evaluation system so PHP is pretty large it's fairly modern as written in C it is a non-trivial",
    "start": "1314870",
    "end": "1322190"
  },
  {
    "text": "interface for interacting with its heap in other words programs written in PHP and what our tool is going to be doing",
    "start": "1322190",
    "end": "1327410"
  },
  {
    "text": "is effectively writing PHP programs that manipulate target State in other words",
    "start": "1327410",
    "end": "1332720"
  },
  {
    "text": "the PHP allocator and then trigger some vulnerability and when the vulnerability is triggered its goal is going to be to put the source and destination adjacent",
    "start": "1332720",
    "end": "1339170"
  },
  {
    "text": "to each other such that the destination is corrupted so the system itself looks something like this so we have three",
    "start": "1339170",
    "end": "1344630"
  },
  {
    "text": "distinct phases we have interaction sequence discovery where we try to figure out how to interact with the programs heap we have corruption target",
    "start": "1344630",
    "end": "1351140"
  },
  {
    "text": "discovery where we try and automatically figure out something interesting to corrupt and then we have a vulnerability template which kind of describes how to",
    "start": "1351140",
    "end": "1356720"
  },
  {
    "text": "put these two things together in the context of a random search to produce what we are calling a primitive skeleton",
    "start": "1356720",
    "end": "1363670"
  },
  {
    "text": "good ok so those of you that are familiar with like s exploitation",
    "start": "1363670",
    "end": "1369440"
  },
  {
    "text": "terminology primitives like a fairly well-known thing the skeleton in this",
    "start": "1369440",
    "end": "1375050"
  },
  {
    "start": "1372000",
    "end": "1372000"
  },
  {
    "text": "case is worth clarifying though so the output of the system is a it's a PHP program which guarantees the relative",
    "start": "1375050",
    "end": "1381260"
  },
  {
    "text": "positioning of the source of the overflow of the underflow and the destination it doesn't however guarantee",
    "start": "1381260",
    "end": "1386360"
  },
  {
    "text": "that the vulnerability will actually corrupt the destination because it doesn't reason about the vulnerability itself the only reasons about",
    "start": "1386360",
    "end": "1392210"
  },
  {
    "text": "positioning so it's up to the user to ensure that if we're saying or if the system says I can get you this source",
    "start": "1392210",
    "end": "1399050"
  },
  {
    "text": "buffer within 8 bytes of this destination buffer you as the exploit developer need to make sure that the vulnerability will actually corrupt 8",
    "start": "1399050",
    "end": "1406400"
  },
  {
    "text": "bytes and then corrupt the target and then finally it doesn't discover how to use the corrupt data so it will",
    "start": "1406400",
    "end": "1411860"
  },
  {
    "text": "guarantee positioning and then if you ensure that the vulnerability actually performs a correct corruption it will",
    "start": "1411860",
    "end": "1418370"
  },
  {
    "text": "guarantee that you get the destination corrupted whether it ends up to you is the end user to figure out how to use that corrupted data so these are kind of",
    "start": "1418370",
    "end": "1424670"
  },
  {
    "text": "like a future work ok so what we need to do is we need to figure out how do we",
    "start": "1424670",
    "end": "1429740"
  },
  {
    "start": "1427000",
    "end": "1427000"
  },
  {
    "text": "actually programmatically interact with the heap that's being used by PHP via the API",
    "start": "1429740",
    "end": "1435800"
  },
  {
    "text": "presented by PHP which is you know PHP programs so what we want to do is we want to synthesize fragments of PHP code",
    "start": "1435800",
    "end": "1441110"
  },
  {
    "text": "the trigger unique interaction sequences the allocator this is based on work I",
    "start": "1441110",
    "end": "1447380"
  },
  {
    "start": "1446000",
    "end": "1446000"
  },
  {
    "text": "presented a few years ago as infiltrate what we're effectively going to do is we're going to take all of PHP regression tests and we're going to",
    "start": "1447380",
    "end": "1453980"
  },
  {
    "text": "parse them down into minimal fragments and then for each of those fragments we're going to record the interactions",
    "start": "1453980",
    "end": "1462080"
  },
  {
    "text": "that that fragment triggers with the with the allocator and then we're going to start fuzzing the fragments",
    "start": "1462080",
    "end": "1468080"
  },
  {
    "text": "recombining them to build bigger and more complex chunks of PHP which have unique interactions with the with the",
    "start": "1468080",
    "end": "1473840"
  },
  {
    "text": "alligator so effectively what we're doing is we're closing but with a minor",
    "start": "1473840",
    "end": "1478940"
  },
  {
    "start": "1474000",
    "end": "1474000"
  },
  {
    "text": "twist so normally when you're fuzzing say fragments of PHP or JavaScript or whatever you're using values that you're",
    "start": "1478940",
    "end": "1485240"
  },
  {
    "text": "hoping to hit edge cases right so 2 - 32 - 1 0 or so on and so forth in this case",
    "start": "1485240",
    "end": "1490580"
  },
  {
    "text": "what we're going to do is we're going to replace integer values and strings with lengths that we haven't seen before in",
    "start": "1490580",
    "end": "1496040"
  },
  {
    "text": "terms of an allocation size so if we haven't seen an allocation of size 256 then we're gonna start spraying the",
    "start": "1496040",
    "end": "1501500"
  },
  {
    "text": "value 256 in two different chunks of PHP code and hope that it results in an allocation of that size secondly our",
    "start": "1501500",
    "end": "1508910"
  },
  {
    "text": "measure of fitness isn't based on code coverage because we don't care about it's based on whether or not we trigger a new alligator interaction if by chance",
    "start": "1508910",
    "end": "1517250"
  },
  {
    "text": "we find a bug and we actually cause the alligator to crash we throw that away because we don't want that to happen we",
    "start": "1517250",
    "end": "1524450"
  },
  {
    "text": "want to find new alligator interactions at the sequences and then we favor the shortest least complex complex fragments",
    "start": "1524450",
    "end": "1532340"
  },
  {
    "text": "during this fuzzing so if we take this is a test from PHP we take this to begin",
    "start": "1532340",
    "end": "1537680"
  },
  {
    "start": "1534000",
    "end": "1534000"
  },
  {
    "text": "with and we break it down into the function calls contained within it so",
    "start": "1537680",
    "end": "1543080"
  },
  {
    "text": "each of those function calls takes a number of arguments and we then abstract that slightly further up to something",
    "start": "1543080",
    "end": "1549110"
  },
  {
    "text": "that looks like this so we break it down into we have the function calls and we have the Associated types of the arguments that it took then we pass this",
    "start": "1549110",
    "end": "1555920"
  },
  {
    "text": "into our fuzzer and what the fuzzer does is it randomly select one of these it looks at its argument types that are",
    "start": "1555920",
    "end": "1561200"
  },
  {
    "text": "randomly selects of you for those argument types so you end up getting something at this so here say we pick the image create true color we",
    "start": "1561200",
    "end": "1567539"
  },
  {
    "text": "know it takes two integer arguments and then we start fuzzing the final argument to find new interaction sequences or",
    "start": "1567539",
    "end": "1573299"
  },
  {
    "text": "similarly if we have this image convolution function we can see it can take different argument combinations and",
    "start": "1573299",
    "end": "1579600"
  },
  {
    "text": "effectively all we're doing is we're taking little fragments of PHP we're recombining them and then we're using instrumentation in order to determine",
    "start": "1579600",
    "end": "1585690"
  },
  {
    "text": "what type of allocation sequences they trigger in the allocator itself so PHP",
    "start": "1585690",
    "end": "1592289"
  },
  {
    "text": "comes with about twelve thousand tests from those twelve thousand tests we can get say three hundred standalone fragments which are like these",
    "start": "1592289",
    "end": "1598370"
  },
  {
    "text": "individual function calls and then fuzzing those for like fifteen twenty",
    "start": "1598370",
    "end": "1603870"
  },
  {
    "text": "minutes you end up with tens of thousands of different alligator interactions that you can trigger so the output of this is effectively we now",
    "start": "1603870",
    "end": "1609600"
  },
  {
    "text": "know how to interact with PHP s alligator using its API that's what we",
    "start": "1609600",
    "end": "1615960"
  },
  {
    "text": "wanted and the the search now instead of",
    "start": "1615960",
    "end": "1621360"
  },
  {
    "start": "1617000",
    "end": "1617000"
  },
  {
    "text": "say being act like an a lock free level what it does when it constructs instances is it pieces together these",
    "start": "1621360",
    "end": "1627210"
  },
  {
    "text": "fragments of PHP code in order to generate a sequence of interactions at the alligator and the search is now a",
    "start": "1627210",
    "end": "1633269"
  },
  {
    "text": "search over the space of PHP programs for a program that minimized the",
    "start": "1633269",
    "end": "1639149"
  },
  {
    "text": "distance between the source and destination okay so that was the first step the second step which we could",
    "start": "1639149",
    "end": "1645330"
  },
  {
    "start": "1641000",
    "end": "1641000"
  },
  {
    "text": "optionally automate we don't have to is finding interesting corruption targets so sometimes the exploit developer",
    "start": "1645330",
    "end": "1651990"
  },
  {
    "text": "themselves will already know this is the thing I want to corrupt therefore they know how to allocate it but that for the",
    "start": "1651990",
    "end": "1657330"
  },
  {
    "text": "sake of adding a little more automation we can also try and figure out what are interesting things to corrupt on the",
    "start": "1657330",
    "end": "1662429"
  },
  {
    "text": "heap and how do we allocate them so there are programs specific things so you could like permission bits and that",
    "start": "1662429",
    "end": "1668639"
  },
  {
    "text": "sort of thing but in our case we're going to focus on our pointers so we want to do is we want to have another search which figures out how to allocate",
    "start": "1668639",
    "end": "1677779"
  },
  {
    "text": "pointers on the heap which can then be used as part of our positioning problem",
    "start": "1677779",
    "end": "1682950"
  },
  {
    "text": "in order to say build a read or write primitive so as before we take the",
    "start": "1682950",
    "end": "1689070"
  },
  {
    "text": "fragments of PHP as input and we execute each of them in isolation",
    "start": "1689070",
    "end": "1694390"
  },
  {
    "text": "and after the fragments are as the fragment is executing we record every",
    "start": "1694390",
    "end": "1699910"
  },
  {
    "text": "dynamically allocated object then when the fragment terminates we record the objects that are still live and we",
    "start": "1699910",
    "end": "1705700"
  },
  {
    "text": "search or the actual memory used by that object looking for things that look like pointers which we can do based on",
    "start": "1705700",
    "end": "1713110"
  },
  {
    "text": "heuristics so their alignment the value they have the mapped address space to",
    "start": "1713110",
    "end": "1719770"
  },
  {
    "text": "the target process that sort of thing so that this is pretty straightforward so at this point what we have is we have",
    "start": "1719770",
    "end": "1725530"
  },
  {
    "text": "something that you can construct PHP programs which randomly manipulate the heap we have something which can tell us",
    "start": "1725530",
    "end": "1732990"
  },
  {
    "text": "what fragments of PHP code will allocate interesting targets on the heap and what",
    "start": "1732990",
    "end": "1739240"
  },
  {
    "text": "we want to do now is we want to put these things together to perform the actual search itself so each vulnerability we come across is",
    "start": "1739240",
    "end": "1746680"
  },
  {
    "start": "1743000",
    "end": "1743000"
  },
  {
    "text": "obviously going to have a different kind of set up it's going to require a different API to trigger so rather than hard coding vulnerability specific",
    "start": "1746680",
    "end": "1753370"
  },
  {
    "text": "information into the search space itself what we do is we have these vulnerability templates which the search",
    "start": "1753370",
    "end": "1759910"
  },
  {
    "text": "will fill in so they look like is as follows so this is from PHP bug report",
    "start": "1759910",
    "end": "1765700"
  },
  {
    "text": "it triggers some overflow in the the second function here so we will do is we will take whatever our vulnerability",
    "start": "1765700",
    "end": "1771850"
  },
  {
    "text": "trigger is and we will control construct a template that looks like this so the template has a preload which is just",
    "start": "1771850",
    "end": "1777070"
  },
  {
    "text": "some things that need to happen it then has something for creating the destination which is the thing we're",
    "start": "1777070",
    "end": "1783580"
  },
  {
    "text": "going to want to corrupt and then finally it has a vulnerability trigger and the system is free to insert heat manipulation or it's free to perform its",
    "start": "1783580",
    "end": "1791560"
  },
  {
    "text": "search at any location outside these tags so it can insert code here to do -",
    "start": "1791560",
    "end": "1798040"
  },
  {
    "text": "ipil a tion or here so this is one durability template looks like it's very straightforward and the overhead for the",
    "start": "1798040",
    "end": "1804160"
  },
  {
    "text": "user is is pretty low already so this is",
    "start": "1804160",
    "end": "1809440"
  },
  {
    "start": "1806000",
    "end": "1806000"
  },
  {
    "text": "we spoke about before we have interaction sequence discovery which is just fuzzing PHP programs for new",
    "start": "1809440",
    "end": "1814480"
  },
  {
    "text": "alligator interactions corruption target discovery which we just spoke about and then we have a vulnerability template we",
    "start": "1814480",
    "end": "1820420"
  },
  {
    "text": "put all these together and they're in the search and what we get out are things that look like this so they're valid PHP programs",
    "start": "1820420",
    "end": "1826640"
  },
  {
    "text": "that they have the pre loot from the template then here we can see a bunch of functions that have been randomly",
    "start": "1826640",
    "end": "1831650"
  },
  {
    "text": "selected and assembled together because they have some useful interaction with",
    "start": "1831650",
    "end": "1836930"
  },
  {
    "text": "the allocator so here we can see that the system is discovered that the image to create true color function and the string repeat function obviously do",
    "start": "1836930",
    "end": "1843470"
  },
  {
    "text": "interesting things in terms of allocating things on the heap it's also figured out that it can trigger freeze via just destroying objects like this",
    "start": "1843470",
    "end": "1850730"
  },
  {
    "text": "and then the rest of it is just from the vulnerability template so these are the instances that are going to be created",
    "start": "1850730",
    "end": "1855800"
  },
  {
    "text": "during the search and we're going to randomly create thousands hundreds of thousands billions of these until we",
    "start": "1855800",
    "end": "1861830"
  },
  {
    "text": "find one combination of these function calls which places the thing that we",
    "start": "1861830",
    "end": "1866960"
  },
  {
    "text": "want to corrupt next to the thing that we that we are flowing out of okay so",
    "start": "1866960",
    "end": "1874340"
  },
  {
    "start": "1873000",
    "end": "1873000"
  },
  {
    "text": "this is kind of the end to end process we start off with a vulnerability trigger we could create from that a template and then the system creates",
    "start": "1874340",
    "end": "1880670"
  },
  {
    "text": "these these instances okay so the",
    "start": "1880670",
    "end": "1887600"
  },
  {
    "start": "1884000",
    "end": "1884000"
  },
  {
    "text": "evaluation for this was based on three CVS from the PHP swab tracker if you're",
    "start": "1887600",
    "end": "1894800"
  },
  {
    "text": "wondering how I picked these I effectively went to the bug tracker and started looking for linear overflows and",
    "start": "1894800",
    "end": "1899930"
  },
  {
    "text": "these were the first three that I came across there's no purposely hard cases left out it wasn't a case that I found 100 and these were the only three it",
    "start": "1899930",
    "end": "1905840"
  },
  {
    "text": "worked on these were the first three that I came across so just to explain some of the headers here the source size",
    "start": "1905840",
    "end": "1912290"
  },
  {
    "text": "is the size of the the buffer which is being overflow out of when these three",
    "start": "1912290",
    "end": "1918230"
  },
  {
    "text": "vulnerabilities are triggered the destination size it sizes the object that we want to corrupt noise is a count",
    "start": "1918230",
    "end": "1924140"
  },
  {
    "text": "of the number of allocations which are triggered when we allocate the overflow source that are not the source buffer",
    "start": "1924140",
    "end": "1930110"
  },
  {
    "text": "itself in other words these are other allocations which can mess up our heap States as I mentioned before the initial",
    "start": "1930110",
    "end": "1937010"
  },
  {
    "text": "distance is the distance between the source and the destination if we simply take the triggers provided in the bug",
    "start": "1937010",
    "end": "1943220"
  },
  {
    "text": "report and our code to allocate the destination and simply run it so we can see here by default there's quite a",
    "start": "1943220",
    "end": "1949850"
  },
  {
    "text": "large distance between the source and destination obviously if we had a trigger which already put the source and destination immediately next to each",
    "start": "1949850",
    "end": "1955310"
  },
  {
    "text": "other then the search will just be wasting time and the final distance is the distance that the system was able to get",
    "start": "1955310",
    "end": "1962509"
  },
  {
    "text": "the source and destination to be from each other so we can see in two of the cases it achieved a perfect result and",
    "start": "1962509",
    "end": "1969169"
  },
  {
    "text": "in the final case it was off by 16 bytes so there were 16 bytes between the source and destination there are a few",
    "start": "1969169",
    "end": "1976369"
  },
  {
    "text": "things I guess worth worth noting here the first is you can see in the cases where we've a lot of noise that the time",
    "start": "1976369",
    "end": "1981919"
  },
  {
    "text": "to AB the best instance is obviously far higher than the case where we have no noise again we saw this in the synthetic",
    "start": "1981919",
    "end": "1987739"
  },
  {
    "text": "evaluation as well in cases where we had no noise at all we could solve the problem almost instantly and we can also",
    "start": "1987739",
    "end": "1993769"
  },
  {
    "text": "see here in the the final case we didn't actually get the perfect result the",
    "start": "1993769",
    "end": "2000129"
  },
  {
    "text": "reason for for in this particular case when I looked into it was actually the two allocations of size 8 which take",
    "start": "2000129",
    "end": "2005559"
  },
  {
    "text": "place as part of this noise here and the system wasn't able to figure out how to get them out of the way basically but",
    "start": "2005559",
    "end": "2012339"
  },
  {
    "text": "overall it works works pretty well on these evaluation instances ok so there",
    "start": "2012339",
    "end": "2021399"
  },
  {
    "start": "2021000",
    "end": "2021000"
  },
  {
    "text": "are a few takeaways from this that I think worth mentioning or reinforcing first so blackbox random search does",
    "start": "2021399",
    "end": "2027789"
  },
  {
    "text": "appear to be an effective mechanism for automatic heap layout manipulation there",
    "start": "2027789",
    "end": "2033249"
  },
  {
    "text": "are a number of instances that were clearly hired that it couldn't solve and if you want to talk about how ways to",
    "start": "2033249",
    "end": "2039339"
  },
  {
    "text": "solve those find me later segregated storage was clearly by far the biggest differentiator between hard and easy",
    "start": "2039339",
    "end": "2044739"
  },
  {
    "text": "instances with DL malloc with a VR Lipsy and no noise black box search or black box random search can solve these",
    "start": "2044739",
    "end": "2050559"
  },
  {
    "text": "instances in like fractions of a second and as noise increases obviously the",
    "start": "2050559",
    "end": "2056378"
  },
  {
    "text": "difficulty of the problems also appear to increase so there are a bunch of things that we can do to improve this",
    "start": "2056379",
    "end": "2061569"
  },
  {
    "text": "the search algorithm itself we can clearly improve we're learning nothing between instances at the moment at the",
    "start": "2061569",
    "end": "2068799"
  },
  {
    "text": "moment I'm working on a basically a buzzing /g a type approach which I can",
    "start": "2068799",
    "end": "2074020"
  },
  {
    "text": "talk about if you find me later the determinism restriction is obviously quite a harsh restriction that would be",
    "start": "2074020",
    "end": "2079839"
  },
  {
    "text": "worth worth alleviating and also be very good to see this ported to other things",
    "start": "2079839",
    "end": "2085419"
  },
  {
    "text": "so media players and JavaScript engines document viewers and that sort of thing RT so the paper",
    "start": "2085419",
    "end": "2093830"
  },
  {
    "text": "and the code you can find there the paper that's up there at the moment is",
    "start": "2093830",
    "end": "2099110"
  },
  {
    "text": "like kind of a technical report if you want the full research paper just send me an email and I'll send it on to you",
    "start": "2099110",
    "end": "2104560"
  },
  {
    "text": "or you can send me an email with any questions you might have other than that I am finished that's it any questions",
    "start": "2104560",
    "end": "2113230"
  },
  {
    "text": "that's a very interesting presentation and so I've worked with a number of the allocators that you specified there",
    "start": "2123250",
    "end": "2130570"
  },
  {
    "text": "one of the ones problems I've seen in the past is when you start considering threading issues and the effects of",
    "start": "2130570",
    "end": "2139580"
  },
  {
    "text": "effectively the instrumentation what mitigations do you take to get the",
    "start": "2139580",
    "end": "2147260"
  },
  {
    "text": "instrumentation not to be a problem so there is no instrumentation that was the",
    "start": "2147260",
    "end": "2154300"
  },
  {
    "text": "this is something I wanted to avoid basically as soon as you are adding instrumentation the heap layout gets messed up and then the test case that",
    "start": "2154300",
    "end": "2161390"
  },
  {
    "text": "you have looks nothing like the real case so because it's done in a completely blackbox fashion we the only",
    "start": "2161390",
    "end": "2167270"
  },
  {
    "text": "observation I'm doing of the the allocator is simply looking at the return values that are given back from",
    "start": "2167270",
    "end": "2173540"
  },
  {
    "text": "allocate free reality lock those sort of things so we're using something like a",
    "start": "2173540",
    "end": "2179600"
  },
  {
    "text": "preload approach to or interposition on those allocators or we replacing the allocators themselves well just passing",
    "start": "2179600",
    "end": "2186380"
  },
  {
    "text": "through just passing through any other questions",
    "start": "2186380",
    "end": "2194170"
  },
  {
    "text": "nope all right you're free",
    "start": "2194920",
    "end": "2199588"
  }
]