[
  {
    "start": "0",
    "end": "134000"
  },
  {
    "text": "thank you yeah we are going to talk about Roja marry tax and first about",
    "start": "30",
    "end": "6270"
  },
  {
    "text": "ourselves my name is Tanya goose I'm currently a postdoc at God's University of Technology and you can reach me via",
    "start": "6270",
    "end": "11730"
  },
  {
    "text": "Twitter or email my name is Maude flip I'm a PhD student at the same Institute in the same office",
    "start": "11730",
    "end": "17460"
  },
  {
    "text": "you can also reach me on Twitter write me an email or come to talk to us later on we also will be at DEFCON and my name",
    "start": "17460",
    "end": "24720"
  },
  {
    "text": "is Michael Schwartz I'm also a PhD student same office same University also on Twitter and you can also drop me an",
    "start": "24720",
    "end": "30929"
  },
  {
    "text": "email talk to us we are here the rest of the conference of course it's not just only as free",
    "start": "30929",
    "end": "36420"
  },
  {
    "text": "there's a whole research team that did a lot of the work here what we are going to present consisting of Clementi movies",
    "start": "36420",
    "end": "43290"
  },
  {
    "text": "daniel ganc in unis your finger Lucas up Lucas dumpster music at Edessa Agassiz",
    "start": "43290",
    "end": "48390"
  },
  {
    "text": "olio kapkan alley Wolfgang Shahi and Yvonne yellow okay let's start directly into the topic",
    "start": "48390",
    "end": "55440"
  },
  {
    "text": "we are talking about Roe hammer today it's a fault in DRAM modules so we have",
    "start": "55440",
    "end": "61230"
  },
  {
    "text": "to talk about DRM first and you might all know that you have it on your service your computer's your laptop's",
    "start": "61230",
    "end": "67340"
  },
  {
    "text": "this Tim your memory and most of you will have more of more than one of that",
    "start": "67340",
    "end": "73200"
  },
  {
    "text": "like two dims in your computer they are connected to your CPU by different channels and they also usually have two",
    "start": "73200",
    "end": "81360"
  },
  {
    "text": "sides front side and the back side and we call them ranks and if we zoom into",
    "start": "81360",
    "end": "86790"
  },
  {
    "text": "that bit more with a lot of chips on those things on both sides and those",
    "start": "86790",
    "end": "91890"
  },
  {
    "text": "chips then consists of multiple banks and in these banks we can find some rows",
    "start": "91890",
    "end": "96990"
  },
  {
    "text": "a lot of rows and also a row buffer we will talk about the row buffer and more",
    "start": "96990",
    "end": "103170"
  },
  {
    "text": "detail later because it's a really important part for row hammering right",
    "start": "103170",
    "end": "108540"
  },
  {
    "text": "now we're focusing on the rows and on the rows such a row consists of multiple",
    "start": "108540",
    "end": "114479"
  },
  {
    "text": "cells the cells are the actual bits that are stored in memory every cell",
    "start": "114479",
    "end": "119729"
  },
  {
    "text": "represents one bit and it consists of one capacitor and one transistor and",
    "start": "119729",
    "end": "125000"
  },
  {
    "text": "this is where the data is actually stored by ADA charging the capacitor or",
    "start": "125000",
    "end": "130709"
  },
  {
    "text": "having it not charged okay this sounds all very complicated maybe we start with a simpler case where",
    "start": "130709",
    "end": "137010"
  },
  {
    "start": "134000",
    "end": "134000"
  },
  {
    "text": "the CPU wants to access one row what happens then so if you want to access data we can't do that by twice and erm",
    "start": "137010",
    "end": "143910"
  },
  {
    "text": "we always have to access one row and we have to read one row so first of all we",
    "start": "143910",
    "end": "150810"
  },
  {
    "text": "have to activate the row we want to read where the data is stored that we want to retrieve and so the memory row is",
    "start": "150810",
    "end": "157560"
  },
  {
    "text": "activated there then it's copied into the row buffer so whole row is copied",
    "start": "157560",
    "end": "162900"
  },
  {
    "text": "into this buffer and only the contents of the buffer can be actually read by",
    "start": "162900",
    "end": "168450"
  },
  {
    "text": "the CPU and it's returned to the CPU okay that sounds really slow actually and what happens if the CPU now wants to",
    "start": "168450",
    "end": "175470"
  },
  {
    "text": "access another row then we do the same thing again so we want to access a different row we have to again activate",
    "start": "175470",
    "end": "182940"
  },
  {
    "text": "that row first then we have something different in a row buffer we have to overwrite the row buffer with the new",
    "start": "182940",
    "end": "189120"
  },
  {
    "text": "row if we change the content before we even have to write back the Dro buffer",
    "start": "189120",
    "end": "194460"
  },
  {
    "text": "to the old row before that then you have this new row in the row buffer and we can return this value to the CPU so this",
    "start": "194460",
    "end": "203100"
  },
  {
    "text": "is this is quite slow a little bit so it's always slow is there a case that is fast for instance if we access the same",
    "start": "203100",
    "end": "209460"
  },
  {
    "text": "row again and we don't have a conflict so that's a lot better for performance and if we want to access state that it's",
    "start": "209460",
    "end": "216330"
  },
  {
    "text": "in the same row then this rows are in the row buffer and we don't have to copy anything and we can directly return the",
    "start": "216330",
    "end": "223830"
  },
  {
    "text": "content of the row buffer to the CPU so this is fast this is a row hit we hit the same row again and this is actually",
    "start": "223830",
    "end": "230880"
  },
  {
    "text": "pretty fast so what you're saying basically the row buffer is a cache where you can store",
    "start": "230880",
    "end": "236730"
  },
  {
    "text": "one row and cache it and if you now have access to a high resolution timer what",
    "start": "236730",
    "end": "242490"
  },
  {
    "text": "you can do you can actually time how long it takes to load the address and we",
    "start": "242490",
    "end": "248070"
  },
  {
    "start": "245000",
    "end": "245000"
  },
  {
    "text": "can distinguish the cases where we have a row hit and a row conflict as we can see on this plot so we can easily find a",
    "start": "248070",
    "end": "255660"
  },
  {
    "text": "threshold in between which allows us to distinguish between row hits and row conflicts yes and as measure I said",
    "start": "255660",
    "end": "263640"
  },
  {
    "text": "before these cells consists of capacity and capacitor is discharged over time if",
    "start": "263640",
    "end": "270690"
  },
  {
    "text": "they discharged over time we have to refresh them frequently and this is also what happens in DRAM all the time but so",
    "start": "270690",
    "end": "278610"
  },
  {
    "text": "if you want to read this row and we copied to the row buffer we actually destroy the content of the row because",
    "start": "278610",
    "end": "284849"
  },
  {
    "text": "we discharged all the capacitors to measure them there also other effect yeah that's a problem there because",
    "start": "284849",
    "end": "290720"
  },
  {
    "text": "everything is so small in there already that we also discharge neighboring capacitors there okay that's a bit of a",
    "start": "290720",
    "end": "298770"
  },
  {
    "text": "problem right and if we do that often enough if we do that often enough and the contents are not refreshed fast",
    "start": "298770",
    "end": "305669"
  },
  {
    "text": "enough then suddenly we have bit flips and we get different contents in",
    "start": "305669",
    "end": "310680"
  },
  {
    "text": "neighboring row rows that we can't even access okay this sounds quite bad but",
    "start": "310680",
    "end": "316470"
  },
  {
    "start": "316000",
    "end": "316000"
  },
  {
    "text": "let's see how widespread this issue actually is maybe this only effects something like below average substandard",
    "start": "316470",
    "end": "324240"
  },
  {
    "text": "DRAM modules that we that sell off the truck somewhere or something I don't know let's talk about ddr3 and ddr4 here",
    "start": "324240",
    "end": "331889"
  },
  {
    "text": "of course it also effects ddr2 we also saw a bit flips on LPD do what you want anymore yes that's true old but for ddr3",
    "start": "331889",
    "end": "340320"
  },
  {
    "text": "there's a study that showed from 2014 kemerall showed that 85% of the modules they had",
    "start": "340320",
    "end": "347400"
  },
  {
    "text": "were affected and see later on 2015 see bond and julian showed that 52% of the",
    "start": "347400",
    "end": "354630"
  },
  {
    "text": "modules they had were affected to their specific hammering method that they used in software for ddr4 people first",
    "start": "354630",
    "end": "362370"
  },
  {
    "text": "believe yeah this is safe you can't flip it's there because that's also what the vendors claimed but we tried it and it",
    "start": "362370",
    "end": "369690"
  },
  {
    "text": "works we showed bit flips on ddr4 in 2016 also there was a paper that had a small",
    "start": "369690",
    "end": "376919"
  },
  {
    "text": "prevalence study with 12 modules and there eight modules were affected came",
    "start": "376919",
    "end": "382380"
  },
  {
    "text": "at all in the original paper also had a correlation to the manufacturing date of",
    "start": "382380",
    "end": "387659"
  },
  {
    "text": "the module so they showed that this seems to be correlated with the",
    "start": "387659",
    "end": "392759"
  },
  {
    "text": "manufacturing date so yeah it flips everywhere ok",
    "start": "392759",
    "end": "399330"
  },
  {
    "start": "398000",
    "end": "398000"
  },
  {
    "text": "what do we need to induce row hammer bit flips we want to reach the DRM so we",
    "start": "399330",
    "end": "406020"
  },
  {
    "text": "need to have uncashed memory accesses we need to bypass the cache somehow this",
    "start": "406020",
    "end": "411060"
  },
  {
    "text": "also has to be fast and this is a problem because uncashed memory accesses are much slower than cached accesses and",
    "start": "411060",
    "end": "416789"
  },
  {
    "text": "now we want to be fast so that we are faster than the next drawer refresh and we also need to target the accesses so",
    "start": "416789",
    "end": "423780"
  },
  {
    "text": "we need to access the correct rows that trigger such bit flips so the question",
    "start": "423780",
    "end": "431460"
  },
  {
    "text": "arises how do we get enough on cache accesses because we have two CPU cache and whenever we load some data it's",
    "start": "431460",
    "end": "437699"
  },
  {
    "text": "stored in the cache and it remains in the cache for subsequent accesses so that those accesses are pretty fast and",
    "start": "437699",
    "end": "443699"
  },
  {
    "text": "makes our systems very fast that we have them nowadays so we have different",
    "start": "443699",
    "end": "448800"
  },
  {
    "start": "447000",
    "end": "447000"
  },
  {
    "text": "methods that we can use to remove data from the cache so that the next axis will be loaded from the main memory and",
    "start": "448800",
    "end": "455419"
  },
  {
    "text": "the first thing is the CL flash instruction and this instruction was also proposed in the original paper and",
    "start": "455419",
    "end": "461939"
  },
  {
    "text": "it's an unprivileged instruction that you can use to just remove the address from the cache in 2015 we then showed",
    "start": "461939",
    "end": "468930"
  },
  {
    "text": "that we can also do this with cache eviction even from JavaScript you might remember the name row Hema Jas because",
    "start": "468930",
    "end": "476639"
  },
  {
    "text": "of course at some point the cache is too small and whenever we load more and commentator at some point the CPU needs",
    "start": "476639",
    "end": "482759"
  },
  {
    "text": "to decide what it needs to evict from the cache so the next time we accesses it will be loaded from the DRAM again",
    "start": "482759",
    "end": "488750"
  },
  {
    "text": "what we also can do is to use non temporal accesses which do not get stored in the cache at all or what we",
    "start": "488750",
    "end": "496229"
  },
  {
    "text": "have seen we can also use a sham cache memory s from the vin showed us on the",
    "start": "496229",
    "end": "502229"
  },
  {
    "text": "android system where they had bit flips on mobile devices yes i'm cache memory sounds really unsafe because we don't",
    "start": "502229",
    "end": "508710"
  },
  {
    "text": "need cash eviction then so now we can have pit flips but how do we target",
    "start": "508710",
    "end": "514279"
  },
  {
    "text": "accesses Michael yeah so we usually don't know about anything about the",
    "start": "514279",
    "end": "519719"
  },
  {
    "start": "518000",
    "end": "518000"
  },
  {
    "text": "addresses and where they are actually stored in which were a row of the DRAM but luckily in 2016 at blackhat Europe",
    "start": "519719",
    "end": "528020"
  },
  {
    "text": "and as Forgan I presented such an attack drama",
    "start": "528020",
    "end": "533130"
  },
  {
    "text": "which allowed us to really get a good picture of how the data is stored in the",
    "start": "533130",
    "end": "538620"
  },
  {
    "text": "DRAM and which address maps to which part of the DRM and how do we target specific roles in the DRM for our omi",
    "start": "538620",
    "end": "547410"
  },
  {
    "text": "attack ok so what you're saying is now we can induce random bit flips right",
    "start": "547410",
    "end": "554819"
  },
  {
    "start": "549000",
    "end": "549000"
  },
  {
    "text": "random bit flips that what we all heard about roarhammer it's random bit flips and here the question is if it's random",
    "start": "554819",
    "end": "561750"
  },
  {
    "text": "bit flips can't we this useless in some fancy ways true randomness is really expensive right and it turns out this is",
    "start": "561750",
    "end": "568980"
  },
  {
    "text": "not true randomness they are not random if you hammer the same locations again",
    "start": "568980",
    "end": "574019"
  },
  {
    "text": "you will get the same bit flip pattern it's highly reproducible so what you can",
    "start": "574019",
    "end": "580500"
  },
  {
    "text": "do is you can think of a data structure that you want to modify and think about the bit position that you want to change",
    "start": "580500",
    "end": "587130"
  },
  {
    "text": "and then you scan the entire memory for bit flips at the right offset and then",
    "start": "587130",
    "end": "593339"
  },
  {
    "text": "try to move your data structure there for instance by spraying and then you",
    "start": "593339",
    "end": "598769"
  },
  {
    "text": "can trigger the bit flip again and you have changed exactly the right bit to exactly the right value and can do",
    "start": "598769",
    "end": "604829"
  },
  {
    "text": "whatever you want with it yes in addition you can also build a path with it because it's not random you",
    "start": "604829",
    "end": "611550"
  },
  {
    "text": "cannot build a random number generator ok so when we have bit flips now Daniel",
    "start": "611550",
    "end": "620850"
  },
  {
    "start": "615000",
    "end": "615000"
  },
  {
    "text": "what can we do with them so it's just one simple bit any ideas about what to",
    "start": "620850",
    "end": "626339"
  },
  {
    "text": "actually exploit with that in 2015 Seabourn and julian showed that we can modify op codes because opcodes have",
    "start": "626339",
    "end": "633329"
  },
  {
    "text": "variable length and you might have a Cisco instruction in included in a",
    "start": "633329",
    "end": "639720"
  },
  {
    "text": "longer opcode so you have a long opcode and part of the opcode could be interpreted as a Cisco but usually",
    "start": "639720",
    "end": "646439"
  },
  {
    "text": "because in Chrome NaCl or something you would have sanitization running you",
    "start": "646439",
    "end": "651630"
  },
  {
    "text": "could not jump to this dis aligned memory address and what you can do now",
    "start": "651630",
    "end": "656939"
  },
  {
    "text": "is you can induce a bit flip at the right offset and then you can jump to this this aligned memory location and",
    "start": "656939",
    "end": "663380"
  },
  {
    "text": "performance is called yeah they showed that you can exploit",
    "start": "663380",
    "end": "669020"
  },
  {
    "text": "the chrome NaCl sandbox with that but what do we do if we want to have a more",
    "start": "669020",
    "end": "677150"
  },
  {
    "text": "generic exploit for instance get access to ring zero and there we can attack",
    "start": "677150",
    "end": "685360"
  },
  {
    "text": "data structures that belong to the kernel for instance the page tables if",
    "start": "685360",
    "end": "690680"
  },
  {
    "start": "688000",
    "end": "688000"
  },
  {
    "text": "you think about the page tables we have here the present bit the right of the right access user space access right",
    "start": "690680",
    "end": "697250"
  },
  {
    "text": "through uncashed reference dirty the size with the global bit and the non-executable bit and we have addition",
    "start": "697250",
    "end": "703400"
  },
  {
    "text": "we have some bits that are not even used there yes and the large red part does",
    "start": "703400",
    "end": "709430"
  },
  {
    "text": "anyone know what this part represent represents the page number it's the page",
    "start": "709430",
    "end": "716690"
  },
  {
    "text": "number and if we flip a bit in there then the mapping from virtual address to",
    "start": "716690",
    "end": "723680"
  },
  {
    "text": "a physical address changes luckily page",
    "start": "723680",
    "end": "728810"
  },
  {
    "text": "tables are organized in 512 such entries in 1 4 kilobyte page so most of the data",
    "start": "728810",
    "end": "734600"
  },
  {
    "text": "on this 4 kilobyte page will consist of physical page numbers so maybe we should",
    "start": "734600",
    "end": "739730"
  },
  {
    "text": "learn a bit more about page tables yeah if you look at the page tables is a really fundamental concept of virtual",
    "start": "739730",
    "end": "745850"
  },
  {
    "start": "742000",
    "end": "742000"
  },
  {
    "text": "memory nowadays so in our programs we have our virtual addresses we call them usually just addresses because we are",
    "start": "745850",
    "end": "752390"
  },
  {
    "text": "never in touch with physically addresses and they somehow map to some part of the physical memory the data as we stored",
    "start": "752390",
    "end": "758990"
  },
  {
    "text": "somewhere and then we have this page table entries and hole paging structure behind them and they then actually map",
    "start": "758990",
    "end": "765260"
  },
  {
    "text": "this virtual address to one physical address and the interesting thing is so",
    "start": "765260",
    "end": "772820"
  },
  {
    "text": "they can map page length we can map any user page or Karl page and the cool thing is if we modify this page table",
    "start": "772820",
    "end": "780470"
  },
  {
    "text": "entry as daniel said we can make it map a different physical page so we could map any page that we have in memory and",
    "start": "780470",
    "end": "787340"
  },
  {
    "text": "then accesses using this virtual address so then we could map some kernel pages",
    "start": "787340",
    "end": "794000"
  },
  {
    "text": "or other page tables or some other user pages",
    "start": "794000",
    "end": "799160"
  },
  {
    "text": "and this is realized so no saint operating system would allow that okay",
    "start": "799160",
    "end": "805490"
  },
  {
    "text": "so what we can do here is we can first scan for the bit flips as we said at some point we will find a location where",
    "start": "805490",
    "end": "812150"
  },
  {
    "text": "we have the right bit flip in this four kilobyte page and then we release this page we free this page and spray the",
    "start": "812150",
    "end": "820070"
  },
  {
    "text": "entire memory fill the entire memory with page tables including this memory location and then we will get to this",
    "start": "820070",
    "end": "826190"
  },
  {
    "text": "picture here so what happens now if we trigger the same bit flip on the victim",
    "start": "826190",
    "end": "831560"
  },
  {
    "text": "page that we had earlier and released with a high chance we flip a bit in the page number which now points directly to",
    "start": "831560",
    "end": "839000"
  },
  {
    "text": "one of our page tables that we control and what can we do with that micro now",
    "start": "839000",
    "end": "844610"
  },
  {
    "text": "we control everything right now we have right access to a page table so this is realize we can map anything read",
    "start": "844610",
    "end": "851870"
  },
  {
    "text": "anything writes to everything so we just simply scan for bit flips exhaust met",
    "start": "851870",
    "end": "857410"
  },
  {
    "text": "memory to have a lot of page tables in the memory and then flip one bit one",
    "start": "857410",
    "end": "863240"
  },
  {
    "text": "page table will point to a different page table we can rewrite the page table entry and we have full access aright I",
    "start": "863240",
    "end": "869510"
  },
  {
    "text": "read anything right anywhere primitive on our computer okay really nice so",
    "start": "869510",
    "end": "874700"
  },
  {
    "text": "these were the basics about the row hammer attack this is all 2015 and earlier but then there were also other",
    "start": "874700",
    "end": "881810"
  },
  {
    "text": "attacks for instance yeah so this this",
    "start": "881810",
    "end": "887990"
  },
  {
    "text": "first idea was from 2015 and it was also reused later on in other words we used it in raw hamachi is it was also used in",
    "start": "887990",
    "end": "895250"
  },
  {
    "text": "one bit flips one cloud flops and then in the drama exploit as well okay so we",
    "start": "895250",
    "end": "902180"
  },
  {
    "start": "900000",
    "end": "900000"
  },
  {
    "text": "can flip bits and the interesting thing is we can only flip bits in page tables",
    "start": "902180",
    "end": "907310"
  },
  {
    "text": "if a lot of more possibilities when we have bit flips we can modify binary",
    "start": "907310",
    "end": "912590"
  },
  {
    "text": "pages have different code credential structs we can corrupt keys or",
    "start": "912590",
    "end": "918080"
  },
  {
    "text": "signatures so basic fault attacks we know we can modify certificates to point to different stuff or make them valid",
    "start": "918080",
    "end": "925310"
  },
  {
    "text": "again you can flip configuration files because we usually have some binary configurations in there to enable or",
    "start": "925310",
    "end": "931490"
  },
  {
    "text": "disable something so there are many many possibilities with just one simple bit flip that we",
    "start": "931490",
    "end": "937010"
  },
  {
    "text": "can induce with brohamer yeah and paid pages are pretty unique they have 32,768 bits they are usually",
    "start": "937010",
    "end": "948650"
  },
  {
    "text": "not identical by coincidence and this brings us to the next point paid seed",
    "start": "948650",
    "end": "953839"
  },
  {
    "start": "953000",
    "end": "953000"
  },
  {
    "text": "application this was exploited in several attacks by music and they also",
    "start": "953839",
    "end": "960200"
  },
  {
    "text": "scan for bid flips they find a location where they have a bit flip and they have another page that they want to relocate there so that they",
    "start": "960200",
    "end": "967610"
  },
  {
    "text": "can induce the bit flip on this page and they do this by storing the same content",
    "start": "967610",
    "end": "973160"
  },
  {
    "text": "on this vulnerable page and then waiting for deduplication the deduplication",
    "start": "973160",
    "end": "978529"
  },
  {
    "text": "hopefully will be replicate in the right direction and if it does then we can induce the bit flip on this page that we",
    "start": "978529",
    "end": "985100"
  },
  {
    "text": "actually should not be able to write to yeah so what can we do now with careful",
    "start": "985100",
    "end": "995210"
  },
  {
    "text": "flips again then we place the content that we want to do to placate so that",
    "start": "995210",
    "end": "1000430"
  },
  {
    "text": "the bit flip can be exploited in the end we perform the bit change through our om attack and profit yeah this is also an",
    "start": "1000430",
    "end": "1011350"
  },
  {
    "text": "idea and it's from 2016 and also with those bit flips we can do a lot of",
    "start": "1011350",
    "end": "1016360"
  },
  {
    "text": "interesting stuff by flipping pointers pointing to different objects or and corrupt keys make the user install",
    "start": "1016360",
    "end": "1024730"
  },
  {
    "text": "updates from untrusted sources by modifying their update file so there are also quite interesting ideas they have",
    "start": "1024730",
    "end": "1032140"
  },
  {
    "text": "already been done before that so apparently we have a real problem",
    "start": "1032140",
    "end": "1037959"
  },
  {
    "text": "because we can just induce pit flips to get root privileges corrupt something different can we mitigate that they were",
    "start": "1037959",
    "end": "1045250"
  },
  {
    "start": "1044000",
    "end": "1044000"
  },
  {
    "text": "of course different proposes to mitigate that so we can distinguish between we can detect it we can prevent it",
    "start": "1045250",
    "end": "1052020"
  },
  {
    "text": "Prevention's usually better than that we can do all the stuff either in software or in Hardware where software's for us",
    "start": "1052020",
    "end": "1059590"
  },
  {
    "text": "easier and then we can talk about short term solution quick fixes that fix it",
    "start": "1059590",
    "end": "1064990"
  },
  {
    "text": "for some time long-term solutions which are they're really good solutions that we then should apply so can we talk about some",
    "start": "1064990",
    "end": "1072310"
  },
  {
    "text": "of them yes so there are also some solutions that maybe do not work the first that comes in mind when we look at",
    "start": "1072310",
    "end": "1078910"
  },
  {
    "text": "the earlier slides we just use seal flush to kick something out of the cache but yeah just forbids dissing structure",
    "start": "1078910",
    "end": "1085480"
  },
  {
    "text": "right we can use Rohan right yes instead the election approach where we don't need CL flush and it works just as well",
    "start": "1085480",
    "end": "1092920"
  },
  {
    "text": "right oh you also said that during the refresh interval we can trigger the bit flip so",
    "start": "1092920",
    "end": "1098860"
  },
  {
    "text": "we just increase the refresh rate so that the content gets updated early yeah so you cannot induce a bit flip yeah but",
    "start": "1098860",
    "end": "1105070"
  },
  {
    "text": "that also does not work in 2014 Kamath I already showed that on some modules they",
    "start": "1105070",
    "end": "1110140"
  },
  {
    "text": "have they would have to increase the refresh rate by factor seven and this would significantly reduce the",
    "start": "1110140",
    "end": "1116530"
  },
  {
    "text": "performance of the DRAM modules so this is not also not really a good solution",
    "start": "1116530",
    "end": "1122220"
  },
  {
    "text": "there was an American implemented by most or by many BIOS vendors where they",
    "start": "1122220",
    "end": "1129630"
  },
  {
    "text": "doubled the refresh rate but this effectively brings little I will try to",
    "start": "1129630",
    "end": "1135460"
  },
  {
    "text": "have it implement it on on Hardware level like use error correcting codes in theorem ECC Ram that should be a lot",
    "start": "1135460",
    "end": "1142810"
  },
  {
    "start": "1136000",
    "end": "1136000"
  },
  {
    "text": "better because they are designed to prevent exactly that that's correct but there is no standard for event",
    "start": "1142810",
    "end": "1148900"
  },
  {
    "text": "reporting for ECC memory and that's quite bad because there was in 2016 a",
    "start": "1148900",
    "end": "1156100"
  },
  {
    "text": "study that found that some servers count the ECC Eros and only if they reach a",
    "start": "1156100",
    "end": "1161320"
  },
  {
    "text": "certain threshold the errors would be reported for instance 100 bit flips per hour only if it goes beyond that",
    "start": "1161320",
    "end": "1167850"
  },
  {
    "text": "threshold they would be reported and in some cases even the OS was never",
    "start": "1167850",
    "end": "1174490"
  },
  {
    "text": "informed about errors not even on corrected errors and this is quite bad if the system continues running although",
    "start": "1174490",
    "end": "1180700"
  },
  {
    "text": "it has ECC memory so there are also some",
    "start": "1180700",
    "end": "1185890"
  },
  {
    "start": "1184000",
    "end": "1184000"
  },
  {
    "text": "other solutions that we have in hardware so the original ideas were proposed in",
    "start": "1185890",
    "end": "1191170"
  },
  {
    "text": "the commit all paper that showed that we have those bit flips so an easy approach is we just make better tear em chips",
    "start": "1191170",
    "end": "1197590"
  },
  {
    "text": "that are not prone to bit flips at all or we use ECC like Daniel described now",
    "start": "1197590",
    "end": "1203350"
  },
  {
    "text": "or we just increase the refresh rate but all of that is not sufficient ECC is a good way to go in addition we could",
    "start": "1203350",
    "end": "1211240"
  },
  {
    "text": "after manufacture and check if there are any cells that are vulnerable to the roham attack and try to remap them or",
    "start": "1211240",
    "end": "1217900"
  },
  {
    "text": "retire them so that they are not used or we can identify Hemet rows at runtime",
    "start": "1217900",
    "end": "1223060"
  },
  {
    "text": "and try to refresh them automatically so that you cannot induce any bit but all",
    "start": "1223060",
    "end": "1229930"
  },
  {
    "text": "of those are in Hardware they're either expensive there's a performance overhead that comes with them also we increase",
    "start": "1229930",
    "end": "1236680"
  },
  {
    "text": "the power consumption and for instance on mobile devices we do not want to do that because we want our phones to last",
    "start": "1236680",
    "end": "1242170"
  },
  {
    "text": "long but it's not the only proposal still there were a lot of proposals afterwards researchers trying to prevent",
    "start": "1242170",
    "end": "1248920"
  },
  {
    "text": "the Rehema effect for example the power the probabilistic adjacent row activation where this was also in the",
    "start": "1248920",
    "end": "1257740"
  },
  {
    "text": "original paper still so every time a row is closed we open with a certain probability and adjacent row so if we",
    "start": "1257740",
    "end": "1265720"
  },
  {
    "text": "have a and we have a lot of row closings and we refresh the neighboring rows more",
    "start": "1265720",
    "end": "1270760"
  },
  {
    "text": "often and that should help us to also refresh them and prevent the row hema effect this is quite easy to implement",
    "start": "1270760",
    "end": "1277480"
  },
  {
    "text": "in hardware and doesn't have a huge overhead and can give give quite good",
    "start": "1277480",
    "end": "1283690"
  },
  {
    "text": "result so it's okay but only as long as we can only induce bit flips in adjacent",
    "start": "1283690",
    "end": "1289030"
  },
  {
    "text": "rows right if this yes not true then we have a problem there was also a similar technique I would say it's a bit similar",
    "start": "1289030",
    "end": "1297670"
  },
  {
    "text": "its target raw refresh and pewter target row refresh and this pretty much worked like this you hammer to memory locations",
    "start": "1297670",
    "end": "1303880"
  },
  {
    "text": "to different rows and you have a counter per row now and this is just incremented",
    "start": "1303880",
    "end": "1309010"
  },
  {
    "text": "as you access memory locations and if the counter reaches a certain threshold",
    "start": "1309010",
    "end": "1315250"
  },
  {
    "text": "the current the corresponding row is refreshed so you can see it here now",
    "start": "1315250",
    "end": "1321370"
  },
  {
    "text": "it's refreshed yeah sounds ok if you have bit fits in there chasing throws",
    "start": "1321370",
    "end": "1326590"
  },
  {
    "text": "but what if the bit flips are somewhere else so we tried that with your are active on",
    "start": "1326590",
    "end": "1332320"
  },
  {
    "text": "our system and we get a lot less bit flips because we didn't have bid flips in a chase and rolls anymore but a few rows apart we",
    "start": "1332320",
    "end": "1339370"
  },
  {
    "text": "still had bid flip so that might not be sufficient I think the attacker is not allowed to do that as all of the fred model i guess",
    "start": "1339370",
    "end": "1345700"
  },
  {
    "text": "but okay let's go for the note hammer kernel module that was an idea from the",
    "start": "1345700",
    "end": "1351429"
  },
  {
    "start": "1346000",
    "end": "1346000"
  },
  {
    "text": "Linux kernel mailing list in 2016 and here the idea was similar as with TR but",
    "start": "1351429",
    "end": "1357550"
  },
  {
    "text": "it's purely in software quite nice so basically a refresh rate of 8 milliseconds would prevent draw him on",
    "start": "1357550",
    "end": "1364210"
  },
  {
    "text": "most systems that what we what we heard before factor 7 above the current refresh rate is fine so factor 8 is also",
    "start": "1364210",
    "end": "1371500"
  },
  {
    "text": "fine and we use performance counters to measure the number of cache misses / 64",
    "start": "1371500",
    "end": "1376990"
  },
  {
    "text": "millisecond interval and if this reaches a certain value namely 1/8 of the",
    "start": "1376990",
    "end": "1384429"
  },
  {
    "text": "maximum then we wait for a refresh and block any operation we don't schedule",
    "start": "1384429",
    "end": "1389950"
  },
  {
    "text": "anything on the processor anymore until the 64 milliseconds password basically halt the whole system yes okay that",
    "start": "1389950",
    "end": "1396640"
  },
  {
    "text": "sounds good right but the problem is now if we have different excesses here then we also reach this threshold because the",
    "start": "1396640",
    "end": "1404410"
  },
  {
    "text": "performance counter cannot really distinguish between all the different rows and then again we wait for a",
    "start": "1404410",
    "end": "1410260"
  },
  {
    "text": "refresh although this was not necessary at all so have you thought about the performance this sounds pretty stupid to",
    "start": "1410260",
    "end": "1418330"
  },
  {
    "text": "me yeah you hold the system the entire time yeah and in addition what we've",
    "start": "1418330",
    "end": "1423460"
  },
  {
    "text": "seen lately with GPU chrome spawning unit paper or with the remote quorum",
    "start": "1423460",
    "end": "1429130"
  },
  {
    "text": "attacks either fro hema using a DMA based network accounts or our net hammer paper which uses commodity Hardware to",
    "start": "1429130",
    "end": "1436300"
  },
  {
    "text": "induce remote bit flips we do not care about that at all so maybe we don't want",
    "start": "1436300",
    "end": "1441820"
  },
  {
    "text": "to dynamically see the row am i attack and then stop it but we want to do some binary analysis",
    "start": "1441820",
    "end": "1448660"
  },
  {
    "text": "there the exploits we do the same thing as antivirus programs we analyze the binary and if they have suspicious code",
    "start": "1448660",
    "end": "1454990"
  },
  {
    "text": "in there like this your Flash instruction who uses that or early dlc or fences then we can flag that and",
    "start": "1454990",
    "end": "1461830"
  },
  {
    "text": "detect the row hema attack with that so you you ask the attacker to compile the attack with your comp",
    "start": "1461830",
    "end": "1467750"
  },
  {
    "text": "so that the attacker learns you cannot run this code I can also do it in an anti-virus program okay okay but I just",
    "start": "1467750",
    "end": "1474680"
  },
  {
    "text": "said you also have those remote attacks so I don't care about the code on your system at all okay then maybe then we",
    "start": "1474680",
    "end": "1484070"
  },
  {
    "text": "might want to go back to the performance counters and detect the row hema attack and if we have a lot of cache misses",
    "start": "1484070",
    "end": "1490430"
  },
  {
    "text": "then we activate neighbor rows so similar thing is stuff in Hardware part",
    "start": "1490430",
    "end": "1496010"
  },
  {
    "text": "in software ok this was also from 2016 but what if performance counters do not",
    "start": "1496010",
    "end": "1502670"
  },
  {
    "text": "work why would they not work because we run our attack in SGX and STX performance counters are not reflected",
    "start": "1502670",
    "end": "1510230"
  },
  {
    "text": "in the normal world performance counters but you shouldn't do bad things nest checks yeah it's also not in the fret",
    "start": "1510230",
    "end": "1516230"
  },
  {
    "text": "you're not allowed to do this right yeah ok so we come back to some Hardware ideas that we have so what if during",
    "start": "1516230",
    "end": "1524000"
  },
  {
    "text": "boot with scan the entire memory check those locations where we can induce bit flips and just block them so that you",
    "start": "1524000",
    "end": "1531020"
  },
  {
    "text": "cannot use them at all yeah this was proposed in 2017 yeah they're also proposed to isolate security domains so",
    "start": "1531020",
    "end": "1538220"
  },
  {
    "text": "the kernel is not next to use the space so we don't have any page tables in our reach for the romantic mm-hmm so this",
    "start": "1538220",
    "end": "1544820"
  },
  {
    "text": "will look like this so either we disable memory or we leave gaps between the",
    "start": "1544820",
    "end": "1550370"
  },
  {
    "text": "different security domains right the problem here is if we use big head there",
    "start": "1550370",
    "end": "1556280"
  },
  {
    "text": "are multiple studies that find that 95 percent or more of your drm might be",
    "start": "1556280",
    "end": "1561470"
  },
  {
    "text": "blocked and unusable so this is not really practical a memory overhead of 95 percent I don't know why do i why do I",
    "start": "1561470",
    "end": "1570590"
  },
  {
    "text": "pay so much for my memory if I can't use 95 percent that sounds odd and also for",
    "start": "1570590",
    "end": "1577250"
  },
  {
    "text": "G ked what about pages that are shared between different security domains shared libraries are there no shared",
    "start": "1577250",
    "end": "1583520"
  },
  {
    "text": "libraries anymore what about non kernel pages because G cap was mostly about kernel to user",
    "start": "1583520",
    "end": "1589910"
  },
  {
    "text": "space isolation what about non kernel pages so this is all not covered here how far do you move",
    "start": "1589910",
    "end": "1597740"
  },
  {
    "text": "them apart anyways yes because we don't know what the maximum is the maximum distance between",
    "start": "1597740",
    "end": "1602750"
  },
  {
    "text": "hammering location and bid Phillip location we observe cases of more than a",
    "start": "1602750",
    "end": "1608790"
  },
  {
    "text": "dros apart so this is easily above one or two megabytes it was a similar space",
    "start": "1608790",
    "end": "1616110"
  },
  {
    "text": "approach with isolating EMA buffers in physical memory so that we can't hammer",
    "start": "1616110",
    "end": "1621180"
  },
  {
    "text": "with them but again we have the same problem right yeah and moved him apart how far sorry",
    "start": "1621180",
    "end": "1628460"
  },
  {
    "text": "how far apart should we go then then we also looked at performance counters we",
    "start": "1628460",
    "end": "1634170"
  },
  {
    "start": "1632000",
    "end": "1632000"
  },
  {
    "text": "did that in 2016 unless fork together with Herod looked at that in 2015 there",
    "start": "1634170",
    "end": "1643830"
  },
  {
    "text": "was also other another paper by Matthias pie in 2016 and you can observe that",
    "start": "1643830",
    "end": "1651360"
  },
  {
    "text": "there is a row hammer attack going on but it's very difficult to find something which has no false positives",
    "start": "1651360",
    "end": "1657960"
  },
  {
    "text": "and false positives are really bad if it's about its detection of attacks but",
    "start": "1657960",
    "end": "1663960"
  },
  {
    "text": "what if you have the case that your performance counters do not get updated at all yes it gets again a problem",
    "start": "1663960",
    "end": "1669210"
  },
  {
    "text": "because you put the attack in an S Jackson glaive and the performance counters are not updated so I can hide the attack on the counter measure yeah",
    "start": "1669210",
    "end": "1676080"
  },
  {
    "start": "1674000",
    "end": "1674000"
  },
  {
    "text": "so so far we have seen a lot of counter measures that we are proposed some of them are existing in real world",
    "start": "1676080",
    "end": "1681540"
  },
  {
    "text": "applications some are more theoretic and they all use different kinds of",
    "start": "1681540",
    "end": "1687650"
  },
  {
    "text": "techniques to detect either by analysis static or dynamic or in Hardware stuff",
    "start": "1687650",
    "end": "1693570"
  },
  {
    "text": "or software countermeasures to try to prevent or detect so we have a huge",
    "start": "1693570",
    "end": "1699570"
  },
  {
    "text": "range of all those countermeasures to try to prevent the Rehema attack so we are safe yeah but they all assume the",
    "start": "1699570",
    "end": "1708240"
  },
  {
    "text": "draw hammer works the way we thought it works by hammering two or more rows so",
    "start": "1708240",
    "end": "1715920"
  },
  {
    "text": "we have what if we have something else yeah actually so there are two different",
    "start": "1715920",
    "end": "1725070"
  },
  {
    "start": "1721000",
    "end": "1721000"
  },
  {
    "text": "hammering techniques we know that there are two different hammering hammering techniques the first is you have a one",
    "start": "1725070",
    "end": "1731160"
  },
  {
    "text": "row and other rows in the same Bank and then you will get trip somewhere the second is you hammer",
    "start": "1731160",
    "end": "1736590"
  },
  {
    "text": "to different roles in the same Bank yeah I know that's all I already did that so",
    "start": "1736590",
    "end": "1742260"
  },
  {
    "start": "1740000",
    "end": "1740000"
  },
  {
    "text": "I choose one row and then I activate it and another random row and again this row and the random row and this row and",
    "start": "1742260",
    "end": "1748440"
  },
  {
    "text": "at some point I get a bit flip next to the one row I activate most often yeah",
    "start": "1748440",
    "end": "1753540"
  },
  {
    "text": "but we can do much better than that because instead of hammering just one world we sandwich our target row and",
    "start": "1753540",
    "end": "1760140"
  },
  {
    "start": "1754000",
    "end": "1754000"
  },
  {
    "text": "hema to neighboring rows and we get bit flips much more reliable and much faster",
    "start": "1760140",
    "end": "1765750"
  },
  {
    "text": "yeah hammering two rows okay we will go for one location hammering there are",
    "start": "1765750",
    "end": "1772980"
  },
  {
    "start": "1772000",
    "end": "1772000"
  },
  {
    "text": "actually three different hammering techniques now we can hammer only one row next to victim row and it works like",
    "start": "1772980",
    "end": "1779040"
  },
  {
    "start": "1779000",
    "end": "1779000"
  },
  {
    "text": "that we access one row we access it again we access it again and it works great bit flips so we have a demo here",
    "start": "1779040",
    "end": "1787500"
  },
  {
    "text": "this is one location hammering on a skylake i7 system and you can see we are",
    "start": "1787500",
    "end": "1795000"
  },
  {
    "text": "hammering a bit here and then after a while we are scanning for bit flips and oh a lot of this you know if ddr4 yeah",
    "start": "1795000",
    "end": "1801750"
  },
  {
    "text": "that's video 4 and with TRR no that's without the tear out your are yeah without yeah we still get a lot of lips",
    "start": "1801750",
    "end": "1808260"
  },
  {
    "text": "just by accessing one senior oh why does that work yeah it doesn't make any sense",
    "start": "1808260",
    "end": "1813660"
  },
  {
    "start": "1813000",
    "end": "1813000"
  },
  {
    "text": "because as we said we have the row buffer which serves as a cache but in addition what we have so-called memory",
    "start": "1813660",
    "end": "1820500"
  },
  {
    "text": "controller policies because at some point the controller needs to decide if it needs to close the row or keep it",
    "start": "1820500",
    "end": "1826530"
  },
  {
    "text": "open so the open page policy says we keep the role open and buffered yeah so",
    "start": "1826530",
    "end": "1833250"
  },
  {
    "text": "that means that we will have a low latency for subsequent accesses to the same row and the high latency for",
    "start": "1833250",
    "end": "1840480"
  },
  {
    "text": "excesses to other rows right that was the case that we observed in the beginning yes yes we also have the",
    "start": "1840480",
    "end": "1846300"
  },
  {
    "text": "closed page policy where we just immediately close a row and prepare to open the next world ok this sounds like",
    "start": "1846300",
    "end": "1853500"
  },
  {
    "text": "it would have a medium latency for XSS to any role right and why do why would",
    "start": "1853500",
    "end": "1859920"
  },
  {
    "text": "we use that yet depending on the policy that we use we can either save memory",
    "start": "1859920",
    "end": "1865350"
  },
  {
    "text": "power consumption or include increase the performance the Ovilus system so we also have adaptive policies that change depending",
    "start": "1865350",
    "end": "1872790"
  },
  {
    "text": "on the usage patterns in the DRM and particularly on multi-core systems the",
    "start": "1872790",
    "end": "1877800"
  },
  {
    "text": "performance of closed draw policies or adaptive policies is much better so",
    "start": "1877800",
    "end": "1883440"
  },
  {
    "text": "where can we find which policy now we can test that we can run a side channel attack again and measure which policy is",
    "start": "1883440",
    "end": "1890490"
  },
  {
    "text": "used but first to sum it up when we have a policy that preemptively closes a row",
    "start": "1890490",
    "end": "1896220"
  },
  {
    "text": "this would allow one location hammering and we found closed page policies mainly",
    "start": "1896220",
    "end": "1901980"
  },
  {
    "text": "on desktop computers and on mobile devices they seem to use in the open",
    "start": "1901980",
    "end": "1907800"
  },
  {
    "text": "page policy most of the time so the question then is how well does one location hammering perform and it",
    "start": "1907800",
    "end": "1912990"
  },
  {
    "text": "performs worse than double-sided of course double-sided is the best it performs worse than single sided but",
    "start": "1912990",
    "end": "1920190"
  },
  {
    "start": "1913000",
    "end": "1913000"
  },
  {
    "text": "still we get a very nice distribution of bit flips across the four kilobyte range",
    "start": "1920190",
    "end": "1926400"
  },
  {
    "text": "this is a four kilobyte page split up into lines every dot there represents",
    "start": "1926400",
    "end": "1931950"
  },
  {
    "text": "one bit offset in the four kilobyte page and the distribution of zero to one",
    "start": "1931950",
    "end": "1936960"
  },
  {
    "text": "flips and one to zero flips they are illustrated in red and blue you can see that they are approximately 50/50 in all",
    "start": "1936960",
    "end": "1943590"
  },
  {
    "text": "cases and in the case of double-sided hammering after eight hours we had 77%",
    "start": "1943590",
    "end": "1950280"
  },
  {
    "text": "of the bit offsets covered with single sided a bit more with one location a bit less half half as many not a bit less",
    "start": "1950280",
    "end": "1958010"
  },
  {
    "text": "okay but in the end with all those counter measures that we've seen like with P ket and cheek at where we",
    "start": "1958010",
    "end": "1964800"
  },
  {
    "text": "separate the memory other security domains we cannot target journal pages",
    "start": "1964800",
    "end": "1970140"
  },
  {
    "text": "anymore right what else can we attack we could do up code flipping so this is a really cool thing many applications that",
    "start": "1970140",
    "end": "1977760"
  },
  {
    "text": "we have running on our computer are performing actions this route anyway think for example the ping command or",
    "start": "1977760",
    "end": "1984210"
  },
  {
    "text": "the mount command or explicitly the sudo command they perform actions as root and",
    "start": "1984210",
    "end": "1989700"
  },
  {
    "text": "the sudo command asked for a password but what if we can",
    "start": "1989700",
    "end": "1994860"
  },
  {
    "text": "patch that some way out so we targeted a pseudo binary and try to flip something",
    "start": "1994860",
    "end": "2001220"
  },
  {
    "text": "in there and the really nice thing about the x86 instructions they are so dense so if you",
    "start": "2001220",
    "end": "2007310"
  },
  {
    "start": "2002000",
    "end": "2002000"
  },
  {
    "text": "look at the one instruction and you flip bits in this instruction then we in most",
    "start": "2007310",
    "end": "2012470"
  },
  {
    "text": "cases we get a different instruction not an invalid instruction but a different instruction so we have here a jumbo the",
    "start": "2012470",
    "end": "2020090"
  },
  {
    "text": "jump equal for the password check yeah that's the trap equal so we check the password and then jump equal and we do this stuff",
    "start": "2020090",
    "end": "2026540"
  },
  {
    "text": "and then your whole to CPU window dia flip there I hold the privilege instruction but there are more",
    "start": "2026540",
    "end": "2031850"
  },
  {
    "text": "instructions I can get an X or I push some prefix for other instructions champ",
    "start": "2031850",
    "end": "2037040"
  },
  {
    "text": "lower champ overflow champ below or equal or champ not equal so we can",
    "start": "2037040",
    "end": "2043640"
  },
  {
    "text": "invert the logic so it's really nice that all the instructions the champ instructions are grouped together so",
    "start": "2043640",
    "end": "2049639"
  },
  {
    "text": "flipping one bit gives you in many cases a different champ instruction with a different logic but that's not all that",
    "start": "2049640",
    "end": "2056600"
  },
  {
    "text": "we can target so besides conditional jumps we can also flip comparisons in general or operands",
    "start": "2056600",
    "end": "2065030"
  },
  {
    "text": "in the comparisons we can change which addresses we load or store or during the",
    "start": "2065030",
    "end": "2070730"
  },
  {
    "text": "address calculation we can change some constants and then use another address if the value did load and by manually",
    "start": "2070730",
    "end": "2078110"
  },
  {
    "text": "analyzing one pseudo binary we found 29 possible bit flip locations where we",
    "start": "2078110",
    "end": "2083960"
  },
  {
    "text": "could circumvent the password check and run a command is route but there are",
    "start": "2083960",
    "end": "2089120"
  },
  {
    "text": "many more to find yes this was many other analyzes okay the question now is",
    "start": "2089120",
    "end": "2094850"
  },
  {
    "text": "if we want to target virtual pages like binary pages how how do we get them to",
    "start": "2094850",
    "end": "2101750"
  },
  {
    "text": "the right target physically okay we need a new technique for that it's not that straightforward because we cannot simply",
    "start": "2101750",
    "end": "2108890"
  },
  {
    "text": "spray our binary over the memory binary is only loaded once in memory and then",
    "start": "2108890",
    "end": "2114080"
  },
  {
    "text": "it stays in memory and this is in some cash in operating system patient page",
    "start": "2114080",
    "end": "2119510"
  },
  {
    "text": "cache and only if this page page cache is full because we execute other binaries that it goes away and sudden",
    "start": "2119510",
    "end": "2126590"
  },
  {
    "text": "the memory anymore otherwise it stays in memory okay so if a binary is loaded to the first time",
    "start": "2126590",
    "end": "2132470"
  },
  {
    "start": "2130000",
    "end": "2130000"
  },
  {
    "text": "into the page cache it stays there and if we evicted if the page cache is",
    "start": "2132470",
    "end": "2139259"
  },
  {
    "text": "full it will be loaded to a new location it's abuse right it's huge yes we we can't just evict the",
    "start": "2139259",
    "end": "2146490"
  },
  {
    "text": "page cache right so yes Mary wailing so basically we want to relocate the page",
    "start": "2146490",
    "end": "2152130"
  },
  {
    "text": "and hit it at the right time when it's sitting at the right location how does it work so we have our binary here in in green",
    "start": "2152130",
    "end": "2158190"
  },
  {
    "start": "2156000",
    "end": "2156000"
  },
  {
    "text": "and our target location and then we can pick the page cache by filling it with",
    "start": "2158190",
    "end": "2163490"
  },
  {
    "text": "binaries until our binary is gone and we reload our binary it's will be at a different location",
    "start": "2163490",
    "end": "2169170"
  },
  {
    "text": "we can't evict it and access the binary until finally at some point our binary",
    "start": "2169170",
    "end": "2174749"
  },
  {
    "text": "is exactly at the location we want it to be so we can introduce our bit flips in the binary okay but do we really reach",
    "start": "2174749",
    "end": "2181499"
  },
  {
    "text": "all the physical pages yes don't we get just the same physical page all over",
    "start": "2181499",
    "end": "2186690"
  },
  {
    "text": "again in fact we are not as you can see on this graph so whenever we get a new",
    "start": "2186690",
    "end": "2192359"
  },
  {
    "text": "physical address for our page with a high chance it's likely to be a new",
    "start": "2192359",
    "end": "2197940"
  },
  {
    "text": "physical location and not the same as we can see in this plot another advantage of this technique is that we do not",
    "start": "2197940",
    "end": "2204960"
  },
  {
    "text": "exhaust the entire memory we use pages that are loaded into the page cache so",
    "start": "2204960",
    "end": "2210269"
  },
  {
    "text": "they can be evicted any at any time so we are not running into any out of memory situation as in previous variants",
    "start": "2210269",
    "end": "2217650"
  },
  {
    "text": "of the row hammer attack but our memory usage actually as reported by the operating system stays very low",
    "start": "2217650",
    "end": "2222839"
  },
  {
    "text": "approximately at sixty sixty-five percent if starting at sixty percent so it stays really really low so it's not a",
    "start": "2222839",
    "end": "2229920"
  },
  {
    "text": "problem for system stability yeah but we can do more for instance we can combine",
    "start": "2229920",
    "end": "2235529"
  },
  {
    "text": "row hammer with intellect checks to get a cheap denial of service attack so intellect X is an instruction set",
    "start": "2235529",
    "end": "2242880"
  },
  {
    "text": "extensions which gives us integrity and confidentiality of code and data in an",
    "start": "2242880",
    "end": "2248039"
  },
  {
    "text": "untrusted environment and it runs with user privileges and is very restricted",
    "start": "2248039",
    "end": "2253859"
  },
  {
    "text": "so you cannot call any system calls in there and programs are run in so called",
    "start": "2253859",
    "end": "2260099"
  },
  {
    "text": "enclaves which is a in a certain part of the memory which is a protected area of",
    "start": "2260099",
    "end": "2265410"
  },
  {
    "text": "memory called TBC yes this EPC is just in the physical memory somewhere and",
    "start": "2265410",
    "end": "2270690"
  },
  {
    "start": "2268000",
    "end": "2268000"
  },
  {
    "text": "it's encrypted and integrity checked and the question then of course is what",
    "start": "2270690",
    "end": "2275970"
  },
  {
    "text": "happens if a bit flips in the epc yeah so as I said it's integrity checked now",
    "start": "2275970",
    "end": "2281670"
  },
  {
    "text": "we flip a bit so the integrity check will fail make sense but it then locks",
    "start": "2281670",
    "end": "2286860"
  },
  {
    "text": "up the memory controller which means that we cannot do any further memory access so the system halts immediately",
    "start": "2286860",
    "end": "2295410"
  },
  {
    "text": "and we need to manually reboot it sounds unsafe it is unsafe especially in a",
    "start": "2295410",
    "end": "2302940"
  },
  {
    "text": "cloud environment ok so if a malicious in place and uses a bit flip the entire",
    "start": "2302940",
    "end": "2309690"
  },
  {
    "text": "machine hearts even in the cloud which allows us to mount denial of service attacks in the cloud on co-located",
    "start": "2309690",
    "end": "2316400"
  },
  {
    "text": "denial of services is boring that's not something we want to do maybe just put",
    "start": "2316400",
    "end": "2322230"
  },
  {
    "text": "everything together we have already with sjx and the one location hammering and opcode flipping and then we build an",
    "start": "2322230",
    "end": "2328350"
  },
  {
    "text": "undetectable exploit that would be cool so for SGX is really nice because it",
    "start": "2328350",
    "end": "2335070"
  },
  {
    "start": "2332000",
    "end": "2332000"
  },
  {
    "text": "protects software from malicious environments and we can't do anything with this thing that's running in there",
    "start": "2335070",
    "end": "2341160"
  },
  {
    "text": "we don't have dynamic analysis we don't have static analysis we don't have performance counters so everything is",
    "start": "2341160",
    "end": "2346530"
  },
  {
    "text": "invisible if we now hammer from inside this Jackson cave then we defeat all the",
    "start": "2346530",
    "end": "2352770"
  },
  {
    "text": "counter measures that were proposed so it protects our exploit from from also",
    "start": "2352770",
    "end": "2358590"
  },
  {
    "text": "benign applications great idea Mike a great idea ok how does it work so this",
    "start": "2358590",
    "end": "2366420"
  },
  {
    "text": "is now a demo for the OP code flipping and we can see we are on a new Ubuntu",
    "start": "2366420",
    "end": "2371430"
  },
  {
    "text": "system with an current sudo version if we run sudo we can see we don't have",
    "start": "2371430",
    "end": "2378180"
  },
  {
    "text": "root privileges here it asked for password I have no idea what the password is so I'm starting a row Hema",
    "start": "2378180",
    "end": "2384320"
  },
  {
    "text": "exploit here and I want to jump this flip this come not equal to a champ",
    "start": "2384320",
    "end": "2389400"
  },
  {
    "text": "equal in a pseudo binary we do in the memory way laying until we have some",
    "start": "2389400",
    "end": "2394500"
  },
  {
    "text": "offset that we can flip and this memory whaling is quite fast then we we flip the bits there at this target location",
    "start": "2394500",
    "end": "2401220"
  },
  {
    "text": "and when we now run sudo it doesn't ask for password anymore and you can just run everything is rude and",
    "start": "2401220",
    "end": "2406740"
  },
  {
    "text": "the nice thing is we can evict the page cache again and is replaced by the original binary and it still works as",
    "start": "2406740",
    "end": "2414120"
  },
  {
    "text": "before and there are no traces of the attack here this is a really cool exploit what if in the meantime I try to",
    "start": "2414120",
    "end": "2420750"
  },
  {
    "text": "login with the correct password yeah it can't log in with the correct password button yeah okay sorry so as we see we",
    "start": "2420750",
    "end": "2431250"
  },
  {
    "text": "have all the defense classes now defeated we can bypass all of them and",
    "start": "2431250",
    "end": "2437940"
  },
  {
    "text": "can mount a attack although we have all the defenses installed but sorry but at",
    "start": "2437940",
    "end": "2444900"
  },
  {
    "text": "least it's a Loki attack right so we still need loki code execution for all of that so okay okay let's just compare",
    "start": "2444900",
    "end": "2453450"
  },
  {
    "start": "2452000",
    "end": "2452000"
  },
  {
    "text": "some performance numbers so for row hammer the reports were that we need at least something like 43,000 hammering",
    "start": "2453450",
    "end": "2460020"
  },
  {
    "text": "attempts so 43,000 uncashed memory accesses within 64 milliseconds that's",
    "start": "2460020",
    "end": "2465570"
  },
  {
    "text": "around just below 700,000 accesses per second hmm",
    "start": "2465570",
    "end": "2471810"
  },
  {
    "text": "while handling network packets we actually access memory locations up to 6",
    "start": "2471810",
    "end": "2477060"
  },
  {
    "text": "times the same memory location up to 6 times depending on the specific kernel that is used so that means if we can",
    "start": "2477060",
    "end": "2484080"
  },
  {
    "text": "handle something like 100 11,000 packets per second we could theoretically do",
    "start": "2484080",
    "end": "2492120"
  },
  {
    "text": "something there right a network package have at least 64 bytes so we need something like 57 megabits per second",
    "start": "2492120",
    "end": "2499200"
  },
  {
    "text": "that sounds really unreal it's Evan megabits per second connection somewhere",
    "start": "2499200",
    "end": "2506480"
  },
  {
    "text": "not in Austria but of course we have modern and pretty fast networks so this",
    "start": "2506600",
    "end": "2513840"
  },
  {
    "text": "is not an issue at all outside of Austria out to the party of course so with net hammer we see that we can",
    "start": "2513840",
    "end": "2521370"
  },
  {
    "text": "just send many many back heads to the system and induce bit flips and in the",
    "start": "2521370",
    "end": "2527970"
  },
  {
    "text": "end network stacks arm for instance of news and cache memory which is perfect for hammering as we've seen or intercom",
    "start": "2527970",
    "end": "2535830"
  },
  {
    "text": "ends location technology for quality of service in cloud environments where you",
    "start": "2535830",
    "end": "2541380"
  },
  {
    "text": "can allocate the cash to different tenants so you restrict the size of the",
    "start": "2541380",
    "end": "2546840"
  },
  {
    "text": "cache and under a heavy workload the virtual machine has only for instance one catch way so you can evict pretty",
    "start": "2546840",
    "end": "2554430"
  },
  {
    "text": "pretty nicely using this technology but also any other any other software that",
    "start": "2554430",
    "end": "2560250"
  },
  {
    "text": "is used on your system any software that uses CL flush somewhere or non-temporal",
    "start": "2560250",
    "end": "2566310"
  },
  {
    "text": "stores right and uses this while handling network requests any of this",
    "start": "2566310",
    "end": "2572370"
  },
  {
    "text": "code could be used for a remote draw hemorrhage so it must not be the driver yourself but any other application that",
    "start": "2572370",
    "end": "2578700"
  },
  {
    "text": "uses the packet that has been sent so",
    "start": "2578700",
    "end": "2584130"
  },
  {
    "start": "2582000",
    "end": "2582000"
  },
  {
    "text": "how can we exploit that we can of course cause to the denial of service with sjx",
    "start": "2584130",
    "end": "2590550"
  },
  {
    "text": "again yeah we can also do denial of service by flipping a bit in the file system heavens quite often if we run a net-net",
    "start": "2590550",
    "end": "2596400"
  },
  {
    "text": "Ameritech unfortunately or a slip something in a DNS server and to a bit squating attack or in an OCSP server and",
    "start": "2596400",
    "end": "2603570"
  },
  {
    "text": "make our invalid certificates great again in making them valid again ok we",
    "start": "2603570",
    "end": "2609990"
  },
  {
    "text": "can also attack crypto for instance if we flip a bit in a private key we can",
    "start": "2609990",
    "end": "2615290"
  },
  {
    "text": "generate a public key for that private key because it can be factorized and you",
    "start": "2615290",
    "end": "2621450"
  },
  {
    "text": "can use this with different services like with github or get left where your upload your public key then we do a bit",
    "start": "2621450",
    "end": "2628410"
  },
  {
    "text": "of a beer calculate a new private key and then we can just push our malicious code in your repository yeah we we",
    "start": "2628410",
    "end": "2635160"
  },
  {
    "text": "implement or several of these of these attacks and from that we can do them in practice and as a bonus we can again and",
    "start": "2635160",
    "end": "2642270"
  },
  {
    "text": "pick the page cache and get rid of the problem key and no one sees any traces anymore so that avoid unfortunate if I",
    "start": "2642270",
    "end": "2649500"
  },
  {
    "text": "if so so you say that is a commit and either run prove that it's not from me",
    "start": "2649500",
    "end": "2654660"
  },
  {
    "text": "errors my commit and no one will ever know ok that's why you should find new commits me yeah some we have seen that many",
    "start": "2654660",
    "end": "2662400"
  },
  {
    "text": "academic countermeasures were proposed so far to mitigate row hammer but we've also seen that we can circumvent all of",
    "start": "2662400",
    "end": "2669120"
  },
  {
    "text": "them yeah we cannot design countermeasures in an effective way without completely",
    "start": "2669120",
    "end": "2676260"
  },
  {
    "text": "understanding the attack first so we had these wrong assumptions about this we need two locations to hammer and Emma",
    "start": "2676260",
    "end": "2681960"
  },
  {
    "text": "showed that's not the case so as soon as we understand the complete attack then",
    "start": "2681960",
    "end": "2687930"
  },
  {
    "text": "we might be able to design good countermeasures yes because otherwise we just patch a concrete exploit but do not",
    "start": "2687930",
    "end": "2695310"
  },
  {
    "text": "solve the problem entirely also something we want to talk about Apple",
    "start": "2695310",
    "end": "2701340"
  },
  {
    "text": "had a really really good idea of a device lower the refresh rate to save energy but yeah got to get some more flips but",
    "start": "2701340",
    "end": "2709680"
  },
  {
    "text": "they just added ECC memory to the iPhone so then that your bit flips again so",
    "start": "2709680",
    "end": "2715230"
  },
  {
    "text": "they save that I straight off okay but yeah that's a great idea but this also shows that it's an",
    "start": "2715230",
    "end": "2721140"
  },
  {
    "text": "optimization problem vendors will always push towards the boundary where they can",
    "start": "2721140",
    "end": "2726480"
  },
  {
    "text": "push where they know there it is still safe with under the current assumptions right but if it was too aggressive you",
    "start": "2726480",
    "end": "2733710"
  },
  {
    "text": "will have bit flips in some cases if it was too cautious you will have a waste of energy you will have a lower battery",
    "start": "2733710",
    "end": "2740370"
  },
  {
    "text": "runtime so it's an optimization problem and also what if the too aggressive changes over time because someone",
    "start": "2740370",
    "end": "2747030"
  },
  {
    "text": "figures out a new technique what if the attack has become slightly better over",
    "start": "2747030",
    "end": "2752760"
  },
  {
    "text": "time it's difficult to optimize with an adversary that works against Q so what",
    "start": "2752760",
    "end": "2760710"
  },
  {
    "text": "do we learn from that we have to invest much more into researching attacks",
    "start": "2760710",
    "end": "2766850"
  },
  {
    "text": "because there are still aspects of Rho Emma that we do not fully understand",
    "start": "2766850",
    "end": "2772370"
  },
  {
    "text": "however this is really a big Friant to design countermeasures that fully",
    "start": "2772370",
    "end": "2777690"
  },
  {
    "text": "protect us against bit flips in the long run and you also have to keep in mind if you add new features to our CPUs then",
    "start": "2777690",
    "end": "2784320"
  },
  {
    "text": "there might be new attack vectors for example if s checks that we haven't thought of okay",
    "start": "2784320",
    "end": "2790230"
  },
  {
    "text": "and yeah what can we say about what we learned here so in the end we",
    "start": "2790230",
    "end": "2796440"
  },
  {
    "text": "underestimated side-channel or micro architectural attacks for a long long time yes and the industry and also",
    "start": "2796440",
    "end": "2804030"
  },
  {
    "text": "the customers had other priorities for a long time they wanted performance and",
    "start": "2804030",
    "end": "2809280"
  },
  {
    "text": "not mainly security you want performance first right but maybe we don't want performance without security nowadays",
    "start": "2809280",
    "end": "2815550"
  },
  {
    "text": "yeah and we have to always think is a reliability issue only a reliability issue or can't become a security impact",
    "start": "2815550",
    "end": "2822120"
  },
  {
    "text": "at some point so we need more research to fully understand the attacks and to",
    "start": "2822120",
    "end": "2829020"
  },
  {
    "text": "ultimately mitigate them with that we would like to thank you for your attention so if there are any questions",
    "start": "2829020",
    "end": "2844890"
  },
  {
    "text": "yeah if there are any questions you can ask them right away at one of the microphones questions in your",
    "start": "2844890",
    "end": "2859760"
  },
  {
    "text": "presentation you had some ddr4 and threes that were vulnerable finger was",
    "start": "2859760",
    "end": "2865920"
  },
  {
    "text": "like 80% for ddr3 and 60% or so for ddr4 what makes a DDR dam vulnerable and what",
    "start": "2865920",
    "end": "2874020"
  },
  {
    "text": "makes it vulnerable um in general the statement about the DIMM module being",
    "start": "2874020",
    "end": "2880200"
  },
  {
    "text": "vulnerable is a very it's an empiric one it's someone tried and was able to find",
    "start": "2880200",
    "end": "2886680"
  },
  {
    "text": "a bit flip so they said it is vulnerable but if you don't find any bit flip that",
    "start": "2886680",
    "end": "2891780"
  },
  {
    "text": "does not mean that it's not vulnerable it seems that there are differences in a manufacturing process even modules that",
    "start": "2891780",
    "end": "2898380"
  },
  {
    "text": "are almost identical that have the same serial number might have a very different profile in terms of bit flips",
    "start": "2898380",
    "end": "2905490"
  },
  {
    "text": "and susceptibility to the raw hammer attack and all of those studies that did not use many modules so in the end we",
    "start": "2905490",
    "end": "2912600"
  },
  {
    "text": "need a study with many many many modules to really say that this percentage is",
    "start": "2912600",
    "end": "2918000"
  },
  {
    "text": "vulnerable so you cannot say that one is cheaper and it has more bit flips the",
    "start": "2918000",
    "end": "2923310"
  },
  {
    "text": "other one is more expensive we were actually hoping for that so we bought several achieve ddr4 modules and no we",
    "start": "2923310",
    "end": "2932730"
  },
  {
    "text": "didn't find an obvious correlation there our one is four gigabytes so it's less dense than 16-gigabyte we",
    "start": "2932730",
    "end": "2940770"
  },
  {
    "text": "also we haven't found anything in this direction yet so I guess it's more about",
    "start": "2940770",
    "end": "2947910"
  },
  {
    "text": "in the manufacturing process where exactly if you if you have this die where the chips are from at which",
    "start": "2947910",
    "end": "2954809"
  },
  {
    "text": "position this is and what influences is help during the manufacturing process and in your experiments you said that",
    "start": "2954809",
    "end": "2963510"
  },
  {
    "text": "the system didn't have the targeted role refresh mitigation so we had one system",
    "start": "2963510",
    "end": "2971130"
  },
  {
    "text": "with this one active and we still had some bit flips there yeah but a lot less and on the other systems on most systems",
    "start": "2971130",
    "end": "2977430"
  },
  {
    "text": "it's it's not available yeah was just on one service system and not in the rows next to the target row but yes we rose",
    "start": "2977430",
    "end": "2983940"
  },
  {
    "text": "we had zero of bit flips in the adjacent rows so they are TRR works as designed but it doesn't prevent rorimer text",
    "start": "2983940",
    "end": "2990180"
  },
  {
    "text": "basically that's the takeaway",
    "start": "2990180",
    "end": "2993349"
  }
]