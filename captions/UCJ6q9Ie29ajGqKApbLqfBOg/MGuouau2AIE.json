[
  {
    "start": "0",
    "end": "230000"
  },
  {
    "text": "okay thanks Alan uh for the introduction so uh today my topic is King laab IOS",
    "start": "280",
    "end": "6040"
  },
  {
    "text": "Jailbreak internals the user land read only memory can be dangerous so as many",
    "start": "6040",
    "end": "11360"
  },
  {
    "text": "of you noticed that King laab demonstrated iOS 10.3.2 under 11 beta 2 jailbreak at MC",
    "start": "11360",
    "end": "21439"
  },
  {
    "text": "2017 but the details of the vulnerability has never been revealed yet so today I would like to take this",
    "start": "21439",
    "end": "29359"
  },
  {
    "text": "opportunity to show uh the details of all uh jailbreak uh chance uh which The",
    "start": "29359",
    "end": "37640"
  },
  {
    "text": "Bu is involved so uh first about myself uh I'm the security researcher and also the",
    "start": "37640",
    "end": "43920"
  },
  {
    "text": "team leader at tensent uh King secret lab and uh previously my uh research",
    "start": "43920",
    "end": "49559"
  },
  {
    "text": "covers on the browser uh vulnerability research uh the exploitation uh majorly",
    "start": "49559",
    "end": "55079"
  },
  {
    "text": "on the Safari chromy and Internet Explorer and now my focus uh moved to",
    "start": "55079",
    "end": "61920"
  },
  {
    "text": "the Apple uh vulnerability research mainly for the S sandbox bypassing and",
    "start": "61920",
    "end": "67080"
  },
  {
    "text": "also kernel uh privilege escalation so uh today our uh uh agenda",
    "start": "67080",
    "end": "74040"
  },
  {
    "text": "is like we will firstly talk about the memory protection implemented by the",
    "start": "74040",
    "end": "79240"
  },
  {
    "text": "modern OS this is not a very import uh interesting uh topic because it is there",
    "start": "79240",
    "end": "85360"
  },
  {
    "text": "for many years next we discuss about the iOS dma features including uh the",
    "start": "85360",
    "end": "91680"
  },
  {
    "text": "previous research as well as the implementation of the iOS uh mmu",
    "start": "91680",
    "end": "98200"
  },
  {
    "text": "protection and the next uh because King laab did a lot of reversing work on the",
    "start": "98200",
    "end": "104360"
  },
  {
    "text": "iOS GPU notification mechanism part since it is not um open sourced part of",
    "start": "104360",
    "end": "111759"
  },
  {
    "text": "the iOS kernel and uh with enough uh knowledge explained we will finally talk",
    "start": "111759",
    "end": "118439"
  },
  {
    "text": "about the bu uh which includes two of them the first one is in the dma mapping",
    "start": "118439",
    "end": "125240"
  },
  {
    "text": "uh feature vulnerability and another is the out of bound right in the Apple uh",
    "start": "125240",
    "end": "131599"
  },
  {
    "text": "Graphics stack after the vulnerability has been uh explained we will talk about",
    "start": "131599",
    "end": "137800"
  },
  {
    "text": "the exploitation with the demo and then we will conclude this talk so the first",
    "start": "137800",
    "end": "144640"
  },
  {
    "text": "part is operating uh system uh memory protection overview so mod OS actually",
    "start": "144640",
    "end": "151280"
  },
  {
    "text": "implements the memory protection at the hardware level to mitigate the non",
    "start": "151280",
    "end": "156800"
  },
  {
    "text": "attack uh attacks they are introduced in different levels for example the",
    "start": "156800",
    "end": "162239"
  },
  {
    "text": "translation block entry properties at the mmu level so uh in this part we will",
    "start": "162239",
    "end": "169040"
  },
  {
    "text": "uh they introduced the NX the nonexecutable bit and also the pxn to",
    "start": "169040",
    "end": "175280"
  },
  {
    "text": "prevent exclusion in the user Land from the kernel site and also the the AP",
    "start": "175280",
    "end": "180519"
  },
  {
    "text": "which indicates uh exess Pro protection uh like the read only or write only or",
    "start": "180519",
    "end": "186640"
  },
  {
    "text": "execute only memory and besides that there are also some of the mitigations",
    "start": "186640",
    "end": "192480"
  },
  {
    "text": "like the kpp amcc which is also uh relating to the memory protection but",
    "start": "192480",
    "end": "197840"
  },
  {
    "text": "they are implemented in maybe uh deeper and lower level which is not our scope",
    "start": "197840",
    "end": "204000"
  },
  {
    "text": "of the torque so among those memory protection mechanisms user l uh read",
    "start": "204000",
    "end": "210200"
  },
  {
    "text": "only mapping is a very old school approach to protect the userland memory",
    "start": "210200",
    "end": "216239"
  },
  {
    "text": "it is very easily implemented but very effective there are three uh major",
    "start": "216239",
    "end": "222400"
  },
  {
    "text": "scenario of using such read only uh userland memory mappings the first one",
    "start": "222400",
    "end": "228200"
  },
  {
    "text": "is for example the executable memory in iOS is only read only to prevent uh the",
    "start": "228200",
    "end": "235920"
  },
  {
    "start": "230000",
    "end": "230000"
  },
  {
    "text": "attackers from overwriting uh the code at the very early stage of the exploitation and along with some other",
    "start": "235920",
    "end": "243239"
  },
  {
    "text": "mitigations like the code signing uh enforcement this has made iOS very",
    "start": "243239",
    "end": "249480"
  },
  {
    "text": "strong in security and the second scenario is the sharing memory uh the",
    "start": "249480",
    "end": "254840"
  },
  {
    "text": "first is the the second one is the between process for example two processes share one physical copy of the",
    "start": "254840",
    "end": "261880"
  },
  {
    "text": "memory and in the second in the third scenario uh it is sharing memory between",
    "start": "261880",
    "end": "267560"
  },
  {
    "text": "the kernel and the process memory sharing at user land Mak the",
    "start": "267560",
    "end": "273840"
  },
  {
    "start": "270000",
    "end": "270000"
  },
  {
    "text": "inter process or user to Kernel communication more efficient this is",
    "start": "273840",
    "end": "279600"
  },
  {
    "text": "because you do not need to use the traditional message send mechanism like",
    "start": "279600",
    "end": "285440"
  },
  {
    "text": "the uh to call some ciso or to call some uh trap to uh send the buffer from the",
    "start": "285440",
    "end": "291840"
  },
  {
    "text": "user to the kernel and uh in that way the server process or the kernel who",
    "start": "291840",
    "end": "298360"
  },
  {
    "text": "owns that memory can trust the me uh can trust it because he is the only one who",
    "start": "298360",
    "end": "305440"
  },
  {
    "text": "can modify it while the client side or the client process can only have the",
    "start": "305440",
    "end": "311280"
  },
  {
    "text": "read only process which uh it is not possible to uh change the memory then uh",
    "start": "311280",
    "end": "318160"
  },
  {
    "text": "the owner uh process the or the kernel can eliminate the the specific secret",
    "start": "318160",
    "end": "325080"
  },
  {
    "text": "consideration such as the uh boundary check or the time of check or time of",
    "start": "325080",
    "end": "330600"
  },
  {
    "text": "use issues so uh its implementation at the mmu level is quite easy it has in",
    "start": "330600",
    "end": "337759"
  },
  {
    "text": "the TBE entry it introduced the access protection bit where you can find uh the",
    "start": "337759",
    "end": "345000"
  },
  {
    "text": "the uh the specification document uh on the right side I will not look into it",
    "start": "345000",
    "end": "350080"
  },
  {
    "text": "very detailedly and when there is uh a way found to make the mapping writable then",
    "start": "350080",
    "end": "357840"
  },
  {
    "start": "351000",
    "end": "351000"
  },
  {
    "text": "the whole uh trust boundary of the memory will be",
    "start": "357840",
    "end": "363319"
  },
  {
    "text": "broken but uh uh you need to make sure that the memory is remapped into uh",
    "start": "363319",
    "end": "370240"
  },
  {
    "text": "right B without marking them uh copy on right otherwise uh another copy of the",
    "start": "370240",
    "end": "376840"
  },
  {
    "text": "physical memory will be introduced and you are not able to uh mutate the original physical copy of the mapping",
    "start": "376840",
    "end": "383960"
  },
  {
    "text": "still and once that is done then it can lead to privilege escalation so in uh",
    "start": "383960",
    "end": "390479"
  },
  {
    "text": "the process to process memory sharing scenario uh you can lead to uh it can",
    "start": "390479",
    "end": "395759"
  },
  {
    "text": "lead to send box by pass while for the pro process to Kernel memory sharing uh",
    "start": "395759",
    "end": "401319"
  },
  {
    "text": "scenario when you are able to uh modify a read only mapping it is very possible",
    "start": "401319",
    "end": "407280"
  },
  {
    "text": "for you to get a kernel code execution iOS actually has its nature to",
    "start": "407280",
    "end": "414160"
  },
  {
    "text": "prevent such uh writeable remappings at its kernel code you can see that once a",
    "start": "414160",
    "end": "421120"
  },
  {
    "text": "memory is mapped to uh to the you uh to the process using read only actually it",
    "start": "421120",
    "end": "427879"
  },
  {
    "text": "has that map pin has a property called Max protection and that Max protection",
    "start": "427879",
    "end": "434560"
  },
  {
    "text": "is set no uh no higher than right B so that uh when you try to remap it as read",
    "start": "434560",
    "end": "442199"
  },
  {
    "text": "and write the Cel will reject you immediately but there is a exception",
    "start": "442199",
    "end": "448479"
  },
  {
    "text": "when uh you you specify uh copy on right uh protection uh properties it will uh",
    "start": "448479",
    "end": "455240"
  },
  {
    "text": "the remapping will be allowed but another copy of the physical memory will",
    "start": "455240",
    "end": "460319"
  },
  {
    "text": "be used so you are still not able to modify that original uh",
    "start": "460319",
    "end": "466400"
  },
  {
    "text": "memory and of course there is some historical issues uh for example the",
    "start": "466400",
    "end": "471680"
  },
  {
    "text": "first one refer to the uh enjoyed uh Shi memory uh making it writable and cause",
    "start": "471680",
    "end": "477759"
  },
  {
    "text": "some uh issues and second one is for on Windows platform however you will be",
    "start": "477759",
    "end": "483000"
  },
  {
    "text": "noticed that on iOS platform there is no such known issues so we have to research",
    "start": "483000",
    "end": "489280"
  },
  {
    "text": "uh on our own the next part will cover uh the iOS dma",
    "start": "489280",
    "end": "496400"
  },
  {
    "text": "features because the uh the uh the more uh stronger and stronger and the more",
    "start": "496400",
    "end": "503759"
  },
  {
    "start": "497000",
    "end": "497000"
  },
  {
    "text": "abundant features provided by modern peripheral uh devices attached to the",
    "start": "503759",
    "end": "509680"
  },
  {
    "text": "mobile device dma technology is introduced to enable the ability for",
    "start": "509680",
    "end": "515518"
  },
  {
    "text": "faster data transfer and interestingly the dma transfer will not involve any",
    "start": "515519",
    "end": "522599"
  },
  {
    "text": "CPU so that the access permission bits on the virtual uh addresses will be",
    "start": "522599",
    "end": "529680"
  },
  {
    "text": "simply ignored and the next question is does",
    "start": "529680",
    "end": "535120"
  },
  {
    "text": "the dma uh transfer use the physical address",
    "start": "535120",
    "end": "540200"
  },
  {
    "text": "and no uh if that is the case no memory protection is involved anymore but",
    "start": "540200",
    "end": "545920"
  },
  {
    "text": "definitely uh it is not the case uh why because modern fronts are first reason",
    "start": "545920",
    "end": "552640"
  },
  {
    "text": "is that modern fronts are 64bit while many of their peripheral uh devices",
    "start": "552640",
    "end": "558959"
  },
  {
    "text": "remain 32bit in that case address translation",
    "start": "558959",
    "end": "564200"
  },
  {
    "text": "is quite needed to trans translate uh from 64bit memory to 32bit memory and",
    "start": "564200",
    "end": "572200"
  },
  {
    "text": "another reason is that we have to enforce the memory protection for the dma transfer also because if it is not",
    "start": "572200",
    "end": "580200"
  },
  {
    "text": "there it not safe right the because of this the",
    "start": "580200",
    "end": "586200"
  },
  {
    "start": "583000",
    "end": "583000"
  },
  {
    "text": "mmu is introduced to perform this jobu uh on 36 uh 66 bit iOS device uh",
    "start": "586200",
    "end": "598120"
  },
  {
    "text": "the concept do which refers to uh device address resolution table is actually uh",
    "start": "598120",
    "end": "604399"
  },
  {
    "text": "introduced and responsible to perform such address translation and there are two uh kind of",
    "start": "604399",
    "end": "612160"
  },
  {
    "start": "609000",
    "end": "609000"
  },
  {
    "text": "dma one for host to device dma and another for uh device to host dma for",
    "start": "612160",
    "end": "618760"
  },
  {
    "text": "host to device dma actually the system physical memory is mapped into the io",
    "start": "618760",
    "end": "624600"
  },
  {
    "text": "space visible by the device and in device to host the em it actually MCH",
    "start": "624600",
    "end": "631200"
  },
  {
    "text": "the device memory back to the OS virtual memory so that it can be identified by",
    "start": "631200",
    "end": "636639"
  },
  {
    "text": "the operating system and in the middle uh 2017 uh gol from Google project zero",
    "start": "636639",
    "end": "644480"
  },
  {
    "text": "leverages the dma features on iOS to achieve the firmware to host",
    "start": "644480",
    "end": "650839"
  },
  {
    "text": "attack and he compromised uh the I uh the Wi-Fi stack first and then try to",
    "start": "650839",
    "end": "658399"
  },
  {
    "text": "mutate uh some right B dma mapping in the device memory and it is also shared",
    "start": "658399",
    "end": "664800"
  },
  {
    "text": "to the OS uh kernel memory uh and the OS iOS thinks that the uh the dma on the on",
    "start": "664800",
    "end": "675079"
  },
  {
    "text": "on the device is trustable so uh it uh eliminate a necessary boundary check and",
    "start": "675079",
    "end": "682079"
  },
  {
    "text": "finally with uh the the the Wi-Fi stack compromised it is very easy to um to",
    "start": "682079",
    "end": "688880"
  },
  {
    "text": "modify that memory and finally uh lead to Kernel code execution however such attack uh has",
    "start": "688880",
    "end": "697079"
  },
  {
    "text": "some limitations one obvious uh uh limitate limitation is that such attack",
    "start": "697079",
    "end": "704079"
  },
  {
    "text": "can only be performed in a short distance scenario because you have to",
    "start": "704079",
    "end": "709959"
  },
  {
    "text": "compromise a Wi-Fi stack first and that requires the attacker and the victim in",
    "start": "709959",
    "end": "716160"
  },
  {
    "text": "the same uh Wi-Fi environment is it possible for us to make it long",
    "start": "716160",
    "end": "722320"
  },
  {
    "start": "719000",
    "end": "719000"
  },
  {
    "text": "distance for example we have a browser exploit we can uh try to launch it remotely by the browser uh exploit and",
    "start": "722320",
    "end": "730360"
  },
  {
    "text": "together with a kernel privilege excl Bo and of course by uh utilizing the dma",
    "start": "730360",
    "end": "736720"
  },
  {
    "text": "related box and that look like a very crazy idea because the dma features like",
    "start": "736720",
    "end": "744440"
  },
  {
    "text": "are kind of very lowlevel implementation which is mostly performed as at the",
    "start": "744440",
    "end": "749920"
  },
  {
    "text": "kernel level or the device level it is not exposed to the uh user land directly",
    "start": "749920",
    "end": "755800"
  },
  {
    "text": "for sure and is it is still possible uh",
    "start": "755800",
    "end": "760959"
  },
  {
    "start": "757000",
    "end": "757000"
  },
  {
    "text": "to uh think of it because there might be some indirect user land dma on the iOS",
    "start": "760959",
    "end": "768079"
  },
  {
    "text": "for example it on the iOS system it has some uh uh jpack engine uh it it is",
    "start": "768079",
    "end": "776120"
  },
  {
    "text": "responsible to uh to accelerate the the encoding and the decoding process",
    "start": "776120",
    "end": "782760"
  },
  {
    "text": "and also in another scenario there is IO surface transform and actually it is",
    "start": "782760",
    "end": "789560"
  },
  {
    "text": "done by the hardware device called the scaler device and we will uh look into",
    "start": "789560",
    "end": "795040"
  },
  {
    "text": "the iOS transform feature a little bit and uh we actually King laab spend some",
    "start": "795040",
    "end": "801519"
  },
  {
    "start": "798000",
    "end": "798000"
  },
  {
    "text": "time to investigate the iOS uh IO surface uh transform feature and uh",
    "start": "801519",
    "end": "808079"
  },
  {
    "text": "before we starting it I'd like to briefly introduce the io surface and the io surface accelerator framework so so",
    "start": "808079",
    "end": "815720"
  },
  {
    "text": "on the Apple word uh IO surface represents a userland buffer which is",
    "start": "815720",
    "end": "821120"
  },
  {
    "text": "shared with the kernel and the userland applications can create a user uh IO",
    "start": "821120",
    "end": "828399"
  },
  {
    "text": "service by providing a existing user land buffer address and its length so",
    "start": "828399",
    "end": "834519"
  },
  {
    "text": "the code uh on the right side shows the creation process so it first gets",
    "start": "834519",
    "end": "840320"
  },
  {
    "text": "properties of that userland memory and then create IO uh memory descriptor with",
    "start": "840320",
    "end": "847480"
  },
  {
    "text": "specific uh property uh as options so here if option K iio Direction out is",
    "start": "847480",
    "end": "854800"
  },
  {
    "text": "set it indicates that the userland mapping is read only and once the read",
    "start": "854800",
    "end": "860360"
  },
  {
    "text": "only mapping is read right then option K iio uh Direction out as well as K iio",
    "start": "860360",
    "end": "868639"
  },
  {
    "text": "Direction in will be boed and the second framework is the io",
    "start": "868639",
    "end": "875759"
  },
  {
    "text": "surface accelerator and it's a kind of userland framework for uh and it is only",
    "start": "875759",
    "end": "882800"
  },
  {
    "text": "existing in uh iOS platform and there are two important uh interfaces one is",
    "start": "882800",
    "end": "889279"
  },
  {
    "text": "IO surface accelerator create and another is IO surface accelerator",
    "start": "889279",
    "end": "894600"
  },
  {
    "text": "transfer uh surface the first one uh is responsible for creating uh IO kit user",
    "start": "894600",
    "end": "901600"
  },
  {
    "text": "CL connection representing a IO surface uh accelerator CL C object and the",
    "start": "901600",
    "end": "908360"
  },
  {
    "text": "second uh interface uh will uh takes two IO surface handles one for the source IO",
    "start": "908360",
    "end": "915279"
  },
  {
    "text": "surface and the other for the destination and du the transform and there is one typical uh scenario of",
    "start": "915279",
    "end": "923079"
  },
  {
    "text": "using this framework which is the screen snapshot where you uh have your",
    "start": "923079",
    "end": "928480"
  },
  {
    "text": "destination iio surface as a uh receiving buffer and the system",
    "start": "928480",
    "end": "934279"
  },
  {
    "text": "maintains the io surface for the frame buffer and you make this transfer and",
    "start": "934279",
    "end": "939639"
  },
  {
    "text": "you can get a screenshot of it of your current iPhone",
    "start": "939639",
    "end": "945959"
  },
  {
    "start": "945000",
    "end": "945000"
  },
  {
    "text": "screen and here is the lowlevel implementation of the io surface",
    "start": "946000",
    "end": "951680"
  },
  {
    "text": "accelerator so uh on the top side you can see there is a uh object called IO",
    "start": "951680",
    "end": "959360"
  },
  {
    "text": "uh surface accelerator C sorry under uh the next component is",
    "start": "959360",
    "end": "966000"
  },
  {
    "text": "the Apple M2 scaler CSC which is a upper level driver and it talks to the hole",
    "start": "966000",
    "end": "973560"
  },
  {
    "text": "which stand for Hardware abstraction uh abstract level and the latter handles",
    "start": "973560",
    "end": "979240"
  },
  {
    "text": "the device independent uh dependent stuff and provide the device independent",
    "start": "979240",
    "end": "985759"
  },
  {
    "text": "uh interface to the driver and this uh whole whole device uh whole object also",
    "start": "985759",
    "end": "992600"
  },
  {
    "text": "create five important objects which stand for some important registers for",
    "start": "992600",
    "end": "998519"
  },
  {
    "text": "that device and that uh object Hall also Maps a device memory uh from the device",
    "start": "998519",
    "end": "1006560"
  },
  {
    "text": "uh IO space into the kernel virtual space V dma represent the uh the device",
    "start": "1006560",
    "end": "1013079"
  },
  {
    "text": "key registers so here is the uh the overall",
    "start": "1013079",
    "end": "1019040"
  },
  {
    "start": "1015000",
    "end": "1015000"
  },
  {
    "text": "workflow for the uh transform the first is the kernel will validate the",
    "start": "1019040",
    "end": "1025240"
  },
  {
    "text": "parameter uh from the user user length and then it obtains the source and the",
    "start": "1025240",
    "end": "1030839"
  },
  {
    "text": "destination IO surface address and then it map the iOS I surface buffer via dma",
    "start": "1030839",
    "end": "1038038"
  },
  {
    "text": "and then it obtains the mapped address and set some buffer uh the device buffer",
    "start": "1038039",
    "end": "1045199"
  },
  {
    "text": "and then it starts the scaler device and after the scalar device is started then",
    "start": "1045199",
    "end": "1051679"
  },
  {
    "text": "the Kel waits for the interrupt from the device to uh wait for its completeness",
    "start": "1051679",
    "end": "1058720"
  },
  {
    "text": "and after it is complete everything is finished so we are mostly uh interested",
    "start": "1058720",
    "end": "1065120"
  },
  {
    "start": "1062000",
    "end": "1062000"
  },
  {
    "text": "on the dma mapping part and we are not interested in other part so this is",
    "start": "1065120",
    "end": "1070280"
  },
  {
    "text": "actually done by the function set map prepared the memory uh descriptor and in",
    "start": "1070280",
    "end": "1076440"
  },
  {
    "text": "that function code you can see that uh colel object called IOD dma command",
    "start": "1076440",
    "end": "1082559"
  },
  {
    "text": "created Created with a very special IO mapper and actually uh that mapper is a",
    "start": "1082559",
    "end": "1089559"
  },
  {
    "text": "instance of IO do mapper which is independent between devices to make sure",
    "start": "1089559",
    "end": "1095720"
  },
  {
    "text": "that device and the device are separated in uh separated in iOS space addresses",
    "start": "1095720",
    "end": "1102280"
  },
  {
    "text": "so that one cannot interfere another and using a very basic iOS utility called IO",
    "start": "1102280",
    "end": "1110120"
  },
  {
    "text": "you can find this instance the Mapp instance for the do",
    "start": "1110120",
    "end": "1115400"
  },
  {
    "text": "scaler and then the io uh surface memory descripted uh descriptor will be bonded",
    "start": "1115400",
    "end": "1123120"
  },
  {
    "text": "to the iodm command and the next step is to obtain the mapped uh IO surface",
    "start": "1123120",
    "end": "1131960"
  },
  {
    "start": "1126000",
    "end": "1126000"
  },
  {
    "text": "address in the io space this is done by the uh calling the function I uh",
    "start": "1131960",
    "end": "1137840"
  },
  {
    "text": "generate I ovm segments after you call this function you obtain that address",
    "start": "1137840",
    "end": "1144320"
  },
  {
    "text": "and you can not notice that v33 uh indicates the result address which is in",
    "start": "1144320",
    "end": "1153240"
  },
  {
    "text": "32bit and after you get the source and the destination iOS uh IO surface",
    "start": "1153240",
    "end": "1159840"
  },
  {
    "text": "address in IO space it's time to set the scaler device uh register the key uh",
    "start": "1159840",
    "end": "1167280"
  },
  {
    "text": "register is for Source uh destination config control this object is used to",
    "start": "1167280",
    "end": "1174240"
  },
  {
    "text": "specify uh those addresses and uh once you decide those addresses you just",
    "start": "1174240",
    "end": "1181840"
  },
  {
    "text": "change the U you spfy it we uh giving",
    "start": "1181840",
    "end": "1187440"
  },
  {
    "text": "some uh value uh and set it into some uh specific offset in that mapped uh",
    "start": "1187440",
    "end": "1195480"
  },
  {
    "text": "virtual memory and after that uh this is is done and the final thing is to start",
    "start": "1195480",
    "end": "1202120"
  },
  {
    "start": "1200000",
    "end": "1200000"
  },
  {
    "text": "the scaler this is very easy you just uh need to uh set one which indicates the",
    "start": "1202120",
    "end": "1209720"
  },
  {
    "text": "power on uh option uh at the offset one 128 and after you make that value to one",
    "start": "1209720",
    "end": "1218120"
  },
  {
    "text": "the scalar device starts its working uh uh starts its work immediately and the",
    "start": "1218120",
    "end": "1224360"
  },
  {
    "text": "final thing is for kernel to wait for that device to finish working and issue",
    "start": "1224360",
    "end": "1230799"
  },
  {
    "text": "uh interrupt event uh to indicate this has been done okay so the next part I will cover",
    "start": "1230799",
    "end": "1238520"
  },
  {
    "text": "for theu memory protection so uh similar as the system",
    "start": "1238520",
    "end": "1244919"
  },
  {
    "text": "mmu page table the I mmu also need to have the page table uh specification",
    "start": "1244919",
    "end": "1252159"
  },
  {
    "text": "however unlike the CV CPU mmu the page table uh document uh for I m muu is not",
    "start": "1252159",
    "end": "1259640"
  },
  {
    "text": "there so you have to uh reverse the ios. code to find out the",
    "start": "1259640",
    "end": "1267000"
  },
  {
    "text": "specification and we did it also and coincidently uh go from uh project zero",
    "start": "1267000",
    "end": "1274400"
  },
  {
    "text": "Google project zero also uh he did a similar work and here I just post a",
    "start": "1274400",
    "end": "1279600"
  },
  {
    "text": "picture uh written by him uh on the right side you can see that it has very",
    "start": "1279600",
    "end": "1285080"
  },
  {
    "text": "similar uh specification as the CPU mmu",
    "start": "1285080",
    "end": "1290200"
  },
  {
    "start": "1289000",
    "end": "1289000"
  },
  {
    "text": "however in his blog he didn't mention that whether the IU supports the memory protection or not",
    "start": "1290200",
    "end": "1298799"
  },
  {
    "text": "so here is a piece of his uh block he said it is unknown whether it is uh it",
    "start": "1298799",
    "end": "1304960"
  },
  {
    "text": "can facilitate uh the user uh the read only mappings however actually by",
    "start": "1304960",
    "end": "1311080"
  },
  {
    "text": "reversing uh the code in iOS uh 11 we can get the",
    "start": "1311080",
    "end": "1316320"
  },
  {
    "text": "answer so ovm map memory function is the entry point for mapping the memory in uh",
    "start": "1316320",
    "end": "1323400"
  },
  {
    "text": "IO space among uh which the map options parameter here uh has included the",
    "start": "1323400",
    "end": "1331799"
  },
  {
    "text": "memory protection bits in the virtual space so here the last three bits in",
    "start": "1331799",
    "end": "1337720"
  },
  {
    "text": "that map options is translated to a direction value visible by theu so here",
    "start": "1337720",
    "end": "1345640"
  },
  {
    "text": "for read only mappings it has the direction value two and the right only mapping has the value one and the read",
    "start": "1345640",
    "end": "1352279"
  },
  {
    "text": "and the right mapping has the value three we only need to uh remember this and this variable finally reach the um",
    "start": "1352279",
    "end": "1360640"
  },
  {
    "text": "lower level implementation Dot and uh a function called set translation is",
    "start": "1360640",
    "end": "1367200"
  },
  {
    "text": "finally reached and from the code logic uh here we can uh clearly see that",
    "start": "1367200",
    "end": "1374720"
  },
  {
    "text": "actually the eight and the ninth bit in the TT e entry are AP related",
    "start": "1374720",
    "end": "1382799"
  },
  {
    "text": "bits so finally we got the access uh Pro uh protection specification in tte foru",
    "start": "1383039",
    "end": "1391080"
  },
  {
    "text": "on iOS so uh here the red part is AP bits and 0 0 stand for read and write 0",
    "start": "1391080",
    "end": "1399080"
  },
  {
    "text": "one read only and one Z write only next we talk about the GPU",
    "start": "1399080",
    "end": "1405919"
  },
  {
    "text": "notification mechanism and the on I uh iPhone 7 device we found that Apple",
    "start": "1405919",
    "end": "1412880"
  },
  {
    "start": "1407000",
    "end": "1407000"
  },
  {
    "text": "Graphics provides with 128 channels for concurrent processing",
    "start": "1412880",
    "end": "1419880"
  },
  {
    "text": "those channels are have three categories CL Channel GL Channel and the TA Channel",
    "start": "1419880",
    "end": "1426279"
  },
  {
    "text": "and the kernel wraps join instructions from user land and puts them into those",
    "start": "1426279",
    "end": "1432080"
  },
  {
    "text": "channels and then kernel just wait for the GPU to finish processing because of",
    "start": "1432080",
    "end": "1438520"
  },
  {
    "text": "that a well-designed notification mechanism is very necessary because uh",
    "start": "1438520",
    "end": "1444559"
  },
  {
    "text": "it need to support for such high uh High need for concurrent",
    "start": "1444559",
    "end": "1450600"
  },
  {
    "start": "1450000",
    "end": "1450000"
  },
  {
    "text": "processing here is a a brief brief uh architecture of the notification the GPU",
    "start": "1450600",
    "end": "1458240"
  },
  {
    "text": "task actually owns a stamp array representing a stamp status of each",
    "start": "1458240",
    "end": "1464440"
  },
  {
    "text": "channel so this memory is actually uh represented of the U in32 array of 128",
    "start": "1464440",
    "end": "1473399"
  },
  {
    "text": "elements each showing the last complete instructions stamp of that channel and",
    "start": "1473399",
    "end": "1480399"
  },
  {
    "text": "this stamp array memory is actually mapped not only to the kernel but Al",
    "start": "1480399",
    "end": "1485960"
  },
  {
    "text": "also to the user land and of course the user land mapping is read",
    "start": "1485960",
    "end": "1491880"
  },
  {
    "start": "1491000",
    "end": "1491000"
  },
  {
    "text": "only and the kernel also maintains the array called a stamp address array and",
    "start": "1492159",
    "end": "1497799"
  },
  {
    "text": "this array is very simply uh constructed by the uh code uh below and it uh it",
    "start": "1497799",
    "end": "1506240"
  },
  {
    "text": "contains an address array of 128 elements and each element represents",
    "start": "1506240",
    "end": "1513720"
  },
  {
    "text": "the virtual address of that mapped uh stamp stator kernel",
    "start": "1513720",
    "end": "1520640"
  },
  {
    "text": "address under the uh stamp value of each channel is incremental upon each of of",
    "start": "1520640",
    "end": "1528600"
  },
  {
    "start": "1521000",
    "end": "1521000"
  },
  {
    "text": "the instruction processing completeness which means once the uh processing is uh",
    "start": "1528600",
    "end": "1534960"
  },
  {
    "text": "completed then uh the GPU will update that stamp value uh uh add it by one and",
    "start": "1534960",
    "end": "1545279"
  },
  {
    "text": "in the kernel uh site there is also a object called IO Exel event which",
    "start": "1545279",
    "end": "1552159"
  },
  {
    "text": "represents uh the expected exemp value in specific channel of one or one group",
    "start": "1552159",
    "end": "1560240"
  },
  {
    "text": "of join instructions so one uh Exel event I Exel event contains eight sub",
    "start": "1560240",
    "end": "1567960"
  },
  {
    "text": "events and one sub event is eight bytes in sites where it's lower uh four bytes",
    "start": "1567960",
    "end": "1574520"
  },
  {
    "text": "represents the channel index and the higher four bytes represents the",
    "start": "1574520",
    "end": "1580440"
  },
  {
    "text": "expected uh SP stamp value of that join instruction so to test whether um join",
    "start": "1580440",
    "end": "1588600"
  },
  {
    "text": "instruction has been completed or not you just need to uh compare the ex",
    "start": "1588600",
    "end": "1595120"
  },
  {
    "text": "expect stamp value with the value in that stamp array so here is the code",
    "start": "1595120",
    "end": "1601960"
  },
  {
    "text": "it's check where expect stamp is higher than the current last completed uh in",
    "start": "1601960",
    "end": "1609720"
  },
  {
    "text": "stamp value if it is higher then it continues The Waiting process in the",
    "start": "1609720",
    "end": "1615760"
  },
  {
    "text": "loop in in the loop but if it is smaller or equal it means that uh join",
    "start": "1615760",
    "end": "1623159"
  },
  {
    "text": "instruction has already been finished last but not the least to",
    "start": "1623159",
    "end": "1629360"
  },
  {
    "text": "improve the performance the I some of the io XL event object are also mapped",
    "start": "1629360",
    "end": "1636120"
  },
  {
    "text": "into the user L which is highly related to our bu this is to make sure that the",
    "start": "1636120",
    "end": "1643679"
  },
  {
    "text": "userland applications can understand the status of the current",
    "start": "1643679",
    "end": "1648799"
  },
  {
    "text": "Uh current uh instruction and the current event without asking the kernel",
    "start": "1648799",
    "end": "1653880"
  },
  {
    "text": "so the the userland AP can also test whether the event has been completed or",
    "start": "1653880",
    "end": "1660200"
  },
  {
    "text": "not okay now with uh almost all the concepts well explained let's discuss",
    "start": "1660200",
    "end": "1667480"
  },
  {
    "text": "about the real uh vulnerabilities so the first vulnerability is quite uh simple",
    "start": "1667480",
    "end": "1673200"
  },
  {
    "start": "1670000",
    "end": "1670000"
  },
  {
    "text": "and obvious on the iOS uh 10 and the early",
    "start": "1673200",
    "end": "1678600"
  },
  {
    "text": "beta of iOS 11 actually the map options of the virtual memory is simply ignored",
    "start": "1678600",
    "end": "1686039"
  },
  {
    "text": "by the dot mapper so from the uh code uh below you can see that in the uh dot",
    "start": "1686039",
    "end": "1691840"
  },
  {
    "text": "code ovm aloc there is a option called map options which",
    "start": "1691840",
    "end": "1698000"
  },
  {
    "text": "indicates exess protection bits of the virtual memory and this parameter is",
    "start": "1698000",
    "end": "1704080"
  },
  {
    "text": "never used later in that function and in the lower level",
    "start": "1704080",
    "end": "1709559"
  },
  {
    "text": "implementation when uh uh the set translation API is called you can find",
    "start": "1709559",
    "end": "1716760"
  },
  {
    "text": "that the E bite and the E bit and the ninth bit of the tte are both set to",
    "start": "1716760",
    "end": "1723159"
  },
  {
    "text": "zero which indicates uh from our previous reseearch z0 means read and",
    "start": "1723159",
    "end": "1729760"
  },
  {
    "text": "write it means for any kind of uh user land mappings or kernel Land mappings once it",
    "start": "1729760",
    "end": "1738399"
  },
  {
    "text": "is translated and mapped into the io space it is always read and",
    "start": "1738399",
    "end": "1744279"
  },
  {
    "text": "right and the second uh is out of bond right vulnerability so before I talk",
    "start": "1744279",
    "end": "1751279"
  },
  {
    "start": "1745000",
    "end": "1745000"
  },
  {
    "text": "about it I will explain the concept of the io XL resource object actually IO XL",
    "start": "1751279",
    "end": "1757480"
  },
  {
    "text": "resource object is very similar in fun functionality as the io surface object",
    "start": "1757480",
    "end": "1762679"
  },
  {
    "text": "except that the AO XEL resource represents a shared user L buffer which",
    "start": "1762679",
    "end": "1768360"
  },
  {
    "text": "would be mapped into the GPU task and like the iOS IO surface object we can",
    "start": "1768360",
    "end": "1775200"
  },
  {
    "text": "also create the Io Io XL resource object uh by specifying uh existing user land",
    "start": "1775200",
    "end": "1782080"
  },
  {
    "text": "buffer uh in the userland applications and during the uh",
    "start": "1782080",
    "end": "1789200"
  },
  {
    "text": "initialization process a shared mapping will be created this shared mapping is",
    "start": "1789200",
    "end": "1795399"
  },
  {
    "text": "called IO XEL client shared IO I and this uh object contains IO Exel event",
    "start": "1795399",
    "end": "1804120"
  },
  {
    "text": "array with four elements with uh the resource ID and its type information and",
    "start": "1804120",
    "end": "1811320"
  },
  {
    "text": "this object the whole object is mapped into both userland and the kernel and of",
    "start": "1811320",
    "end": "1817080"
  },
  {
    "text": "course userland mapping is read only and this address will also be returned to",
    "start": "1817080",
    "end": "1823039"
  },
  {
    "text": "the US land application so the user uh will know the address of it",
    "start": "1823039",
    "end": "1829559"
  },
  {
    "text": "and the user uh uh user application can also delete the created IO Exel resource",
    "start": "1829559",
    "end": "1837840"
  },
  {
    "text": "by calling the method one in IO Exel shared user CL and uh after that the",
    "start": "1837840",
    "end": "1844840"
  },
  {
    "text": "test event function will be reached and this function uh actually uh simply",
    "start": "1844840",
    "end": "1850760"
  },
  {
    "text": "checks which uh if each uh IO XL event object in IO XL C sh our is complete or",
    "start": "1850760",
    "end": "1859200"
  },
  {
    "text": "not the code logic is quite simple so first it check whether the events expect",
    "start": "1859200",
    "end": "1866279"
  },
  {
    "text": "uh stamp value is lower than the current uh stamp maintained in a object called m",
    "start": "1866279",
    "end": "1873360"
  },
  {
    "text": "in line array and if yes then it means the event has been",
    "start": "1873360",
    "end": "1879480"
  },
  {
    "text": "completed yeah and uh if not then uh the code try to fetch the latest stamp value",
    "start": "1879480",
    "end": "1887519"
  },
  {
    "text": "uh from on the device memory which is referred to by uh the array uh M stamp",
    "start": "1887519",
    "end": "1893919"
  },
  {
    "text": "uh address array and the after the latest uh value has been obtained it do",
    "start": "1893919",
    "end": "1900159"
  },
  {
    "text": "the comparison [Music] again it do the comparison again and",
    "start": "1900159",
    "end": "1905760"
  },
  {
    "text": "check uh if it is smaller or bigger and uh decide whether this uh this uh event",
    "start": "1905760",
    "end": "1913399"
  },
  {
    "text": "has been completed or not it looks very uh good at first",
    "start": "1913399",
    "end": "1920559"
  },
  {
    "text": "glance however together with the dma mapping bu the it is possible that we",
    "start": "1920559",
    "end": "1927720"
  },
  {
    "text": "can uh we can modify uh the the uh Channel index here and because uh this",
    "start": "1927720",
    "end": "1935600"
  },
  {
    "text": "uh this object is created by kernel and it's not possible uh to be mutated by",
    "start": "1935600",
    "end": "1941559"
  },
  {
    "text": "the userland applications could fully trust it and it doesn't perform enough",
    "start": "1941559",
    "end": "1947480"
  },
  {
    "text": "bound check so once the uh index is mutated to a very big value then of",
    "start": "1947480",
    "end": "1955159"
  },
  {
    "text": "course we will have a out of bound read to read out the array of the M stamp",
    "start": "1955159",
    "end": "1963159"
  },
  {
    "text": "array address array and uh read out that uh value and then write to the uh m in",
    "start": "1963159",
    "end": "1971519"
  },
  {
    "text": "line array which is OB right",
    "start": "1971519",
    "end": "1976960"
  },
  {
    "text": "okay so after the box has been exp planned let's look into the",
    "start": "1979320",
    "end": "1985159"
  },
  {
    "text": "exploitation so exploitability of those two box depends on whether we can",
    "start": "1985159",
    "end": "1990880"
  },
  {
    "start": "1986000",
    "end": "1986000"
  },
  {
    "text": "control the content for both M inline array and the M stamp address array we",
    "start": "1990880",
    "end": "1997159"
  },
  {
    "text": "need to control the content of both of them it looks like a very hard task this",
    "start": "1997159",
    "end": "2002799"
  },
  {
    "text": "is because that both arrays are created in very early stage of the iOS booting",
    "start": "2002799",
    "end": "2008960"
  },
  {
    "text": "process and it looks impossible that we can put very controlled contents right",
    "start": "2008960",
    "end": "2015080"
  },
  {
    "text": "after them and also the second reason is that the size of the element of each",
    "start": "2015080",
    "end": "2021519"
  },
  {
    "text": "three is quite different the larger the index we specify the longer Span in the",
    "start": "2021519",
    "end": "2027840"
  },
  {
    "text": "this uh the the address of the reference array element we have so that's not a",
    "start": "2027840",
    "end": "2035320"
  },
  {
    "text": "very good news and the to exploit this SP the memory layouting is a key factor before",
    "start": "2035320",
    "end": "2042399"
  },
  {
    "start": "2037000",
    "end": "2037000"
  },
  {
    "text": "doing that we need to understand some facts the first fact is that kernel hip",
    "start": "2042399",
    "end": "2047960"
  },
  {
    "text": "memory start uh at a relatively low address and Hep can glow uh grow uh",
    "start": "2047960",
    "end": "2055520"
  },
  {
    "text": "linely uh with more and more memory uh allocated and the start address of the",
    "start": "2055520",
    "end": "2062560"
  },
  {
    "text": "hip differs within tens of megabytes upon each boot this is due to the early",
    "start": "2062560",
    "end": "2070118"
  },
  {
    "text": "random value and also the address of M in line",
    "start": "2070119",
    "end": "2075839"
  },
  {
    "text": "array and the M stamp address array are closed with each",
    "start": "2075839",
    "end": "2081358"
  },
  {
    "text": "other and because of that uh we can uh use a relatively large Channel index",
    "start": "2081359",
    "end": "2088800"
  },
  {
    "text": "along with some uh Technologies like kernel hip spray we might able to",
    "start": "2088800",
    "end": "2094679"
  },
  {
    "text": "increase the possibility to make sure the out of bound value of both array are",
    "start": "2094679",
    "end": "2101480"
  },
  {
    "text": "under our",
    "start": "2101480",
    "end": "2104040"
  },
  {
    "text": "control so uh we definitely need a heap spray technologies and luckily this is",
    "start": "2106960",
    "end": "2113320"
  },
  {
    "text": "not a problem because it Is Well published and uh you can find a lot of",
    "start": "2113320",
    "end": "2119079"
  },
  {
    "text": "public articles about it and on I uh iPhone 7 uh under our test We can spray",
    "start": "2119079",
    "end": "2127240"
  },
  {
    "text": "around the 350 megab kernel memory within the container sandbox",
    "start": "2127240",
    "end": "2133800"
  },
  {
    "text": "applications and after those two uh arrays are created there are around 50",
    "start": "2133800",
    "end": "2141079"
  },
  {
    "text": "megabytes extra kernel memory [Music]",
    "start": "2141079",
    "end": "2146240"
  },
  {
    "start": "2145000",
    "end": "2145000"
  },
  {
    "text": "allocated so what conclusion we can get at this stage the first the because uh",
    "start": "2146240",
    "end": "2152680"
  },
  {
    "text": "the m in line array element size is 24 bytes under m uh stamp address array",
    "start": "2152680",
    "end": "2159440"
  },
  {
    "text": "element size is 8 bytes so uh if we can make sure that the index value",
    "start": "2159440",
    "end": "2166160"
  },
  {
    "text": "multiplied by 24 is smaller than 400 megabytes and the",
    "start": "2166160",
    "end": "2172839"
  },
  {
    "text": "index value multiplied by8 is larger than 50 megabytes then with uh we get",
    "start": "2172839",
    "end": "2180200"
  },
  {
    "text": "the range of index is in this this range and if the index is in",
    "start": "2180200",
    "end": "2187839"
  },
  {
    "text": "this range we will have higher Pro probabilities and higher",
    "start": "2187839",
    "end": "2194240"
  },
  {
    "text": "possibilities that both out of bound value of both array are fallen into our",
    "start": "2194240",
    "end": "2200160"
  },
  {
    "text": "spread data and the uh next issue is do we have",
    "start": "2200160",
    "end": "2206160"
  },
  {
    "start": "2202000",
    "end": "2202000"
  },
  {
    "text": "a arbitary memory read and write according to the nature of the bu the",
    "start": "2206160",
    "end": "2211480"
  },
  {
    "text": "arbitary memory read is not a problem because m a stamp address array element",
    "start": "2211480",
    "end": "2217319"
  },
  {
    "text": "size is 8 by with arbitary uh index value you can reach every DWS within",
    "start": "2217319",
    "end": "2224440"
  },
  {
    "text": "each page however the higher four bytes of keyword cannot be read but it is not",
    "start": "2224440",
    "end": "2231800"
  },
  {
    "text": "necessary because we uh in usually uh to make it code execution you only need to",
    "start": "2231800",
    "end": "2238640"
  },
  {
    "text": "modify and address lower bites lower 4 byes instead of the higher four",
    "start": "2238640",
    "end": "2245119"
  },
  {
    "text": "bytes however the arbitary memory right is more tricky because uh the",
    "start": "2245119",
    "end": "2252359"
  },
  {
    "text": "uh because uh because the m in line array uh element size is 24 bytes only",
    "start": "2252359",
    "end": "2259680"
  },
  {
    "text": "one of its DW can be written so it introduced a very interesting issue can",
    "start": "2259680",
    "end": "2265960"
  },
  {
    "text": "we o write to a arbitrary offset in a0x 4,000 page with the OB array element",
    "start": "2265960",
    "end": "2275359"
  },
  {
    "text": "size only 24 by before we solve this issue we need to",
    "start": "2275359",
    "end": "2281960"
  },
  {
    "text": "understand some facts the facts the first fact is a good news thanks to the",
    "start": "2281960",
    "end": "2287560"
  },
  {
    "text": "mechanism of the iOS xnu zom allocator The Base address of M in line array is",
    "start": "2287560",
    "end": "2295800"
  },
  {
    "text": "always at offset 0x F0 or 0x20 F0 because it is a uh a field in",
    "start": "2295800",
    "end": "2305400"
  },
  {
    "text": "some uh bigger object which is one uh 4,000 in in uh 2000 page uh 2000 insides",
    "start": "2305400",
    "end": "2314359"
  },
  {
    "text": "0x 2000 insides and similarly M stamp address array is allocated with uh 0x",
    "start": "2314359",
    "end": "2322760"
  },
  {
    "text": "200 Insight falling into the kog do 52 and this address offset withing the0",
    "start": "2322760",
    "end": "2330920"
  },
  {
    "text": "x uh 4,000 page can all be the Valu uh can all can be all values divided Able",
    "start": "2330920",
    "end": "2337839"
  },
  {
    "text": "by 0x 200 so this is a good news and",
    "start": "2337839",
    "end": "2342880"
  },
  {
    "text": "similarly uh uh we we need to find a find a way to write arbitrary page",
    "start": "2342880",
    "end": "2350000"
  },
  {
    "text": "offset by OB right on the m in line array and this problem uh can be solved",
    "start": "2350000",
    "end": "2357319"
  },
  {
    "text": "actually by by uh a mathematics Theory called congruence Ser so because ZX",
    "start": "2357319",
    "end": "2366160"
  },
  {
    "text": "c0000 is dividable by 0x 4000 so all",
    "start": "2366160",
    "end": "2371240"
  },
  {
    "text": "index values where are the remainder values divided by 0x 800 are the same so",
    "start": "2371240",
    "end": "2378520"
  },
  {
    "text": "we can always OB be right to the same offset in the m in line array and with",
    "start": "2378520",
    "end": "2385359"
  },
  {
    "text": "in the factor here we get get a con conclusion that uh given uh the index",
    "start": "2385359",
    "end": "2393720"
  },
  {
    "text": "equals to uh 0x uh 27 F uh 6 Plus un multipl by 0x",
    "start": "2393720",
    "end": "2403720"
  },
  {
    "text": "800 so uh if that uh condition is me we",
    "start": "2403720",
    "end": "2409440"
  },
  {
    "text": "we can always overwrite to the first eight bytes in a spray the",
    "start": "2409440",
    "end": "2415400"
  },
  {
    "text": "page and the next problem is to reach the arbitrary offset within the page",
    "start": "2415400",
    "end": "2421960"
  },
  {
    "text": "with in uh with the m be the offset of the page we just ensure that index",
    "start": "2421960",
    "end": "2428160"
  },
  {
    "text": "equals to this and we can reach to arbitary uh uh",
    "start": "2428160",
    "end": "2435319"
  },
  {
    "text": "offset within the page so we resolve this problem so here you don't need to",
    "start": "2435319",
    "end": "2440920"
  },
  {
    "text": "understand all the stories of the concr uh Theory but you only need to remember",
    "start": "2440920",
    "end": "2446200"
  },
  {
    "text": "the uh result the conclusion so when index equals to this under it within the",
    "start": "2446200",
    "end": "2453880"
  },
  {
    "text": "range of this then we can uh we are able to uh to uh overwrite",
    "start": "2453880",
    "end": "2461160"
  },
  {
    "text": "arbitrary offset in a page and at last we choose the value 0x9 e",
    "start": "2461160",
    "end": "2469000"
  },
  {
    "text": "6185 which means it can uh reach the offset 568 of one uh 4,000 Page by",
    "start": "2469000",
    "end": "2477800"
  },
  {
    "text": "writing uh this m in line array out of",
    "start": "2477800",
    "end": "2483200"
  },
  {
    "text": "bound and now let's do the first attempt of exploitation first we uh try to uh SP",
    "start": "2483880",
    "end": "2491839"
  },
  {
    "start": "2484000",
    "end": "2484000"
  },
  {
    "text": "uh spray uh around 350 megabyte and the",
    "start": "2491839",
    "end": "2497040"
  },
  {
    "text": "logic is here the test event function will reach the OB values uh uh here here",
    "start": "2497040",
    "end": "2505160"
  },
  {
    "text": "and then it try to uh try to uh try to put a guest address onto it and refer to",
    "start": "2505160",
    "end": "2513720"
  },
  {
    "text": "the value of it in slot B we call it the value uh written uh read value to read",
    "start": "2513720",
    "end": "2520640"
  },
  {
    "text": "and the uh value uh that is read will be finally uh written to uh the slot C at",
    "start": "2520640",
    "end": "2529280"
  },
  {
    "text": "the offset 0x 568 which is M uh in line array uh in in",
    "start": "2529280",
    "end": "2537839"
  },
  {
    "text": "m in line array uh array and by first attempt of the exploit we",
    "start": "2537839",
    "end": "2545119"
  },
  {
    "start": "2541000",
    "end": "2541000"
  },
  {
    "text": "then receive the o message to see which message aw field the uh address written",
    "start": "2545119",
    "end": "2553480"
  },
  {
    "text": "field has been changed by checking the new value in that uh address we can obtain two very",
    "start": "2553480",
    "end": "2561480"
  },
  {
    "text": "important piece of information the first information is which o message is",
    "start": "2561480",
    "end": "2567559"
  },
  {
    "text": "allocated in uh slot C and the second message uh important uh information is",
    "start": "2567559",
    "end": "2575599"
  },
  {
    "text": "which o message is in slot B because we can specify each o messages VR field",
    "start": "2575599",
    "end": "2583720"
  },
  {
    "text": "very unique and of after we got those information we can perform the second",
    "start": "2583720",
    "end": "2591119"
  },
  {
    "text": "exploit to bypass the aslr we do it by filling uh slot B with uh",
    "start": "2591119",
    "end": "2598480"
  },
  {
    "text": "hxg uh context object and that object is in k.",
    "start": "2598480",
    "end": "2605319"
  },
  {
    "text": "8192 so it's a very good good you can fill uh free the slot B and the fill in",
    "start": "2605319",
    "end": "2611800"
  },
  {
    "text": "the at the same address and then we change the ga value to this which is",
    "start": "2611800",
    "end": "2618839"
  },
  {
    "text": "origin g a value minus 0 x30 because the",
    "start": "2618839",
    "end": "2624160"
  },
  {
    "text": "Base address of slot B is the V table of the first eight bytes of the object is a",
    "start": "2624160",
    "end": "2631720"
  },
  {
    "text": "v table address of hxg context object so we exploit The Bu again and finally we",
    "start": "2631720",
    "end": "2639559"
  },
  {
    "text": "got the lower four bytes of the hxg context V table and after that we obtain the uh we",
    "start": "2639559",
    "end": "2648200"
  },
  {
    "text": "bypass the ksr and finally we we need the code execution so to get the code",
    "start": "2648200",
    "end": "2654400"
  },
  {
    "start": "2650000",
    "end": "2650000"
  },
  {
    "text": "execution we need to free the slot C and fill in with the object where it's offet",
    "start": "2654400",
    "end": "2661559"
  },
  {
    "text": "0x 568 represents some important object and",
    "start": "2661559",
    "end": "2666720"
  },
  {
    "text": "we found the hxg context is the best choice also because it's offset",
    "start": "2666720",
    "end": "2672920"
  },
  {
    "text": "568 represents uh HX accelerator object",
    "start": "2672920",
    "end": "2678599"
  },
  {
    "text": "by calling uh that user client method zero we can reach the function context",
    "start": "2678599",
    "end": "2684520"
  },
  {
    "text": "finish and the context finish will de reference uh that objects 5 68 uh as a d",
    "start": "2684520",
    "end": "2692359"
  },
  {
    "text": "ke word as a uh HX accelerator object and use it to call it virtual uh",
    "start": "2692359",
    "end": "2698880"
  },
  {
    "text": "functions so by uh exploit that bu again we are able to uh modify the lower four",
    "start": "2698880",
    "end": "2706400"
  },
  {
    "text": "bytes of that agx accelerate object and to modifi to",
    "start": "2706400",
    "end": "2712400"
  },
  {
    "text": "any arit value and we can control the content of that new address so that we",
    "start": "2712400",
    "end": "2718760"
  },
  {
    "text": "get PC control so finally uh I talk about the overall exploit overflow so",
    "start": "2718760",
    "end": "2724800"
  },
  {
    "start": "2720000",
    "end": "2720000"
  },
  {
    "text": "first we create IO XL source and then we got the io XEL event read only buffer we",
    "start": "2724800",
    "end": "2731640"
  },
  {
    "text": "trick the first bu to modify the M Channel index to a bigger value and then",
    "start": "2731640",
    "end": "2737839"
  },
  {
    "text": "we uh prepare the memory layout trick B two to obtain the index of the slot B",
    "start": "2737839",
    "end": "2744200"
  },
  {
    "text": "and the slot C and then we uh prepare the memory",
    "start": "2744200",
    "end": "2749520"
  },
  {
    "text": "layout under uh to uh to for KR bypass",
    "start": "2749520",
    "end": "2754559"
  },
  {
    "text": "trigger the B two and obtain the V table of hxg context so that we bypass kslr",
    "start": "2754559",
    "end": "2762400"
  },
  {
    "text": "and finally we prepare the memory leg out again for code execution to Trigger",
    "start": "2762400",
    "end": "2767880"
  },
  {
    "text": "Bug two again and overrides the ihx accelerator um pointer in agx GL context",
    "start": "2767880",
    "end": "2776359"
  },
  {
    "text": "and after that we can perform a drop and get the task for PID Z and then we",
    "start": "2776359",
    "end": "2783200"
  },
  {
    "text": "perform post exploitation to jailbreak so uh after that we got task",
    "start": "2783200",
    "end": "2789280"
  },
  {
    "start": "2786000",
    "end": "2786000"
  },
  {
    "text": "for p id0 but it's only first step of the jailbreak we still need to break the",
    "start": "2789280",
    "end": "2794760"
  },
  {
    "text": "amfi to uh remount the root FS to uh read and write and to perform the kpp",
    "start": "2794760",
    "end": "2801040"
  },
  {
    "text": "and amcc bypass is and those are very well documented out outside publicly and",
    "start": "2801040",
    "end": "2807760"
  },
  {
    "text": "it's not a scope of our talk and we we will show a demo of the the tack",
    "start": "2807760",
    "end": "2817440"
  },
  {
    "text": "yeah yeah so uh because of the time limitation I will skip some uh parts and",
    "start": "2821040",
    "end": "2826800"
  },
  {
    "text": "first we we choose version 10.3.3 because I only have this version",
    "start": "2826800",
    "end": "2832520"
  },
  {
    "text": "which can exploit this bug actually uh the bug also exists in some early version of iOS uh 11 beta but I don't",
    "start": "2832520",
    "end": "2839559"
  },
  {
    "text": "have the device so uh we click the our application uh we bypass the sbox uh",
    "start": "2839559",
    "end": "2846559"
  },
  {
    "text": "actually there is no sand box because we exploit the kernel directly but we involve two box so one I think maybe",
    "start": "2846559",
    "end": "2853920"
  },
  {
    "text": "sometime uh it can also uh the dma feature bug can also bypass the uh send",
    "start": "2853920",
    "end": "2859319"
  },
  {
    "text": "box uh also but here we don't use it we just to use it to uh change the M index",
    "start": "2859319",
    "end": "2865960"
  },
  {
    "text": "Channel index yeah after we bypass the pp uh kpp",
    "start": "2865960",
    "end": "2871559"
  },
  {
    "text": "then uh it uh do a respring and finally uh we found that that uh",
    "start": "2871559",
    "end": "2878640"
  },
  {
    "text": "the the cdia is installed on this machine uh with uh yeah you can yeah but",
    "start": "2878640",
    "end": "2885040"
  },
  {
    "text": "it's a little bit broken but I think with triple uh actions you can make it",
    "start": "2885040",
    "end": "2891319"
  },
  {
    "text": "work yeah and finally you can find the correct version of it and uh finally uh",
    "start": "2891319",
    "end": "2898920"
  },
  {
    "text": "I talk about the",
    "start": "2898920",
    "end": "2902160"
  },
  {
    "start": "2905000",
    "end": "2905000"
  },
  {
    "text": "conclusion so uh with the first release of iOS 11 Apple actually fixed the first",
    "start": "2905040",
    "end": "2910920"
  },
  {
    "text": "bu which is the dma mapping bu and it is actually fixed by adding the",
    "start": "2910920",
    "end": "2916640"
  },
  {
    "text": "implementation of the read only mapping at its do code and however the other OB",
    "start": "2916640",
    "end": "2923599"
  },
  {
    "text": "right back remains unfixed up till now and this is a very good example of how",
    "start": "2923599",
    "end": "2930760"
  },
  {
    "text": "secret can be broken by very bad implementation but with very good",
    "start": "2930760",
    "end": "2936359"
  },
  {
    "text": "Hardware design and it makes a possible a very complex exploit CH to achieve the",
    "start": "2936359",
    "end": "2943119"
  },
  {
    "text": "jailbreak within the usland applications at this uh stage it is",
    "start": "2943119",
    "end": "2950680"
  },
  {
    "text": "still safe to say that uh because with the first bu fixed the trust boundary of",
    "start": "2950680",
    "end": "2957400"
  },
  {
    "text": "the user land read only mapping is back so you don't need to uh to fix the bug",
    "start": "2957400",
    "end": "2963359"
  },
  {
    "text": "two but it brings a problem to us should we actually trust the kernel uh the user",
    "start": "2963359",
    "end": "2971160"
  },
  {
    "text": "L read only mappings and of course currently there is no definite answer because I don't",
    "start": "2971160",
    "end": "2977880"
  },
  {
    "text": "have another way to break that trust boundary but at least in this talk we",
    "start": "2977880",
    "end": "2983359"
  },
  {
    "text": "demonstrated that the user L read only mapping can be dangerous it is possible",
    "start": "2983359",
    "end": "2989240"
  },
  {
    "text": "that in the future another bu is introduced and break this trust boundary",
    "start": "2989240",
    "end": "2994760"
  },
  {
    "text": "uh trust boundary again and we make the whole exploit chain work again it's very",
    "start": "2994760",
    "end": "3000480"
  },
  {
    "text": "likely and we never know at this moment thanks for listening and if you",
    "start": "3000480",
    "end": "3006599"
  },
  {
    "text": "have any questions",
    "start": "3006599",
    "end": "3010119"
  }
]