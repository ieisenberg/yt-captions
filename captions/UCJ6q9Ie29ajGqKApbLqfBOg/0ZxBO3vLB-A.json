[
  {
    "text": "my name is Yogesh Swamy I work for a two-person startup called secure substrates we are trying to build a",
    "start": "30",
    "end": "6690"
  },
  {
    "text": "cryptographically secure container platform before joining secure secure substrates I used to work at a company",
    "start": "6690",
    "end": "12719"
  },
  {
    "text": "called cryptography research which I think more people might know about I still do some consulting work with them",
    "start": "12719",
    "end": "17970"
  },
  {
    "text": "and in fact when I submitted his talk I was still working at cryptography research so this is a brief roadmap of",
    "start": "17970",
    "end": "26310"
  },
  {
    "text": "my talk basically I want to talk about pitfalls in protocol composition and",
    "start": "26310",
    "end": "32250"
  },
  {
    "text": "some of the issues like sequential composition and concurrent composition these two issues have been known in",
    "start": "32250",
    "end": "37920"
  },
  {
    "text": "cryptographic literature for a long time however until recently and unless you've",
    "start": "37920",
    "end": "44399"
  },
  {
    "text": "worked in the area of key exchange protocols you probably didn't pay much attention to these issues because there",
    "start": "44399",
    "end": "49800"
  },
  {
    "text": "was very limited things that you do with like composing different protocols with",
    "start": "49800",
    "end": "54809"
  },
  {
    "text": "the Intel SGX however there is like a whole new way of composing protocols",
    "start": "54809",
    "end": "59910"
  },
  {
    "text": "inside an enclave so I want to highlight some of the issues that come up when you are sequentially composing protocols or",
    "start": "59910",
    "end": "66030"
  },
  {
    "text": "when you are composing them in a concurrent manner and I also want to",
    "start": "66030",
    "end": "71549"
  },
  {
    "text": "discuss a little bit about the issues with Enclave state malleability so a typical misconception is that SGX",
    "start": "71549",
    "end": "79650"
  },
  {
    "text": "enclaves are basically a black box unfortunately that's not true you can actually influence the state of the",
    "start": "79650",
    "end": "85320"
  },
  {
    "text": "black box adversarially if you if you interrupt the processor so I want to",
    "start": "85320",
    "end": "92729"
  },
  {
    "text": "discuss about that and I want to discuss what are the implications of this mainly for proof of knowledge protocols because",
    "start": "92729",
    "end": "98869"
  },
  {
    "text": "if you are not careful you might be able to extract secrets out of the Enclave by",
    "start": "98869",
    "end": "104130"
  },
  {
    "text": "appropriate by appropriately interrupting the processor so that's sort of like the first half of my talk",
    "start": "104130",
    "end": "109790"
  },
  {
    "text": "in the second half I have tried to analyze the impaired Intel's epoch",
    "start": "109790",
    "end": "115680"
  },
  {
    "text": "provisioning Enclave and the Intel's remote attestation Enclave so these two aren't waves basically try to bootstrap",
    "start": "115680",
    "end": "123420"
  },
  {
    "text": "a group signature scheme and they are created by Intel signed by Intel and so",
    "start": "123420",
    "end": "130110"
  },
  {
    "text": "I wanted to analyze how these enclaves actually behave in terms of these three issues that I listed above so here I have some",
    "start": "130110",
    "end": "137890"
  },
  {
    "text": "good news that the enclaves are secured and some bad news that the goal of",
    "start": "137890",
    "end": "143230"
  },
  {
    "text": "epidurals to provide anonymity is actually not achieved at least the way",
    "start": "143230",
    "end": "148390"
  },
  {
    "text": "the Intel has implemented it so that's sort of a brief roadmap of my talk so",
    "start": "148390",
    "end": "155260"
  },
  {
    "text": "let's get started so STX is an example",
    "start": "155260",
    "end": "163060"
  },
  {
    "text": "of a hardware software crypto code design and typically in such systems you",
    "start": "163060",
    "end": "168760"
  },
  {
    "text": "have a trusted piece of hardware and you have a trusted piece of software and you want to always and you have like a small",
    "start": "168760",
    "end": "175680"
  },
  {
    "text": "small trusted piece of software and you want to make sure that your trusted software always runs in the trusted",
    "start": "175680",
    "end": "181420"
  },
  {
    "text": "piece of hardware the problem is when you are running these things in a cloud environment you do not know if the",
    "start": "181420",
    "end": "188290"
  },
  {
    "text": "trusted heart if the trusted software is actually running on the trusted hardware so for example if I am an attacker I",
    "start": "188290",
    "end": "194590"
  },
  {
    "text": "might be able to replace the trusted hardware with a simulator of that hardware so you can think of for example",
    "start": "194590",
    "end": "201519"
  },
  {
    "text": "in this case I have the user wants the application to run in in in the real",
    "start": "201519",
    "end": "206980"
  },
  {
    "text": "Hardware SGX but the cloud provider actually switches the HDX hardware with",
    "start": "206980",
    "end": "212199"
  },
  {
    "text": "a qme simulator of HDX and there are two classes of simulator attacks that you can do so first class",
    "start": "212199",
    "end": "218829"
  },
  {
    "text": "is like you basically just simulate the whole thing on a on a general platform",
    "start": "218829",
    "end": "224530"
  },
  {
    "text": "the second class of attacks is where you simulate where the simulator runs inside",
    "start": "224530",
    "end": "229810"
  },
  {
    "text": "the trusted hardware so to prevent attacks against the first kind of attack",
    "start": "229810",
    "end": "235019"
  },
  {
    "text": "first kind of attack it's the countermeasures are relatively simple you just give oracle access to the",
    "start": "235019",
    "end": "241569"
  },
  {
    "text": "hardware incident key and you cannot give the real access to the hardware dissident key because the software might",
    "start": "241569",
    "end": "247299"
  },
  {
    "text": "not be trusted so the software might actually take the hardware key and pretend to be hardware from that point",
    "start": "247299",
    "end": "252760"
  },
  {
    "text": "onwards so you have to have some kind of access control mechanism typically an",
    "start": "252760",
    "end": "259090"
  },
  {
    "text": "Oracle basically our Oracle based access control mechanism to access the hardware",
    "start": "259090",
    "end": "264240"
  },
  {
    "text": "resident key when the attacker can run the simulator inside a trusted hardware",
    "start": "264240",
    "end": "269280"
  },
  {
    "text": "then the countermeasures are more difficult and the goal typically in in",
    "start": "269280",
    "end": "274290"
  },
  {
    "text": "in simulating simulating something inside a trusted hardware is to do like",
    "start": "274290",
    "end": "280440"
  },
  {
    "text": "a man-in-the-middle attack the good news is that the sgx platform SGX",
    "start": "280440",
    "end": "286170"
  },
  {
    "text": "by design it has like embedded key within the hardware and it takes care of both these issues with simulating the",
    "start": "286170",
    "end": "294030"
  },
  {
    "text": "hardware so if you instantiate an enclave and if you get a remote",
    "start": "294030",
    "end": "300480"
  },
  {
    "text": "attestation you are guaranteed that the whole Enclave have been instantiated correctly on a real hardware however the",
    "start": "300480",
    "end": "309060"
  },
  {
    "text": "question is and maybe the essence of this talk is that since you can just",
    "start": "309060",
    "end": "315780"
  },
  {
    "text": "because you can instantiate the whole thing in the real hardware does that",
    "start": "315780",
    "end": "321510"
  },
  {
    "text": "mean that you cannot simulate some sub computation of that whole thing outside",
    "start": "321510",
    "end": "326580"
  },
  {
    "text": "of the Enclave so but to get to that let's look at a common SGX and STX",
    "start": "326580",
    "end": "335780"
  },
  {
    "text": "design paradigm and this is not just specific to STX this is maybe this also",
    "start": "335780",
    "end": "342510"
  },
  {
    "text": "applies to things like cloud HSM where when you are communicating with the cloud edge system you need to make sure",
    "start": "342510",
    "end": "348780"
  },
  {
    "text": "that you are actually talking to a cloud HSM and not a simulator of the cloud HSM because you have because when you are",
    "start": "348780",
    "end": "355680"
  },
  {
    "text": "interacting remotely you have no guarantees that the cloud provider is actually running your software in a real",
    "start": "355680",
    "end": "361170"
  },
  {
    "text": "cloud HSM hardware so a common design",
    "start": "361170",
    "end": "366300"
  },
  {
    "text": "paradigm and this is that you first define a generic remote attestation scheme so in this example that generic",
    "start": "366300",
    "end": "373110"
  },
  {
    "text": "remote attestation scheme is that you pick a random nonce sufficiently long and you basically send that nonce to the",
    "start": "373110",
    "end": "380430"
  },
  {
    "text": "Enclave the Enclave creates generates an attestation on this nonce and returns",
    "start": "380430",
    "end": "385470"
  },
  {
    "text": "the neurons back returns the nonce and attestation back and then in the step",
    "start": "385470",
    "end": "390750"
  },
  {
    "text": "two you basically define your actual you case so here you define things like how",
    "start": "390750",
    "end": "395960"
  },
  {
    "text": "to generate keys how to switch are generating keys you have private keys and public is you need to save these",
    "start": "395960",
    "end": "401600"
  },
  {
    "text": "private keys onto disk so you need to have a protocol for encrypting those private keys then you might require you",
    "start": "401600",
    "end": "409190"
  },
  {
    "text": "might be needed to generate a CSR so CSR is another protocol where you need to do",
    "start": "409190",
    "end": "414530"
  },
  {
    "text": "like proof of position things like that and then you you might also do auditing",
    "start": "414530",
    "end": "420830"
  },
  {
    "text": "and and things like that so in step 2 normally this is like a software",
    "start": "420830",
    "end": "425990"
  },
  {
    "text": "engineering paradigm you build things in a modular way and then you try to combine them together and then in the",
    "start": "425990",
    "end": "432560"
  },
  {
    "text": "third step you typically have like a workflow so you take all these things so",
    "start": "432560",
    "end": "437900"
  },
  {
    "text": "you have basically key generation maybe loading the key signing things with that key saving keys to the disk all those",
    "start": "437900",
    "end": "446090"
  },
  {
    "text": "things and you define a workflow which combines meta-level things so the workflow will be like in step one I'll",
    "start": "446090",
    "end": "453169"
  },
  {
    "text": "generate a key I'll get the CSR I'll sign it and return it back in step two it will be I will sign I will look up",
    "start": "453169",
    "end": "459080"
  },
  {
    "text": "the key I will sign some data with that key so on and so forth and there are",
    "start": "459080",
    "end": "464840"
  },
  {
    "text": "several examples of this kind of a paradigm so it's both in like published",
    "start": "464840",
    "end": "470570"
  },
  {
    "text": "literature in fact some of the published papers they don't even mention step one they assume that there is like a remote",
    "start": "470570",
    "end": "476810"
  },
  {
    "text": "attestation mechanism and they only focus on step two and maybe step three and the question is like is this design",
    "start": "476810",
    "end": "483800"
  },
  {
    "text": "paradigm secure so once again as I mentioned before because one cannot instantiate the whole Enclave secure",
    "start": "483800",
    "end": "493419"
  },
  {
    "text": "cannot simulate the whole Enclave the Assumption in all these designs is that because you cannot seem simulate the",
    "start": "493419",
    "end": "500330"
  },
  {
    "text": "whole thing you might not be able to simulate parts of the things unfortunately this design paradigm is",
    "start": "500330",
    "end": "507710"
  },
  {
    "text": "completely broken and and probably you will never design something like this in real life so this is deliberately a bad",
    "start": "507710",
    "end": "514010"
  },
  {
    "text": "example the problem here is that basically the attacker can response to",
    "start": "514010",
    "end": "522289"
  },
  {
    "text": "the nonce and the challenge appropriately with the attestation but everything else that I can simulate",
    "start": "522289",
    "end": "529500"
  },
  {
    "text": "in some other piece of hardware so the attacker can do the key generation outside of the HSM or the of the Enclave",
    "start": "529500",
    "end": "536250"
  },
  {
    "text": "the attacker can basically get the get the CSR sign the CSR and install the",
    "start": "536250",
    "end": "542790"
  },
  {
    "text": "certificate so this example so in this example it's the whole thing is",
    "start": "542790",
    "end": "548310"
  },
  {
    "text": "completely broken because the private key will be generated outside of the ante in in in a more realistic scenario",
    "start": "548310",
    "end": "558570"
  },
  {
    "text": "things might not be this clear-cut so identifying this attack would be like trivial but in a more realistic scenario",
    "start": "558570",
    "end": "564570"
  },
  {
    "text": "you might have 10 different enclaves which are interacting with each other and some portions of those antlers",
    "start": "564570",
    "end": "570570"
  },
  {
    "text": "cannot be simulated outside however there might be some component some states of this Enclave so an enclave is",
    "start": "570570",
    "end": "576990"
  },
  {
    "text": "basically it's an algorithm it transitions from one state to another and some of those states might be",
    "start": "576990",
    "end": "583560"
  },
  {
    "text": "simulated outside of the Conclave and and so a crucial question in designing",
    "start": "583560",
    "end": "591420"
  },
  {
    "text": "all these things is to not analyze individual individual components of the",
    "start": "591420",
    "end": "597780"
  },
  {
    "text": "protocol so not analyze just like attestation or not analyze just how to do key generation and how to get the",
    "start": "597780",
    "end": "604650"
  },
  {
    "text": "certificate signing request but to analyze this whole Enclave as a single protocol which is composed of multiple",
    "start": "604650",
    "end": "612980"
  },
  {
    "text": "multiple sub protocols and if one looks at the an treyvion in such a way one can",
    "start": "612980",
    "end": "621750"
  },
  {
    "text": "come up with some very subtle attacks so for example a very popular paradigm once",
    "start": "621750",
    "end": "628650"
  },
  {
    "text": "again is that people love to log the hash of private data so what I call like",
    "start": "628650",
    "end": "635339"
  },
  {
    "text": "commitment logs people will take like some confidential data for example someone's birthday and instead of",
    "start": "635339",
    "end": "640980"
  },
  {
    "text": "logging that birthday itself they will log the hash of that birthday and then",
    "start": "640980",
    "end": "646440"
  },
  {
    "text": "later on they will take this birthday and they will send it over TLS assuming and and in the whole process while they",
    "start": "646440",
    "end": "653190"
  },
  {
    "text": "are doing this that thinking that since I put the hash of the birthday that's secure because I'm putting a hash it's",
    "start": "653190",
    "end": "659190"
  },
  {
    "text": "not and then since I'm sending things over TLS no one can read the birthday but the",
    "start": "659190",
    "end": "666990"
  },
  {
    "text": "truth is this this subtle scheme is once again not secure because the user can enlist all",
    "start": "666990",
    "end": "672960"
  },
  {
    "text": "the birthdays compute its hash and completely destroy the confidentiality of the whatever goes on the TLS so in a",
    "start": "672960",
    "end": "680820"
  },
  {
    "text": "mood and this is once again is an example of a sequential composition so you are hashing things and putting it in",
    "start": "680820",
    "end": "686430"
  },
  {
    "text": "a log and then you are taking that actual content and you are sending it out over the wire over TLS and there can",
    "start": "686430",
    "end": "694110"
  },
  {
    "text": "be some even more subtle examples which I am not listed here where the attack is",
    "start": "694110",
    "end": "699240"
  },
  {
    "text": "not so clear-cut but the attacks are in terms of the bounds of your algorithm so every crypto algorithm you have bounced",
    "start": "699240",
    "end": "706320"
  },
  {
    "text": "it says like until you make like maybe two days to ninety queries until you",
    "start": "706320",
    "end": "711780"
  },
  {
    "text": "generate like two didn't raise to ninety messages your whole system is secure beyond that it completely falls apart",
    "start": "711780",
    "end": "717800"
  },
  {
    "text": "however when you are sequentially composing things it might happen that that two days to ninety came back to two",
    "start": "717800",
    "end": "723240"
  },
  {
    "text": "days two thirty now it's within my cryptanalysis bounds and I can now go ahead and do something with it so at",
    "start": "723240",
    "end": "732000"
  },
  {
    "text": "this point you might be wondering that why is this and why am I talking about this in terms of simulation and remote",
    "start": "732000",
    "end": "738120"
  },
  {
    "text": "attestation and and the reason is that an Enclave is actually an algorithm and",
    "start": "738120",
    "end": "744150"
  },
  {
    "text": "there is no easy way to talk about an algorithm what does it mean for an algorithm to be secure so we know what",
    "start": "744150",
    "end": "750900"
  },
  {
    "text": "it means for a piece of data to be secured but an algorithm is kind of like a living thing it's transitioning from",
    "start": "750900",
    "end": "757470"
  },
  {
    "text": "one state to another and in that context it's better to talk about similar simulation and simulate ability than to",
    "start": "757470",
    "end": "765570"
  },
  {
    "text": "talk about whether it's broken or not broken as I've been saying okay so so",
    "start": "765570",
    "end": "772350"
  },
  {
    "text": "the first point I want to make is that sequential composition is is problematic",
    "start": "772350",
    "end": "777750"
  },
  {
    "text": "and you have to look at the whole Enclave as a single protocol and analyze it from that perspective so let's go",
    "start": "777750",
    "end": "784680"
  },
  {
    "text": "back to this example and let's look at the shield protocol so",
    "start": "784680",
    "end": "792770"
  },
  {
    "text": "so the user had generated a key and the user now wants to save this private key",
    "start": "796670",
    "end": "801930"
  },
  {
    "text": "and later on the user wants to kind of retrieve these private keys in lookup",
    "start": "801930",
    "end": "808410"
  },
  {
    "text": "this private key key is really fast so that they can do like so that they can serve like web applications and things",
    "start": "808410",
    "end": "814230"
  },
  {
    "text": "like that which is getting like millions of requests per second and so the user",
    "start": "814230",
    "end": "819779"
  },
  {
    "text": "comes up with this scheme for storing their keys so because SGX does not have a replay",
    "start": "819779",
    "end": "828240"
  },
  {
    "text": "protection okay let me first describe how the keys are stored and then I'll describe for the issue that so the user",
    "start": "828240",
    "end": "835589"
  },
  {
    "text": "wants to store their private keys on disk so they decide that we will use an aad scheme like GCM where I will keep",
    "start": "835589",
    "end": "843569"
  },
  {
    "text": "like the key attributes the key name the public key and the encrypted secret key as a single record but the problem is",
    "start": "843569",
    "end": "852060"
  },
  {
    "text": "that SGX does not have an internal counter so the HDX needs to know to get",
    "start": "852060",
    "end": "857370"
  },
  {
    "text": "the nonce which cannot be repeated from somewhere outside and the only trusted way to generate this nonce is basically",
    "start": "857370",
    "end": "864209"
  },
  {
    "text": "by using by adding a TPM to the trusted compute this so so what the user has done they have actually added TPM to",
    "start": "864209",
    "end": "871350"
  },
  {
    "text": "their trusted computing base and every time they want to generate a record like this they first get a counter from the",
    "start": "871350",
    "end": "878220"
  },
  {
    "text": "TPM and they get a signature from the TPM because you don't want someone to",
    "start": "878220",
    "end": "883319"
  },
  {
    "text": "switch the motherboard and reset the TPM counter because if you switch the motherboard the TPM counter will go back",
    "start": "883319",
    "end": "888720"
  },
  {
    "text": "to zero on a fresh motherboard so the user has taken care of that and before",
    "start": "888720",
    "end": "893850"
  },
  {
    "text": "using this TPM counter basically they validate the counter and then do a GCM",
    "start": "893850",
    "end": "898949"
  },
  {
    "text": "encrypt with this counter so if we look at this example the user has done",
    "start": "898949",
    "end": "904019"
  },
  {
    "text": "everything that the GCM spec expects you to do and go and public on often beyond",
    "start": "904019",
    "end": "909839"
  },
  {
    "text": "than what is expected but this scheme is still completely insecure and the reason",
    "start": "909839",
    "end": "917040"
  },
  {
    "text": "is that the Enclave does not have a way to control how many instances of the Enclave can be instantiated so aunt",
    "start": "917040",
    "end": "924269"
  },
  {
    "text": "waves are like shared libraries so you can create as many copies of the enclaves in processor process memory as you want and",
    "start": "924269",
    "end": "931220"
  },
  {
    "text": "so what the attacker does it takes the TPM counter and the signature and feeds",
    "start": "931220",
    "end": "936329"
  },
  {
    "text": "it to both these instances of the Enclave now both these enclaves will validate the validate the counter",
    "start": "936329",
    "end": "943200"
  },
  {
    "text": "correctly because it's signed by the TPM both the Bourdon and trace are exactly the same the only thing that's different",
    "start": "943200",
    "end": "949950"
  },
  {
    "text": "is the internal random number in them and so they will both basically generate",
    "start": "949950",
    "end": "956430"
  },
  {
    "text": "two different keys but encrypt those two different keys with the same counter and",
    "start": "956430",
    "end": "963230"
  },
  {
    "text": "and because it's encrypting the same same thing in GCM using the same nonce",
    "start": "963230",
    "end": "968910"
  },
  {
    "text": "this can be completely broken so so this is an example of a concurrent",
    "start": "968910",
    "end": "975029"
  },
  {
    "text": "composition fair and otherwise secure protocol so if you run this whole thing sequentially you have no issue but if",
    "start": "975029",
    "end": "982769"
  },
  {
    "text": "you run these things in if you run these things concurrently the whole system is",
    "start": "982769",
    "end": "988410"
  },
  {
    "text": "broken now for keys it might not be an issue because like AES key or ECDSA key",
    "start": "988410",
    "end": "993510"
  },
  {
    "text": "it already has enough randomness that even if you XOR your GCM encrypted block",
    "start": "993510",
    "end": "998519"
  },
  {
    "text": "you won't be able to build a distinguisher but in general this will be an issue if if the underlying data",
    "start": "998519",
    "end": "1004490"
  },
  {
    "text": "doesn't have sufficient randomness I want to point out that the SGX has the",
    "start": "1004490",
    "end": "1011089"
  },
  {
    "text": "lack of replay protection it has lots of consequences when you are actually",
    "start": "1011089",
    "end": "1016279"
  },
  {
    "text": "implementing an unsafe and at least I think it's like a design flaw that there",
    "start": "1016279",
    "end": "1022550"
  },
  {
    "text": "is no easy way to get a counter from the SGX from Intel SGX instruction set there",
    "start": "1022550",
    "end": "1034220"
  },
  {
    "text": "is joy in STX there is a way to kind of do access control and that access control mechanism is enforced by the",
    "start": "1034220",
    "end": "1041839"
  },
  {
    "text": "launch Enclave which again Intel provides however it cannot limit",
    "start": "1041839",
    "end": "1047390"
  },
  {
    "text": "concurrency so if you want to create 1 million copies of the Enclave 1 million processor images of the Enclave you are",
    "start": "1047390",
    "end": "1055280"
  },
  {
    "text": "totally free to do that so so sequential composition is the",
    "start": "1055280",
    "end": "1062290"
  },
  {
    "text": "problem concurrent composition is a problem and here again the issue is not that I can extract the key or I can",
    "start": "1062290",
    "end": "1070260"
  },
  {
    "text": "extract basically some part of the key the issue here is that because I can",
    "start": "1070260",
    "end": "1076600"
  },
  {
    "text": "extract some portion of the key I might be able to simulate some subset of the",
    "start": "1076600",
    "end": "1082510"
  },
  {
    "text": "state machines that my original Enclave have so the limit the damage of all these things is not limited to that",
    "start": "1082510",
    "end": "1088840"
  },
  {
    "text": "piece of data but everything that might depend on that data so once again enclaves are like living things these",
    "start": "1088840",
    "end": "1094780"
  },
  {
    "text": "are algorithms right so you are not just affecting one node in your in the state",
    "start": "1094780",
    "end": "1101260"
  },
  {
    "text": "machine of your Enclave you might be affecting multiple nodes in the whole system",
    "start": "1101260",
    "end": "1106950"
  },
  {
    "text": "okay so that's about concurrent composition so the third issue that I",
    "start": "1106950",
    "end": "1112240"
  },
  {
    "text": "want to talk about is state malleability and knowledge extractors so a common",
    "start": "1112240",
    "end": "1124090"
  },
  {
    "text": "misconception is that an SGX Enclave is a black box so so what does it mean for",
    "start": "1124090",
    "end": "1130720"
  },
  {
    "text": "something to be a black box so conceptually a black box is something where you make a call so for example on",
    "start": "1130720",
    "end": "1138190"
  },
  {
    "text": "the top left diagram you make an e call and from the time when you make an equal",
    "start": "1138190",
    "end": "1143920"
  },
  {
    "text": "and the time you exit out of that call no one else outside of that block black box can affect the internal state of the",
    "start": "1143920",
    "end": "1151180"
  },
  {
    "text": "box okay so for example if if SGX enclaves were really a black box and if",
    "start": "1151180",
    "end": "1157960"
  },
  {
    "text": "they were like a global variable call let's say counter which is set to zero when you make a call to this black box",
    "start": "1157960",
    "end": "1164620"
  },
  {
    "text": "the counter will go to one as long as you are inside that black box no one",
    "start": "1164620",
    "end": "1170560"
  },
  {
    "text": "outside of the black box can influence the value of this counter so if SJ x",
    "start": "1170560",
    "end": "1175930"
  },
  {
    "text": "were like a pure black box the value of this counter would either be 0 or 1 so it will be 0 when you are outside of the",
    "start": "1175930",
    "end": "1182200"
  },
  {
    "text": "Enclave it will be 1 when you are inside unfortunately the problem is that when",
    "start": "1182200",
    "end": "1187990"
  },
  {
    "text": "the processor gets an interrupt the Shanta life comes out of its secure mode",
    "start": "1187990",
    "end": "1193040"
  },
  {
    "text": "and hands over control to the environment to the interrupt service routine now the interrupt service",
    "start": "1193040",
    "end": "1199010"
  },
  {
    "text": "routine it's in untrusted part of the code so typically you would expect that",
    "start": "1199010",
    "end": "1204140"
  },
  {
    "text": "the the interrupt service routine will basically return back and it will resume",
    "start": "1204140",
    "end": "1210130"
  },
  {
    "text": "however the adversity is under no obligation to do that so the adversity can actually create an artificial",
    "start": "1210130",
    "end": "1216770"
  },
  {
    "text": "interrupt and instead of resuming from that it can recall the same function so",
    "start": "1216770",
    "end": "1222020"
  },
  {
    "text": "it can call the same eCall make the same a call and increment the counter by",
    "start": "1222020",
    "end": "1228140"
  },
  {
    "text": "whatever number it wants right so and so if you have a global state in STX that",
    "start": "1228140",
    "end": "1234710"
  },
  {
    "text": "global state can be influenced by the by the outside software and this actually",
    "start": "1234710",
    "end": "1242960"
  },
  {
    "text": "manifests in very different ways depending upon how the protocol is implemented how different protocols are",
    "start": "1242960",
    "end": "1249770"
  },
  {
    "text": "implemented so for example a lot of proof of knowledge protocol so proof of knowledge protocols are those in which",
    "start": "1249770",
    "end": "1256450"
  },
  {
    "text": "there is a mechanism by which you can extract the knowledge that is sitting",
    "start": "1256450",
    "end": "1261500"
  },
  {
    "text": "inside that protocol so for example you could have like two prime numbers and",
    "start": "1261500",
    "end": "1267860"
  },
  {
    "text": "you have like the your RSA modulus which is B times Q a proof of knowledge",
    "start": "1267860",
    "end": "1273380"
  },
  {
    "text": "protocol will have a mechanism which will say what are these two prime numbers it's not easy to come up with a proof of knowledge with with composite",
    "start": "1273380",
    "end": "1281360"
  },
  {
    "text": "numbers but the idea is that there is a mechanism to extract the the knowledge",
    "start": "1281360",
    "end": "1287090"
  },
  {
    "text": "that is hiding behind the protocol and most of these proof of knowledge",
    "start": "1287090",
    "end": "1292100"
  },
  {
    "text": "protocols they basically work by giving assimilated the ability to rewind the",
    "start": "1292100",
    "end": "1298400"
  },
  {
    "text": "prover so so for example in in Sigma protocols you have a single you have",
    "start": "1298400",
    "end": "1304340"
  },
  {
    "text": "like a commit you have a challenge and a response and you prove proof of knowledge by for the same commit if",
    "start": "1304340",
    "end": "1310610"
  },
  {
    "text": "someone can respond to two challenges you can solve for the for the secret",
    "start": "1310610",
    "end": "1316010"
  },
  {
    "text": "that is sitting behind so because of this because you can interrupt the global state if you are",
    "start": "1316010",
    "end": "1322870"
  },
  {
    "text": "if you put the commitment as a global state in the Enclave one might be able to call different threads in the Enclave",
    "start": "1322870",
    "end": "1329230"
  },
  {
    "text": "and generate two challenged responses and then solve for that and this way you",
    "start": "1329230",
    "end": "1334330"
  },
  {
    "text": "can actually extract the extract the knowledge that is hiding behind it so it's not that you cannot protect against",
    "start": "1334330",
    "end": "1341950"
  },
  {
    "text": "this you just have to know about it that what might happen so these are the three",
    "start": "1341950",
    "end": "1348310"
  },
  {
    "text": "issues that that I think are important to know and consider when when you are",
    "start": "1348310",
    "end": "1353830"
  },
  {
    "text": "designing enclaves so in the second part of the talk I'm going to talk about how",
    "start": "1353830",
    "end": "1359050"
  },
  {
    "text": "Intel does STX epic processing and how it does remote attestation and and",
    "start": "1359050",
    "end": "1367480"
  },
  {
    "text": "basically try to find out like how if these things are secured under those",
    "start": "1367480",
    "end": "1375190"
  },
  {
    "text": "three issues that I mentioned before",
    "start": "1375190",
    "end": "1378299"
  },
  {
    "text": "so just to recap the issue is that there is a secret sitting inside the hardware",
    "start": "1384820",
    "end": "1392380"
  },
  {
    "text": "and and and the hardware is supposed to prove to some third party that it",
    "start": "1392380",
    "end": "1400270"
  },
  {
    "text": "actually has that secret and the question is how can the hardware do this especially when some malicious software",
    "start": "1400270",
    "end": "1407380"
  },
  {
    "text": "might be running on that hardware and the simplest way to do that would be to",
    "start": "1407380",
    "end": "1412450"
  },
  {
    "text": "use something like a signature of knowledge scream like a schnorrer signature which will prove that the",
    "start": "1412450",
    "end": "1418300"
  },
  {
    "text": "hardware actually has this has this secret the problem with that is that it",
    "start": "1418300",
    "end": "1423700"
  },
  {
    "text": "raises issues concerns about the privacy so with such a scheme if if the same",
    "start": "1423700",
    "end": "1431800"
  },
  {
    "text": "platform signs to messages using short stick signatures you might be able to link those two signatures you might be",
    "start": "1431800",
    "end": "1440140"
  },
  {
    "text": "able to find out if it's the same platform or if it is a different platform so these are randomized but they are still linked of them so and so",
    "start": "1440140",
    "end": "1450960"
  },
  {
    "text": "so the STX elute solution to that was that was to use group signatures and to",
    "start": "1450960",
    "end": "1457510"
  },
  {
    "text": "protect against the privacy issues so",
    "start": "1457510",
    "end": "1463020"
  },
  {
    "text": "just a very brief overview of group signatures so group signatures are like",
    "start": "1463020",
    "end": "1469450"
  },
  {
    "text": "are a lot like standard signatures that you have a public key with which you can",
    "start": "1469450",
    "end": "1475600"
  },
  {
    "text": "verify sign messages but the way this the private keys are managed they are",
    "start": "1475600",
    "end": "1481600"
  },
  {
    "text": "very different so in a group signature each member of the group has a has a",
    "start": "1481600",
    "end": "1487930"
  },
  {
    "text": "unique private key but there is a single public key with which you can validate signatures coming from any of these",
    "start": "1487930",
    "end": "1494050"
  },
  {
    "text": "members and the reason you might want to have something like this is because you",
    "start": "1494050",
    "end": "1499690"
  },
  {
    "text": "want to have anonymity of the members so if two members for example if SK 1 and",
    "start": "1499690",
    "end": "1505510"
  },
  {
    "text": "SK 2 if they both sign a message just by",
    "start": "1505510",
    "end": "1511390"
  },
  {
    "text": "having the signature and the group public key you will not be able to tell whether SK 1 signed it or whether",
    "start": "1511390",
    "end": "1517299"
  },
  {
    "text": "care to sign it and so of course to build such a thing you need a definition",
    "start": "1517299",
    "end": "1523539"
  },
  {
    "text": "of a group so you need a group manager who defines who are the members of this group and who defines basically what are",
    "start": "1523539",
    "end": "1530860"
  },
  {
    "text": "the credentials of each member so you have a group group manager which in case of HDX is the Intel attestation service",
    "start": "1530860",
    "end": "1537100"
  },
  {
    "text": "and then you have individual members which are basically individual CPUs and",
    "start": "1537100",
    "end": "1543779"
  },
  {
    "text": "group signatures like standard signatures have this have the standard",
    "start": "1543779",
    "end": "1548860"
  },
  {
    "text": "requirement of and forge ability but they have additional requirements for example anonymity and they're like lots",
    "start": "1548860",
    "end": "1556690"
  },
  {
    "text": "of models of this so Bolero much Volare much inch of Mariinsky they had like a first formal model in which they define",
    "start": "1556690",
    "end": "1564279"
  },
  {
    "text": "the notion of fully anonymous group signatures where even if you give the",
    "start": "1564279",
    "end": "1569710"
  },
  {
    "text": "adverts to you all the private keys that versity can still cannot distinguish one",
    "start": "1569710",
    "end": "1574840"
  },
  {
    "text": "signature one member from other another so that's a very strong guarantee epi don't have that but that's something to",
    "start": "1574840",
    "end": "1582700"
  },
  {
    "text": "strive for group signatures also tend to have issues have requirements in terms",
    "start": "1582700",
    "end": "1587889"
  },
  {
    "text": "of traceability so if there is a rogue member and if you want to eventually",
    "start": "1587889",
    "end": "1593019"
  },
  {
    "text": "find out like who that rogue member of the group is you might want to open the signature and see who has the signer for",
    "start": "1593019",
    "end": "1600639"
  },
  {
    "text": "that message so in general it's it's anonymous but there is a special entity",
    "start": "1600639",
    "end": "1606279"
  },
  {
    "text": "who can open the signature and figure out who was the signer once again epi does not have anonymity",
    "start": "1606279",
    "end": "1614769"
  },
  {
    "text": "the reason I'm mentioning all these things is because like lots of models out there for group signatures and you have to pick the right model to actually",
    "start": "1614769",
    "end": "1621549"
  },
  {
    "text": "understand what epital sighing to doing to do so in epic the three main main",
    "start": "1621549",
    "end": "1627489"
  },
  {
    "text": "security goals are anonymity so this is not full anonymity in the sense of Villa",
    "start": "1627489",
    "end": "1632739"
  },
  {
    "text": "Roma chinchou but in ski but this is anonymity as long as the private keys are secret adversity cannot distinguish",
    "start": "1632739",
    "end": "1640149"
  },
  {
    "text": "between two members epital so has a blinded joint protocol so a blinded join",
    "start": "1640149",
    "end": "1646539"
  },
  {
    "text": "means that when a member joins a the member does not have to reveal its",
    "start": "1646539",
    "end": "1651840"
  },
  {
    "text": "private key to the group manager a lot of group signature schemes you would",
    "start": "1651840",
    "end": "1657330"
  },
  {
    "text": "have to give your private keys or the group manager had to generate the private key for you and give it back to",
    "start": "1657330",
    "end": "1663270"
  },
  {
    "text": "you so if it does not require that and then epital so has memory vocation so",
    "start": "1663270",
    "end": "1670260"
  },
  {
    "text": "because if it does not have a way to open signatures you need signature reification to flag who are the bad",
    "start": "1670260",
    "end": "1676740"
  },
  {
    "text": "members of this crew okay so so I'll",
    "start": "1676740",
    "end": "1682440"
  },
  {
    "text": "just briefly describe how a paid work so I won't go into the algebraic details of this because I think it's not very relevant for this talk but in general it",
    "start": "1682440",
    "end": "1691020"
  },
  {
    "text": "has so opit signatures have two components one is what what is called",
    "start": "1691020",
    "end": "1697140"
  },
  {
    "text": "like the basic signature and then there is a proof of non revoked signature and then second component to the proof of",
    "start": "1697140",
    "end": "1702750"
  },
  {
    "text": "non revoked signatures and the basic signature is based on BBS Plus scheme so",
    "start": "1702750",
    "end": "1708600"
  },
  {
    "text": "BBS was born a boy and Sansome group signature which was a short group",
    "start": "1708600",
    "end": "1713910"
  },
  {
    "text": "signature it only worked in the static model so the group manager had to create all the private keys that group",
    "start": "1713910",
    "end": "1721350"
  },
  {
    "text": "signature was converted to a standard signature scheme by all Susilo and new",
    "start": "1721350",
    "end": "1728940"
  },
  {
    "text": "and and and there they only make assumptions about Q s th and and the CCA",
    "start": "1728940",
    "end": "1736290"
  },
  {
    "text": "to secure in standard model what that means is that you don't need to have you",
    "start": "1736290",
    "end": "1742020"
  },
  {
    "text": "don't see in this whole scheme for example anyone computing hashes on commitments and things like that you",
    "start": "1742020",
    "end": "1747960"
  },
  {
    "text": "might still have to compute a hash of the message to map the message to a to a",
    "start": "1747960",
    "end": "1753660"
  },
  {
    "text": "field element but that's about it you don't need to actually make assumptions about like the random Oracle model and",
    "start": "1753660",
    "end": "1761330"
  },
  {
    "text": "so if it makes heavy use of BBS + signature scheme and the construct",
    "start": "1761330",
    "end": "1768240"
  },
  {
    "text": "construction is something like this the member basically generates its own private key which is gamma and then it",
    "start": "1768240",
    "end": "1775470"
  },
  {
    "text": "gets a BBS plus signature on on gamma from the group man",
    "start": "1775470",
    "end": "1780490"
  },
  {
    "text": "and since the model is in in the steps and since the signature is in the standard model you can actually prove",
    "start": "1780490",
    "end": "1787270"
  },
  {
    "text": "things about this signature so that's one of the advantages of using PBS plus is that since it's in the standard model",
    "start": "1787270",
    "end": "1793690"
  },
  {
    "text": "you can prove properties of the signature and to sign a message basically any member who has got a",
    "start": "1793690",
    "end": "1800860"
  },
  {
    "text": "signature on on its private key can prove in zero knowledge that I know us",
    "start": "1800860",
    "end": "1806500"
  },
  {
    "text": "gamma and I have a signature from the group manager on that gamma and and and",
    "start": "1806500",
    "end": "1812230"
  },
  {
    "text": "this is the zero knowledge proof of that so it's a so BBS plus is a really very",
    "start": "1812230",
    "end": "1818260"
  },
  {
    "text": "pretty signature scheme I won't go into any more details notice that the join protocol is is is it's a zero knowledge",
    "start": "1818260",
    "end": "1828010"
  },
  {
    "text": "protocol so and most unit protocols have issues with concurrent join epi does not",
    "start": "1828010",
    "end": "1833140"
  },
  {
    "text": "by itself try to address that however the Intel SGX implementation it",
    "start": "1833140",
    "end": "1840490"
  },
  {
    "text": "tries to address that by encrypting every join request with a key known only to Intel attestation service and the CPU",
    "start": "1840490",
    "end": "1847540"
  },
  {
    "text": "I think that's why they interpret I'm not sure so as I mentioned they're like",
    "start": "1847540",
    "end": "1853150"
  },
  {
    "text": "two parts of the signature one is the basic signature which is based on this pairing groups and then there is another",
    "start": "1853150",
    "end": "1860730"
  },
  {
    "text": "part of the signature which is used primarily for for revocation purposes",
    "start": "1860730",
    "end": "1866940"
  },
  {
    "text": "and the way this works is like every time someone signs something they also pick a random group element and they",
    "start": "1866940",
    "end": "1875190"
  },
  {
    "text": "create that random element and exponentiate it with the private key so here I'm putting F but that should have",
    "start": "1875190",
    "end": "1882490"
  },
  {
    "text": "been gamma so this gamma from the previous slide and and basically they",
    "start": "1882490",
    "end": "1891340"
  },
  {
    "text": "have the basic signature as well as these two group elements as part of each signature and based on this when when",
    "start": "1891340",
    "end": "1900070"
  },
  {
    "text": "the group manager wants to revoke someone someone's so if it has like a",
    "start": "1900070",
    "end": "1906280"
  },
  {
    "text": "signature based revocation so remember these are like group signatures where you have a single public key so you",
    "start": "1906280",
    "end": "1911800"
  },
  {
    "text": "cannot just put like the public key in the revocation list you have to do something other than that so one way to do that is",
    "start": "1911800",
    "end": "1919710"
  },
  {
    "text": "like is to do that with the private key which is the private key based revocation but the other way is to",
    "start": "1919710",
    "end": "1925260"
  },
  {
    "text": "basically do a signature based revocation where you suspect that this particular signature came from a",
    "start": "1925260",
    "end": "1930539"
  },
  {
    "text": "fraudulent signer and and the way you do that is essentially by by flagging these",
    "start": "1930539",
    "end": "1937950"
  },
  {
    "text": "values of B and K and putting it in the revocation lists and at the time of signing the signer needs to prove in",
    "start": "1937950",
    "end": "1945090"
  },
  {
    "text": "zero-knowledge that its value of F could not have come",
    "start": "1945090",
    "end": "1950309"
  },
  {
    "text": "from the list of all these pairs B 1 K 1 B 2 K 2 and so on and so forth so so so",
    "start": "1950309",
    "end": "1956970"
  },
  {
    "text": "once again because zero knowledge proof selectively powerful there you can prove any statement in NP you can prove things",
    "start": "1956970",
    "end": "1962549"
  },
  {
    "text": "like this and say very efficiently but you can prove them so these are two",
    "start": "1962549",
    "end": "1969480"
  },
  {
    "text": "kinds of signatures one key thing I want to mention here is that epital aoz",
    "start": "1969480",
    "end": "1975030"
  },
  {
    "text": "signature signatures to be linkable what that means is that if you wanted you can pick the same value of B for all the",
    "start": "1975030",
    "end": "1982320"
  },
  {
    "text": "signatures that you generate and this way you can tell the endpoint that all",
    "start": "1982320",
    "end": "1987630"
  },
  {
    "text": "these signatures are coming from the same endpoint so if it lets you have sort of like linkable signatures so I",
    "start": "1987630",
    "end": "1997530"
  },
  {
    "text": "already mentioned about the private key based revocation one strange thing about",
    "start": "1997530",
    "end": "2002929"
  },
  {
    "text": "the private key base revoke a revocation is that once your private key goes into the revocation list you retro actively",
    "start": "2002929",
    "end": "2008900"
  },
  {
    "text": "lose all anonymity because because f it is not have full anonymity okay so",
    "start": "2008900",
    "end": "2017659"
  },
  {
    "text": "that's about how apid signatures work so let's say I have a implementation of",
    "start": "2017659",
    "end": "2024409"
  },
  {
    "text": "epicness and but the question still remains how should a member be allowed",
    "start": "2024409",
    "end": "2030890"
  },
  {
    "text": "to join an epic group right so anyone can generate like a pet private key they",
    "start": "2030890",
    "end": "2036020"
  },
  {
    "text": "can submit it to a group manager they can get like potentials from the group manager but the crucial question at",
    "start": "2036020",
    "end": "2042110"
  },
  {
    "text": "least in case of SD x is how does this private key a member a CPU manages to convince Intel",
    "start": "2042110",
    "end": "2050090"
  },
  {
    "text": "at a station service that it's a valid STX hardware and the way Intel solves",
    "start": "2050090",
    "end": "2056450"
  },
  {
    "text": "this is by having a hardware key having a 128-bit random number inside the",
    "start": "2056450",
    "end": "2064370"
  },
  {
    "text": "hardware and they use this 128-bit random number in different ways so",
    "start": "2064370",
    "end": "2069919"
  },
  {
    "text": "basically they use it to encrypt things they use it to ECDSA sign things but",
    "start": "2069919",
    "end": "2074929"
  },
  {
    "text": "eventually that random number acts as the root of trust between the HDX CPU",
    "start": "2074929",
    "end": "2080060"
  },
  {
    "text": "and the Intel attestation service and based on this route of trust they bootstrap a new set of epic credentials",
    "start": "2080060",
    "end": "2086840"
  },
  {
    "text": "on each CPU and Intel calls this the epic provisioning Enclave the PvE and PC",
    "start": "2086840",
    "end": "2095260"
  },
  {
    "text": "once a platform has got the these epic credentials so so basically a processor",
    "start": "2095260",
    "end": "2101990"
  },
  {
    "text": "and Intel CPU comes up it generates the epic profit key submits the the epic",
    "start": "2101990",
    "end": "2107180"
  },
  {
    "text": "journey request to internet restoration surface gets the certification saves it on disk once it has all these",
    "start": "2107180",
    "end": "2112670"
  },
  {
    "text": "credentials on this it can now start generating a bit sick natures and so",
    "start": "2112670",
    "end": "2118160"
  },
  {
    "text": "what we call remote attestation is actually just that like computing epic matures on using these epic keys so this",
    "start": "2118160",
    "end": "2129140"
  },
  {
    "text": "is how Intel has implemented the whole PV it's a fairly complicated",
    "start": "2129140",
    "end": "2136240"
  },
  {
    "text": "implementation and it and seems to use a lot of crypto primitives so all the way",
    "start": "2136240",
    "end": "2142850"
  },
  {
    "text": "from way P and C Mac and and of course",
    "start": "2142850",
    "end": "2148970"
  },
  {
    "text": "the epidemic that and ECDSA and GCM so",
    "start": "2148970",
    "end": "2154010"
  },
  {
    "text": "it tends to compose a lot of cryptographic primitives in ways that I",
    "start": "2154010",
    "end": "2162260"
  },
  {
    "text": "had not expected actually and but in spite of that I think the the",
    "start": "2162260",
    "end": "2169250"
  },
  {
    "text": "whole PvE implementation is quite secure so but at a higher level this is how the",
    "start": "2169250",
    "end": "2177350"
  },
  {
    "text": "epitaphs evening works basically each from generates a platform provisioning ID and this platform provisioning ID is",
    "start": "2177350",
    "end": "2185510"
  },
  {
    "text": "based on the provisioning key so so the hardware 128-bit random number that the hardware has that acts as the",
    "start": "2185510",
    "end": "2192079"
  },
  {
    "text": "provisioning key and from that you derive provisioning ID unfortunately the",
    "start": "2192079",
    "end": "2198380"
  },
  {
    "text": "process of provisioning because this ID is always known both to Intel and to the CPU inter will always know when you are",
    "start": "2198380",
    "end": "2206299"
  },
  {
    "text": "joining their group and so this kind of destroys the anonymity during the join",
    "start": "2206299",
    "end": "2213859"
  },
  {
    "text": "process of course if it makes no guarantees about the anonymity of join so maybe this is not an issue but but",
    "start": "2213859",
    "end": "2221030"
  },
  {
    "text": "it's good to keep in mind because every time you delete this epic blob on your PC your your machine will actually go",
    "start": "2221030",
    "end": "2229250"
  },
  {
    "text": "and try to get these epic blobs from the other end point and Intel will know",
    "start": "2229250",
    "end": "2234740"
  },
  {
    "text": "about it the epic John process it basically uses ECDSA",
    "start": "2234740",
    "end": "2240230"
  },
  {
    "text": "signature using the hardware resident key to convince that the Intel attestation service to convince Internet",
    "start": "2240230",
    "end": "2248089"
  },
  {
    "text": "restoration service that it's a valid Hardware so the issue here is like only authentic CPUs should be able to join",
    "start": "2248089",
    "end": "2255380"
  },
  {
    "text": "SDX epic group if I who is not an STX processor if I can go and join the Intel",
    "start": "2255380",
    "end": "2262220"
  },
  {
    "text": "epic group I might start signing remote attestation randomly so and that will",
    "start": "2262220",
    "end": "2267920"
  },
  {
    "text": "destroy the entire ecosystem of remote attestation because you cannot correlate because you cannot correlate signatures",
    "start": "2267920",
    "end": "2275329"
  },
  {
    "text": "it will become really difficult to figure out whether I'm a genuine processor or whether I'm a rogue process",
    "start": "2275329",
    "end": "2281660"
  },
  {
    "text": "so this process is really crucial it has to be like very secure so in added",
    "start": "2281660",
    "end": "2288740"
  },
  {
    "text": "addition to like generating ECDSA signatures the epic journey quest is also encrypted using the provisioning",
    "start": "2288740",
    "end": "2295339"
  },
  {
    "text": "key the implication of this is that the Intel must the Intel attestation service",
    "start": "2295339",
    "end": "2300920"
  },
  {
    "text": "must have a database of these highly sensitive keys somewhere online and so",
    "start": "2300920",
    "end": "2308480"
  },
  {
    "text": "it's a good exercise to maybe try to hack that now I'm not and then do a",
    "start": "2308480",
    "end": "2313760"
  },
  {
    "text": "responsible disclosure and the third",
    "start": "2313760",
    "end": "2318890"
  },
  {
    "text": "strange thing about how intel has implemented the provisioning Enclave is that they encrypt the member private key",
    "start": "2318890",
    "end": "2325580"
  },
  {
    "text": "using a different key and upload it also to inter lattice station service so remember the join protocol in epital",
    "start": "2325580",
    "end": "2333370"
  },
  {
    "text": "fits it's blinded so it the the the group manager doesn't need to know the",
    "start": "2333370",
    "end": "2339560"
  },
  {
    "text": "private private key however in the implementation intel encrypts this private key and still uploads it to",
    "start": "2339560",
    "end": "2346480"
  },
  {
    "text": "interactive station services they claim that they don't know this key but I'm not sure what is the motivation for",
    "start": "2346480",
    "end": "2352280"
  },
  {
    "text": "doing this but at the end of the epitaphs inning process each each CPU",
    "start": "2352280",
    "end": "2358600"
  },
  {
    "text": "will basically get the group member membership credentials and it will also",
    "start": "2358600",
    "end": "2363860"
  },
  {
    "text": "get group ID so that's about how the",
    "start": "2363860",
    "end": "2368980"
  },
  {
    "text": "platform basically gets the epic credentials at this point the platform",
    "start": "2368980",
    "end": "2376400"
  },
  {
    "text": "can start signing things using these epic keys so so just to recap there is a hardware key with which we bootstrap the",
    "start": "2376400",
    "end": "2383390"
  },
  {
    "text": "PDS and now given the epic is now we can sign things using that f8 key and so to",
    "start": "2383390",
    "end": "2391760"
  },
  {
    "text": "do this once again enter has done some a couple of things which I think are strange the first thing you need to do",
    "start": "2391760",
    "end": "2398900"
  },
  {
    "text": "to make use of a pet signal is that the service provider so this one will be",
    "start": "2398900",
    "end": "2404030"
  },
  {
    "text": "like the client of cloud service or maybe someone who is supporting clients",
    "start": "2404030",
    "end": "2410330"
  },
  {
    "text": "of the cloud service you first need to go and sign up with Intel and you need",
    "start": "2410330",
    "end": "2415670"
  },
  {
    "text": "to give them your own x.509 certificate and and only after this basically the",
    "start": "2415670",
    "end": "2424100"
  },
  {
    "text": "service provider can sorry I have a mistake in the slide there should have",
    "start": "2424100",
    "end": "2429350"
  },
  {
    "text": "been an arrow coming from sp2 Enclave as the first step so the service provider",
    "start": "2429350",
    "end": "2434360"
  },
  {
    "text": "first gives its service provider ID to the Enclave the Enclave whatever state",
    "start": "2434360",
    "end": "2440030"
  },
  {
    "text": "it wants to compute the remote attestation on it first compute a local attestation on that and and then",
    "start": "2440030",
    "end": "2447380"
  },
  {
    "text": "it transferred that transfers that local attestation to the coating Enclave and",
    "start": "2447380",
    "end": "2453310"
  },
  {
    "text": "and it also sends the service provider ID and the nonce the nonce is the nonce",
    "start": "2453310",
    "end": "2460820"
  },
  {
    "text": "has to be sent to make sure that the coating Enclave is actually running on the same processor so there are",
    "start": "2460820",
    "end": "2467840"
  },
  {
    "text": "scenarios in which the ante if the someone has compromised one coating Enclave and if you don't send this nonce",
    "start": "2467840",
    "end": "2474440"
  },
  {
    "text": "you might be able to take that local attestation to that platform get a",
    "start": "2474440",
    "end": "2480410"
  },
  {
    "text": "signature appids igniter from that platform and no one will be able to figure it out that's the beauty of",
    "start": "2480410",
    "end": "2485900"
  },
  {
    "text": "anonymity so so so the Enclave sends the",
    "start": "2485900",
    "end": "2491000"
  },
  {
    "text": "local attestation to the coating Enclave along with the service provider ID the",
    "start": "2491000",
    "end": "2496130"
  },
  {
    "text": "coating Enclave basically validates the local attestation and then using the",
    "start": "2496130",
    "end": "2502660"
  },
  {
    "text": "epidote key it will create an epic nature on the identity of the Enclave so",
    "start": "2502660",
    "end": "2508610"
  },
  {
    "text": "so the identity of the antigen is basically the mystery Enclave and the mr. signer and the attributes and these",
    "start": "2508610",
    "end": "2515060"
  },
  {
    "text": "things that Intel has defined and and these things come from the actual",
    "start": "2515060",
    "end": "2520850"
  },
  {
    "text": "hardware so you cannot spoof these things in the local attestation now the",
    "start": "2520850",
    "end": "2526130"
  },
  {
    "text": "strange thing about about the coating Enclave however is that it does not give you the raw signature the raw appids",
    "start": "2526130",
    "end": "2532820"
  },
  {
    "text": "signature instead it encrypts that raw signature with an authenticated public",
    "start": "2532820",
    "end": "2538070"
  },
  {
    "text": "key and that public the private key of that public key is only known to Intel",
    "start": "2538070",
    "end": "2543500"
  },
  {
    "text": "attestation service so even if you have liked the group public key with you you cannot locally validate a paid sick",
    "start": "2543500",
    "end": "2549350"
  },
  {
    "text": "matures and so once you get these encrypted epic matures you have to",
    "start": "2549350",
    "end": "2554660"
  },
  {
    "text": "actually go back to Intel attestation service and get in yes or no from Intel",
    "start": "2554660",
    "end": "2559910"
  },
  {
    "text": "I find this problematic because if Intel wanted to do a man-in-the-middle attack",
    "start": "2559910",
    "end": "2565040"
  },
  {
    "text": "on on one of these enclaves it could actually always respond by saying yes to",
    "start": "2565040",
    "end": "2572750"
  },
  {
    "text": "the to these messages so even though the signature is invalid it also say that this Enclave is good go",
    "start": "2572750",
    "end": "2579970"
  },
  {
    "text": "ahead and this way they might be able to put like a intermediary Enclave in the in the middle which does the man in the",
    "start": "2579970",
    "end": "2586509"
  },
  {
    "text": "middle but this is how they have kind of implemented so so basically to summarize",
    "start": "2586509",
    "end": "2595630"
  },
  {
    "text": "the talk the both the provisioning",
    "start": "2595630",
    "end": "2600670"
  },
  {
    "text": "Enclave all the provisioning enclaves and the quoting enclaves these are securely implemented and they are",
    "start": "2600670",
    "end": "2607119"
  },
  {
    "text": "securely implemented in the sense of sequential composition as well as like concurrent composition I haven't fully",
    "start": "2607119",
    "end": "2613930"
  },
  {
    "text": "analyzed the concurrent zero knowledge that goes in the join protocol but since it's encrypted",
    "start": "2613930",
    "end": "2618970"
  },
  {
    "text": "you cannot arbitrarily interleave these join messages and you cannot you will",
    "start": "2618970",
    "end": "2624220"
  },
  {
    "text": "not probably have the problems that people typically run into with concurring zero however there is like a",
    "start": "2624220",
    "end": "2631059"
  },
  {
    "text": "lots of unnecessary crypto so so the Enclave encrypt something and then the host side also encrypts it and it",
    "start": "2631059",
    "end": "2637450"
  },
  {
    "text": "derives keys in some strange ways so it will take the public key hash it then hash it with some more random numbers",
    "start": "2637450",
    "end": "2644710"
  },
  {
    "text": "and things like that so sometimes the goal is not clear why why they are doing this the second conclusion I would say",
    "start": "2644710",
    "end": "2653829"
  },
  {
    "text": "that there is no privacy in spite of the group signatures and the reason is that since the signatures are encrypted",
    "start": "2653829",
    "end": "2661380"
  },
  {
    "text": "whenever Intel is kind of decrypting it and validating that signature it knows",
    "start": "2661380",
    "end": "2667630"
  },
  {
    "text": "the service provider so there is privacy in terms of the privacy of the processor",
    "start": "2667630",
    "end": "2672970"
  },
  {
    "text": "but there is no privacy in terms of the service provider so every time you do a remote attestation basically until we",
    "start": "2672970",
    "end": "2680440"
  },
  {
    "text": "know that you are talking to an STX processor and the other issue is that",
    "start": "2680440",
    "end": "2685720"
  },
  {
    "text": "this can be used for doing a man-in-the-middle attack especially if Intel as a company is compelled to do",
    "start": "2685720",
    "end": "2691900"
  },
  {
    "text": "that so that's kind of the end of my talk so I'm almost on time five minutes",
    "start": "2691900",
    "end": "2697839"
  },
  {
    "text": "ahead so happy to take any questions [Applause]",
    "start": "2697839",
    "end": "2702930"
  },
  {
    "text": "[Music] [Applause]",
    "start": "2702930",
    "end": "2709319"
  },
  {
    "text": "um I was just wondering for the first set of problems that you discussed now I",
    "start": "2713110",
    "end": "2718970"
  },
  {
    "text": "don't know whether there's a way for Intel to get there from here but if everything that changed the state",
    "start": "2718970",
    "end": "2726200"
  },
  {
    "text": "with any time state changed within the Enclave if the Enclave returned some some in a",
    "start": "2726200",
    "end": "2735410"
  },
  {
    "text": "sense new attestation of the state right so there is some work on like dynamic",
    "start": "2735410",
    "end": "2740900"
  },
  {
    "text": "attestation schemes and they might be more effective however I think the user",
    "start": "2740900",
    "end": "2747200"
  },
  {
    "text": "still has to analyze the whole Enclave has like a single protocol because like",
    "start": "2747200",
    "end": "2752300"
  },
  {
    "text": "in the dumbest thing doc dumbest scheme you can just take like the private keys",
    "start": "2752300",
    "end": "2757490"
  },
  {
    "text": "inside the Enclave and just put it outside and that will completely so no",
    "start": "2757490",
    "end": "2763580"
  },
  {
    "text": "scheme can protect against these kinds of things but there are like basically",
    "start": "2763580",
    "end": "2769400"
  },
  {
    "text": "dynamic attestation schemes which might be better suited for this kind of thing thank you there's really interesting",
    "start": "2769400",
    "end": "2777520"
  },
  {
    "text": "so one quick question you said something about that the enclaves don't support",
    "start": "2782310",
    "end": "2787980"
  },
  {
    "text": "replay production have you looked at the platform services Enclave and the",
    "start": "2787980",
    "end": "2793329"
  },
  {
    "text": "monotonic counter support that it has right so the monotonic counter that Intel has",
    "start": "2793329",
    "end": "2798880"
  },
  {
    "text": "it's fast it's coming from a TPM which is encrypted using Intel ME and given",
    "start": "2798880",
    "end": "2805750"
  },
  {
    "text": "the history with Intel Emmy I think people are better off putting their own TPM and building their own protocols",
    "start": "2805750",
    "end": "2811240"
  },
  {
    "text": "instead of using Intel Emmy but it's not like inherently part of the SGX itself",
    "start": "2811240",
    "end": "2817180"
  },
  {
    "text": "it's coming once again from TPM yeah",
    "start": "2817180",
    "end": "2823859"
  },
  {
    "text": "this is kind of maybe not relevant to the crypto but do you think it's likely",
    "start": "2823859",
    "end": "2829030"
  },
  {
    "text": "that they take that signing the group",
    "start": "2829030",
    "end": "2834579"
  },
  {
    "text": "signature out of the out of the specifications of the coding archives so",
    "start": "2834579",
    "end": "2840280"
  },
  {
    "text": "that later we can independently verify signatures right so the issue there is like so basically the root of trust that",
    "start": "2840280",
    "end": "2849280"
  },
  {
    "text": "is there which is known between Intel and so this root of trust which is a key",
    "start": "2849280",
    "end": "2858130"
  },
  {
    "text": "in the hardware and known to the Intel somehow a third party will have to know",
    "start": "2858130",
    "end": "2863950"
  },
  {
    "text": "about this if people want to bootstrap their own security however one possible",
    "start": "2863950",
    "end": "2869770"
  },
  {
    "text": "scenario is that you do all of this but then you use one time a pet signature to",
    "start": "2869770",
    "end": "2875470"
  },
  {
    "text": "validate all this and then you bootstrap from the opit signature a whole new set of credentials so that's completely",
    "start": "2875470",
    "end": "2880690"
  },
  {
    "text": "possible sorry I think I wasn't clear I wasn't talking about the join protocol just remote attestation because there if",
    "start": "2880690",
    "end": "2889300"
  },
  {
    "text": "if they had a good implementation of epoch you should have been able to do",
    "start": "2889300",
    "end": "2895240"
  },
  {
    "text": "attestation yourself just having the group public key right so is it possible that they're just being cautious in this",
    "start": "2895240",
    "end": "2901569"
  },
  {
    "text": "first release and later they build that's entirely possible I'm also not sure like why you'd want to",
    "start": "2901569",
    "end": "2909609"
  },
  {
    "text": "like encrypt group like a signature like so signatures by definition one should be one should be",
    "start": "2909609",
    "end": "2917540"
  },
  {
    "text": "able to verify these signatures using a public key so the moment you encrypt a signature it's no longer a signature",
    "start": "2917540",
    "end": "2923300"
  },
  {
    "text": "scheme it's something else right so so I can overall take away be",
    "start": "2923300",
    "end": "2929600"
  },
  {
    "text": "that appetit it is pretty much a good protocol apart from some unnecessary",
    "start": "2929600",
    "end": "2934870"
  },
  {
    "text": "complexity but they have a much inferior implementation of it so a petard says",
    "start": "2934870",
    "end": "2941980"
  },
  {
    "text": "secure other efficiency while it's it's still very heavyweight so you have like",
    "start": "2941980",
    "end": "2950840"
  },
  {
    "text": "lots of so basically it uses pairings so you have to learn miller's algorithm multiple times and then you have to",
    "start": "2950840",
    "end": "2957470"
  },
  {
    "text": "prove like non equality of discrete locks and so the zero knowledge proof of",
    "start": "2957470",
    "end": "2963110"
  },
  {
    "text": "that so for each element in your revocation list you have to do multiple exponentiations and things like that so",
    "start": "2963110",
    "end": "2970220"
  },
  {
    "text": "because of that it's really computationally intensive however it's secure so there is like good proofs in",
    "start": "2970220",
    "end": "2977360"
  },
  {
    "text": "in the paper that it's it's secure so this is very interesting research thank",
    "start": "2977360",
    "end": "2983780"
  },
  {
    "text": "you yeah has Intel had a response to this was there no so I've been traveling",
    "start": "2983780",
    "end": "2990920"
  },
  {
    "text": "I just came back from vacation so it'll be interesting",
    "start": "2990920",
    "end": "2996460"
  },
  {
    "text": "all right so I think we are out of time",
    "start": "2997810",
    "end": "3002040"
  },
  {
    "text": "[Applause]",
    "start": "3009650",
    "end": "3011909"
  }
]