[
  {
    "start": "0",
    "end": "55000"
  },
  {
    "text": "hello and welcome to our talk Armageddon how your smartphone CPU breaks off the level security and privacy in the",
    "start": "30",
    "end": "8099"
  },
  {
    "text": "beginning I want to say that if you have a so safe software infrastructure meaning that your code has no back this",
    "start": "8099",
    "end": "14610"
  },
  {
    "text": "does not mean that the execution will be safe because the hardware where the software runs on may leak information",
    "start": "14610",
    "end": "20160"
  },
  {
    "text": "and today we want to focus on the CPU cache because maybe you've seen in the",
    "start": "20160",
    "end": "25890"
  },
  {
    "text": "past that cache attacks can be used for covered communication and to attack rip",
    "start": "25890",
    "end": "30900"
  },
  {
    "text": "two implementations however they have only been demonstrated on intellect 86 or now and as mobile devices like",
    "start": "30900",
    "end": "39180"
  },
  {
    "text": "smartphones and tablets have become the most important personal computing device in the past and despite the fact that",
    "start": "39180",
    "end": "45629"
  },
  {
    "text": "people thought that those that X cannot be applied on mobile devices we wanted to investigate why they don't work on",
    "start": "45629",
    "end": "52770"
  },
  {
    "text": "arm and if we can do something about that but before that I want to introduce",
    "start": "52770",
    "end": "57960"
  },
  {
    "start": "55000",
    "end": "175000"
  },
  {
    "text": "myself my name is Moe it's lip I'm from cut University of Technology and I'm a",
    "start": "57960",
    "end": "63210"
  },
  {
    "text": "master student and I've just finished my master thesis if you want you can reach me on Twitter writing an email or just",
    "start": "63210",
    "end": "69540"
  },
  {
    "text": "come and talk to me later on and my name is Clemens in movies I",
    "start": "69540",
    "end": "75150"
  },
  {
    "text": "finished my PhD last year and I'm now post doc at class University of Technology you can also",
    "start": "75150",
    "end": "81259"
  },
  {
    "text": "reach me on Twitter or by email or even later the rest of the research team is",
    "start": "81259",
    "end": "87900"
  },
  {
    "text": "composed of Daniel who's half age type sir and stefan monk out and we are all from class University of Technology and",
    "start": "87900",
    "end": "95360"
  },
  {
    "text": "before we delve into the details we are going to show you a quick demo",
    "start": "95360",
    "end": "102259"
  },
  {
    "text": "so on left you should see the screen of this galaxy s6 and",
    "start": "105890",
    "end": "114380"
  },
  {
    "text": "we have just started up the messenger app and on the right side we have a",
    "start": "114500",
    "end": "119579"
  },
  {
    "text": "terminal and we will start our spy tool and now Clementine will type something",
    "start": "119579",
    "end": "126000"
  },
  {
    "text": "into the smartphone and as you can see on the right whenever she",
    "start": "126000",
    "end": "131009"
  },
  {
    "text": "presses and character our spy tool catches that and also if she presses the",
    "start": "131009",
    "end": "136740"
  },
  {
    "text": "spacebar we see that on the right and at some point if she may decide that she",
    "start": "136740",
    "end": "142380"
  },
  {
    "text": "wants to delete the word or a character we can also spy on that so because of",
    "start": "142380",
    "end": "147810"
  },
  {
    "text": "that we can derive the words at length of the word she types and spy on the",
    "start": "147810",
    "end": "153390"
  },
  {
    "text": "user and we will now show you how this is done and as we said this is no software pack",
    "start": "153390",
    "end": "161640"
  },
  {
    "text": "it's just because of the hardware so for the rest of our talk we first",
    "start": "161640",
    "end": "169110"
  },
  {
    "text": "give you some background information about CPU caches and about the CPU architecture on intellect 86 as well as",
    "start": "169110",
    "end": "175260"
  },
  {
    "text": "on arm then we will discuss the challenges why those attacks are so hard to can be mounted alarm and then we will",
    "start": "175260",
    "end": "183600"
  },
  {
    "text": "show you how you can solve those challenges then we will demonstrate you some attack scenarios what you can do",
    "start": "183600",
    "end": "189900"
  },
  {
    "text": "with those attacks besides the demo and in the end we will give you all the tools that we've developed to mount such",
    "start": "189900",
    "end": "196500"
  },
  {
    "text": "attacks and Clementine is going to tell you now about cache attacks in general yeah so",
    "start": "196500",
    "end": "204150"
  },
  {
    "text": "as you may know we have a memory hierarchy that is composed of CPU",
    "start": "204150",
    "end": "209459"
  },
  {
    "text": "registers different levels of sip of the CPU cache the main memory which is the",
    "start": "209459",
    "end": "215430"
  },
  {
    "text": "DRAM and the disks or storage and we have different timings depending on",
    "start": "215430",
    "end": "221010"
  },
  {
    "text": "where data reside on and this is precisely what we are going to exploit in cache attacks and in particular the",
    "start": "221010",
    "end": "226950"
  },
  {
    "text": "difference of timing between data in the cache and in the main memory so if data",
    "start": "226950",
    "end": "232260"
  },
  {
    "text": "resides in the cache and the access is going to be fast we call that a cache hit and if data is not in the cache then",
    "start": "232260",
    "end": "239400"
  },
  {
    "text": "we have to retrieve it from the main memory and it's slow and we call that a cache miss",
    "start": "239400",
    "end": "244489"
  },
  {
    "text": "now you can clearly see that we have we can see the difference between cache",
    "start": "244489",
    "end": "249690"
  },
  {
    "text": "hits here and cache misses here and this is basically what we always talk to do when we not a cache attack we time the",
    "start": "249690",
    "end": "257579"
  },
  {
    "text": "cache hit and the cache misses and then we can have some threshold because we know that we will never have any cache",
    "start": "257579",
    "end": "263940"
  },
  {
    "text": "miss below as 700 CPU cycles and then just by measuring the time an access",
    "start": "263940",
    "end": "270440"
  },
  {
    "text": "take we can say it's a cache hit or it's a cache miss so we also need for this cache attacks",
    "start": "270440",
    "end": "278270"
  },
  {
    "text": "to know precisely how the CPU cache work for um and Inter CPU we have set",
    "start": "278270",
    "end": "284060"
  },
  {
    "text": "associative caches so we have data that is loaded in a specific set and that depends on some",
    "start": "284060",
    "end": "290600"
  },
  {
    "text": "bits of the address so this is a cache set here then we have several ways per set so",
    "start": "290600",
    "end": "298690"
  },
  {
    "text": "this is one way here we have four ways and a cache line is loading in a",
    "start": "298690",
    "end": "304610"
  },
  {
    "text": "specific way depending on the replacement policy of the CPU because usually when at the CPU loads a cache",
    "start": "304610",
    "end": "310580"
  },
  {
    "text": "line into the cache it has to evict a previous line to make someone fog to make some room for the new cache line so",
    "start": "310580",
    "end": "317510"
  },
  {
    "text": "the cache line is here for example and this is the smallest unit we are going to talk about so now on to cache attacks",
    "start": "317510",
    "end": "326000"
  },
  {
    "text": "we have different types of Cascia text and the first one is called flush and we load and here what's really important is",
    "start": "326000",
    "end": "332449"
  },
  {
    "text": "that we have some shared memory between the attacker and the victim so here that can be for example a shared library so",
    "start": "332449",
    "end": "339590"
  },
  {
    "text": "the etiquette starts by mapping this shared library and data that is shared in the memory is",
    "start": "339590",
    "end": "346099"
  },
  {
    "text": "going to be shared in the cache so if data if the cache Ram is in the cache it's in the cache for both the attacker",
    "start": "346099",
    "end": "351919"
  },
  {
    "text": "and the victim so what the attacker now is going to do is the attacker is going to flush this shared cache line and so",
    "start": "351919",
    "end": "359449"
  },
  {
    "text": "that it's neither in the cache for the attacker and the victim and then he's going to let the victim",
    "start": "359449",
    "end": "365530"
  },
  {
    "text": "perform for example encryption that data come out to spy on and then the CPU will",
    "start": "365530",
    "end": "371900"
  },
  {
    "text": "automatically reload some data now the attacker wants to know if this particular cache line was accessed by",
    "start": "371900",
    "end": "378590"
  },
  {
    "text": "the victim so the attacker then we lost the data and measure the time it takes and by measuring the time it takes you",
    "start": "378590",
    "end": "384979"
  },
  {
    "text": "can know if it's in the CPU cache which means that the victim did access this particular cache line and if it was not",
    "start": "384979",
    "end": "391520"
  },
  {
    "text": "in the cache then the victim did not access so this attack is actually quite powerful because the attacker can know",
    "start": "391520",
    "end": "397070"
  },
  {
    "text": "if the victim accessed one particular cache line which is usually around 64 bytes",
    "start": "397070",
    "end": "403600"
  },
  {
    "text": "so this was the case in which we had some kind of shared memory if we don't",
    "start": "403600",
    "end": "409220"
  },
  {
    "text": "have any kind of shall memory we can use Fram in probe so here the attacker is going to start",
    "start": "409220",
    "end": "414980"
  },
  {
    "text": "by filling the cache and then again let's the victim perform for",
    "start": "414980",
    "end": "420020"
  },
  {
    "text": "example encryption and again the victim is going and the CPU is going to automatically load data and this is",
    "start": "420020",
    "end": "426350"
  },
  {
    "text": "going to evict some of the line of the attacker so here and the victim evicted 1/9 of the attacker then another line",
    "start": "426350",
    "end": "433430"
  },
  {
    "text": "and now the attacker wants to know if the victim access this particular",
    "start": "433430",
    "end": "438970"
  },
  {
    "text": "cache set and the attacker won't know which particular cache line but you can know if add the attacker exceed the",
    "start": "438970",
    "end": "446000"
  },
  {
    "text": "victim access this kashyap so is going to prototype previously put in the cache so here on the first time that's a fast",
    "start": "446000",
    "end": "453920"
  },
  {
    "text": "access because they died still in the cache and on the second line is a slow axis because the victim has a",
    "start": "453920",
    "end": "462669"
  },
  {
    "text": "evicted one cache line of the article so the attacker now knows that ok the",
    "start": "462669",
    "end": "467690"
  },
  {
    "text": "victim access some cache line that reside in this precise cache set and now what it is going to tell you about",
    "start": "467690",
    "end": "474350"
  },
  {
    "text": "the differences between Intel x86 and arm so the first thing we need we need",
    "start": "474350",
    "end": "479360"
  },
  {
    "text": "to be capable and find a way to remove an address out of the cache to the main memory and for this we need to",
    "start": "479360",
    "end": "485570"
  },
  {
    "text": "invalidate the cache line and we have to cache maintenance instructions available",
    "start": "485570",
    "end": "491020"
  },
  {
    "start": "490000",
    "end": "608000"
  },
  {
    "text": "which do that for us and on intellect 86 you may know the unprivileged CL flash",
    "start": "491020",
    "end": "497210"
  },
  {
    "text": "instruction which you can use to perform this task on the other hand on army 7",
    "start": "497210",
    "end": "502520"
  },
  {
    "text": "while we have such cache maintenance instructions we can't use them because they are privileged and they need a",
    "start": "502520",
    "end": "508130"
  },
  {
    "text": "kernel module to be unlocked for users based and this is not the case normally in addition on arm v8 we have also",
    "start": "508130",
    "end": "515990"
  },
  {
    "text": "privileged instructions but four of them can be unlocked to user space entirely",
    "start": "515990",
    "end": "521710"
  },
  {
    "text": "and the first big challenge there is that we have no flash instruction",
    "start": "521710",
    "end": "526880"
  },
  {
    "text": "available on arm that we can use without any privileges so the easiest thing which comes to mind",
    "start": "526880",
    "end": "534060"
  },
  {
    "text": "is we just fill the whole cache with different data then we are going to evict our target address and we are fine",
    "start": "534060",
    "end": "539250"
  },
  {
    "text": "however this is way too slow so we can't rely on that we can improve on that by",
    "start": "539250",
    "end": "545580"
  },
  {
    "text": "just filling a specific hash set and as you can see in this illustration the",
    "start": "545580",
    "end": "550920"
  },
  {
    "text": "green block is the address you want to evict and we just start accessing as many addresses which map to the same",
    "start": "550920",
    "end": "557520"
  },
  {
    "text": "cache set as we have ways so at one point we're going to evicted our gate",
    "start": "557520",
    "end": "562860"
  },
  {
    "text": "address sounds easy it is easy but it's only the ideal case if we have a least",
    "start": "562860",
    "end": "569100"
  },
  {
    "text": "recently used replacement policy on the cache active but in real life we don't",
    "start": "569100",
    "end": "576120"
  },
  {
    "text": "have that because we have absurd a random replacement policy and when we do the same thing again just add accessing",
    "start": "576120",
    "end": "583709"
  },
  {
    "text": "addresses it may happen that we just evict the address we have just loaded into the cache so in the end our target",
    "start": "583709",
    "end": "590670"
  },
  {
    "text": "address will still remain in the cache and so this approach is also highly inefficient so the second challenge is",
    "start": "590670",
    "end": "598260"
  },
  {
    "text": "that we have to take care of the pseudo-random replacement policy to find a nice way to evict the address still",
    "start": "598260",
    "end": "604920"
  },
  {
    "text": "out of the cache in a fast way the second thing that we need to mount",
    "start": "604920",
    "end": "610380"
  },
  {
    "start": "608000",
    "end": "819000"
  },
  {
    "text": "such cache attacks is we need to be able to measure the time it needs to take to",
    "start": "610380",
    "end": "615630"
  },
  {
    "text": "load the address and on intellect 86 we have the RDS see instruction which is",
    "start": "615630",
    "end": "621089"
  },
  {
    "text": "also unprivileged while we can access the cycle count on arm as well we can only do that in",
    "start": "621089",
    "end": "627270"
  },
  {
    "text": "privileged mode so this is not easily",
    "start": "627270",
    "end": "632430"
  },
  {
    "text": "done in a non rooted device and all the previous attacks that have been",
    "start": "632430",
    "end": "637589"
  },
  {
    "text": "published require root access on the device so they are not very practical so the third challenge that we have is",
    "start": "637589",
    "end": "644579"
  },
  {
    "text": "that we need to find unprivileged timing sources which are as accurate as we can as we need to distinguish between a",
    "start": "644579",
    "end": "652800"
  },
  {
    "text": "cache it and the cache miss so beside cache maintenance and timing",
    "start": "652800",
    "end": "659700"
  },
  {
    "text": "we also have the cache hierarchy that is quite different on our main on Intel CPUs so this is for Intel CPUs at the",
    "start": "659700",
    "end": "666470"
  },
  {
    "text": "modern Intel CPUs so we have usually three levels of caches 11 1 and level 2",
    "start": "666470",
    "end": "671990"
  },
  {
    "text": "I private to each car and we have the last level cache that is level 3 and this one and it's also inclusive which",
    "start": "671990",
    "end": "680089"
  },
  {
    "text": "means that everything that is on level 1 and level 2 will also be in this last",
    "start": "680089",
    "end": "685490"
  },
  {
    "text": "level cache and in that also means that a shell memory that is shared in Shannon",
    "start": "685490",
    "end": "691370"
  },
  {
    "text": "with is shared in the cache across all cost so we have no restriction on where and the Spy is",
    "start": "691370",
    "end": "698290"
  },
  {
    "text": "with respect to the victim so the victim might pin cos 0 and the attacker can be on post ring it will not be a problem",
    "start": "698290",
    "end": "705200"
  },
  {
    "text": "thanks to this inclusive property now on ARM Cortex a cpu we have two",
    "start": "705200",
    "end": "713060"
  },
  {
    "text": "levels of caches now level 1 is still private and level 2 is shared but this",
    "start": "713060",
    "end": "718520"
  },
  {
    "text": "time it is not inclusive and that means that shared memory that is not in level 2 is not shared in the cache and that",
    "start": "718520",
    "end": "726190"
  },
  {
    "text": "people thought that it was basically the biggest obstacle to performing cross core",
    "start": "726190",
    "end": "731980"
  },
  {
    "text": "cache attacks on arm so that's our first channel we have non included caches",
    "start": "731980",
    "end": "738970"
  },
  {
    "text": "then we have the cache hierarchy on arm pick little and here we have not only",
    "start": "738970",
    "end": "744470"
  },
  {
    "text": "one CPUs but two multiple CPUs and the input interconnected by this calling and",
    "start": "744470",
    "end": "750760"
  },
  {
    "text": "we have the level 2 cache that is shared across core but only of one CPUs so we",
    "start": "750760",
    "end": "758330"
  },
  {
    "text": "have CPUs that do not share a cache and once again we would like to have no restriction on where the attacker is",
    "start": "758330",
    "end": "764720"
  },
  {
    "text": "with respect to the victim and this is our first challenge we have no",
    "start": "764720",
    "end": "770660"
  },
  {
    "text": "shared cache between these CPUs so let's solve these",
    "start": "770660",
    "end": "777529"
  },
  {
    "text": "challenges we have those five challenges so now flush instruction obscure random",
    "start": "777529",
    "end": "782959"
  },
  {
    "text": "replacement policy no unprivileged timing non-inclusive caches and no shell cash so I'll start with the first one no",
    "start": "782959",
    "end": "790850"
  },
  {
    "text": "flash instruction so the idea is quite simple we are going to replace this missing flash instruction with cash",
    "start": "790850",
    "end": "796100"
  },
  {
    "text": "eviction that actually works well on a intel x86 because we have brahmin probe that i",
    "start": "796100",
    "end": "802529"
  },
  {
    "text": "showed you at the beginning this one does not need any flash instruction and if we have some kind of shell memory but",
    "start": "802529",
    "end": "809130"
  },
  {
    "text": "no flash instruction we can perform a variant of flash envelope that is called Ava can reload so challenge one done or",
    "start": "809130",
    "end": "817670"
  },
  {
    "text": "is it well actually no it's not done yet because addiction can be slow and",
    "start": "817670",
    "end": "824279"
  },
  {
    "start": "819000",
    "end": "913000"
  },
  {
    "text": "unreliable unless you know how to properly Big Data and this is kind of",
    "start": "824279",
    "end": "829709"
  },
  {
    "text": "our thing in the group we're really good at editing data from the cache and that was in fact the central idea of all row",
    "start": "829709",
    "end": "836070"
  },
  {
    "text": "homogeneous paper so if you recall rahama you access the theorem in some",
    "start": "836070",
    "end": "841410"
  },
  {
    "text": "kind of patterns and then you're going to have a bit flip in one location that you never accessed so you need to reach",
    "start": "841410",
    "end": "849510"
  },
  {
    "text": "the theorem and bypass the cache to do that and we also did that on JavaScript where you do not have any flash",
    "start": "849510",
    "end": "855720"
  },
  {
    "text": "instructions so we're going to use the same kind of techniques that we did for this one",
    "start": "855720",
    "end": "861079"
  },
  {
    "text": "which leads me to my to the second challenge this pseudo random replacement policy because evicting the cache would",
    "start": "861079",
    "end": "868620"
  },
  {
    "text": "be really easy if it was not for this one because the cache on to be discarded is chosen to the randomly",
    "start": "868620",
    "end": "875000"
  },
  {
    "text": "so what we did on kind of all Intel CPUs was accessing",
    "start": "875000",
    "end": "881240"
  },
  {
    "text": "only ones and addresses in an N way cache sets such as mobis showed you",
    "start": "881240",
    "end": "887190"
  },
  {
    "text": "earlier but because of the pillar random replacement policy this is really slow and unreliable so what we are going to",
    "start": "887190",
    "end": "894300"
  },
  {
    "text": "do is we are going to access addresses that fills in to the same cache set not only once but several times and with",
    "start": "894300",
    "end": "901380"
  },
  {
    "text": "different access patterns and the replacement policy is supposed to be pseudo-random so we should not be able",
    "start": "901380",
    "end": "907829"
  },
  {
    "text": "to really influence anything but as we're going to see it actually works really well",
    "start": "907829",
    "end": "913339"
  },
  {
    "start": "913000",
    "end": "1060000"
  },
  {
    "text": "so this is the kind of numbers that we can have with the Alcatel OneTouch pop",
    "start": "913339",
    "end": "918360"
  },
  {
    "text": "too so if we access 48 addresses that fit into the same cache set we access",
    "start": "918360",
    "end": "924630"
  },
  {
    "text": "them one by one it takes six thousand cycles which is quite fast but the",
    "start": "924630",
    "end": "929699"
  },
  {
    "text": "eviction rate is really bad the eviction rate is basically how the",
    "start": "929699",
    "end": "937319"
  },
  {
    "text": "sorry if the line that we wanted to evict has",
    "start": "937319",
    "end": "944529"
  },
  {
    "text": "actually been evicted so here it's actually been evicted in 70% of the cases",
    "start": "944529",
    "end": "949649"
  },
  {
    "text": "which is really bad we want something better than that so if we access more addresses then the eviction rate goes up",
    "start": "949649",
    "end": "956470"
  },
  {
    "text": "we have 96 percent eviction rates and it now is quite slow we have",
    "start": "956470",
    "end": "962879"
  },
  {
    "text": "33,000 cycles so we can access even more addresses let's say 800 ad eviction rate",
    "start": "962879",
    "end": "969129"
  },
  {
    "text": "is no good 99 point 10 percents but it's really really way too slow 1",
    "start": "969129",
    "end": "975029"
  },
  {
    "text": "142,000 cycles so we are going to access these addresses multiple times and now",
    "start": "975029",
    "end": "981310"
  },
  {
    "text": "is only 21 addresses that we access 96 times we have an eviction rate of ninety",
    "start": "981310",
    "end": "987910"
  },
  {
    "text": "nine point ninety three percent and it only takes four thousand cycles we can",
    "start": "987910",
    "end": "993189"
  },
  {
    "text": "even do a little bit better with 22 addresses even a bit more accesses with",
    "start": "993189",
    "end": "999009"
  },
  {
    "text": "an eviction rate of 99.99 percent I takes five thousand cycles and with",
    "start": "999009",
    "end": "1004410"
  },
  {
    "text": "twenty three addresses then we have an addiction rate that is perfect we measure on 100% and it took six thousand",
    "start": "1004410",
    "end": "1010920"
  },
  {
    "text": "cycles so this is really good and even the timing is better than the first one we had a very bad eviction rate so now",
    "start": "1010920",
    "end": "1018089"
  },
  {
    "text": "I'm pretty sure that it sounded all voodoo we have different addresses we access them multiple times this is the",
    "start": "1018089",
    "end": "1024209"
  },
  {
    "text": "kind of thing that we started to do manually with roham areas but it's really a pain to do so we fully",
    "start": "1024209",
    "end": "1030329"
  },
  {
    "text": "automated this process the idea is that we are going to generate a lot of eviction strategies",
    "start": "1030329",
    "end": "1036380"
  },
  {
    "text": "executive on the target device and then we have a lot of log files and we are",
    "start": "1036380",
    "end": "1041520"
  },
  {
    "text": "going to build a database to be able to compare this eviction strategies so as",
    "start": "1041520",
    "end": "1046829"
  },
  {
    "text": "the eviction strategies usually depend on the device because the cash characteristic are going to change from",
    "start": "1046829",
    "end": "1052559"
  },
  {
    "text": "one device to the other we can find with these methods a fast an addiction efficient eviction strategies for any",
    "start": "1052559",
    "end": "1059669"
  },
  {
    "text": "device and this is the kind of thing that we can now obtain with this eviction strategy so if you have some",
    "start": "1059669",
    "end": "1066690"
  },
  {
    "start": "1060000",
    "end": "1156000"
  },
  {
    "text": "kind of shell memory but no flush instruction you can use evict and reload with these eviction strategies and as",
    "start": "1066690",
    "end": "1072960"
  },
  {
    "text": "you can see we can really distinguish between the victim access and no victim access so we can have a threshold then",
    "start": "1072960",
    "end": "1079980"
  },
  {
    "text": "this is with the kind of traffic you want to have now for priming probe if you do not have",
    "start": "1079980",
    "end": "1085830"
  },
  {
    "text": "any kind of shell memory you have a bit more noise but you can still see this peak and if you put a threshold just",
    "start": "1085830",
    "end": "1093750"
  },
  {
    "text": "after this peak you can say that roughly everything that is below this is no victim access everything that is after",
    "start": "1093750",
    "end": "1099809"
  },
  {
    "text": "this is victim access so it looks a bit more noisy but as you will see later we can still mount a very powerful cache",
    "start": "1099809",
    "end": "1106440"
  },
  {
    "text": "attack with that so the next challenge that we need to",
    "start": "1106440",
    "end": "1111600"
  },
  {
    "text": "solve is that we don't have an unprivileged timing sauce and as I told you that the Foreman's counter can only",
    "start": "1111600",
    "end": "1116940"
  },
  {
    "text": "be accessed in privileged mode so we need to find something different that we can use to distinguish between a cache",
    "start": "1116940",
    "end": "1122640"
  },
  {
    "text": "hit in the cache miss and the first thing that we found is you can use the graphic interface with the probe event",
    "start": "1122640",
    "end": "1129120"
  },
  {
    "text": "open Cisco which is unprivileged and we can also access the cycle counter through that however on new devices it's",
    "start": "1129120",
    "end": "1136950"
  },
  {
    "text": "not available anymore on the one hand we just can't access the cipher counter or the kernel isn't built with this module",
    "start": "1136950",
    "end": "1143880"
  },
  {
    "text": "so it doesn't work however we can also use the basic function clock at time we",
    "start": "1143880",
    "end": "1150929"
  },
  {
    "text": "can pass the timer as an argument and we will have a nanosecond resolution if",
    "start": "1150929",
    "end": "1156630"
  },
  {
    "start": "1156000",
    "end": "1272000"
  },
  {
    "text": "this wouldn't be available we can have a very simple approach by just",
    "start": "1156630",
    "end": "1161730"
  },
  {
    "text": "implementing a thread counter which is a thread running on a different core just incrementing a global variable and this",
    "start": "1161730",
    "end": "1168720"
  },
  {
    "text": "is enough for distinguishing cache hits and cache misses so we have now free",
    "start": "1168720",
    "end": "1174120"
  },
  {
    "text": "unprivileged timing sources that we can use and they all give us a nanosecond resolution and this is enough to",
    "start": "1174120",
    "end": "1180960"
  },
  {
    "text": "distinguish hits from misses as we can see on this plot so on the Left we have",
    "start": "1180960",
    "end": "1187050"
  },
  {
    "text": "all the timing sources measuring a cache hit and then we have a huge gap and on",
    "start": "1187050",
    "end": "1192360"
  },
  {
    "text": "the right we have the same only for the cache misses and it's easy to find the threshold in between we can use for our",
    "start": "1192360",
    "end": "1199340"
  },
  {
    "text": "measurements in the end so the next thing that we have to take care of and this is probably one of the",
    "start": "1199340",
    "end": "1205760"
  },
  {
    "text": "hardest challenges is that we have non-inclusive caches because for in this",
    "start": "1205760",
    "end": "1211070"
  },
  {
    "text": "scenario the victim process is running on core zero and an address is loaded in",
    "start": "1211070",
    "end": "1216710"
  },
  {
    "text": "its first level instruction cache and our attacking process is running on core one and this cache is for instance",
    "start": "1216710",
    "end": "1224000"
  },
  {
    "text": "instruction inclusive and data non-inclusive and this means that the data from the instruction cache here has",
    "start": "1224000",
    "end": "1230990"
  },
  {
    "text": "also be to be in the last level cache and what we can do now to evict the data",
    "start": "1230990",
    "end": "1236600"
  },
  {
    "text": "from the first level cache of the other core which is private to the other cores by just filling our own local data cache",
    "start": "1236600",
    "end": "1244250"
  },
  {
    "text": "and starting populating the last level cache and at some point we are going to",
    "start": "1244250",
    "end": "1250370"
  },
  {
    "text": "evict the address out of the last level cache and because it's inclusive it will also get evicted from the first level",
    "start": "1250370",
    "end": "1257420"
  },
  {
    "text": "cache and now we were able to evict an address from another core even if we",
    "start": "1257420",
    "end": "1262610"
  },
  {
    "text": "don't have inclusive caches entirely so the second thing we need to do we",
    "start": "1262610",
    "end": "1268430"
  },
  {
    "text": "need to find a way to measure if the other core has reloaded the address and the solution is that there are cache",
    "start": "1268430",
    "end": "1275750"
  },
  {
    "start": "1272000",
    "end": "1372000"
  },
  {
    "text": "coherency protocols in place on the CPU which run all the time and they allow us",
    "start": "1275750",
    "end": "1280970"
  },
  {
    "text": "to fetch data from a remote core and the reason behind this is that loading the data from another core is still faster",
    "start": "1280970",
    "end": "1287960"
  },
  {
    "text": "if we need to have a memory access and as you can see on the plot while it takes roughly 100 hundred cycles more to",
    "start": "1287960",
    "end": "1295790"
  },
  {
    "text": "load the address from another core it's still much faster than if it would have to make a memory access to the main",
    "start": "1295790",
    "end": "1302060"
  },
  {
    "text": "memory and we can exploit this to measure if the address has been loaded by the other core so we can run",
    "start": "1302060",
    "end": "1309320"
  },
  {
    "text": "cross-court decks as well the last thing we need to fix is that we",
    "start": "1309320",
    "end": "1314630"
  },
  {
    "text": "have no shared cache on modern phones with which have multiple CPUs so that there is no shared cache",
    "start": "1314630",
    "end": "1322040"
  },
  {
    "text": "between them and the answer is again cache coherency protocols because they",
    "start": "1322040",
    "end": "1327170"
  },
  {
    "text": "allow us to fetch data not only from the remote core but from the remote CPU and",
    "start": "1327170",
    "end": "1332179"
  },
  {
    "text": "this is also faster than if we would have to access the T RAM and why we see",
    "start": "1332179",
    "end": "1337760"
  },
  {
    "text": "here that it's much slower than a local access it's still roughly 100 cycles",
    "start": "1337760",
    "end": "1343309"
  },
  {
    "text": "faster than if we have to make an access to the DRAM and regarding that for performance",
    "start": "1343309",
    "end": "1350620"
  },
  {
    "text": "things we need to we can exploit the cache coherency protocols which are running all the time and now we have",
    "start": "1350620",
    "end": "1358840"
  },
  {
    "text": "found a solution for all those challenges and we want to present you some attack scenarios beside the demo",
    "start": "1358840",
    "end": "1366020"
  },
  {
    "text": "that we've showed you in the beginning so the first thing you can do is you can build covered communication so for",
    "start": "1366020",
    "end": "1373070"
  },
  {
    "text": "instance a user installs a malicious gallery application and he is not suspicious when he installs this app",
    "start": "1373070",
    "end": "1379880"
  },
  {
    "text": "because the only permission it needs is to access the images so it doesn't need an internet access or read the contact",
    "start": "1379880",
    "end": "1386990"
  },
  {
    "text": "data of the user in addition the user wants to see what the weather is outside",
    "start": "1386990",
    "end": "1392150"
  },
  {
    "text": "and installs the malicious weather widget and he's also not suspicious because the only permission it requires",
    "start": "1392150",
    "end": "1398150"
  },
  {
    "text": "is to have access to the Internet so what if both apps can build a cover",
    "start": "1398150",
    "end": "1404750"
  },
  {
    "text": "channel to communicate with each other so that the gallery app can send the image to the weather app which uploads",
    "start": "1404750",
    "end": "1411679"
  },
  {
    "text": "it to the Internet and so if two applications want to communicate with each other but they are",
    "start": "1411679",
    "end": "1418669"
  },
  {
    "text": "not allowed to do so because they either don't have the permissions or there's just no mechanism they can use like",
    "start": "1418669",
    "end": "1424309"
  },
  {
    "text": "shared memory they can use a cabbage channel and a cabbage channel enables to",
    "start": "1424309",
    "end": "1430640"
  },
  {
    "text": "unprivileged applications to communicate with each other but it does not use any",
    "start": "1430640",
    "end": "1436070"
  },
  {
    "text": "data transfer mechanism that is provided by the operating system and this evades",
    "start": "1436070",
    "end": "1441380"
  },
  {
    "text": "the sandboxing concept and also the permission system and because you have two apps which need to",
    "start": "1441380",
    "end": "1448190"
  },
  {
    "text": "work together this is called a collusion attack and what we did was we built a",
    "start": "1448190",
    "end": "1453890"
  },
  {
    "text": "cover channel using the cache so we used addresses from shared memory from a",
    "start": "1453890",
    "end": "1458990"
  },
  {
    "text": "shared library on executable and we transmitted bits through cash hits and cache misses so as",
    "start": "1458990",
    "end": "1466710"
  },
  {
    "text": "an example if you want to transmit to zero you just to send the doesn't access the address and so the receiver would",
    "start": "1466710",
    "end": "1473909"
  },
  {
    "text": "measure a cache miss if you want to transmit one the sender would access the address and the receiver will measure a",
    "start": "1473909",
    "end": "1480720"
  },
  {
    "text": "cache hit and using those building blocks we can build the protocol based on packets so we use",
    "start": "1480720",
    "end": "1488370"
  },
  {
    "start": "1481000",
    "end": "1938000"
  },
  {
    "text": "the sequence number and also a checksum to protect our payload so that we can check the integrity of the data and can",
    "start": "1488370",
    "end": "1495539"
  },
  {
    "text": "recent data if we require to on the other hand the receiver responds with",
    "start": "1495539",
    "end": "1500700"
  },
  {
    "text": "the sequence number he has already received and our cover channel works using flash and",
    "start": "1500700",
    "end": "1507419"
  },
  {
    "text": "reload techniques evict and reload and also flash and flash which we haven't discussed but basically the flash",
    "start": "1507419",
    "end": "1513779"
  },
  {
    "text": "instruction also leaks timing information depending of the if the address is cached or not so we can use",
    "start": "1513779",
    "end": "1519990"
  },
  {
    "text": "it instead of the reload step so our cover channel works across core",
    "start": "1519990",
    "end": "1525869"
  },
  {
    "text": "and also across CPU and is way faster than any of the state-of-the-art cover channel which has been published so for",
    "start": "1525869",
    "end": "1533999"
  },
  {
    "text": "instance we had a cover terminal using the volume settings and it only got 150",
    "start": "1533999",
    "end": "1540419"
  },
  {
    "text": "bits per second or one using the type of intense with 4k bits per second so our",
    "start": "1540419",
    "end": "1548730"
  },
  {
    "text": "cover channel in the best case using flash and reload had one megabit per",
    "start": "1548730",
    "end": "1554480"
  },
  {
    "text": "second and as you can see when we use a victim reload it still it's much slower",
    "start": "1554480",
    "end": "1560669"
  },
  {
    "text": "of course because there's much noise but it's even fat is still faster than any",
    "start": "1560669",
    "end": "1565919"
  },
  {
    "text": "previously discovered cover channel and now Clementine will tell us how we did",
    "start": "1565919",
    "end": "1570990"
  },
  {
    "text": "the demo and how you can use our attacks to spy on the user so on our second case",
    "start": "1570990",
    "end": "1577590"
  },
  {
    "text": "study and for the rest and the attack scenario is a bit different than for the cover channel here we do not have two",
    "start": "1577590",
    "end": "1584129"
  },
  {
    "text": "malicious application but just one malicious application that is going to spy on the other benign applications so",
    "start": "1584129",
    "end": "1592620"
  },
  {
    "text": "problem is always which address do we want to spy on so locating these event",
    "start": "1592620",
    "end": "1598320"
  },
  {
    "text": "dependent memory accesses so to do that we had cache Don Pettit",
    "start": "1598320",
    "end": "1603660"
  },
  {
    "text": "acts on Intel CPUs and basically reported that one so the first step is we are going to map a shared library or",
    "start": "1603660",
    "end": "1611250"
  },
  {
    "text": "executable then we are going to repeatedly trigger an events and in parallel of that we are going to use",
    "start": "1611250",
    "end": "1617820"
  },
  {
    "text": "flash and we load on one address if we have a lot of cache hits then it means",
    "start": "1617820",
    "end": "1623400"
  },
  {
    "text": "that the address the specific address is used by the library or the executive on and then we are going to repeat this",
    "start": "1623400",
    "end": "1629580"
  },
  {
    "text": "second step for every address of the library",
    "start": "1629580",
    "end": "1634640"
  },
  {
    "text": "if then you want to spy on more events then you just repeat step two and three so we obtain a catch template matrix",
    "start": "1634640",
    "end": "1642630"
  },
  {
    "text": "which is basically how many cache hits we have for each pair event and address so if you have a dark cell it means we",
    "start": "1642630",
    "end": "1649320"
  },
  {
    "text": "had many cache hits if you have a light cell no cash no cache its we can do that",
    "start": "1649320",
    "end": "1654420"
  },
  {
    "text": "on shell memory and also add binaries so this example is on the android keyboard and what's quite interesting in here is",
    "start": "1654420",
    "end": "1661830"
  },
  {
    "text": "to see that we have different numbers of cache sheets for different addresses depending on which type of input we had",
    "start": "1661830",
    "end": "1669210"
  },
  {
    "text": "so here the user pressed an alphabet key the enter key the space key and the",
    "start": "1669210",
    "end": "1674610"
  },
  {
    "text": "backspace key and if you see for example if we spy on this address in particular",
    "start": "1674610",
    "end": "1679800"
  },
  {
    "text": "the only event that causes cache hits is the alphabet so if we spy on this one and we had some cash sheets it means",
    "start": "1679800",
    "end": "1686309"
  },
  {
    "text": "that the user press an alphabet key now we can also combine different addresses and for example if we combine these two",
    "start": "1686309",
    "end": "1693540"
  },
  {
    "text": "address since then we can differentiate between the backspace and the alphabet because both the backspace and the",
    "start": "1693540",
    "end": "1700110"
  },
  {
    "text": "alphabets have cache hits on this address but only the alphabet Healthcare shapes on this one so basically if we",
    "start": "1700110",
    "end": "1706740"
  },
  {
    "text": "have cache hits on this address but no cache sheets on this one it means that is the backspace and we can",
    "start": "1706740",
    "end": "1712290"
  },
  {
    "text": "differentiate between alphabet and backspace like that and this is basically what we have seen in the demo",
    "start": "1712290",
    "end": "1719030"
  },
  {
    "text": "so that was now to see from which address we are going to choose to monitor and",
    "start": "1719030",
    "end": "1725899"
  },
  {
    "text": "now monitoring them using a victim reload and so on two different addresses on the Alcatel OneTouch pop two on this",
    "start": "1725899",
    "end": "1733159"
  },
  {
    "text": "text file you can see that we can really differentiate keys from spaces so we",
    "start": "1733159",
    "end": "1738619"
  },
  {
    "text": "have first we have very precise timing here and we have exactly one cache hit",
    "start": "1738619",
    "end": "1744049"
  },
  {
    "text": "per of space that the users pressed so we can really see the in Turkey stroke",
    "start": "1744049",
    "end": "1749419"
  },
  {
    "text": "timing here and we can modern that distinguish between the keys and the",
    "start": "1749419",
    "end": "1755059"
  },
  {
    "text": "space because there is one address that reacts only two space has been pressed",
    "start": "1755059",
    "end": "1761080"
  },
  {
    "text": "so we have a different fit between a key and spaces and really precise timing so",
    "start": "1761080",
    "end": "1768109"
  },
  {
    "text": "this was an example on the keyboard but that is really endless possibilities",
    "start": "1768109",
    "end": "1773119"
  },
  {
    "text": "just can alter libraries and as long as you have some secret dependent accesses",
    "start": "1773119",
    "end": "1778399"
  },
  {
    "text": "then you will be able to automate these attacks and the really neat thing is that you do not need any source code for",
    "start": "1778399",
    "end": "1785330"
  },
  {
    "text": "that just use the occasional method X so you can spy and learn about the users",
    "start": "1785330",
    "end": "1791239"
  },
  {
    "text": "behavior other kind of attacks that we can foresee is like if the user turned",
    "start": "1791239",
    "end": "1796820"
  },
  {
    "text": "on the GPS out the camera for example now we have our third case study and",
    "start": "1796820",
    "end": "1803419"
  },
  {
    "text": "we're going to add a cryptographic algorithms using cache attacks so our use case is the AES t-tables and",
    "start": "1803419",
    "end": "1811669"
  },
  {
    "text": "this one is a fast software implementation because it uses sub pre computed look-up tables now the bad",
    "start": "1811669",
    "end": "1817789"
  },
  {
    "text": "thing is that since 2006 it is known to be vulnerable to cyber attacks so the",
    "start": "1817789",
    "end": "1823820"
  },
  {
    "text": "attack has been done by all wicked an and it's a one-round known plaintext attack so you have Peter plaintext MK",
    "start": "1823820",
    "end": "1830929"
  },
  {
    "text": "the secret key and at each round are you're going to compute an intermediate state and on the first round this",
    "start": "1830929",
    "end": "1838609"
  },
  {
    "text": "intermediate state is AD the access table indices and it's just basically plaintext so secret key now this is a",
    "start": "1838609",
    "end": "1846229"
  },
  {
    "text": "known plaintext attack so if we are able to recover this access table indices it",
    "start": "1846229",
    "end": "1852589"
  },
  {
    "text": "means that we have recovered the key because it's just so so this has been shown in 2003 that's",
    "start": "1852589",
    "end": "1859900"
  },
  {
    "text": "ten years ago so nobody uses that anymore right no that's actually the",
    "start": "1859900",
    "end": "1865810"
  },
  {
    "text": "default implementation of bouncy castle it uses these two tables and we've seen that we can monitor a lot of",
    "start": "1865810",
    "end": "1872470"
  },
  {
    "text": "things with cache attack so let's monitor these tea tables entries now the difference between this attack and the",
    "start": "1872470",
    "end": "1879100"
  },
  {
    "text": "previous one is that for the previous one we had some kind of shell memory here the Java Virtual Machine creates a",
    "start": "1879100",
    "end": "1885850"
  },
  {
    "text": "copy of the tea table when the app starts so it means that we do not have any kind",
    "start": "1885850",
    "end": "1891550"
  },
  {
    "text": "of shell memory so we cannot use a victim reload of flushing reload but at",
    "start": "1891550",
    "end": "1896650"
  },
  {
    "text": "the beginning I've shown you we have priming probe if you don't have any kind of shell memory so we just use that and",
    "start": "1896650",
    "end": "1903180"
  },
  {
    "text": "here's the time the kind of figure that you can have if the attack is successful so",
    "start": "1903180",
    "end": "1909030"
  },
  {
    "text": "here you have to plant expert values and here the at the addresses and the",
    "start": "1909030",
    "end": "1914860"
  },
  {
    "text": "addresses are basically which tea table entry was accessed and this has been done using a key that is",
    "start": "1914860",
    "end": "1921910"
  },
  {
    "text": "all zeros and as long as you have this really nice diagonal it means that the attack succeeded if the key is not zeros",
    "start": "1921910",
    "end": "1929200"
  },
  {
    "text": "then you will just have a different access pattern here but you can in each case recover which T turbulently was",
    "start": "1929200",
    "end": "1935380"
  },
  {
    "text": "accessed and therefore recover the key and now our last case study and in addition",
    "start": "1935380",
    "end": "1942340"
  },
  {
    "start": "1938000",
    "end": "2186000"
  },
  {
    "text": "we want to show you that you can also use those attacks to monitor all the UM trust zone and the UM trust zone is a",
    "start": "1942340",
    "end": "1948340"
  },
  {
    "text": "hardware based security technology which provides you with a secure execution",
    "start": "1948340",
    "end": "1953530"
  },
  {
    "text": "environment and roots of trust and there are small applications running on it",
    "start": "1953530",
    "end": "1958600"
  },
  {
    "text": "called trust let's and the run in the secure world in parallel to your untrusted operating system and they",
    "start": "1958600",
    "end": "1965200"
  },
  {
    "text": "implement things like a credential store or a secure element for payments or",
    "start": "1965200",
    "end": "1970210"
  },
  {
    "text": "maybe digital rights management and one wants to assume that information which",
    "start": "1970210",
    "end": "1976120"
  },
  {
    "text": "is stored and processed in the trusted world should not be leaked to the non secure world however we find on one",
    "start": "1976120",
    "end": "1983350"
  },
  {
    "text": "smartphone there is a trust let which you can use to create our essay signatures for arbitrary data and",
    "start": "1983350",
    "end": "1989880"
  },
  {
    "text": "we measured some time difference depending on the key that is used and we",
    "start": "1989880",
    "end": "1996279"
  },
  {
    "text": "had no knowledge about the implementation of the trusted operating system and also not about the trust let",
    "start": "1996279",
    "end": "2002130"
  },
  {
    "text": "so we didn't have any source code and it's not necessarily required to do",
    "start": "2002130",
    "end": "2007289"
  },
  {
    "text": "something without having a source code so what we can do is we can distinguish",
    "start": "2007289",
    "end": "2012870"
  },
  {
    "text": "between valid and invalid keys that are processed in the trust zone and on this",
    "start": "2012870",
    "end": "2018390"
  },
  {
    "text": "plot you see on the x-axis the cash set that is used and on the y-axis the mean",
    "start": "2018390",
    "end": "2024929"
  },
  {
    "text": "squared error from two measurements in comparison with the mean over all valid",
    "start": "2024929",
    "end": "2031230"
  },
  {
    "text": "keys and the black line is an invalid key and you see there is a huge difference on almost every care set if",
    "start": "2031230",
    "end": "2038010"
  },
  {
    "text": "you use an invalid key in on the other hand if user valid key and over here you",
    "start": "2038010",
    "end": "2043890"
  },
  {
    "text": "can see you can also distinguish between which key has been used on some cash sets and maybe you can build more",
    "start": "2043890",
    "end": "2051839"
  },
  {
    "text": "sophisticated tags on that because the drafts on in the end leaks to the untrusted world and so you can monitor",
    "start": "2051839",
    "end": "2057990"
  },
  {
    "text": "what's happening in the trust zone so last but not least we want to show you",
    "start": "2057990",
    "end": "2063868"
  },
  {
    "text": "the tools that we have developed to mount such cash attacks and the first thing we did we build the",
    "start": "2063869",
    "end": "2070980"
  },
  {
    "text": "library to build cross-platform cache attacks you can write your attic code once and can execute it on x86 mv7 and",
    "start": "2070980",
    "end": "2078599"
  },
  {
    "text": "on v8 and it implements various attack techniques where some of them we've",
    "start": "2078599",
    "end": "2083669"
  },
  {
    "text": "showed you previously and it's open source and you can down it download it",
    "start": "2083669",
    "end": "2088770"
  },
  {
    "text": "online and all the describe examples that we have showed you today have been",
    "start": "2088770",
    "end": "2094560"
  },
  {
    "text": "developed on top on this life of this library and we also include eviction",
    "start": "2094560",
    "end": "2099630"
  },
  {
    "text": "strategies for the devices that we have used so you can go and try to code yourself if you have the same device and",
    "start": "2099630",
    "end": "2107030"
  },
  {
    "text": "we provide you with a very sophisticated example code and good documentation how",
    "start": "2107030",
    "end": "2112740"
  },
  {
    "text": "you can install and use the library and in addition this library also allows you",
    "start": "2112740",
    "end": "2118680"
  },
  {
    "text": "to implement cross-platform roham attacks and this is the github all that we have and",
    "start": "2118680",
    "end": "2125160"
  },
  {
    "text": "you can just go there download the code in addition if you have a device that we didn't have and",
    "start": "2125160",
    "end": "2131590"
  },
  {
    "text": "you still want to mount those attacks you can use our eviction strategy evaluator and this is basically the tool",
    "start": "2131590",
    "end": "2138580"
  },
  {
    "text": "which automatically tries several eviction strategies on your phone and provide you with a database that you can",
    "start": "2138580",
    "end": "2145990"
  },
  {
    "text": "use to analyze and find an eviction strategy you want to use and it's also in our repository and",
    "start": "2145990",
    "end": "2153390"
  },
  {
    "text": "last but not least we have also an implementation of the cache template the text so that you can also use them to",
    "start": "2153390",
    "end": "2160540"
  },
  {
    "text": "find libraries and executables for vulnerable addresses so you can spy on the user like we did in the demo and we",
    "start": "2160540",
    "end": "2168100"
  },
  {
    "text": "even give you a small tool which you can use to simulate input events so that you don't have to be on the phone and type",
    "start": "2168100",
    "end": "2174160"
  },
  {
    "text": "everything manually and you find this also in our repository and now",
    "start": "2174160",
    "end": "2180010"
  },
  {
    "text": "Clementine wants to talk about some countermeasures what we can do to prevent maybe some of these attacks",
    "start": "2180010",
    "end": "2186060"
  },
  {
    "text": "so the first thing to know is that we had cache attacks on Intel CPUs for a",
    "start": "2186060",
    "end": "2193120"
  },
  {
    "text": "good decade now and we still haven't found a good solution to prevent them because it uses this really crucial",
    "start": "2193120",
    "end": "2199960"
  },
  {
    "text": "element for perform that is the CPU cache and we cannot just get rid of the cache doesn't make any sense",
    "start": "2199960",
    "end": "2206280"
  },
  {
    "text": "so a first countermeasure that had been proposed for Intel CPUs was to have more",
    "start": "2206280",
    "end": "2212140"
  },
  {
    "text": "coarse-grained timers because we really need to make it to find the difference between caches and cache misses and that",
    "start": "2212140",
    "end": "2219280"
  },
  {
    "text": "is in the order of nanoseconds so the idea is if we have a more coarse grained timers that is on the resolution of",
    "start": "2219280",
    "end": "2226060"
  },
  {
    "text": "let's say milliseconds we wouldn't be able to differentiate between these cache hits and these cache misses the",
    "start": "2226060",
    "end": "2231850"
  },
  {
    "text": "thing is that as we've just shown you a thread timer is sufficient to recover an accuracy in the order of nanoseconds so",
    "start": "2231850",
    "end": "2238450"
  },
  {
    "text": "as long as we had some really true parallelism for this file we will be able to have fine-grained timers so this",
    "start": "2238450",
    "end": "2246340"
  },
  {
    "text": "is really not a good countermeasure and the second one is no shell memory so if",
    "start": "2246340",
    "end": "2251980"
  },
  {
    "text": "we do not have any shell memory we cannot use a flush in Medora we can reload and this out",
    "start": "2251980",
    "end": "2258250"
  },
  {
    "text": "easiest attacks we can do and also the most fine-grained so we can be very precise",
    "start": "2258250",
    "end": "2264430"
  },
  {
    "text": "with this attacks the thing is that it that left us with priming probe and we",
    "start": "2264430",
    "end": "2269530"
  },
  {
    "text": "can still come really nice attacks like we've shown you earlier so that was that",
    "start": "2269530",
    "end": "2275440"
  },
  {
    "text": "was still raised the powerful attacker so that would still be a good thing to implement especially if we also have the",
    "start": "2275440",
    "end": "2282280"
  },
  {
    "text": "system information that is restricted so for example no access to page map so in this case we wouldn't have any access to",
    "start": "2282280",
    "end": "2289420"
  },
  {
    "text": "physical addresses and that makes the hotter the attacks much harder again for",
    "start": "2289420",
    "end": "2294850"
  },
  {
    "text": "prevent probe how does again still possible it just raises the power for",
    "start": "2294850",
    "end": "2299860"
  },
  {
    "text": "the attackers now I think a crucial thing is that on modern smart phones we have",
    "start": "2299860",
    "end": "2306130"
  },
  {
    "text": "cryptographic instruction extensions so using like AES suitable implementation",
    "start": "2306130",
    "end": "2312850"
  },
  {
    "text": "it should not be the case so yet this instruction extension are still not the",
    "start": "2312850",
    "end": "2319030"
  },
  {
    "text": "default everywhere this is really bad also if you have a device that does not have these extensions we also know how",
    "start": "2319030",
    "end": "2325480"
  },
  {
    "text": "to have crypto algorithm and software only that do not leak any information so that",
    "start": "2325480",
    "end": "2332950"
  },
  {
    "text": "should be the case now it's not a system-wide a solution so it",
    "start": "2332950",
    "end": "2338500"
  },
  {
    "text": "still wouldn't protect from a spy music behavior on the keyboard like we showed you in the demo so I think the",
    "start": "2338500",
    "end": "2345780"
  },
  {
    "text": "message here is we know how to protect crypto so we should do that for the rest",
    "start": "2345780",
    "end": "2351700"
  },
  {
    "text": "there is really no satisfying solution we didn't found solutions for Intel CPUs I'm not realistic that we find solution",
    "start": "2351700",
    "end": "2358450"
  },
  {
    "text": "for arm CPU anytime soon now for the conclusion so what we've",
    "start": "2358450",
    "end": "2364690"
  },
  {
    "text": "seen today is that all of the powerful cache attacks are also applicable to mobile devices and they do not require",
    "start": "2364690",
    "end": "2371620"
  },
  {
    "text": "any permission or any privilege and you can use them to build fast copper channels to evade the sandboxing and",
    "start": "2371620",
    "end": "2378960"
  },
  {
    "text": "privileged permission system and you can use them to spy on the user's activity",
    "start": "2378960",
    "end": "2384160"
  },
  {
    "text": "with a very high accuracy as we have seen in the demo as well and you can also use it to derive cryptographic",
    "start": "2384160",
    "end": "2391210"
  },
  {
    "text": "cheese and to monitor the um trust zone which should not be possible so we want",
    "start": "2391210",
    "end": "2397270"
  },
  {
    "text": "to thank you for your attention and welcome you to try our tools yourself they are all online and if you have any",
    "start": "2397270",
    "end": "2404109"
  },
  {
    "text": "questions feel free to ask them or talk to us later thank you",
    "start": "2404109",
    "end": "2409470"
  },
  {
    "text": "[Applause]",
    "start": "2409470",
    "end": "2417380"
  }
]