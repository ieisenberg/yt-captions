[
  {
    "start": "0",
    "end": "56000"
  },
  {
    "text": "[Music]",
    "start": "910",
    "end": "9040"
  },
  {
    "text": "hello everybody my name is dana and i'm here with my colleague martin and today we will discuss about usb based attacks",
    "start": "9040",
    "end": "15839"
  },
  {
    "text": "at rescuer we do a lot of embedded research and today we would like to tell you the story of how we use what we call",
    "start": "15839",
    "end": "22160"
  },
  {
    "text": "the forgotten vulnerability to compromise our target by just inserting a malicious usb device",
    "start": "22160",
    "end": "28400"
  },
  {
    "text": "so our agenda for today is the following we will discuss about the relevance of usb based attacks we will then tell you",
    "start": "28400",
    "end": "35360"
  },
  {
    "text": "a little bit more about the forgotten vulnerability after that we will share our exploitation methods and approach",
    "start": "35360",
    "end": "42320"
  },
  {
    "text": "and we will show you how this attack looks like by giving a demo and we will conclude our presentation by",
    "start": "42320",
    "end": "48879"
  },
  {
    "text": "giving a few discussion points on our final takeaways so",
    "start": "48879",
    "end": "53920"
  },
  {
    "text": "why do we care about usb based attacks so there are several reasons for this but here we will only mention the main",
    "start": "53920",
    "end": "61680"
  },
  {
    "start": "56000",
    "end": "56000"
  },
  {
    "text": "the ones that we consider that are the main ones the first reason is that the usb",
    "start": "61680",
    "end": "66880"
  },
  {
    "text": "interface is available in pretty much all devices even closed down devices actually",
    "start": "66880",
    "end": "74000"
  },
  {
    "text": "support typically usb interfaces the second reason is that the usb interface",
    "start": "74000",
    "end": "79920"
  },
  {
    "text": "is generally available from the moment the device is powered on till the moment the device is powered off that makes it",
    "start": "79920",
    "end": "86640"
  },
  {
    "text": "really interesting the third reason is that the usb protocol is quite complex and that makes",
    "start": "86640",
    "end": "92799"
  },
  {
    "text": "it error prone c scholar has demonstrated in the last few years that there are still a lot of",
    "start": "92799",
    "end": "98240"
  },
  {
    "text": "vulnerabilities to be uncovered in the usb drivers of the linux kernel and these vulnerabilities get found but",
    "start": "98240",
    "end": "105200"
  },
  {
    "text": "they also get exploited in the wild and recent research has shown the potential",
    "start": "105200",
    "end": "110479"
  },
  {
    "text": "of such vulnerabilities so now we can move forward to the forgotten vulnerability so what is this",
    "start": "110479",
    "end": "117600"
  },
  {
    "start": "116000",
    "end": "116000"
  },
  {
    "text": "vulnerability about this is basically a double free in the linux kernel while we were doing research on our device we",
    "start": "117600",
    "end": "124240"
  },
  {
    "text": "found this vulnerability to shortly after discover that a researcher called andre conovalo also founded in 2016. he",
    "start": "124240",
    "end": "131920"
  },
  {
    "text": "actually made a really nice blog post where he explains about the vulnerability and his exploitation",
    "start": "131920",
    "end": "137120"
  },
  {
    "text": "approach to give a little bit more details this is a vulnerability in the usb midi subsystem",
    "start": "137120",
    "end": "143200"
  },
  {
    "text": "andrei demonstrated that it was possible to both cause a denial of service in the linux kernel but also gained code",
    "start": "143200",
    "end": "148959"
  },
  {
    "text": "execution so he managed to turn this double free vulnerability into a use after free",
    "start": "148959",
    "end": "154560"
  },
  {
    "text": "and he used um these two primitives to actually shape the heap and bring it into an",
    "start": "154560",
    "end": "160319"
  },
  {
    "text": "exploitable state these are the cisco uh interface and also he used sockets in order to do",
    "start": "160319",
    "end": "167040"
  },
  {
    "text": "this so now you may be asking yourself usb midi devices are not that common why",
    "start": "167040",
    "end": "172480"
  },
  {
    "text": "do we care about this vulnerability well the fact is that this driver was enabled",
    "start": "172480",
    "end": "178239"
  },
  {
    "text": "in pretty much every device that uses linux this meant that the issue affected even",
    "start": "178239",
    "end": "184720"
  },
  {
    "text": "major distributions such as ubuntu and fedora of course in order to exploit this",
    "start": "184720",
    "end": "189920"
  },
  {
    "text": "vulnerability you need physical access to the device so now you might also be asking yourself",
    "start": "189920",
    "end": "196400"
  },
  {
    "text": "why do we still care right this vulnerability was found five years ago so we wanted to share",
    "start": "196400",
    "end": "202800"
  },
  {
    "text": "um a little timeline with events to answer that question so in 2016 andre",
    "start": "202800",
    "end": "208959"
  },
  {
    "text": "found the vulnerability and shortly after the issue was patched upstream and a cve was assigned to it",
    "start": "208959",
    "end": "215519"
  },
  {
    "text": "four years later when martin and i were doing research on a device we stumbled across this vulnerability and two months",
    "start": "215519",
    "end": "222640"
  },
  {
    "text": "later we actually had a successful exploit running this is the story that we will tell in",
    "start": "222640",
    "end": "228319"
  },
  {
    "text": "this presentation how we managed to do that so just to give you a little bit of background on the device this is a",
    "start": "228319",
    "end": "234640"
  },
  {
    "text": "broadly used device that's probably in millions of households it had a pretty trimmed down version of",
    "start": "234640",
    "end": "241840"
  },
  {
    "text": "linux that was based on kernel 4.x and as far as we could see they were",
    "start": "241840",
    "end": "248239"
  },
  {
    "text": "actively backporting all the security fixes or at least most of them the most important characteristic of",
    "start": "248239",
    "end": "254560"
  },
  {
    "text": "this device is that it was completely locked down so our attack surface was really limited",
    "start": "254560",
    "end": "261120"
  },
  {
    "text": "we only had one usb interface then a network interface and a heavily sandbox",
    "start": "261120",
    "end": "266720"
  },
  {
    "text": "browser on top of that we did not have any sort of output so",
    "start": "266720",
    "end": "273040"
  },
  {
    "text": "upon crashes we could not see anything the actual device is not relevant for",
    "start": "273040",
    "end": "278479"
  },
  {
    "text": "this stock what we want to show is our exploitation approach on our methods so now let's dive a little bit deeper",
    "start": "278479",
    "end": "285199"
  },
  {
    "text": "into the vulnerability to see how is this triggered so triggering this variability is",
    "start": "285199",
    "end": "291199"
  },
  {
    "text": "surprisingly easy you just need to connect a misconfigure usb midi device and you will cause this to happen",
    "start": "291199",
    "end": "298080"
  },
  {
    "text": "so when you start a device a process called probing will start so",
    "start": "298080",
    "end": "303600"
  },
  {
    "start": "300000",
    "end": "300000"
  },
  {
    "text": "the linux kernel will start the process to find the proper drivers that can handle that device",
    "start": "303600",
    "end": "309759"
  },
  {
    "text": "and an important thing to know is that the probing process is driven by the host in this case the host is our target",
    "start": "309759",
    "end": "317120"
  },
  {
    "text": "so it all starts with the usb hub work you and this work you basically contains",
    "start": "317120",
    "end": "322400"
  },
  {
    "text": "all the events that the kernel needs to handle related to usb then after that a handshake will start",
    "start": "322400",
    "end": "329120"
  },
  {
    "text": "between the host and the device we insert and the host will be asking some questions like who are you what are your",
    "start": "329120",
    "end": "335520"
  },
  {
    "text": "capabilities what's your name and there can be more messages depending on the",
    "start": "335520",
    "end": "340960"
  },
  {
    "text": "first exchange the important thing to note there is that the device that we insert",
    "start": "340960",
    "end": "346400"
  },
  {
    "text": "um does not have a lot of freedom it just needs to reply to the host requests",
    "start": "346400",
    "end": "352320"
  },
  {
    "text": "and in a reply in a specific format so um",
    "start": "352320",
    "end": "358080"
  },
  {
    "text": "along the road then we will start initializing objects and we will end up",
    "start": "358080",
    "end": "364800"
  },
  {
    "text": "in the code that handles midi devices then the kernel will decide to allocate an",
    "start": "364800",
    "end": "371440"
  },
  {
    "text": "object which here we call umidi on the heap since we are inserting a device that's",
    "start": "371440",
    "end": "378080"
  },
  {
    "text": "misconfigured the kernel will also realize that this device is",
    "start": "378080",
    "end": "383199"
  },
  {
    "text": "not properly showing its information and this will cause the first free of this",
    "start": "383199",
    "end": "390240"
  },
  {
    "text": "object that was allocated but the process doesn't stop there because the",
    "start": "390240",
    "end": "395280"
  },
  {
    "text": "error will be propagated and then as a probing failure result and the as",
    "start": "395280",
    "end": "401919"
  },
  {
    "text": "the aftermath there will be a second free this is basically what causes the",
    "start": "401919",
    "end": "407360"
  },
  {
    "text": "vulnerability to happen so let's now talk a bit about the linux",
    "start": "407360",
    "end": "414560"
  },
  {
    "text": "memory allocator so since a really early version of linux slab is the default allocator this is",
    "start": "414560",
    "end": "421759"
  },
  {
    "text": "the subsystem that handles allocations and the allocations of the kernel and the important thing for us",
    "start": "421759",
    "end": "427840"
  },
  {
    "text": "is that in order to handle memory this allocator groups chunks into",
    "start": "427840",
    "end": "433039"
  },
  {
    "text": "structures that we call slabs so basically all the objects that are of the same size",
    "start": "433039",
    "end": "440080"
  },
  {
    "text": "end up in the same slot the thing is that of course not all the",
    "start": "440080",
    "end": "445680"
  },
  {
    "text": "objects are going to be of the same size so upon receiving certain allocation requests the kernel",
    "start": "445680",
    "end": "451759"
  },
  {
    "text": "will check it will round the size to an appropriate slab and then the slab will be chosen",
    "start": "451759",
    "end": "457919"
  },
  {
    "text": "the slava locator also needs of course a way of keeping track of the chunks that are",
    "start": "457919",
    "end": "464720"
  },
  {
    "text": "available for giving when a request comes this is done by",
    "start": "464720",
    "end": "469919"
  },
  {
    "text": "using a free list that's basically a single linked list another important thing to know is that",
    "start": "469919",
    "end": "476240"
  },
  {
    "text": "this single linked list is handled in a sort of a fifo way so first in first out",
    "start": "476240",
    "end": "481440"
  },
  {
    "text": "that means that the first object that is inserted in the list will also be the first object to be given upon a memory",
    "start": "481440",
    "end": "489440"
  },
  {
    "text": "allocation request and this specific behavior is really important",
    "start": "489440",
    "end": "494560"
  },
  {
    "text": "for shaping our free list so in order to see what happens with the",
    "start": "494560",
    "end": "500560"
  },
  {
    "start": "498000",
    "end": "498000"
  },
  {
    "text": "hip while this vulnerability happens we will see a series of images",
    "start": "500560",
    "end": "507199"
  },
  {
    "text": "first we start with the free list as the kernel has it before anything happens",
    "start": "507199",
    "end": "512320"
  },
  {
    "text": "once we allocate the umidi object the freely shape will change we will give",
    "start": "512320",
    "end": "517518"
  },
  {
    "text": "away chunk one so then now the three lists will be pointing to chunk two",
    "start": "517519",
    "end": "522560"
  },
  {
    "text": "when we do the first three if no other allocation happens in between we will get back to our initial state",
    "start": "522560",
    "end": "529839"
  },
  {
    "text": "we will have the free list with all the chunks because chunk one will return the problem is that when we do the second",
    "start": "529839",
    "end": "536640"
  },
  {
    "text": "free again if no other object was allocated in between we will end up in this",
    "start": "536640",
    "end": "542160"
  },
  {
    "text": "situation this basically means that with this vulnerability we managed to corrupt the free list of the kernel and from",
    "start": "542160",
    "end": "549200"
  },
  {
    "text": "this point on the kernel will constantly give this same chunk to all the allocations",
    "start": "549200",
    "end": "555279"
  },
  {
    "text": "that are requested this opens the door for memory corruption",
    "start": "555279",
    "end": "560839"
  },
  {
    "text": "attacks and as a closing remark for this section we want to show you the fix",
    "start": "560839",
    "end": "566320"
  },
  {
    "text": "so basically the fix consisted in just removing one line of one of the freeze",
    "start": "566320",
    "end": "572959"
  },
  {
    "text": "and that was it then the vulnerability was fixed now i would like to give the floor to",
    "start": "572959",
    "end": "579360"
  },
  {
    "text": "martin who will talk about our exploitation approach so let's talk about how we actually",
    "start": "579360",
    "end": "586240"
  },
  {
    "text": "exploited this vulnerability and the approach we took to develop our method",
    "start": "586240",
    "end": "591519"
  },
  {
    "text": "so as we have seen devices are severely constrained in what they can do when they are communicated with the host and",
    "start": "591519",
    "end": "597760"
  },
  {
    "text": "in principle they only can respond to the request the host is sending to the devices that means that devices cannot",
    "start": "597760",
    "end": "604560"
  },
  {
    "text": "initiate arbitrary communication or send arbitrary data back to the host and this is severely limiting the exploitation",
    "start": "604560",
    "end": "611200"
  },
  {
    "text": "primitives we have of to our availability to understand what we are working with",
    "start": "611200",
    "end": "616800"
  },
  {
    "start": "614000",
    "end": "614000"
  },
  {
    "text": "we need to take a deeper look at the bd object and how what is happening with the heap of the",
    "start": "616800",
    "end": "621839"
  },
  {
    "text": "system so the midi object is a structure of 272 bytes of memory and it gets",
    "start": "621839",
    "end": "628480"
  },
  {
    "text": "allocated on the kernel heap and because it is 272 bytes and the kernel or the",
    "start": "628480",
    "end": "634399"
  },
  {
    "text": "slab allocator is rounding up its sizes it means it will land on the slab for 512 byte objects",
    "start": "634399",
    "end": "641680"
  },
  {
    "text": "and this slab has interesting characteristics at least interesting characteristics for exploiting the",
    "start": "641680",
    "end": "647519"
  },
  {
    "text": "system what we found is that 512 bytes is a nice amount for crafting",
    "start": "647519",
    "end": "654000"
  },
  {
    "text": "our attack but what's way more important is that this slab is a relatively low activity actually we have noticed that",
    "start": "654000",
    "end": "661279"
  },
  {
    "text": "this slab seems to be mostly used for network related activity and that are then also the things that might be",
    "start": "661279",
    "end": "667680"
  },
  {
    "text": "interfering with our attack due to the fact that this is a relatively low activity slab this has",
    "start": "667680",
    "end": "674560"
  },
  {
    "text": "been really one of the key characteristics that allows us to exploit this vulnerability on the system",
    "start": "674560",
    "end": "679760"
  },
  {
    "text": "because we have to win the race between the double free and the actual fact that something is happening with",
    "start": "679760",
    "end": "686000"
  },
  {
    "text": "the heap again so how are we going to turn this double free into something that is actually",
    "start": "686000",
    "end": "692399"
  },
  {
    "start": "687000",
    "end": "687000"
  },
  {
    "text": "useful because after the double free we have a loop in our free list what we noticed is that all allocations",
    "start": "692399",
    "end": "699200"
  },
  {
    "text": "that occur on the same cpu core and on the same slab actually are getting the same memory",
    "start": "699200",
    "end": "705279"
  },
  {
    "text": "chunk assigned every time you do an allocation as has been explained by donna however this is just panicking the",
    "start": "705279",
    "end": "711600"
  },
  {
    "text": "kernel in a matter of seconds so what is happening well we do multiple allocations each of them are returning",
    "start": "711600",
    "end": "720000"
  },
  {
    "text": "the same address due to the loop we have in our system because it's a",
    "start": "720000",
    "end": "725519"
  },
  {
    "text": "linked list what we actually have is we have the start of the list but we also have a pointer to the next chunk this",
    "start": "725519",
    "end": "731519"
  },
  {
    "text": "pointer is stored at the first eight bytes of our chunk and due to the loop in the list it is pointing to itself",
    "start": "731519",
    "end": "738560"
  },
  {
    "text": "that also means that when we are updating the free list or actually",
    "start": "738560",
    "end": "744560"
  },
  {
    "text": "actually allocating memory we will take this pointer from the start of the check",
    "start": "744560",
    "end": "750079"
  },
  {
    "text": "this means that when we have an allocated jump and we are writing data to it",
    "start": "750079",
    "end": "755440"
  },
  {
    "text": "due to the loop in the free list the next allocation will actually start using the address",
    "start": "755440",
    "end": "760959"
  },
  {
    "text": "that we have at the beginning of that chunk this means that if we have two consecutive allocations and we control",
    "start": "760959",
    "end": "767839"
  },
  {
    "text": "the content of those allocations we can actually make the free list point to an arbitrary location in memory and the",
    "start": "767839",
    "end": "774639"
  },
  {
    "text": "third allocation will then return the address we have put in the freelance pointer",
    "start": "774639",
    "end": "780000"
  },
  {
    "text": "if you then control the content that is written to that address we have an arbitrary right primitive in our system",
    "start": "780000",
    "end": "786320"
  },
  {
    "text": "and this is the base primitive for the x for our exploit",
    "start": "786320",
    "end": "792160"
  },
  {
    "text": "so what do we have we have a chunk on the 512 by swap we need to have three memory allocations",
    "start": "792160",
    "end": "798800"
  },
  {
    "text": "in a row and we need to control the data of those memory allocations ideally we control the content that is written to",
    "start": "798800",
    "end": "805680"
  },
  {
    "text": "all allocations however we can't get away with if it's only controlling the first and the last allocation the first",
    "start": "805680",
    "end": "812399"
  },
  {
    "text": "allocation we need to set the address that we are going to target with our",
    "start": "812399",
    "end": "817760"
  },
  {
    "text": "right and the third allocation what is written to that allocation is actually the payload that is being delivered to",
    "start": "817760",
    "end": "824399"
  },
  {
    "text": "our arbitrary memory location however there are we going to write an exploitation primitive with exactly",
    "start": "824399",
    "end": "831120"
  },
  {
    "text": "these characteristics that is also accessible over usb and we have been digging through several usb drivers and",
    "start": "831120",
    "end": "838399"
  },
  {
    "text": "at a certain moment we were encountering a very interesting usb driver and this usb driver is the usb hid protocol or",
    "start": "838399",
    "end": "846560"
  },
  {
    "text": "human interface devices and it is basically a generic protocol for keyboards mousers game controllers etc",
    "start": "846560",
    "end": "853440"
  },
  {
    "text": "and it basically allows you to describe your device through a series of inputs and outputs",
    "start": "853440",
    "end": "858720"
  },
  {
    "text": "and the way it works is that the usb protocol is extended with two additional descriptors the first one is the hcd",
    "start": "858720",
    "end": "865360"
  },
  {
    "text": "destructor and the second one is the haste id report descriptor and the haste id report descriptor is basically an",
    "start": "865360",
    "end": "870720"
  },
  {
    "text": "arbitrarily sized blob of data that is describing your device and the interesting bit of this is is that this",
    "start": "870720",
    "end": "877040"
  },
  {
    "text": "report descriptor has a variable length gets dynamically allocated and the actual length that will be allocated is",
    "start": "877040",
    "end": "883760"
  },
  {
    "text": "delivered in the initial hid descriptor so let's now take a look at the probing",
    "start": "883760",
    "end": "889360"
  },
  {
    "start": "887000",
    "end": "887000"
  },
  {
    "text": "process that happens for hid devices one of the main functions that is doing the problem is the usb hid pass function the",
    "start": "889360",
    "end": "897440"
  },
  {
    "text": "usb hd pass function will first do request the hcd descriptor and the",
    "start": "897440",
    "end": "902800"
  },
  {
    "text": "hsid descriptor will have the size of the report descriptor which is then stored in the air size variable",
    "start": "902800",
    "end": "910000"
  },
  {
    "text": "then it will start allocating memory for storing the report descriptor and actually call the corresponding function",
    "start": "910000",
    "end": "916000"
  },
  {
    "text": "to read retrieve the report descriptor from the device this is done by the haste id cad",
    "start": "916000",
    "end": "921680"
  },
  {
    "text": "class descriptor function but then as a next step we start actually processing this report",
    "start": "921680",
    "end": "927680"
  },
  {
    "text": "descriptor and there we see some very interesting behavior this happens in the haste id open report function which is",
    "start": "927680",
    "end": "934399"
  },
  {
    "text": "quite a bit later in the in the probing process of this device and interestingly enough this driver is making two copies",
    "start": "934399",
    "end": "941920"
  },
  {
    "text": "of our reaper descriptor buffer and it's just allocating the same size of memory and",
    "start": "941920",
    "end": "947279"
  },
  {
    "text": "just coping over the content of the buffer the k-man dot function is basically a",
    "start": "947279",
    "end": "953920"
  },
  {
    "text": "combination of a k malloc and a mem copy with the purpose to duplicate a buffer however what we have here are our three",
    "start": "953920",
    "end": "961360"
  },
  {
    "text": "allocations in a row and the content we control aka we have here our average very right",
    "start": "961360",
    "end": "967839"
  },
  {
    "text": "primitive that we can reach from outside over usb",
    "start": "967839",
    "end": "973360"
  },
  {
    "text": "but how are we then going to exploit that on the real device because remember on the real device we have no way to see",
    "start": "973360",
    "end": "979839"
  },
  {
    "text": "what is happening in the device the device might work the device might crash but that's all the information we can",
    "start": "979839",
    "end": "986000"
  },
  {
    "text": "get we have no insight in what's happening on the device and due to that we",
    "start": "986000",
    "end": "991199"
  },
  {
    "text": "invested heavily in created creating a development environment that allows us",
    "start": "991199",
    "end": "996320"
  },
  {
    "text": "to actually develop the attack before we try to execute it on the real device",
    "start": "996320",
    "end": "1002800"
  },
  {
    "text": "and one of the main problems we have is how do we craft our attack in such a way",
    "start": "1002800",
    "end": "1008720"
  },
  {
    "text": "that we reliable win the race between the double free and actually allocating",
    "start": "1008720",
    "end": "1013759"
  },
  {
    "text": "the buffer for the report descriptors but also how are we crafting a payload",
    "start": "1013759",
    "end": "1018800"
  },
  {
    "text": "that is working for our specific target luckily enough we did have access to the",
    "start": "1018800",
    "end": "1024880"
  },
  {
    "text": "plaintext binaries which helped us a lot however we'd have no information",
    "start": "1024880",
    "end": "1030880"
  },
  {
    "text": "from the runtime of the device and what we did is we actually did a lot of work in preparing our attack using the",
    "start": "1030880",
    "end": "1037600"
  },
  {
    "text": "grammar emulator what we did is that we basically tried to model the real device as close as",
    "start": "1037600",
    "end": "1045438"
  },
  {
    "start": "1039000",
    "end": "1039000"
  },
  {
    "text": "possible in the emulator and this has as major benefit that we could completely",
    "start": "1045439",
    "end": "1050480"
  },
  {
    "text": "control and debug our attack before we had to do it on the real device in the",
    "start": "1050480",
    "end": "1055600"
  },
  {
    "text": "blind and this has been really critically to get a sufficient understanding of how the attack is",
    "start": "1055600",
    "end": "1062480"
  },
  {
    "text": "behaving and the elements that we need to control to make it work",
    "start": "1062480",
    "end": "1067600"
  },
  {
    "text": "of course an emulator is not a real device the binary is different the",
    "start": "1067600",
    "end": "1073679"
  },
  {
    "text": "device behavior is different the activity is different however we really tried hard in making",
    "start": "1073679",
    "end": "1081280"
  },
  {
    "text": "sure that all the critical code paths and all the data structures are as close as possible to the real device also by",
    "start": "1081280",
    "end": "1088000"
  },
  {
    "text": "comparing our emulated kernel with the real device",
    "start": "1088000",
    "end": "1094080"
  },
  {
    "text": "however until the very last it remained the question how accurate is the emulation that we are doing on our",
    "start": "1094080",
    "end": "1100720"
  },
  {
    "text": "device of our device and how is it actually mapping to the real environment",
    "start": "1100720",
    "end": "1107039"
  },
  {
    "text": "so in q ammo we can of course test our kernel but how are we going to",
    "start": "1107039",
    "end": "1112960"
  },
  {
    "text": "test this real attack and what we did is we actually took the emulated devices of guamo for usb and we",
    "start": "1112960",
    "end": "1120240"
  },
  {
    "text": "basically repurposed that so we took the mouse and we made a midi device out of it which has the invalid configuration",
    "start": "1120240",
    "end": "1126880"
  },
  {
    "text": "triggering the double free and we changed the tablet interface such that it is using its hid report",
    "start": "1126880",
    "end": "1133280"
  },
  {
    "text": "descriptor to deliver the payload which then gets copied and written to memory to the",
    "start": "1133280",
    "end": "1138720"
  },
  {
    "text": "address we want and to our real surprise is that we almost had to change",
    "start": "1138720",
    "end": "1145679"
  },
  {
    "text": "nothing only of course the addresses and the offsets and similar things but it almost worked out of the box on the real",
    "start": "1145679",
    "end": "1151840"
  },
  {
    "text": "device and that was really a surprise to us but how are we actually going to do this on a real device because you will not",
    "start": "1151840",
    "end": "1158559"
  },
  {
    "start": "1153000",
    "end": "1153000"
  },
  {
    "text": "find a usb device that first represents itself as a media device doing a double free and then say hey i'm in hid device",
    "start": "1158559",
    "end": "1166080"
  },
  {
    "text": "and i want to deliver a payload that it gets written somewhere in your address space and what we used is the face",
    "start": "1166080",
    "end": "1171760"
  },
  {
    "text": "dancer framework this is a very nice open source framework to implement arbitrary usb devices in python and we",
    "start": "1171760",
    "end": "1179039"
  },
  {
    "text": "then use the great fat board to make it interface with our target and what we did is we changed the face sensor",
    "start": "1179039",
    "end": "1185520"
  },
  {
    "text": "framework in such a way that it first connects a midi device triggers a double",
    "start": "1185520",
    "end": "1190559"
  },
  {
    "text": "free disconnects itself connects us in his id device and delivers the payload",
    "start": "1190559",
    "end": "1195600"
  },
  {
    "text": "and hopefully that results in something useful for us what's very critical here is that the triggering of the double free the",
    "start": "1195600",
    "end": "1202480"
  },
  {
    "text": "disconnecting connecting and delivering of the payload need to be as close as possible the timing of the allocation of",
    "start": "1202480",
    "end": "1208880"
  },
  {
    "text": "the reboot descriptor should be as close as possible as the triggering of the double free because if there is",
    "start": "1208880",
    "end": "1214000"
  },
  {
    "text": "something else trying to use this slab for a different purpose that might crash the kernel due to the corruption we have",
    "start": "1214000",
    "end": "1220880"
  },
  {
    "text": "passed but what is the kind of payload we are actually going to deliver and one of the",
    "start": "1220880",
    "end": "1226000"
  },
  {
    "text": "main questions there is the code of the kernel writable if the code is not writable you will have to resort to some",
    "start": "1226000",
    "end": "1232799"
  },
  {
    "text": "form of data only attack however in our case we could actually override the kernel code because it was map writable",
    "start": "1232799",
    "end": "1239520"
  },
  {
    "text": "on this very specific device and by overwriting the kernel code we could get our get arbitrary code execution in the",
    "start": "1239520",
    "end": "1246320"
  },
  {
    "text": "context of the kernel but one of the main questions here is where are we going to hijack the kernel code and",
    "start": "1246320",
    "end": "1252559"
  },
  {
    "start": "1250000",
    "end": "1250000"
  },
  {
    "text": "getting code execution and do something for it naturally for us one of the",
    "start": "1252559",
    "end": "1257840"
  },
  {
    "text": "logical locations to take control would be as close as possible where our",
    "start": "1257840",
    "end": "1262880"
  },
  {
    "text": "payload is written to memory this is the h this is the assembly code of the haste id open",
    "start": "1262880",
    "end": "1269200"
  },
  {
    "text": "report function and we see the two k member calls inside the code",
    "start": "1269200",
    "end": "1275840"
  },
  {
    "text": "that we want to target our payload to start executing as close as possible after the second game end up because",
    "start": "1275840",
    "end": "1282720"
  },
  {
    "text": "this is the function that is going to write our payload to memory what we did is actually we override the",
    "start": "1282720",
    "end": "1289360"
  },
  {
    "text": "code slightly before the branch to this function because due to the start of our",
    "start": "1289360",
    "end": "1294480"
  },
  {
    "text": "payload having the destination address that we want to write to which is not executable code and then when the k-man",
    "start": "1294480",
    "end": "1301440"
  },
  {
    "text": "verb returns it will actually start executing the first instruction of our payload",
    "start": "1301440",
    "end": "1307280"
  },
  {
    "start": "1307000",
    "end": "1307000"
  },
  {
    "text": "how are we then designing our payloads well what we did is we again went back to coemo and we started crafting",
    "start": "1307280",
    "end": "1314000"
  },
  {
    "text": "different payloads and our very first payload was simply calling the print function and seeing we could print",
    "start": "1314000",
    "end": "1321039"
  },
  {
    "text": "a message to the console and seeing how the kernel panicked of course this is not",
    "start": "1321039",
    "end": "1326880"
  },
  {
    "text": "very useful however it gave gave us the confirmation",
    "start": "1326880",
    "end": "1332400"
  },
  {
    "text": "that we could actually gain code execution in the context of the kernel",
    "start": "1332400",
    "end": "1338320"
  },
  {
    "text": "the next step that we did and that was also very useful to do on the real device is calling the usb getstring",
    "start": "1338400",
    "end": "1345120"
  },
  {
    "text": "function this is going to do and get string descriptor request to the usb device and this is one of the very few",
    "start": "1345120",
    "end": "1351679"
  },
  {
    "text": "things we could observe from the outside what would happen is when we take control of the kernel",
    "start": "1351679",
    "end": "1359120"
  },
  {
    "text": "when we take control of the kernel is that when we call this function we see on the usb device that the kernel asks",
    "start": "1359120",
    "end": "1365520"
  },
  {
    "text": "for a string descriptor that we specify while this is very likely that the",
    "start": "1365520",
    "end": "1371120"
  },
  {
    "text": "kernel panics afterwards at least what we can see is that we successfully got code execution on the device",
    "start": "1371120",
    "end": "1377760"
  },
  {
    "text": "and then we went through several iterations and the final version of our attack we could actually",
    "start": "1377760",
    "end": "1384480"
  },
  {
    "text": "clean up the mess we have caused inside the memory of the device such that we could run the exploit pretty much an",
    "start": "1384480",
    "end": "1390640"
  },
  {
    "text": "indefinite amount of times on this specific device so how does our payload look like well",
    "start": "1390640",
    "end": "1396880"
  },
  {
    "start": "1394000",
    "end": "1394000"
  },
  {
    "text": "as i told before we are constrained in size to 512 bytes and at the very start",
    "start": "1396880",
    "end": "1402320"
  },
  {
    "text": "we have the destination address where we want our want to write our payload to then we have some mandatory cleanup",
    "start": "1402320",
    "end": "1409360"
  },
  {
    "text": "steps to prevent the kernel from instantly panicking the moment we deliver the payload and then we have the",
    "start": "1409360",
    "end": "1415120"
  },
  {
    "text": "actual useful part of our payload this could for example be running on shell command as root extracting some data",
    "start": "1415120",
    "end": "1421919"
  },
  {
    "text": "like cryptographic keys or disabling some of the protections like si linux",
    "start": "1421919",
    "end": "1428159"
  },
  {
    "text": "to be able to actually run the attack multiple times we need to augment our",
    "start": "1428159",
    "end": "1433200"
  },
  {
    "text": "payload with some other steps for example we need to restore the code or at least the most critical parts of the",
    "start": "1433200",
    "end": "1439279"
  },
  {
    "text": "code we have overwritten we need to clean up and we need to do a proper return and make sure the probing process",
    "start": "1439279",
    "end": "1446320"
  },
  {
    "text": "fails because that way we can actually trigger the probing multiple time and get code execution multiple times and we",
    "start": "1446320",
    "end": "1453600"
  },
  {
    "text": "can simply make the actual useful part of the payload differ each time we get code execution and for example run",
    "start": "1453600",
    "end": "1460320"
  },
  {
    "text": "different drill shell commands each time we execute our attack",
    "start": "1460320",
    "end": "1465919"
  },
  {
    "start": "1465000",
    "end": "1465000"
  },
  {
    "text": "so what are we then going to execute for example on the device well we can run arbitrary commands as root",
    "start": "1465919",
    "end": "1473200"
  },
  {
    "text": "using a function in the kernel called run command this is a well-known technique to turn an arbitrary code",
    "start": "1473200",
    "end": "1479520"
  },
  {
    "text": "execution in the linux kernel in actually doing something useful however something we noticed is that this",
    "start": "1479520",
    "end": "1485200"
  },
  {
    "text": "function does not function from the interrupt context this is exactly the context the usb hub",
    "start": "1485200",
    "end": "1490880"
  },
  {
    "text": "work you work under so when we actually tried using this function our kernel",
    "start": "1490880",
    "end": "1496159"
  },
  {
    "text": "would panic because it is not valid to be used that way alternatively you can use the system",
    "start": "1496159",
    "end": "1502240"
  },
  {
    "text": "work queue to schedule the start of a new process by pushing this as a work item onto the work queue and then the",
    "start": "1502240",
    "end": "1508960"
  },
  {
    "text": "system work queue will take care of it that the process gets started luckily for us there is already a mechanism in",
    "start": "1508960",
    "end": "1515200"
  },
  {
    "text": "the kernel that does this and that we could simply repurpose there are the functions orderly reboot and orderly",
    "start": "1515200",
    "end": "1521120"
  },
  {
    "text": "shutdown that basically are scheduling the execution of a command through the",
    "start": "1521120",
    "end": "1526400"
  },
  {
    "text": "system work you and then calls the run command function with this command and these commands that get executed are",
    "start": "1526400",
    "end": "1533840"
  },
  {
    "text": "frightable with our specific kernel so we could simply change the command and call the",
    "start": "1533840",
    "end": "1539600"
  },
  {
    "text": "and call the relevant function so what are we then going to execute",
    "start": "1539600",
    "end": "1546000"
  },
  {
    "text": "with our with good privileges well we can of course pick any binary we want in the file system but as we talked before",
    "start": "1546000",
    "end": "1552960"
  },
  {
    "text": "this is a very minimal system and there are effectively no useful binaries in the system",
    "start": "1552960",
    "end": "1558000"
  },
  {
    "text": "um however we are doing a usb attack so why not use a usb stick and that is indeed what we did we simply were",
    "start": "1558000",
    "end": "1564720"
  },
  {
    "text": "putting a reverse shell binary on a usb stick which we then were running from uh",
    "start": "1564720",
    "end": "1571520"
  },
  {
    "text": "using our exploit of course ideally the usb stand gets outer mounted by the system in our case we have to do a",
    "start": "1571520",
    "end": "1578480"
  },
  {
    "text": "little bit more work to manually mount the usb stick on our device and what about sl linux",
    "start": "1578480",
    "end": "1585279"
  },
  {
    "text": "that might prevent you to spawn new processors well we simply had to disable it for example in our case we could set",
    "start": "1585279",
    "end": "1591200"
  },
  {
    "text": "the air forcing variable to zero which is a well-known technique but you could of course also patch the in-memory",
    "start": "1591200",
    "end": "1596640"
  },
  {
    "text": "policy database or use one of the other techniques that i know so we have preferred a demo that is",
    "start": "1596640",
    "end": "1603600"
  },
  {
    "text": "demonstrating our attack we have recorded our demo for the presentation",
    "start": "1603600",
    "end": "1609039"
  },
  {
    "text": "which we now would like to show to you in this demo we would like to demonstrate the attack we have discussed",
    "start": "1609039",
    "end": "1615039"
  },
  {
    "text": "so far we took a several years old smartphone which has a linux kernel that is quite similar to the device we",
    "start": "1615039",
    "end": "1621360"
  },
  {
    "text": "originally exploited using this vulnerability updated to the latest firmware version",
    "start": "1621360",
    "end": "1626799"
  },
  {
    "text": "the phone is not vulnerable to this attack therefore we created and installed a custom kernel that contains",
    "start": "1626799",
    "end": "1632960"
  },
  {
    "text": "the vulnerability as well as a few small modifications such as disabling some vendor-specific kerneling hardening the",
    "start": "1632960",
    "end": "1639840"
  },
  {
    "text": "original device didn't have on the right side we have a netcat instance waiting for incoming",
    "start": "1639840",
    "end": "1645600"
  },
  {
    "text": "connections then we gain code execution in the context of the linux kernel we will use this to launch a reverse shell",
    "start": "1645600",
    "end": "1652399"
  },
  {
    "text": "on the phone that connects to the netcat instance giving us a shell on the phone with root privileges which then allows",
    "start": "1652399",
    "end": "1658480"
  },
  {
    "text": "accessing the phone's data on the left side we are going to run the exploit implemented in python using the",
    "start": "1658480",
    "end": "1665600"
  },
  {
    "text": "face dancer framework first it will connect a midi device that triggers to use after free vulnerability then it",
    "start": "1665600",
    "end": "1673440"
  },
  {
    "text": "disconnects and connects the hrd device delivering the payload with the shell code all of this will happen within a",
    "start": "1673440",
    "end": "1680399"
  },
  {
    "text": "few hundred milliseconds and you will see the usb communication quickly scrolling by",
    "start": "1680399",
    "end": "1685679"
  },
  {
    "text": "the longer these two steps take the lower the probability within the race however we notice that when the device",
    "start": "1685679",
    "end": "1692000"
  },
  {
    "text": "has been idle for several minutes we have a quite high chance of success",
    "start": "1692000",
    "end": "1697840"
  },
  {
    "text": "as you can see on the right side the attack worked and we have an incoming connection showing we successfully got a",
    "start": "1701279",
    "end": "1707919"
  },
  {
    "text": "rootshell on the phone giving us full control over the android environment as this is a demo we will use this to show",
    "start": "1707919",
    "end": "1714960"
  },
  {
    "text": "how this allows unlocking the device by simulating physical input however if the",
    "start": "1714960",
    "end": "1720240"
  },
  {
    "text": "phone is already fully booted and unlocked before exploitation of this vulnerability gives immediate access to",
    "start": "1720240",
    "end": "1726480"
  },
  {
    "text": "all data stored on the device and now we will talk about our discussion points we will first want",
    "start": "1726480",
    "end": "1733279"
  },
  {
    "start": "1732000",
    "end": "1732000"
  },
  {
    "text": "to discuss about the attack challenges as martin mentioned earlier winning the race is one of our main challenges we",
    "start": "1733279",
    "end": "1740320"
  },
  {
    "text": "need a very specific sequence sequence of events um to succeed and this is basically",
    "start": "1740320",
    "end": "1746240"
  },
  {
    "text": "inserting the usb midi device to cause the double f3 disconnecting it connect the other device to uh deliver the",
    "start": "1746240",
    "end": "1752880"
  },
  {
    "text": "payload so um if we are dealing if with slabs with low",
    "start": "1752880",
    "end": "1759200"
  },
  {
    "text": "activity we will have a high chance of winning the race whereas if we would be dealing with high activity slabs that",
    "start": "1759200",
    "end": "1765679"
  },
  {
    "text": "will be more complicated so that's something to take into account the second thing is the cache behavior since",
    "start": "1765679",
    "end": "1771120"
  },
  {
    "text": "we chose to override the kernel's code caches could make it hard to predict",
    "start": "1771120",
    "end": "1776240"
  },
  {
    "text": "where exactly we are taking control this could be mitigated of course by adding an obsolete",
    "start": "1776240",
    "end": "1782480"
  },
  {
    "text": "but you need to have space to fit it in your payload slot and the third thing we wanted to discuss",
    "start": "1782480",
    "end": "1788720"
  },
  {
    "text": "is about exploit mitigation so what if the kernel has address-based layout randomization this is a hurdle that we",
    "start": "1788720",
    "end": "1795520"
  },
  {
    "start": "1790000",
    "end": "1790000"
  },
  {
    "text": "will need to overcome so either finding another vulnerability to leak a pointer",
    "start": "1795520",
    "end": "1801120"
  },
  {
    "text": "or an address of the kernel so we can then dynamically calculate our addresses or we could also choose to brute force",
    "start": "1801120",
    "end": "1807279"
  },
  {
    "text": "it but this approach has the downside that of course the kernel will crash if we don't hit the correct address and in",
    "start": "1807279",
    "end": "1814640"
  },
  {
    "text": "some cases this might not be acceptable the second thing are all kind of protections code and data can be",
    "start": "1814640",
    "end": "1821520"
  },
  {
    "text": "protected so then if that happens we need to look for other attack paths either a data only attack or also we can",
    "start": "1821520",
    "end": "1827840"
  },
  {
    "text": "think of for example trying to override privileged process code from the kernel's fist map",
    "start": "1827840",
    "end": "1835520"
  },
  {
    "text": "which would allow us to gain control as well and the third point is all kind of heap",
    "start": "1835520",
    "end": "1843279"
  },
  {
    "text": "hardening techniques so for example the free list metadata could be checked or the allocations",
    "start": "1843279",
    "end": "1850559"
  },
  {
    "text": "could be randomized those are all factors that could make our attack impossible to execute",
    "start": "1850559",
    "end": "1857760"
  },
  {
    "start": "1857000",
    "end": "1857000"
  },
  {
    "text": "if we talk about applicability we think that similar bugs in a lower activity slab could be exploited using our",
    "start": "1857760",
    "end": "1864799"
  },
  {
    "text": "methods but of course the precise steps of the exploitation will really depend on the device there are different",
    "start": "1864799",
    "end": "1870799"
  },
  {
    "text": "factors to consider such as the architecture the device configuration vendor specific customizations and the",
    "start": "1870799",
    "end": "1877760"
  },
  {
    "text": "exploit mitigations about our exploit requirements",
    "start": "1877760",
    "end": "1882799"
  },
  {
    "start": "1880000",
    "end": "1880000"
  },
  {
    "text": "as andres exploit we of course need to have physical access to the device",
    "start": "1882799",
    "end": "1888399"
  },
  {
    "text": "and we need this vulnerable driver to be enabled with our approach we managed to",
    "start": "1888399",
    "end": "1894080"
  },
  {
    "text": "remove two of the prerequisites because we don't need to have unprivileged code execution since we are doing everything",
    "start": "1894080",
    "end": "1900399"
  },
  {
    "text": "from the usb subsystem that runs in the interrupt context of the kernel and we also don't need any other interface we",
    "start": "1900399",
    "end": "1907760"
  },
  {
    "text": "are just using the elements we have with the usb protocol stack",
    "start": "1907760",
    "end": "1912960"
  },
  {
    "text": "but as we mentioned several times already we do need a low activity slab because",
    "start": "1912960",
    "end": "1918880"
  },
  {
    "text": "for us um it's not that easy um to keep bashing the",
    "start": "1918880",
    "end": "1925519"
  },
  {
    "text": "heap until we win the race so this is a prerequisite that's quite important um and now we would like to conclude our",
    "start": "1925519",
    "end": "1932480"
  },
  {
    "start": "1931000",
    "end": "1931000"
  },
  {
    "text": "talk with three main takeaways the first takeaway is that even though vulnerabilities might be",
    "start": "1932480",
    "end": "1938880"
  },
  {
    "text": "easy to fix as we showed it's not that easy to propagate all these fixes to devices that are already",
    "start": "1938880",
    "end": "1945679"
  },
  {
    "text": "deployed on the field another thing we learned is that investing time in your debugging",
    "start": "1945679",
    "end": "1950960"
  },
  {
    "text": "environment is very important so this really allowed us to see to the detail what was going on with our",
    "start": "1950960",
    "end": "1957679"
  },
  {
    "text": "exploit and actually it was quite easy to port it to the actual device once we",
    "start": "1957679",
    "end": "1962880"
  },
  {
    "text": "have done all the work of replicating the environment and the last thing is that usb attacks",
    "start": "1962880",
    "end": "1969120"
  },
  {
    "text": "are quite powerful and in this presentation we demonstrated how we",
    "start": "1969120",
    "end": "1974480"
  },
  {
    "text": "could compromise a device by just using the usb protocol",
    "start": "1974480",
    "end": "1979840"
  },
  {
    "text": "sometimes it might even be your only attack vector and with this we would like to conclude the presentation and ask whether there",
    "start": "1979840",
    "end": "1986880"
  },
  {
    "text": "are any questions [Music]",
    "start": "1986880",
    "end": "1999319"
  },
  {
    "text": "you",
    "start": "1999840",
    "end": "2001919"
  }
]