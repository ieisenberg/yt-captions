[
  {
    "text": "so welcome everyone to our presentation today we are going to present star to league forwarding there and back again",
    "start": "799",
    "end": "7440"
  },
  {
    "text": "um my name is claudio canella i'm a phd student at guards university of technology you can also find me on twitter or send",
    "start": "7440",
    "end": "13679"
  },
  {
    "text": "me an email if you have any questions my name is lucas gina i'm also a ph.d",
    "start": "13679",
    "end": "18720"
  },
  {
    "text": "student in graz don't be thrown off by the shirt some below this later you're exactly where you're meant to be",
    "start": "18720",
    "end": "24480"
  },
  {
    "text": "and my name is michael schwarz i'm a faculty at sisbe helmholtz center for information",
    "start": "24480",
    "end": "29599"
  },
  {
    "text": "security and you can reach all of us on twitter via email if you have any more questions",
    "start": "29599",
    "end": "36239"
  },
  {
    "text": "more than you could ask after this talk so what is this talk about",
    "start": "36239",
    "end": "42800"
  },
  {
    "text": "so we want to figure out in this talk how stores and loads are handled on",
    "start": "42800",
    "end": "48399"
  },
  {
    "text": "modern micro architectures what happens if we load a value from a location where we previously",
    "start": "48399",
    "end": "54239"
  },
  {
    "text": "stored some value we also want to look at the meltdown mitigations and see what they changed in this store",
    "start": "54239",
    "end": "61120"
  },
  {
    "text": "and load path in the micro architecture and see whether we can figure out some new",
    "start": "61120",
    "end": "67119"
  },
  {
    "text": "mechanisms from that that allows for some new and of course we also want to mitigate",
    "start": "67119",
    "end": "74000"
  },
  {
    "text": "those attacks that we find so we'll also talk about some clever mitigations here",
    "start": "74000",
    "end": "81040"
  },
  {
    "text": "okay so first we need a bit of background so the manual model you can have as a",
    "start": "81759",
    "end": "86799"
  },
  {
    "text": "programmer from the cpu is fairly simple so instructions are executed in program order just as you",
    "start": "86799",
    "end": "93119"
  },
  {
    "text": "expect just as you write them down the pipeline stalls when the stage is not ready",
    "start": "93119",
    "end": "98799"
  },
  {
    "text": "and if data isn't available we also have to wait so this can look something like this",
    "start": "98799",
    "end": "105600"
  },
  {
    "text": "where we first fetch into the l1 instruction cache we decode the instructions then we",
    "start": "105600",
    "end": "113200"
  },
  {
    "text": "execute them if necessary we access that we perform accesses to memory",
    "start": "113200",
    "end": "119680"
  },
  {
    "text": "and finally we write back into the architectural register file",
    "start": "119680",
    "end": "125119"
  },
  {
    "text": "i always thought that microarchitectures are much more complex than that well that is a very simple",
    "start": "125119",
    "end": "131360"
  },
  {
    "text": "micro architecture and in general in modern architectures you want more performance",
    "start": "131360",
    "end": "137280"
  },
  {
    "text": "and more performance means super scalar and superscalar means that we do loads",
    "start": "137280",
    "end": "142640"
  },
  {
    "text": "of things in parallel so the question here is if we don't have a dependency between",
    "start": "142640",
    "end": "148239"
  },
  {
    "text": "different instructions and we have many execution ports available why don't we do loads of things in",
    "start": "148239",
    "end": "153760"
  },
  {
    "text": "parallel so we execute them in whatever order is",
    "start": "153760",
    "end": "159440"
  },
  {
    "text": "is convenient and supports are available and importantly we retire them in the",
    "start": "159440",
    "end": "165200"
  },
  {
    "text": "order that they're in the program so from the outside from programmer's view everything still stays the same",
    "start": "165200",
    "end": "171519"
  },
  {
    "text": "so now an interesting situation is when a fault happens and there are already newer instructions",
    "start": "171519",
    "end": "179440"
  },
  {
    "text": "in flight that are already calculating on data what do we do with them so for this the processor tracks",
    "start": "179440",
    "end": "186640"
  },
  {
    "text": "the architectural changes that instructions would make and if there is a fault it undoes the",
    "start": "186640",
    "end": "192400"
  },
  {
    "text": "out-of-order effects and we then call those instructions transient",
    "start": "192400",
    "end": "198319"
  },
  {
    "text": "that's pretty smart yeah it is and those transient instructions don't",
    "start": "198319",
    "end": "203760"
  },
  {
    "text": "leave any architectural trace they're basically gone so at this point you might wonder",
    "start": "203760",
    "end": "210239"
  },
  {
    "text": "if they don't if they're undone if they don't leave any trace what are they even for what's the point",
    "start": "210239",
    "end": "216239"
  },
  {
    "text": "of them or what can we do with them more as an attacker and so i said remember i said",
    "start": "216239",
    "end": "222080"
  },
  {
    "text": "the processor tracks the architectural changes and reverts those it does not track microarchitectural",
    "start": "222080",
    "end": "229360"
  },
  {
    "text": "changes so we can encode data that we calculate during uh transient",
    "start": "229360",
    "end": "236159"
  },
  {
    "text": "execution into a microarchitectural state do you have an example for",
    "start": "236159",
    "end": "241680"
  },
  {
    "text": "microarchitectural state yes i don't know what you're talking about yes i do one of those stateful",
    "start": "241680",
    "end": "246959"
  },
  {
    "text": "microarchitectural elements is the cache that's a simple way",
    "start": "246959",
    "end": "252400"
  },
  {
    "text": "and so ah the state in the cache is if a cache line is present or not and so",
    "start": "252400",
    "end": "258479"
  },
  {
    "text": "let's have a look at an example we access a variable and try to load it into a register",
    "start": "258479",
    "end": "264080"
  },
  {
    "text": "and so the first time we try this the cpu will have a miss and it will have to load from ram",
    "start": "264080",
    "end": "269919"
  },
  {
    "text": "we'll get a response and it will be cached at that point and the next time we try this slow yeah",
    "start": "269919",
    "end": "276639"
  },
  {
    "text": "and the next time we try this we get a cache hit and that'll be much faster",
    "start": "276639",
    "end": "283759"
  },
  {
    "text": "so the dramax is very slow the non-drm the cached access no surprise here it's much faster and",
    "start": "283759",
    "end": "290960"
  },
  {
    "text": "this difference is very very clear and we can determine this with high reliability",
    "start": "290960",
    "end": "297360"
  },
  {
    "text": "so in the future of this talk when we talk about transient transient instructions and their effects",
    "start": "297360",
    "end": "305039"
  },
  {
    "text": "this is how we generally see them architecturally how we make use of them we encode them in the",
    "start": "305039",
    "end": "310320"
  },
  {
    "text": "cache so when we look when we look at the how",
    "start": "310320",
    "end": "315680"
  },
  {
    "text": "core is made up we've talked a bit about the execution engine the front end so what's left is the memory subsystem",
    "start": "315680",
    "end": "322720"
  },
  {
    "text": "and so here first we have a load buffer and the store buffer connected to the load ports and the store ports in the execution engine",
    "start": "322720",
    "end": "329759"
  },
  {
    "text": "as a next level we have the l1 data cache with a tlb and light field buffer with a second",
    "start": "329759",
    "end": "336720"
  },
  {
    "text": "level with the l2 cache and another tlb and then off core we have the l3 cache",
    "start": "336720",
    "end": "342080"
  },
  {
    "text": "and the ram finally and so these three caches are what we can use as just that to encode our transient uh our transient",
    "start": "342080",
    "end": "349680"
  },
  {
    "text": "data so wow that that looks complicated",
    "start": "349680",
    "end": "356000"
  },
  {
    "text": "yeah so why don't you tell us a bit more about the store buffer",
    "start": "356000",
    "end": "361039"
  },
  {
    "text": "okay so let's see what actually happens if we have some data stores and data",
    "start": "361039",
    "end": "367199"
  },
  {
    "text": "loads that we are executing that has to go through all this machinery you just explained before",
    "start": "367199",
    "end": "373520"
  },
  {
    "text": "so if we move some data to the memory so if we store some data then what",
    "start": "373520",
    "end": "379199"
  },
  {
    "text": "happens is that in the execution unit we have the store operation it has to store some data and for that it uses",
    "start": "379199",
    "end": "385759"
  },
  {
    "text": "the store buffer the store buffer helps that it does not have to wait for the store to actually",
    "start": "385759",
    "end": "391039"
  },
  {
    "text": "complete it just throws it in there and then the store buffer handles the rest of it and the store buffer",
    "start": "391039",
    "end": "398080"
  },
  {
    "text": "then can go to the l1 store the data in the l1 if there's space in l1",
    "start": "398080",
    "end": "403440"
  },
  {
    "text": "and in the meantime the execution unit can already continue with some other instruction",
    "start": "403440",
    "end": "408720"
  },
  {
    "text": "you've said that before with this out of order execution so now we do something maybe stupid",
    "start": "408720",
    "end": "416080"
  },
  {
    "text": "we write some data to memory and then immediately afterwards we read from this memory address the",
    "start": "416080",
    "end": "422479"
  },
  {
    "text": "data back that we just wrote we of course know what this data is but what does the cpu do",
    "start": "422479",
    "end": "429039"
  },
  {
    "text": "so the cpu for loading a data it uses this low data part in the execution unit",
    "start": "429039",
    "end": "434800"
  },
  {
    "text": "and it uses a load buffer where it also has a kind of a queue which stores what values to load and it",
    "start": "434800",
    "end": "442000"
  },
  {
    "text": "knows this address it has to load that and usually it would go to the l1 memory check that l1 memory is",
    "start": "442000",
    "end": "449520"
  },
  {
    "text": "this data there if there's a hit then retrieve it otherwise go to the l2 l3",
    "start": "449520",
    "end": "454800"
  },
  {
    "text": "or dram but the thing is cpus are quite smart nowadays",
    "start": "454800",
    "end": "461039"
  },
  {
    "text": "so what this additionally does it checks whether somebody some address was",
    "start": "461039",
    "end": "468160"
  },
  {
    "text": "already stored before some data stored to the same address so if there's a match between the store address and the",
    "start": "468160",
    "end": "474639"
  },
  {
    "text": "address that we load we can do a shortcut we don't have to wait for the memory so we directly take it from the store",
    "start": "474639",
    "end": "481759"
  },
  {
    "text": "buffer and do the store to load forwarding to this load so this is a lot faster so we have this",
    "start": "481759",
    "end": "489360"
  },
  {
    "text": "this data that goes there into the execution unit memory substance subsystem and then back again before it",
    "start": "489360",
    "end": "496240"
  },
  {
    "text": "even reaches the memory subsystem that the l1 or l2 so this makes it a lot faster",
    "start": "496240",
    "end": "503840"
  },
  {
    "text": "and is a nice optimization that we have in modern cpus of course we can optimize that further",
    "start": "503840",
    "end": "511840"
  },
  {
    "text": "so we don't have to check for a full match we can optimize that even more so we can do something like a",
    "start": "511840",
    "end": "520000"
  },
  {
    "text": "normal comparison and if it's true we do the forwarding and this can be",
    "start": "520000",
    "end": "525120"
  },
  {
    "text": "okay so it's true positive everything happens as it should we only forward the",
    "start": "525120",
    "end": "531040"
  },
  {
    "text": "things that actually match maybe we also have some errors in the comparison there because things go",
    "start": "531040",
    "end": "537519"
  },
  {
    "text": "really fast and we might have other stores and loads in between so maybe we also have some true",
    "start": "537519",
    "end": "544640"
  },
  {
    "text": "negatives where we don't have some uh something there and we're also not we're",
    "start": "544640",
    "end": "552320"
  },
  {
    "text": "not matching anything we're not forwarding anything this is also fine that's true negatives",
    "start": "552320",
    "end": "558080"
  },
  {
    "text": "and this is basically all true positives and true negatives that we exploit in this talk here wait a second",
    "start": "558080",
    "end": "565839"
  },
  {
    "text": "that sounds familiar isn't there a second attack that does exactly the same isn't there fallout",
    "start": "565839",
    "end": "572800"
  },
  {
    "text": "yes because these are not the only two cases in the store buffer we can also have some let's say kind of",
    "start": "572800",
    "end": "580080"
  },
  {
    "text": "errors or optimizations in there like false positives so we have",
    "start": "580080",
    "end": "585839"
  },
  {
    "text": "addresses that are actually not the same but the data is forwarded so this one is exploited in fallout",
    "start": "585839",
    "end": "594080"
  },
  {
    "text": "but already fixed in modern cpus and then also the other direction like",
    "start": "594080",
    "end": "600080"
  },
  {
    "text": "false negatives the address is actually the same it should forward the data but it doesn't do so and this effect is",
    "start": "600080",
    "end": "607760"
  },
  {
    "text": "exploited inspector stl so all these store buffer magic in there",
    "start": "607760",
    "end": "615279"
  },
  {
    "text": "are optimizations for the transient execution so for the parts we don't see if this",
    "start": "615279",
    "end": "620959"
  },
  {
    "text": "optimization is wrong architecturally we don't care because everything is undone as luke has",
    "start": "620959",
    "end": "627920"
  },
  {
    "text": "explained before so we will never see that and our attack",
    "start": "627920",
    "end": "634480"
  },
  {
    "text": "here just relies on the store buffer to do everything correctly so correct matching correct",
    "start": "634480",
    "end": "641440"
  },
  {
    "text": "forwarding on the same addresses interesting part here that we are going",
    "start": "641440",
    "end": "648240"
  },
  {
    "text": "to exploit is that stores can only be forwarded",
    "start": "648240",
    "end": "653279"
  },
  {
    "text": "if we store something to a valid address of course that sounds kind of intuitive",
    "start": "653279",
    "end": "658800"
  },
  {
    "text": "we can't store somewhere that's not a valid location so this is also described",
    "start": "658800",
    "end": "664079"
  },
  {
    "text": "in the intel manual so it says like the store execution phase it fills the store buffer with linear",
    "start": "664079",
    "end": "670399"
  },
  {
    "text": "and physical address and data and one store address and data are known the store data",
    "start": "670399",
    "end": "676160"
  },
  {
    "text": "can be forwarded to the following load operations that need it so if everything is known then we can",
    "start": "676160",
    "end": "682160"
  },
  {
    "text": "forward this data to them to the load and what does it mean with valid and",
    "start": "682160",
    "end": "689519"
  },
  {
    "text": "invalid a virtual address that has an actual physical backing to it so we have some data page where we can",
    "start": "689519",
    "end": "697279"
  },
  {
    "text": "really write to it then this is a valid address and then we can",
    "start": "697279",
    "end": "702399"
  },
  {
    "text": "use that the interesting thing that we already know from meltdown",
    "start": "702399",
    "end": "707600"
  },
  {
    "text": "is that permission checks on intel cpus are a bit lazy and they're not done",
    "start": "707600",
    "end": "714079"
  },
  {
    "text": "up front but at some point in between when we already do that so that's what that was exploited in a",
    "start": "714079",
    "end": "720240"
  },
  {
    "text": "meltdown attack and we want to exploit the same thing",
    "start": "720240",
    "end": "726079"
  },
  {
    "text": "what happens with distort load forwarding when we store some data to an address",
    "start": "726079",
    "end": "731120"
  },
  {
    "text": "and then read it back but this address is inaccessible so it's still valid",
    "start": "731120",
    "end": "737839"
  },
  {
    "text": "there's a physical page behind it but maybe it belongs to the kernel so we couldn't access it",
    "start": "737839",
    "end": "743200"
  },
  {
    "text": "does this mechanism still trigger so let's try it's not that difficult we",
    "start": "743200",
    "end": "749839"
  },
  {
    "text": "write some value onto our kernel address that of course gives us a fault segmentation fault",
    "start": "749839",
    "end": "756160"
  },
  {
    "text": "but out of order execution instructions are still executed so in this out of order execution we",
    "start": "756160",
    "end": "763680"
  },
  {
    "text": "read the same address back and code it in the cache as lucas explained before",
    "start": "763680",
    "end": "769120"
  },
  {
    "text": "and see if we get the same value back if so we know that the store to load",
    "start": "769120",
    "end": "776079"
  },
  {
    "text": "forwarding that's actually working although there was a fault so that's nice no but",
    "start": "776079",
    "end": "781839"
  },
  {
    "text": "what does that get us what can we do with this that's a good question i bet you've",
    "start": "781839",
    "end": "788079"
  },
  {
    "text": "heard about address-based layout randomization especially in the kernel",
    "start": "788079",
    "end": "793440"
  },
  {
    "text": "we have that so we randomize all the parts in the kernel the modules and the kernel image and every time we",
    "start": "793440",
    "end": "799760"
  },
  {
    "text": "put it's at a different location so the modules that are different locations the kernel image this is a different",
    "start": "799760",
    "end": "804800"
  },
  {
    "text": "location so we don't know where the kernel is and so we can't mount reliable attacks on the kernel",
    "start": "804800",
    "end": "811839"
  },
  {
    "text": "because we don't know where this the image and the data is located",
    "start": "811839",
    "end": "818959"
  },
  {
    "text": "okay but with this like this explanation i can i think i know what your attack is that",
    "start": "818959",
    "end": "824959"
  },
  {
    "text": "you want to do so i think it's called data bound we can see here we have again a memory",
    "start": "824959",
    "end": "830240"
  },
  {
    "text": "subsystem with the store buffer and the load buffer we have a little bit of code and the blue square here indicates the location of",
    "start": "830240",
    "end": "836880"
  },
  {
    "text": "the kernel within memory and mem here is just an array where we store",
    "start": "836880",
    "end": "842639"
  },
  {
    "text": "data and if we time this right now using the primitive that lucas told us",
    "start": "842639",
    "end": "848320"
  },
  {
    "text": "then we just see the timing is always the same because we need to fetch it from dram right so now what we do with this",
    "start": "848320",
    "end": "856800"
  },
  {
    "text": "stored load forwarding logic is we simply write to a kernel address some value in our case the value x and",
    "start": "856800",
    "end": "864079"
  },
  {
    "text": "later on dereference it use the value that we get back from the kernel address as an index to our memory and then we",
    "start": "864079",
    "end": "871360"
  },
  {
    "text": "should observe this x if distorted load forging logic works so let us try this so in the",
    "start": "871360",
    "end": "878880"
  },
  {
    "text": "beginning there is nothing met so as michel said we cannot write this there's no store buffer entry for this",
    "start": "878880",
    "end": "885760"
  },
  {
    "text": "so we don't find anything we can repeat this and we never get a value back but now",
    "start": "885760",
    "end": "892320"
  },
  {
    "text": "we find the location where the kernel is actually met and suddenly we can write to this address we",
    "start": "892320",
    "end": "898560"
  },
  {
    "text": "get a stop of entry when we load then from this address we get distorted load forwarding",
    "start": "898560",
    "end": "903920"
  },
  {
    "text": "effect we get it into the load buffer and the data is forwarded and used in subsequent instructions for",
    "start": "903920",
    "end": "910800"
  },
  {
    "text": "the access to mem and if we then use our primitive again we can suddenly see that the",
    "start": "910800",
    "end": "916399"
  },
  {
    "text": "axis time for x is much slower and slower and we know that there is something met",
    "start": "916399",
    "end": "921839"
  },
  {
    "text": "our kernel is there so the question then is what if an address is valid",
    "start": "921839",
    "end": "927040"
  },
  {
    "text": "but unknown so we know it has a physical backing but it's maybe not in we don't know the",
    "start": "927040",
    "end": "933120"
  },
  {
    "text": "physical address yet because it has not been used recently so what if we simply repeat data bounds",
    "start": "933120",
    "end": "940480"
  },
  {
    "text": "we can see here if we have unmapped regions we have mapped regions as well if we get our",
    "start": "940480",
    "end": "946639"
  },
  {
    "text": "data and in the first try of data bounds so it's forwarded on the first try we know that this in the dlb so it has",
    "start": "946639",
    "end": "953199"
  },
  {
    "text": "been recently used because we know the physical address if we get it on the second try we know it's",
    "start": "953199",
    "end": "960160"
  },
  {
    "text": "valid but it's not in the dlb and in the final case we don't get any",
    "start": "960160",
    "end": "965759"
  },
  {
    "text": "forwarding no matter how often we try it then we can infer that this address is unmapped it's not valid",
    "start": "965759",
    "end": "973360"
  },
  {
    "text": "that's a nice observation claudio but i don't think it has any security implications i mean",
    "start": "973360",
    "end": "979680"
  },
  {
    "text": "what are you going to do that we already broke kslr what are going with that additional",
    "start": "979680",
    "end": "985519"
  },
  {
    "text": "information no i think we can do something i think there's an attack primitive here and all",
    "start": "985519",
    "end": "991120"
  },
  {
    "text": "good attack primitives need a name so i think we're going to call it fetch and bounce so now we aren't agnostic of",
    "start": "991120",
    "end": "997360"
  },
  {
    "text": "a tlb anymore we know it's there and we use it so in this case we see four kernel pages that are all",
    "start": "997360",
    "end": "1005279"
  },
  {
    "text": "mapped and now what we're gonna do is we're gonna do it again but with fetch and bounce we only access",
    "start": "1005279",
    "end": "1011440"
  },
  {
    "text": "once each we don't repeat and so when we do this for the first address we can see that we got a lookup",
    "start": "1011440",
    "end": "1017680"
  },
  {
    "text": "in a tlb there's nothing there and so when we try to store we can't get a valid store buffer entry",
    "start": "1017680",
    "end": "1024160"
  },
  {
    "text": "and so we also can't get forwarding and so now there's a tlb entry but it's already too late",
    "start": "1024160",
    "end": "1029678"
  },
  {
    "text": "we've moved on to the next address and the same thing here tlb is entry empty there's no entry",
    "start": "1029679",
    "end": "1036558"
  },
  {
    "text": "again we don't get a store-bought entry so now but for his third and uh third address there is",
    "start": "1036559",
    "end": "1042798"
  },
  {
    "text": "already a tlb entry and so when we try it now we get a sob of entry we get forwarding and in our next",
    "start": "1042799",
    "end": "1050000"
  },
  {
    "text": "address we get the x back and so now what we've learned is that there that recently this page",
    "start": "1050000",
    "end": "1056240"
  },
  {
    "text": "was actually used by the kernel and so that's a new attack primitive here for the last page again it's not",
    "start": "1056240",
    "end": "1062880"
  },
  {
    "text": "mapped and so we get nothing back okay so what can we do with this we can",
    "start": "1062880",
    "end": "1069919"
  },
  {
    "text": "observe kernel activity and more specifically for example something like the modules we can check which module is used and",
    "start": "1069919",
    "end": "1077600"
  },
  {
    "text": "which code page in it is used so as an example we use a bluetooth module and maybe we",
    "start": "1077600",
    "end": "1083760"
  },
  {
    "text": "connect our phone to it and play some music and then we can detect when there is some activity here",
    "start": "1083760",
    "end": "1092159"
  },
  {
    "text": "okay so does that really work it does really work or is that just theory it seems a little bit far-fetched",
    "start": "1093200",
    "end": "1100080"
  },
  {
    "text": "so can you show us that this works because i don't okay okay okay all right",
    "start": "1100080",
    "end": "1106000"
  },
  {
    "text": "let's let's go into detail a bit more so the first step first thing you have to solve is we don't actually know where the modules",
    "start": "1106000",
    "end": "1111760"
  },
  {
    "text": "are because they're also hidden by kslr and so unlike the kernel we might be able to",
    "start": "1111760",
    "end": "1118640"
  },
  {
    "text": "find them but we need to do some more to identify them and so what we do is here in this demo we scan the entire",
    "start": "1118640",
    "end": "1127520"
  },
  {
    "text": "module address space as you can see that's very quick we identify contiguous pages of memory and",
    "start": "1127520",
    "end": "1133600"
  },
  {
    "text": "we can infer that those are modules and we can read the size of the module",
    "start": "1133600",
    "end": "1138799"
  },
  {
    "text": "with that and so now we can match unique sizes to modules with unique sizes",
    "start": "1138799",
    "end": "1144799"
  },
  {
    "text": "so here we've identified three we're going to check in proc modules if the addresses are correct so we're",
    "start": "1144799",
    "end": "1150799"
  },
  {
    "text": "going to check for bluetooth that looks correct we're going to check",
    "start": "1150799",
    "end": "1156000"
  },
  {
    "text": "for the wi-fi module that we tried to identify that looks good as well",
    "start": "1156000",
    "end": "1161039"
  },
  {
    "text": "and lastly the thunderbolt module we also correctly identified and you can also see that the font sizes",
    "start": "1161039",
    "end": "1168480"
  },
  {
    "text": "match because of sizes again are how we identify the modules so this doesn't work for modules of the",
    "start": "1168480",
    "end": "1173840"
  },
  {
    "text": "same size so that's the first step we know where our target module is",
    "start": "1173840",
    "end": "1179520"
  },
  {
    "text": "in this case the bluetooth module so what you've basically shown us now is that this is data bound this is data bounce",
    "start": "1179520",
    "end": "1186240"
  },
  {
    "text": "right this is later bounce you still haven't shown us that fetching bounce works correct let's use faction bonds with this",
    "start": "1186240",
    "end": "1192080"
  },
  {
    "text": "now we know where the module is we know an address let's say some page in a bluetooth module we want to attack and so now what we're going to",
    "start": "1192080",
    "end": "1198880"
  },
  {
    "text": "do is we're going to sample uh we're going to sample with fetch and bounce this page in a bluetooth module",
    "start": "1198880",
    "end": "1205120"
  },
  {
    "text": "then we're gonna clear the tlb for this core because they're the tlbs are per core and not shared",
    "start": "1205120",
    "end": "1211120"
  },
  {
    "text": "then we're gonna jump to the next core and do the same thing and so with this we move through the cores in order and give the bluetooth",
    "start": "1211120",
    "end": "1217600"
  },
  {
    "text": "module time to work and then we sample again and so this is what it looks like in action",
    "start": "1217600",
    "end": "1224480"
  },
  {
    "text": "we get hit rate and you can see as soon as we hit play",
    "start": "1224799",
    "end": "1229919"
  },
  {
    "text": "on the right in the phone we get correctly identified once",
    "start": "1229919",
    "end": "1235120"
  },
  {
    "text": "and so for the bluetooth module something we've noticed is that there is some after activity",
    "start": "1235120",
    "end": "1240720"
  },
  {
    "text": "so now we get zeros again we're gonna start and we get a very sharp identification",
    "start": "1240720",
    "end": "1247679"
  },
  {
    "text": "here again so you can see right now we have about one percent of detection",
    "start": "1247679",
    "end": "1253520"
  },
  {
    "text": "which is because of that's how often we sample so again you can see that there's the",
    "start": "1253520",
    "end": "1259919"
  },
  {
    "text": "temporary resolution for first detection is fairly good in this case we just don't",
    "start": "1259919",
    "end": "1265520"
  },
  {
    "text": "do this very often and you can see it is all very stable and",
    "start": "1265520",
    "end": "1271679"
  },
  {
    "text": "in general from the from the music you get this is a very important plc this is",
    "start": "1271679",
    "end": "1277039"
  },
  {
    "text": "very dramatic right so",
    "start": "1277039",
    "end": "1284640"
  },
  {
    "text": "it works okay yeah i believe all right we can do something with that that's a",
    "start": "1284720",
    "end": "1290159"
  },
  {
    "text": "great demo thanks so thanks we have something else as well though another variant but for this we're going",
    "start": "1290159",
    "end": "1296400"
  },
  {
    "text": "to have to go a bit back in time and mikhail is going to tell you a bit more about that",
    "start": "1296400",
    "end": "1302000"
  },
  {
    "text": "exactly i was just thinking so you talked about out of order transient executions and stuff",
    "start": "1302000",
    "end": "1307919"
  },
  {
    "text": "what if we actually combine that with another transient execution attack that",
    "start": "1307919",
    "end": "1313120"
  },
  {
    "text": "we know spectre so if you test short recap for spectre it's about",
    "start": "1313120",
    "end": "1318960"
  },
  {
    "text": "um the variant one is about bounce and and predicting uh bounds of accesses and if",
    "start": "1318960",
    "end": "1324880"
  },
  {
    "text": "the cpu predicts that something is in bounds if you do an imbalance check",
    "start": "1324880",
    "end": "1329919"
  },
  {
    "text": "then everything is faster because it was predicted correctly um if the miss if there was a",
    "start": "1329919",
    "end": "1334960"
  },
  {
    "text": "misprediction it might be a bit slower but it's still okay if it predicts it's not in bounce and is",
    "start": "1334960",
    "end": "1340320"
  },
  {
    "text": "actually not in bounce it's also fine the prediction was correct but yes one corner case",
    "start": "1340320",
    "end": "1346320"
  },
  {
    "text": "that is actually exploitable the spectral attack so if the cpu predicts that something is in bounds but it's not",
    "start": "1346320",
    "end": "1354480"
  },
  {
    "text": "inbounds so that means we can transiently access data out of bounds",
    "start": "1354480",
    "end": "1359760"
  },
  {
    "text": "of an array and if you look at the simple if condition here that checks whether an index a given index",
    "start": "1359760",
    "end": "1366000"
  },
  {
    "text": "is smaller than four and then x is an array that has four elements and after this array",
    "start": "1366000",
    "end": "1371919"
  },
  {
    "text": "there's some secret data in memory that we shouldn't be able to access architecturally because we have this bounce check here",
    "start": "1371919",
    "end": "1378640"
  },
  {
    "text": "in the if condition and uses this data here as an index for some [Music]",
    "start": "1378640",
    "end": "1384720"
  },
  {
    "text": "memory for example a font file here to do pretty printing of this letter that we get from the",
    "start": "1384720",
    "end": "1390720"
  },
  {
    "text": "array so if we look at that the first time the cpu has no idea if this condition will",
    "start": "1390720",
    "end": "1396720"
  },
  {
    "text": "be true or not it speculates something maybe it speculates for it's wrong okay nothing happens then if we actually",
    "start": "1396720",
    "end": "1404880"
  },
  {
    "text": "execute that on the cpu the cpu sees oh this condition was actually true",
    "start": "1404880",
    "end": "1409919"
  },
  {
    "text": "because 0 is smaller than 4 and it loads the first value from memory it uses that to index this",
    "start": "1409919",
    "end": "1416240"
  },
  {
    "text": "font file that we have here and all of that is put transparently into the cache",
    "start": "1416240",
    "end": "1423279"
  },
  {
    "text": "and the next execution we have the next index one is smaller than four the cpu is like",
    "start": "1423279",
    "end": "1428480"
  },
  {
    "text": "oh it was smaller before it was true before so let's speculate that it's also true now it speculates that it has to",
    "start": "1428480",
    "end": "1435919"
  },
  {
    "text": "get the data from memory it does that looks it up in this font file everything is put in the cache and when",
    "start": "1435919",
    "end": "1443279"
  },
  {
    "text": "it actually executes then architecturally it sees oh my prediction was correct everything is fine nothing has to be",
    "start": "1443279",
    "end": "1449520"
  },
  {
    "text": "undone perfect super fast and it continues like that for the next index and for the next",
    "start": "1449520",
    "end": "1455120"
  },
  {
    "text": "index and then we get to index four and four is not smaller than four",
    "start": "1455120",
    "end": "1460240"
  },
  {
    "text": "but the cpu is like yeah it was always through this condition will be true as well this time so it",
    "start": "1460240",
    "end": "1466480"
  },
  {
    "text": "starts fetching memory that's actually out of bounds of the array so it shouldn't be accessible and takes",
    "start": "1466480",
    "end": "1472880"
  },
  {
    "text": "that looks it up in the font file puts it into the cache and there we have our problem we have",
    "start": "1472880",
    "end": "1479679"
  },
  {
    "text": "something in the cache that correlates to the secret data in memory that we are not supposed",
    "start": "1479679",
    "end": "1485200"
  },
  {
    "text": "to access and as lucas said before we have this attacks that can measure",
    "start": "1485200",
    "end": "1492240"
  },
  {
    "text": "the timings and also audio exploited that and we can see that from the cache and infer the secrets from that",
    "start": "1492240",
    "end": "1500400"
  },
  {
    "text": "and now we could also combine that with our fetch and bounce method so if we",
    "start": "1500400",
    "end": "1505760"
  },
  {
    "text": "have this bounce check here this condition and then we could access something based on",
    "start": "1505760",
    "end": "1513679"
  },
  {
    "text": "this index here then it's not only put into the cache but also into the tlb",
    "start": "1513679",
    "end": "1519919"
  },
  {
    "text": "so then we can use fetch and pounds to iterate over the memory instead of",
    "start": "1519919",
    "end": "1525840"
  },
  {
    "text": "doing a cache attack we're doing a tlb attack with fetch and bounce and we can infer that secret from the",
    "start": "1525840",
    "end": "1533279"
  },
  {
    "text": "tlb when it was a tlp hit or not so whether fetch and bounce succeeded at the first try or not",
    "start": "1533279",
    "end": "1541600"
  },
  {
    "text": "that's very interesting but i remember there was specter and wasn't there another vulnerability as well",
    "start": "1541600",
    "end": "1547200"
  },
  {
    "text": "that's i don't know it sounded really scary something like nuclear stuff something like that ah you mean meltdown",
    "start": "1547200",
    "end": "1554240"
  },
  {
    "text": "yes meltdown was also at the same time but it's a different attack",
    "start": "1554240",
    "end": "1559600"
  },
  {
    "text": "so this exploits the the permission check that we also exploit here uh with data bounds so that permissions",
    "start": "1559600",
    "end": "1566720"
  },
  {
    "text": "are checked later on and with that it was possible to basically read the entire memory",
    "start": "1566720",
    "end": "1572480"
  },
  {
    "text": "because even inaccessible memory could be accessed transiently encoded somewhere and then restored with",
    "start": "1572480",
    "end": "1579279"
  },
  {
    "text": "a side channel attack and as the kernel maps all physical memory basically",
    "start": "1579279",
    "end": "1584480"
  },
  {
    "text": "we can read arbitrary memory with meltdown so yes you're right super scary yeah but i",
    "start": "1584480",
    "end": "1591039"
  },
  {
    "text": "mean we know it's scary but how do you fix this i remember that it was like this huge performance impact",
    "start": "1591039",
    "end": "1597760"
  },
  {
    "text": "so isn't there a smarter way to fix this right so we know intel did fix it but we don't",
    "start": "1597760",
    "end": "1604559"
  },
  {
    "text": "really know how right so let's reverse engineer this let's see we make a few assumptions here so",
    "start": "1604559",
    "end": "1610799"
  },
  {
    "text": "starting the cpu we think might be a bit costly and it might also require some re-engineering of the",
    "start": "1610799",
    "end": "1617120"
  },
  {
    "text": "pipeline and we know that these mitigations were rolled out fairly quickly so let's make a guess here let's say",
    "start": "1617120",
    "end": "1625039"
  },
  {
    "text": "data is just zeroed out on a load if that load falls but the load still happens so we can",
    "start": "1625039",
    "end": "1631760"
  },
  {
    "text": "test this hypothesis so first we just do meltdown and meltdown unsurprisingly on mitigated",
    "start": "1631760",
    "end": "1637919"
  },
  {
    "text": "cpus now returns zero and not the data anymore so that's that's good mission accomplished right so",
    "start": "1637919",
    "end": "1645760"
  },
  {
    "text": "we confirm our hypothesis of how this works with some performance counters so first we look at memory stalls and we",
    "start": "1645760",
    "end": "1653440"
  },
  {
    "text": "compare intel cpus that are vulnerable that are mitigated and an amd cpu",
    "start": "1653440",
    "end": "1659520"
  },
  {
    "text": "and so what we can see is that on a vulnerable cpu and on a mitigated cpu for user and kernel accesses there is",
    "start": "1659520",
    "end": "1667120"
  },
  {
    "text": "the same percentage of stalls that is not a hundred percent like it is for",
    "start": "1667120",
    "end": "1672159"
  },
  {
    "text": "non-present and on an unaffected cpu such as an amd cpu we see that non-present pages and",
    "start": "1672159",
    "end": "1678240"
  },
  {
    "text": "current pages both stall 100 of the time so we can look at a second counter the",
    "start": "1678240",
    "end": "1684399"
  },
  {
    "text": "issued micro-ops on the load ports and again here we can see that with and",
    "start": "1684399",
    "end": "1689520"
  },
  {
    "text": "without mitigations user and kernel address accesses have the same number of",
    "start": "1689520",
    "end": "1695760"
  },
  {
    "text": "microbes issued and that again points towards our conclusion that loads still happen in the",
    "start": "1695760",
    "end": "1702000"
  },
  {
    "text": "background they just zeroed out and so just to be sure we tried a third",
    "start": "1702000",
    "end": "1707120"
  },
  {
    "text": "measure that is when we have an access that misses the l1 we measure this uh we look at this",
    "start": "1707120",
    "end": "1713520"
  },
  {
    "text": "mispending cycles counter and again we see that between unmitigated and mitigated cpus",
    "start": "1713520",
    "end": "1720080"
  },
  {
    "text": "the ratio of user and kernel accesses is exactly the same so again this leads us to the conclusion it's",
    "start": "1720080",
    "end": "1727200"
  },
  {
    "text": "just zeroed out the load happens in the background anyways so that's very nice but when i see this i",
    "start": "1727200",
    "end": "1734000"
  },
  {
    "text": "immediately think that can we use the hardware based mitigations for an attack because it sounds like we can do that",
    "start": "1734000",
    "end": "1740320"
  },
  {
    "text": "why don't you build one well we've seen already ksl outbreaks we've seen data bounce which was such an",
    "start": "1740320",
    "end": "1746480"
  },
  {
    "text": "attack and when we've looked at these mitigations we thought okay we find another one let's",
    "start": "1746480",
    "end": "1752799"
  },
  {
    "text": "call it echelod which is a very fast and reliable case law break and it again simply encodes the return",
    "start": "1752799",
    "end": "1758880"
  },
  {
    "text": "value when we access it simply like a meltdown attack in the cache and actually load for instance it can't",
    "start": "1758880",
    "end": "1765360"
  },
  {
    "text": "be summarized with this very short sample of code it's more or less a memory access",
    "start": "1765360",
    "end": "1771600"
  },
  {
    "text": "encoding data that we load from the kernel edge that looks almost the same as before so yeah but different now but it's a little",
    "start": "1771600",
    "end": "1777600"
  },
  {
    "text": "bit different because what you hear exploit now is that we exploit this stalling behavior when the cpu",
    "start": "1777600",
    "end": "1783440"
  },
  {
    "text": "uh when the cpu tries to access the memory that is not backed by physical memory so we can",
    "start": "1783440",
    "end": "1790880"
  },
  {
    "text": "change this kernel address and we never find we always stall but at one point we get",
    "start": "1790880",
    "end": "1796559"
  },
  {
    "text": "to this location where the kernel is actually placed and now we see the effect that these mitigations have",
    "start": "1796559",
    "end": "1803039"
  },
  {
    "text": "because now we have a faulting load and we get a zero back so we know now",
    "start": "1803039",
    "end": "1809520"
  },
  {
    "text": "where the kernel is placed nice right that's pretty cool but the question then is always what's",
    "start": "1809520",
    "end": "1816320"
  },
  {
    "text": "the performance of issue right because that's what we care about in the end we want numbers we want speed yes and we evaluate it on several cpus with",
    "start": "1816320",
    "end": "1824159"
  },
  {
    "text": "mitigations without mitigation because it also works on those without mitigations because then it's simply meltdown and",
    "start": "1824159",
    "end": "1832799"
  },
  {
    "text": "we also tried it because we have 14 loads so we need to somehow prevent our program from dying we place",
    "start": "1832799",
    "end": "1839440"
  },
  {
    "text": "the faulting load within speculation within tsx which is an intel feature",
    "start": "1839440",
    "end": "1844960"
  },
  {
    "text": "or simply by using a segfault handling and as we can see it is very fast on the i9 i9",
    "start": "1844960",
    "end": "1852000"
  },
  {
    "text": "with dsx we have like 29 microseconds and a perfect accuracy with an f score",
    "start": "1852000",
    "end": "1857760"
  },
  {
    "text": "of one so we are very reliable and very fast even faster than previous state of",
    "start": "1857760",
    "end": "1863360"
  },
  {
    "text": "the art and for the other cpus with speculation we sometimes see that it's not",
    "start": "1863360",
    "end": "1869760"
  },
  {
    "text": "completely perfect but this is more or less because inducing speculation doesn't work always",
    "start": "1869760",
    "end": "1875919"
  },
  {
    "text": "reliable so this might be the explanation for that what we were also able to do is we were",
    "start": "1875919",
    "end": "1882640"
  },
  {
    "text": "able to show that these that this attack works in sgx and we can also use it in javascript",
    "start": "1882640",
    "end": "1888960"
  },
  {
    "text": "so now in the beginning we talked about that we not only want to attack something but",
    "start": "1888960",
    "end": "1894960"
  },
  {
    "text": "we also want to defend against these attacks and we need softwork around for that and",
    "start": "1894960",
    "end": "1900080"
  },
  {
    "text": "we don't just want to mitigate data bounce or actual load we also want to mitigate",
    "start": "1900080",
    "end": "1905200"
  },
  {
    "text": "other attacks that have been designed previously and so in order to do so we need to come up",
    "start": "1905200",
    "end": "1911039"
  },
  {
    "text": "with what are these attacks exploiting so we looked at the at all of them and we discovered that",
    "start": "1911039",
    "end": "1917120"
  },
  {
    "text": "they all exploit timing differences between mapped and unmapped pages like",
    "start": "1917120",
    "end": "1922399"
  },
  {
    "text": "we saw just now with echoload and data bonds for instance as well",
    "start": "1922399",
    "end": "1928000"
  },
  {
    "text": "there have been has been another attack that simply differentiates the kernel based on the different page size it uses",
    "start": "1928000",
    "end": "1934559"
  },
  {
    "text": "and there's another one that can differentiate the timing difference between executable and non-executable",
    "start": "1934559",
    "end": "1940880"
  },
  {
    "text": "pages so if you want to prevent all of these attacks what we need to do is we need to mitigate all of these",
    "start": "1940880",
    "end": "1947519"
  },
  {
    "text": "attack vectors so our mitigation is called flare it stands for fake load address response",
    "start": "1947519",
    "end": "1954960"
  },
  {
    "text": "and we can see here the current linux design without flare in place and we have the beginning of the kernel",
    "start": "1954960",
    "end": "1961120"
  },
  {
    "text": "is somewhere somewhere randomly placed with kslr and the code section n",
    "start": "1961120",
    "end": "1967120"
  },
  {
    "text": "is directly followed by the data section so code is obviously mapped",
    "start": "1967120",
    "end": "1973519"
  },
  {
    "text": "using executable pages and the data section without so we need to prevent this in the first",
    "start": "1973519",
    "end": "1980080"
  },
  {
    "text": "step let's take the look at the mapped and unmet pages we simply fill out",
    "start": "1980080",
    "end": "1986080"
  },
  {
    "text": "all positions where the kernel can be met quick and easy solution right of course and we're done now right and more or",
    "start": "1986080",
    "end": "1992559"
  },
  {
    "text": "less so we we fixed the data bounce and actually load for instance but others are still problematic so in this step what we also",
    "start": "1992559",
    "end": "1998640"
  },
  {
    "text": "need to do is we need to ensure that all of them use the same page size so all of them use four kilobyte pages for",
    "start": "1998640",
    "end": "2005120"
  },
  {
    "text": "instance in the next step we mitigate the difference between executable non-executable pages",
    "start": "2005120",
    "end": "2010559"
  },
  {
    "text": "so we simply split the range for the kernel place executable code in the first half and",
    "start": "2010559",
    "end": "2016399"
  },
  {
    "text": "non-executable in the second half so the switch now is always at the predefined location that the attacker",
    "start": "2016399",
    "end": "2022240"
  },
  {
    "text": "already knows so with this simple fix we've fixed all of them so how does this now look we",
    "start": "2022240",
    "end": "2029840"
  },
  {
    "text": "should for instance perform flare we've seen this before but now everything is mapped and we always get zero back so that's",
    "start": "2029840",
    "end": "2036960"
  },
  {
    "text": "echo load right that's actually no right so when we take another look at all the",
    "start": "2036960",
    "end": "2043279"
  },
  {
    "text": "other attacks we have seen actual already before uh prefetch this is the one that was able",
    "start": "2043279",
    "end": "2049358"
  },
  {
    "text": "to differentiate the different page sizes we can see here unmapped one gigabyte four kilobyte and",
    "start": "2049359",
    "end": "2055599"
  },
  {
    "text": "two megabyte pages with flare there's nothing in there anymore",
    "start": "2055599",
    "end": "2060638"
  },
  {
    "text": "databands we've already seen that one also not differentiable the double page fault simply tries to",
    "start": "2060639",
    "end": "2066960"
  },
  {
    "text": "access something twice and measure the timing difference because if it's mapped the second axis will be fast",
    "start": "2066960",
    "end": "2073280"
  },
  {
    "text": "also not possible anymore dr k improved the double page fault by using tsx",
    "start": "2073280",
    "end": "2080320"
  },
  {
    "text": "so we also don't see it there anymore and fallout is also hidden and we had already",
    "start": "2080320",
    "end": "2086240"
  },
  {
    "text": "discussed the difference between fallout so we also implemented this as a proof of concept",
    "start": "2086240",
    "end": "2091839"
  },
  {
    "text": "which you can find on our github page check it out we don't take any",
    "start": "2091839",
    "end": "2097520"
  },
  {
    "text": "guarantees that it works flawlessly but in my practice system",
    "start": "2097520",
    "end": "2102880"
  },
  {
    "text": "i never have probably won't never happened to me so yes all right so what",
    "start": "2102880",
    "end": "2111040"
  },
  {
    "text": "do we take from that so we see again optimizations whatever they are in a",
    "start": "2111040",
    "end": "2117680"
  },
  {
    "text": "micro architecture they introduce security problems and sometimes these mitigations",
    "start": "2117680",
    "end": "2125520"
  },
  {
    "text": "can fix the main problem but this can still be some edge cases that are overlooked and are still exploitable",
    "start": "2125520",
    "end": "2131040"
  },
  {
    "text": "and we've seen that once again just like with meltdown we require software mitigations to",
    "start": "2131040",
    "end": "2137200"
  },
  {
    "text": "prevent these edge cases with that we are more or less finished with our presentation and",
    "start": "2137200",
    "end": "2144240"
  },
  {
    "text": "we hope you enjoyed it and we are looking forward to any questions that you have",
    "start": "2144240",
    "end": "2150240"
  },
  {
    "text": "thanks for your attention",
    "start": "2150240",
    "end": "2155920"
  }
]