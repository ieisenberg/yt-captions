[
  {
    "text": "foreign",
    "start": "0",
    "end": "2539"
  },
  {
    "text": "consider to be potentially useful to an attacker so load library is just an example which is very well Illustrated",
    "start": "30500",
    "end": "37079"
  },
  {
    "text": "here now instead of bypassing usually hooks we can get a little bit you know we can",
    "start": "37079",
    "end": "43620"
  },
  {
    "text": "do a lot more interesting things and since userline hooks run in ring three just like our Shell Code does",
    "start": "43620",
    "end": "50640"
  },
  {
    "text": "we can just go ahead and attack our code directly we don't have to bypass it we can just get rid of it all together so",
    "start": "50640",
    "end": "58320"
  },
  {
    "text": "instead of bypassing the hooks we can just attack the protection mechanism and this applies not just to buffer",
    "start": "58320",
    "end": "64080"
  },
  {
    "text": "overflows it surprises the old secreting mechanisms that are implemented in in user land such as win32 safer",
    "start": "64080",
    "end": "71780"
  },
  {
    "text": "here's an example as I mentioned before when low libraries hijackable when any",
    "start": "72060",
    "end": "78420"
  },
  {
    "text": "function is hijacked the first five bytes are replaced with the jump instruction well there's nothing that stops us to",
    "start": "78420",
    "end": "85320"
  },
  {
    "text": "replacing the five bytes back to the original value which negates all the protection once again so in this",
    "start": "85320",
    "end": "91619"
  },
  {
    "text": "particular case it's kind of a pseudocode but it illustrates the point very well and it demonstrates",
    "start": "91619",
    "end": "96720"
  },
  {
    "text": "several techniques that can be used to bypass this particular security mechanism",
    "start": "96720",
    "end": "101820"
  },
  {
    "text": "what we're going to do is we're going to find out where load library is called and then we're just going to replace the first five bytes with the original value",
    "start": "101820",
    "end": "108119"
  },
  {
    "text": "pretty simple so the first technique is first of all we need to find out where low libraries",
    "start": "108119",
    "end": "113220"
  },
  {
    "text": "is is loaded and to do that we can use a win32 API which is called get proc",
    "start": "113220",
    "end": "119100"
  },
  {
    "text": "address which basically gives you the address of of any API you're interested in the problem is that most of hips vendors",
    "start": "119100",
    "end": "126119"
  },
  {
    "text": "will probably hook get product address as well so we cannot use it because we cannot use it because of that",
    "start": "126119",
    "end": "132660"
  },
  {
    "text": "but if we provide our entire copy of get Park address in our Shell Code we can just call that directly and once again",
    "start": "132660",
    "end": "138300"
  },
  {
    "text": "we bypass any type of verification so all we do is we include",
    "start": "138300",
    "end": "143819"
  },
  {
    "text": "get Park address in our Shell Code and call that once we have the address we'll just go ahead and replace the five",
    "start": "143819",
    "end": "150420"
  },
  {
    "text": "bytes with original five bet with original five bytes and then we'll call the load Library",
    "start": "150420",
    "end": "155520"
  },
  {
    "text": "directly and this without any hooks or anything like that interestingly enough some of the implementation we've done well you might",
    "start": "155520",
    "end": "161580"
  },
  {
    "text": "say well hold on a second you're replacing five bytes in a code segment I thought code segment was read only",
    "start": "161580",
    "end": "167340"
  },
  {
    "text": "but you see some when when hips vendors replace when they installed their hooks",
    "start": "167340",
    "end": "172680"
  },
  {
    "text": "they need to obviously make the code segment right read write in order to install their Hooks and guess what they",
    "start": "172680",
    "end": "178260"
  },
  {
    "text": "leave it to read write so we can just go ahead and conveniently override our code segment which is not re read",
    "start": "178260",
    "end": "184500"
  },
  {
    "text": "write and not just read only so this this code actually works very well against some of the implementations we",
    "start": "184500",
    "end": "190019"
  },
  {
    "text": "looked at bypass the kernel hooks is a little bit more interesting the reason for that is",
    "start": "190019",
    "end": "196379"
  },
  {
    "text": "we cannot modify we cannot tamper with kernel directly we're not allowed to override any kernel code we're not",
    "start": "196379",
    "end": "201480"
  },
  {
    "text": "allowed to do a lot of different things we can do in user land so if the kernel is implemented correctly that's pretty much negates all",
    "start": "201480",
    "end": "207900"
  },
  {
    "text": "of the techniques that we just talked about but there's still a pretty powerful one the problem with criminalism limitations",
    "start": "207900",
    "end": "214260"
  },
  {
    "text": "that kernel implementation still depend on user-controlled data they still depend on information that is on stack",
    "start": "214260",
    "end": "222120"
  },
  {
    "text": "and the information in the stack is of course completely controlled by malicious code thus when a malicious code begins to execute they can create",
    "start": "222120",
    "end": "228060"
  },
  {
    "text": "arbitrary phase stack frames they can do anything they want on stack and currently has to trust whatever it sees",
    "start": "228060",
    "end": "233580"
  },
  {
    "text": "on that so to bypass kernel hook the way Carla hooks work is they rely on",
    "start": "233580",
    "end": "240540"
  },
  {
    "text": "stock back tracing whilst in user land if we call if we hook kernel 32 dll we have immediate",
    "start": "240540",
    "end": "247140"
  },
  {
    "text": "access to the last return address which is usually where our shell code is the problem with kernel is that it's several",
    "start": "247140",
    "end": "253260"
  },
  {
    "text": "layers away from the actual code from the actual origin of the coal so kernel",
    "start": "253260",
    "end": "259079"
  },
  {
    "text": "what Colonel has to do is it has to actually find where the cola originated from it so it has to get back all the",
    "start": "259079",
    "end": "264120"
  },
  {
    "text": "way to application so it takes the address of ntdll then it says okay",
    "start": "264120",
    "end": "269940"
  },
  {
    "text": "it gets it goes all the way to Chrome 32 then it goes to the Shell Code and then says uh-huh so it's writing for my read",
    "start": "269940",
    "end": "276180"
  },
  {
    "text": "write memory segment so it must be must be something malicious happening so the way it does this is realizing",
    "start": "276180",
    "end": "282300"
  },
  {
    "text": "stack backs racing and stack back tracing relies on EBP register on x86 architectures EBP registry used just for",
    "start": "282300",
    "end": "289979"
  },
  {
    "text": "that for linking stack frames with one another since the con since the stack frame can have them pretty much arbitrary amount",
    "start": "289979",
    "end": "296580"
  },
  {
    "text": "of space allocated to it there's no way for for us to find where the next stack",
    "start": "296580",
    "end": "301800"
  },
  {
    "text": "frame is without the EBP register unfortunately due to register pressure on x86 a lot of compiler optimization",
    "start": "301800",
    "end": "309000"
  },
  {
    "text": "actually throw away DBP register or rather they don't use it for original purpose and they use it for whatever other means so that pretty much negates",
    "start": "309000",
    "end": "315780"
  },
  {
    "text": "this technique completely even without us trying to do anything it basically does not work on certain Service Pack",
    "start": "315780",
    "end": "321300"
  },
  {
    "text": "because the EBP register is not there and kernel is not is basically cannot get all the way back to application",
    "start": "321300",
    "end": "327660"
  },
  {
    "text": "but even if it can get all the way to this particular Point there's nothing that",
    "start": "327660",
    "end": "333360"
  },
  {
    "text": "stops us from creating fake stack frames so all we have to do to bypass the",
    "start": "333360",
    "end": "338880"
  },
  {
    "text": "kernel Hook is create a fake frame that does not does not have the EVP register that is this is",
    "start": "338880",
    "end": "346020"
  },
  {
    "text": "our stack back tracing is going to terminate at that particular point and the return address must point to your",
    "start": "346020",
    "end": "351660"
  },
  {
    "text": "read-only segment so you cannot point to a none you cannot point to a writable segment so creating a fake frame would that be",
    "start": "351660",
    "end": "357960"
  },
  {
    "text": "before registered spirit is simply you just push a couple values and stack and you're done the only Point here the only",
    "start": "357960",
    "end": "363180"
  },
  {
    "text": "interesting point is well how do you how do we get get a return address that points to an non-writable segment",
    "start": "363180",
    "end": "369539"
  },
  {
    "text": "the problem with this is that we obviously cannot write to read only segments so how do we get how do we use",
    "start": "369539",
    "end": "377759"
  },
  {
    "text": "where do we get an address that points to a non-writable segment well the trick here is to actually proxy our return",
    "start": "377759",
    "end": "384780"
  },
  {
    "text": "through a red construction a rep instruction is return address as return instruction x36 which fetches a value",
    "start": "384780",
    "end": "391500"
  },
  {
    "text": "from stack and returns to that particular value let me illustrate this with an example",
    "start": "391500",
    "end": "398180"
  },
  {
    "text": "here's a little snippet of code that actually bypasses",
    "start": "398280",
    "end": "403380"
  },
  {
    "text": "the bypasses kernel hooks all it does is once again I'm going to illustrate in the load Library",
    "start": "403380",
    "end": "409759"
  },
  {
    "text": "the way it's going to work is instead of calling load Library using a call instruction and thereby creating a",
    "start": "410039",
    "end": "415500"
  },
  {
    "text": "normal stack frame we're going to create our own stack frame so in fact we're",
    "start": "415500",
    "end": "421259"
  },
  {
    "text": "going to create two stack frames one of them for load Library call and the other one for faking and bypassing kernel",
    "start": "421259",
    "end": "426900"
  },
  {
    "text": "hooks so to create a first frame with our real version address we use the first push instruction and then we",
    "start": "426900",
    "end": "432660"
  },
  {
    "text": "actually emulate a cold load Library called but instead of using our normal return address in the read-only SEC and",
    "start": "432660",
    "end": "438600"
  },
  {
    "text": "read write segment that is on the sacrone hip instead of using that address",
    "start": "438600",
    "end": "443759"
  },
  {
    "text": "we use address somewhere in the read-only segment and we can find this dynamic or we can find this Dynamic at",
    "start": "443759",
    "end": "449039"
  },
  {
    "text": "runtime so we find a retro instruction and we just use that",
    "start": "449039",
    "end": "454560"
  },
  {
    "text": "so what's going to happen is we call load Library our kernel Hook is going to get all the",
    "start": "454560",
    "end": "460259"
  },
  {
    "text": "way to our fake frame it's going to look at it and says it points to a read-only segment which means it's okay there is",
    "start": "460259",
    "end": "466740"
  },
  {
    "text": "no EVP registered which means we're going to terminate here so it looks like we're good to go and it's just going to allow the execution",
    "start": "466740",
    "end": "473460"
  },
  {
    "text": "when low Library Returns what is actually going to happen it's not going to return to our Shell Code rather it's",
    "start": "473460",
    "end": "478979"
  },
  {
    "text": "going to return through the next frame which is going to get our real return address from stack and actually jump",
    "start": "478979",
    "end": "484979"
  },
  {
    "text": "return the control back to our Shell Code so a bit of a trickery here so here's here's example",
    "start": "484979",
    "end": "490319"
  },
  {
    "text": "a normal stack looks like this normal stack is the one on the left where we have two different functions that call",
    "start": "490319",
    "end": "495960"
  },
  {
    "text": "each other function two takes two parameters it has a return AP address of whoever",
    "start": "495960",
    "end": "501479"
  },
  {
    "text": "called function2 and it's got a safe DBP which points to the next frame and it",
    "start": "501479",
    "end": "506520"
  },
  {
    "text": "looks pretty much similar it's got two parameters a return address and EBP that's pretty much how a normal execution goes now like I said there's",
    "start": "506520",
    "end": "514560"
  },
  {
    "text": "nothing that prevents us from creating arbitrary effect arbitrary stack frames so instead of doing a normal looking",
    "start": "514560",
    "end": "521099"
  },
  {
    "text": "frame what we're going to do is we're going to create a frame that one does not have the EBP register basically it's",
    "start": "521099",
    "end": "526500"
  },
  {
    "text": "going to we're going to terminate the kernel of Stack back tracing here and two the return address is going to point to",
    "start": "526500",
    "end": "532620"
  },
  {
    "text": "your read-only segment so here is the code from the previous slides that are actually going to",
    "start": "532620",
    "end": "537660"
  },
  {
    "text": "generate this particular this particular frame notice that in using just four",
    "start": "537660",
    "end": "544560"
  },
  {
    "text": "simple instructions we can completely bypass the kernel hook buffer overflow protection pretty simple just a little",
    "start": "544560",
    "end": "551519"
  },
  {
    "text": "bit trickery but very effective and in this particular technique also works against",
    "start": "551519",
    "end": "557040"
  },
  {
    "text": "userland since usual and pretty much relies in the same and the same mechanism but",
    "start": "557040",
    "end": "564060"
  },
  {
    "text": "there are much easier ways to bypass user and user line Hooks and this pretty much shows you only use for Pearl stuff",
    "start": "564060",
    "end": "570980"
  },
  {
    "text": "now are there any questions when it comes to this I know this might get a little bit tricky so are there any questions about how this works and why",
    "start": "571440",
    "end": "577860"
  },
  {
    "text": "this works you guys are Sharp",
    "start": "577860",
    "end": "584040"
  },
  {
    "text": "so to summarize buffer flow protection is hard it's very",
    "start": "584040",
    "end": "589560"
  },
  {
    "text": "hard to implement it in a secure manner it's even harder to do it on a closed Source operating system such as Windows",
    "start": "589560",
    "end": "597920"
  },
  {
    "text": "the majority of the protection mechanisms that we looked at that are available in the market and are marketed as being you know effective against",
    "start": "598200",
    "end": "604740"
  },
  {
    "text": "buffer flows are simply designed to detect Shell Code so they don't actually prevent buffer overflows what they do is",
    "start": "604740",
    "end": "610140"
  },
  {
    "text": "they basically try to detect when Shell Code they can stay execute and if your particular IPS implementation does is",
    "start": "610140",
    "end": "616380"
  },
  {
    "text": "then you pretty much might as well give up because it'd be simply not going to work and it can be easily bypassed by",
    "start": "616380",
    "end": "622019"
  },
  {
    "text": "attackers now that we gain access to our system by",
    "start": "622019",
    "end": "627240"
  },
  {
    "text": "back by by passing buffer flow protection let's look at how we can cause further damage",
    "start": "627240",
    "end": "635160"
  },
  {
    "text": "once our code is running in the system so operating system protection is",
    "start": "635160",
    "end": "640740"
  },
  {
    "text": "designed to protect the underlying operating system like I said it can be a window so it can be Unix",
    "start": "640740",
    "end": "647100"
  },
  {
    "text": "and it usually most protecting integrative system files system logs system binaries registry keys pretty",
    "start": "647100",
    "end": "653100"
  },
  {
    "text": "much anything that can be that that's steam sensitive that can be used to elevate higher privilege get higher",
    "start": "653100",
    "end": "658380"
  },
  {
    "text": "privileges or cause any any type of further damage operating system protection should also",
    "start": "658380",
    "end": "664079"
  },
  {
    "text": "disallow loading of arbitrary code if it is not the case then you might as well also give up because once an attacker",
    "start": "664079",
    "end": "670800"
  },
  {
    "text": "loads a kernel module then game over once once malicious code starts",
    "start": "670800",
    "end": "675839"
  },
  {
    "text": "executing in ring zero then game over because it has access to every single resource on a computer can do anything",
    "start": "675839",
    "end": "681779"
  },
  {
    "text": "it wants and similar to buffer flow protection operating system can be protection can",
    "start": "681779",
    "end": "688440"
  },
  {
    "text": "be implemented in user land Rank 3 or kernel now",
    "start": "688440",
    "end": "693480"
  },
  {
    "text": "as I already described userline protection is pretty much useless it runs by the same privileges thus it",
    "start": "693480",
    "end": "700320"
  },
  {
    "text": "cannot provide any extra protection against malicious code I was disassembling some kernel 32",
    "start": "700320",
    "end": "707279"
  },
  {
    "text": "functions and I've noticed that winter is too safely seems to be implemented this way and I came to",
    "start": "707279",
    "end": "713820"
  },
  {
    "text": "conclusion that this particular technology cannot be relied on CE your malicious code 2 starts",
    "start": "713820",
    "end": "719820"
  },
  {
    "text": "executing so it's completely effective against malicious code so if malicious code start to run then",
    "start": "719820",
    "end": "726959"
  },
  {
    "text": "this is not going to stop and you determine attacker so to do this properly one has to do it in kernel in",
    "start": "726959",
    "end": "733800"
  },
  {
    "text": "ring zero the reason for this is the kernel crew runs with different pure religious it runs in ring zero it has",
    "start": "733800",
    "end": "739140"
  },
  {
    "text": "complete control over the entire system it acts as a guardian for all of resources and it's also very",
    "start": "739140",
    "end": "744899"
  },
  {
    "text": "hard to attack directly if implemented properly you cannot override kernel code you cannot do a lot of things you can do",
    "start": "744899",
    "end": "750480"
  },
  {
    "text": "in user land so pretty much the only way to bypass operating system protection is to evade",
    "start": "750480",
    "end": "756360"
  },
  {
    "text": "it rather than attack it directly so let's for example look at the file",
    "start": "756360",
    "end": "762000"
  },
  {
    "text": "system protection an IPS system for example might be",
    "start": "762000",
    "end": "768540"
  },
  {
    "text": "designed to protect system drivers and disks we might say well we don't want to attackers to override our system drivers",
    "start": "768540",
    "end": "775139"
  },
  {
    "text": "so an IPS system might be designed to protect C Windows system through to drivers you might make them read only",
    "start": "775139",
    "end": "780600"
  },
  {
    "text": "say no we're not going to allow anyone to override our drivers the question is if it's protecting C",
    "start": "780600",
    "end": "787380"
  },
  {
    "text": "window system 32 drivers is it protecting X drivers or is it protecting this weird thing",
    "start": "787380",
    "end": "794459"
  },
  {
    "text": "what is X drivers well an X driver is basically a link a symbolic link that points to the same directory so to",
    "start": "794459",
    "end": "802560"
  },
  {
    "text": "do this we don't have to program anything we can just use a simple dos utility called Subs that can map arbitrary drives to arbitrary",
    "start": "802560",
    "end": "808440"
  },
  {
    "text": "directories so let's say we want to override IP filter driver to gain access",
    "start": "808440",
    "end": "813779"
  },
  {
    "text": "to ring zero so since we cannot override C Windows system 32 driveways files directly we're going to try to enrich",
    "start": "813779",
    "end": "820019"
  },
  {
    "text": "the IPS system by creating symbolic links specifically we're going to call a Subs command which is going to Map X",
    "start": "820019",
    "end": "826079"
  },
  {
    "text": "drive to C Windows system 32. and then if you look at the next line and we do dir and X driver sap filter you're going",
    "start": "826079",
    "end": "833760"
  },
  {
    "text": "to notice that the file that we're actually displaying is absolutely the same even though it now calls something completely different it is now X Windows",
    "start": "833760",
    "end": "840899"
  },
  {
    "text": "system 32. another point which doesn't involve symbolic lens but still is interesting",
    "start": "840899",
    "end": "846120"
  },
  {
    "text": "is is X drivers dollar sign data well you might ask what",
    "start": "846120",
    "end": "853200"
  },
  {
    "text": "the hell is that what the thing is is that due to some",
    "start": "853200",
    "end": "859560"
  },
  {
    "text": "Macintosh capabilities issues which was important I guess about 15 years ago but not anymore Windows 10 was designed to",
    "start": "859560",
    "end": "865800"
  },
  {
    "text": "support multiple streams in a file meaning that each file can contain multiple streams stream is",
    "start": "865800",
    "end": "872399"
  },
  {
    "text": "basically just a piece of data that can be saved under a particular name now when you access a normal file let's say",
    "start": "872399",
    "end": "878760"
  },
  {
    "text": "you open a text file in notepad by default you're accessing a default stream which is called Data now you can",
    "start": "878760",
    "end": "884820"
  },
  {
    "text": "have other streams in there which are completely might be completely invisible and the question is can you trick can your IPS",
    "start": "884820",
    "end": "892500"
  },
  {
    "text": "system handle multiple streams or is it just working does it only handle the default",
    "start": "892500",
    "end": "898380"
  },
  {
    "text": "case there are many other attacks that are related to file system but those are",
    "start": "898380",
    "end": "904320"
  },
  {
    "text": "just some of the things to get you to start thinking about some of the ways to attack IPS systems",
    "start": "904320",
    "end": "910560"
  },
  {
    "text": "absolutely the same ways can be same mechanism can be used to be bypassed any kind of registry protection",
    "start": "910560",
    "end": "917040"
  },
  {
    "text": "so let's say an IPS is trying to protect certain Keys certain system keys from being overwritten so it can be a",
    "start": "917040",
    "end": "922500"
  },
  {
    "text": "registered machine system or whatever else the question is once again is it protecting my registry machine system",
    "start": "922500",
    "end": "929279"
  },
  {
    "text": "well what is my registration system this is what it is it's a simple symbolic link that can be created with this",
    "start": "929279",
    "end": "935519"
  },
  {
    "text": "particular API and what it does it creates arbitrary symbolic links in kernel namespace",
    "start": "935519",
    "end": "940680"
  },
  {
    "text": "so here you see that my registry machine is an object in the global namespace",
    "start": "940680",
    "end": "946980"
  },
  {
    "text": "which is a symbolic link to register machine so therefore my registration system slash whatever key is the same",
    "start": "946980",
    "end": "953760"
  },
  {
    "text": "thing as register mission system whatever key there's some IPS systems that cannot handle some roller coins",
    "start": "953760",
    "end": "958800"
  },
  {
    "text": "that can be easily bypassed using this particular technique",
    "start": "958800",
    "end": "963680"
  },
  {
    "text": "now what about kernel code does your IPS system stop kernel code from being loaded",
    "start": "965160",
    "end": "972120"
  },
  {
    "text": "well let's look at some of the ways that one can load kernel code in in a Windows environment and you'll be truly amazed",
    "start": "972120",
    "end": "979500"
  },
  {
    "text": "the best the well-known and the best Android studio interface is of course service control manager API and that's",
    "start": "979500",
    "end": "985199"
  },
  {
    "text": "used for loading system Services it's you can be used for loading system kernel drivers whatever else so most of",
    "start": "985199",
    "end": "992279"
  },
  {
    "text": "obviously IPS system can handle the lab since it's a interface that's most likely to be used",
    "start": "992279",
    "end": "998040"
  },
  {
    "text": "to load a kernel driver alternatively if that's actually hooked then you can",
    "start": "998040",
    "end": "1003860"
  },
  {
    "text": "a ZW load driver system call and try to load the driver directly",
    "start": "1003860",
    "end": "1009380"
  },
  {
    "text": "or you can start getting really tricky instead of using the subscure system calls that no one no one really knows why",
    "start": "1009380",
    "end": "1015920"
  },
  {
    "text": "they're there but can load kernel code nevertheless it's a ZW set system information",
    "start": "1015920",
    "end": "1022160"
  },
  {
    "text": "there are instances in the past that were published where some of the IPS vendors were able to",
    "start": "1022160",
    "end": "1028040"
  },
  {
    "text": "handle a CM API they would even hook this particular interface but they figure out all about this piece of code",
    "start": "1028040",
    "end": "1034640"
  },
  {
    "text": "and that could be used to load arbitrary code but that's not all besides using let alone interfaces such",
    "start": "1034640",
    "end": "1041418"
  },
  {
    "text": "as GW set system information which is quite effective attackers can get really tricky and they can start",
    "start": "1041419",
    "end": "1048679"
  },
  {
    "text": "they can try to inject code by directly modifying kernel memory Windows 10t exposes a certain device",
    "start": "1048679",
    "end": "1054559"
  },
  {
    "text": "driver called device physical memory which exposes underlying physical memory so if you have administrator rights and",
    "start": "1054559",
    "end": "1061460"
  },
  {
    "text": "you can gain access to this particular device you can pretty much Start overriding physical memory that is you can override",
    "start": "1061460",
    "end": "1067460"
  },
  {
    "text": "kernel code you can overwrite arbitrary data structures pretty much anything else also note is that",
    "start": "1067460",
    "end": "1073100"
  },
  {
    "text": "whilst it's the official name is device mode physical memory we can still access it for example through my physical",
    "start": "1073100",
    "end": "1078440"
  },
  {
    "text": "memory just as well another way which is pretty much",
    "start": "1078440",
    "end": "1084799"
  },
  {
    "text": "the most effective the most stealth and pretty much Unstoppable is a kernel overflow",
    "start": "1084799",
    "end": "1092360"
  },
  {
    "text": "if one exploits the kernel overflow they can pretty much inject arbitrary code and there's nothing absolutely nothing",
    "start": "1092360",
    "end": "1099200"
  },
  {
    "text": "in any IPS system can do to prevent this",
    "start": "1099200",
    "end": "1103779"
  },
  {
    "text": "I'm not aware of any of or at least a lot of Kernel overflows in Windows NT",
    "start": "1104299",
    "end": "1109460"
  },
  {
    "text": "but I'm sure there's some another interesting point is that an APS",
    "start": "1109460",
    "end": "1117080"
  },
  {
    "text": "system cannot simply prevent all processes from loading kernel code the reason for this is that some system",
    "start": "1117080",
    "end": "1123140"
  },
  {
    "text": "Services rely on the ability to be able to load kernel code to load kernel drivers to carry out whatever tasks so",
    "start": "1123140",
    "end": "1130280"
  },
  {
    "text": "some system code some system drivers or some system services but still have the ability to load",
    "start": "1130280",
    "end": "1136100"
  },
  {
    "text": "kernel drivers well one way some IPS vendors approach this problem say well",
    "start": "1136100",
    "end": "1141860"
  },
  {
    "text": "we're just going to trust particular system processes we're going to let them to load kernel drivers",
    "start": "1141860",
    "end": "1148400"
  },
  {
    "text": "well guess what all we have to do is we use we can use old entrusted dll injection technique to",
    "start": "1148400",
    "end": "1155000"
  },
  {
    "text": "inject our user Lin code into the trusted process and then load malicious kernel driver whilst running in the context of a",
    "start": "1155000",
    "end": "1161900"
  },
  {
    "text": "trusted system process in other technique is to modify an",
    "start": "1161900",
    "end": "1167480"
  },
  {
    "text": "existing kernel and driver and disk which is why I was showing you the example with symbolic drivers whilst",
    "start": "1167480",
    "end": "1173200"
  },
  {
    "text": "some well as an IPS might try to make some device drivers read only",
    "start": "1173200",
    "end": "1178580"
  },
  {
    "text": "looking still possibly bypass it and just modify driver on disk and then the",
    "start": "1178580",
    "end": "1183679"
  },
  {
    "text": "next reboot we've got code writing in ring zero another interesting possibility is instead of trying to open",
    "start": "1183679",
    "end": "1189080"
  },
  {
    "text": "a file can we just open the device car disk partition which is basically like Dev HDA on Unix and modify",
    "start": "1189080",
    "end": "1197179"
  },
  {
    "text": "raw code on on disk that's that's a very powerful technique and I didn't see a lot of people talking about it",
    "start": "1197179",
    "end": "1204679"
  },
  {
    "text": "so as you can see they're some official ways but there are many many other ways to get your code to run",
    "start": "1204679",
    "end": "1211400"
  },
  {
    "text": "in a kernel and like I said once you have malicious code running in ring zero",
    "start": "1211400",
    "end": "1217280"
  },
  {
    "text": "it's game over",
    "start": "1217280",
    "end": "1220000"
  },
  {
    "text": "so to summarize the OS protection bit is IPS systems well most of them are",
    "start": "1224660",
    "end": "1230660"
  },
  {
    "text": "designed to protect the underlying operating system the Integrity of the operating system system logs register Keys etc etc",
    "start": "1230660",
    "end": "1239539"
  },
  {
    "text": "user land implementation cannot be relied upon because they're running with the same privileges I pointed out before",
    "start": "1239539",
    "end": "1245780"
  },
  {
    "text": "so any decent IPS must rely on kernel implementation so Colonel implementation is a lot more",
    "start": "1245780",
    "end": "1251780"
  },
  {
    "text": "robust but well they cannot be attacked directly they can be still evaded by modifying system name spaces and we can",
    "start": "1251780",
    "end": "1258860"
  },
  {
    "text": "get trick and try to load our kernel code which is pretty fatal",
    "start": "1258860",
    "end": "1264740"
  },
  {
    "text": "any questions on the OS protection bit so far",
    "start": "1264740",
    "end": "1269500"
  },
  {
    "text": "okay besides besides",
    "start": "1270260",
    "end": "1276320"
  },
  {
    "text": "trying to protect against buffer flows trying to protect the underlying operating system a very important point",
    "start": "1276320",
    "end": "1282100"
  },
  {
    "text": "is protecting itself a security mechanism to try to protect",
    "start": "1282100",
    "end": "1287360"
  },
  {
    "text": "everybody else must also protect itself and a lot of vendors seem to forget about that",
    "start": "1287360",
    "end": "1294260"
  },
  {
    "text": "so a hips system might be attacked directly",
    "start": "1294260",
    "end": "1299900"
  },
  {
    "text": "so appropriate services or demons can be taught directly a service can be simply unloaded you can just go into service",
    "start": "1299900",
    "end": "1306740"
  },
  {
    "text": "control manager and say stop this particular service and if there is no self-protection code",
    "start": "1306740",
    "end": "1312620"
  },
  {
    "text": "then you're pretty much your protection steps stops there at a simple click of a stop button",
    "start": "1312620",
    "end": "1318860"
  },
  {
    "text": "on Windows we can get a little bit trickier or even some instance in Unix that we can try to temper with memory",
    "start": "1318860",
    "end": "1325100"
  },
  {
    "text": "address space of a running agent hips agent so for example we can use",
    "start": "1325100",
    "end": "1332179"
  },
  {
    "text": "apis Windows 3 apis such as read process memory right process memory to try to temper with our running agent we can try",
    "start": "1332179",
    "end": "1338539"
  },
  {
    "text": "to modify it some of the data structures we can try to do all the tricky things",
    "start": "1338539",
    "end": "1343760"
  },
  {
    "text": "or we can get really aggressive and just inject our own code into running service there's nothing",
    "start": "1343760",
    "end": "1349400"
  },
  {
    "text": "that prevents us from injecting our code into the service and then completely taking over the security",
    "start": "1349400",
    "end": "1356320"
  },
  {
    "text": "unfortunately I don't have a demo of this but I've been talking to some people and they told me that it's possible to",
    "start": "1357200",
    "end": "1364760"
  },
  {
    "text": "attack certain IPS which shall remain nameless it's possible to inject code into",
    "start": "1364760",
    "end": "1371480"
  },
  {
    "text": "running instance of this particular IPS because it does not control reprocess read process memory and write",
    "start": "1371480",
    "end": "1378260"
  },
  {
    "text": "process memory we can inject code into the service and then use whilst running in the context of the process we can",
    "start": "1378260",
    "end": "1383840"
  },
  {
    "text": "actually unload the kernel driver that enforces the security or we can",
    "start": "1383840",
    "end": "1389539"
  },
  {
    "text": "basically stop all the hooks we can disable all the hook so we're working pretty much do anything else or we can just take over",
    "start": "1389539",
    "end": "1395419"
  },
  {
    "text": "the entire job and just say well if this particular process is running then always allow it to run",
    "start": "1395419",
    "end": "1402080"
  },
  {
    "text": "so the point of this is if IPS does not protect itself then it cannot obviously provide any",
    "start": "1402080",
    "end": "1409580"
  },
  {
    "text": "type of Integrity for the rest of the system",
    "start": "1409580",
    "end": "1413200"
  },
  {
    "text": "and as I mentioned I do believe that hip technology has a promising future",
    "start": "1417559",
    "end": "1423020"
  },
  {
    "text": "but getting it right is quite hard there are a lot of attack vectors and missing just one for example I'm missing just",
    "start": "1423020",
    "end": "1429200"
  },
  {
    "text": "one way of loading kernel code completely compromises the security and integrity of the underlying system missing one way of getting the kernel",
    "start": "1429200",
    "end": "1436400"
  },
  {
    "text": "code malicious kernel code to run in ring zero pretty much compromises the entire system",
    "start": "1436400",
    "end": "1442820"
  },
  {
    "text": "so it's quite hard to get it right and the majority of current IPS implementation suffer from a variety of",
    "start": "1442820",
    "end": "1448880"
  },
  {
    "text": "security flaws they make a lot of claims which unfortunately don't stand up specifically providing buffer effective",
    "start": "1448880",
    "end": "1455240"
  },
  {
    "text": "buffer protection on Windows is very very hard and as I showed you some of the aps",
    "start": "1455240",
    "end": "1460520"
  },
  {
    "text": "players can be truly bypassed so IPS technology is promising future but it needs time to mature",
    "start": "1460520",
    "end": "1467480"
  },
  {
    "text": "and it might need some help from OS vendors like Microsoft to get things right in terms of when it comes to",
    "start": "1467480",
    "end": "1473000"
  },
  {
    "text": "buffer flow protection now if you have any questions I'll take them before showing you a little demo so",
    "start": "1473000",
    "end": "1479059"
  },
  {
    "text": "if there are any questions before I'll take them out",
    "start": "1479059",
    "end": "1482679"
  },
  {
    "text": "right",
    "start": "1489200",
    "end": "1491799"
  },
  {
    "text": "the question is what is the preferred method of getting the code to run in the kernel well they",
    "start": "1495980",
    "end": "1501200"
  },
  {
    "text": "use this way is really use a a very little known interface such as",
    "start": "1501200",
    "end": "1507679"
  },
  {
    "text": "the W set system information until recently most of people weren't even aware of it it's existent and so it",
    "start": "1507679",
    "end": "1513559"
  },
  {
    "text": "was really trivial I think Greg Hoagland was one of the first ones to point it out with ipd",
    "start": "1513559",
    "end": "1519260"
  },
  {
    "text": "about two years ago but I have not tested other operating other IPS implementations but I'll bet",
    "start": "1519260",
    "end": "1526159"
  },
  {
    "text": "you some of them can be still bypassed and unfortunately it's a very very hard job like I said there's nothing that",
    "start": "1526159",
    "end": "1532760"
  },
  {
    "text": "stops anyone from exploiting a remote service gaining control",
    "start": "1532760",
    "end": "1538159"
  },
  {
    "text": "getting administrative rights and then opening a device partition directly and modifying a driver on disk and then",
    "start": "1538159",
    "end": "1544400"
  },
  {
    "text": "rebooting the machine and after that you've got to bring zero code and that kind of attack is really really hard to prevent",
    "start": "1544400",
    "end": "1551679"
  },
  {
    "text": "even without even without loading kernel code if you've got monolicious code running in your system",
    "start": "1554419",
    "end": "1559640"
  },
  {
    "text": "then you're in deep trouble and so since the almost no decent implementation of",
    "start": "1559640",
    "end": "1566480"
  },
  {
    "text": "Buffalo flow protection it's a a really hard problem",
    "start": "1566480",
    "end": "1571700"
  },
  {
    "text": "yes",
    "start": "1571700",
    "end": "1574240"
  },
  {
    "text": "right",
    "start": "1595460",
    "end": "1597940"
  },
  {
    "text": "right",
    "start": "1617120",
    "end": "1619179"
  },
  {
    "text": "a gentleman suggested a way a different way of protecting buffer flow specifically",
    "start": "1635360",
    "end": "1642760"
  },
  {
    "text": "hijacking apis and then putting kind of a wrap around them which has a counter so it says",
    "start": "1643059",
    "end": "1649460"
  },
  {
    "text": "I've called this function once or I've called this function twice and then when you return we make sure that the return",
    "start": "1649460",
    "end": "1654919"
  },
  {
    "text": "at that the counter is still correct now the I've seen your post to Buck",
    "start": "1654919",
    "end": "1660679"
  },
  {
    "text": "track and I've thought about this and there are several problems first of all this",
    "start": "1660679",
    "end": "1665720"
  },
  {
    "text": "particular myth right the one major flaw which has",
    "start": "1665720",
    "end": "1671059"
  },
  {
    "text": "nothing to do with security is handling a synchronous code such as exceptions",
    "start": "1671059",
    "end": "1676640"
  },
  {
    "text": "such as signals Etc so basically if we tear down multiple stack frames then that pretty",
    "start": "1676640",
    "end": "1683360"
  },
  {
    "text": "much kills any kind of counter the other problem with this approach is like I mentioned if your code is running with",
    "start": "1683360",
    "end": "1688400"
  },
  {
    "text": "the same Privileges and you're trying to basically create a security mechanism that runs by the same privileges as your",
    "start": "1688400",
    "end": "1693440"
  },
  {
    "text": "malicious code then you might as well give up because that's more or less obscurity security through obscurity",
    "start": "1693440",
    "end": "1699320"
  },
  {
    "text": "because you're creating a system which does some magic things but like I said",
    "start": "1699320",
    "end": "1705380"
  },
  {
    "text": "once the code starts running with the same privileges there's nothing that stops me from creating arbitrary stack frames with arbitrary Canary values that",
    "start": "1705380",
    "end": "1711740"
  },
  {
    "text": "I control with arbitrary counters so they're um there are issues with that particular",
    "start": "1711740",
    "end": "1717140"
  },
  {
    "text": "scheme",
    "start": "1717140",
    "end": "1719559"
  },
  {
    "text": "right you have to find encounters but I've seen weirder things getting exploited so",
    "start": "1722600",
    "end": "1730120"
  },
  {
    "text": "are there any other questions yeah",
    "start": "1730220",
    "end": "1733900"
  },
  {
    "text": "um the question was does this also apply to Unix system um well some of the stuff that I showed applies was mostly a gear towards uni",
    "start": "1738799",
    "end": "1746600"
  },
  {
    "text": "Windows system like I said the architecture is not that different and if",
    "start": "1746600",
    "end": "1752000"
  },
  {
    "text": "implementations are pretty much done the same way then you can attack them the same way as a matter of fact",
    "start": "1752000",
    "end": "1758000"
  },
  {
    "text": "some of the I've talked to some some people who implemented the systems on system like Solaris and they use similar",
    "start": "1758000",
    "end": "1763399"
  },
  {
    "text": "techniques for protecting therefore we can use similar techniques for bypassing as a matter of fact Unix architecture is",
    "start": "1763399",
    "end": "1770299"
  },
  {
    "text": "a lot simpler so um there are other ways of attacking the code so",
    "start": "1770299",
    "end": "1776480"
  },
  {
    "text": "Unix is different but it's not that different so you can pretty much use the safety Kinks",
    "start": "1776480",
    "end": "1782380"
  },
  {
    "text": "and so if it is on a close operating system such as Solaris you're going to run into the same problems where you",
    "start": "1782380",
    "end": "1788000"
  },
  {
    "text": "don't control the operating system so you have to use various tricks such as hooking various functions and then doing some magic in the background but",
    "start": "1788000",
    "end": "1794960"
  },
  {
    "text": "yeah this pretty much directly applies to Unique Systems as well",
    "start": "1794960",
    "end": "1799779"
  },
  {
    "text": "right",
    "start": "1804919",
    "end": "1807460"
  },
  {
    "text": "would I install it",
    "start": "1819020",
    "end": "1822580"
  },
  {
    "text": "right like I said um I don't want to say that you know hips is just a buzzword and and it's",
    "start": "1826399",
    "end": "1832580"
  },
  {
    "text": "basically going to go away go away in a couple of years in fact I strongly believe that this technology has a",
    "start": "1832580",
    "end": "1837919"
  },
  {
    "text": "promising future because security belongs in an in-house because that's the way it actually happens so properly",
    "start": "1837919",
    "end": "1843260"
  },
  {
    "text": "implemented hip system has control over the entire system so it can do a lot of different things which you can do never",
    "start": "1843260",
    "end": "1848419"
  },
  {
    "text": "in the network now the question was well would you still recommend a CTO of a large organization who has 5 000",
    "start": "1848419",
    "end": "1854000"
  },
  {
    "text": "workstations to actually implement this kind of technology and it really depends on um",
    "start": "1854000",
    "end": "1860539"
  },
  {
    "text": "you kind of whilst the technology really matters it also has you have to consider risk management you have to consider",
    "start": "1860539",
    "end": "1866360"
  },
  {
    "text": "them the cost and so you might find that maybe a network-based IPS or IDs or",
    "start": "1866360",
    "end": "1872600"
  },
  {
    "text": "whatever might not offer the same type of security but it costs one tenth of the entire solution so it really depends",
    "start": "1872600",
    "end": "1879559"
  },
  {
    "text": "on what you're trying to do what kind of threats you're dealing with um I like IPS I really believe that they",
    "start": "1879559",
    "end": "1885500"
  },
  {
    "text": "have a place in in modern companies but like I said it takes time to get it right it",
    "start": "1885500",
    "end": "1891799"
  },
  {
    "text": "really it's really hard what I covered is really just it's just the top this is just protecting against simple things",
    "start": "1891799",
    "end": "1897020"
  },
  {
    "text": "it's protecting against buffer flows and protecting underlying operating systems when we get into protecting applications we'll get into starting analyzing the",
    "start": "1897020",
    "end": "1904340"
  },
  {
    "text": "system calls and what applications are allowed to do things that get really really hairy Windows unlike Unix has",
    "start": "1904340",
    "end": "1911240"
  },
  {
    "text": "very interesting quote-unquote interesting architecture and it does a lot of interesting things and doing once",
    "start": "1911240",
    "end": "1917299"
  },
  {
    "text": "you get really a little level and you start looking system calls things can get really really interesting so there",
    "start": "1917299",
    "end": "1922460"
  },
  {
    "text": "are a lot of different values to consider a lot of definitions to consider and like I said technology needs time to mature really it's quite",
    "start": "1922460",
    "end": "1927860"
  },
  {
    "text": "in terms of commercial offerings it's really quite new so there's still some issues that are need to be ironed out",
    "start": "1927860",
    "end": "1934279"
  },
  {
    "text": "but I do believe that we'll see you know we already have a radio system installations of systems even though they're",
    "start": "1934279",
    "end": "1940520"
  },
  {
    "text": "vulnerable they're out there but I believe that we'll see more and more of them as uh as",
    "start": "1940520",
    "end": "1945860"
  },
  {
    "text": "as technology gains more acceptance and the implementations will get better I do believe that we will see more of them at",
    "start": "1945860",
    "end": "1952700"
  },
  {
    "text": "least for example on sensitive servers if not across entire Enterprise such as across 5000 workstations",
    "start": "1952700",
    "end": "1959679"
  },
  {
    "text": "the question was how effective is the NOAA execute feature that's implemented in the latest EMD and then picked up by",
    "start": "1969260",
    "end": "1974360"
  },
  {
    "text": "Intel the no execute feature consists of adding an extra bit which is about 30 years overdue",
    "start": "1974360",
    "end": "1981679"
  },
  {
    "text": "um but in particular the problem is that wind the x86 processors such as Intel",
    "start": "1981679",
    "end": "1990080"
  },
  {
    "text": "and AMD processors do not support execute bit on pages meaning that you can make a page read only you can make",
    "start": "1990080",
    "end": "1995960"
  },
  {
    "text": "your page read write but you cannot say that this page is not non-executable you cannot say that your stack segment you",
    "start": "1995960",
    "end": "2002740"
  },
  {
    "text": "cannot execute code from your stack or your from your hip this is why we have this convoluted solution such as",
    "start": "2002740",
    "end": "2008799"
  },
  {
    "text": "providing quote unquote um solutions by trying to detect whether",
    "start": "2008799",
    "end": "2014260"
  },
  {
    "text": "we're writing from a writable page where we basically what APS vendors is trying to do here is do the no execute bit",
    "start": "2014260",
    "end": "2019419"
  },
  {
    "text": "because if we had to no execute bit all along all we have to do is say stack and",
    "start": "2019419",
    "end": "2025299"
  },
  {
    "text": "hip and non-executable and pretty much we don't have to hook anything because the underlying processor will enforce",
    "start": "2025299",
    "end": "2030940"
  },
  {
    "text": "this particular feature now how effective this um feature is well",
    "start": "2030940",
    "end": "2036399"
  },
  {
    "text": "there's several issues to consider first of all in short term it's not very effective because it only works on 64-bit processors at least on AMD so if",
    "start": "2036399",
    "end": "2043720"
  },
  {
    "text": "you don't your if your workstations or your service are not running an amd64 it's not very useful second of all only",
    "start": "2043720",
    "end": "2049599"
  },
  {
    "text": "certain operating systems supported I'm sure a service Back 2 will support it in 2K3 but if you're running 95 don't",
    "start": "2049599",
    "end": "2055720"
  },
  {
    "text": "bother and third of all the technology the sum of the buff",
    "start": "2055720",
    "end": "2060878"
  },
  {
    "text": "overflows some of the integer overflows will not be stopped by this particular",
    "start": "2060879",
    "end": "2065919"
  },
  {
    "text": "feature yes normal simple stack overflows will be prevented but",
    "start": "2065919",
    "end": "2072158"
  },
  {
    "text": "there are other ways of bypassing this feature so basically what it's going to do is going to raise the bar for",
    "start": "2072159",
    "end": "2077378"
  },
  {
    "text": "existing Technologies yes it's a good idea it will take time for it to mature for it to get out there it's a good idea",
    "start": "2077379",
    "end": "2082599"
  },
  {
    "text": "but don't count on it just yet and also going to put some IPS vendors",
    "start": "2082599",
    "end": "2089500"
  },
  {
    "text": "out of business",
    "start": "2089500",
    "end": "2091919"
  },
  {
    "text": "so they're backboarding back to 30-bit processors Intel okay well you know the thing with",
    "start": "2095020",
    "end": "2102400"
  },
  {
    "text": "the Intel Microsoft you know it took them 30 years before they started taking security serious and now they have to play a catch-up game and they're going",
    "start": "2102400",
    "end": "2109420"
  },
  {
    "text": "to cost them a lot more money but nevertheless things are improving slowly but surely",
    "start": "2109420",
    "end": "2115200"
  },
  {
    "text": "maltix was designed in the sixes and it was done right and pretty much everything after that was done not right",
    "start": "2117160",
    "end": "2122680"
  },
  {
    "text": "but will not get we'll not get into that any other questions",
    "start": "2122680",
    "end": "2127960"
  },
  {
    "text": "okay I'm going to show you a brief demo",
    "start": "2127960",
    "end": "2131940"
  },
  {
    "text": "first of all I'm going to run really quick through um simple kernel 32 hook what I did is I",
    "start": "2134680",
    "end": "2141160"
  },
  {
    "text": "wrote a simple code that emulates the hook feature that is it's it gets the",
    "start": "2141160",
    "end": "2148300"
  },
  {
    "text": "return address from stack and make sure it's not unwritable page and then if it is then we you know pop up a message box",
    "start": "2148300",
    "end": "2154720"
  },
  {
    "text": "and if it's not then we just go on so this is basically to demonstrate I know that it might be a little bit hard to",
    "start": "2154720",
    "end": "2160900"
  },
  {
    "text": "for me to explain the entire feature in three slides so I'll think if I show it to you live it'll illustrate a little bit",
    "start": "2160900",
    "end": "2167740"
  },
  {
    "text": "better so what's happening here is we have a function which is called buffer flow protection and what it",
    "start": "2167740",
    "end": "2173800"
  },
  {
    "text": "basically is it's a sample kernel 32 hook or ntgll hook all it does it's",
    "start": "2173800",
    "end": "2180520"
  },
  {
    "text": "it retrieves the return address which is the first d word on stack which has been pushed there by Cold instruction it",
    "start": "2180520",
    "end": "2186460"
  },
  {
    "text": "retrieves the return address from stack and then it does the pseudo check against to see whether it's in a",
    "start": "2186460",
    "end": "2191560"
  },
  {
    "text": "writable page what it actually does it make sure that it's not on stack the stack on the Windows 32 of a primary",
    "start": "2191560",
    "end": "2196839"
  },
  {
    "text": "thread is below usually the binary Base address it's a hack but it doesn't really matter let's step through the",
    "start": "2196839",
    "end": "2202839"
  },
  {
    "text": "code and see what's going on so the first instruction here is going to retrieve the return address on stack like I said it's the first code keyword",
    "start": "2202839",
    "end": "2210400"
  },
  {
    "text": "on stack if we look at the memory here I hope you can see this the first",
    "start": "2210400",
    "end": "2216520"
  },
  {
    "text": "four bytes is our return address you can actually see it in the registry window and the value is 12 fd08 and 12 fd08 is",
    "start": "2216520",
    "end": "2228299"
  },
  {
    "text": "is a stack address it's a stack address so it's under the binary based address so this should potentially this should",
    "start": "2228700",
    "end": "2235839"
  },
  {
    "text": "basically work and we should flag this as a buffer overflow or rather as something running on stack I should",
    "start": "2235839",
    "end": "2242020"
  },
  {
    "text": "mention that there is there are there are some programs that do actually create code on stack and run",
    "start": "2242020",
    "end": "2249280"
  },
  {
    "text": "it from there such as Java Java Java generates some of the code at runtime when stack and runs it so as a matter of",
    "start": "2249280",
    "end": "2254560"
  },
  {
    "text": "fact this particular implementation is going to break some of the Java applications so nevertheless we",
    "start": "2254560",
    "end": "2259660"
  },
  {
    "text": "retrieved the return address and then we do our little check and it fails so",
    "start": "2259660",
    "end": "2267280"
  },
  {
    "text": "we say that buffer also has been detected we terminate the process and we just go",
    "start": "2267280",
    "end": "2272740"
  },
  {
    "text": "on so this pretty much how the IPS vendors designed this so they get their return",
    "start": "2272740",
    "end": "2278320"
  },
  {
    "text": "address from stack if it's writable then let's say we've got a buffer flow end of story",
    "start": "2278320",
    "end": "2283540"
  },
  {
    "text": "Now using identical code identical Shell Code that instead of",
    "start": "2283540",
    "end": "2289660"
  },
  {
    "text": "using a stack based return address that uses our proxy through red technique but",
    "start": "2289660",
    "end": "2296800"
  },
  {
    "text": "otherwise remaining the same bypasses this code and bypasses many other IPS",
    "start": "2296800",
    "end": "2301960"
  },
  {
    "text": "implementations so same code just a slight difference the difference is",
    "start": "2301960",
    "end": "2307839"
  },
  {
    "text": "is that now when we execute the return address fetch if you look in the",
    "start": "2307839",
    "end": "2313119"
  },
  {
    "text": "register window what the value actually is is 41 48 FB now this is above binary Base address",
    "start": "2313119",
    "end": "2319780"
  },
  {
    "text": "what it actually is basically it's it's not on stack",
    "start": "2319780",
    "end": "2324880"
  },
  {
    "text": "so this passes the non-writable check",
    "start": "2324880",
    "end": "2329980"
  },
  {
    "text": "and it passes a no EBP on stack the terminate Soul stack back tracing and if",
    "start": "2329980",
    "end": "2336579"
  },
  {
    "text": "we step through the code then we don't get the buffer flow detected message because",
    "start": "2336579",
    "end": "2342220"
  },
  {
    "text": "our return address is valid it's not on stack if we Trace further down",
    "start": "2342220",
    "end": "2350040"
  },
  {
    "text": "and we actually look what's on stack now we get to our second stack frame which",
    "start": "2351460",
    "end": "2358000"
  },
  {
    "text": "is which is the one that actually has the real return address which is 12 fcfp",
    "start": "2358000",
    "end": "2363640"
  },
  {
    "text": "and that's actually is very similar to the original value which is the stack best based value and now we execute red",
    "start": "2363640",
    "end": "2370140"
  },
  {
    "text": "and we get we regain control of our program so this pretty much illustrates how this",
    "start": "2370140",
    "end": "2376359"
  },
  {
    "text": "works in a little bit more details and so if we continue running then which is going to get done which means that we",
    "start": "2376359",
    "end": "2381640"
  },
  {
    "text": "got to the past past the buffer overflow protection well you might say well this is just a",
    "start": "2381640",
    "end": "2388000"
  },
  {
    "text": "silly example you know I can also throw a couple assembly lines together and it's going to work the problem is it",
    "start": "2388000",
    "end": "2393820"
  },
  {
    "text": "actually works in practice now I've got a VMware here which has a simple IPS",
    "start": "2393820",
    "end": "2401440"
  },
  {
    "text": "running on it and it has two versions but it just shows you one that",
    "start": "2401440",
    "end": "2408660"
  },
  {
    "text": "does not use bypassing techniques it just calls the low Library directly or whatever the API was and the other one",
    "start": "2408760",
    "end": "2416079"
  },
  {
    "text": "actually tries to colloid Library by creating a fake frame and we if we run no bypass it immediately terminates the",
    "start": "2416079",
    "end": "2422619"
  },
  {
    "text": "reason why it immediately determinates is because the Shell Code or the IPS picks up the fact that it's running off",
    "start": "2422619",
    "end": "2428020"
  },
  {
    "text": "the stack and it terminates it executing identical code that uses our",
    "start": "2428020",
    "end": "2434020"
  },
  {
    "text": "fake frame thickening if we run it it actually is not terminated as we again we get the done",
    "start": "2434020",
    "end": "2440500"
  },
  {
    "text": "prompt which means that we got passed at this point we have successfully loaded an arbitrary dll that is we executed",
    "start": "2440500",
    "end": "2446940"
  },
  {
    "text": "malicious code in the system and then if we look at the log of the synonymous",
    "start": "2446940",
    "end": "2453040"
  },
  {
    "text": "IPS we see that it's a generic buffer overflow on the C no bypass executable",
    "start": "2453040",
    "end": "2459280"
  },
  {
    "text": "which means that if we detected or the IPS is detected that there was a code running off stack",
    "start": "2459280",
    "end": "2466599"
  },
  {
    "text": "so very simple kicking that's very very effective against a lot of different ips's out there",
    "start": "2466599",
    "end": "2473200"
  },
  {
    "text": "so that pretty much concludes my talk if you have any",
    "start": "2473200",
    "end": "2478240"
  },
  {
    "text": "further questions about this feel free tonight thank you",
    "start": "2478240",
    "end": "2486300"
  },
  {
    "text": "foreign",
    "start": "2645339",
    "end": "2647640"
  },
  {
    "text": "foreign",
    "start": "2823119",
    "end": "2826078"
  }
]