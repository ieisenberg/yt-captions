[
  {
    "text": "welcome everyone yeah today we'll present you how we broke out of the gas environment in BMR and compromised the",
    "start": "2960",
    "end": "11040"
  },
  {
    "text": "host color we'll work through the key steps and challenge we overcame to",
    "start": "11040",
    "end": "16560"
  },
  {
    "text": "achieve this demonstrating the power of training",
    "start": "16560",
    "end": "21439"
  },
  {
    "text": "exploits our presentation is divided into three main sections first in the",
    "start": "21960",
    "end": "27359"
  },
  {
    "text": "VML and Windows corner patch we'll deep we'll dive into the vulnerabilities and",
    "start": "27359",
    "end": "33280"
  },
  {
    "text": "exploitation standards for each then in the training section we'll",
    "start": "33280",
    "end": "39120"
  },
  {
    "text": "wrap it up by showing how we link the to achieve our final",
    "start": "39120",
    "end": "46239"
  },
  {
    "text": "goal i'm Kang Jang and this is Jenry we are both part of vulnerable research",
    "start": "48280",
    "end": "53680"
  },
  {
    "text": "team at theory where we conduct exciting research focused on binary analysis and",
    "start": "53680",
    "end": "61600"
  },
  {
    "text": "exploitation we began this research with go competing in ponton 2024 focusing on",
    "start": "62760",
    "end": "69840"
  },
  {
    "text": "the virtualization category specifically targeting VMware workstation",
    "start": "69840",
    "end": "75840"
  },
  {
    "text": "the challenge included not only compromising the guest environment but also escaping privileges through a",
    "start": "75840",
    "end": "82720"
  },
  {
    "text": "window corner vulnerability on the host this inspired us to develop the",
    "start": "82720",
    "end": "89040"
  },
  {
    "text": "chain multiple exploit which we'll be working through",
    "start": "89040",
    "end": "94680"
  },
  {
    "text": "today and in this part I'll be explaining the vulnerabilities we discovered in BMR workstation and how we",
    "start": "94680",
    "end": "102159"
  },
  {
    "text": "exploit them let's begin by introducing hypervisors",
    "start": "102159",
    "end": "108799"
  },
  {
    "text": "hypervisor also known as virtual machine monitor is technology that facilitates",
    "start": "108799",
    "end": "114399"
  },
  {
    "text": "the creation and management of virtual machines it can be implemented as a",
    "start": "114399",
    "end": "119960"
  },
  {
    "text": "serier firmware or hardware hypervisor typically divided into two types type",
    "start": "119960",
    "end": "126320"
  },
  {
    "text": "one and type two type one hypervisor often called bare metal hypervisor run",
    "start": "126320",
    "end": "132239"
  },
  {
    "text": "directly on the host hardware in construct type two hypervisor operates as an application",
    "start": "132239",
    "end": "139200"
  },
  {
    "text": "royer on top of host operating system example of type one hypervisor",
    "start": "139200",
    "end": "145599"
  },
  {
    "text": "include KVM hypob and ESXi for type two",
    "start": "145599",
    "end": "151239"
  },
  {
    "text": "hypervisors examples include BML workstation which is our research",
    "start": "151239",
    "end": "156480"
  },
  {
    "text": "purpose along with virtual box and fiberator next let's move on the concept",
    "start": "156480",
    "end": "164560"
  },
  {
    "text": "of VM escape vm escape refers to a vulnerability that allows a guest",
    "start": "164560",
    "end": "169760"
  },
  {
    "text": "virtual machine to break out of its isolated environment and interact with",
    "start": "169760",
    "end": "175040"
  },
  {
    "text": "the host system or other systems our goal was gain access to the host to we",
    "start": "175040",
    "end": "182080"
  },
  {
    "text": "focused on vulnerabilities that could lead to code execution or information",
    "start": "182080",
    "end": "188920"
  },
  {
    "text": "leakage we started by examining publicly available on day in hypervisor hoping to",
    "start": "188920",
    "end": "195760"
  },
  {
    "text": "uncover Jay vulnerabilities while platform like HyperV do not",
    "start": "195760",
    "end": "201360"
  },
  {
    "text": "disclose specific bug details we concentrated on VMware virtual box and",
    "start": "201360",
    "end": "207200"
  },
  {
    "text": "QM later where more detail information was",
    "start": "207200",
    "end": "212480"
  },
  {
    "text": "available as shown on the slide most hypervisor vulnerabilities are found in",
    "start": "212519",
    "end": "218480"
  },
  {
    "text": "virtual devices however there are case where bugs have been discouraged in",
    "start": "218480",
    "end": "224640"
  },
  {
    "text": "other functionalities such as artificial mechanism or guess physical address",
    "start": "224640",
    "end": "229840"
  },
  {
    "text": "request handling based on these findings we decide to explore the virtual device",
    "start": "229840",
    "end": "236640"
  },
  {
    "text": "implementation of hypervisors for finding new",
    "start": "236640",
    "end": "242040"
  },
  {
    "text": "vulnerabilities dur identified two key vulnerabilities the",
    "start": "242040",
    "end": "247360"
  },
  {
    "text": "first is an information range vulnerability in the MVME implementation the second is a user of",
    "start": "247360",
    "end": "254640"
  },
  {
    "text": "free is in VM feature both vulnerability were",
    "start": "254640",
    "end": "259919"
  },
  {
    "text": "successfully exploit enabling us to escape from the guest to the",
    "start": "259919",
    "end": "266040"
  },
  {
    "text": "host but challenge arose during our work two weeks before the registration",
    "start": "266040",
    "end": "272080"
  },
  {
    "text": "deadline BML issued a patch targeting vulnerability discovered during the TM",
    "start": "272080",
    "end": "277840"
  },
  {
    "text": "cup last October unfortunately one of our vulnerability which found in MVME",
    "start": "277840",
    "end": "284560"
  },
  {
    "text": "was silently fixed as part of the update",
    "start": "284560",
    "end": "290360"
  },
  {
    "text": "we redirected our focus to a different tech service the host guess file sharing",
    "start": "291120",
    "end": "296880"
  },
  {
    "text": "feature or HGFS we identified a new vulnerability",
    "start": "296880",
    "end": "302240"
  },
  {
    "text": "in this component developed on exploit and successfully test in just one day",
    "start": "302240",
    "end": "308160"
  },
  {
    "text": "before the submission deadline let's now dive deeper into the details of what vulnerability we",
    "start": "308160",
    "end": "315240"
  },
  {
    "text": "discovered starting with the HFS",
    "start": "315240",
    "end": "320400"
  },
  {
    "text": "issue the first vulnerability involved uninitialized hip memory in the host",
    "start": "320840",
    "end": "326240"
  },
  {
    "text": "guest file sharing feature hfs allows the guest to access the host file system facilitating file",
    "start": "326240",
    "end": "334240"
  },
  {
    "text": "sharing operations vmr provides two communication channels for this purpose",
    "start": "334240",
    "end": "340840"
  },
  {
    "text": "VMCI and back door during this channel the guest can invoke various fish",
    "start": "340840",
    "end": "347440"
  },
  {
    "text": "functions including those used by",
    "start": "347440",
    "end": "352560"
  },
  {
    "text": "HJFS let's take a closer look at the root cause of this vulnerability when",
    "start": "352840",
    "end": "358080"
  },
  {
    "text": "the guest leaves a shared file from the host the HFS file read function is",
    "start": "358080",
    "end": "363639"
  },
  {
    "text": "invoked this function is responsible for handling file read requests as part of",
    "start": "363639",
    "end": "369440"
  },
  {
    "text": "host gas file sharing feature internally the HFS valid function called",
    "start": "369440",
    "end": "376880"
  },
  {
    "text": "the amalo function to allocate a response ber which will hold the data to",
    "start": "376880",
    "end": "382720"
  },
  {
    "text": "be sent back to the guest the size of allocated buffer is",
    "start": "382720",
    "end": "388160"
  },
  {
    "text": "determined by the protocol version for version one the buffer size is set to",
    "start": "388160",
    "end": "394360"
  },
  {
    "text": "h1 however the critical issue lies in how the memory is allocated and",
    "start": "394360",
    "end": "399680"
  },
  {
    "text": "initialized the MLO function does not initialize the memory it allocates",
    "start": "399680",
    "end": "404880"
  },
  {
    "text": "leaving parts of it in an uninsurized state let's examine the memory",
    "start": "404880",
    "end": "412160"
  },
  {
    "text": "initialization some process in more detail using both code and diagram to illustrate the issue when the buffer is",
    "start": "412160",
    "end": "419960"
  },
  {
    "text": "allocated only a portion of memory is filled with actual response data that",
    "start": "419960",
    "end": "426080"
  },
  {
    "text": "could respond to the requested part the remaining portion of the burper",
    "start": "426080",
    "end": "432080"
  },
  {
    "text": "remains uninterized as a result data from the host heap data should remain",
    "start": "432080",
    "end": "437759"
  },
  {
    "text": "private can be inadcluded in the response ber sent back",
    "start": "437759",
    "end": "442800"
  },
  {
    "text": "to the guest this creates an information leakage vulner because the uninitialized",
    "start": "442800",
    "end": "449199"
  },
  {
    "text": "memory may contain sensitive data from the host environment",
    "start": "449199",
    "end": "455160"
  },
  {
    "text": "to exploit this vulnerability we needed to write a client that supports HFS",
    "start": "455520",
    "end": "460800"
  },
  {
    "text": "version one the challenge was that HFS over VMCI the channel uses the",
    "start": "460800",
    "end": "468080"
  },
  {
    "text": "communication between the guest and host is not fully implemented in the open BM",
    "start": "468080",
    "end": "474240"
  },
  {
    "text": "tools project additionally the official Windows guest tools only supports HFS",
    "start": "474240",
    "end": "479759"
  },
  {
    "text": "version two which doesn't exhibit the same vulnerability",
    "start": "479759",
    "end": "485919"
  },
  {
    "text": "to overcome this limitation we hooked the guest filter driver uh component in",
    "start": "485919",
    "end": "491199"
  },
  {
    "text": "Windows that handled par sharing requests to help us manipulate and trigger the",
    "start": "491199",
    "end": "499120"
  },
  {
    "text": "vulnerability here's how the process works uh when a shared file is accessed",
    "start": "499319",
    "end": "506160"
  },
  {
    "text": "through the Windows file system the private driver generates an HFS version to",
    "start": "506160",
    "end": "512120"
  },
  {
    "text": "request this request is sent to the host via the VMCI channel the host process",
    "start": "512120",
    "end": "518800"
  },
  {
    "text": "the request and return the return result as an HFS version two response to",
    "start": "518800",
    "end": "525839"
  },
  {
    "text": "exploit the bug we insert hooks with the filter driver to intercept and modify",
    "start": "525839",
    "end": "532320"
  },
  {
    "text": "the HFS request it generates the exploitation steps are at",
    "start": "532320",
    "end": "539680"
  },
  {
    "text": "follow first our hooks intercept the HF's version two requests generated by",
    "start": "539680",
    "end": "546160"
  },
  {
    "text": "filter driver we then modify the request converting it into the format of an HFS",
    "start": "546160",
    "end": "554080"
  },
  {
    "text": "version one request second the modified request is sent to the host via FMCI",
    "start": "554080",
    "end": "560800"
  },
  {
    "text": "channel where it is processed as if it were a regime HFS version one request",
    "start": "560800",
    "end": "568240"
  },
  {
    "text": "because the host process this as a version request it allocates the response ber using the logic specific to",
    "start": "568240",
    "end": "576320"
  },
  {
    "text": "the HF's version one",
    "start": "576320",
    "end": "580600"
  },
  {
    "text": "third once the host returns a response we extract and back up the uninitialized",
    "start": "583360",
    "end": "590399"
  },
  {
    "text": "data from the response wrapper to our temporary space in memory finally to",
    "start": "590399",
    "end": "595600"
  },
  {
    "text": "maintain compatibility with the rest of the system we modify the response back",
    "start": "595600",
    "end": "601360"
  },
  {
    "text": "to the HFS version to format so that it can be processed correctly by the filter",
    "start": "601360",
    "end": "608600"
  },
  {
    "text": "driver to further exploit this vulnerability we needed to identify the base address of VMR VMS module to",
    "start": "608600",
    "end": "617120"
  },
  {
    "text": "achieve this we sprayed memory with CDM related object which have a same size as",
    "start": "617120",
    "end": "623279"
  },
  {
    "text": "the response ber and contain the address of VML VX water",
    "start": "623279",
    "end": "630720"
  },
  {
    "text": "the rational for using these object is that their memory layout often includes",
    "start": "630720",
    "end": "636000"
  },
  {
    "text": "pointer that leave the address of the VM VMX module by repeatly triggering the",
    "start": "636000",
    "end": "643320"
  },
  {
    "text": "vulnerability we were able to get the VM VMX module address from the uninsurized",
    "start": "643320",
    "end": "649880"
  },
  {
    "text": "data returned in the response if successful we can obtain the",
    "start": "649880",
    "end": "657200"
  },
  {
    "text": "base address a critical piece of information needed for further",
    "start": "657200",
    "end": "664959"
  },
  {
    "text": "exploitation let's now discuss uh let's now discuss the second vulnerability we",
    "start": "666680",
    "end": "672839"
  },
  {
    "text": "discovered this vulnerability is a user free is in VMR virtual feature the",
    "start": "672839",
    "end": "679440"
  },
  {
    "text": "virtual Bluetooth feature is designed to allow designed to allow the guest to",
    "start": "679440",
    "end": "686800"
  },
  {
    "text": "connect the Bluetooth device via the receiver plugged in the host since this feature operates over",
    "start": "686800",
    "end": "694800"
  },
  {
    "text": "USB it processed USB cast blocks or URPs to handle communication we identified",
    "start": "694800",
    "end": "702160"
  },
  {
    "text": "this vulnerability during our analysis of URB processing logic in virtual",
    "start": "702160",
    "end": "707680"
  },
  {
    "text": "device let's take a closer look at the root of",
    "start": "707680",
    "end": "712880"
  },
  {
    "text": "this vulnerability when the USB controller sends a URB to the ber device it is",
    "start": "712880",
    "end": "720320"
  },
  {
    "text": "passed to a function called V submit URB this function inspect the endpoint of",
    "start": "720320",
    "end": "728079"
  },
  {
    "text": "the incoming URB and then passed it to the V USBQ submit URB which adds it a",
    "start": "728079",
    "end": "734240"
  },
  {
    "text": "queue for processing the B USB submit URB function creates a",
    "start": "734240",
    "end": "741440"
  },
  {
    "text": "Q node stores the URB object address and append the node to the queue the",
    "start": "741440",
    "end": "747839"
  },
  {
    "text": "critical flow here that the URB object reference count is not incremented at",
    "start": "747839",
    "end": "754160"
  },
  {
    "text": "this stage this oversight is where the vulnerability",
    "start": "754160",
    "end": "759680"
  },
  {
    "text": "begins as the queue is processed by B USPQ handle URB functions each URB in",
    "start": "761480",
    "end": "768560"
  },
  {
    "text": "the queue is iterated over and handled once processing is complete the URB",
    "start": "768560",
    "end": "775200"
  },
  {
    "text": "object should perform power following up action such as returning data to the",
    "start": "775200",
    "end": "780240"
  },
  {
    "text": "guest or bringing assoc associated resource to avoid return the followup",
    "start": "780240",
    "end": "787600"
  },
  {
    "text": "tasks are registered as a job to a polling Q which a worker thread process",
    "start": "787600",
    "end": "793760"
  },
  {
    "text": "generator now let's look at how USB reset command",
    "start": "793760",
    "end": "801040"
  },
  {
    "text": "contribute this to this issue usb device supports various commands for device",
    "start": "801040",
    "end": "807880"
  },
  {
    "text": "management among these the reset command pically resets the device in the virtual",
    "start": "807880",
    "end": "813839"
  },
  {
    "text": "USB implementation issuing a reset reset command the reference or pipe object and",
    "start": "813839",
    "end": "820480"
  },
  {
    "text": "their associate urb the problem arises because the",
    "start": "820480",
    "end": "825680"
  },
  {
    "text": "reference counter for the URB object was never incremented during submission as a",
    "start": "825680",
    "end": "831600"
  },
  {
    "text": "result the reset command freeze the URB object even if it's still ceued for",
    "start": "831600",
    "end": "837519"
  },
  {
    "text": "followup processing now let's now break down how",
    "start": "837519",
    "end": "846240"
  },
  {
    "text": "this vulnerability can be triggered first the guest sends a URB to the bot",
    "start": "846240",
    "end": "853480"
  },
  {
    "text": "device once the URB processing is complete the URB object and handler",
    "start": "853480",
    "end": "858639"
  },
  {
    "text": "function are registered as a job the polling Q next before the polling worker",
    "start": "858639",
    "end": "866639"
  },
  {
    "text": "executes this job the guest send a reset command to the virtual device via a",
    "start": "866639",
    "end": "873360"
  },
  {
    "text": "control type URB this command reset the device causing it to reference and free",
    "start": "873360",
    "end": "880560"
  },
  {
    "text": "the URB object while it is still pending in the polling",
    "start": "880560",
    "end": "886879"
  },
  {
    "text": "queue before the polling Q associate the freed object we sprayed the memory with",
    "start": "891800",
    "end": "898720"
  },
  {
    "text": "object of the same size to acpy the freed memory space",
    "start": "898720",
    "end": "903839"
  },
  {
    "text": "bmr's BMCI feature allows us to allocate controller memory enabling us to spray a",
    "start": "903839",
    "end": "910880"
  },
  {
    "text": "fake URB object in the freed memory",
    "start": "910880",
    "end": "916240"
  },
  {
    "text": "region here's how we use this vulnerability to achieve arbitary code",
    "start": "916760",
    "end": "922199"
  },
  {
    "text": "execution the bu USB complete URB function which processes the URB called",
    "start": "922199",
    "end": "928240"
  },
  {
    "text": "another function called BU USB complete URB at batch this function contains an",
    "start": "928240",
    "end": "934959"
  },
  {
    "text": "indirect core whose target address is taken from the UR object data since we",
    "start": "934959",
    "end": "941680"
  },
  {
    "text": "already had the base address of VMware VMX module from the first vulnerability",
    "start": "941680",
    "end": "947519"
  },
  {
    "text": "we use this address to control the URB object data this allows us redirect the",
    "start": "947519",
    "end": "954399"
  },
  {
    "text": "indirect core to execute a code however there are an additional",
    "start": "954399",
    "end": "961199"
  },
  {
    "text": "challenge control flow gut or CFD the VMware VMX binary is protected",
    "start": "961199",
    "end": "967279"
  },
  {
    "text": "by GFG which limits the function that can be called",
    "start": "967279",
    "end": "972519"
  },
  {
    "text": "indirectly to pip to bypass this we construct a return oriented programming",
    "start": "972519",
    "end": "978639"
  },
  {
    "text": "or ROP chain using GFG compatible gadgets",
    "start": "978639",
    "end": "985320"
  },
  {
    "text": "first we needed to we needed the RP chain to pivot each first argument to",
    "start": "986320",
    "end": "991839"
  },
  {
    "text": "the controllable memory region to achieve this we redirect the P argument",
    "start": "991839",
    "end": "998480"
  },
  {
    "text": "to the guest physical memory space which is accessible to both the guest and host",
    "start": "998480",
    "end": "1006480"
  },
  {
    "text": "an ad advantage of this approach is that the base address of gas physical memory",
    "start": "1006480",
    "end": "1012560"
  },
  {
    "text": "is stored in the data section of BMR VMX additionally the first page of physical",
    "start": "1012560",
    "end": "1019920"
  },
  {
    "text": "memory remains unused after foot pivoting a predictable and safe",
    "start": "1019920",
    "end": "1026240"
  },
  {
    "text": "location for our payload",
    "start": "1026240",
    "end": "1030280"
  },
  {
    "text": "since we already know the base address of VMware VMX we can modify the URB",
    "start": "1031439",
    "end": "1037438"
  },
  {
    "text": "object to make the pipe object point the data section where the physical memory",
    "start": "1037439",
    "end": "1042640"
  },
  {
    "text": "address is stored by adjusting a pipe object to",
    "start": "1042640",
    "end": "1047918"
  },
  {
    "text": "point the device object to physical memory we can gain control over the device object",
    "start": "1047919",
    "end": "1055280"
  },
  {
    "text": "data following the same method described in the previous slide by setting the device object po",
    "start": "1056039",
    "end": "1063919"
  },
  {
    "text": "point to the data section we can make the pre table point to the guest",
    "start": "1063919",
    "end": "1069600"
  },
  {
    "text": "physical memory once this is done we can call a shape",
    "start": "1069600",
    "end": "1075760"
  },
  {
    "text": "gessing explain the process of pivoting the first segment of the gas gadget to",
    "start": "1077320",
    "end": "1083520"
  },
  {
    "text": "the gas physical memory first we set the URB object data and core gadget zero",
    "start": "1083520",
    "end": "1090320"
  },
  {
    "text": "this gadget enables us to change the RGX register to a physical memory",
    "start": "1090320",
    "end": "1095400"
  },
  {
    "text": "address and redirect the execution flow to the address stored in the data",
    "start": "1095400",
    "end": "1100760"
  },
  {
    "text": "section however since the guest cannot write directly to the VM VMX data",
    "start": "1100760",
    "end": "1107200"
  },
  {
    "text": "section we use an additional gadget to bypass this limitation",
    "start": "1107200",
    "end": "1114360"
  },
  {
    "text": "next we select a gadget from the function address stored in the r data section while there are limitation in",
    "start": "1115039",
    "end": "1122240"
  },
  {
    "text": "the section of gadget the gadget we choose only need to train the next one by using the data",
    "start": "1122240",
    "end": "1130000"
  },
  {
    "text": "provided in the first argument now that is first argument",
    "start": "1130000",
    "end": "1137440"
  },
  {
    "text": "point the guess address we gain full control over it allowing us to",
    "start": "1137440",
    "end": "1143039"
  },
  {
    "text": "manipulate the first segment as needed this enabled us to core any GFC",
    "start": "1143039",
    "end": "1149039"
  },
  {
    "text": "compatible gadget at this point system command",
    "start": "1149039",
    "end": "1154480"
  },
  {
    "text": "could be executed using only RP however we decided to chain a Windows local",
    "start": "1154480",
    "end": "1160720"
  },
  {
    "text": "privilege escalation as this allows us to achieve a higher reward during the",
    "start": "1160720",
    "end": "1167039"
  },
  {
    "text": "competition to do so we crafted the exploit to",
    "start": "1167039",
    "end": "1172720"
  },
  {
    "text": "execute a share code leveraging this approach to finalize our tech",
    "start": "1172720",
    "end": "1178880"
  },
  {
    "text": "fortunately our UF vulnerability does not trigger a panic when probably",
    "start": "1178880",
    "end": "1185240"
  },
  {
    "text": "executed and it can be reliably triggered multiple times additionally",
    "start": "1185240",
    "end": "1192480"
  },
  {
    "text": "PML PMX lo modules that are not p uh not",
    "start": "1192480",
    "end": "1197919"
  },
  {
    "text": "sorry additionally PMX lo modules that are not protected by CFG which further",
    "start": "1197919",
    "end": "1204559"
  },
  {
    "text": "simplified the exploit process the process of executing the",
    "start": "1204559",
    "end": "1211200"
  },
  {
    "text": "share code is as follows first we trigger the UF we trigger the UF to read",
    "start": "1211200",
    "end": "1217840"
  },
  {
    "text": "the base address of physical memory which is then used for a memory read write",
    "start": "1217840",
    "end": "1223480"
  },
  {
    "text": "operations next we use abitary memory reads to obtain the address of virtual",
    "start": "1223480",
    "end": "1229200"
  },
  {
    "text": "protect function and recruit module then we select an unused memory space and",
    "start": "1229200",
    "end": "1234960"
  },
  {
    "text": "assign our WX permissions and then write the share code to there finally we",
    "start": "1234960",
    "end": "1240640"
  },
  {
    "text": "execute the share code using the jump RX gadget from the recrypt module with this step complete we are",
    "start": "1240640",
    "end": "1248080"
  },
  {
    "text": "now ready to escape the VM and execute the Windows RP",
    "start": "1248080",
    "end": "1254000"
  },
  {
    "text": "exploit okay hi uh I'm Jun Lee uh in this part uh we'll be discussing a",
    "start": "1256919",
    "end": "1263360"
  },
  {
    "text": "Windows kernel vulnerability that was exploited in the VMR chain so we'll",
    "start": "1263360",
    "end": "1269280"
  },
  {
    "text": "cover the attack vector and the bug itself with a particular focus on how it",
    "start": "1269280",
    "end": "1275679"
  },
  {
    "text": "was exploited by the end uh you will know how to bypass uh hardened KAS error and",
    "start": "1275679",
    "end": "1282880"
  },
  {
    "text": "other protection techniques the vulnerability we'll be",
    "start": "1282880",
    "end": "1288960"
  },
  {
    "text": "discussing exist in the cloud file mini filter commonly known as cloud filter",
    "start": "1288960",
    "end": "1295200"
  },
  {
    "text": "this file system filter help manage files and directories shared on Microsoft one",
    "start": "1295200",
    "end": "1301559"
  },
  {
    "text": "drive since it is a file system related driver uh it includes a large number of",
    "start": "1301559",
    "end": "1307760"
  },
  {
    "text": "functions around a thousand in total and multiple attack",
    "start": "1307760",
    "end": "1313000"
  },
  {
    "text": "vectors two primary attack vectors for this filter driver include the file",
    "start": "1313000",
    "end": "1318159"
  },
  {
    "text": "operation filter and the file uh filter communication port",
    "start": "1318159",
    "end": "1323679"
  },
  {
    "text": "additionally uh placeholders that manage one drive files can also be",
    "start": "1323679",
    "end": "1330280"
  },
  {
    "text": "targeted this cloud filter has been the focus of several successful exploits",
    "start": "1330280",
    "end": "1336559"
  },
  {
    "text": "including a blog post from Star Labs and the vulnerability exploited by Sective",
    "start": "1336559",
    "end": "1342400"
  },
  {
    "text": "at Ponto on last year now uh let's take a look at how we",
    "start": "1342400",
    "end": "1350000"
  },
  {
    "text": "discovered this bug the vulnerability occurs in cloud filters handling of",
    "start": "1350000",
    "end": "1355840"
  },
  {
    "text": "repar data and this attack vector became wellknown following the technical",
    "start": "1355840",
    "end": "1361600"
  },
  {
    "text": "analysis of CBE 2021 31",
    "start": "1361600",
    "end": "1367080"
  },
  {
    "text": "31969 last year uh another in the wild vulnerability was discovered uh in this",
    "start": "1367080",
    "end": "1373360"
  },
  {
    "text": "attack vector as we analyze it uh we realized that this was an interesting surface so",
    "start": "1373360",
    "end": "1380960"
  },
  {
    "text": "we decided to look further uh which led us to discover a new",
    "start": "1380960",
    "end": "1387200"
  },
  {
    "text": "vulnerability uh here's a simplified version of the code used for storing repress point data to be processed by",
    "start": "1387480",
    "end": "1394720"
  },
  {
    "text": "cloud filter repar point data can be stored using the set reparoint control in the",
    "start": "1394720",
    "end": "1401600"
  },
  {
    "text": "file system the repar tag here uh specify the",
    "start": "1401600",
    "end": "1406720"
  },
  {
    "text": "type of repar data being stored if we store data with a tag processed by",
    "start": "1406720",
    "end": "1413280"
  },
  {
    "text": "cloud filter like cloud on_3 uh the system will parse it when a file",
    "start": "1413280",
    "end": "1420960"
  },
  {
    "text": "operation such as opening a file uses reparoint information uh the stored data",
    "start": "1420960",
    "end": "1427200"
  },
  {
    "text": "will be processed internally cloud filters",
    "start": "1427200",
    "end": "1432720"
  },
  {
    "text": "repoint data relies on special structure called HSM",
    "start": "1432720",
    "end": "1438200"
  },
  {
    "text": "data hsm data contains multiple elements with different types like bite long or",
    "start": "1438200",
    "end": "1444880"
  },
  {
    "text": "byte stream each are defined by uh offset and length in cloud filters HSM data",
    "start": "1444880",
    "end": "1452799"
  },
  {
    "text": "structure there are exactly 10 elements",
    "start": "1452799",
    "end": "1457639"
  },
  {
    "text": "the vulnerability arises during the parsing uh and storage of bit map",
    "start": "1458240",
    "end": "1463600"
  },
  {
    "text": "information uh held by some elements one of the elements uh element 4 can store",
    "start": "1463600",
    "end": "1469919"
  },
  {
    "text": "up to hex thousand bytes of data when moving the data of element four to newly",
    "start": "1469919",
    "end": "1476320"
  },
  {
    "text": "allocated buffer there is a length validation but even if this check fails",
    "start": "1476320",
    "end": "1481919"
  },
  {
    "text": "copying still occurs this makes the length validation meaningless allowing an attacker to pass",
    "start": "1481919",
    "end": "1488640"
  },
  {
    "text": "a value larger than hex thousand and lead to a heap of",
    "start": "1488640",
    "end": "1494480"
  },
  {
    "text": "overflow interestingly uh there is a routine that validate each element",
    "start": "1494679",
    "end": "1499919"
  },
  {
    "text": "header value before the vulnerable function is called for element four",
    "start": "1499919",
    "end": "1505279"
  },
  {
    "text": "there is a check to ensure the length doesn't exceed hex thousand",
    "start": "1505279",
    "end": "1510320"
  },
  {
    "text": "however if element two which is a by type flag is zero the validation is",
    "start": "1510320",
    "end": "1516240"
  },
  {
    "text": "bypassed allowing the vulnerability to be triggered so what can we achieve with",
    "start": "1516240",
    "end": "1523919"
  },
  {
    "text": "this vulnerability first uh we can trigger heap of overflow uh in chunk of",
    "start": "1523919",
    "end": "1530080"
  },
  {
    "text": "hex,000 bytes in the paste pool where the chunk size is fixed moreover uh if",
    "start": "1530080",
    "end": "1536720"
  },
  {
    "text": "you check the part that retrieve repress point data you will notice it can read",
    "start": "1536720",
    "end": "1542480"
  },
  {
    "text": "up to hex 4,000 bytes of data while more data can be stored due",
    "start": "1542480",
    "end": "1548320"
  },
  {
    "text": "to compression format hex 4,000 bytes is more than sufficient for our",
    "start": "1548320",
    "end": "1554600"
  },
  {
    "text": "exploit since repress point data can store arbitrary uh data we can fully",
    "start": "1554600",
    "end": "1560559"
  },
  {
    "text": "control the overflowed content now uh we know the potential uh",
    "start": "1560559",
    "end": "1566960"
  },
  {
    "text": "let's explore how how we uh use these conditions to build a reliable",
    "start": "1566960",
    "end": "1573640"
  },
  {
    "text": "exploit the first object we considered for our exploit strategy was the Windows",
    "start": "1573640",
    "end": "1578799"
  },
  {
    "text": "notification factory or WNF object when WNF generates state data it creates a",
    "start": "1578799",
    "end": "1586799"
  },
  {
    "text": "WNF state data object which is commonly used in paste pool hips sprays for",
    "start": "1586799",
    "end": "1592559"
  },
  {
    "text": "Windows kernel exploit this object is size mutable and",
    "start": "1592559",
    "end": "1597919"
  },
  {
    "text": "by overriding the data size member we can gain a powerful primitive using this",
    "start": "1597919",
    "end": "1604320"
  },
  {
    "text": "we can perform out of bound write while updating state data as well as out of",
    "start": "1604320",
    "end": "1609440"
  },
  {
    "text": "bound read by querying state data initially this seemed like a",
    "start": "1609440",
    "end": "1615679"
  },
  {
    "text": "straightforward way to complete the exploit however if you see the creation",
    "start": "1615679",
    "end": "1620720"
  },
  {
    "text": "of the WNF object you will notice a max state size check this limit the size of a WNF state",
    "start": "1620720",
    "end": "1629520"
  },
  {
    "text": "data object to no more than hex,000 luckily uh since the vulnerability",
    "start": "1629520",
    "end": "1635440"
  },
  {
    "text": "causing chunk was also hex thousand bytes it wasn't a problem for object",
    "start": "1635440",
    "end": "1642760"
  },
  {
    "text": "spray next we looked at the state data update function used for performing out",
    "start": "1642760",
    "end": "1648880"
  },
  {
    "text": "of right unfortunately there is a validation on the data size which correspond to the",
    "start": "1648880",
    "end": "1655919"
  },
  {
    "text": "size of the overwritten data so we couldn't directly use this function in our exploit",
    "start": "1655919",
    "end": "1662880"
  },
  {
    "text": "if the size of the data to be overwritten exceed max state size the function returns an error meaning an out",
    "start": "1662880",
    "end": "1669600"
  },
  {
    "text": "of right larger than hex,000 by couldn't be",
    "start": "1669600",
    "end": "1674880"
  },
  {
    "text": "triggered we then reviewed the state data query function which is used for",
    "start": "1675080",
    "end": "1680320"
  },
  {
    "text": "performing out of read interestingly this function passes zero as the size",
    "start": "1680320",
    "end": "1686080"
  },
  {
    "text": "when validating the data size meaning that it always passes the validation",
    "start": "1686080",
    "end": "1691120"
  },
  {
    "text": "against max state size this allows us to still use the outbound read",
    "start": "1691120",
    "end": "1698799"
  },
  {
    "text": "primitive given this constraint we had to find a new object to use in our",
    "start": "1699000",
    "end": "1705159"
  },
  {
    "text": "exploitation the object we chose was the maze load object a M load is used for",
    "start": "1705159",
    "end": "1711279"
  },
  {
    "text": "one-way communication between processes in Windows the receiving thread create a",
    "start": "1711279",
    "end": "1718080"
  },
  {
    "text": "mail slot to read incoming data and if no data is received the thread wait for",
    "start": "1718080",
    "end": "1723919"
  },
  {
    "text": "a timeout the sending thread can open the specified mail slope pass with write",
    "start": "1723919",
    "end": "1730240"
  },
  {
    "text": "permissions to send messages and the mail slot can hold multiple",
    "start": "1730240",
    "end": "1736799"
  },
  {
    "text": "messages as mentioned earlier the measo can store multiple messages which are",
    "start": "1736840",
    "end": "1743120"
  },
  {
    "text": "held in the data entry queue this is quite similar to the data",
    "start": "1743120",
    "end": "1748159"
  },
  {
    "text": "entry used in named pipe so when a message is received misload",
    "start": "1748159",
    "end": "1753840"
  },
  {
    "text": "allocate an object containing a buffer equal to the size of the data received",
    "start": "1753840",
    "end": "1759919"
  },
  {
    "text": "and associated with a misload context object as part of the linked",
    "start": "1759919",
    "end": "1766640"
  },
  {
    "text": "list let's look at how the mlot data entry object help in",
    "start": "1767320",
    "end": "1772679"
  },
  {
    "text": "exploitation first this object is size mutable as you can see from the buffer",
    "start": "1772679",
    "end": "1778720"
  },
  {
    "text": "member on the right it stores the content of the received data meaning",
    "start": "1778720",
    "end": "1783919"
  },
  {
    "text": "that you can adjust the object size by varying the length of the",
    "start": "1783919",
    "end": "1789240"
  },
  {
    "text": "data this is crucial when performing hip sprrays in Windows kernel additionally",
    "start": "1789240",
    "end": "1795679"
  },
  {
    "text": "uh this object contains useful members such as data size and buffer pointer",
    "start": "1795679",
    "end": "1801360"
  },
  {
    "text": "which we will discuss later another important point is that this",
    "start": "1801360",
    "end": "1806399"
  },
  {
    "text": "object doesn't have a size limit data size is four bytes meaning that it can",
    "start": "1806399",
    "end": "1811760"
  },
  {
    "text": "handle up to 4 GB which is more than enough for most of the HIPS exploit",
    "start": "1811760",
    "end": "1817960"
  },
  {
    "text": "finally because this object is allocated in the paste pool uh it becomes a",
    "start": "1817960",
    "end": "1824000"
  },
  {
    "text": "feasible option for exploiting our vulnerability",
    "start": "1824000",
    "end": "1829240"
  },
  {
    "text": "so the first primitive is out of bound read we can perform an out of bound read",
    "start": "1829559",
    "end": "1835200"
  },
  {
    "text": "by overriding the data size member of the measel data entry object using measo peak prevent freeing",
    "start": "1835200",
    "end": "1843600"
  },
  {
    "text": "the object and avoid potential side effects to perform an arbitrary read",
    "start": "1843600",
    "end": "1851520"
  },
  {
    "text": "overwrite the buffer pointer member of the Melo entry with a target address as",
    "start": "1851520",
    "end": "1857159"
  },
  {
    "text": "before using Melo P avoid premature object free here members before buffer",
    "start": "1857159",
    "end": "1863919"
  },
  {
    "text": "pointer are not important for",
    "start": "1863919",
    "end": "1867519"
  },
  {
    "text": "exploit the mow data entry can also be used to obtain critical object addresses",
    "start": "1869159",
    "end": "1875760"
  },
  {
    "text": "necessary for completing the exploit among them the thread object is a very",
    "start": "1875760",
    "end": "1882240"
  },
  {
    "text": "important object in Windows kernel exploit and the address of the current",
    "start": "1882240",
    "end": "1887679"
  },
  {
    "text": "thread can be obtained through this primitive to create this primitive we",
    "start": "1887679",
    "end": "1894080"
  },
  {
    "text": "need the arbitrary read primitive mentioned earlier since Merlo data entry is a linked list",
    "start": "1894080",
    "end": "1901360"
  },
  {
    "text": "structure where entries are linked to the Merlo context object reading the",
    "start": "1901360",
    "end": "1907440"
  },
  {
    "text": "data entry list member allows you to obtain the address of the MEO",
    "start": "1907440",
    "end": "1913000"
  },
  {
    "text": "context the Meloor context object stores the address of the process object of the",
    "start": "1913000",
    "end": "1919279"
  },
  {
    "text": "thread that created the Mellet this enables us to obtain both the",
    "start": "1919279",
    "end": "1925279"
  },
  {
    "text": "process and the thread object addresses which can then be used for token swapping or",
    "start": "1925279",
    "end": "1932960"
  },
  {
    "text": "something next let's discuss arbitrary nullification arbitrary nullification",
    "start": "1934039",
    "end": "1940960"
  },
  {
    "text": "allows us to set an arbitrary address to zero which was a powerful primitive in",
    "start": "1940960",
    "end": "1947200"
  },
  {
    "text": "Windows kernel exploit at the time of ponttoon",
    "start": "1947200",
    "end": "1952240"
  },
  {
    "text": "this can be used to create an ARW primitive by setting the previous mode",
    "start": "1952240",
    "end": "1958000"
  },
  {
    "text": "of the thread object to zero when a read is performed on a M",
    "start": "1958000",
    "end": "1964080"
  },
  {
    "text": "slot the corresponding data entry is freed and the MS remove data Q entry",
    "start": "1964080",
    "end": "1970159"
  },
  {
    "text": "function is called if the value of the member is non zero",
    "start": "1970159",
    "end": "1975840"
  },
  {
    "text": "the function assumes that it is waiting for a timer and calls the ms cancel",
    "start": "1975840",
    "end": "1981039"
  },
  {
    "text": "timer function which set the value in the worker context object to",
    "start": "1981039",
    "end": "1987159"
  },
  {
    "text": "zero this enables us to make the value at any address zero meaning arbitrary",
    "start": "1987159",
    "end": "1993360"
  },
  {
    "text": "nullification is possible if we manipulate the worker context members of",
    "start": "1993360",
    "end": "1999200"
  },
  {
    "text": "the merlo context entry object",
    "start": "1999200",
    "end": "2003518"
  },
  {
    "text": "this diagram shows how an arbitrary write is achieved through the meso load",
    "start": "2005039",
    "end": "2010159"
  },
  {
    "text": "object first we create a measel data entry with the initial right then we",
    "start": "2010159",
    "end": "2017760"
  },
  {
    "text": "leak the mason context address by following data entry list to access and",
    "start": "2017760",
    "end": "2023120"
  },
  {
    "text": "manipulate internal members like Q status by nullifying Q status in baso",
    "start": "2023120",
    "end": "2029679"
  },
  {
    "text": "context and triggering a type confusion we bypass certain checks next we",
    "start": "2029679",
    "end": "2036399"
  },
  {
    "text": "override the buffer pointer with an arbitrary address finally with the",
    "start": "2036399",
    "end": "2041840"
  },
  {
    "text": "second right we trigger the arbitrary right copying our data to the control memory address using mem",
    "start": "2041840",
    "end": "2050398"
  },
  {
    "text": "copy let's see uh how we use this object for our",
    "start": "2051399",
    "end": "2057320"
  },
  {
    "text": "exploitation first we perform a hip spray to align hex thousand bite chunks",
    "start": "2057320",
    "end": "2062800"
  },
  {
    "text": "in memory you might think that it is difficult to arrange three different objects in this",
    "start": "2062800",
    "end": "2068960"
  },
  {
    "text": "order but with large chunks there is a high probability they will be allocated",
    "start": "2068960",
    "end": "2074800"
  },
  {
    "text": "adjacent to each other after a certain number of sprays those segment boundaries could",
    "start": "2074800",
    "end": "2082158"
  },
  {
    "text": "disrupt the layout the anti-query techniques help maintain the necessary arrangement",
    "start": "2082159",
    "end": "2088919"
  },
  {
    "text": "additionally since this chunk size isn't frequently used by the kernel it didn't",
    "start": "2088919",
    "end": "2094720"
  },
  {
    "text": "generate noise in our testing then we trigger the",
    "start": "2094720",
    "end": "2101119"
  },
  {
    "text": "vulnerability to modify the WNF state data object then use WNF autobound read",
    "start": "2101119",
    "end": "2107760"
  },
  {
    "text": "to inspect the method object and confirm the hip layout",
    "start": "2107760",
    "end": "2112800"
  },
  {
    "text": "it is important to note that the large chunk for example uh larger than a page",
    "start": "2112800",
    "end": "2118160"
  },
  {
    "text": "size was easily reclaimable enabling repeated",
    "start": "2118160",
    "end": "2124160"
  },
  {
    "text": "corruption after that we re-triggered the vulnerability to create the",
    "start": "2124760",
    "end": "2130160"
  },
  {
    "text": "arbitrary nullification primitive mentioned earlier although we previously discussed",
    "start": "2130160",
    "end": "2135920"
  },
  {
    "text": "that the arbitrary right primitive we didn't need it for this exploit however",
    "start": "2135920",
    "end": "2142160"
  },
  {
    "text": "for the current version of the Windows kernel it may become necessary as the",
    "start": "2142160",
    "end": "2147520"
  },
  {
    "text": "use of previous mode might no longer be possible in our scenario uh because the",
    "start": "2147520",
    "end": "2153839"
  },
  {
    "text": "vulnerable chunk object can be freed and reclaimed multiple times uh all of the",
    "start": "2153839",
    "end": "2159440"
  },
  {
    "text": "previously mentioned primitives can be used including obtaining critical object",
    "start": "2159440",
    "end": "2164640"
  },
  {
    "text": "addresses through arbitary read we'll leverage it this to create",
    "start": "2164640",
    "end": "2170240"
  },
  {
    "text": "the ARW primitive by overriding previous mode of the current thread",
    "start": "2170240",
    "end": "2177119"
  },
  {
    "text": "object the final steps are quite straightforward first we follow the process link present in the current",
    "start": "2177240",
    "end": "2184160"
  },
  {
    "text": "thread process object to retrieve the address of the init process object",
    "start": "2184160",
    "end": "2189960"
  },
  {
    "text": "next we read the token object of the initi process and overwrite the token",
    "start": "2189960",
    "end": "2195040"
  },
  {
    "text": "member of the current process thereby performing privilege",
    "start": "2195040",
    "end": "2200240"
  },
  {
    "text": "escalation now uh let's talk about how we chain the three exploits discussed so",
    "start": "2200599",
    "end": "2206839"
  },
  {
    "text": "far even after gaining control of VMware chaining those wasn't that trivial as",
    "start": "2206839",
    "end": "2213400"
  },
  {
    "text": "expected we would like to share the strategy we used to overcome this challenge",
    "start": "2213400",
    "end": "2220240"
  },
  {
    "text": "to summarize the entire process of chaining we first execute shell code in",
    "start": "2220240",
    "end": "2225640"
  },
  {
    "text": "VMware this allows us to drop and run the Windows kernel exploit on the host",
    "start": "2225640",
    "end": "2230760"
  },
  {
    "text": "PC however dropping such a large file present a significant",
    "start": "2230760",
    "end": "2237400"
  },
  {
    "text": "hurdle our goal is to drop a big binary to the host and execute it so we decided",
    "start": "2237400",
    "end": "2244720"
  },
  {
    "text": "to leverage conventional memory conventional memory is located at the",
    "start": "2244720",
    "end": "2249760"
  },
  {
    "text": "bottom of the physical memory and has enough unused pages to store the LP",
    "start": "2249760",
    "end": "2255800"
  },
  {
    "text": "exploit as seen in the diagram if all byes in a page are zero the memory is",
    "start": "2255800",
    "end": "2262079"
  },
  {
    "text": "considered unused by identifying these empty pages",
    "start": "2262079",
    "end": "2267119"
  },
  {
    "text": "we can store the exploit earlier we successfully achieved",
    "start": "2267119",
    "end": "2272960"
  },
  {
    "text": "shell code execution by bypassing cfg in VMware building on that we first opened",
    "start": "2272960",
    "end": "2279200"
  },
  {
    "text": "the file to store the windows kernel exploit we then sequentially saved the",
    "start": "2279200",
    "end": "2284320"
  },
  {
    "text": "blocks located in conventional memory to this file finally by using win xc we",
    "start": "2284320",
    "end": "2290160"
  },
  {
    "text": "executed the saved exploit file effectively chaining the exploits",
    "start": "2290160",
    "end": "2296040"
  },
  {
    "text": "together now our presentation is finished uh let's see together our poto",
    "start": "2296040",
    "end": "2301920"
  },
  {
    "text": "on exploit",
    "start": "2301920",
    "end": "2304640"
  },
  {
    "text": "demo you can see that our exploit is fail safe so we are triggering the",
    "start": "2308760",
    "end": "2314000"
  },
  {
    "text": "vulnerability multiple",
    "start": "2314000",
    "end": "2317119"
  },
  {
    "text": "times and you can see the elevated system shell on host",
    "start": "2320599",
    "end": "2326640"
  },
  {
    "text": "PC okay so retention finished due to time constraint I will skip over the",
    "start": "2327000",
    "end": "2333839"
  },
  {
    "text": "conclusion part uh which was prepared for formality okay uh any questions",
    "start": "2333839",
    "end": "2342200"
  },
  {
    "text": "uh sorry uh yeah yeah",
    "start": "2355839",
    "end": "2363559"
  },
  {
    "text": "uh K you mean KP uh actually we bypassed KPPP with known tools so that wasn't uh",
    "start": "2364079",
    "end": "2373280"
  },
  {
    "text": "the serious problem",
    "start": "2373280",
    "end": "2376480"
  },
  {
    "text": "yeah okay uh if you have question you can email us later okay thank you",
    "start": "2381640",
    "end": "2387530"
  },
  {
    "text": "[Applause]",
    "start": "2387530",
    "end": "2394499"
  }
]