[
  {
    "text": "[Music] foreign",
    "start": "1730",
    "end": "6720"
  },
  {
    "text": "and welcome to browser power desync attacks have you ever had an idea and then just",
    "start": "8599",
    "end": "15960"
  },
  {
    "text": "dismissed it because there's no way that that would ever work",
    "start": "15960",
    "end": "21359"
  },
  {
    "text": "three years ago I thought wouldn't it be cool if you could make browsers launch desync attacks that would enable some",
    "start": "21359",
    "end": "27960"
  },
  {
    "text": "really interesting possibilities but I figured that there was no way that",
    "start": "27960",
    "end": "34620"
  },
  {
    "text": "any web server was doing something foolish enough to make that possible",
    "start": "34620",
    "end": "39780"
  },
  {
    "text": "this year I discovered I was completely wrong you can achieve all manner of",
    "start": "39780",
    "end": "45059"
  },
  {
    "text": "interesting things and in this session I'll show you how like many discoveries the journey that",
    "start": "45059",
    "end": "52500"
  },
  {
    "text": "led to it was quite windy it started in late 2019 when there was a Spate of",
    "start": "52500",
    "end": "58199"
  },
  {
    "text": "requests smuggling false positives even leading to an incorrect cve for nginx",
    "start": "58199",
    "end": "64500"
  },
  {
    "text": "I had a look at what the root cause of this was and declared that there was a",
    "start": "64500",
    "end": "69780"
  },
  {
    "text": "simple solution and to do was never reuse HTTP one connections when looking for request",
    "start": "69780",
    "end": "76680"
  },
  {
    "text": "smuggling and after that well everything was wonderful until last year when I",
    "start": "76680",
    "end": "83040"
  },
  {
    "text": "realized that connection locked request smuggling was a thing and the only way to find this was to always reuse HTTP",
    "start": "83040",
    "end": "90420"
  },
  {
    "text": "one connections so at this point we had a bit of a mess",
    "start": "90420",
    "end": "96659"
  },
  {
    "text": "this year I set out to tackle this and after quite a lot of effort I eventually",
    "start": "96659",
    "end": "102420"
  },
  {
    "text": "found that by slowing things down and paying really close attention to the",
    "start": "102420",
    "end": "108479"
  },
  {
    "text": "exact sequence of events I could reuse connections and still distinguish genuine vulnerabilities from false",
    "start": "108479",
    "end": "114840"
  },
  {
    "text": "positives and that was nice but sometimes when you pay extra close",
    "start": "114840",
    "end": "120960"
  },
  {
    "text": "attention to things you find more than you bargained for on one website I noticed that something",
    "start": "120960",
    "end": "127740"
  },
  {
    "text": "wasn't quite right and I pulled on that thread and what I found broke my mental",
    "start": "127740",
    "end": "133020"
  },
  {
    "text": "model for request smuggling because the resulting attack didn't require an",
    "start": "133020",
    "end": "138840"
  },
  {
    "text": "attacker and that meant it didn't even require a front-end server and that",
    "start": "138840",
    "end": "144660"
  },
  {
    "text": "opens a whole new frontier of attack surface so today I'm here to share with you a",
    "start": "144660",
    "end": "151319"
  },
  {
    "text": "methodology and toolkit that I've built to navigate this new world demonstrated with exploits on Apache Akamai varnish",
    "start": "151319",
    "end": "158520"
  },
  {
    "text": "amazon.com and multiple web vpns first we're going to get warmed up with",
    "start": "158520",
    "end": "164819"
  },
  {
    "text": "HP handling anomalies after that I'll share the client-side desync methodology using four in-depth",
    "start": "164819",
    "end": "172260"
  },
  {
    "text": "case studies then I'll introduce pause based desync including a live demo because the attack is so cool and",
    "start": "172260",
    "end": "178800"
  },
  {
    "text": "unreliable I couldn't resist and uh after that I'll chat about defense key takeaways and wrap up with",
    "start": "178800",
    "end": "185220"
  },
  {
    "text": "five minutes of questions there's a lot of techniques in this",
    "start": "185220",
    "end": "190860"
  },
  {
    "text": "presentation and I really want them to work for you so as part of that whenever",
    "start": "190860",
    "end": "196319"
  },
  {
    "text": "you see this squiggly logo on a slide that means that my team has built an online replica",
    "start": "196319",
    "end": "202260"
  },
  {
    "text": "of this vulnerability so you can practice that technique on a real system online for free",
    "start": "202260",
    "end": "207780"
  },
  {
    "text": "I'm also releasing the code that powered every finding in this presentation and whenever there's a named Target you'll",
    "start": "207780",
    "end": "214379"
  },
  {
    "text": "find full proof of exploit code on the white paper even if I haven't managed to squeeze it onto a slide",
    "start": "214379",
    "end": "221700"
  },
  {
    "text": "we're going to start with a series of six esoteric vulnerabilities that directly led to the discovery of",
    "start": "221700",
    "end": "227940"
  },
  {
    "text": "client-side desync attacks and also really quite valuable in their own right",
    "start": "227940",
    "end": "233220"
  },
  {
    "text": "but first there's something I need to tell you the request is a lie HTTP requests are a",
    "start": "233220",
    "end": "242700"
  },
  {
    "text": "really useful abstraction but in HTTP 1 this abstraction is incredibly weak and",
    "start": "242700",
    "end": "248700"
  },
  {
    "text": "the harder you try to cling on to this concept of a request the less sense the",
    "start": "248700",
    "end": "254459"
  },
  {
    "text": "techniques are going to make so at all times just bear in mind that all we're",
    "start": "254459",
    "end": "259680"
  },
  {
    "text": "really doing is sending a stream of bytes to the server and what the server",
    "start": "259680",
    "end": "264840"
  },
  {
    "text": "does with that is up to it for example if you believe in requests",
    "start": "264840",
    "end": "271320"
  },
  {
    "text": "it's all too easy to forget about HTTP connection we use most of the time because HTTP is supposed to be stateless",
    "start": "271320",
    "end": "280199"
  },
  {
    "text": "but sometimes State just finds a way to creep in take this website that I found",
    "start": "280199",
    "end": "285479"
  },
  {
    "text": "they had a reverse proxy which was set up to allow me to access sites intended",
    "start": "285479",
    "end": "291060"
  },
  {
    "text": "to be public and not to let me access private sites on their internal Network",
    "start": "291060",
    "end": "297419"
  },
  {
    "text": "but it was only validating the host header of the first request on each",
    "start": "297419",
    "end": "302699"
  },
  {
    "text": "connection so by sending a legitimate request followed by my request to access an internal system I got access to that",
    "start": "302699",
    "end": "309600"
  },
  {
    "text": "internal system now fortunately this particular bug class is quite rare but there is a more",
    "start": "309600",
    "end": "316740"
  },
  {
    "text": "common variation which I'll call First request routing",
    "start": "316740",
    "end": "322080"
  },
  {
    "text": "this is when the front end looks at the first request to work out where to Route",
    "start": "322080",
    "end": "327240"
  },
  {
    "text": "it and then just pass us all subsequent requests on the same connection straight through to the same back end",
    "start": "327240",
    "end": "334740"
  },
  {
    "text": "this Behavior by itself is not really a vulnerability but you can use it to hit any back end with an arbitrary host",
    "start": "334740",
    "end": "341460"
  },
  {
    "text": "header so it can form part of an exploit chain in this example here I want to hit the back end with a poisoned password",
    "start": "341460",
    "end": "348360"
  },
  {
    "text": "reset header to generate a poisoned email but if I try and do that directly it",
    "start": "348360",
    "end": "354900"
  },
  {
    "text": "doesn't work because the front end won't route it to the right back end but once again just by prefixing my attack with a",
    "start": "354900",
    "end": "361500"
  },
  {
    "text": "genuine request with a correct host header I can hit that back end generate a poisoned password reset email and",
    "start": "361500",
    "end": "368699"
  },
  {
    "text": "hopefully hijack someone's account so hopefully that technique will come in",
    "start": "368699",
    "end": "374580"
  },
  {
    "text": "useful for you but there's also a broader takeaway which is that sometimes it's good to peel away these",
    "start": "374580",
    "end": "381000"
  },
  {
    "text": "abstractions because they can hide Behavior that's really quite important",
    "start": "381000",
    "end": "387020"
  },
  {
    "text": "now you know the deal with request smuggling right you make the front end and the back end disagree about the",
    "start": "388319",
    "end": "394139"
  },
  {
    "text": "length of the message you use that to apply a malicious prefix shown in Orange to the victim's request",
    "start": "394139",
    "end": "400740"
  },
  {
    "text": "that makes bad things happen to the victim and to make that length disagreement",
    "start": "400740",
    "end": "406259"
  },
  {
    "text": "happen you usually obfuscate the transfer and coding header to hide it from one of the two servers",
    "start": "406259",
    "end": "412800"
  },
  {
    "text": "and so I was a bit puzzled when I found you could trigger really suspicious",
    "start": "412800",
    "end": "418500"
  },
  {
    "text": "behavior on quite a few websites using aws's application load balancer using",
    "start": "418500",
    "end": "424860"
  },
  {
    "text": "this HTTP 2 request if you look at this request you might",
    "start": "424860",
    "end": "430560"
  },
  {
    "text": "wonder where the attack is because it's a legitimate request it's",
    "start": "430560",
    "end": "435960"
  },
  {
    "text": "specification compliant and there's no obfuscation in it there's really nothing",
    "start": "435960",
    "end": "441000"
  },
  {
    "text": "sketchy going on here and yet this was triggering some really shady behavior and after doing a bunch of Investigation",
    "start": "441000",
    "end": "449940"
  },
  {
    "text": "I discovered that what Amazon was doing is they were downgrading this request to http one and when they did so",
    "start": "449940",
    "end": "456240"
  },
  {
    "text": "for some reason they were adding a header that said this message was chunked",
    "start": "456240",
    "end": "461280"
  },
  {
    "text": "now I've genuinely not sure why they were doing that but my best guess is",
    "start": "461280",
    "end": "467039"
  },
  {
    "text": "that it's because browsers always send a Content length header even when they're using HTTP 2. even though it's kind of",
    "start": "467039",
    "end": "473580"
  },
  {
    "text": "pointless when you're using H2 so Amazon ended up with some logic that",
    "start": "473580",
    "end": "478919"
  },
  {
    "text": "said well if the request doesn't have a Content length header I guess it must be chunked",
    "start": "478919",
    "end": "484020"
  },
  {
    "text": "so using that just by changing the payload I sent slightly I could trigger an exploitable desync or a whole bunch",
    "start": "484020",
    "end": "490259"
  },
  {
    "text": "of websites I reported to Amazon they fixed it pretty fast",
    "start": "490259",
    "end": "495360"
  },
  {
    "text": "but the main thing was this taught me something really important which is",
    "start": "495360",
    "end": "501900"
  },
  {
    "text": "full request smuggling you don't always need header obfuscation or ambiguity",
    "start": "501900",
    "end": "508979"
  },
  {
    "text": "all you need is a server taken by surprise we'll come back to that later",
    "start": "508979",
    "end": "516659"
  },
  {
    "text": "now let's take a closer look at the connection locked HP one request smuggling issue mentioned earlier",
    "start": "516659",
    "end": "523560"
  },
  {
    "text": "to confirm regular request smuggling all you need to do is send two requests and confirm that the body of the first",
    "start": "523560",
    "end": "530100"
  },
  {
    "text": "request affects the response to the second as shown here and this works great",
    "start": "530100",
    "end": "536040"
  },
  {
    "text": "provided you send those two requests over separate connections if you send",
    "start": "536040",
    "end": "541380"
  },
  {
    "text": "them over the same connection you've got a problem so here we're sending and receiving exactly the same",
    "start": "541380",
    "end": "547200"
  },
  {
    "text": "bytes but we can no longer tell where the front end thinks the message ends and therefore we can't tell if this",
    "start": "547200",
    "end": "554399"
  },
  {
    "text": "system is really vulnerable the solution to this is to realize that",
    "start": "554399",
    "end": "559980"
  },
  {
    "text": "the bites that you get aren't the only information that you have available you also have timing information",
    "start": "559980",
    "end": "567000"
  },
  {
    "text": "if the front end thinks that this initial message is chunked that means it's actually starting to generate a response before",
    "start": "567000",
    "end": "573959"
  },
  {
    "text": "we send the orange payload so before setting the orange data you",
    "start": "573959",
    "end": "579180"
  },
  {
    "text": "can pause and do a read on the socket and see if you've got a request back from the server and if you do that tells",
    "start": "579180",
    "end": "586019"
  },
  {
    "text": "you that the front end is treating this message is chunked it's not using the content length and therefore you can bail on the attack because it will just",
    "start": "586019",
    "end": "592740"
  },
  {
    "text": "be a false positive anyway meanwhile if your read attempt hangs for several seconds that shows that the",
    "start": "592740",
    "end": "599100"
  },
  {
    "text": "server thinks the message hasn't finished yet and therefore it must be using the content length and as long as",
    "start": "599100",
    "end": "604740"
  },
  {
    "text": "the rest of the attack pans out must be vulnerable so I automated this technique it does",
    "start": "604740",
    "end": "611279"
  },
  {
    "text": "work I went scanning with it and found a bunch of systems uh including one that was slightly funny because they were",
    "start": "611279",
    "end": "618000"
  },
  {
    "text": "using barracuda's web application firewall in front of IIs and they were vulnerable because of the",
    "start": "618000",
    "end": "625080"
  },
  {
    "text": "web application firewall and what's more Barracuda had actually already issued a",
    "start": "625080",
    "end": "630180"
  },
  {
    "text": "patch for this vulnerability but they hadn't flagged it as a security fix they just said it was a bit of a hardening",
    "start": "630180",
    "end": "637260"
  },
  {
    "text": "measure and as such the client hadn't bothered to install it as usual though the best desync that",
    "start": "637260",
    "end": "644940"
  },
  {
    "text": "that technique found is the one that initially made the least sense after extensive testing in refinement it looks",
    "start": "644940",
    "end": "651959"
  },
  {
    "text": "like this now there's two things to unpack here",
    "start": "651959",
    "end": "657959"
  },
  {
    "text": "first off as you can see the back end server is completely ignoring the content length of this message so that",
    "start": "657959",
    "end": "664620"
  },
  {
    "text": "means this is something you could call a c0.0 desync which is a rarer attack",
    "start": "664620",
    "end": "670200"
  },
  {
    "text": "class that's not detected by any public black box tools currently",
    "start": "670200",
    "end": "676320"
  },
  {
    "text": "secondly well why is the backend server ignoring the content length",
    "start": "676320",
    "end": "681360"
  },
  {
    "text": "there's no reason right they're just ignoring it because they feel like it",
    "start": "681360",
    "end": "686820"
  },
  {
    "text": "and it never occurred to me that that might happen and that has serious consequences",
    "start": "686820",
    "end": "692880"
  },
  {
    "text": "finally this left me wondering given that I found this vulnerability here by accident well how many more sites will I",
    "start": "692880",
    "end": "699120"
  },
  {
    "text": "find if I go deliberately looking for this issue I'm pleased to say the answer is quite a",
    "start": "699120",
    "end": "704579"
  },
  {
    "text": "few for example on amazon.com they ignore the content length if you do a",
    "start": "704579",
    "end": "710160"
  },
  {
    "text": "post request to the path slash B using that I was able to trigger a",
    "start": "710160",
    "end": "715920"
  },
  {
    "text": "proper server side desync and I made a proof of concept which stored random",
    "start": "715920",
    "end": "721079"
  },
  {
    "text": "users requests inside my Amazon wishlist so I send the attack a few times load up",
    "start": "721079",
    "end": "727500"
  },
  {
    "text": "my Amazon wishlist grab some random person's credentials from their request and I can access their account",
    "start": "727500",
    "end": "734820"
  },
  {
    "text": "so I reported this to Amazon they fixed it at some point and then I realized I",
    "start": "734820",
    "end": "740279"
  },
  {
    "text": "made a terrible mistake I'd missed out on a much cooler attack",
    "start": "740279",
    "end": "747440"
  },
  {
    "text": "this attack here exploits a random live user right and there's no obfuscation in",
    "start": "747440",
    "end": "754079"
  },
  {
    "text": "this attack request so that means that request can be sent by a browser",
    "start": "754079",
    "end": "759120"
  },
  {
    "text": "so if instead of doing the wish listing I'd use the head technique to execute",
    "start": "759120",
    "end": "764160"
  },
  {
    "text": "JavaScript in the victim's browser I could have made every user that got",
    "start": "764160",
    "end": "769320"
  },
  {
    "text": "hit by this spread the attack to 10 other users effectively making a self-spreading desynchronization worm",
    "start": "769320",
    "end": "775560"
  },
  {
    "text": "and compromising every active Amazon user with virtually no effort on my part",
    "start": "775560",
    "end": "782579"
  },
  {
    "text": "so that was a cool finding a missed opportunity and also a hint at an entire",
    "start": "782579",
    "end": "790200"
  },
  {
    "text": "new attack class which we'll call client-side decent",
    "start": "790200",
    "end": "797040"
  },
  {
    "text": "every decent attack we've seen so far including the Amazon one has desynchronized the connection between",
    "start": "797040",
    "end": "802860"
  },
  {
    "text": "the front-end server and the back end server but if you can make a web browser cause",
    "start": "802860",
    "end": "808980"
  },
  {
    "text": "a desync you can Target the browser's own connection pool and therefore exploit sites that don't actually have a",
    "start": "808980",
    "end": "815160"
  },
  {
    "text": "front-end backend architecture this attack flow starts with the victim",
    "start": "815160",
    "end": "820500"
  },
  {
    "text": "visiting the attacker site which triggers two requests to the Target the first one desynchronizes the",
    "start": "820500",
    "end": "826740"
  },
  {
    "text": "browser's connection so that the second request triggers a harmful response to go back from the Target website to the",
    "start": "826740",
    "end": "833579"
  },
  {
    "text": "victim generally given the attacker control over the victim's account",
    "start": "833579",
    "end": "839459"
  },
  {
    "text": "to build these attacks I've adapted the methodology from classic request smuggling the key difference with",
    "start": "839459",
    "end": "846420"
  },
  {
    "text": "client-side desync is the the our entire exploit needs to run inside our Victims",
    "start": "846420",
    "end": "852779"
  },
  {
    "text": "web browser and that is an environment that's a lot more complex and uncontrolled than a dedicated hacking",
    "start": "852779",
    "end": "860040"
  },
  {
    "text": "tool and so as such it's crucial to periodically check that the proof of concept that's working in your tool also",
    "start": "860040",
    "end": "866160"
  },
  {
    "text": "works as expected in the Target browser tooling wise I did this with custom code",
    "start": "866160",
    "end": "872519"
  },
  {
    "text": "which I'm releasing to GitHub straight after this presentation uh I also designed a new burp Suite",
    "start": "872519",
    "end": "878880"
  },
  {
    "text": "feature called send request sequence which offers similar functionality but with a slightly gentler learning curve",
    "start": "878880",
    "end": "884699"
  },
  {
    "text": "uh for the Target web browser you can this technique works on all browsers I've tested personally I focused on",
    "start": "884699",
    "end": "892199"
  },
  {
    "text": "Chrome because it has the best developer tools for building this kind of exploit",
    "start": "892199",
    "end": "898380"
  },
  {
    "text": "the first step towards an attack is just to identify your client-side desync vector",
    "start": "898380",
    "end": "904320"
  },
  {
    "text": "this is a HTTP one request with three Key Properties first and foremost the server must",
    "start": "904320",
    "end": "911339"
  },
  {
    "text": "ignore the content length and this usually happens because your request either either triggers some kind of",
    "start": "911339",
    "end": "917279"
  },
  {
    "text": "server error or the server just wasn't expecting a post request to that endpoint so in this example here I'm",
    "start": "917279",
    "end": "923760"
  },
  {
    "text": "just doing a post request to a static file which they might not expect and as you",
    "start": "923760",
    "end": "930180"
  },
  {
    "text": "can see I've sent a contact length that's higher than the data that I'm actually sending so if a server responds",
    "start": "930180",
    "end": "935880"
  },
  {
    "text": "to this request immediately that's an indication that it may be vulnerable to a client site desync",
    "start": "935880",
    "end": "943560"
  },
  {
    "text": "now the other key request the other key requirement is that this request can be triggered in a web browser cross domain",
    "start": "943560",
    "end": "951240"
  },
  {
    "text": "so that means that you must use the post method and you can't have any unusual headers or header obfuscation or stuff",
    "start": "951240",
    "end": "958620"
  },
  {
    "text": "like that and also the target server can't advertise support for HTTP 2 because this attack exploits HTTP 1",
    "start": "958620",
    "end": "966000"
  },
  {
    "text": "connection of a use and browsers will aggressively prefer to use HTTP 2 if the server supports it",
    "start": "966000",
    "end": "973500"
  },
  {
    "text": "finally I after your client-side decent Vector request the server has to leave",
    "start": "973500",
    "end": "978600"
  },
  {
    "text": "the connection open because there's no point in desyncing a connection that is immediately closed",
    "start": "978600",
    "end": "985500"
  },
  {
    "text": "once you've found your client's idsync Vector the next step is to confirm it works inside a real browser",
    "start": "985500",
    "end": "992040"
  },
  {
    "text": "you can do that using some JavaScript that looks something like this as you can see here we're sending two requests",
    "start": "992040",
    "end": "999360"
  },
  {
    "text": "the first one is going to desync the connection and the second is going to suffer the consequences",
    "start": "999360",
    "end": "1005300"
  },
  {
    "text": "in the initial request I've got a couple of special Flags worth mentioning uh",
    "start": "1005300",
    "end": "1010339"
  },
  {
    "text": "first off I'm specifying mode no chords this is not actually required for a",
    "start": "1010339",
    "end": "1015740"
  },
  {
    "text": "successful attack but what it does is improves the visibility we have into what's happening inside the dev tools",
    "start": "1015740",
    "end": "1022579"
  },
  {
    "text": "which is very useful when it doesn't work as expected secondly specifying credentials no",
    "start": "1022579",
    "end": "1029740"
  },
  {
    "text": "credentials include is essential web browsers have multiple connection",
    "start": "1029740",
    "end": "1035240"
  },
  {
    "text": "pools per website and if you poison the wrong connection pool I can promise you",
    "start": "1035240",
    "end": "1041000"
  },
  {
    "text": "an extremely frustrating time now when you run this if it's successful you'll see two two requests Landing in",
    "start": "1041000",
    "end": "1048679"
  },
  {
    "text": "the dev tools with the same connection ID and you should see that the second response has been affected by the",
    "start": "1048679",
    "end": "1054380"
  },
  {
    "text": "malicious prefix in the first request as shown here",
    "start": "1054380",
    "end": "1059980"
  },
  {
    "text": "if that works well congratulations you found your first client-side vsync now it's just time to build an exploit",
    "start": "1061160",
    "end": "1068419"
  },
  {
    "text": "you've got three main options here first off you could try and store the user request somewhere where you can access",
    "start": "1068419",
    "end": "1075620"
  },
  {
    "text": "it much like what I did on Amazon uh that works the same as server side desync so I'm not going to waste time",
    "start": "1075620",
    "end": "1081679"
  },
  {
    "text": "talking about it now uh secondly there's an all-new option which is chaining and",
    "start": "1081679",
    "end": "1087200"
  },
  {
    "text": "pivoting a client-side desync lets you make your Victims web browser send arbitrary",
    "start": "1087200",
    "end": "1093620"
  },
  {
    "text": "requests arbitrary strings of bytes to the Target website so that turns their browser into your",
    "start": "1093620",
    "end": "1101419"
  },
  {
    "text": "personal attack platform and it puts extra attack surface within your Reach For example you can make them put log",
    "start": "1101419",
    "end": "1107539"
  },
  {
    "text": "for Shell payloads wherever you like and send those to internal systems that you can't directly access and you can even",
    "start": "1107539",
    "end": "1113900"
  },
  {
    "text": "hit authenticated attack service using their using their credentials in a",
    "start": "1113900",
    "end": "1119179"
  },
  {
    "text": "approach that's a bit like cross-site request forgery but more powerful because you don't have the same browser",
    "start": "1119179",
    "end": "1124880"
  },
  {
    "text": "implemented restrictions on what requests you can send I'm going to focus on directly",
    "start": "1124880",
    "end": "1131660"
  },
  {
    "text": "exploiting the end user now I've tried quite a few different techniques for this and had the most success with two",
    "start": "1131660",
    "end": "1138679"
  },
  {
    "text": "well-known gadgets from server-side request smuggling with certain tweaks",
    "start": "1138679",
    "end": "1143720"
  },
  {
    "text": "applied to overcome some of the challenges that we're going to encounter so",
    "start": "1143720",
    "end": "1149360"
  },
  {
    "text": "that's the methodology let's try applying it with some case studies",
    "start": "1149360",
    "end": "1155600"
  },
  {
    "text": "first off we're going to exploit a straightforward vulnerability that affected a huge number of websites using",
    "start": "1155600",
    "end": "1162440"
  },
  {
    "text": "the accumbai CDN here the desync Vector is nice and simple you just do a post request that",
    "start": "1162440",
    "end": "1169640"
  },
  {
    "text": "triggers a redirect from the front end and now ignore the content length causing a client-side desicc",
    "start": "1169640",
    "end": "1176960"
  },
  {
    "text": "confirming this in a browser is also nice and simple so here I've crafted the",
    "start": "1176960",
    "end": "1182240"
  },
  {
    "text": "malicious prefix in Orange so that when the browser follows the server redirects it's just going to end up getting the",
    "start": "1182240",
    "end": "1189260"
  },
  {
    "text": "contents of the robot's txt file now for our exploit I'm going to use the",
    "start": "1189260",
    "end": "1196340"
  },
  {
    "text": "head technique if you're not familiar with this technique it's documented in",
    "start": "1196340",
    "end": "1201620"
  },
  {
    "text": "more detail in last year's presentation on HTTP 2 but the gist is we use the",
    "start": "1201620",
    "end": "1206960"
  },
  {
    "text": "head method to queue up multiple responses that when combined are harmful in their browser",
    "start": "1206960",
    "end": "1213200"
  },
  {
    "text": "and it's that simple if you're doing a server-side desync",
    "start": "1213200",
    "end": "1218299"
  },
  {
    "text": "but because this is client site there's a couple of extra things that we need to fix first",
    "start": "1218299",
    "end": "1224780"
  },
  {
    "text": "first problem is that the initial response coming back to the browser is a redirect and so the browser will",
    "start": "1224780",
    "end": "1230600"
  },
  {
    "text": "immediately follow that and that's the request that will get hit by the poison socket and that will break our attack",
    "start": "1230600",
    "end": "1237740"
  },
  {
    "text": "second issue is something I'll call the Stacked response problem whenever Chrome reads in a response from",
    "start": "1237740",
    "end": "1244880"
  },
  {
    "text": "the server it deliberately does a little overread on the TCP socket to see if the server",
    "start": "1244880",
    "end": "1251179"
  },
  {
    "text": "has sent more data than expected and if Chrome sees any additional the",
    "start": "1251179",
    "end": "1257020"
  },
  {
    "text": "data it quietly drops the connection and breaks our attack",
    "start": "1257020",
    "end": "1263360"
  },
  {
    "text": "fortunately we can fix both of these issues fairly easily on this target so you can fix the Stacked response problem",
    "start": "1263360",
    "end": "1269480"
  },
  {
    "text": "by adding a cash Buster to the request which means it causes a cash Miss on the",
    "start": "1269480",
    "end": "1274760"
  },
  {
    "text": "front end goes all the way to the back end and that incurs such a big time delay that by the time it gets back",
    "start": "1274760",
    "end": "1281539"
  },
  {
    "text": "Chrome has already done the overread and therefore hasn't seen it and the exploit works",
    "start": "1281539",
    "end": "1287840"
  },
  {
    "text": "and secondly we can easily stop the browser from following the redirect by changing mode no cores to mode cores",
    "start": "1287840",
    "end": "1294740"
  },
  {
    "text": "causing an exception when the redirect is seen which we can then catch and continue with our exploit",
    "start": "1294740",
    "end": "1302380"
  },
  {
    "text": "for our next Target we'll hit Cisco's web VPN and here causing a desync is",
    "start": "1302480",
    "end": "1308059"
  },
  {
    "text": "even easier you just do a post request to their home page using this we can easily trigger an",
    "start": "1308059",
    "end": "1315020"
  },
  {
    "text": "unexpected redirect to our website which could in theory let us hijack a",
    "start": "1315020",
    "end": "1320240"
  },
  {
    "text": "JavaScript resource load and take full control of the site the problem is",
    "start": "1320240",
    "end": "1325940"
  },
  {
    "text": "when a browser renders a page it loads all the resources at more or less the same time and that makes it really hard",
    "start": "1325940",
    "end": "1332539"
  },
  {
    "text": "to ensure that we hijack the correct request fortunately there's a solution here",
    "start": "1332539",
    "end": "1338720"
  },
  {
    "text": "because this redirect response coming back to the user is cachable so if we poison the connection with this",
    "start": "1338720",
    "end": "1347000"
  },
  {
    "text": "response and then navigate the browser to this slash win.js Javascript file that we want to poison the browser is",
    "start": "1347000",
    "end": "1354020"
  },
  {
    "text": "going to see this redirect and get bounced back to our site but it will also save that redirect in its cache so",
    "start": "1354020",
    "end": "1361039"
  },
  {
    "text": "when they land back on our website we can send them on to the login page on the VPN which then tries to import that",
    "start": "1361039",
    "end": "1368419"
  },
  {
    "text": "JavaScript resource and ends up loading the poisoned version from the cache and gives us full control of that page and",
    "start": "1368419",
    "end": "1375320"
  },
  {
    "text": "hopefully their passwords so",
    "start": "1375320",
    "end": "1380659"
  },
  {
    "text": "I reported this to Cisco and they didn't reply for a while and then when they did",
    "start": "1380659",
    "end": "1386480"
  },
  {
    "text": "and they said actually they're going to deprecate this product so they're not going to bother fixing this issue but to their credit they are",
    "start": "1386480",
    "end": "1393020"
  },
  {
    "text": "issuing a CV and an advisory for it next up uh we're going to hit the main",
    "start": "1393020",
    "end": "1400340"
  },
  {
    "text": "website of Vemma site so on this website you could trigger a",
    "start": "1400340",
    "end": "1406580"
  },
  {
    "text": "desync using a URL encoded forward slash once again I don't really know why but",
    "start": "1406580",
    "end": "1412940"
  },
  {
    "text": "unfortunately that wasn't the only thing a bit unusual about their setup for reasons that I sadly don't have time to",
    "start": "1412940",
    "end": "1420020"
  },
  {
    "text": "explain to get a working exploit I had to send a head request with an incomplete chunked body and then tune",
    "start": "1420020",
    "end": "1427280"
  },
  {
    "text": "the size of the follow-up request so that it's slotted inside that trailing chunk",
    "start": "1427280",
    "end": "1432380"
  },
  {
    "text": "now the interesting thing here is this approach is exclusive to client-side",
    "start": "1432380",
    "end": "1438799"
  },
  {
    "text": "desync because if you're doing a server side that you think you don't control what the next request will be and",
    "start": "1438799",
    "end": "1444080"
  },
  {
    "text": "therefore you can't accurate accurately predict its size and so attempting this technique will fail",
    "start": "1444080",
    "end": "1450799"
  },
  {
    "text": "so it's worth bearing in mind that although client-side decent can be painful sometimes you do have some extra",
    "start": "1450799",
    "end": "1457100"
  },
  {
    "text": "options available to you speaking of painful",
    "start": "1457100",
    "end": "1462679"
  },
  {
    "text": "for our final case study we're going to Target pulse secure VPN here you can trigger a desync doing a",
    "start": "1462679",
    "end": "1469520"
  },
  {
    "text": "post request to slash robots txt and just like Cisco's VPN they've got",
    "start": "1469520",
    "end": "1474980"
  },
  {
    "text": "host header redirect Gadget that I'd like to use to hijack a JavaScript import",
    "start": "1474980",
    "end": "1480320"
  },
  {
    "text": "but this time the redirect isn't cachable so we can't do cash poisoning and we're",
    "start": "1480320",
    "end": "1486799"
  },
  {
    "text": "in this scenario where our attack timing is crucial and therefore I had to take three key steps to make this attack",
    "start": "1486799",
    "end": "1493820"
  },
  {
    "text": "at least a teeny bit reliable first off I pre-connect the victim's",
    "start": "1493820",
    "end": "1499280"
  },
  {
    "text": "browser with the Target website to reduce the effects of network Jitter on the on the attack timings to be honest",
    "start": "1499280",
    "end": "1506480"
  },
  {
    "text": "this probably doesn't actually make any difference but it does work uh the more",
    "start": "1506480",
    "end": "1512120"
  },
  {
    "text": "importantly it's essential that we can have multiple attempts at our at our attack because it",
    "start": "1512120",
    "end": "1519740"
  },
  {
    "text": "may fail but a failed attack and leaves the user on the Target website so I was able to resolve this by",
    "start": "1519740",
    "end": "1527720"
  },
  {
    "text": "opening an extra Tab and just running that attack inside that tab finally if the attack fails and the",
    "start": "1527720",
    "end": "1534679"
  },
  {
    "text": "browser ends up caching the genuine non-poisoned Javascript file then we'll have to wait for that file to expire",
    "start": "1534679",
    "end": "1541460"
  },
  {
    "text": "from their cache which could take weeks so it's essential that that never happens but I was able to avoid that by finding",
    "start": "1541460",
    "end": "1548419"
  },
  {
    "text": "a page on the pulse secure VPN that add a JavaScript import that never got",
    "start": "1548419",
    "end": "1553580"
  },
  {
    "text": "cached because the file the Javascript file wasn't actually present and just always for a foot",
    "start": "1553580",
    "end": "1560179"
  },
  {
    "text": "so by stitching all of that together I built a proof of concept but we'll just see a quick video of here hopefully so",
    "start": "1560179",
    "end": "1566960"
  },
  {
    "text": "you see the extra tab pops open loads the target page a couple of times and eventually our payload fires and we get",
    "start": "1566960",
    "end": "1573380"
  },
  {
    "text": "a full control of the site I've reported that to pulse secure and they they said they fixed it last week",
    "start": "1573380",
    "end": "1580760"
  },
  {
    "text": "but I couldn't find any advisory for or anything so I'm not 100 sure what's happening there uh but there we go",
    "start": "1580760",
    "end": "1588760"
  },
  {
    "text": "so that was client side desync now we saw earlier that slowing down and",
    "start": "1588860",
    "end": "1594980"
  },
  {
    "text": "pausing can reveal useful information it turns out pausing can also create",
    "start": "1594980",
    "end": "1600799"
  },
  {
    "text": "entire new desync vulnerabilities that are hilariously simple to trigger a pause-based async when",
    "start": "1600799",
    "end": "1607880"
  },
  {
    "text": "speaking directly to a vulnerable server you can start by just sending your headers promising a body and then just",
    "start": "1607880",
    "end": "1614419"
  },
  {
    "text": "waiting and eventually the vulnerable server will hit some kind of timeout and send a response and then you just follow",
    "start": "1614419",
    "end": "1620900"
  },
  {
    "text": "up with the rest of your of your request and the next one and that will be",
    "start": "1620900",
    "end": "1626179"
  },
  {
    "text": "interpreted as a separate second request causing it basic",
    "start": "1626179",
    "end": "1631220"
  },
  {
    "text": "I initially found this Behavior on varnish through an extreme fluke it",
    "start": "1631220",
    "end": "1637340"
  },
  {
    "text": "was multiple different bugs in my code combined that made me find this and once",
    "start": "1637340",
    "end": "1642919"
  },
  {
    "text": "I realized this before this this was a thing I went looking for it I found that it also works on Apache",
    "start": "1642919",
    "end": "1650240"
  },
  {
    "text": "it seems to tend to happen on an end point when the server is generating a response itself instead of forwarding",
    "start": "1650240",
    "end": "1657200"
  },
  {
    "text": "the request to the to the back end or handing it off to the application layer now this single vulnerability enables",
    "start": "1657200",
    "end": "1665539"
  },
  {
    "text": "two completely different attacks first off let's use it to cause an",
    "start": "1665539",
    "end": "1671840"
  },
  {
    "text": "old-school server-side desync for this to work you need a vulnerable server",
    "start": "1671840",
    "end": "1676940"
  },
  {
    "text": "like Apache as a back end and a front-end server that streams the request specifically it",
    "start": "1676940",
    "end": "1684559"
  },
  {
    "text": "needs to forward the request headers without waiting for the entire request body to a life",
    "start": "1684559",
    "end": "1692000"
  },
  {
    "text": "now what you do is what will you send your request you promise to send more data and then you wait for this timeout",
    "start": "1692000",
    "end": "1698120"
  },
  {
    "text": "to happen as before but we don't necessarily what the front end may not actually read in",
    "start": "1698120",
    "end": "1705500"
  },
  {
    "text": "this timeout response and pass it on to us until it's seen us send a complete request",
    "start": "1705500",
    "end": "1711500"
  },
  {
    "text": "so what you need to do in practice is send your headers and then pause until you think a timeout has probably",
    "start": "1711500",
    "end": "1717860"
  },
  {
    "text": "happened on the back end and just then just continue unprompted and send the",
    "start": "1717860",
    "end": "1723620"
  },
  {
    "text": "body and the follow-up which should trigger a poison response I've updated",
    "start": "1723620",
    "end": "1728900"
  },
  {
    "text": "the turbo Intruder tool to add a couple of different ways of saying where you want to do this delay and how long it",
    "start": "1728900",
    "end": "1736460"
  },
  {
    "text": "should wait for before sending the rest of the request so you do this and that's it you've got",
    "start": "1736460",
    "end": "1742580"
  },
  {
    "text": "a nice server side desync at this point well you might be thinking well that sounds really nice but what",
    "start": "1742580",
    "end": "1749299"
  },
  {
    "text": "front ends actually stream requests like this oh well I just found out yesterday that",
    "start": "1749299",
    "end": "1755659"
  },
  {
    "text": "this is much more common with hv2 but that's not what I was looking at when I did this Research In This research I",
    "start": "1755659",
    "end": "1763760"
  },
  {
    "text": "found it works on Amazon's application load balancer but there's one extra catch they've got",
    "start": "1763760",
    "end": "1770480"
  },
  {
    "text": "a defensive measure called early response detection if they see a response come back from",
    "start": "1770480",
    "end": "1775880"
  },
  {
    "text": "the back end before the request from the client is completed then they'll bend the connection and our attack will fail",
    "start": "1775880",
    "end": "1782539"
  },
  {
    "text": "I mean thrash the connection sorry uh if fortunately this is designed to",
    "start": "1782539",
    "end": "1789679"
  },
  {
    "text": "prevent bugs rather than actual attackers from what I can tell so it's really quite easy to bypass",
    "start": "1789679",
    "end": "1796940"
  },
  {
    "text": "you just need to identify the back end timeout and then make the orange payload hit the front end in the time window",
    "start": "1796940",
    "end": "1803360"
  },
  {
    "text": "between the back end generating the timeout response and the front end seeing it this",
    "start": "1803360",
    "end": "1809360"
  },
  {
    "text": "basically this attack may require a few attempts but it's ultimately worth it",
    "start": "1809360",
    "end": "1815620"
  },
  {
    "text": "there's one final catch you may encounter which is uh quite a lot worse this is when the front end and the",
    "start": "1816740",
    "end": "1823279"
  },
  {
    "text": "back-end server have the same timeout configured on application load balancer that",
    "start": "1823279",
    "end": "1828740"
  },
  {
    "text": "creates a race condition within a race condition that we need to hit which makes life really painful I it may be",
    "start": "1828740",
    "end": "1836179"
  },
  {
    "text": "possible to reset the front-end timer without resetting the back end timer by",
    "start": "1836179",
    "end": "1841340"
  },
  {
    "text": "sending some data that the front end sees but then normalizes and doesn't send on to the back end but nothing I",
    "start": "1841340",
    "end": "1846740"
  },
  {
    "text": "tried actually worked eventually I just gave up of trying things and I was like you know what I'm",
    "start": "1846740",
    "end": "1852080"
  },
  {
    "text": "just gonna leave set a vanilla attack running and just leave it going and just forget about it and uh 66 hours later it",
    "start": "1852080",
    "end": "1859279"
  },
  {
    "text": "was successful so this is one for the patient",
    "start": "1859279",
    "end": "1864640"
  },
  {
    "text": "so that was server side pause based async that just leaves us with one final",
    "start": "1865220",
    "end": "1870860"
  },
  {
    "text": "question which is is there such a thing as a client side poor space desync now I",
    "start": "1870860",
    "end": "1878240"
  },
  {
    "text": "couldn't find any way to make a browser pause halfway through issuing a request",
    "start": "1878240",
    "end": "1883399"
  },
  {
    "text": "but SSL and TLS don't stop attackers from delaying your traffic so there is a potential attack the attacker triggers a",
    "start": "1883399",
    "end": "1890659"
  },
  {
    "text": "request in the browser that's really big it gets split into multiple packets and if the attacker can delay the right",
    "start": "1890659",
    "end": "1896240"
  },
  {
    "text": "packet that can cause a pause-based client-side desync",
    "start": "1896240",
    "end": "1902799"
  },
  {
    "text": "good I've got time so that might sound a bit theoretical but this is blackout so",
    "start": "1903020",
    "end": "1908240"
  },
  {
    "text": "I've made a proof of concept that uses this technique on a default Apache based website to execute arbitrary JavaScript",
    "start": "1908240",
    "end": "1915039"
  },
  {
    "text": "and kind of break TLS uh on the in the victim's browser uh the",
    "start": "1915039",
    "end": "1922100"
  },
  {
    "text": "attack code looks kind of like a normal client-side desync except I've injected tons of padding so the request gets",
    "start": "1922100",
    "end": "1928880"
  },
  {
    "text": "split into multiple packets on the attacker's middle box I've just used the following code to implement the",
    "start": "1928880",
    "end": "1936020"
  },
  {
    "text": "delay it just says slow down traffic by 60 seconds if it's going to the Target",
    "start": "1936020",
    "end": "1941360"
  },
  {
    "text": "website and it's in between 700 and 1 300 bytes in size",
    "start": "1941360",
    "end": "1946880"
  },
  {
    "text": "uh this demo is not the most reliable because it's based on how the browser decides just to split the packets up uh",
    "start": "1946880",
    "end": "1954799"
  },
  {
    "text": "but it works most of the time we'll see what happens",
    "start": "1954799",
    "end": "1959380"
  },
  {
    "text": "so two and we got to kill uh so on the",
    "start": "1960080",
    "end": "1965299"
  },
  {
    "text": "on the victim side I'm just gonna Sox proxy the victim through a box on Amazon",
    "start": "1965299",
    "end": "1972559"
  },
  {
    "text": "uh that's being man in the middle just so the local network doesn't mess things up too much",
    "start": "1972559",
    "end": "1977779"
  },
  {
    "text": "uh and here I'm just connecting to the attacker machine",
    "start": "1977779",
    "end": "1983200"
  },
  {
    "text": "[Applause]",
    "start": "1984220",
    "end": "1987359"
  },
  {
    "text": "all right so you can see the code I've got here to slow down the packets of a certain size and uh the",
    "start": "1990860",
    "end": "1998240"
  },
  {
    "text": "only difference from the slide is that I've changed the vulnerable website timeout from 60 seconds which is the",
    "start": "1998240",
    "end": "2004299"
  },
  {
    "text": "default down to five seconds so the demo doesn't take ages so I'm only injecting",
    "start": "2004299",
    "end": "2009340"
  },
  {
    "text": "a six second delay on the packets now I've just launched TCP dump on the",
    "start": "2009340",
    "end": "2015100"
  },
  {
    "text": "attacker system and if the attack is successful what we'll see in TCP dump is a few packets going",
    "start": "2015100",
    "end": "2022539"
  },
  {
    "text": "through and then a particular large packet being resent by the browser multiple times because the browser knows",
    "start": "2022539",
    "end": "2028960"
  },
  {
    "text": "that it hasn't reached the server yet and it thinks it might have been dropped but the attack is actually just",
    "start": "2028960",
    "end": "2035260"
  },
  {
    "text": "slowing down all those packets and it'll eventually let them through and if everything works that will cause a",
    "start": "2035260",
    "end": "2041980"
  },
  {
    "text": "server-side desync and cores a nice alert box to pop up in the browser so uh let's let's see if it works shall",
    "start": "2041980",
    "end": "2049480"
  },
  {
    "text": "we okay we can see one packets being resent a bunch of times here so any second now",
    "start": "2049480",
    "end": "2055300"
  },
  {
    "text": "in the browser hopefully there we go excellent",
    "start": "2055300",
    "end": "2061720"
  },
  {
    "text": "cool [Applause]",
    "start": "2061720",
    "end": "2066178"
  },
  {
    "text": "cool thanks so yep that's one that's one vulnerability but as you've seen two",
    "start": "2069520",
    "end": "2075040"
  },
  {
    "text": "completely different attacks coming out of it uh we can skip my backup video because it actually worked uh",
    "start": "2075040",
    "end": "2081878"
  },
  {
    "text": "foreign that was the final attack of the",
    "start": "2081879",
    "end": "2087878"
  },
  {
    "text": "presentation so let's talk about defense these attacks almost all exploit HTTP",
    "start": "2087879",
    "end": "2094720"
  },
  {
    "text": "one so if you can use hb2 end to end if you can't use it end to end I would not",
    "start": "2094720",
    "end": "2101260"
  },
  {
    "text": "recommend doing HP downgrading from H2 to H1 because that introduces extra",
    "start": "2101260",
    "end": "2106960"
  },
  {
    "text": "risks the second point is and I'm genuinely",
    "start": "2106960",
    "end": "2112180"
  },
  {
    "text": "not sure what other people are going to think about this but honestly it's really easy to make a HTTP",
    "start": "2112180",
    "end": "2119440"
  },
  {
    "text": "one server and it's really hard to make a secure HTTP one server so my advice",
    "start": "2119440",
    "end": "2125859"
  },
  {
    "text": "would be avoid coding your own HP one server if you can that said I think software diversity is",
    "start": "2125859",
    "end": "2131980"
  },
  {
    "text": "a great thing uh so here's some advice if you're a server maintainer and you want to harden your server or patch an",
    "start": "2131980",
    "end": "2139720"
  },
  {
    "text": "existing client-side desync vulnerability there's a bunch of further reading",
    "start": "2139720",
    "end": "2145960"
  },
  {
    "text": "available the three key things I would suggest are check out the white paper that's the top link have a go at the",
    "start": "2145960",
    "end": "2151660"
  },
  {
    "text": "online Labs that we've made to get some practical experience and then try out like my code to scan and find and",
    "start": "2151660",
    "end": "2157359"
  },
  {
    "text": "exploit some real vulnerable systems uh feel free to chat me an email to let me know how it goes",
    "start": "2157359",
    "end": "2162520"
  },
  {
    "text": "there's also a presentation this afternoon that is kind of related to this one actually so you might want to",
    "start": "2162520",
    "end": "2168220"
  },
  {
    "text": "check that out uh the three key things to take away are the request is a lie",
    "start": "2168220",
    "end": "2175480"
  },
  {
    "text": "HTTP one connection we use is harmful and all you need is a server taken by",
    "start": "2175480",
    "end": "2182740"
  },
  {
    "text": "surprise I'll take about three minutes of questions now if you have any more after",
    "start": "2182740",
    "end": "2188560"
  },
  {
    "text": "that feel free to come and chat to me at the back or just chat me an email time to forget to follow me on Twitter",
    "start": "2188560",
    "end": "2194680"
  },
  {
    "text": "thank you for listening [Applause]",
    "start": "2194680",
    "end": "2206500"
  },
  {
    "text": "so we've got two minutes any questions foreign",
    "start": "2206500",
    "end": "2213420"
  },
  {
    "text": "thank you [Applause] [Music] [Applause]",
    "start": "2218700",
    "end": "2226740"
  },
  {
    "text": "[Music]",
    "start": "2226740",
    "end": "2231690"
  }
]