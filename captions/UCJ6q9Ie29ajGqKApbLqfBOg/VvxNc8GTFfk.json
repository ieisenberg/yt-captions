[
  {
    "start": "0",
    "end": "76000"
  },
  {
    "text": "[Music]",
    "start": "1130",
    "end": "13840"
  },
  {
    "text": "hi everyone good morning or evening wherever you are uh i'm your den",
    "start": "13840",
    "end": "19520"
  },
  {
    "text": "and i'll be talking today about the windows pool and how it changed since",
    "start": "19520",
    "end": "25519"
  },
  {
    "text": "windows 10 redstone 5 and how that impacts us mostly from an exploit",
    "start": "25519",
    "end": "31840"
  },
  {
    "text": "development or exploit defense perspective so before i start i'll just introduce",
    "start": "31840",
    "end": "38320"
  },
  {
    "text": "myself as you as usual i'm a software engineer at crowdstrike before crowdstrike i worked at central",
    "start": "38320",
    "end": "45280"
  },
  {
    "text": "one i did security research and software testing",
    "start": "45280",
    "end": "50559"
  },
  {
    "text": "i'm also a circus artist doing aerial arts and i used to be a pastry chef",
    "start": "50559",
    "end": "56719"
  },
  {
    "text": "and outside of my day job i teach windows internals classes with alex nesco at insiders",
    "start": "56719",
    "end": "63840"
  },
  {
    "text": "um i blog and generally rant about windows and security and stuff on twitter or in",
    "start": "63840",
    "end": "70880"
  },
  {
    "text": "a blog that's here on the slide if you're interested later",
    "start": "70880",
    "end": "75920"
  },
  {
    "start": "76000",
    "end": "234000"
  },
  {
    "text": "all right so your topic to anyone who isn't familiar the windows kernel pool",
    "start": "77119",
    "end": "82400"
  },
  {
    "text": "is similar to the user mode heap it's used for any kind of dynamic memory",
    "start": "82400",
    "end": "88000"
  },
  {
    "text": "anything that needs to be allocated or modified during runtime is going to go",
    "start": "88000",
    "end": "93040"
  },
  {
    "text": "in the kernel pool now unlike user mode where every process has its own heap",
    "start": "93040",
    "end": "98640"
  },
  {
    "text": "in the kernel all the code running in the kernel is going to use the same",
    "start": "98640",
    "end": "104720"
  },
  {
    "text": "pools there are a few different kernel pools of where the biggest difference is some are",
    "start": "104720",
    "end": "110560"
  },
  {
    "text": "paid memory and some are non-paged memory but there are a few other kinds as well such as a special pool etc",
    "start": "110560",
    "end": "119119"
  },
  {
    "text": "now the pool is a pretty common and popular target for kernel exploits for example using",
    "start": "119119",
    "end": "125680"
  },
  {
    "text": "buffer overflows to overwrite the next for a location or the one after that",
    "start": "125680",
    "end": "131760"
  },
  {
    "text": "to gain data corruption attacks to use for data corruption attacks",
    "start": "131760",
    "end": "138640"
  },
  {
    "text": "and hopefully ultimately getting ring zero code execution",
    "start": "138640",
    "end": "144319"
  },
  {
    "text": "and that's been going on for a lot of years there have been all sorts of smaller mitigations around that but as a",
    "start": "144319",
    "end": "152160"
  },
  {
    "text": "technique um techniques using um the kernel pool",
    "start": "152160",
    "end": "157280"
  },
  {
    "text": "for exploitation are still relatively common as far as curl exploits go",
    "start": "157280",
    "end": "164480"
  },
  {
    "text": "now the second thing for the second thing that current pools are used for for exploitation",
    "start": "164480",
    "end": "170640"
  },
  {
    "text": "is information leaks so because since aslr the addresses of drivers the",
    "start": "170640",
    "end": "176239"
  },
  {
    "text": "addresses of objects in the kernel are changing every boot you can't predict",
    "start": "176239",
    "end": "181519"
  },
  {
    "text": "them so you can use the kernel pool for example if you have uninitialized memory there",
    "start": "181519",
    "end": "187200"
  },
  {
    "text": "that's going to be returned to user mode you get all sorts of random stuff that were in the kernel pool random kernel",
    "start": "187200",
    "end": "193760"
  },
  {
    "text": "pointers uh you can get all sorts of fun information leaks there",
    "start": "193760",
    "end": "199440"
  },
  {
    "text": "now that has been mostly mitigated in windows 10 with a new api ex allocate pool 2 that",
    "start": "199440",
    "end": "207840"
  },
  {
    "text": "zeroes out pool locations once they're allocated then even if you",
    "start": "207840",
    "end": "213840"
  },
  {
    "text": "have an initial uh you don't have uninitialized memory anymore you're not going to leak random pull data to use remote okay it's",
    "start": "213840",
    "end": "222000"
  },
  {
    "text": "all going to be zeros but that allocate but that new allocation",
    "start": "222000",
    "end": "227599"
  },
  {
    "text": "api only mitigates one attack vector and there are still many more",
    "start": "227599",
    "end": "234799"
  },
  {
    "start": "234000",
    "end": "286000"
  },
  {
    "text": "um and if we look at the apis that are exposed to third-party",
    "start": "234799",
    "end": "239920"
  },
  {
    "text": "callers in the kernel meaning kernel code that is not running inside the kernel itself",
    "start": "239920",
    "end": "246159"
  },
  {
    "text": "if we're just looking at the allocation apis we see at least 10 here that's just",
    "start": "246159",
    "end": "251439"
  },
  {
    "text": "the ones i got from ida when i open it up that doesn't include any of the other",
    "start": "251439",
    "end": "259440"
  },
  {
    "text": "apis that handle pool or any of the apis running underneath them that aren't",
    "start": "259440",
    "end": "266960"
  },
  {
    "text": "exported and there are lots and lots and lots and lots of functions doing super complicated things",
    "start": "266960",
    "end": "272800"
  },
  {
    "text": "and in general handling the kernel pool is a really uh complicated thing for the system to",
    "start": "272800",
    "end": "279759"
  },
  {
    "text": "do it just keeps getting more complicated the more memory the kernel uses",
    "start": "279759",
    "end": "287280"
  },
  {
    "start": "286000",
    "end": "385000"
  },
  {
    "text": "but from a developer or defender or exploit perspective",
    "start": "287280",
    "end": "292800"
  },
  {
    "text": "before rs-5 the pool was a relatively simple thing because it had pretty",
    "start": "292800",
    "end": "297840"
  },
  {
    "text": "simple structures as far as the exploit was concerned we",
    "start": "297840",
    "end": "302960"
  },
  {
    "text": "could look at the pool on a per page basis every pool page started with a pool header that had some information",
    "start": "302960",
    "end": "309199"
  },
  {
    "text": "about the block size the previous block size uh the type of pool it's in and a pool",
    "start": "309199",
    "end": "316560"
  },
  {
    "text": "tag used to identify the allocation after each pool header there was the",
    "start": "316560",
    "end": "322240"
  },
  {
    "text": "data after that another pool header telling us information about the next block its size whether it's allocated or",
    "start": "322240",
    "end": "328800"
  },
  {
    "text": "free etc etc data another pool header so on and so on",
    "start": "328800",
    "end": "333840"
  },
  {
    "text": "if we chose a random address in the pool we could go to the beginning of the page start parsing from the beginning of the",
    "start": "333840",
    "end": "339919"
  },
  {
    "text": "page and have all the information we needed about everything in that pool page it was easy to parse all the data was",
    "start": "339919",
    "end": "348960"
  },
  {
    "text": "clear text it was very easy to read it was also very easy to fake if you use the buffer overflow",
    "start": "348960",
    "end": "357840"
  },
  {
    "text": "vulnerability to override the next location you could just for example fake the next allocation",
    "start": "357840",
    "end": "365199"
  },
  {
    "text": "and tell the system that it's way smaller or way larger it actually is and get all sorts of nice techniques there",
    "start": "365199",
    "end": "373440"
  },
  {
    "text": "but that was before rs5 since rs5 things look a little bit",
    "start": "373440",
    "end": "378639"
  },
  {
    "text": "differently and the structures of the pool look something like this",
    "start": "378639",
    "end": "385759"
  },
  {
    "start": "385000",
    "end": "486000"
  },
  {
    "text": "which is way way way more than just a single pool page this is a little bit",
    "start": "385759",
    "end": "392160"
  },
  {
    "text": "overwhelming we'll go over some of it in this talk um of course not every exploit or",
    "start": "392160",
    "end": "399520"
  },
  {
    "text": "defender will need to handle all these structures but a lot of them are relevant we can't just look at a single",
    "start": "399520",
    "end": "405840"
  },
  {
    "text": "page anymore because with this new pool model um",
    "start": "405840",
    "end": "411759"
  },
  {
    "text": "it the system switches to a completely new design",
    "start": "411759",
    "end": "417199"
  },
  {
    "text": "which is the same as the design of the user mode heap now we're not looking at a per page",
    "start": "417199",
    "end": "425520"
  },
  {
    "text": "view anymore single pages don't really mean that much in the modern kernel pool",
    "start": "425520",
    "end": "430960"
  },
  {
    "text": "instead we're looking at a model of segments and sub segments",
    "start": "430960",
    "end": "437120"
  },
  {
    "text": "and all sorts of different things like that that require knowing the system a lot better just to figure out what we're",
    "start": "437120",
    "end": "444240"
  },
  {
    "text": "looking at but if anyone is familiar with the internal structures of the user mode heap this will be very very similar",
    "start": "444240",
    "end": "450639"
  },
  {
    "text": "it now uses the same libraries with minor differences to",
    "start": "450639",
    "end": "455759"
  },
  {
    "text": "make it work properly for the kernel needs which means you can now look at both",
    "start": "455759",
    "end": "462080"
  },
  {
    "text": "user mode and kernel mode heaps in a very similar way which is both good and bad and we'll see",
    "start": "462080",
    "end": "468160"
  },
  {
    "text": "later why the one thing that hasn't changed is large pool the large pool was managed by",
    "start": "468160",
    "end": "474879"
  },
  {
    "text": "the va space and still is nothing changed there but we're not going to talk about the large pool today",
    "start": "474879",
    "end": "481599"
  },
  {
    "text": "practically everything else is now different um",
    "start": "481599",
    "end": "487680"
  },
  {
    "text": "one more thing that is different is that until rs5 we didn't really care all that much about the size of separate blocks",
    "start": "487680",
    "end": "494800"
  },
  {
    "text": "the main thing that we heard that we cared about when choosing where to allocate a single block is",
    "start": "494800",
    "end": "500400"
  },
  {
    "text": "whether it's large enough to go in the large pool or not if it's small enough to not go into large pool it went in the",
    "start": "500400",
    "end": "507039"
  },
  {
    "text": "same regular pages everything else that's not true anymore now we do very",
    "start": "507039",
    "end": "513279"
  },
  {
    "text": "much hear about specific sizes of pool blocks and later in this talk we'll see",
    "start": "513279",
    "end": "518479"
  },
  {
    "text": "why now this new model every separate pool has",
    "start": "518479",
    "end": "525200"
  },
  {
    "text": "one structure one large structure managing it that structure is the segment heap",
    "start": "525200",
    "end": "530800"
  },
  {
    "text": "that's allocated in the beginning of every pool the first by of the first page",
    "start": "530800",
    "end": "535839"
  },
  {
    "text": "has the segment heap and all the structures contained in it it has a lot of metadata information",
    "start": "535839",
    "end": "542959"
  },
  {
    "text": "for example what address do allocations start in what pages are committed what pages are",
    "start": "542959",
    "end": "549760"
  },
  {
    "text": "uncommitted amounts of allocated and free pages all",
    "start": "549760",
    "end": "556720"
  },
  {
    "text": "sorts of pointers to different structures that are needed to manage separate parts of the pool and",
    "start": "556720",
    "end": "563120"
  },
  {
    "text": "that's a start that's a structure that's good to know and it has all sorts of interesting information when you're looking at an individual pool",
    "start": "563120",
    "end": "571600"
  },
  {
    "start": "570000",
    "end": "724000"
  },
  {
    "text": "now i mentioned that sizes do matter now more than they used to and",
    "start": "571600",
    "end": "577120"
  },
  {
    "text": "they matter in two different ways the first one is do they belong in",
    "start": "577120",
    "end": "583040"
  },
  {
    "text": "the large pool if they do they go into large pool as always and if they don't belong in a large pool",
    "start": "583040",
    "end": "590399"
  },
  {
    "text": "we have a second split is the address over or under",
    "start": "590399",
    "end": "595880"
  },
  {
    "text": "508 kilobytes because if the address is over 508",
    "start": "595880",
    "end": "601519"
  },
  {
    "text": "kilobytes it's a pretty um not the address the size is over 508 kilobytes",
    "start": "601519",
    "end": "607519"
  },
  {
    "text": "it's a pretty large allocation and we don't really need to look at small resolutions such as a single page uh you",
    "start": "607519",
    "end": "615120"
  },
  {
    "text": "can fit a whole lot of pages in 508 kilobytes and there's no need to",
    "start": "615120",
    "end": "620240"
  },
  {
    "text": "handle them on a per page basis because the system doesn't really care about the data inside the application",
    "start": "620240",
    "end": "626720"
  },
  {
    "text": "instead it can handle those we won't call them large allocations because they're not in a",
    "start": "626720",
    "end": "632560"
  },
  {
    "text": "large pool but let's call them um big allocations it can handle them with a",
    "start": "632560",
    "end": "639040"
  },
  {
    "text": "larger resolution in a way that's more efficient now if the pool block is a small one",
    "start": "639040",
    "end": "644160"
  },
  {
    "text": "which is under 508 kilobytes it can still be pretty small it can be",
    "start": "644160",
    "end": "649839"
  },
  {
    "text": "20 30 40 bytes then we still need to handle it in smaller units of one page or less than a",
    "start": "649839",
    "end": "657680"
  },
  {
    "text": "page and handle them sort of the same way we used to but we'll see how that's",
    "start": "657680",
    "end": "663519"
  },
  {
    "text": "still not exactly true and now in the segment heap we have",
    "start": "663519",
    "end": "669760"
  },
  {
    "text": "two segments the first segments in the first segment represented both by a heapsed context",
    "start": "669760",
    "end": "676240"
  },
  {
    "text": "structure um is used for small allocations up to 508 kilobytes and the second segment or",
    "start": "676240",
    "end": "684880"
  },
  {
    "text": "seg context is used for allocations that are medium-sized",
    "start": "684880",
    "end": "690240"
  },
  {
    "text": "meaning 508 kilobytes up to 8128",
    "start": "690240",
    "end": "695760"
  },
  {
    "text": "which is the limit uh over it everything is large and each one of these set contacts",
    "start": "695760",
    "end": "702079"
  },
  {
    "text": "handles a different um base unit for small blocks the",
    "start": "702079",
    "end": "708800"
  },
  {
    "text": "base unit we're talking about is one page for medium blocks in the second heapset context the base unit we'll talk",
    "start": "708800",
    "end": "716160"
  },
  {
    "text": "about is 16 pages so now instead of talking about pages we're talking about",
    "start": "716160",
    "end": "721920"
  },
  {
    "text": "basic units",
    "start": "721920",
    "end": "724880"
  },
  {
    "start": "724000",
    "end": "787000"
  },
  {
    "text": "but if we're looking at a single allocation we do want to know what",
    "start": "727440",
    "end": "733600"
  },
  {
    "text": "seg context it uses to know which structure you want to look at so to know that we have a new bitmap but",
    "start": "733600",
    "end": "740480"
  },
  {
    "text": "it has three layers like a lot of kernel bitmaps do and for this bitmap every",
    "start": "740480",
    "end": "748399"
  },
  {
    "text": "um every allocation every every byte is represented by two bits",
    "start": "748399",
    "end": "754560"
  },
  {
    "text": "and if those two bits have a value of zero this is a large pool",
    "start": "754560",
    "end": "760240"
  },
  {
    "text": "if the value is one it's a small pool block meaning it's represent it's used",
    "start": "760240",
    "end": "766000"
  },
  {
    "text": "in the first set context for small blocks and if the bitmap value is two",
    "start": "766000",
    "end": "772160"
  },
  {
    "text": "it's a medium block and we need to go to the second set context to look at it three is not",
    "start": "772160",
    "end": "779120"
  },
  {
    "text": "really used it has sort of inconsistent interpretation but it's best to to ignore it",
    "start": "779120",
    "end": "787839"
  },
  {
    "start": "787000",
    "end": "840000"
  },
  {
    "text": "now inside that heapset context again we're talking about um basic basic units",
    "start": "788959",
    "end": "795600"
  },
  {
    "text": "of either one or 16 pages of basic information",
    "start": "795600",
    "end": "800880"
  },
  {
    "text": "and inside of that inside of each of them we have a split into segments where each",
    "start": "800880",
    "end": "807120"
  },
  {
    "text": "segment handles a certain amount of memory so in the first seg context for small",
    "start": "807120",
    "end": "814480"
  },
  {
    "text": "blocks each segment handles one megabyte of memory in the second it handles 16 megabytes of",
    "start": "814480",
    "end": "821279"
  },
  {
    "text": "memory so they handle the same amount of units but the unit size is different and",
    "start": "821279",
    "end": "826720"
  },
  {
    "text": "we can go to set context to iterate the list of segments and find each and every segment managed by the set context",
    "start": "826720",
    "end": "834399"
  },
  {
    "text": "and if we want to parse them handle them in whatever way we want",
    "start": "834399",
    "end": "840959"
  },
  {
    "start": "840000",
    "end": "1034000"
  },
  {
    "text": "so this is just to reiterate because there are a lot of new structures here there's a lot of new data going on uh so",
    "start": "840959",
    "end": "847839"
  },
  {
    "text": "we have a segment heap in the beginning of the pool that segment heap has two set contexts for different size",
    "start": "847839",
    "end": "855360"
  },
  {
    "text": "allocations and in each one of these same contexts we have a list of segments and from",
    "start": "855360",
    "end": "863040"
  },
  {
    "text": "those segments we can get to the actual allocations now how do we do that",
    "start": "863040",
    "end": "869760"
  },
  {
    "text": "the heat page segment structure is in is in the beginning of the",
    "start": "869760",
    "end": "876160"
  },
  {
    "text": "segment meaning for every pull block if we go to the beginning of its segment meaning either the beginning of the",
    "start": "876160",
    "end": "882240"
  },
  {
    "text": "megabyte or the beginning of its 16 megabytes we'll find the heap page",
    "start": "882240",
    "end": "887360"
  },
  {
    "text": "segment structure now that structure has an array of 256 descriptors",
    "start": "887360",
    "end": "894079"
  },
  {
    "text": "and each descriptor represents a basic unit and",
    "start": "894079",
    "end": "899440"
  },
  {
    "text": "the descriptor in the descriptor array gives us information about the basic",
    "start": "899440",
    "end": "905519"
  },
  {
    "text": "unit um what type of unit it is and we'll talk",
    "start": "905519",
    "end": "910639"
  },
  {
    "text": "about the different types of units later is it the beginning of a range the middle of a range is it used not used",
    "start": "910639",
    "end": "918800"
  },
  {
    "text": "etc and using the index of the descriptor we can just",
    "start": "918800",
    "end": "924880"
  },
  {
    "text": "multiply that by the size of a base unit jump there and get to the actual address",
    "start": "924880",
    "end": "931199"
  },
  {
    "text": "in that range and we'll see how we do that another thing that we have in the page",
    "start": "931199",
    "end": "936320"
  },
  {
    "text": "segment and we have that in this diagram is we have a signature and that",
    "start": "936320",
    "end": "941360"
  },
  {
    "text": "signature can lead us back to the heaps and context but go on to signature",
    "start": "941360",
    "end": "947519"
  },
  {
    "text": "because it's not a pointer you if you look at it you'll see a value like the one on the slide that looks like",
    "start": "947519",
    "end": "954399"
  },
  {
    "text": "complete garbage because that's not a direct pointer to this say context it's an encode it's an",
    "start": "954399",
    "end": "961120"
  },
  {
    "text": "encoded pointer that's encoded with the segment address and",
    "start": "961120",
    "end": "966480"
  },
  {
    "text": "um a magic value that's hardcore in the kernel and a heap key",
    "start": "966480",
    "end": "972480"
  },
  {
    "text": "there are new keys now in the kernel that are of course non-exported and generated on boot that are used to",
    "start": "972480",
    "end": "979040"
  },
  {
    "text": "encode all sorts of things because this design change in the pool it was done",
    "start": "979040",
    "end": "984160"
  },
  {
    "text": "mostly for performance reasons but they also added some security",
    "start": "984160",
    "end": "989839"
  },
  {
    "text": "improvements such as encoding all sorts of interesting values to avoid inflicts",
    "start": "989839",
    "end": "995839"
  },
  {
    "text": "to make exploitation harder to make it so that if you want to exploit the pool",
    "start": "995839",
    "end": "1001120"
  },
  {
    "text": "you won't just need your initial vulnerability in your first primitive you will also need a whole lot of",
    "start": "1001120",
    "end": "1009199"
  },
  {
    "text": "information disclosures just to get the pointers you need and this is one of them so you don't have a direct pointer",
    "start": "1009199",
    "end": "1016720"
  },
  {
    "text": "back to a heapside context you have an encoded one that you need to have all sorts of",
    "start": "1016720",
    "end": "1024400"
  },
  {
    "text": "very specific information that's not even all that easy to get in the kernel",
    "start": "1024400",
    "end": "1029600"
  },
  {
    "text": "to decode it and we'll see that heap key being used in all sorts of other contexts later",
    "start": "1029600",
    "end": "1036079"
  },
  {
    "text": "and we talked about the descriptors and how the descriptors describe what type",
    "start": "1036079",
    "end": "1041760"
  },
  {
    "text": "of um unit this is what kind of range this is",
    "start": "1041760",
    "end": "1047438"
  },
  {
    "text": "and now i need to talk about the second case uh the second place where the pull block",
    "start": "1047439",
    "end": "1053360"
  },
  {
    "text": "size matters because now we don't just care if the pull block is smaller or larger than 508",
    "start": "1053360",
    "end": "1061039"
  },
  {
    "text": "kilobytes we also care if it's a common size or not when they say common size i mean",
    "start": "1061039",
    "end": "1067840"
  },
  {
    "text": "one of 129 common sizes that were hardcoded in the kernel things like 10 bytes 20 bytes",
    "start": "1067840",
    "end": "1075520"
  },
  {
    "text": "30 bytes 100 bytes 200 bytes sizes that we expect to see very often",
    "start": "1075520",
    "end": "1081919"
  },
  {
    "text": "in the kernel and for those sizes we have one type of sub segment called lfh or",
    "start": "1081919",
    "end": "1089520"
  },
  {
    "text": "low fragmentation heap because if we have a lot of pull block size let's say 20 bytes",
    "start": "1089520",
    "end": "1097039"
  },
  {
    "text": "then we don't necessarily need to have a header like a pool header for each of",
    "start": "1097039",
    "end": "1102480"
  },
  {
    "text": "them we can just have a sub segment of only block size 20 20 hex bytes right one",
    "start": "1102480",
    "end": "1111120"
  },
  {
    "text": "after the other and then we don't really need a header for each we just know that all the blocks here",
    "start": "1111120",
    "end": "1117520"
  },
  {
    "text": "have the same size and it's very easy to find them with simple",
    "start": "1117520",
    "end": "1123280"
  },
  {
    "text": "arithmetic um and we can save a whole lot of space on headers that aren't really necessary",
    "start": "1123280",
    "end": "1129280"
  },
  {
    "text": "so for 129 common sizes up to",
    "start": "1129280",
    "end": "1134400"
  },
  {
    "text": "uh 4 000 hex bytes we have",
    "start": "1134400",
    "end": "1139760"
  },
  {
    "text": "um we have lfh sub segments now each type of lfa sub segment each",
    "start": "1139760",
    "end": "1146000"
  },
  {
    "text": "uh each each range of lfh sub segment",
    "start": "1146000",
    "end": "1151120"
  },
  {
    "text": "will only have blocks of one of the 129 common sizes",
    "start": "1151120",
    "end": "1157760"
  },
  {
    "text": "so we could have one range that handles block size 20 bytes one range that",
    "start": "1157760",
    "end": "1163919"
  },
  {
    "text": "handles block size 40 bytes another one candles block size 100 bytes etc etc",
    "start": "1163919",
    "end": "1172160"
  },
  {
    "text": "and then we have the second type of segment vs or variable size and that handles",
    "start": "1172160",
    "end": "1178640"
  },
  {
    "text": "everything else anything that doesn't fit in one of the lfh buckets goes in a vs",
    "start": "1178640",
    "end": "1185280"
  },
  {
    "text": "sub segment now with via subsegment we can't know in advance the size of all",
    "start": "1185280",
    "end": "1190480"
  },
  {
    "text": "the sub segments because each one can have a different block size so for those",
    "start": "1190480",
    "end": "1195919"
  },
  {
    "text": "we will have a header for every block but in cases where we can",
    "start": "1195919",
    "end": "1202320"
  },
  {
    "text": "save some space we will use lfh and just know that all the blocks in this range",
    "start": "1202320",
    "end": "1208400"
  },
  {
    "text": "have the same size",
    "start": "1208400",
    "end": "1211919"
  },
  {
    "start": "1211000",
    "end": "1419000"
  },
  {
    "text": "and here we can see what the ranges look like now in this slide i made it so both ranges have the same",
    "start": "1216960",
    "end": "1224320"
  },
  {
    "text": "size and notes this is not always the case we can have",
    "start": "1224320",
    "end": "1229440"
  },
  {
    "text": "an lfh range that is four pages and immediately after it a vs range of",
    "start": "1229440",
    "end": "1235520"
  },
  {
    "text": "is 11 pages we can't know in advance the size of the different ranges how many pages there will be",
    "start": "1235520",
    "end": "1242400"
  },
  {
    "text": "we'll have ranges that cross page boundaries the only way to know the size of a range is",
    "start": "1242400",
    "end": "1248480"
  },
  {
    "text": "to go to the beginning of a segment and look at the descriptors the range descriptors",
    "start": "1248480",
    "end": "1256559"
  },
  {
    "text": "which will have information such as what type of range is this is it lfa is it vs",
    "start": "1256559",
    "end": "1263039"
  },
  {
    "text": "uh is this unit in the beginning of a sub-segment is it in the middle of a sub-segment",
    "start": "1263039",
    "end": "1269120"
  },
  {
    "text": "uh what is the offset of this descriptor from the beginning of the sub-segment",
    "start": "1269120",
    "end": "1275039"
  },
  {
    "text": "etc you will really just need to go to a segment if you pick a random page you don't have a good way to know",
    "start": "1275039",
    "end": "1282000"
  },
  {
    "text": "what type of sub segment it is or where it begins so you just need to use the segment for that",
    "start": "1282000",
    "end": "1288240"
  },
  {
    "text": "now like i mentioned uh elephant sub segments just have a header in the beginning of the sub segment which is a",
    "start": "1288240",
    "end": "1295360"
  },
  {
    "text": "heap lfh subsegment structure and that has information about most",
    "start": "1295360",
    "end": "1302559"
  },
  {
    "text": "importantly what block sizes are handled in the sub segment",
    "start": "1302559",
    "end": "1308000"
  },
  {
    "text": "what blocks are allocated which ones are free and all sorts of other metadata",
    "start": "1308000",
    "end": "1313840"
  },
  {
    "text": "for vs sub segments we have a different structure that is again in the beginning of the subsegment",
    "start": "1313840",
    "end": "1320320"
  },
  {
    "text": "it's called the heap vs subsegment and that gives us some metadata about the",
    "start": "1320320",
    "end": "1325440"
  },
  {
    "text": "segment but here we do need a header for every separate pro block because each one has",
    "start": "1325440",
    "end": "1332159"
  },
  {
    "text": "a different size so we have a heap beast chunk header for every pull block that has",
    "start": "1332159",
    "end": "1338720"
  },
  {
    "text": "information about the block and most importantly its size now anything that has",
    "start": "1338720",
    "end": "1344960"
  },
  {
    "text": "explicit sizes is now going to be encoded so this will be the lfh sub segment",
    "start": "1344960",
    "end": "1350960"
  },
  {
    "text": "header and the heap vs chunk header both have size information so both will be encoded",
    "start": "1350960",
    "end": "1357039"
  },
  {
    "text": "the vs headers will be encoded with the heap key and the lfh sub segment will be",
    "start": "1357039",
    "end": "1362480"
  },
  {
    "text": "encoded with the lfh key which is another key also determined at boot also",
    "start": "1362480",
    "end": "1369360"
  },
  {
    "text": "saved in the kernel and not exported now for every data block it will start",
    "start": "1369360",
    "end": "1376400"
  },
  {
    "text": "with a pool header just for compatibility reasons and as a place to store the uh",
    "start": "1376400",
    "end": "1383039"
  },
  {
    "text": "the pool tag but you can't use them to iterate the pool anymore",
    "start": "1383039",
    "end": "1388480"
  },
  {
    "text": "or to parse it because only allocated blocks will have pull headers for free blocks",
    "start": "1388480",
    "end": "1394320"
  },
  {
    "text": "you can't count on them having pull headers it might be there because no one overwrote it might be there's just junk",
    "start": "1394320",
    "end": "1401120"
  },
  {
    "text": "information but to iterate free blocks you really need the actual",
    "start": "1401120",
    "end": "1406640"
  },
  {
    "text": "structures used by the kernel to manage the pool pool header is just",
    "start": "1406640",
    "end": "1412320"
  },
  {
    "text": "a nice thing to have there for compatibility for allocated blocks it's a good place to find the pool tag but",
    "start": "1412320",
    "end": "1417760"
  },
  {
    "text": "not much else",
    "start": "1417760",
    "end": "1420559"
  },
  {
    "start": "1419000",
    "end": "1517000"
  },
  {
    "text": "now one way to find lfh and via sub segments is to go to the beginning of the segment and walk",
    "start": "1425600",
    "end": "1433520"
  },
  {
    "text": "the range descriptors one by one and figure out for every unit is this an lfh or a",
    "start": "1433520",
    "end": "1440159"
  },
  {
    "text": "vs subsequent another way is going to the heap",
    "start": "1440159",
    "end": "1446880"
  },
  {
    "text": "to the segment heap structure and looking",
    "start": "1446880",
    "end": "1452720"
  },
  {
    "text": "looking there for vs and lfh contexts these manage lfh and",
    "start": "1452720",
    "end": "1460159"
  },
  {
    "text": "vs subsegments in the pool they have a linked list",
    "start": "1460159",
    "end": "1465279"
  },
  {
    "text": "of all the sub-segments of that type and they also have callbacks that",
    "start": "1465279",
    "end": "1471360"
  },
  {
    "text": "point to management functions functions used for allocating uh freeing",
    "start": "1471360",
    "end": "1477120"
  },
  {
    "text": "committing etc memory because we treat the kernel treats lfh and vs memory",
    "start": "1477120",
    "end": "1482720"
  },
  {
    "text": "differently it's all just reiterates uh and gives a little bit more details about the specific encoding",
    "start": "1482720",
    "end": "1490480"
  },
  {
    "text": "usually things are encoded with either the lfh or the hip key",
    "start": "1490480",
    "end": "1495520"
  },
  {
    "text": "and the address of the header or the sub segment or where the wherever the",
    "start": "1495520",
    "end": "1500880"
  },
  {
    "text": "structure is this is just about the vs and lfh",
    "start": "1500880",
    "end": "1507200"
  },
  {
    "text": "contexts in the segment heap each of them has callbacks",
    "start": "1507200",
    "end": "1512320"
  },
  {
    "text": "to kernel functions that are used to manage this type of memory",
    "start": "1512320",
    "end": "1518879"
  },
  {
    "start": "1517000",
    "end": "1636000"
  },
  {
    "text": "now here we can see the lfh buckets they are hard coded in the kernel in an",
    "start": "1519120",
    "end": "1524799"
  },
  {
    "text": "array first we have a hops of 10 hex bytes",
    "start": "1524799",
    "end": "1530080"
  },
  {
    "text": "from zero to um to uh 200 or actually 400 then",
    "start": "1530080",
    "end": "1539039"
  },
  {
    "text": "um hops with larger resolution and in total we have 129",
    "start": "1539039",
    "end": "1546960"
  },
  {
    "text": "sizes up until 4 000 hex files meaning only said context zero the one that handles",
    "start": "1546960",
    "end": "1554240"
  },
  {
    "text": "small allocations has lh sub sub segments anything larger than 4 000 x",
    "start": "1554240",
    "end": "1562000"
  },
  {
    "text": "bytes will always be vs subsegment because these",
    "start": "1562000",
    "end": "1567919"
  },
  {
    "text": "are these sizes are too large that we don't expect to have all that many of them",
    "start": "1567919",
    "end": "1573679"
  },
  {
    "text": "another thing is once in a while you might also see one of these common sizes in a vs",
    "start": "1573679",
    "end": "1580960"
  },
  {
    "text": "subsequent that's because we don't um the car won't activate lfh buckets",
    "start": "1580960",
    "end": "1587440"
  },
  {
    "text": "until there are at least 16 allocations of that size so",
    "start": "1587440",
    "end": "1593200"
  },
  {
    "text": "the first 16 allocations of pool of block size uh 20",
    "start": "1593200",
    "end": "1598559"
  },
  {
    "text": "20 hex bytes will go in vs sub segments only after 16 locations the girl will say oh okay",
    "start": "1598559",
    "end": "1606080"
  },
  {
    "text": "there are enough pull blocks of that size will activate this lfh bucket will",
    "start": "1606080",
    "end": "1611600"
  },
  {
    "text": "create an lfh sub segment for block sized 20 bytes but you will still see a few",
    "start": "1611600",
    "end": "1619039"
  },
  {
    "text": "blocks that were allocated before the bucket was activated so you can still see them in",
    "start": "1619039",
    "end": "1624320"
  },
  {
    "text": "vs blocks and this just shows how these structures",
    "start": "1624320",
    "end": "1629360"
  },
  {
    "text": "are connected just zooming in on different parts of that huge scary diagram from the beginning of the talk",
    "start": "1629360",
    "end": "1637960"
  },
  {
    "start": "1636000",
    "end": "1807000"
  },
  {
    "text": "now we've talked about the internal structures or at least the part of them that is relevant uh for us in this case",
    "start": "1642000",
    "end": "1648240"
  },
  {
    "text": "now how does this affect exploitation mostly this very much limits",
    "start": "1648240",
    "end": "1655039"
  },
  {
    "text": "modern pool exploitation because with this new design",
    "start": "1655039",
    "end": "1661120"
  },
  {
    "text": "spraying the pool is way way way harder because we need to account for what type of",
    "start": "1661120",
    "end": "1668159"
  },
  {
    "text": "sub-segment this pool this object that we're spraying is going to",
    "start": "1668159",
    "end": "1673520"
  },
  {
    "text": "end up in is it a common size we will go in lfa sub-segments",
    "start": "1673520",
    "end": "1678799"
  },
  {
    "text": "is this a non-common size we'll go in vs sub segments if this is a via sub segment then every block has an encoded",
    "start": "1678799",
    "end": "1686640"
  },
  {
    "text": "header how do we handle that also sub segments cross page boundaries",
    "start": "1686640",
    "end": "1692559"
  },
  {
    "text": "so we need to account for all sorts of things like um weird alignments because",
    "start": "1692559",
    "end": "1697679"
  },
  {
    "text": "there are all sorts of weird alignments going on with this new model also",
    "start": "1697679",
    "end": "1703039"
  },
  {
    "text": "we don't necessarily know that all of our sprayed objects will necessarily end",
    "start": "1703039",
    "end": "1709120"
  },
  {
    "text": "up in the same sub-segment even if it's the same sub-segment type we can have",
    "start": "1709120",
    "end": "1715600"
  },
  {
    "text": "four pages of lfh sub-segments then nine pages of v8 are via sub-segment then",
    "start": "1715600",
    "end": "1722480"
  },
  {
    "text": "five pages of another lfh sub segment but of a different size we don't",
    "start": "1722480",
    "end": "1729039"
  },
  {
    "text": "necessarily know that we'll have all of our straight objects",
    "start": "1729039",
    "end": "1734080"
  },
  {
    "text": "immediately one after the other we can't know that the uh pull block we're overflowing",
    "start": "1734080",
    "end": "1741440"
  },
  {
    "text": "is not at the end of a sub segment and will overflow a different uh a different sub segment",
    "start": "1741440",
    "end": "1748720"
  },
  {
    "text": "if uh we're trying to use a buffer overflow we will need to",
    "start": "1748720",
    "end": "1754000"
  },
  {
    "text": "get a buffer overflow in a pull block that is the same size as",
    "start": "1754000",
    "end": "1759120"
  },
  {
    "text": "the blocks were sprayed otherwise they could end up in different sub segments even if they're both lfh sizes they will",
    "start": "1759120",
    "end": "1766000"
  },
  {
    "text": "end up in different lfh sub segments if we're going to overflow a block in a vs sub segment",
    "start": "1766000",
    "end": "1772240"
  },
  {
    "text": "then we're going to overflow the next vs chunk header that isn't encoded and if",
    "start": "1772240",
    "end": "1777440"
  },
  {
    "text": "we don't fake it correctly then when the kernel tries to handle it it will decode it and will most likely just crash",
    "start": "1777440",
    "end": "1785360"
  },
  {
    "text": "in one way or another and faking it is really hard because to",
    "start": "1785360",
    "end": "1790399"
  },
  {
    "text": "encode it properly we need all we need like two or three different information",
    "start": "1790399",
    "end": "1795679"
  },
  {
    "text": "disclosures that are very non-trivial anymore so",
    "start": "1795679",
    "end": "1801120"
  },
  {
    "text": "it doesn't make it impossible but it doesn't make it a lot harder than this used to be",
    "start": "1801120",
    "end": "1808480"
  },
  {
    "start": "1807000",
    "end": "1861000"
  },
  {
    "text": "that's one thing um and we also have all the different",
    "start": "1808480",
    "end": "1813760"
  },
  {
    "text": "mitigations that were added before this change such as the new allocation api that zeroes out",
    "start": "1813760",
    "end": "1820240"
  },
  {
    "text": "allocations once they're made meaning it removes a lot of the information like",
    "start": "1820240",
    "end": "1827760"
  },
  {
    "text": "information links that used to exist and now and we need way more information links to for example in code and fake",
    "start": "1827760",
    "end": "1835840"
  },
  {
    "text": "pull headers or decode pool headers if we can read them that makes it even harder",
    "start": "1835840",
    "end": "1842480"
  },
  {
    "text": "another thing is there used to be a lot of pool overflows of buffer overflow techniques in the",
    "start": "1842480",
    "end": "1848720"
  },
  {
    "text": "pool that took advantage of object headers and corrupting them a lot of these things",
    "start": "1848720",
    "end": "1855200"
  },
  {
    "text": "were mitigated too in the last few years making this also a little bit harder",
    "start": "1855200",
    "end": "1862399"
  },
  {
    "start": "1861000",
    "end": "2016000"
  },
  {
    "text": "but it isn't all that bad um because there are still some benefits",
    "start": "1863600",
    "end": "1869679"
  },
  {
    "text": "too one of them which is pretty cool and was discovered by alex inesco when we",
    "start": "1869679",
    "end": "1875760"
  },
  {
    "text": "initially researched the new pool design is that one of the kernel pools that",
    "start": "1875760",
    "end": "1882640"
  },
  {
    "text": "used to exist and now isn't um isn't used all that much anymore is",
    "start": "1882640",
    "end": "1888720"
  },
  {
    "text": "the executable non-paged pool because up until windows 8",
    "start": "1888720",
    "end": "1895120"
  },
  {
    "text": "the [Music] or windows 7 i think the default non-paged pool was executable for all",
    "start": "1895120",
    "end": "1902080"
  },
  {
    "text": "sorts of historical reasons and since then things changed the",
    "start": "1902080",
    "end": "1908080"
  },
  {
    "text": "default non-page pool is now uh non-executable non-page pool nx",
    "start": "1908080",
    "end": "1914000"
  },
  {
    "text": "but a non-page pool still exists sort of in most most systems it's not used anymore but",
    "start": "1914000",
    "end": "1922000"
  },
  {
    "text": "since the pool type still exists uh there is still a segment heap for it",
    "start": "1922000",
    "end": "1927919"
  },
  {
    "text": "and because there is a segment heap for it we need to have at least one page of executable non-paged pool to allocate",
    "start": "1927919",
    "end": "1935440"
  },
  {
    "text": "the segment heap in so if you know where to find it there is still one read write execute page in the",
    "start": "1935440",
    "end": "1942880"
  },
  {
    "text": "kernel now yes there is a segment heap structure there that you don't really want to",
    "start": "1942880",
    "end": "1950080"
  },
  {
    "text": "corrupt but that structure with all the different nested structures in it takes about half a page around 800 hex bytes",
    "start": "1950080",
    "end": "1959039"
  },
  {
    "text": "that leaves you with about half a page of read write execute memory in the kernel",
    "start": "1959039",
    "end": "1966080"
  },
  {
    "text": "even if no one uses any regular non-page to pull memory at all",
    "start": "1966080",
    "end": "1972159"
  },
  {
    "text": "so that's a nice little place for your kernel shell code if you have an arbitrary right vulnerability",
    "start": "1972159",
    "end": "1978640"
  },
  {
    "text": "and manage to find that page it's a nice place to drop your shell code",
    "start": "1978640",
    "end": "1984320"
  },
  {
    "text": "of course that doesn't work with hvci because with hvci the executable non-page pool doesn't exist anymore but",
    "start": "1984320",
    "end": "1991600"
  },
  {
    "text": "very very very few systems use hvci so that's still a pretty cool trick",
    "start": "1991600",
    "end": "1998000"
  },
  {
    "text": "um and here's proof i use this uh windbag command to find the",
    "start": "1998240",
    "end": "2004320"
  },
  {
    "text": "executable non-paged pool dumped its pte and we can see that i actually have a",
    "start": "2004320",
    "end": "2010000"
  },
  {
    "text": "page of read write execute memory on my system which i think is very cool",
    "start": "2010000",
    "end": "2016799"
  },
  {
    "start": "2016000",
    "end": "2179000"
  },
  {
    "text": "another thing is the secure pool because now with hyper-v we have the secure",
    "start": "2016960",
    "end": "2023200"
  },
  {
    "text": "kernel that is completely protected from normal kernel uh regular kernel code can't access it and one of the things",
    "start": "2023200",
    "end": "2030559"
  },
  {
    "text": "that we got there is the secure pool it's a pool that is read write",
    "start": "2030559",
    "end": "2036799"
  },
  {
    "text": "in vtl1 in the secure kernel and read only for normal kernel code and its",
    "start": "2036799",
    "end": "2043679"
  },
  {
    "text": "purpose is to let third party drivers allocate memory that they don't want",
    "start": "2043679",
    "end": "2049040"
  },
  {
    "text": "anyone to be able to override to avoid data corruption attacks",
    "start": "2049040",
    "end": "2054398"
  },
  {
    "text": "and since all pools now use the same design that means the secure pool uses",
    "start": "2054399",
    "end": "2059839"
  },
  {
    "text": "that design too and another thing that alex discovered",
    "start": "2059839",
    "end": "2064878"
  },
  {
    "text": "in that research is that the secure pool",
    "start": "2064879",
    "end": "2069919"
  },
  {
    "text": "it has a read-only mapping for the normal kernel to read and that read-only mapping",
    "start": "2069919",
    "end": "2076320"
  },
  {
    "text": "contained the whole pool including the segment heap structure on the first",
    "start": "2076320",
    "end": "2082320"
  },
  {
    "text": "page and what we know about the segment heap is it has all sorts of pointers and",
    "start": "2082320",
    "end": "2088398"
  },
  {
    "text": "because it was a mapping of vtl1 that has a different address space that should not be",
    "start": "2088399",
    "end": "2095200"
  },
  {
    "text": "exposed to the normal kernel it should be aslod",
    "start": "2095200",
    "end": "2101040"
  },
  {
    "text": "having that structure mapped into vtl0 into the normal kernel linked all sorts",
    "start": "2101520",
    "end": "2106640"
  },
  {
    "text": "of different addresses and the most interesting ones were the callbacks in",
    "start": "2106640",
    "end": "2112240"
  },
  {
    "text": "the vs and lph context because these callbacks point to",
    "start": "2112240",
    "end": "2117680"
  },
  {
    "text": "uh kernel functions to that are used to allocate free etc",
    "start": "2117680",
    "end": "2123599"
  },
  {
    "text": "lfh and vs blocks and for the secure in the secure pool",
    "start": "2123599",
    "end": "2129520"
  },
  {
    "text": "these pointed two addresses of functions in the secure kernel that should not be available to normal kernel",
    "start": "2129520",
    "end": "2136400"
  },
  {
    "text": "now since alex um discovered and reported that this was fixed the",
    "start": "2136400",
    "end": "2142240"
  },
  {
    "text": "segment heath is not mapped into the normal kernel anymore so you can't use that but there are still a few",
    "start": "2142240",
    "end": "2149040"
  },
  {
    "text": "um address leaks there using other structures such as the heap page segment",
    "start": "2149040",
    "end": "2154800"
  },
  {
    "text": "that leaks the addresses of the secure pool itself and addresses of the",
    "start": "2154800",
    "end": "2160000"
  },
  {
    "text": "metadata heap where the segment heap is now allocated so not as critical as",
    "start": "2160000",
    "end": "2167200"
  },
  {
    "text": "leaking the address to the secure pool but still some vtl1 to vtl0 address leaks that might be useful to someone at",
    "start": "2167200",
    "end": "2174160"
  },
  {
    "text": "some point and those aren't patched as of today",
    "start": "2174160",
    "end": "2180079"
  },
  {
    "start": "2179000",
    "end": "2297000"
  },
  {
    "text": "now before i finish the talk i want to show a few interesting tools that you can use to",
    "start": "2180640",
    "end": "2187599"
  },
  {
    "text": "analyze the pool if you're using wind bag you can use bank pool it was broken",
    "start": "2187599",
    "end": "2192880"
  },
  {
    "text": "for a while now it's back it works in about 98 of cases still a little bit slow but it",
    "start": "2192880",
    "end": "2199599"
  },
  {
    "text": "does work i also wrote a pull extension that works similarly to bank pool it's",
    "start": "2199599",
    "end": "2206320"
  },
  {
    "text": "a lot faster and has a few other cool features that i'll release after the talk and the coolest one is",
    "start": "2206320",
    "end": "2213599"
  },
  {
    "text": "a gui tool called pool viewer that i wrote that looks like",
    "start": "2213599",
    "end": "2219520"
  },
  {
    "text": "this i already loaded the dump in it of the current machine just i preloaded it",
    "start": "2219520",
    "end": "2225599"
  },
  {
    "text": "because it's a little bit slow and you can use it to view",
    "start": "2225599",
    "end": "2231440"
  },
  {
    "text": "general ma general data about your pools what heaps you have what types how many",
    "start": "2231440",
    "end": "2237280"
  },
  {
    "text": "blocks some call statistics like the common pool tags including empty pool tag",
    "start": "2237280",
    "end": "2244160"
  },
  {
    "text": "and how many blocks you have of each type unsurprisingly the most common one is",
    "start": "2244160",
    "end": "2249839"
  },
  {
    "text": "lfh and if you want you can go to the second tab and view blocks individually you can",
    "start": "2249839",
    "end": "2257760"
  },
  {
    "text": "filter them based on whatever it is that you want to filter and use that as the beginning",
    "start": "2257760",
    "end": "2264960"
  },
  {
    "text": "as either investigating your pool or looking into specific addresses",
    "start": "2264960",
    "end": "2271119"
  },
  {
    "text": "trying to find all sorts of um weird or interesting information it knows how to open an existing dump",
    "start": "2271119",
    "end": "2277920"
  },
  {
    "text": "file or if it's running as an admin you can analyze your live machine which just create a dump of your",
    "start": "2277920",
    "end": "2284640"
  },
  {
    "text": "current machine and opens it or you can export all your cool blocks to uh csv and run whatever data analysis",
    "start": "2284640",
    "end": "2293359"
  },
  {
    "text": "tools you have on them so",
    "start": "2293359",
    "end": "2299119"
  },
  {
    "start": "2297000",
    "end": "2346000"
  },
  {
    "text": "uh that's it for now of course there are a lot there is a lot more to do here for example there is a very very very cool",
    "start": "2299119",
    "end": "2305440"
  },
  {
    "text": "research done by a few people from synactiv showing",
    "start": "2305440",
    "end": "2310480"
  },
  {
    "text": "specific showing new exploitation techniques um using this new pool design uh there",
    "start": "2310480",
    "end": "2318720"
  },
  {
    "text": "will be more research in the future i hope and there is a lot more to discover and do",
    "start": "2318720",
    "end": "2324000"
  },
  {
    "text": "in this context and for anything that you want i'm available for questions here",
    "start": "2324000",
    "end": "2329680"
  },
  {
    "text": "on twitter on email or on any platform uh where you managed to find me so thank",
    "start": "2329680",
    "end": "2335520"
  },
  {
    "text": "you for coming to my talk and i hope you uh and i hope you learned something about the windows pool and exploiting it",
    "start": "2335520",
    "end": "2342800"
  },
  {
    "text": "thank you",
    "start": "2342800",
    "end": "2346040"
  }
]