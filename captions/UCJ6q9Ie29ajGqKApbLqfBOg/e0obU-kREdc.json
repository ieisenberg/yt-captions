[
  {
    "start": "0",
    "end": "80000"
  },
  {
    "text": "[Music]",
    "start": "1130",
    "end": "13759"
  },
  {
    "text": "hi everyone i'm matthew and today saba and i are going to be telling you about deep reach which is an attack that we",
    "start": "13759",
    "end": "18880"
  },
  {
    "text": "developed against databases encryption is one of the most important",
    "start": "18880",
    "end": "24880"
  },
  {
    "text": "tools for protecting sensitive data both at rest and in transit additionally compression is often",
    "start": "24880",
    "end": "30640"
  },
  {
    "text": "carried paired with encryption in order to save on storage costs however combining the two can be risky",
    "start": "30640",
    "end": "36880"
  },
  {
    "text": "and sometimes leak the underlying plain text information this class of vulnerabilities is known",
    "start": "36880",
    "end": "42079"
  },
  {
    "text": "as a compression side channel one context in which encryption and",
    "start": "42079",
    "end": "47280"
  },
  {
    "text": "compression are commonly combined is in databases which brings us to our attack debreach",
    "start": "47280",
    "end": "53120"
  },
  {
    "text": "in debreach an attacker is able to recover other uses and users encrypted content by utilizing a compression psi",
    "start": "53120",
    "end": "59680"
  },
  {
    "text": "channel we were able to extend on techniques and the name of the crime and breach attacks",
    "start": "59680",
    "end": "66560"
  },
  {
    "text": "beyond the web security context and to the database context and debreach is",
    "start": "66560",
    "end": "72400"
  },
  {
    "text": "we believe the first compression side channel attack on a real world database system",
    "start": "72400",
    "end": "79600"
  },
  {
    "start": "80000",
    "end": "80000"
  },
  {
    "text": "just a quick roadmap of what we're going to talk about today so saba is going to walk you through some background on",
    "start": "81280",
    "end": "87759"
  },
  {
    "text": "encryption and compression and databases and side channel tasks in general then i'm going to tell you about how our",
    "start": "87759",
    "end": "93119"
  },
  {
    "text": "attack works some of the implementation roadblocks and solutions that we came up with",
    "start": "93119",
    "end": "99680"
  },
  {
    "text": "i'm going to talk about how efficient and accurate we were able to make our attack and then finally i'm going to discuss",
    "start": "99680",
    "end": "104799"
  },
  {
    "text": "some possible mitigation so that you uh you will be able to avoid this attack or",
    "start": "104799",
    "end": "110320"
  },
  {
    "text": "similar attacks on your own systems and now i'm going to hand it over to sabo to give you some necessary",
    "start": "110320",
    "end": "116159"
  },
  {
    "text": "background information all right thanks matthew so let's start out by",
    "start": "116159",
    "end": "121520"
  },
  {
    "text": "um talking about what we mean when we say an encryption scheme is secure so when we say encryption is secure informally we're saying that a cipher",
    "start": "121520",
    "end": "127520"
  },
  {
    "text": "text reveals nothing about the message that's being encrypted except the message's length and this",
    "start": "127520",
    "end": "134000"
  },
  {
    "start": "129000",
    "end": "129000"
  },
  {
    "text": "accept the message's length is the piece that kind of allows compression side channel attacks to happen so what a",
    "start": "134000",
    "end": "139200"
  },
  {
    "text": "compression side channel is going to do the key idea is to use compression to reveal messages length",
    "start": "139200",
    "end": "145520"
  },
  {
    "text": "and then by looking at length information we're able to learn something about the message contents and that's where the compression side",
    "start": "145520",
    "end": "151040"
  },
  {
    "text": "channel comes from so messages that compress more are shorter messages that compress less are larger and if you can",
    "start": "151040",
    "end": "159120"
  },
  {
    "text": "set it so that learning something about the message length tells you about the the message content then you have a",
    "start": "159120",
    "end": "164319"
  },
  {
    "text": "compression side channel so compression side channels have famously been used in the crime and",
    "start": "164319",
    "end": "169599"
  },
  {
    "start": "166000",
    "end": "166000"
  },
  {
    "text": "breach attacks to break tls and i'm going to give a very very high level",
    "start": "169599",
    "end": "174640"
  },
  {
    "text": "overview of the intuition behind these attacks just so we can draw some lessons on how compression side channels can be used",
    "start": "174640",
    "end": "180400"
  },
  {
    "text": "so the setting here is we have a client and a server who have a compressed and encrypted channel between the two of",
    "start": "180400",
    "end": "186400"
  },
  {
    "text": "them over which they send secret information that they that they want to send to each other",
    "start": "186400",
    "end": "191920"
  },
  {
    "text": "and there's an attacker who wants to learn the secrets that they're communicating with each other so what the attacker has to be able to",
    "start": "191920",
    "end": "198560"
  },
  {
    "text": "do to make this attack work is the attacker has a guess as to what the secrets might be and the attacker gets the client to",
    "start": "198560",
    "end": "204720"
  },
  {
    "text": "include its guess in the messages that it sends to the server so for example the attacker could be the client might",
    "start": "204720",
    "end": "210000"
  },
  {
    "text": "navigate to a web page that has some malicious javascript and the javascript gets the gets the client to send the",
    "start": "210000",
    "end": "215280"
  },
  {
    "text": "attacker's guests as part of the messages that are sent over the secure channel so now the messages between the",
    "start": "215280",
    "end": "220480"
  },
  {
    "text": "client and the server will include not only the secrets that they're sending back and forth but also the guests that the attacker has as to what the secrets",
    "start": "220480",
    "end": "226640"
  },
  {
    "text": "might be the final step of the attack is for the adversary to be able to observe the size",
    "start": "226640",
    "end": "232640"
  },
  {
    "text": "of the encrypted messages that are going back and forth between the server and the client and the idea is that the",
    "start": "232640",
    "end": "237840"
  },
  {
    "text": "adversary is looking to see if the if the guest kind of compresses with the secrets so if the guess is correct and",
    "start": "237840",
    "end": "242959"
  },
  {
    "text": "it's exactly the same as the secrets that are being sent back and forth these things will compress together and the message won't get that big so the",
    "start": "242959",
    "end": "249680"
  },
  {
    "text": "adversary will know that it has a correct guess on the other hand if the guess and the secret don't compress with",
    "start": "249680",
    "end": "254720"
  },
  {
    "text": "each other if they're just different things that are not compressible together then the attacker knows that it gets wrong and they can guess something",
    "start": "254720",
    "end": "260479"
  },
  {
    "text": "else and it can do this iteratively until it gets the secrets right so let's zoom out and think about what the what is required to make an attack",
    "start": "260479",
    "end": "267280"
  },
  {
    "text": "like this work so the first requirement is that encryption and compression have to be used together here",
    "start": "267280",
    "end": "273520"
  },
  {
    "text": "and of course this is happening and it's important that encryption always comes after compression because if you",
    "start": "273520",
    "end": "280400"
  },
  {
    "text": "compress before you encrypt then you get the compression and then you encrypt but if you uh do it the other way around",
    "start": "280400",
    "end": "285759"
  },
  {
    "text": "then the encryption is going to make the messages look kind of random and random strings are incompressible so the",
    "start": "285759",
    "end": "290960"
  },
  {
    "text": "compressor won't do anything for you so if you want to use encryption and compression together compression always has to come first",
    "start": "290960",
    "end": "296560"
  },
  {
    "text": "that's the first requirement next requirement is the attacker is somehow able to inject messages into",
    "start": "296560",
    "end": "302639"
  },
  {
    "text": "this compressed and encrypted channel between the client and the server and the third requirement is that the",
    "start": "302639",
    "end": "308320"
  },
  {
    "text": "attacker has to have access to the size of the messages that are going back between these parties and the question we want to answer in",
    "start": "308320",
    "end": "314320"
  },
  {
    "text": "this work is where else do all these factors come together and uh from the title and from math's",
    "start": "314320",
    "end": "320400"
  },
  {
    "text": "introduction you know that databases are a place where all of these factors are going to come together",
    "start": "320400",
    "end": "326400"
  },
  {
    "start": "324000",
    "end": "324000"
  },
  {
    "text": "so i'm going to give now some background on how encryption and compression work in mariadb and the nodb storage engine",
    "start": "326400",
    "end": "333600"
  },
  {
    "text": "just because these are this is what we use to instantiate our attack although the attack in general can apply to many",
    "start": "333600",
    "end": "340080"
  },
  {
    "text": "different dbmss and different storage engines so mariadb offers what's called data at",
    "start": "340080",
    "end": "345600"
  },
  {
    "text": "rest encryption which is a feature that transparently encrypts data before writing to disk so it has a bunch of",
    "start": "345600",
    "end": "350880"
  },
  {
    "text": "different offers for key management but ultimately what happens is whatever storage your engine you're using uh does",
    "start": "350880",
    "end": "356639"
  },
  {
    "text": "its management of the tables in the database and then when it's time to write those tables to disk there is a transparent encryption step that happens",
    "start": "356639",
    "end": "363520"
  },
  {
    "text": "just before the right to disk takes place easy enough also murray to be offers many options",
    "start": "363520",
    "end": "370080"
  },
  {
    "text": "for compression which as i mentioned before always happens before the encryption so one is",
    "start": "370080",
    "end": "375199"
  },
  {
    "text": "called storage engine independent compression this is a mariadb feature that uh kind of compresses the contents",
    "start": "375199",
    "end": "381840"
  },
  {
    "text": "of each cell within a table this is good if you're if you have a database table that has like large strings or large",
    "start": "381840",
    "end": "387680"
  },
  {
    "text": "blobs of text that you're putting into it and you just want to compress those things but it doesn't do any compression",
    "start": "387680",
    "end": "392720"
  },
  {
    "text": "between different parts of a table so between different rows or different columns um then there is inno db's compression",
    "start": "392720",
    "end": "400160"
  },
  {
    "text": "features which do allow this so innodb has table compression and transparent page compression which are two different",
    "start": "400160",
    "end": "406400"
  },
  {
    "text": "compression offerings and i'm going to focus on the transparent page compression because it's the more recent one it has some performance benefits",
    "start": "406400",
    "end": "413199"
  },
  {
    "text": "over the table compression it's also simpler and it's going to be the one that we're going to use in our attack",
    "start": "413199",
    "end": "418400"
  },
  {
    "text": "so how does energy's page compression work well it handles compression transparently before encrypting and",
    "start": "418400",
    "end": "424240"
  },
  {
    "start": "419000",
    "end": "419000"
  },
  {
    "text": "writing to disk so just like the encryption was transparent just before the write to disk the compression is going to transparently happen on the",
    "start": "424240",
    "end": "430639"
  },
  {
    "text": "table before that table is encrypted and written to disk so how does this work the compression is",
    "start": "430639",
    "end": "436720"
  },
  {
    "text": "going to compress the data within each database page so in the nodb storage engine um each",
    "start": "436720",
    "end": "443759"
  },
  {
    "text": "table is broken up into 16 kilobyte pages and the compression feature is going to",
    "start": "443759",
    "end": "449360"
  },
  {
    "text": "compress each of these pages separately before writing them to disk or before encrypting them and then writing them to",
    "start": "449360",
    "end": "454880"
  },
  {
    "text": "disk so as you can see on the slide there's going to be some kind of empty space",
    "start": "454880",
    "end": "460479"
  },
  {
    "text": "after each compressed page before the next page begins and what the file system is going to do",
    "start": "460479",
    "end": "466479"
  },
  {
    "text": "is it's going to use a feature called hole punching to reclaim this empty space and use it for other stuff",
    "start": "466479",
    "end": "472560"
  },
  {
    "text": "so what hole punching allows the file to do is if there's a file that's sparse and it has a big gap in it",
    "start": "472560",
    "end": "477680"
  },
  {
    "text": "it can do a hole punch in the file and take that punch away and the hole punch has to be in a multiple of four",
    "start": "477680",
    "end": "483280"
  },
  {
    "text": "kilobytes because the file system page is typically going to be four kilobytes and the hole punching kind of applies to whole pages at a time so if you have a",
    "start": "483280",
    "end": "490560"
  },
  {
    "text": "little bit of extra compression beyond the one page mark or if the page if a database page doesn't compress",
    "start": "490560",
    "end": "496639"
  },
  {
    "text": "enough to result in saving an entire file system page then there isn't going to be a hole punch",
    "start": "496639",
    "end": "501840"
  },
  {
    "text": "and what this means is that uh this compression feature only helps when",
    "start": "501840",
    "end": "506879"
  },
  {
    "text": "there's enough compression to remove a whole file system page otherwise you don't get the compression",
    "start": "506879",
    "end": "513039"
  },
  {
    "text": "and this is important for our attack because it affects the granularity of information that an attacker can get about how much compression is happening",
    "start": "513039",
    "end": "520399"
  },
  {
    "text": "in the database table so in terms of the actual compression algorithms that are being used um page",
    "start": "520399",
    "end": "527120"
  },
  {
    "start": "523000",
    "end": "523000"
  },
  {
    "text": "compression supports a number of different algorithms but only zlib lz4 and snappy",
    "start": "527120",
    "end": "533200"
  },
  {
    "text": "are installed by default in a standard ubuntu build and all three of these have a similar",
    "start": "533200",
    "end": "538399"
  },
  {
    "text": "structure they begin with a sliding window compression where there's a sliding window that begins at the beginning of the page of the database",
    "start": "538399",
    "end": "545600"
  },
  {
    "text": "page and whenever it finds a duplicate of a string that has occurred earlier in the window it'll remove the second",
    "start": "545600",
    "end": "551600"
  },
  {
    "text": "instance of the string and replace it with a reference back to the first instance of the string what this means",
    "start": "551600",
    "end": "556959"
  },
  {
    "text": "is the second instance of the string doesn't need to appear in the file anymore and that makes the file smaller allowing it to be compressed",
    "start": "556959",
    "end": "564000"
  },
  {
    "text": "zlib has an additional step that's not present in the other two and this is a huffman coding step where at the end",
    "start": "564000",
    "end": "569600"
  },
  {
    "text": "after doing the sliding window compression it compresses more frequently occurring strings by giving",
    "start": "569600",
    "end": "575040"
  },
  {
    "text": "them shorter representations and this is something that matthew will talk about later that kind of has some",
    "start": "575040",
    "end": "580399"
  },
  {
    "text": "complications for when it comes to making an attack on these things so with that background matthew's now",
    "start": "580399",
    "end": "586240"
  },
  {
    "text": "gonna tell us about our actual attack",
    "start": "586240",
    "end": "591000"
  },
  {
    "text": "thanks saba so first i want to talk a little bit about the threat model or the",
    "start": "592240",
    "end": "597279"
  },
  {
    "start": "595000",
    "end": "595000"
  },
  {
    "text": "capabilities that an attacker needs to achieve in order to pull off the attack first of all an attacker needs the",
    "start": "597279",
    "end": "602880"
  },
  {
    "text": "ability to insert and update into a database table also an attacker needs to be able to",
    "start": "602880",
    "end": "608160"
  },
  {
    "text": "assess the size of the compressed table note that these two requirements mirror the requirements for the breach and",
    "start": "608160",
    "end": "613839"
  },
  {
    "text": "crime attacks that saba talked about earlier we believe that this threat model is",
    "start": "613839",
    "end": "618959"
  },
  {
    "text": "realistic and achievable and here's how insert and update capability can be",
    "start": "618959",
    "end": "624480"
  },
  {
    "text": "achieved through a front-end web interface that's backed up by a database table",
    "start": "624480",
    "end": "629519"
  },
  {
    "text": "something that's really common in a lot of databases for example if the table was account metadata the web interface",
    "start": "629519",
    "end": "636560"
  },
  {
    "text": "could be your edit profile or create profile page",
    "start": "636560",
    "end": "641600"
  },
  {
    "text": "additionally mariadb provides these things called column level permissions which",
    "start": "641600",
    "end": "647120"
  },
  {
    "text": "can grant partial selectability on only certain columns and using this partial selectability an",
    "start": "647120",
    "end": "653839"
  },
  {
    "text": "attacker can be can gain update ability on the entire table as long as they only read those columns",
    "start": "653839",
    "end": "660399"
  },
  {
    "text": "while they're doing the updates so uh it would kind of be a coincidence for",
    "start": "660399",
    "end": "665760"
  },
  {
    "text": "the permissions to be set up that way but it is possible for the database permissions to just be set up in such a way that you have insert and update",
    "start": "665760",
    "end": "671920"
  },
  {
    "text": "capability but you can't read the whole table additionally to be able to assess the",
    "start": "671920",
    "end": "677600"
  },
  {
    "text": "size of the compressed table an attacker can read the size of the table file file if they can gain read access to the file",
    "start": "677600",
    "end": "684160"
  },
  {
    "text": "system so they need to gain some sort of read access but once they do they can just use a",
    "start": "684160",
    "end": "689360"
  },
  {
    "text": "tool like ls to see how big the table space file is",
    "start": "689360",
    "end": "694880"
  },
  {
    "text": "an attacker could also monitor network packets if if database backups were happening and",
    "start": "695519",
    "end": "702720"
  },
  {
    "text": "see how big those were are but um that's probably more complicated and not as",
    "start": "702720",
    "end": "707839"
  },
  {
    "text": "easy as just getting read access to the file system in most cases one final thing to note is that if an",
    "start": "707839",
    "end": "713839"
  },
  {
    "text": "attacker is not able to achieve update permissions but can get right access on the file",
    "start": "713839",
    "end": "719120"
  },
  {
    "text": "system then they can force an update by rolling back the table file and inserting so this requires more comprehensive file",
    "start": "719120",
    "end": "726399"
  },
  {
    "text": "system access but fewer database permissions and it's just a different means of gaining the necessary",
    "start": "726399",
    "end": "732399"
  },
  {
    "text": "capabilities um that would slow down the attack significantly though because",
    "start": "732399",
    "end": "737839"
  },
  {
    "text": "forcibly rolling back the table is a lot slower than just running one update sql command",
    "start": "737839",
    "end": "745120"
  },
  {
    "start": "745000",
    "end": "745000"
  },
  {
    "text": "now i'm going to talk a little bit about our attack algorithm and on the right here i'm going to keep this diagram of table layout",
    "start": "745120",
    "end": "752320"
  },
  {
    "text": "in which this blue rectangle is one file system page so four kilobytes",
    "start": "752320",
    "end": "757440"
  },
  {
    "text": "initially we just have some plain text that was inserted by other users",
    "start": "757440",
    "end": "762639"
  },
  {
    "text": "that's represented by the green rectangle it could be any any number of rows as long as it fits on this file system page",
    "start": "762639",
    "end": "770800"
  },
  {
    "text": "one thing to remember with this attack is we're only recovering information from the most recent file system page uh",
    "start": "770800",
    "end": "777040"
  },
  {
    "text": "because that's how large the compression window is sorry we are only recovering information",
    "start": "777040",
    "end": "784320"
  },
  {
    "text": "from the most recent database page because that's how large the compression window is",
    "start": "784320",
    "end": "790240"
  },
  {
    "text": "first an attacker is going to add random filler rows until the table grows",
    "start": "792000",
    "end": "797440"
  },
  {
    "text": "these filler rows are just normal rows with the text fields filled with some random",
    "start": "797440",
    "end": "803040"
  },
  {
    "text": "non-compressible text they're going to keep inserting rows until they overflow the file system page",
    "start": "803040",
    "end": "808399"
  },
  {
    "text": "and a new page is added once they overflow the page and a new",
    "start": "808399",
    "end": "814079"
  },
  {
    "text": "one is added they're going to update the first filler row to contain their guess which is represented by that yellow box there",
    "start": "814079",
    "end": "822240"
  },
  {
    "text": "one thing to uh or the key idea here is that if the guess is a repeated string from the",
    "start": "822240",
    "end": "828480"
  },
  {
    "text": "target plain text then some compression will take place and if",
    "start": "828480",
    "end": "833680"
  },
  {
    "text": "it's not then no compression will take place the attacker then wants to figure out",
    "start": "833680",
    "end": "839680"
  },
  {
    "text": "how compressive how much the gas compressed with the plain text and to do so they're going to bite by bite make",
    "start": "839680",
    "end": "845839"
  },
  {
    "text": "the filler rows compressible this takes the form in practice of just switching the text",
    "start": "845839",
    "end": "852800"
  },
  {
    "text": "in the filler rows to all be the same character from whatever random filler",
    "start": "852800",
    "end": "858079"
  },
  {
    "text": "they were before so the attacker goes by by making them compressible until",
    "start": "858079",
    "end": "863120"
  },
  {
    "text": "eventually the whole table will have compressed enough such that it fits back on the old file system page and a hold",
    "start": "863120",
    "end": "870560"
  },
  {
    "text": "punch will take place as sava talked about earlier so that whole bunch will happen the",
    "start": "870560",
    "end": "875839"
  },
  {
    "text": "table will shrink and the number of bytes until the table shrinks is going to be what determines",
    "start": "875839",
    "end": "881120"
  },
  {
    "text": "this guess's compressibility score and that's what we're going to use to compare guesses against each other",
    "start": "881120",
    "end": "887839"
  },
  {
    "text": "the key idea behind compressibility scores is just that a guess that results in a more compressible table layout",
    "start": "887839",
    "end": "893360"
  },
  {
    "start": "888000",
    "end": "888000"
  },
  {
    "text": "because it is repeated from the target plaintext should have a higher compressibility score",
    "start": "893360",
    "end": "900319"
  },
  {
    "text": "we're going to calculate it uh by defining this term bg for guess g which is the number of bytes",
    "start": "900560",
    "end": "907519"
  },
  {
    "text": "that we made compressible in order to shrink the table that's represented by the gray portion in this table layout diagram",
    "start": "907519",
    "end": "913440"
  },
  {
    "text": "we're then just going to say that the compressibility score cg is 1 over bg so therefore if a guess was very",
    "start": "913440",
    "end": "920160"
  },
  {
    "text": "compressible with the target plaintext it would take fewer bytes in order to it would take uh switching fewer bytes in",
    "start": "920160",
    "end": "926720"
  },
  {
    "text": "order to compress the table or shrink the table and therefore",
    "start": "926720",
    "end": "932160"
  },
  {
    "text": "uh the compressibility score will be higher whereas if a guess did not compress the target plaintext it will take",
    "start": "932160",
    "end": "938399"
  },
  {
    "text": "more bytes and therefore the compressibility score will be lower",
    "start": "938399",
    "end": "944399"
  },
  {
    "text": "so the aforementioned algorithm kind of lends itself very nicely to two main",
    "start": "945120",
    "end": "951040"
  },
  {
    "text": "attack varieties the first one is the k of n attack which is given n options",
    "start": "951040",
    "end": "957279"
  },
  {
    "text": "which k are most likely to be in the table and implementing this uh given the prior",
    "start": "957279",
    "end": "963680"
  },
  {
    "text": "algorithm is is pretty simple it's just we run that algorithm on all n of the guesses and we pick the k guesses with",
    "start": "963680",
    "end": "969680"
  },
  {
    "text": "the highest compressibility scores um so now that you have some algorithmic",
    "start": "969680",
    "end": "974880"
  },
  {
    "text": "background i'm going to pause from the presentation briefly and and start a little demo so you can see the kvn",
    "start": "974880",
    "end": "980560"
  },
  {
    "text": "attack in action so i have here a list of 500 names that",
    "start": "980560",
    "end": "988320"
  },
  {
    "text": "were just randomly generated from commonly used names in the us",
    "start": "988320",
    "end": "993920"
  },
  {
    "text": "and i'm going to generate a random number 110. so we're going to take the name at",
    "start": "993920",
    "end": "1000240"
  },
  {
    "text": "index 110 named villanueva",
    "start": "1000240",
    "end": "1006000"
  },
  {
    "text": "and this name is going to be inserted into the table that we're about to set up",
    "start": "1007440",
    "end": "1012560"
  },
  {
    "text": "now i'm going to do some quick table setup",
    "start": "1012560",
    "end": "1016720"
  },
  {
    "text": "make sure that the table is not currently there",
    "start": "1018000",
    "end": "1024279"
  },
  {
    "text": "now going to create a table",
    "start": "1027679",
    "end": "1031839"
  },
  {
    "text": "um so the table in this case is just going to consist of a primary key id",
    "start": "1032880",
    "end": "1038240"
  },
  {
    "text": "which is an integer and a varchar data field which will contain the name",
    "start": "1038240",
    "end": "1043760"
  },
  {
    "text": "um the engine is in adb compression and encryption are both on so we're going to create it",
    "start": "1043760",
    "end": "1049919"
  },
  {
    "text": "we're now going to insert the name that we just randomly chose into the victim table",
    "start": "1049919",
    "end": "1056240"
  },
  {
    "text": "and then finally just going to confirm that that is the only thing in the table right now there you have it there's one row in the",
    "start": "1057039",
    "end": "1063760"
  },
  {
    "text": "table now going to run our attack",
    "start": "1063760",
    "end": "1070320"
  },
  {
    "text": "in order to figure out what we just inserted so",
    "start": "1070320",
    "end": "1076250"
  },
  {
    "text": "[Music] we're going to run this demo it's going to take a second but you're going to see",
    "start": "1076250",
    "end": "1082160"
  },
  {
    "text": "that it's inserting filler rows um it took 29 insertions for the table it's",
    "start": "1082160",
    "end": "1088960"
  },
  {
    "text": "calculating some reference scores i'm going to talk about that in a second and now it's starting to try each guess so",
    "start": "1088960",
    "end": "1094559"
  },
  {
    "text": "the actual act of trying the guesses um takes a couple minutes so",
    "start": "1094559",
    "end": "1099919"
  },
  {
    "text": "i'm going to return to the presentation and we're going to check in later to see how we did",
    "start": "1099919",
    "end": "1105280"
  },
  {
    "text": "in addition to the k of n attack there's another attack that the prior algorithm really lends itself to",
    "start": "1106480",
    "end": "1111600"
  },
  {
    "text": "and that's the decision attack which just asks for a given guess is it in the table yes or no",
    "start": "1111600",
    "end": "1118720"
  },
  {
    "text": "this is decidedly more complicated than the k of n attack mainly because we need a reference point for the",
    "start": "1119039",
    "end": "1124640"
  },
  {
    "text": "compressibility scores we need to know what does the positive case look like and what does the negative case look like what do the",
    "start": "1124640",
    "end": "1130320"
  },
  {
    "text": "scores mean to find these reference points we're going to calculate compressibility scores scs and snow for strings that we",
    "start": "1130320",
    "end": "1136880"
  },
  {
    "start": "1132000",
    "end": "1132000"
  },
  {
    "text": "know are in and not in the table to determine sks what we're going to do is we're going to take a substring from",
    "start": "1136880",
    "end": "1143200"
  },
  {
    "text": "the first filler route that's the same length as the guess and we're going to insert it into the second failure and then we're going to determine the",
    "start": "1143200",
    "end": "1148960"
  },
  {
    "text": "compressibility score of that layout so this is kind of mocking the positive",
    "start": "1148960",
    "end": "1154400"
  },
  {
    "text": "case because we know for a fact that there's a repeated string that we just inserted into the filler data",
    "start": "1154400",
    "end": "1160320"
  },
  {
    "text": "to determine snow we're going to do something very similar but we're going to use a random string instead of a repeated substring",
    "start": "1160320",
    "end": "1166880"
  },
  {
    "text": "the idea here is that the random string is very unlikely to occur elsewhere in the table",
    "start": "1166880",
    "end": "1172559"
  },
  {
    "text": "then with these reference points we're going to say that a guesses score if a guesses score is within some threshold",
    "start": "1172559",
    "end": "1177840"
  },
  {
    "text": "of ses relative to snow we answer yes the reason why we need to do some threshold instead of trying to do an",
    "start": "1177840",
    "end": "1184320"
  },
  {
    "text": "exact match is because as i'm going to talk about in a little bit there are some sources of noise in the side",
    "start": "1184320",
    "end": "1190160"
  },
  {
    "text": "channel that can obscure how uh what the compressibility scores precisely mean",
    "start": "1190160",
    "end": "1197200"
  },
  {
    "start": "1197000",
    "end": "1197000"
  },
  {
    "text": "one final attack that we can build out of our prior algorithm is a character by character",
    "start": "1197600",
    "end": "1202640"
  },
  {
    "text": "extraction attack in which we use a k of n attack as a subroutine to extract the",
    "start": "1202640",
    "end": "1208320"
  },
  {
    "text": "plain text one character at a time um so i'm going to talk through the basic algorithm for this type of attack",
    "start": "1208320",
    "end": "1215679"
  },
  {
    "text": "and then i'm also going to talk about some difficulties that we've encountered and we're currently encountering while implementing this",
    "start": "1215679",
    "end": "1223120"
  },
  {
    "text": "so we start with some known prefix that we strongly believe occurs in the table in this case the secret code is",
    "start": "1223360",
    "end": "1229440"
  },
  {
    "text": "from the prefix we're going to generate n guesses where n is the size of the",
    "start": "1229440",
    "end": "1234559"
  },
  {
    "text": "size of the alphabet of all possible characters so if we're doing all english uppercase",
    "start": "1234559",
    "end": "1240080"
  },
  {
    "text": "and lowercase characters n would be 52 for example these n guesses are going to be fed into",
    "start": "1240080",
    "end": "1246159"
  },
  {
    "text": "a one of n attack sub module which will pick which one option is most likely out of all 52",
    "start": "1246159",
    "end": "1254720"
  },
  {
    "text": "or all n in this case let's say that the first case a is the most likely",
    "start": "1254720",
    "end": "1261120"
  },
  {
    "text": "we're going to take the most likely case and we're going to make it the new prefix from the new prefix we're going to",
    "start": "1261120",
    "end": "1268159"
  },
  {
    "text": "generate a new set of n guesses and repeat over and over until we've extracted the entire plaintext",
    "start": "1268159",
    "end": "1275520"
  },
  {
    "text": "um one thing to note here however is that if you look at these n guesses the",
    "start": "1275520",
    "end": "1281280"
  },
  {
    "text": "correct option and the incorrect option only differ by one character therefore we expect that their",
    "start": "1281280",
    "end": "1286880"
  },
  {
    "text": "compressibility scores will be quite similar and we're a lot more vulnerable to",
    "start": "1286880",
    "end": "1292400"
  },
  {
    "text": "sources of noise in the side channel as such this is still a work in progress and we're working on developing a",
    "start": "1292400",
    "end": "1298559"
  },
  {
    "text": "practical and accurate implementation but we believe that the eventual solution will consist of this basic",
    "start": "1298559",
    "end": "1304480"
  },
  {
    "text": "algorithm now i'm going to talk through some roadblocks that we encountered",
    "start": "1304480",
    "end": "1310159"
  },
  {
    "text": "while uh while implementing our attack and the solutions that we use to overcome them",
    "start": "1310159",
    "end": "1316400"
  },
  {
    "start": "1316000",
    "end": "1316000"
  },
  {
    "text": "one problem that we saw uh repeatedly was what we ended up calling the substring super string problem",
    "start": "1316400",
    "end": "1322880"
  },
  {
    "text": "we saw that we got a much higher rate of false positives when a guess is a substring or a superstring that is what",
    "start": "1322880",
    "end": "1328480"
  },
  {
    "text": "is in the table is a substring of the guess in the substring case we see that",
    "start": "1328480",
    "end": "1333919"
  },
  {
    "text": "the guess can is not an exact match for the plaintext but the ground in the",
    "start": "1333919",
    "end": "1339600"
  },
  {
    "text": "guess will match with the ground truth and the plaintext or sorry the ground from the ground truth in the plaintext",
    "start": "1339600",
    "end": "1346799"
  },
  {
    "text": "and compression will happen so the guess will appear very compressible",
    "start": "1346799",
    "end": "1351919"
  },
  {
    "text": "in the superstring case we see that again the guess has a",
    "start": "1351919",
    "end": "1357120"
  },
  {
    "text": "the guess or much of the guess matches the plaintext and will therefore compress making us vulnerable to false positives",
    "start": "1357120",
    "end": "1364880"
  },
  {
    "text": "one thing to note is the substring case is not really that bad",
    "start": "1364880",
    "end": "1370159"
  },
  {
    "text": "we're still identifying a valid substring that occurs in the table",
    "start": "1370159",
    "end": "1375440"
  },
  {
    "text": "which is the goal of the attack so it's not really a false positive and it really drives from the point the importance of the attacker having a good",
    "start": "1375440",
    "end": "1382240"
  },
  {
    "text": "set of initial guesses the superstring case however is quite bad this is a true false positive the",
    "start": "1382240",
    "end": "1389760"
  },
  {
    "text": "guess occurs nowhere in the table and we would really like to avoid situations like this",
    "start": "1389760",
    "end": "1395520"
  },
  {
    "text": "to address the superstring problem we switched to using the ses snow reference point strategy on all guesses",
    "start": "1395520",
    "end": "1402480"
  },
  {
    "start": "1396000",
    "end": "1396000"
  },
  {
    "text": "now guess this score is determined by how close it is to s relative to s no",
    "start": "1402480",
    "end": "1409200"
  },
  {
    "text": "and then since ses is calculated using a string that's the same length as the gas superstring guesses will only appear",
    "start": "1409200",
    "end": "1415600"
  },
  {
    "text": "partially compressible relative to an exact match so in the prior example ground truth regarding",
    "start": "1415600",
    "end": "1422320"
  },
  {
    "text": "will only appear partially compressible compared to something of that length that was actually a precise",
    "start": "1422320",
    "end": "1428840"
  },
  {
    "text": "match unfortunately we're still slightly vulnerable to false positives if the super string is not much longer than the",
    "start": "1428840",
    "end": "1435200"
  },
  {
    "text": "ground truth because we might be within the threshold of s yes that is necessary",
    "start": "1435200",
    "end": "1440320"
  },
  {
    "text": "to say yes it's in the table so while this is a big improvement",
    "start": "1440320",
    "end": "1446080"
  },
  {
    "text": "in cases such as the character by character extraction tab where the strings only differ by one character we",
    "start": "1446080",
    "end": "1451760"
  },
  {
    "text": "still sometimes fall victim to this superstring problem so as i alluded to a couple times before",
    "start": "1451760",
    "end": "1458640"
  },
  {
    "start": "1456000",
    "end": "1456000"
  },
  {
    "text": "we also encountered various sources of noise in the side channel that obscured the signal",
    "start": "1458640",
    "end": "1464159"
  },
  {
    "text": "the first source of noise that we saw was from huffman and gooding and",
    "start": "1464159",
    "end": "1470000"
  },
  {
    "text": "this is uh is utilized in the lzip compression algorithm so in huffman encoding",
    "start": "1470000",
    "end": "1476480"
  },
  {
    "text": "the precise ratio of characters relative to other characters can change how compressive can change",
    "start": "1476480",
    "end": "1483840"
  },
  {
    "text": "how compressible the table is even if the guess is not compressing with",
    "start": "1483840",
    "end": "1489039"
  },
  {
    "text": "the target plain text and since when we're inserting guesses we are changing this ratio slightly this introduces some",
    "start": "1489039",
    "end": "1496000"
  },
  {
    "text": "source of noise luckily this typically does not overwhelm the signal in the k of n or decision attacks",
    "start": "1496000",
    "end": "1503440"
  },
  {
    "text": "because the compression of the guess is so much greater than the minor changes due to huffman coding however it poses a",
    "start": "1503440",
    "end": "1510320"
  },
  {
    "text": "pretty serious problem for the character by character extraction attack in which",
    "start": "1510320",
    "end": "1515520"
  },
  {
    "text": "we're only changing one character at a time so the signal is weaker",
    "start": "1515520",
    "end": "1521200"
  },
  {
    "text": "we're continuing to address this problem and um the breach paper holds some useful hints",
    "start": "1521600",
    "end": "1527520"
  },
  {
    "text": "that i won't have the time to talk about today but we think that they'll come in handy as we continue to implement the",
    "start": "1527520",
    "end": "1533440"
  },
  {
    "text": "character by character extraction attack another source of noise was compression with irrelevant parts of the tablespace",
    "start": "1533440",
    "end": "1539840"
  },
  {
    "text": "file such as metadata or our own filler rows so if the guess compresses with these it'll have a high compressibility score",
    "start": "1539840",
    "end": "1546320"
  },
  {
    "text": "even though it doesn't match the target plain text a solution here is to randomly choose the filler data from some disjoint",
    "start": "1546320",
    "end": "1553120"
  },
  {
    "text": "alphabet that we believe will not occur anywhere else in the table this prevents compression with our own",
    "start": "1553120",
    "end": "1559840"
  },
  {
    "text": "filler data and managed to mostly eliminate this source of noise in the side channel because it appears that",
    "start": "1559840",
    "end": "1565200"
  },
  {
    "text": "compression with metadata is relatively unlikely additionally",
    "start": "1565200",
    "end": "1571360"
  },
  {
    "text": "we we saw some we occasionally saw compression within the guess itself uh for example if a guess contains many",
    "start": "1571360",
    "end": "1578400"
  },
  {
    "text": "repeated substrings it'll shrink because it's compressing within itself it'll appear very compressible even though it",
    "start": "1578400",
    "end": "1584320"
  },
  {
    "text": "doesn't match anything in the target plaintext solution here is to penalize the",
    "start": "1584320",
    "end": "1589760"
  },
  {
    "text": "internally compressible guesses one way to do so is to break ties based",
    "start": "1589760",
    "end": "1594960"
  },
  {
    "text": "on what is more or less internally compressible or we could actually decrease the compressibility scores of",
    "start": "1594960",
    "end": "1600159"
  },
  {
    "text": "very internally compressible guesses the necessity of this solution kind of",
    "start": "1600159",
    "end": "1606000"
  },
  {
    "text": "depends on the format of the guesses and can be toggled on and off as needed by the attacker",
    "start": "1606000",
    "end": "1612159"
  },
  {
    "text": "finally lots of deletions and updates can lead to a fragmented table space which can",
    "start": "1612159",
    "end": "1617840"
  },
  {
    "text": "make our insertions happen on different pages leading to unexpected behavior",
    "start": "1617840",
    "end": "1622880"
  },
  {
    "text": "luckily this situation is fairly easy to detect because we just get nonsensical",
    "start": "1622880",
    "end": "1628159"
  },
  {
    "text": "output and since we can detect it we can then retry and hopefully our previous failed",
    "start": "1628159",
    "end": "1633440"
  },
  {
    "text": "attempt filled up all those fragments in the table space",
    "start": "1633440",
    "end": "1638240"
  },
  {
    "start": "1638000",
    "end": "1638000"
  },
  {
    "text": "one final optimization that we took was to maximize to maximize the efficiency of our attack",
    "start": "1639120",
    "end": "1644880"
  },
  {
    "text": "um relates to minimizing the number of database actions that we're performing which is very important for evading",
    "start": "1644880",
    "end": "1650480"
  },
  {
    "text": "detection so previously the real bottleneck for database actions was when we were",
    "start": "1650480",
    "end": "1655840"
  },
  {
    "text": "continually updating in order to find the precise boundary at which",
    "start": "1655840",
    "end": "1661840"
  },
  {
    "text": "at which the table will shrink back to that prior page so previously we performed a linear",
    "start": "1661840",
    "end": "1667360"
  },
  {
    "text": "search across this entire all this whole filler row to find the boundary which as you can",
    "start": "1667360",
    "end": "1673440"
  },
  {
    "text": "see is painfully slow um if r is the maximum row size it could",
    "start": "1673440",
    "end": "1678720"
  },
  {
    "text": "take up to r updates in order to find that boundary we switched to using a binary search",
    "start": "1678720",
    "end": "1685520"
  },
  {
    "text": "method to find that cutoff point which now only takes log base two of our updates for gets so big improvement as",
    "start": "1685520",
    "end": "1692399"
  },
  {
    "text": "you can see um now i'm going to talk a little bit about",
    "start": "1692399",
    "end": "1699039"
  },
  {
    "text": "how just how efficient and accurate we were able to make our attack so that binary search optimization",
    "start": "1699039",
    "end": "1705520"
  },
  {
    "start": "1704000",
    "end": "1704000"
  },
  {
    "text": "really helped quite a bit again if we say that r is the maximum size of a row",
    "start": "1705520",
    "end": "1711200"
  },
  {
    "text": "then while we're inserting uh while we're inserting filler rows we must initially insert at most page size",
    "start": "1711200",
    "end": "1717279"
  },
  {
    "text": "divided by r rows in order to overfill the page so in practice with a mostly empty page",
    "start": "1717279",
    "end": "1723279"
  },
  {
    "text": "in r two equals 200 it takes around 30 insertions and then as we explained before it takes",
    "start": "1723279",
    "end": "1729679"
  },
  {
    "text": "just log base 2 updates per guess log base 2 of r updates per guess to find that boundary at which point the table",
    "start": "1729679",
    "end": "1736480"
  },
  {
    "text": "shrinks back to its prior size so for n guesses we perform only o of r",
    "start": "1736480",
    "end": "1741600"
  },
  {
    "text": "plus n log r database actions um we found that this was quite performant",
    "start": "1741600",
    "end": "1748720"
  },
  {
    "text": "and in practice when r is 200 200 bytes a single guess takes only about 0.2 to",
    "start": "1748720",
    "end": "1755760"
  },
  {
    "text": "0.4 seconds and on the order of 10 updates",
    "start": "1755760",
    "end": "1762640"
  },
  {
    "text": "or fewer so in terms of accuracy we were quite pleased with the results we were able to",
    "start": "1763679",
    "end": "1769200"
  },
  {
    "start": "1766000",
    "end": "1766000"
  },
  {
    "text": "achieve in this experiment we inserted some number k",
    "start": "1769200",
    "end": "1776240"
  },
  {
    "text": "rows onto a page which were randomly chosen from a name set very similar to the one that you saw in the demo",
    "start": "1776240",
    "end": "1782480"
  },
  {
    "text": "then if we inserted k records onto the page we would run the k event extraction attack",
    "start": "1782480",
    "end": "1787840"
  },
  {
    "text": "through all possible options that those records were randomly chosen from and try and pick which k",
    "start": "1787840",
    "end": "1793840"
  },
  {
    "text": "were inserted for low values of k or when there's not many records on the page",
    "start": "1793840",
    "end": "1801120"
  },
  {
    "text": "we uh achieved very high accuracy levels so if you look at one it's over 95",
    "start": "1801120",
    "end": "1806559"
  },
  {
    "text": "for two and four uh they're also over ninety percent also note that this x-axis is on a log",
    "start": "1806559",
    "end": "1813039"
  },
  {
    "text": "scale and then even as k gets quite high so there's uh fifty",
    "start": "1813039",
    "end": "1818559"
  },
  {
    "text": "over fifty or over a hundred rows on the page we remain we are still able to",
    "start": "1818559",
    "end": "1824080"
  },
  {
    "text": "extract 75 or 70 plus percent of those records on average",
    "start": "1824080",
    "end": "1831679"
  },
  {
    "start": "1832000",
    "end": "1832000"
  },
  {
    "text": "one last thing i want to note is that it's there's nothing really specific",
    "start": "1832799",
    "end": "1838080"
  },
  {
    "text": "about marine tv and industries implementation that makes them vulnerable to this attack",
    "start": "1838080",
    "end": "1843840"
  },
  {
    "text": "the the issue is more fundamental it's that the database compresses attacker and victim data together and this occurs",
    "start": "1843840",
    "end": "1850399"
  },
  {
    "text": "in all sorts of database management systems and storage engines as such we believe that other rdbms's",
    "start": "1850399",
    "end": "1856159"
  },
  {
    "text": "and storage engines are likely vulnerable to the same attack or very similar attacks",
    "start": "1856159",
    "end": "1861200"
  },
  {
    "text": "we think that mysql is especially likely to be vulnerable since marie dv is just a fork of mysql and mysql also uses the",
    "start": "1861200",
    "end": "1868080"
  },
  {
    "text": "nodd storage engine now i'm going to go over some possible",
    "start": "1868080",
    "end": "1873519"
  },
  {
    "text": "mitigations for our attack there are really two classes of",
    "start": "1873519",
    "end": "1878960"
  },
  {
    "start": "1877000",
    "end": "1877000"
  },
  {
    "text": "mitigations there's prevention which is what dbas and developers who are using",
    "start": "1878960",
    "end": "1884320"
  },
  {
    "text": "databases can use to avoid falling victim to this sort of attack and then there's actually patching the problem",
    "start": "1884320",
    "end": "1889679"
  },
  {
    "text": "which are more recommendations for the mariadb developers or other database developers themselves",
    "start": "1889679",
    "end": "1896159"
  },
  {
    "text": "in terms of profession prevention we have a few strategies first of all",
    "start": "1896159",
    "end": "1901200"
  },
  {
    "text": "don't use column level commercials for select capabilities this attack clearly showed that these",
    "start": "1901200",
    "end": "1907279"
  },
  {
    "text": "are broken and they provide attackers with half the necessary capabilities because they allow you to update over",
    "start": "1907279",
    "end": "1912880"
  },
  {
    "text": "the whole table and then therefore once you gain",
    "start": "1912880",
    "end": "1918880"
  },
  {
    "text": "read access to the file system they allow you to read the whole table or much of the table",
    "start": "1918880",
    "end": "1925679"
  },
  {
    "text": "additionally dbas or developers could monitor database usage for unusual activity",
    "start": "1925679",
    "end": "1931679"
  },
  {
    "text": "patterns this will look pretty similar to denial of service detection if a single user is",
    "start": "1931679",
    "end": "1937360"
  },
  {
    "text": "performing an unusually high number of inserts and updates or a very unusual pattern of inserts and updates then it",
    "start": "1937360",
    "end": "1943279"
  },
  {
    "text": "might be a good idea to block them from the database for some period of time however remember that after the binary",
    "start": "1943279",
    "end": "1949519"
  },
  {
    "text": "search optimization this takes uh checking one guess takes only about",
    "start": "1949519",
    "end": "1955600"
  },
  {
    "text": "30 insertions and 10 or so updates therefore this ddos detection strategy",
    "start": "1955600",
    "end": "1962720"
  },
  {
    "text": "might be difficult if an attacker is only checking a small number of guesses",
    "start": "1962720",
    "end": "1968240"
  },
  {
    "text": "the only foolproof method for preventing this attack is to turn off compression",
    "start": "1968240",
    "end": "1973279"
  },
  {
    "text": "or alternatively switch to using the storage engine independent compression offering that really provides",
    "start": "1973279",
    "end": "1979760"
  },
  {
    "text": "in both of those cases attacker data will not be compressed with victim data recall that in the",
    "start": "1979760",
    "end": "1985519"
  },
  {
    "text": "storage engine independent compression compression only happens within database cells so within a column and row",
    "start": "1985519",
    "end": "1993760"
  },
  {
    "text": "obviously there's some performance hit for turning off compression and storage will become more expensive however if",
    "start": "1995200",
    "end": "2000559"
  },
  {
    "text": "the data is very sensitive this might be worth it in order to",
    "start": "2000559",
    "end": "2006080"
  },
  {
    "text": "protect the data in terms of actually patching the vulnerability we have a few suggestions",
    "start": "2006080",
    "end": "2013360"
  },
  {
    "start": "2008000",
    "end": "2008000"
  },
  {
    "text": "we believe that column level permissions for select should probably be deprecated or at least recommended against until a",
    "start": "2013360",
    "end": "2019440"
  },
  {
    "text": "more comprehensive solution is found that's for the same reasons as mentioned earlier",
    "start": "2019440",
    "end": "2026799"
  },
  {
    "text": "additionally marietv could offer a compression option that compresses only within rows so",
    "start": "2027200",
    "end": "2033360"
  },
  {
    "text": "attacker data and victim data is not compressing together so storage engine independent compression compresses only",
    "start": "2033360",
    "end": "2038960"
  },
  {
    "text": "within road columns so specific cells but perhaps compressing within rows will",
    "start": "2038960",
    "end": "2045760"
  },
  {
    "text": "be more performant than that while avoiding this issue another idea would be to compress only",
    "start": "2045760",
    "end": "2052320"
  },
  {
    "text": "within rows inserted by the same user and user group so this feature doesn't exist yet but if",
    "start": "2052320",
    "end": "2058480"
  },
  {
    "text": "it were added then it would prevent attackers from compressing with and therefore discovering",
    "start": "2058480",
    "end": "2064638"
  },
  {
    "text": "other users data so now i'm going to go quickly check in",
    "start": "2064639",
    "end": "2071919"
  },
  {
    "text": "on how our demo went it should be done by now so we see down here",
    "start": "2071919",
    "end": "2078480"
  },
  {
    "text": "let's make this a little bigger it's able to uncover the secret name",
    "start": "2078480",
    "end": "2083599"
  },
  {
    "text": "james villanueva remember that we inserted that above um",
    "start": "2083599",
    "end": "2088960"
  },
  {
    "text": "so hooray okay and now a quick conclusion",
    "start": "2088960",
    "end": "2094560"
  },
  {
    "text": "so in summary uh deep reach is an attack on compression and encryption in databases",
    "start": "2094560",
    "end": "2100240"
  },
  {
    "text": "it derives from a simple and achievable threat model and it is efficient and accurate",
    "start": "2100240",
    "end": "2105760"
  },
  {
    "text": "we believe that this really drives home the point that compression and encryption should be combined very",
    "start": "2105760",
    "end": "2111040"
  },
  {
    "text": "carefully lest you or your system fall victim to a compression side channel attack",
    "start": "2111040",
    "end": "2116960"
  },
  {
    "text": "additionally it raises the question of what other context besides databases and besides web security",
    "start": "2116960",
    "end": "2123599"
  },
  {
    "text": "may be vulnerable to such compression side channel attacks and i think there's plenty of opportunities for",
    "start": "2123599",
    "end": "2128880"
  },
  {
    "text": "future work to address that okay thank you happy to take any questions",
    "start": "2128880",
    "end": "2136640"
  }
]