[
  {
    "start": "0",
    "end": "40000"
  },
  {
    "text": "welcome to exploiting the hyper-v IDE emulator to escape the virtual machine in Lagoon JKL with joe by lac before we",
    "start": "30",
    "end": "7170"
  },
  {
    "text": "begin a few brief notes please stop by the business hall located in Mandalay Bay Oceanside and shoreline ballrooms on",
    "start": "7170",
    "end": "13049"
  },
  {
    "text": "level 2 during the day and for the Welcome Reception at 5:30 p.m. tonight the blackhat Arsenal is in the business",
    "start": "13049",
    "end": "19320"
  },
  {
    "text": "hall in level 2 please join us for the pony Awards in lagoon JKL which is this room at 6:30 p.m. and lunch is in",
    "start": "19320",
    "end": "27689"
  },
  {
    "text": "Bayside a be from 1205 to 1:30 please put your phones on vibrate it makes it easier for the rest of us to ignore the",
    "start": "27689",
    "end": "34079"
  },
  {
    "text": "rain while you wait for your voicemail to pick it up now please give a warm welcome to job Ilyich hi so my name is",
    "start": "34079",
    "end": "44550"
  },
  {
    "start": "40000",
    "end": "314000"
  },
  {
    "text": "Joe and I work for Microsoft on the nsrc vulnerabilities and mitigations team and in case you haven't noticed",
    "start": "44550",
    "end": "50520"
  },
  {
    "text": "Microsoft cares quite a bit about hyper-v and we've actually paid out six hundred and twenty five thousand dollars",
    "start": "50520",
    "end": "55649"
  },
  {
    "text": "in hyper-v bounties since blackhat last year today I'm going to be talking about exploiting a vulnerability that was",
    "start": "55649",
    "end": "62129"
  },
  {
    "text": "reported to us through the hyper-v bug bounty and also show you how incredibly",
    "start": "62129",
    "end": "67200"
  },
  {
    "text": "impactful some of the bug reports that you send to us can be so this story",
    "start": "67200",
    "end": "72479"
  },
  {
    "text": "begins sometime in 2017 and I was going through a number of the hyper-v",
    "start": "72479",
    "end": "77790"
  },
  {
    "text": "emulators at the time and looking for security bugs I started reviewing the emulated storage stack and as you might",
    "start": "77790",
    "end": "85950"
  },
  {
    "text": "expect from code that's written in the 90s some of the code in here was a bit sketchy just as a quick example there",
    "start": "85950",
    "end": "93119"
  },
  {
    "text": "was this function it was called write data port and the thing that had me a little bit concerned about this function was that there was a memo opening with a",
    "start": "93119",
    "end": "101040"
  },
  {
    "text": "pointer that it had a bunch of arithmetic done on it and it seemed like some of the arithmetic was checked and",
    "start": "101040",
    "end": "107070"
  },
  {
    "text": "some of the arithmetic definitely was not checked in this function at least but other parts of the state machine in",
    "start": "107070",
    "end": "112799"
  },
  {
    "text": "theory were supposed to be validating that none of these offsets would ever",
    "start": "112799",
    "end": "117840"
  },
  {
    "text": "force the buffer to go out of bounds now unfortunately for me I did not end up",
    "start": "117840",
    "end": "124350"
  },
  {
    "text": "finding a way to trigger a bug here because I got sidetracked we had a meeting with the visual studio team at",
    "start": "124350",
    "end": "130560"
  },
  {
    "text": "Microsoft and they were talking to us about class that they were helping create for",
    "start": "130560",
    "end": "135569"
  },
  {
    "text": "C++ called the span and really all that a span does is it wraps in a race so it",
    "start": "135569",
    "end": "140940"
  },
  {
    "text": "has a pointer it has a size and whenever you do array accesses it does bounce checking for you and fast fields if",
    "start": "140940",
    "end": "146849"
  },
  {
    "text": "you're doing an out of bounds access now one of the things that we're pretty interested in is how we can make our",
    "start": "146849",
    "end": "152160"
  },
  {
    "text": "products safer and just eliminate classes of vulnerabilities so this seemed pretty cool to us and I ended up",
    "start": "152160",
    "end": "157680"
  },
  {
    "text": "switching gears and porting GSL span into the emulated storage stack because",
    "start": "157680",
    "end": "163590"
  },
  {
    "text": "it seemed like a good candidate based on what I had seen and as I was wrapping",
    "start": "163590",
    "end": "169680"
  },
  {
    "text": "that up a crash dump appeared on my desk a researcher that I was working fairly",
    "start": "169680",
    "end": "174840"
  },
  {
    "text": "closely with at the time sent me a crash dump just as a friendly heads-up and told me that he would send me a POC",
    "start": "174840",
    "end": "180930"
  },
  {
    "text": "shortly and maybe even work on an exploit now I didn't want to wait for a",
    "start": "180930",
    "end": "188400"
  },
  {
    "text": "POC because this seemed pretty cool he had a crash in hyper-v and so I cracked open the crash dump and lo and behold",
    "start": "188400",
    "end": "196109"
  },
  {
    "text": "the crash dump is actually in the emulated storage component which I've been working on and actually the crash",
    "start": "196109",
    "end": "201720"
  },
  {
    "text": "dump is inside of this right data port function which looked questionable to me",
    "start": "201720",
    "end": "206900"
  },
  {
    "text": "and when I went and looked at what was going on in that function there were a",
    "start": "206900",
    "end": "212700"
  },
  {
    "text": "couple interesting things to me there was a buffer here it's called the track cache buffer and it's 64 kilobytes big",
    "start": "212700",
    "end": "218280"
  },
  {
    "text": "and there's another variable called the dryest a buffer offset and this variable ends up getting added to the track hash",
    "start": "218280",
    "end": "224730"
  },
  {
    "text": "buffer but this offset was way bigger than 64 kilobytes and so it appeared",
    "start": "224730",
    "end": "230669"
  },
  {
    "text": "that this arithmetic that was being done on the pointer probably wasn't correct",
    "start": "230669",
    "end": "236040"
  },
  {
    "text": "after all now we're gonna talk more about this in a second but before we talk more about it I want to give you at",
    "start": "236040",
    "end": "242609"
  },
  {
    "text": "least some understanding as to what this component is and where it lives nico when i gave a talk at blackhat last year",
    "start": "242609",
    "end": "248400"
  },
  {
    "text": "about hyper-v architecture so if you want to know all the gory details you should check that talk out for the",
    "start": "248400",
    "end": "253680"
  },
  {
    "text": "purposes of this talk though what you need to know is that hyper-v is Microsoft's bare-metal hypervisor in",
    "start": "253680",
    "end": "259109"
  },
  {
    "text": "hyper-v we have this concept of partitions and that just enforces isolation between the different virtual",
    "start": "259109",
    "end": "265500"
  },
  {
    "text": "machines that are running on the the hypervisor one force that different virtual machines cannot interact with",
    "start": "265500",
    "end": "271080"
  },
  {
    "text": "each other's physical memory using extended page tables and the hypervisor will intercept attempts to execute",
    "start": "271080",
    "end": "276900"
  },
  {
    "text": "certain instructions like the in and out instruction which is used to talk directly to Hardware over i/o ports and",
    "start": "276900",
    "end": "285240"
  },
  {
    "text": "if you try to execute some of those instructions then the hypervisor will just emulate them instead so that you can't end up doing harm to other virtual",
    "start": "285240",
    "end": "292319"
  },
  {
    "text": "machines running on the system in hyper view we do have one special partition and that's called the root partition and",
    "start": "292319",
    "end": "298800"
  },
  {
    "text": "it's where the host operating system lives the host operating system is effectively responsible for managing all",
    "start": "298800",
    "end": "305279"
  },
  {
    "text": "the virtual machines that run on the system and one of the things that it does is it provides device simulation to",
    "start": "305279",
    "end": "311189"
  },
  {
    "text": "those virtual machines if they need it and then that brings us to the IDE",
    "start": "311189",
    "end": "316710"
  },
  {
    "text": "emulator or the emulated storage component I use both of those interchangeably what this diagram shows",
    "start": "316710",
    "end": "323669"
  },
  {
    "text": "is that when the guest operating system goes and executes an in or out instruction to do an IO port read or",
    "start": "323669",
    "end": "329729"
  },
  {
    "text": "write that will be intercepted by the hypervisor the hypervisor will forward that down to the host operating systems",
    "start": "329729",
    "end": "336839"
  },
  {
    "text": "kernel and host operating systems kernel will forward that down to the VM worker process",
    "start": "336839",
    "end": "341879"
  },
  {
    "text": "now there's one VM worker process for every virtual machine running on the",
    "start": "341879",
    "end": "346919"
  },
  {
    "text": "system and that actually provides one really nice property for us which is that if you find a bug in code in the",
    "start": "346919",
    "end": "353460"
  },
  {
    "text": "worker process that just allows you to crash the worker process that vulnerability only allows you to create",
    "start": "353460",
    "end": "360960"
  },
  {
    "text": "a denial of service for your own virtual machine it doesn't actually impact anything else running on the system now",
    "start": "360960",
    "end": "367830"
  },
  {
    "text": "the VM worker process is where a number of components live one of them is the instruction emulator which is",
    "start": "367830",
    "end": "373800"
  },
  {
    "text": "responsible for decoding this i/o port read or write instruction and terminate",
    "start": "373800",
    "end": "378839"
  },
  {
    "text": "what exactly you're trying to do and then the instruction emulator will end up forwarding for that forwarding that",
    "start": "378839",
    "end": "384599"
  },
  {
    "text": "on to the appropriate device simulator in this case we can assume that it is",
    "start": "384599",
    "end": "390449"
  },
  {
    "text": "going to the emulated storage device emulator and this is this consists of a couple components there is the IDE",
    "start": "390449",
    "end": "396360"
  },
  {
    "text": "controller device there are two IDE channels that are at that controller device and each channel",
    "start": "396360",
    "end": "402689"
  },
  {
    "text": "has two attachments attached to it and those attachments can either be hard drives or optical drives for the",
    "start": "402689",
    "end": "408629"
  },
  {
    "text": "purposes of this talk I'm gonna be using hard drives and also for the purposes of this talk",
    "start": "408629",
    "end": "413999"
  },
  {
    "text": "the only i/o ports that actually matter are one F zero through one F seven the emulated storage component does emulate",
    "start": "413999",
    "end": "420360"
  },
  {
    "text": "a number of other i/o ports but they don't matter for this vulnerability",
    "start": "420360",
    "end": "426499"
  },
  {
    "start": "426000",
    "end": "705000"
  },
  {
    "text": "let's talk more about the bug so as I mentioned I was already working on the",
    "start": "427789",
    "end": "433379"
  },
  {
    "text": "emulated storage component when this crash dump was sent to us and rather",
    "start": "433379",
    "end": "439169"
  },
  {
    "text": "than wait for the POC to come I decided I couldn't wait and I wanted to try to figure out what was actually going on",
    "start": "439169",
    "end": "444659"
  },
  {
    "text": "here it was a little bit of a point of pride for me because I had clearly missed this bug when I had first looked",
    "start": "444659",
    "end": "450119"
  },
  {
    "text": "at the function so I spent about half a day trying to figure out how I could force this condition to happen and after",
    "start": "450119",
    "end": "455909"
  },
  {
    "text": "about half a day I had a POC created the vulnerability itself is inside of the",
    "start": "455909",
    "end": "462449"
  },
  {
    "text": "state machine of the emulated storage device so it's not super straightforward to show you like a code snippet for like",
    "start": "462449",
    "end": "470039"
  },
  {
    "text": "here's exactly where the bug is but effectively what was happening here is that the emulated storage component was",
    "start": "470039",
    "end": "475829"
  },
  {
    "text": "supposed to enforce that this drive state buffer offset variable would never get too big and it wasn't enforcing that",
    "start": "475829",
    "end": "483449"
  },
  {
    "text": "correctly so the way that you trigger the bug is first you do a couple of i/o port writes just to put this device in a",
    "start": "483449",
    "end": "489569"
  },
  {
    "text": "desired state and then there's this loop here and it's in dark blue I can try to",
    "start": "489569",
    "end": "495479"
  },
  {
    "text": "highlight this with my laser pointer this loop right here every time this loop executes it doesn't",
    "start": "495479",
    "end": "502259"
  },
  {
    "text": "I Oh port right and every i/o port right that you execute there will end up incrementing the drive state buffer",
    "start": "502259",
    "end": "508679"
  },
  {
    "text": "offset by 512 so the drive state buffer offset is always 512 byte aligned now",
    "start": "508679",
    "end": "516930"
  },
  {
    "text": "there's two ways you can go the first way you can go is you can issue an i/o port right to port 1 f0 and",
    "start": "516930",
    "end": "523198"
  },
  {
    "text": "when you do that that is going to trigger a write to the track cache buffer using this massive drive state",
    "start": "523199",
    "end": "530639"
  },
  {
    "text": "buffer offset so even out of bounds right the other way you can go is you can do an IO port read from that same IO port",
    "start": "530639",
    "end": "537300"
  },
  {
    "text": "and when you do that it will trigger a read from the tract cache buffer and it will return that data to you and you",
    "start": "537300",
    "end": "543180"
  },
  {
    "text": "have an out-of-bounds read there if we look at the functions that are actually involved and this this is probably too",
    "start": "543180",
    "end": "549840"
  },
  {
    "text": "small to read but I'm just going to talk through it and you can reference the slide later if you want to there's this",
    "start": "549840",
    "end": "556020"
  },
  {
    "text": "function inside the emulated storage component and it's called write data port and this function has a couple of",
    "start": "556020",
    "end": "561390"
  },
  {
    "text": "key variables it has the track cache buffer which is this pointer it has the drive state buffer offset which is this",
    "start": "561390",
    "end": "567180"
  },
  {
    "text": "value that we can increment to to be out of bounds and that is a unsigned 32-bit",
    "start": "567180",
    "end": "572420"
  },
  {
    "text": "value so you can increment that that value to be up to four gigabytes big and",
    "start": "572420",
    "end": "579000"
  },
  {
    "text": "the other important variable here is this current byte variable and this is always between 0 and 512 gets",
    "start": "579000",
    "end": "585930"
  },
  {
    "text": "incremented every time you read or write from the track cache buffer and once it",
    "start": "585930",
    "end": "591060"
  },
  {
    "text": "hits 511 it will reset back down to 0",
    "start": "591060",
    "end": "596990"
  },
  {
    "text": "now what this function ends up doing is it adds these variables together the buffer the drive state buffer offset and",
    "start": "596990",
    "end": "603060"
  },
  {
    "text": "that current byte and it uses that as the destination for mmm copy and the",
    "start": "603060",
    "end": "609030"
  },
  {
    "text": "source of the mem copy is the attacker controlled data that was specified to be used in the i/o port right so you have a",
    "start": "609030",
    "end": "615390"
  },
  {
    "text": "relative write primitive here with a attacker controlled 32-bit offset and attack controlled data and just in case",
    "start": "615390",
    "end": "624300"
  },
  {
    "text": "it isn't super clear the way that you end up having that full 32-bit offset",
    "start": "624300",
    "end": "629430"
  },
  {
    "text": "under your control is the high 23 bits come from the drive state buffer offset because that's always going to be 512",
    "start": "629430",
    "end": "635760"
  },
  {
    "text": "byte aligned and the low 9 bits come from the current byte now there's a",
    "start": "635760",
    "end": "643140"
  },
  {
    "text": "corresponding function here it's called read data port it pretty much does the opposite thing it uses those same three",
    "start": "643140",
    "end": "649320"
  },
  {
    "text": "variables to compute a pointer but instead of writing to that pointer it reads from the pointer and it copies",
    "start": "649320",
    "end": "655710"
  },
  {
    "text": "that data into a buffer which will eventually be returned to the guest so this gives me a relative read primitive",
    "start": "655710",
    "end": "661500"
  },
  {
    "text": "with a controlled unsigned 32-bit offset",
    "start": "661500",
    "end": "666920"
  },
  {
    "text": "and one thing that was cool and a little bit unfortunate was that that version of",
    "start": "667680",
    "end": "673439"
  },
  {
    "text": "the emulated storage stack that I had been porting GSL span into was not actually vulnerable to this bug because",
    "start": "673439",
    "end": "679110"
  },
  {
    "text": "as soon as you run the POC the VM worker process would just immediately fast fail it would never let you go out of bounds",
    "start": "679110",
    "end": "685230"
  },
  {
    "text": "and you would just crash your own virtual machine and nothing else on the host was impacted but of course we",
    "start": "685230",
    "end": "691050"
  },
  {
    "text": "hadn't shipped it yet in fact I don't even think it had been checked in yet so that doesn't do us any good quite yet but it is still kind of interesting for",
    "start": "691050",
    "end": "698939"
  },
  {
    "text": "us to see that proactive work we were doing was actually killing real bugs that people were finding so let's move",
    "start": "698939",
    "end": "706559"
  },
  {
    "start": "705000",
    "end": "805000"
  },
  {
    "text": "on this bug looked awesome it's you know I have this 32-bit index that I control",
    "start": "706559",
    "end": "712199"
  },
  {
    "text": "and I can read and write and so I figured I'd like to try to write an x plate for it and I figured I'd start with Server 2012 r2 because it was being",
    "start": "712199",
    "end": "719730"
  },
  {
    "text": "used in cloud environments and also because I figured it would be easier than exploiting the latest version of Windows so it would be a little bit of a",
    "start": "719730",
    "end": "726269"
  },
  {
    "text": "warm-up for me I had a few constraints with writing this exploit the first",
    "start": "726269",
    "end": "732600"
  },
  {
    "text": "constraint is that the emulated storage path is slow and the way that I had written my POC made it even slower than",
    "start": "732600",
    "end": "739110"
  },
  {
    "text": "it needed to be and so I figured that if the way that I was going to exploit this",
    "start": "739110",
    "end": "744660"
  },
  {
    "text": "bug required me winning some weird timing or race condition between threads",
    "start": "744660",
    "end": "750179"
  },
  {
    "text": "that's probably not gonna be practical I'm also limited to only using",
    "start": "750179",
    "end": "755850"
  },
  {
    "text": "generation 1 Virtual Machines hyper-v has two generations of virtual machines the emulated storage stack is not",
    "start": "755850",
    "end": "762870"
  },
  {
    "text": "supported on the second generation really all that that means is that I have a more limited set of devices that",
    "start": "762870",
    "end": "768240"
  },
  {
    "text": "I can use to try to do things like keep massaging or build other primitives out of and of course the VM worker process",
    "start": "768240",
    "end": "776249"
  },
  {
    "text": "is running with control flow guard and aslr and dep enabled and it is only a",
    "start": "776249",
    "end": "783179"
  },
  {
    "text": "64-bit process you cannot have a 32-bit hyper-v hosts so the VM worker process will never be 32 bits and that's a",
    "start": "783179",
    "end": "789749"
  },
  {
    "text": "little bit unfortunate for me because if it was a 32 bit process and I have a full control over a 32-bit unsigned",
    "start": "789749",
    "end": "795870"
  },
  {
    "text": "index then I would just immediately have a full read/write primitive over the entire virtual address space of the",
    "start": "795870",
    "end": "801510"
  },
  {
    "text": "process but that's not the case here so the first question that I had is where",
    "start": "801510",
    "end": "807840"
  },
  {
    "text": "does the track cache buffer get allocated is it in the heap or is it somewhere else and it turns out that it",
    "start": "807840",
    "end": "813240"
  },
  {
    "text": "is allocated using the virtual Alec API which is a bottom-up allocator in",
    "start": "813240",
    "end": "818790"
  },
  {
    "text": "Windows and the allocations that are returned by virtual Alec are always 64 kilobytes aligned and they are made",
    "start": "818790",
    "end": "826080"
  },
  {
    "text": "sequentially to reduce fragmentation in the virtual address space so I have a little example here on the side where if",
    "start": "826080",
    "end": "831990"
  },
  {
    "text": "you go and you make a whole bunch of virtual Alec allocations you will see that the address just grows 64 kilobytes",
    "start": "831990",
    "end": "838710"
  },
  {
    "text": "at a time or if the allocation is bigger than 64 kilobytes then it grows by a larger amount at a time but they're all sequential and this gave me an idea",
    "start": "838710",
    "end": "845700"
  },
  {
    "text": "which is that it might be possible that there is some interesting buffer that is",
    "start": "845700",
    "end": "853380"
  },
  {
    "text": "allocated at some predictable offset from the track cache buffer because",
    "start": "853380",
    "end": "858390"
  },
  {
    "text": "these allocations are all made in such a you know sequential and predictable way",
    "start": "858390",
    "end": "863720"
  },
  {
    "text": "however it's not guaranteed that that's going to be the case because if there's multiple threads calling virtual Alec at",
    "start": "863720",
    "end": "869880"
  },
  {
    "text": "a time then there can still be unpredictability and how things are laid out so what I did to figure out if this",
    "start": "869880",
    "end": "878070"
  },
  {
    "start": "875000",
    "end": "1157000"
  },
  {
    "text": "was the case or not is I just started turning virtual machines on and then I would use a VM map to go and dump the",
    "start": "878070",
    "end": "884190"
  },
  {
    "text": "address space of the VM worker process and I did this over a whole bunch of reboots and every time that I would do",
    "start": "884190",
    "end": "891960"
  },
  {
    "text": "it I would record what I was seeing and I created this memory layout generalization based off that data and",
    "start": "891960",
    "end": "897860"
  },
  {
    "text": "there are a couple interesting things here that I noticed so near the top we have the track hash buffer and after the",
    "start": "897860",
    "end": "905580"
  },
  {
    "text": "track cache buffer we had these allocations that I was I just refer to them as the miscellaneous allocations and it seemed to be typically anywhere",
    "start": "905580",
    "end": "913380"
  },
  {
    "text": "from 64 kilobytes to 3 megabytes and this immediately kind of messes up my plan because none of these allocations",
    "start": "913380",
    "end": "921810"
  },
  {
    "text": "look like good corruption targets and there was a totally variable number of them after that there was this buffer",
    "start": "921810",
    "end": "928260"
  },
  {
    "text": "called the vram buffer it's 8 megabytes big and I'll talk more about that in a second that was followed by a stack",
    "start": "928260",
    "end": "935130"
  },
  {
    "text": "and I call it the unreliable stack because it seemed to die a lot and so I didn't really want to try to corrupt it because it would just unmask itself a",
    "start": "935130",
    "end": "942510"
  },
  {
    "text": "lot of the times then there was a heap it was a thousand eighty eight kilobytes it had a single allocation in it it",
    "start": "942510",
    "end": "948090"
  },
  {
    "text": "wasn't a good corruption target there were a couple small allocations and then there was this floppy device",
    "start": "948090",
    "end": "954000"
  },
  {
    "text": "eventlistener stack and one key observation I had here is that there seems to be a fixed offset between the",
    "start": "954000",
    "end": "959940"
  },
  {
    "text": "end of that vram buffer and the start of the floppy device eventlistener stack",
    "start": "959940",
    "end": "965180"
  },
  {
    "text": "now I was thinking that corrupting a stack would be great because if I corrupt a stack then I can just ignore",
    "start": "965630",
    "end": "972060"
  },
  {
    "text": "control flow guard since it doesn't actually protect stacks but the issue is that there's no predictable offset",
    "start": "972060",
    "end": "978480"
  },
  {
    "text": "between that track cache buffer and any of the stacks on the system because of these miscellaneous allocations that",
    "start": "978480",
    "end": "984540"
  },
  {
    "text": "vary in size so much so I really needed to figure out if there was a reliable",
    "start": "984540",
    "end": "990300"
  },
  {
    "text": "way that I could read and write stacks so I started looking at this vram buffer",
    "start": "990300",
    "end": "996660"
  },
  {
    "text": "to figure out what it was and it turns out that this is what is known in hyper-v lingo as an aperture and all",
    "start": "996660",
    "end": "1004700"
  },
  {
    "text": "that an aperture is a shared section that map's guest physical memory and I'm",
    "start": "1004700",
    "end": "1010430"
  },
  {
    "text": "of course running in the guest so I can go and write whatever I want in that physical memory and whenever I write",
    "start": "1010430",
    "end": "1016430"
  },
  {
    "text": "data into that physical memory it immediately shows up inside of this vram buffer in the VM worker process so",
    "start": "1016430",
    "end": "1022970"
  },
  {
    "text": "here's what I did I went and wrote a bunch of markers inside of that vram buffer and every marker just tells me",
    "start": "1022970",
    "end": "1029688"
  },
  {
    "text": "how much of the vram buffer is left you'll see why this is useful in a second here the next thing I noticed is",
    "start": "1029689",
    "end": "1037188"
  },
  {
    "text": "that since those miscellaneous allocations never seemed to be bigger than three megabytes but the vram buffer",
    "start": "1037189",
    "end": "1044180"
  },
  {
    "text": "is eight megabytes big I could just index eight megabytes off the end of that track cache buffer and I would land",
    "start": "1044180",
    "end": "1050720"
  },
  {
    "text": "somewhere in the vram buffer now I have no way to know exactly where I'm gonna land in it but I will land somewhere in",
    "start": "1050720",
    "end": "1056480"
  },
  {
    "text": "it and so what I can do here is I can use my out-of-bounds read and go and",
    "start": "1056480",
    "end": "1063740"
  },
  {
    "text": "read eight megabytes off the end of that buffer and then read them that I wrote into the vram buffer and",
    "start": "1063740",
    "end": "1069800"
  },
  {
    "text": "that will tell me how far another vrn buffer I am once I know how far into the vram buffer I am I know how much further",
    "start": "1069800",
    "end": "1077750"
  },
  {
    "text": "I need to read out of bounds to get to the end of that vram buffer and this",
    "start": "1077750",
    "end": "1085520"
  },
  {
    "text": "gives me pretty much everything that I need to exploit the bug because there seemed to be a fixed offset between the end of the vram buffer and the start of",
    "start": "1085520",
    "end": "1092450"
  },
  {
    "text": "the floppy device eventlistener stack so once I find the end of the vram buffer I now also know how far I need to read and",
    "start": "1092450",
    "end": "1098780"
  },
  {
    "text": "right out of bounds to get to that stack and so I can go and I can read from the stack and leak the address of ntdll and",
    "start": "1098780",
    "end": "1106490"
  },
  {
    "text": "kernel32 and then I can go and I can corrupt that stack and write a brought payload on it there was one little",
    "start": "1106490",
    "end": "1114500"
  },
  {
    "text": "remaining issue here which is that the floppy device eventlistener stack needs to unwind before I can trigger my",
    "start": "1114500",
    "end": "1120830"
  },
  {
    "text": "payload and this stack was always just sitting waiting for events to be signaled to it now nobody really uses",
    "start": "1120830",
    "end": "1128510"
  },
  {
    "text": "floppy drives anymore and the only way that it seemed that events would be",
    "start": "1128510",
    "end": "1133640"
  },
  {
    "text": "signaled to this is if you had a floppy drive plugged into your virtual machine and it was doing things but one thing I",
    "start": "1133640",
    "end": "1140000"
  },
  {
    "text": "did realize is that if I restart the virtual machine that will also signal the floppy event device event listener",
    "start": "1140000",
    "end": "1146330"
  },
  {
    "text": "stack because it will tell that stack hey the virtual machine is shutting down so the stack is going away and that will",
    "start": "1146330",
    "end": "1152390"
  },
  {
    "text": "trigger the stack to unwind and that will then kick off my payload I have a",
    "start": "1152390",
    "end": "1157730"
  },
  {
    "start": "1157000",
    "end": "1242000"
  },
  {
    "text": "little demo here the demos are all recorded because some of them take a little while to run but effectively what",
    "start": "1157730",
    "end": "1167000"
  },
  {
    "text": "I'm doing here is I'm running on a 2012 r2 host and I have this guest operating system here I run the exploit the first",
    "start": "1167000",
    "end": "1173990"
  },
  {
    "text": "thing that it does is go and look for markers inside the vram buffer now it's found the markers in the vram buffer and",
    "start": "1173990",
    "end": "1179600"
  },
  {
    "text": "so it's gonna go and read from the stack look for addresses and then it's gonna go and corrupt the stack with the",
    "start": "1179600",
    "end": "1185930"
  },
  {
    "text": "payload that I've created now in this case the payload is just going to call win exec to pop calc so it's writing",
    "start": "1185930",
    "end": "1195470"
  },
  {
    "text": "it's writing it takes a little takes a little while to do these writes but it's now finished writing",
    "start": "1195470",
    "end": "1201680"
  },
  {
    "text": "and the exploit tells me helpfully that I now need to restart the virtual machine to actually trigger that payload",
    "start": "1201680",
    "end": "1208810"
  },
  {
    "text": "and so I go and restart and then if you",
    "start": "1208810",
    "end": "1218030"
  },
  {
    "text": "use process Explorer you can see that pop calyx it's in session zero so you don't actually see it on your desktop here but we do pop calc and it's running",
    "start": "1218030",
    "end": "1225680"
  },
  {
    "text": "as the VM worker processes user account so that's great Oh alrighty so then I",
    "start": "1225680",
    "end": "1243860"
  },
  {
    "start": "1242000",
    "end": "1422000"
  },
  {
    "text": "decided to set my sights on something hopefully more challenging which was the latest version of Windows at the time",
    "start": "1243860",
    "end": "1249560"
  },
  {
    "text": "Windows 10 1709 I believe the codename for this was redstone 3 it was not quite released yet",
    "start": "1249560",
    "end": "1255800"
  },
  {
    "text": "but it was almost released at this point so the obvious question is what has",
    "start": "1255800",
    "end": "1262280"
  },
  {
    "text": "changed right if I'm going after a new version of Windows can I just do the exact same thing or not now one big",
    "start": "1262280",
    "end": "1268940"
  },
  {
    "text": "change that was made was as a result of an exploit that Jordan rabbit wrote who's on the OSR team and Microsoft",
    "start": "1268940",
    "end": "1276130"
  },
  {
    "text": "stack stems and PEVs were no longer allocated anywhere near the rest of the",
    "start": "1276130",
    "end": "1281480"
  },
  {
    "text": "bottom up allocations and windows which means they are not allocated anywhere near any allocation made using virtual",
    "start": "1281480",
    "end": "1288590"
  },
  {
    "text": "outlook this means that I can no longer use my readwrite primitive to read and write to stacks so that immediately",
    "start": "1288590",
    "end": "1295370"
  },
  {
    "text": "changes everything about the exploit effectively we also have more exploit mitigations that are applied in the",
    "start": "1295370",
    "end": "1301190"
  },
  {
    "text": "latest version of Windows the vm worker process had AC G and C I G enabled and these are just two mitigations that",
    "start": "1301190",
    "end": "1307520"
  },
  {
    "text": "effectively make it so that the process itself cannot allocate its own executable code pages and the only",
    "start": "1307520",
    "end": "1314180"
  },
  {
    "text": "executable code pages that the kernel will map in our code pages that are signed by Microsoft we also have no",
    "start": "1314180",
    "end": "1322040"
  },
  {
    "text": "child process enabled which means you can no longer spawn child processes and we have another mitigation enabled which",
    "start": "1322040",
    "end": "1327530"
  },
  {
    "text": "prevents you from loading dll's that are from a network location and we",
    "start": "1327530",
    "end": "1334919"
  },
  {
    "text": "have a number of control flow guard improvements that have been made a lot of these were reported through the hyper-v bounty or sorry not the hyper-v",
    "start": "1334919",
    "end": "1340919"
  },
  {
    "text": "bounty but the the mitigations bounty that we have so we had we had done some",
    "start": "1340919",
    "end": "1346049"
  },
  {
    "text": "work to harden CFG but really the big thing here was that since stacks were no",
    "start": "1346049",
    "end": "1351419"
  },
  {
    "text": "longer allocated near me I was gonna have to change a lot about how I exploited this bug so I ended up doing",
    "start": "1351419",
    "end": "1359220"
  },
  {
    "text": "the the same initial process of using vm map to go and create this memory layout",
    "start": "1359220",
    "end": "1364619"
  },
  {
    "text": "generalization and a lot of it was the same there were a couple important things though one important thing is",
    "start": "1364619",
    "end": "1371279"
  },
  {
    "text": "that most of the heaps in the vm worker process are allocated at a lower virtual",
    "start": "1371279",
    "end": "1377639"
  },
  {
    "text": "address than the track hash buffer and that means I cannot read or write them however there was this one heap that I",
    "start": "1377639",
    "end": "1386909"
  },
  {
    "text": "am going to refer to as the target heap for the purposes of this talk it was a four megabyte heap and I could read and",
    "start": "1386909",
    "end": "1395039"
  },
  {
    "text": "write that from the track hash buffer using this out-of-bounds primitive that I had and the other nice thing is that",
    "start": "1395039",
    "end": "1400950"
  },
  {
    "text": "this target heap also seemed to be at a fixed offset from the vram buffer now",
    "start": "1400950",
    "end": "1408029"
  },
  {
    "text": "one thing that I that I quickly noticed was that I could use the exact same technique as before to find the vram",
    "start": "1408029",
    "end": "1414239"
  },
  {
    "text": "buffer those allocations had not changed so there was the track cache buffer miscellaneous allocations and then a",
    "start": "1414239",
    "end": "1419669"
  },
  {
    "text": "VRAM buffer so with this I had a couple",
    "start": "1419669",
    "end": "1425100"
  },
  {
    "start": "1422000",
    "end": "1463000"
  },
  {
    "text": "ideas for how I could go about exploiting the bug the first thing that I really wanted to do was I wanted to",
    "start": "1425100",
    "end": "1430379"
  },
  {
    "text": "find some interesting piece of data that I could corrupt so that I could boost my",
    "start": "1430379",
    "end": "1435539"
  },
  {
    "text": "relative read/write primitive to arbitrary readwrite and I thought there was if I can get an arbitrary readwrite",
    "start": "1435539",
    "end": "1441690"
  },
  {
    "text": "primitive then maybe I can leak the address of a stack and I could just go cur up the stack again and completely",
    "start": "1441690",
    "end": "1447419"
  },
  {
    "text": "ignore completely ignore control flow guard so that seemed great the other idea I had was I could obviously go and",
    "start": "1447419",
    "end": "1454379"
  },
  {
    "text": "just corrupt a function pointer and then I would have to confront control flow guard head-on I would have to find some",
    "start": "1454379",
    "end": "1460379"
  },
  {
    "text": "way to bypass it but let's start with the first one because that's what I",
    "start": "1460379",
    "end": "1465659"
  },
  {
    "start": "1463000",
    "end": "1586000"
  },
  {
    "text": "really wanted to make work first thing that I did was I started logging all of the heap allocations that",
    "start": "1465659",
    "end": "1471630"
  },
  {
    "text": "were being made by the VM worker process so I would turn the virtual machine on let it run look at the call stack of all",
    "start": "1471630",
    "end": "1478080"
  },
  {
    "text": "those allocations and look and see if any of those allocations look like they could be influenced by the guest like if",
    "start": "1478080",
    "end": "1484350"
  },
  {
    "text": "I could spray a bunch of allocations and for any of those allocations then I wanted to see is there interesting data",
    "start": "1484350",
    "end": "1490800"
  },
  {
    "text": "in them that if I corrupted I could boost myself to this arbitrary readwrite primitive and sadly for me this did not",
    "start": "1490800",
    "end": "1498000"
  },
  {
    "text": "work out because as it turned out the VM worker process for a generation one virtual machine at least has effectively",
    "start": "1498000",
    "end": "1505620"
  },
  {
    "text": "no ability to spray allocations on the heap almost all of the allocations are",
    "start": "1505620",
    "end": "1510930"
  },
  {
    "text": "made up front when the virtual machine turns on and so it was just a dead end",
    "start": "1510930",
    "end": "1517760"
  },
  {
    "text": "so I moved on and instead I figured that I would just go and look at that target heap and see if there were any out in",
    "start": "1517760",
    "end": "1524220"
  },
  {
    "text": "any interesting allocations that were already allocated in the target heap that had a similar property of having",
    "start": "1524220",
    "end": "1530070"
  },
  {
    "text": "some interesting piece of data that I could corrupt and then get an arbitrary readwrite primitive and one thing that I",
    "start": "1530070",
    "end": "1535470"
  },
  {
    "text": "spent probably way too much time on but I just wanted it to work so bad was I wanted to find an emulator that had like",
    "start": "1535470",
    "end": "1544080"
  },
  {
    "text": "the the class that implemented the emulator was allocated inside of that target heap because I figured if I did",
    "start": "1544080",
    "end": "1551760"
  },
  {
    "text": "that then I could go and just corrupt the buffer that that emulator writes IO",
    "start": "1551760",
    "end": "1557430"
  },
  {
    "text": "port writes into or that it retrieves i/o port reads from so if I corrupted that pointer then maybe I could just get",
    "start": "1557430",
    "end": "1563910"
  },
  {
    "text": "arbitrary readwrite to anywhere in the address space but it didn't work out the",
    "start": "1563910",
    "end": "1568920"
  },
  {
    "text": "emulators were effectively never allocated in this target heap so I couldn't corrupt the emulators",
    "start": "1568920",
    "end": "1574380"
  },
  {
    "text": "themselves and I wasn't able to find anything else in the target heap that looked like an interesting target for",
    "start": "1574380",
    "end": "1580800"
  },
  {
    "text": "data corruption okay so I ended up moving on this this didn't seem like it",
    "start": "1580800",
    "end": "1587070"
  },
  {
    "text": "was going to work so I figured that rather than do a data corruption I was probably gonna have to just go and",
    "start": "1587070",
    "end": "1593040"
  },
  {
    "text": "confront control flow guard but I figured maybe that would be easy maybe",
    "start": "1593040",
    "end": "1598890"
  },
  {
    "text": "what I could do is I could go and just look at all the binaries that get loaded in the worker process and I could find a",
    "start": "1598890",
    "end": "1605010"
  },
  {
    "text": "binary that was not compiled with control flow guard at all and if that",
    "start": "1605010",
    "end": "1610380"
  },
  {
    "text": "was the case then I would have a whole bunch of unprotected indirect calls so that would make it hopefully pretty easy",
    "start": "1610380",
    "end": "1615930"
  },
  {
    "text": "for me to bypass see if cheap but I did not find any binaries that were not compiled with control flow garden and I",
    "start": "1615930",
    "end": "1623970"
  },
  {
    "text": "also wanted to see if I could just find some indirect calls maybe indirect calls",
    "start": "1623970",
    "end": "1630480"
  },
  {
    "text": "that were written with assembly that we're missing control flow guard instrumentation on that specific",
    "start": "1630480",
    "end": "1636540"
  },
  {
    "text": "indirect call and once again I hit a dead end here I could not find any",
    "start": "1636540",
    "end": "1641640"
  },
  {
    "text": "indirect calls that were loaded into the worker process that were missing CFG instrumentation there were a couple of",
    "start": "1641640",
    "end": "1648720"
  },
  {
    "text": "control flow got bypasses that existed in some of these binaries some of them were publicly known at the time however",
    "start": "1648720",
    "end": "1656040"
  },
  {
    "text": "all of the bypasses that I found either required that I knew the address of my",
    "start": "1656040",
    "end": "1661500"
  },
  {
    "text": "current stack which I do not or they required that I had to win some race",
    "start": "1661500",
    "end": "1667980"
  },
  {
    "text": "condition between two threads so I had to get one thread to start executing down a code path and then I had to do a",
    "start": "1667980",
    "end": "1674790"
  },
  {
    "text": "write at like a very specific time to race what that thread was doing and and",
    "start": "1674790",
    "end": "1679980"
  },
  {
    "text": "that just seemed completely impractical with the primitive that I had so it looked like I wasn't gonna be able to",
    "start": "1679980",
    "end": "1685620"
  },
  {
    "text": "get a super easy control flow guard bypass so I decided that rather than",
    "start": "1685620",
    "end": "1692850"
  },
  {
    "text": "look for easy CFG bypasses what I was going to do was just try to abuse the coarse-grain nature of control flow",
    "start": "1692850",
    "end": "1698670"
  },
  {
    "text": "guard and I was gonna make valid indirect calls that just gave me a little bit more control over the address",
    "start": "1698670",
    "end": "1705330"
  },
  {
    "text": "space of the process maybe try to get a read/write primitive out of it but in",
    "start": "1705330",
    "end": "1712620"
  },
  {
    "text": "order to do this I needed some building blocks so I started looking around and just looking for things that looked",
    "start": "1712620",
    "end": "1718860"
  },
  {
    "start": "1715000",
    "end": "1825000"
  },
  {
    "text": "interesting that I could use to start building an exploit one of the first",
    "start": "1718860",
    "end": "1723930"
  },
  {
    "text": "things I found was this class it's called the video dirt listener one really amazing thing about this class is",
    "start": "1723930",
    "end": "1730830"
  },
  {
    "text": "that it's allocated in the target heap so I can corrupt it great that's like my first requirement right",
    "start": "1730830",
    "end": "1736260"
  },
  {
    "text": "another nice thing about this class is that it has virtual functions now one downside is that those virtual functions",
    "start": "1736260",
    "end": "1742770"
  },
  {
    "text": "are only triggered when the virtual machine reboots so I once again have the situation where I need to reboot the VM",
    "start": "1742770",
    "end": "1748529"
  },
  {
    "text": "to trigger things but that's okay I can work with it another nice thing about",
    "start": "1748529",
    "end": "1754080"
  },
  {
    "text": "this class is that it has a very large buffer inside of it it's over a page big",
    "start": "1754080",
    "end": "1760350"
  },
  {
    "text": "and that matters because when you reboot the virtual machine a lot of the allocations that are in the heap have",
    "start": "1760350",
    "end": "1767309"
  },
  {
    "text": "already been freed by the time virtual functions in this class have been called and if you're gonna try to execute some",
    "start": "1767309",
    "end": "1773429"
  },
  {
    "text": "sort of payload you need to be sure that your payload still exists when you go to",
    "start": "1773429",
    "end": "1778649"
  },
  {
    "text": "execute it so the fact that this class both had a virtual function table and it",
    "start": "1778649",
    "end": "1784590"
  },
  {
    "text": "had this massive buffer work at store payload was great and then the other thing is that I can find the address of",
    "start": "1784590",
    "end": "1791340"
  },
  {
    "text": "comm based DLL and RPC RT for DLL inside of the target heap",
    "start": "1791340",
    "end": "1796490"
  },
  {
    "text": "unfortunately for me I could not find the address of kernel base inside the target key and I'll talk more about why",
    "start": "1796490",
    "end": "1801990"
  },
  {
    "text": "that matters in a minute the video dirt listener object itself it's actually",
    "start": "1801990",
    "end": "1807840"
  },
  {
    "text": "pretty complicated it has a lot of things but for the purposes of this talk there's only two things that matter at offset 150 there's a V table and",
    "start": "1807840",
    "end": "1814289"
  },
  {
    "text": "immediately following that V table is this massive page size buffer that is completely unused during normal VM",
    "start": "1814289",
    "end": "1820620"
  },
  {
    "text": "operation so I am free to write whatever I want into it the next building block",
    "start": "1820620",
    "end": "1828929"
  },
  {
    "start": "1825000",
    "end": "1913000"
  },
  {
    "text": "that I found was this cool CFG gadget I'm just going to refer to it as the looping in direct caller this there's",
    "start": "1828929",
    "end": "1835590"
  },
  {
    "text": "this function it's called revert changes it is a valid indirect call target so if",
    "start": "1835590",
    "end": "1841169"
  },
  {
    "text": "you hijack a function pointer you can call this function what this function does is it takes a contact structure it",
    "start": "1841169",
    "end": "1848789"
  },
  {
    "text": "follows a list head field inside of that context structure and loop through a",
    "start": "1848789",
    "end": "1854399"
  },
  {
    "text": "linked list of these node structures on every node structure it makes a virtual",
    "start": "1854399",
    "end": "1860580"
  },
  {
    "text": "function call it does not pass any parameters to the virtual function call except for the implied this pointer that",
    "start": "1860580",
    "end": "1867929"
  },
  {
    "text": "is always passed you virtual function calls and then it just keeps looping through the list so",
    "start": "1867929",
    "end": "1873660"
  },
  {
    "text": "this effectively this effectively gives me the ability to make an unlimited unlimited number of indirect calls so",
    "start": "1873660",
    "end": "1882660"
  },
  {
    "text": "what I can do here is I can have this video dirt listener object and I can overlay this context structure into it",
    "start": "1882660",
    "end": "1888690"
  },
  {
    "text": "such that when the virtual function call is made on the video dirt listener it actually calls this river changes",
    "start": "1888690",
    "end": "1894480"
  },
  {
    "text": "function and that kicks off this loop where I get to make an unlimited number",
    "start": "1894480",
    "end": "1899520"
  },
  {
    "text": "of virtual function calls so that's great I've kind of boosted my capabilities a little bit right instead",
    "start": "1899520",
    "end": "1905010"
  },
  {
    "text": "of only being able to make one virtual function call when the virtual machine reboots I can now make an unlimited",
    "start": "1905010",
    "end": "1910770"
  },
  {
    "text": "number unfortunately I don't control the parameters of any of those virtual",
    "start": "1910770",
    "end": "1916260"
  },
  {
    "start": "1913000",
    "end": "1964000"
  },
  {
    "text": "function calls and so it it's not super useful for me right now but luckily for me Tomas Garnier has already done some",
    "start": "1916260",
    "end": "1922950"
  },
  {
    "text": "research in this area and he found that there's this really interesting function in the RPC runtime of Windows called ndr",
    "start": "1922950",
    "end": "1928530"
  },
  {
    "text": "server call 2 and what this function does it takes a single parameter this parameter and when the function is",
    "start": "1928530",
    "end": "1936539"
  },
  {
    "text": "called it will use that parameter to deserialize some data structures and it",
    "start": "1936539",
    "end": "1942480"
  },
  {
    "text": "will deserialize those data structures into the address of a function to call indirectly now this function needs to be",
    "start": "1942480",
    "end": "1948539"
  },
  {
    "text": "a valid indirect call target but it will it'll take that address of that function and will also deserialize a list of",
    "start": "1948539",
    "end": "1955049"
  },
  {
    "text": "arguments and you control the number of arguments and the value of the arguments",
    "start": "1955049",
    "end": "1960440"
  },
  {
    "text": "so what this means is that I have now a primitive that will allow me to loop",
    "start": "1960440",
    "end": "1967320"
  },
  {
    "text": "through and make an unlimited number of indirect calls but also using this ndr server call to technique I can have full",
    "start": "1967320",
    "end": "1974640"
  },
  {
    "text": "control over the number of parameters and the value of the parameters that are made to those function calls and really",
    "start": "1974640",
    "end": "1981150"
  },
  {
    "text": "what this diagram is just illustrating is that we have these node structures that we loop through and we overlay an",
    "start": "1981150",
    "end": "1986580"
  },
  {
    "text": "RPC message structure on top of it which is the structure that the ndr server call to function is expecting the first",
    "start": "1986580",
    "end": "1993030"
  },
  {
    "text": "parameter of both of these structures the node and the RPC message is a V table so that aligns well and the only",
    "start": "1993030",
    "end": "2000200"
  },
  {
    "text": "other parameter that actually matters in node structure to do this looping through a linked list is a next field",
    "start": "2000200",
    "end": "2007940"
  },
  {
    "text": "which is an offset 58 but the RPC message itself is only hex 50 bytes big",
    "start": "2007940",
    "end": "2015679"
  },
  {
    "text": "which means that you can safely overlay these two structures and none of the",
    "start": "2015679",
    "end": "2021260"
  },
  {
    "text": "fields conflict with each other alright the last gadget that I found that I",
    "start": "2021260",
    "end": "2028370"
  },
  {
    "start": "2024000",
    "end": "2060000"
  },
  {
    "text": "needed was this mem copy gadget so this is once again a function that is an indirect call target and it uses the",
    "start": "2028370",
    "end": "2035270"
  },
  {
    "text": "parameters that are passed to it to make a call to mem copy and what this ends up",
    "start": "2035270",
    "end": "2040640"
  },
  {
    "text": "giving me is an arbitrary read/write primitive because I control the source the destination and the size of that",
    "start": "2040640",
    "end": "2046640"
  },
  {
    "text": "call to mem copy however there is this Evette that I can only are caveat that I",
    "start": "2046640",
    "end": "2053030"
  },
  {
    "text": "that I can only make this call to mem copy when the virtual machine reboots",
    "start": "2053030",
    "end": "2060879"
  },
  {
    "start": "2060000",
    "end": "2114000"
  },
  {
    "text": "but I figure with this I can probably get a working exploit the strategy that",
    "start": "2063399",
    "end": "2069800"
  },
  {
    "text": "I figured I'd use is first I'm going to get this arbitrary read/write primitive and I get that using this mem copy",
    "start": "2069800",
    "end": "2075080"
  },
  {
    "text": "gadget then I need to leak the address of kernel base and the reason I need to",
    "start": "2075080",
    "end": "2080540"
  },
  {
    "text": "leak the address of kernel base is because I want to call the function virtual protect I'm going to use virtual",
    "start": "2080540",
    "end": "2086000"
  },
  {
    "text": "protect to make the control flow guard check function pointer writable this is the function that gets called every time",
    "start": "2086000",
    "end": "2093230"
  },
  {
    "text": "you need to validate if some function is a valid indirect call target or not so I make that function pointer writable and",
    "start": "2093230",
    "end": "2099170"
  },
  {
    "text": "then I override it with a function that always returns yes this is a valid indirect call target and then once",
    "start": "2099170",
    "end": "2107150"
  },
  {
    "text": "control flow guard is effectively neutralized I can make indirect calls anywhere I want so I can make an indirect call to",
    "start": "2107150",
    "end": "2112640"
  },
  {
    "text": "kick off a rope chain so that's exactly what I did the first thing I need to do",
    "start": "2112640",
    "end": "2117980"
  },
  {
    "text": "of course is I need to read the target heap and I need to find the address of RPC rt4 com base and the video dirt",
    "start": "2117980",
    "end": "2123980"
  },
  {
    "text": "listener object and it's worth noting that well these these offsets are",
    "start": "2123980",
    "end": "2129830"
  },
  {
    "text": "typically fixed so like the offset between the vram buffer and the target heap is typically fixed it's",
    "start": "2129830",
    "end": "2136400"
  },
  {
    "text": "100% of the time so so this will fail sometimes and you know the the video",
    "start": "2136400",
    "end": "2145160"
  },
  {
    "text": "dirt listener object itself is not always allocated in target keep and if it's not allocated in the target heap",
    "start": "2145160",
    "end": "2150170"
  },
  {
    "text": "then I need to restart the VM and try again and every time I have to restart the VM and try again that's just one",
    "start": "2150170",
    "end": "2156680"
  },
  {
    "text": "more chance for this whole thing to fail right because I'm gonna have to go and refine the target heap but it might not",
    "start": "2156680",
    "end": "2161779"
  },
  {
    "text": "actually be there and then I crash so it's worth calling out that this is actually less reliable than the previous",
    "start": "2161779",
    "end": "2168410"
  },
  {
    "text": "exploit anyway so I go I find these",
    "start": "2168410",
    "end": "2173450"
  },
  {
    "text": "addresses and the next thing I'm going to do is I need to create this mem copy payload so that I can have my arbitrary readwrite but there's a problem just",
    "start": "2173450",
    "end": "2180589"
  },
  {
    "text": "that this is triggered when the virtual machine is rebooting and the trap cache buffer and the vram buffer are both",
    "start": "2180589",
    "end": "2187400"
  },
  {
    "text": "going to be freed as part of the virtual machine rebooting most of the allocations in the target he are going",
    "start": "2187400",
    "end": "2192980"
  },
  {
    "text": "to be freed as part of the virtual machine rebooting and I am NOT I have no ability to interact with the with the VM",
    "start": "2192980",
    "end": "2202339"
  },
  {
    "text": "worker process while that payload is executing because when I restart the VM all of the virtual processors of that VM",
    "start": "2202339",
    "end": "2210200"
  },
  {
    "text": "are stopped and so I just have to wait for this payload to execute and then when the virtual machine reboots that",
    "start": "2210200",
    "end": "2216140"
  },
  {
    "text": "mem copy better have copied the data to someplace that I can read it now one",
    "start": "2216140",
    "end": "2222890"
  },
  {
    "text": "convenient thing for me is that while most of those target heap allocations get freed the target heap itself does",
    "start": "2222890",
    "end": "2228470"
  },
  {
    "text": "not get freed and the target heap starts with this structure it's called the heap segment header and inside of that heap",
    "start": "2228470",
    "end": "2235309"
  },
  {
    "text": "segment header there is a field that is not used at least when the VM worker",
    "start": "2235309",
    "end": "2240799"
  },
  {
    "text": "process is running it's eight bytes big and so so that's a place where I could",
    "start": "2240799",
    "end": "2246859"
  },
  {
    "text": "copy data and it will persist the VM rebooting when the VM turns back on that target heap heap segment will still",
    "start": "2246859",
    "end": "2254450"
  },
  {
    "text": "exist and it will have the data that was copied there so I use this mem copy",
    "start": "2254450",
    "end": "2259730"
  },
  {
    "text": "payload to go and copy data into the target heap and the data that I'm going",
    "start": "2259730",
    "end": "2264890"
  },
  {
    "text": "to copy there is the is it's an IAT entry from Rp",
    "start": "2264890",
    "end": "2270130"
  },
  {
    "text": "TRT four and it's an IP or it's an IAT entry for Colonel base for a colonel",
    "start": "2270130",
    "end": "2275349"
  },
  {
    "text": "base function so this effectively allows me to leak the address of Colonel base so I restart the virtual machine that",
    "start": "2275349",
    "end": "2282160"
  },
  {
    "text": "address gets copied in the target heat and then when the virtual machine reboots the track cache buffer and the",
    "start": "2282160",
    "end": "2287950"
  },
  {
    "text": "vram buffer get reallocated and luckily for me those bottom-up allocations that",
    "start": "2287950",
    "end": "2294220"
  },
  {
    "text": "are made by virtual alik are very predictable right because we want to have very minimal fragmentation in the",
    "start": "2294220",
    "end": "2300430"
  },
  {
    "text": "address space and that means that the track cache buffer and the vram buffer are usually going to be reallocated in",
    "start": "2300430",
    "end": "2306220"
  },
  {
    "text": "the exact same spot that they were before which means that I can then trigger the bug again I can do this out",
    "start": "2306220",
    "end": "2312400"
  },
  {
    "text": "of bounds read and I can go and read the target heap and I can read that Colonel",
    "start": "2312400",
    "end": "2320109"
  },
  {
    "text": "base address out of the the heap segment header I also need to rescan the target heap to find a new video dirt listener",
    "start": "2320109",
    "end": "2327549"
  },
  {
    "text": "object because the video dirt listeners all got freed and then reallocated so I find that new video dirt listener object",
    "start": "2327549",
    "end": "2334150"
  },
  {
    "text": "and now that I know the address of the colonel base dll I can compute the address that the virtual protect",
    "start": "2334150",
    "end": "2340660"
  },
  {
    "text": "function is located inside of it if you wanted to be a little bit more professional I guess you would probably",
    "start": "2340660",
    "end": "2346450"
  },
  {
    "text": "go and read the export address table of the colonel base DLL so that you",
    "start": "2346450",
    "end": "2352390"
  },
  {
    "text": "wouldn't need to have hard-coded offsets but I didn't have time to do that now",
    "start": "2352390",
    "end": "2357990"
  },
  {
    "text": "that I know the address of the virtual protect function I'm going to create my final payload what this payload is going",
    "start": "2359069",
    "end": "2365920"
  },
  {
    "text": "to do is it's going to first call virtual protect and the reason that I can call virtual protect is because it",
    "start": "2365920",
    "end": "2372369"
  },
  {
    "text": "is a dll export and by default all DLL exports are valid in direct call targets",
    "start": "2372369",
    "end": "2381450"
  },
  {
    "text": "so I'm going to call virtual protect with parameters I control to make that CFG check function pointer writable I'm",
    "start": "2381450",
    "end": "2387579"
  },
  {
    "text": "going to use the mem copy gadget to overwrite the CFG check function pointer with a no op function and now that",
    "start": "2387579",
    "end": "2395170"
  },
  {
    "text": "control flow guard is neutralized I can go ahead and kick off a rope chain so I",
    "start": "2395170",
    "end": "2400599"
  },
  {
    "text": "used a relative read pipe I use the relative write primitive to go and right the new video dirt listener object",
    "start": "2400599",
    "end": "2405700"
  },
  {
    "text": "with this payload and I guess it's worth mentioning that this payload was fairly",
    "start": "2405700",
    "end": "2412690"
  },
  {
    "start": "2406000",
    "end": "2438000"
  },
  {
    "text": "simple due to all of the explanations that have been applied to the VM worker process any payload you write has to be",
    "start": "2412690",
    "end": "2419320"
  },
  {
    "text": "full Rob and I didn't really have time to go and create a super complicated raw",
    "start": "2419320",
    "end": "2425830"
  },
  {
    "text": "payload and so I opted to do something a bit easier which is that I just wrote a",
    "start": "2425830",
    "end": "2430900"
  },
  {
    "text": "raw payload that would go and create a new folder on the hard drive just that I could demonstrate that I do in fact have",
    "start": "2430900",
    "end": "2436180"
  },
  {
    "text": "arbitrary code execution go ahead and demo this one now so I'm once again",
    "start": "2436180",
    "end": "2447820"
  },
  {
    "start": "2438000",
    "end": "2501000"
  },
  {
    "text": "going to run this exploit but now I'm running on a 1709 host and the screen is gonna shift in a second here and that's",
    "start": "2447820",
    "end": "2453820"
  },
  {
    "text": "because reading the whole heap takes quite a while with this exploit and I don't think that everyone wants to sit",
    "start": "2453820",
    "end": "2459010"
  },
  {
    "text": "here for 20 minutes watching this thing scan the heap so I fast forward so yep",
    "start": "2459010",
    "end": "2464470"
  },
  {
    "text": "the window shifts we fast forwarded it's almost done reading the heap and it's presumably going to find the ARP CRT for",
    "start": "2464470",
    "end": "2471460"
  },
  {
    "text": "address the com base address and a video direct listener object address and it",
    "start": "2471460",
    "end": "2477220"
  },
  {
    "text": "does so now I'm going to start",
    "start": "2477220",
    "end": "2484960"
  },
  {
    "text": "corrupting that video turret listener object so it's going to build the payload that will end up leaking the",
    "start": "2484960",
    "end": "2490960"
  },
  {
    "text": "kernel base address for me that payload has been written so we need to restart",
    "start": "2490960",
    "end": "2496960"
  },
  {
    "text": "the virtual machine to kick that payload off alright so the virtual machine has",
    "start": "2496960",
    "end": "2504460"
  },
  {
    "start": "2501000",
    "end": "2583000"
  },
  {
    "text": "rebooted now and then the next thing that we need to do is go and recover the",
    "start": "2504460",
    "end": "2509890"
  },
  {
    "text": "kernel based address that was leapt and then build this second payload which neutralizes control flow guard and kicks",
    "start": "2509890",
    "end": "2515260"
  },
  {
    "text": "off the raw payload so once again it needs to go and read the heap so I'm",
    "start": "2515260",
    "end": "2521530"
  },
  {
    "text": "going to fast forward here so that we're not here all day it finds everything it needs it finds the video turret listener",
    "start": "2521530",
    "end": "2526990"
  },
  {
    "text": "object it finds the address of kernel base and then it's going to go and write",
    "start": "2526990",
    "end": "2534190"
  },
  {
    "text": "this next payload into the video dirt listener object",
    "start": "2534190",
    "end": "2538170"
  },
  {
    "text": "and it takes a little while the ndr server called to technique",
    "start": "2543240",
    "end": "2548920"
  },
  {
    "text": "requires I think around a thousand bytes per virtual call that you want to make",
    "start": "2548920",
    "end": "2554170"
  },
  {
    "text": "and my primitive is fairly slow for writing so writing about 3,000 bytes",
    "start": "2554170",
    "end": "2559359"
  },
  {
    "text": "takes a bit of time because I mean I'm making three virtual calls but I finished writing and I restart the",
    "start": "2559359",
    "end": "2565690"
  },
  {
    "text": "virtual machine again and the payload will get kicked off and I've created a new folder on the C Drive so I have",
    "start": "2565690",
    "end": "2571990"
  },
  {
    "text": "arbitrary code execution now the VM",
    "start": "2571990",
    "end": "2586509"
  },
  {
    "start": "2583000",
    "end": "2628000"
  },
  {
    "text": "worker process was originally designed with least privilege in mind however it was it was built quite a while ago and",
    "start": "2586509",
    "end": "2592569"
  },
  {
    "text": "so it it doesn't have all of the latest and greatest sandboxing technologies on Windows it runs with a unique SID not as",
    "start": "2592569",
    "end": "2600009"
  },
  {
    "text": "the system at counter network service but thus it runs under is part of authenticated users so it has access to",
    "start": "2600009",
    "end": "2605559"
  },
  {
    "text": "quite a lot of files on the system and at the time it had se impersonate privilege and a couple other sensitive",
    "start": "2605559",
    "end": "2611739"
  },
  {
    "text": "privileges and having se impersonate privilege effectively means that you can",
    "start": "2611739",
    "end": "2617200"
  },
  {
    "text": "automatically elevate to system so achieving system privilege was a matter",
    "start": "2617200",
    "end": "2622509"
  },
  {
    "text": "of writing a big rot payload and I didn't really want to do that so I didn't but that's how that's how you",
    "start": "2622509",
    "end": "2629049"
  },
  {
    "start": "2628000",
    "end": "2734000"
  },
  {
    "text": "would do it if you wanted to now let's talk about what we've learned from this write because I said that I wanted to",
    "start": "2629049",
    "end": "2635170"
  },
  {
    "text": "show you how impactful some of these bug reports can be one of the things we learned is that writing exploits against",
    "start": "2635170",
    "end": "2640569"
  },
  {
    "text": "the latest version of Windows is a lot harder and also in this case it was a lot less reliable it took me about three",
    "start": "2640569",
    "end": "2646450"
  },
  {
    "text": "days to get the exploit working for Server 2012 r2 and it took me upwards of 20 days to get it working on 1709 which",
    "start": "2646450",
    "end": "2654009"
  },
  {
    "text": "was the latest version of Windows at the time for 2012 r2 it was about 40 percent reliable and for 1709 after 20 days of",
    "start": "2654009",
    "end": "2661269"
  },
  {
    "text": "work it was like well under 10 percent reliable and I'm sure that there are",
    "start": "2661269",
    "end": "2666400"
  },
  {
    "text": "some things that you could do to make the exploit more reliable but that just means more to Element time so you're gonna increase",
    "start": "2666400",
    "end": "2673150"
  },
  {
    "text": "that time too right exploit and I'm personally fairly confident that there's no way that you could make this",
    "start": "2673150",
    "end": "2678160"
  },
  {
    "text": "completely reliable things that hurt reliability were one since I had to go",
    "start": "2678160",
    "end": "2683560"
  },
  {
    "text": "in the heap I couldn't corrupt the stack anymore sometimes I would run into guard pages so that would cause me to crash the",
    "start": "2683560",
    "end": "2689680"
  },
  {
    "text": "other thing was that I now have to run the exploit at least two times because I have to pay loads that need to execute",
    "start": "2689680",
    "end": "2696099"
  },
  {
    "text": "and every time I run the payload or every time I try to go out of balance I",
    "start": "2696099",
    "end": "2702430"
  },
  {
    "text": "might not find the heap I'm looking for and and I just crash and so every time I",
    "start": "2702430",
    "end": "2707560"
  },
  {
    "text": "have to do that it just once again adds to the unreliability of the exploit and while CFG certainly isn't perfect",
    "start": "2707560",
    "end": "2714880"
  },
  {
    "text": "because CFG was in place I couldn't just go and corrupt any arbitrary function pointer that I saw in the heap I had to",
    "start": "2714880",
    "end": "2721420"
  },
  {
    "text": "go and look for very specific objects in the heap that I could use to build these primitives and sometimes those objects",
    "start": "2721420",
    "end": "2726940"
  },
  {
    "text": "weren't in the heap and so I have to reboot the virtual machine and look again and just once again risk crashing looking for these objects that",
    "start": "2726940",
    "end": "2733480"
  },
  {
    "text": "I need let's talk about language safety one of the things that we've been really",
    "start": "2733480",
    "end": "2738640"
  },
  {
    "start": "2734000",
    "end": "2792000"
  },
  {
    "text": "interested in lately is how we can just eliminate vulnerabilities from our products and as I mentioned I had",
    "start": "2738640",
    "end": "2744579"
  },
  {
    "text": "stopped pen testing this component to go import GSL span into it and when we saw",
    "start": "2744579",
    "end": "2750250"
  },
  {
    "text": "that GSL span actually killed the bug that was a great signal to the hyper-v team and other groups in Microsoft that",
    "start": "2750250",
    "end": "2756940"
  },
  {
    "text": "using things like GSL span is absolutely worthwhile it can save us from really nasty issues and in addition to that the",
    "start": "2756940",
    "end": "2765280"
  },
  {
    "text": "visual studio team spent a pretty decent amount of time going and optimizing span for us so that we could use it without",
    "start": "2765280",
    "end": "2771339"
  },
  {
    "text": "risking impacting performance in some of these components if you look at hyper-v",
    "start": "2771339",
    "end": "2776589"
  },
  {
    "text": "code today there is over 200 files that have GSL span being used in them which is pretty awesome and I honestly think",
    "start": "2776589",
    "end": "2783700"
  },
  {
    "text": "that a lot of that can really be attributed to this bug report and this exploit that was written because without",
    "start": "2783700",
    "end": "2789220"
  },
  {
    "text": "that we would just think it was a cool technology we've also been doing other",
    "start": "2789220",
    "end": "2794890"
  },
  {
    "start": "2792000",
    "end": "2811000"
  },
  {
    "text": "work to eliminate bug classes so we've been aggressively killing uninitialized bugs and Windows we've been using safer",
    "start": "2794890",
    "end": "2800349"
  },
  {
    "text": "language features and our products we've been using static analysis like Cemil to go and eliminate specific bug",
    "start": "2800349",
    "end": "2806110"
  },
  {
    "text": "patterns in our code and we've also been investigating just using safer languages like rust Sam boxing is another",
    "start": "2806110",
    "end": "2814210"
  },
  {
    "start": "2811000",
    "end": "2863000"
  },
  {
    "text": "interesting thing to talk about virtualization is absolutely the best sandbox that we have built at this point",
    "start": "2814210",
    "end": "2820120"
  },
  {
    "text": "however the worker process is designed to run with lease privilege it doesn't need system privilege and so one of the",
    "start": "2820120",
    "end": "2826870"
  },
  {
    "text": "things that we started investigating after we got this bug report was if it would make sense to go and put the VM",
    "start": "2826870",
    "end": "2833350"
  },
  {
    "text": "worker process in a stronger sandbox just to add another layer of defense and depth so that you wouldn't just need a",
    "start": "2833350",
    "end": "2838810"
  },
  {
    "text": "worker process bug but you would also need a sandbox escape on top of that we've done a lot of work in that area we",
    "start": "2838810",
    "end": "2844870"
  },
  {
    "text": "don't have anything that's production ready yet but we do have working prototypes that work for specific scenarios and we also went ahead and",
    "start": "2844870",
    "end": "2852220"
  },
  {
    "text": "removed se impersonate privilege and some other sensitive privileges from the worker process in the meantime and this",
    "start": "2852220",
    "end": "2858730"
  },
  {
    "text": "is once again work that was really motivated by the bug report that we got",
    "start": "2858730",
    "end": "2864150"
  },
  {
    "text": "related to that we've seen that basically exploits that we've written for this hyper-v user mode component and",
    "start": "2864150",
    "end": "2871000"
  },
  {
    "text": "kernel mode components in hyper-v we can see that the user mode components are a lot harder to attack the exploit",
    "start": "2871000",
    "end": "2877420"
  },
  {
    "text": "mitigations are more robust in user mode we have the ability to use safer languages like safe C++ features or rust",
    "start": "2877420",
    "end": "2884230"
  },
  {
    "text": "etc and of course we do have potential for extreme sandboxing in user mode if we choose to you know really go through",
    "start": "2884230",
    "end": "2890380"
  },
  {
    "text": "with that and so as a result of this the hyper-v team has been investigating moving some of their kernel components",
    "start": "2890380",
    "end": "2896920"
  },
  {
    "text": "into user mode so that we can take advantage of those benefits more and finally as you would expect whenever we",
    "start": "2896920",
    "end": "2904030"
  },
  {
    "text": "write an exploit we use that to evaluate how our exploit mitigations are doing in general one thing we noticed was that",
    "start": "2904030",
    "end": "2909910"
  },
  {
    "text": "this exploit took advantage of indirectly calling DLL exports and we actually had a feature at the time",
    "start": "2909910",
    "end": "2915370"
  },
  {
    "text": "called export suppression which prevents that so we went ahead and turned that on for the VM worker process and now part",
    "start": "2915370",
    "end": "2921520"
  },
  {
    "text": "of the technique that I used for 1709 is broken and you'd have to go back to the drawing board there we also have a new",
    "start": "2921520",
    "end": "2927490"
  },
  {
    "text": "version of CFG that dave wesson announced at blue hat shanghai called xfg and when xfg was being worked on we",
    "start": "2927490",
    "end": "2934960"
  },
  {
    "text": "went and looked to see how xfg would imp this particular exploit and we can clearly see that xfg would make this",
    "start": "2934960",
    "end": "2941560"
  },
  {
    "text": "exploit substantially harder to pull off because the function signatures would no longer match between the indirect call",
    "start": "2941560",
    "end": "2948130"
  },
  {
    "text": "target and the indirect call site and we also use this just to look at potential cpu features that we're working on such",
    "start": "2948130",
    "end": "2955330"
  },
  {
    "text": "as or not necessarily working on but just considering as future options so we might look and see how would memory",
    "start": "2955330",
    "end": "2961780"
  },
  {
    "text": "tagging impact this how would something like Cherry impact this etc so it really goes and helps us dive into future",
    "start": "2961780",
    "end": "2968560"
  },
  {
    "text": "investments that we should make so my point here is that your bug reports all matter and not all of them result in us",
    "start": "2968560",
    "end": "2975220"
  },
  {
    "text": "going and building a full chain exploit for one of our products but at the very minimum we use all of this data to",
    "start": "2975220",
    "end": "2981910"
  },
  {
    "text": "analyze bug trends and figure out where we're currently lagging and where we need to invest more and some of the some",
    "start": "2981910",
    "end": "2988570"
  },
  {
    "text": "of the vulnerability reports and exploit reports that we see are used to drive really big investments in our products",
    "start": "2988570",
    "end": "2994500"
  },
  {
    "text": "now as I noted we paid six hundred and twenty-five thousand dollars since last blackhat and hyper-v bounties and 4.4",
    "start": "2994500",
    "end": "3001050"
  },
  {
    "text": "million dollars in bounties total so please participate in the hyper-v bounty we want submissions and also please",
    "start": "3001050",
    "end": "3007920"
  },
  {
    "start": "3003000",
    "end": "3012000"
  },
  {
    "text": "participate in the other bounty programs that we have I'm out of time thank you",
    "start": "3007920",
    "end": "3014509"
  }
]