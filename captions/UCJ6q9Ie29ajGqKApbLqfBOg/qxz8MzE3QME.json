[
  {
    "start": "0",
    "end": "35000"
  },
  {
    "text": "welcome everybody just make sure you're in the right spot you're in for the Zen poem breaking para para virtualized",
    "start": "30",
    "end": "7109"
  },
  {
    "text": "devices with Felix Vilhelm in Mandalay Bay gh a couple things housekeeping you",
    "start": "7109",
    "end": "13799"
  },
  {
    "text": "probably heard these before stop by the business hall located in Bayside a B during the day and for the Welcome Reception from 1730 to 1900 tonight the",
    "start": "13799",
    "end": "22410"
  },
  {
    "text": "black how black hat Arsenal is in the palm foyer on level three the pony Awards are in Mandalay Bay BCD at 18:30",
    "start": "22410",
    "end": "29640"
  },
  {
    "text": "and don't forget to put your phones on vibrate okay hi everyone and welcome to my talk",
    "start": "29640",
    "end": "37920"
  },
  {
    "text": "xn pound breaking power virtualize devices so before I start with the",
    "start": "37920",
    "end": "43440"
  },
  {
    "text": "interesting content of the presentation I have a short introduction slide about myself so I'm security researcher",
    "start": "43440",
    "end": "50280"
  },
  {
    "text": "working at Ian W research which is a small penetration testing company located in Heidelberg Germany I'm mostly",
    "start": "50280",
    "end": "59370"
  },
  {
    "text": "concentrate on application and virtualization security and the recent published research mostly focus on two",
    "start": "59370",
    "end": "66960"
  },
  {
    "text": "different areas security blinds this on the one hand side so I did some some",
    "start": "66960",
    "end": "72869"
  },
  {
    "text": "research on paralyzer firewalls couple of months ago and on the fire I'm a",
    "start": "72869",
    "end": "78060"
  },
  {
    "text": "protection system in the summer of last year sync and besides that I'm mostly",
    "start": "78060",
    "end": "84420"
  },
  {
    "text": "concentrating on hypervisor security so low-level virtualization security for",
    "start": "84420",
    "end": "89610"
  },
  {
    "text": "that the recent years mostly concentrating on the Zen hypervisor yeah",
    "start": "89610",
    "end": "94950"
  },
  {
    "text": "you can also find me on Twitter I'm not that active but I'm always happy about more follower so agenda for today's talk",
    "start": "94950",
    "end": "103829"
  },
  {
    "text": "I give a short introduction what's device virtualization and what our power virtualize devices so the term",
    "start": "103829",
    "end": "110579"
  },
  {
    "text": "paravirtualized devices comes from the Zen hypervisor but as we will learn it's the concept or the same technique",
    "start": "110579",
    "end": "118079"
  },
  {
    "text": "technology is used in all mainstream hypervisors so even if the talk has sin",
    "start": "118079",
    "end": "123149"
  },
  {
    "text": "in the title or any subject this is not research that's completely focused on sin security instead it's something",
    "start": "123149",
    "end": "129750"
  },
  {
    "text": "that's relevant for all virtualization platforms and then I talk",
    "start": "129750",
    "end": "135599"
  },
  {
    "text": "about ability type I concentrate it on in my research and that's a so-called double fetch vulnerability I didn't find",
    "start": "135599",
    "end": "144000"
  },
  {
    "text": "that manually instead I developed the tool for that and the tool is called cent pound and the main part of the talk",
    "start": "144000",
    "end": "150360"
  },
  {
    "text": "I given in overview about the architecture of this tool and its design I used the tool on a couple of",
    "start": "150360",
    "end": "157319"
  },
  {
    "text": "hypervisors so I will present my results on that and then I have a single special",
    "start": "157319",
    "end": "162720"
  },
  {
    "text": "Park which i think is really interesting from a technical perspective and we do",
    "start": "162720",
    "end": "168630"
  },
  {
    "text": "full exploitation walkthrough including a full extent breakout by exploiting",
    "start": "168630",
    "end": "174630"
  },
  {
    "text": "this vulnerability so that's like the last part of the talk so starting with",
    "start": "174630",
    "end": "181650"
  },
  {
    "start": "180000",
    "end": "240000"
  },
  {
    "text": "device virtualization so at its core basically if you have a virtual system",
    "start": "181650",
    "end": "186780"
  },
  {
    "text": "you need access to virtual devices this can be like a disk or network device or",
    "start": "186780",
    "end": "192840"
  },
  {
    "text": "even like a serial port or something like that and traditionally you just used device emulation so if you look at",
    "start": "192840",
    "end": "200220"
  },
  {
    "text": "how QAM works older versions of VMware work they basically take an really old and well",
    "start": "200220",
    "end": "207000"
  },
  {
    "text": "supported hardware device and emulate it in software this has the advantage that",
    "start": "207000",
    "end": "212700"
  },
  {
    "text": "you're guest operating system so the virtual system does not need any special",
    "start": "212700",
    "end": "217739"
  },
  {
    "text": "drivers because these o devices are supported by almost any operating system",
    "start": "217739",
    "end": "222930"
  },
  {
    "text": "you can imagine so you don't need special drivers you can just install from the standard installation source",
    "start": "222930",
    "end": "229139"
  },
  {
    "text": "and the system will work and for example you have this this really old floppy",
    "start": "229139",
    "end": "234840"
  },
  {
    "text": "disk controller or something that's emulated in software now when you look",
    "start": "234840",
    "end": "241139"
  },
  {
    "text": "at the downsides of emulated devices you have a couple of them most importantly",
    "start": "241139",
    "end": "247280"
  },
  {
    "text": "they're incredibly hard to implement securely and correctly so if you look at",
    "start": "247280",
    "end": "254489"
  },
  {
    "text": "like the vulnerability history of this device emulations if you just look at the visibility statistics of the QM",
    "start": "254489",
    "end": "260870"
  },
  {
    "text": "codebase you would see a lot of low level memory corruption vulnerabilities because you are writing really low-level",
    "start": "260870",
    "end": "268270"
  },
  {
    "text": "code you're always writing it didn't see it's kind of hard to implement that",
    "start": "268270",
    "end": "273280"
  },
  {
    "text": "stuff correctly from a security perspective but also correctly from like the features you want to support and",
    "start": "273280",
    "end": "279970"
  },
  {
    "text": "device emulation is kind of slow because you can't use any advanced features that",
    "start": "279970",
    "end": "286360"
  },
  {
    "text": "were introduced like in the couple in the last years or something instead you are implementing a hardware device",
    "start": "286360",
    "end": "292750"
  },
  {
    "text": "that's kind of released somewhere in 90s we implemented in software so you don't have like a lot of speed of performance",
    "start": "292750",
    "end": "299980"
  },
  {
    "text": "you can work with and of course all the advanced features you might be interested in probably are not supported",
    "start": "299980",
    "end": "306520"
  },
  {
    "text": "by the roots in your device so you can't support an using device emulation so what you're going to do and what every",
    "start": "306520",
    "end": "313780"
  },
  {
    "text": "mainstream hypervisor is currently doing is you use paravirtualized devices and the idea of this is that you have",
    "start": "313780",
    "end": "320020"
  },
  {
    "text": "specialized device drivers that are optimized for use in virtual systems so",
    "start": "320020",
    "end": "326020"
  },
  {
    "text": "you still support emulated devices at least most of the hypervisor still support them but if a special device",
    "start": "326020",
    "end": "333880"
  },
  {
    "text": "running in its operating system Mike has",
    "start": "333880",
    "end": "340200"
  },
  {
    "text": "if a special guest driver is working in the in the virtual system then instead",
    "start": "340200",
    "end": "346390"
  },
  {
    "text": "of using the emulated device you're using the para virtualized devices the",
    "start": "346390",
    "end": "351970"
  },
  {
    "text": "term para virtualized devices is kind of interesting because Sen also has a concept called para virtualized domains",
    "start": "351970",
    "end": "358540"
  },
  {
    "text": "so they're kind of related but they're not similar so even if you have like hardware virtualized domain so",
    "start": "358540",
    "end": "364570"
  },
  {
    "text": "hardware-assisted virtualization in excel it will still use para virtualized devices and the same holds true for like",
    "start": "364570",
    "end": "370960"
  },
  {
    "text": "hyper-v and VMware and if you look at how these para virtualized devices are",
    "start": "370960",
    "end": "376630"
  },
  {
    "start": "374000",
    "end": "440000"
  },
  {
    "text": "actually implemented you moreless always have the same architecture so it's a",
    "start": "376630",
    "end": "381940"
  },
  {
    "text": "split driver model where you have a front-end that runs in the guest system so in the virtual machine and you have a",
    "start": "381940",
    "end": "389230"
  },
  {
    "text": "back end and the back end runs in the management domain so in X and it's would",
    "start": "389230",
    "end": "394510"
  },
  {
    "text": "be dumb su on hyper-v would be like your UVM host or your",
    "start": "394510",
    "end": "400580"
  },
  {
    "text": "privilege domain or partition and on on KVM it would simply be your host system",
    "start": "400580",
    "end": "406310"
  },
  {
    "text": "and so all these hypervisors use basically this model they call it",
    "start": "406310",
    "end": "412730"
  },
  {
    "text": "different differently so on extended code back end on front and on hyper-v",
    "start": "412730",
    "end": "418520"
  },
  {
    "text": "it's called virtualization service client virtualization service provider and KVM uses two viet io mechanism and",
    "start": "418520",
    "end": "427190"
  },
  {
    "text": "vio talks about devices and drivers but if you actually look how they are",
    "start": "427190",
    "end": "432560"
  },
  {
    "text": "implemented under the hood they are kind of similar so it's it's an interesting area to look at and one important",
    "start": "432560",
    "end": "441140"
  },
  {
    "start": "440000",
    "end": "559000"
  },
  {
    "text": "feature of this is that all these para virtualized devices are implemented on top of shared memory and the reason for",
    "start": "441140",
    "end": "447320"
  },
  {
    "text": "that of course is that you have a really great performance so you don't have to",
    "start": "447320",
    "end": "452420"
  },
  {
    "text": "copy your buffers a lot around if you just share memory between the virtual domain so the virtual system and the",
    "start": "452420",
    "end": "458900"
  },
  {
    "text": "host system because of course if you have like a virtual network out at some point the data the virtual system puts",
    "start": "458900",
    "end": "465800"
  },
  {
    "text": "inside the shared memory has to end in in the buffer of the network card but if",
    "start": "465800",
    "end": "471860"
  },
  {
    "text": "you use shared Maui you have a lot of less copies than if you would do something like a socket based message",
    "start": "471860",
    "end": "478070"
  },
  {
    "text": "passing or something like that it's also really easy to implement because your hypervisor already includes all this",
    "start": "478070",
    "end": "484280"
  },
  {
    "text": "memory mapping stuff so simply creating a shared memory mapping between the virtual machine and the hypervisor it's",
    "start": "484280",
    "end": "490610"
  },
  {
    "text": "not a lot of code and if you are really fancy you can actually try to implement completely zero copy algorithms so like",
    "start": "490610",
    "end": "497720"
  },
  {
    "text": "you never have to move buffers around a memory which leads to quite high",
    "start": "497720",
    "end": "503030"
  },
  {
    "text": "performance of course simply working with shared memory addresses or spaces",
    "start": "503030",
    "end": "509630"
  },
  {
    "text": "wouldn't be very comfortable to developer so they're kind of message",
    "start": "509630",
    "end": "514640"
  },
  {
    "text": "protocols implemented on top and forks and hyper-v and KVM user base is just",
    "start": "514640",
    "end": "520039"
  },
  {
    "text": "standard ring buffer so you start filling at the beginning and then you go go around and have like dedicated",
    "start": "520040",
    "end": "526760"
  },
  {
    "text": "message slots and there's implementation differences if you are",
    "start": "526760",
    "end": "531930"
  },
  {
    "text": "implementing these shared memory mappings constantly so for Sam you have this cramped table which is small as",
    "start": "531930",
    "end": "538380"
  },
  {
    "text": "constant after the virtual machine boots up or if you create them on demand so",
    "start": "538380",
    "end": "543450"
  },
  {
    "text": "while your per virtual eyes device is working you could say hey please map my memory at that address in the management",
    "start": "543450",
    "end": "551610"
  },
  {
    "text": "to me so this is kind of an overview about how these paravirtualized devices",
    "start": "551610",
    "end": "557580"
  },
  {
    "text": "work now the question is if you look at this this do these features from security perspective you will see it's",
    "start": "557580",
    "end": "565020"
  },
  {
    "start": "559000",
    "end": "773000"
  },
  {
    "text": "it's a really interesting attack surface because you dispatch and once in the privileged context so it is a runs on",
    "start": "565020",
    "end": "571560"
  },
  {
    "text": "the host system or and management domain and what it's important for sand or hyper-v if you own the management domain",
    "start": "571560",
    "end": "577920"
  },
  {
    "text": "he basically owned the whole system so it's not exactly like you'd be are not exploiting the hypervisor itself and",
    "start": "577920",
    "end": "584190"
  },
  {
    "text": "start you're trying to exploit the backend that operates in the management to me and if you get code execution",
    "start": "584190",
    "end": "590070"
  },
  {
    "text": "that's it's basically game over and so you have this communication between the front end and back end and that's a",
    "start": "590070",
    "end": "596910"
  },
  {
    "text": "trust boundary and then you have like a lot of low-level code again because so",
    "start": "596910",
    "end": "603150"
  },
  {
    "text": "you have this real buffer and on top of that of course you have protocols and",
    "start": "603150",
    "end": "608760"
  },
  {
    "text": "these protocols are more or less device specific so like the network the network",
    "start": "608760",
    "end": "613980"
  },
  {
    "text": "packet driver will speak like a different high level protocol than for example the disc back-end driver and all",
    "start": "613980",
    "end": "620310"
  },
  {
    "text": "these protocols are text surface the code that passes these protocols is again implemented in C so you have like",
    "start": "620310",
    "end": "627930"
  },
  {
    "text": "all the normal low level vulnerabilities you also see for like network demons or so from like pure security perspective",
    "start": "627930",
    "end": "635040"
  },
  {
    "text": "if you say your guest system is untrusted then all this backend code operates in exactly the same environment",
    "start": "635040",
    "end": "642210"
  },
  {
    "text": "and for example a network daemon because basically someone untrusted can send out heavy data over the shared memory",
    "start": "642210",
    "end": "648360"
  },
  {
    "text": "interface and a couple of bucks released in these back-end interfaces so for",
    "start": "648360",
    "end": "654270"
  },
  {
    "text": "example the KVM dispatch and had he based a fogger float it was disclosed in",
    "start": "654270",
    "end": "659400"
  },
  {
    "text": "2011 and I was just last year really interesting buffer overflow in the hyper-v starch",
    "start": "659400",
    "end": "666239"
  },
  {
    "text": "back-end which is also interesting because it was internally discovered by Microsoft researcher who got credit for",
    "start": "666239",
    "end": "674309"
  },
  {
    "text": "that in the Microsoft advisory so it was kind of an interesting will ability",
    "start": "674309",
    "end": "680009"
  },
  {
    "text": "release so now the question is why aren't there more than these parks or",
    "start": "680009",
    "end": "686309"
  },
  {
    "text": "why don't we see a lot of more vulnerabilities released in this area and it seems to be that this code isn't",
    "start": "686309",
    "end": "693029"
  },
  {
    "text": "a scrutinized as emulated devices there a couple of reasons for that I think one",
    "start": "693029",
    "end": "698069"
  },
  {
    "text": "of them is that all this code is device and hypervisor specific so you're not working with like standard stuff instead",
    "start": "698069",
    "end": "704759"
  },
  {
    "text": "if you want to attack like the k vm v 8 io backends you have to understand how",
    "start": "704759",
    "end": "710489"
  },
  {
    "text": "it all works how the different devices work and then even like sending fake",
    "start": "710489",
    "end": "716160"
  },
  {
    "text": "messages is not completely to review because you have to write your own car manual and stuff so it's kind of a bit",
    "start": "716160",
    "end": "722610"
  },
  {
    "text": "of work and it's always target specific so it's not something that you can generically targeted to your different",
    "start": "722610",
    "end": "729660"
  },
  {
    "text": "hypervisor and it's much harder to fast than simply emulated devices so for an",
    "start": "729660",
    "end": "735209"
  },
  {
    "text": "emulated device you have like this io port communication stuff so you're just writing to i/o ports maybe you have some",
    "start": "735209",
    "end": "742470"
  },
  {
    "text": "memory mapped i/o interfaces or something like that for a paravirtualized device you often have",
    "start": "742470",
    "end": "747779"
  },
  {
    "text": "like a complex protocol that's stateful so you have to like build up connection and stuff and of course if if your",
    "start": "747779",
    "end": "754589"
  },
  {
    "text": "virtual disk driver misbehaves it's kind of so you can assume that your virtual",
    "start": "754589",
    "end": "761399"
  },
  {
    "text": "machine won't survive that long so fuzzing this isn't like as trivial as",
    "start": "761399",
    "end": "767220"
  },
  {
    "text": "just like executing it I don't know bootable disk and fuzzing io pot a third",
    "start": "767220",
    "end": "773399"
  },
  {
    "text": "thing this stuff isn't very interesting target because nowadays if you look at how device emulation is done so if you",
    "start": "773399",
    "end": "779910"
  },
  {
    "text": "look at Huey or if you look at the VM worker process which is responsible for device emulation and hyper-v you will",
    "start": "779910",
    "end": "787499"
  },
  {
    "text": "see that this is often done in user space and it's done in user space in a heavily sandbox environment so normally",
    "start": "787499",
    "end": "794790"
  },
  {
    "text": "the VM process on the modern hyper-v environment has really heavily",
    "start": "794790",
    "end": "800170"
  },
  {
    "text": "restricted permissions so even if you explode it it's you need another bug to to completely compromise the host system",
    "start": "800170",
    "end": "807070"
  },
  {
    "text": "Huey Lewis is sandbox by using SELinux or something like that so again you need",
    "start": "807070",
    "end": "813430"
  },
  {
    "text": "another privilege escalation on the other hand if you look at these paravirtualized device patterns because",
    "start": "813430",
    "end": "818890"
  },
  {
    "text": "they're really performance critical they're implemented in the kernel for her performance so if you look at the",
    "start": "818890",
    "end": "824770"
  },
  {
    "text": "device backends or the network bagans of same kvn hyper-v they are all color",
    "start": "824770",
    "end": "830680"
  },
  {
    "text": "models or current drivers running in saticons base of the management domain and this means if you have code",
    "start": "830680",
    "end": "836800"
  },
  {
    "text": "execution it's an instant game over because any compromise to hold system and this paralyze devices are also",
    "start": "836800",
    "end": "845560"
  },
  {
    "text": "becoming more and more important so if you if you compare the performance of different hypervisors currently the main",
    "start": "845560",
    "end": "851980"
  },
  {
    "text": "performance difference you will see is actually the difference of these paravirtualized devices so if you",
    "start": "851980",
    "end": "858580"
  },
  {
    "text": "compare like the network traffic you can put through the MM machine and a hyper-v machine the difference we will see",
    "start": "858580",
    "end": "864730"
  },
  {
    "text": "strongly depends on performance of this paravirtualized device drivers so this",
    "start": "864730",
    "end": "870490"
  },
  {
    "text": "means they implement more features more optimizations so this code base is growing and not shrinking or not getting",
    "start": "870490",
    "end": "878320"
  },
  {
    "text": "sign books you also have like lot of more device types so for example use the PCI 3d acceleration and stuff like that",
    "start": "878320",
    "end": "887610"
  },
  {
    "text": "and then we have an interesting future development so if you look at hyper-v they actually introduced generation 2",
    "start": "887610",
    "end": "894160"
  },
  {
    "text": "VMs which completely remove emulated devices because they noticed this is",
    "start": "894160",
    "end": "900100"
  },
  {
    "text": "kind of an interesting attack surface so if you completely remove emulate device",
    "start": "900100",
    "end": "905530"
  },
  {
    "text": "support you only have to paralyze devices to to attack so what's the goal",
    "start": "905530",
    "end": "910690"
  },
  {
    "start": "910000",
    "end": "953000"
  },
  {
    "text": "of my research basically I wanted to find an efficient way it's so efficient vulnerability discovery in pervert lies",
    "start": "910690",
    "end": "917380"
  },
  {
    "text": "devices and what do I mean ficient the idea was I didn't want to spend too much",
    "start": "917380",
    "end": "922510"
  },
  {
    "text": "time in Ida or reading the source code instead I wanted to have some kind of automatic tool that helps",
    "start": "922510",
    "end": "928819"
  },
  {
    "text": "identifying vulnerabilities and Mike our idea was basically did you have or that",
    "start": "928819",
    "end": "934910"
  },
  {
    "text": "nobody ever presented any kind of research on the use of shared memory in the context of these paravirtualized",
    "start": "934910",
    "end": "941600"
  },
  {
    "text": "devices what's interesting about shared memory and there's a certain backlash",
    "start": "941600",
    "end": "947749"
  },
  {
    "text": "that only affects shared memory and that backlash is called double fetch so what",
    "start": "947749",
    "end": "953779"
  },
  {
    "text": "about that will fetch vulnerabilities there's special type of time of check to time of use vulnerability that affects",
    "start": "953779",
    "end": "959929"
  },
  {
    "text": "shared memory so like a simple definition would be you have a same memory address and memory trace is",
    "start": "959929",
    "end": "966679"
  },
  {
    "text": "accessed multiple times out of approval of context so from the back end but the",
    "start": "966679",
    "end": "972859"
  },
  {
    "text": "validation of the excess data is missing at least once so for example the back",
    "start": "972859",
    "end": "979100"
  },
  {
    "text": "end reads an integer out of a shared memory section and it fetches the value wants checks that would fit into an",
    "start": "979100",
    "end": "986539"
  },
  {
    "text": "upper boundary and then sometimes later it checks or it fetches the value a second time but it doesn't include to",
    "start": "986539",
    "end": "993859"
  },
  {
    "text": "check again so the upper bound or check and then you have classic time of check time to use back so you can simply erase",
    "start": "993859",
    "end": "1000909"
  },
  {
    "text": "or try to exploit the race condition to flip the value in between these two fetches the cool thing about double",
    "start": "1000909",
    "end": "1007239"
  },
  {
    "text": "fetch vulnerabilities is so disability class can lead to a lot of powerful exploit primitives depending on the kind",
    "start": "1007239",
    "end": "1014619"
  },
  {
    "text": "of bug because sometimes you can just like skip over certain checks so this can lead to arbitrary reads arbitrary",
    "start": "1014619",
    "end": "1020889"
  },
  {
    "text": "writes buffer overflows or even like direct control or an instruction pointer as we will see later on during my demo",
    "start": "1020889",
    "end": "1028620"
  },
  {
    "text": "so some history like the term double fetch was actually coined by from",
    "start": "1028620",
    "end": "1034288"
  },
  {
    "start": "1030000",
    "end": "1086000"
  },
  {
    "text": "Indiana in 2008 in a blog post on Microsoft Research blog I think but the",
    "start": "1034289",
    "end": "1040990"
  },
  {
    "text": "back class itself is well known before that it's just like the term double fetch that was introduced there the",
    "start": "1040990",
    "end": "1047438"
  },
  {
    "text": "first wave of research and ended on this backlash was published in 2007 and 2008",
    "start": "1047439",
    "end": "1052899"
  },
  {
    "text": "so there was a really good paper do use mix 2007 on exploiting concurrency",
    "start": "1052899",
    "end": "1058299"
  },
  {
    "text": "vulnerabilities in system call APIs which talked about this kind of issue and then the most presentation at cccc",
    "start": "1058299",
    "end": "1065290"
  },
  {
    "text": "and two famous fact paper but this Enescu yahoo where they also talked",
    "start": "1065290",
    "end": "1071290"
  },
  {
    "text": "about these bug types the first example of a bug that actually fits this double",
    "start": "1071290",
    "end": "1077410"
  },
  {
    "text": "fetch pair Dickman is sent message to new york spot which allowed print",
    "start": "1077410",
    "end": "1082570"
  },
  {
    "text": "escalation in 2005 so i also have an example for this one so in this kind of",
    "start": "1082570",
    "end": "1088210"
  },
  {
    "start": "1086000",
    "end": "1154000"
  },
  {
    "text": "shared memory interface is like the user space because if you have like user space kernel communication then you can",
    "start": "1088210",
    "end": "1094960"
  },
  {
    "text": "think about the user space as a shared memory interface because the kernel can access it but at the same time the user",
    "start": "1094960",
    "end": "1100900"
  },
  {
    "text": "space can still manipulate it and basically you had the problem is that you have two fetches to this uscm len",
    "start": "1100900",
    "end": "1110980"
  },
  {
    "text": "variable so you have this get user wrapper which copies data out of the user space and at the first mark line",
    "start": "1110980",
    "end": "1117640"
  },
  {
    "text": "it's copied into the UCM land buyer and then it's used to perform a heap allocation or depending on the size it's",
    "start": "1117640",
    "end": "1124690"
  },
  {
    "text": "the heap allocation or start under step and i'm a couple of lines later they've touched the value again at the same",
    "start": "1124690",
    "end": "1131470"
  },
  {
    "text": "address and use it as the size parameter of a copy from user call and of course",
    "start": "1131470",
    "end": "1138100"
  },
  {
    "text": "an attacker can simply flip the value in between these two cards and then you have a trivial stack based overflow or",
    "start": "1138100",
    "end": "1144820"
  },
  {
    "text": "heap overflow depending on on the size George needed pass so this is like the",
    "start": "1144820",
    "end": "1150280"
  },
  {
    "text": "first example of of these bugs now a couple of years later there was this",
    "start": "1150280",
    "end": "1155290"
  },
  {
    "start": "1154000",
    "end": "1264000"
  },
  {
    "text": "really interesting research box pound it published by you and given well and they",
    "start": "1155290",
    "end": "1162610"
  },
  {
    "text": "released the paper identifying and exploiting Windows kernel waste conditions by a memory access patterns",
    "start": "1162610",
    "end": "1168310"
  },
  {
    "text": "and the idea was basically they wanted to identify these Terra fetch vulnerabilities but using an extended",
    "start": "1168310",
    "end": "1175240"
  },
  {
    "text": "version of the Box CPU emulator to trace all memory accesses from kernel",
    "start": "1175240",
    "end": "1180610"
  },
  {
    "text": "traitorous to users please so they look at every memory access from color to user space and if they see multiple",
    "start": "1180610",
    "end": "1186640"
  },
  {
    "text": "memory accesses to the same at verse in a short time frame they might have double fetch availability so box",
    "start": "1186640",
    "end": "1194740"
  },
  {
    "text": "resulted in the second a number of women's parks so they looked at I'd I only looked at local foods",
    "start": "1194740",
    "end": "1200980"
  },
  {
    "text": "escalations in their OS context so kernel vulnerabilities and there are some on aware this is a bounty for most",
    "start": "1200980",
    "end": "1207400"
  },
  {
    "text": "innovative research but interestingly there wasn't so they also released like the whole tool is open source but nobody",
    "start": "1207400",
    "end": "1214990"
  },
  {
    "text": "really followed up on this so you don't see a lot of follow-up research using that tool and then we also released like",
    "start": "1214990",
    "end": "1223480"
  },
  {
    "text": "a really detailed by paper that contains an analysis when these double factors",
    "start": "1223480",
    "end": "1229510"
  },
  {
    "text": "become exploitable and to make it short or just summarize it in one sentence if you have a multi-car system so like the",
    "start": "1229510",
    "end": "1236410"
  },
  {
    "text": "the system has multiple CPU cores available then even if you shot your aces extremely short this type of bugs",
    "start": "1236410",
    "end": "1244240"
  },
  {
    "text": "are exploitable which is perfectly fine for my use case because normally in like",
    "start": "1244240",
    "end": "1250060"
  },
  {
    "text": "if you are operating in a virtual machine you probably have more than one CPU core available as you might notice",
    "start": "1250060",
    "end": "1256780"
  },
  {
    "text": "from the name of my talk box pound was the main inspiration for this research and they found a lot of interesting bugs",
    "start": "1256780",
    "end": "1263320"
  },
  {
    "text": "so one example of availability they found and this is in the in the Windows kernel so you don't we don't have source",
    "start": "1263320",
    "end": "1270220"
  },
  {
    "start": "1264000",
    "end": "1337000"
  },
  {
    "text": "code available for this but you can see in the first line so they eat EDI",
    "start": "1270220",
    "end": "1276190"
  },
  {
    "text": "register points into user space so they go to the hex offset 18 of EDI and fetch",
    "start": "1276190",
    "end": "1282730"
  },
  {
    "text": "value into e 6 they then use this ec x value as an argument to probe for right",
    "start": "1282730",
    "end": "1289780"
  },
  {
    "text": "and basically what probe for right is a dust check if that's a valid user space pointer so if the kernel should write",
    "start": "1289780",
    "end": "1296950"
  },
  {
    "text": "into there or if it's the address that's pointing into the kernel space because then you could have trigger memory",
    "start": "1296950",
    "end": "1302680"
  },
  {
    "text": "crunch so they have this check to probe for right and after that they take all mem copy",
    "start": "1302680",
    "end": "1310000"
  },
  {
    "text": "with the same user space to trace again as a length parameter as destination",
    "start": "1310000",
    "end": "1316390"
  },
  {
    "text": "parameter so but the problem of causes they perform a memory fetch a second time so between line 1 and between line",
    "start": "1316390",
    "end": "1323980"
  },
  {
    "text": "9 you have like this waste condition again where you can flip a different value in there and perform arbitrary memory corruption",
    "start": "1323980",
    "end": "1331309"
  },
  {
    "text": "they also demoed that this is sufficient to get privilege escalation so the idea",
    "start": "1331309",
    "end": "1337850"
  },
  {
    "text": "of Sam power now is to adapt this memory tracing approach that is used by box",
    "start": "1337850",
    "end": "1343429"
  },
  {
    "text": "bound but now uses to analyze paravirtualized device communication you might ask why don't we simply use box",
    "start": "1343429",
    "end": "1350030"
  },
  {
    "text": "pan main problem is the box bound is really really slow because like the Box",
    "start": "1350030",
    "end": "1355610"
  },
  {
    "text": "CPU emulator is already slow if you add additional instrumentation it becomes even slower and and it's a passive",
    "start": "1355610",
    "end": "1362840"
  },
  {
    "text": "overhead so you have this for every memory access not only memory accesses we are interested in and my main problem",
    "start": "1362840",
    "end": "1370580"
  },
  {
    "text": "when I try to use it most basically compatibility issues so you are not even able to run hyper-v inside box at least",
    "start": "1370580",
    "end": "1378260"
  },
  {
    "text": "at the point in time when I tested this and to use the basic approach to just",
    "start": "1378260",
    "end": "1383540"
  },
  {
    "text": "dumped a memory traces into a text file which also does not scale if you want to do like long-running traces so my idea",
    "start": "1383540",
    "end": "1390740"
  },
  {
    "text": "was I wanted to implement the same technique or approach but you should implement it on top of hardware-assisted",
    "start": "1390740",
    "end": "1396470"
  },
  {
    "text": "virtualization so in this is the architecture I I landed on and basically",
    "start": "1396470",
    "end": "1402830"
  },
  {
    "text": "the core idea is you have nested virtualization so you have level 0 hypervisor and on top of this you have",
    "start": "1402830",
    "end": "1408500"
  },
  {
    "text": "another hypervisor running the level 1 hypervisor and the level 1 hypervisors",
    "start": "1408500",
    "end": "1414470"
  },
  {
    "text": "are actually target so we look at communication of virtual machines running under this level 1 hypervisor",
    "start": "1414470",
    "end": "1420140"
  },
  {
    "text": "and all my tooling runs as diminishment domain in level 1 selects and power",
    "start": "1420140",
    "end": "1427340"
  },
  {
    "text": "architecture the advantage of this this architecture is that you don't have",
    "start": "1427340",
    "end": "1432710"
  },
  {
    "text": "require any modification to the hypervisor so I can just use the off-the-shelf Zen hypervisor",
    "start": "1432710",
    "end": "1438410"
  },
  {
    "text": "and if I write stupid code so if I wipe box you don't crash the whole system I mean",
    "start": "1438410",
    "end": "1444679"
  },
  {
    "text": "if I would modify the Zen hypervisor and I would introduce box it would probably have a lot of impact so what I need is I",
    "start": "1444679",
    "end": "1451309"
  },
  {
    "text": "lead like this one interface to talk to the level 0 hypervisor and to somehow",
    "start": "1451309",
    "end": "1456890"
  },
  {
    "text": "perform memory access tracing lifters and one of the core components are used for the Am I and let me am I to create library",
    "start": "1456890",
    "end": "1465400"
  },
  {
    "text": "for virtual machine introspection and it's more or less hypervisor elastic so",
    "start": "1465400",
    "end": "1470860"
  },
  {
    "text": "you can use a sin or KVM and it's us-based wrapper so at the end you just",
    "start": "1470860",
    "end": "1476200"
  },
  {
    "text": "have like a simple C user space API and it allows us to wheat and many play to",
    "start": "1476200",
    "end": "1482710"
  },
  {
    "text": "guest CPU States so I can look into the memory I can look at CPU registers and even manipulator and more interestingly",
    "start": "1482710",
    "end": "1489720"
  },
  {
    "text": "the exam version supports a feature called memory humans and memory events",
    "start": "1489720",
    "end": "1496090"
  },
  {
    "text": "allow me to trap on an access to guest physical address so when every mine",
    "start": "1496090",
    "end": "1501970"
  },
  {
    "text": "everytime my nested hypervisor or its virtual machines access a certain",
    "start": "1501970",
    "end": "1507400"
  },
  {
    "text": "guest physical address this will trigger an apt violation so it's implemented",
    "start": "1507400",
    "end": "1512650"
  },
  {
    "text": "using extended page tables at which we can EPT violation and the VM exit and my",
    "start": "1512650",
    "end": "1518320"
  },
  {
    "text": "tooling gets controlled so my handler gets caught so I can like analyze what",
    "start": "1518320",
    "end": "1524320"
  },
  {
    "text": "triggers memory access and if it's interesting so with this feature we can kind of",
    "start": "1524320",
    "end": "1529990"
  },
  {
    "start": "1528000",
    "end": "1560000"
  },
  {
    "text": "easily implement memory access tracing we basically find our shared memory pages then we would just a memory event",
    "start": "1529990",
    "end": "1537820"
  },
  {
    "text": "handlers for every of these shared memory pages and whenever an EPT violation is triggered so whenever we",
    "start": "1537820",
    "end": "1544270"
  },
  {
    "text": "see something we analyze this memory event extract all the needed information and then start somewhere in our trace",
    "start": "1544270",
    "end": "1550810"
  },
  {
    "text": "storage with an animal's algorithm that later on tries to find double fetch",
    "start": "1550810",
    "end": "1555850"
  },
  {
    "text": "vulnerabilities or whatever else we are interested in the trace collector as I",
    "start": "1555850",
    "end": "1561580"
  },
  {
    "start": "1560000",
    "end": "1659000"
  },
  {
    "text": "said before it uses Librium I to inspect memory and to identify the shared memory",
    "start": "1561580",
    "end": "1566620"
  },
  {
    "text": "pages this is interesting because it's the earliest target specific code so I",
    "start": "1566620",
    "end": "1571930"
  },
  {
    "text": "can target the same hypervisor I can target hyper-v I can even target the chrome sandbox for example I just have",
    "start": "1571930",
    "end": "1578530"
  },
  {
    "text": "to write code that is able to identify a shared memory page that kind kind of",
    "start": "1578530",
    "end": "1584140"
  },
  {
    "text": "irrelevant as just boundary depending on how does this implemented you basically",
    "start": "1584140",
    "end": "1590290"
  },
  {
    "text": "have to walk through data structures inside a virtual machine to bars like the physical",
    "start": "1590290",
    "end": "1595330"
  },
  {
    "text": "versus if it has identified this shared memory page it then registers a memory a",
    "start": "1595330",
    "end": "1601570"
  },
  {
    "text": "bantam plus so we get notified whenever someone accesses these pages and then the callback handler does the main work",
    "start": "1601570",
    "end": "1608350"
  },
  {
    "text": "it analyzes the XS it disassembles to instruction using the capstone library",
    "start": "1608350",
    "end": "1613390"
  },
  {
    "text": "to identify what kind of memory accesses is and then stores all these informations so the the card back hand",
    "start": "1613390",
    "end": "1621100"
  },
  {
    "text": "map basically looks like this so in my case I'm only interested in excesses",
    "start": "1621100",
    "end": "1626410"
  },
  {
    "text": "from the privilege domain we are I don't want to find double fetches in the front end because the front end isn't boots",
    "start": "1626410",
    "end": "1631960"
  },
  {
    "text": "instead I'm only looking at the back end so first of all we have to extract the main ID then we look if it's the",
    "start": "1631960",
    "end": "1639880"
  },
  {
    "text": "privilege domain if that's the case we further analyze it if we have never seen that instruction before we disassemble",
    "start": "1639880",
    "end": "1646750"
  },
  {
    "text": "it to store data about instructions and at the end we just create a trace entry",
    "start": "1646750",
    "end": "1653500"
  },
  {
    "text": "for this memory access and then let let it be M continue so the question is",
    "start": "1653500",
    "end": "1659860"
  },
  {
    "start": "1659000",
    "end": "1798000"
  },
  {
    "text": "where to store these traces so as you can imagine they become quite large and",
    "start": "1659860",
    "end": "1665370"
  },
  {
    "text": "so you need to have a fast persistent storage with minimum overhead you want",
    "start": "1665370",
    "end": "1671320"
  },
  {
    "text": "to have efficient compression because then you can store longer traces and luckily there's do that kind of fulfills",
    "start": "1671320",
    "end": "1678160"
  },
  {
    "text": "this requirement it's called zero trace it's developed by the opens operation system group at the",
    "start": "1678160",
    "end": "1683740"
  },
  {
    "text": "classroom Institute of Technology and symmetrize is basically designed for",
    "start": "1683740",
    "end": "1689680"
  },
  {
    "text": "full system memory tracing so it's a starch where you can like store complete memory traces with the memory content",
    "start": "1689680",
    "end": "1696370"
  },
  {
    "text": "that's written so this is kind of interesting for like replaying of virtual machine negativity it's",
    "start": "1696370",
    "end": "1703630"
  },
  {
    "text": "optimized on we highly efficient communication over shared memory pages again it's written in C++ you get like a",
    "start": "1703630",
    "end": "1711250"
  },
  {
    "text": "client library he can use fonts from C and then you have this daemon running besides that that's responsible for all",
    "start": "1711250",
    "end": "1717790"
  },
  {
    "text": "the trace entries so it's kind of like a special database you can imagine the cool fact about this is that it has",
    "start": "1717790",
    "end": "1724480"
  },
  {
    "text": "special compression algorithm that's optimized for memory traces so I can put data in there and it's get",
    "start": "1724480",
    "end": "1730690"
  },
  {
    "text": "compressed with an incredibly high weight so I don't need like a lot of space so in I think this tool is quite",
    "start": "1730690",
    "end": "1738130"
  },
  {
    "text": "interesting and you should check it out I'm also saying it's kind of useful for",
    "start": "1738130",
    "end": "1743770"
  },
  {
    "text": "stuff like heap visualization or maybe other looking stuff that's requires high",
    "start": "1743770",
    "end": "1749230"
  },
  {
    "text": "performance now the question is what kind of entries do you store inside there and basically what we are doing is",
    "start": "1749230",
    "end": "1756070"
  },
  {
    "text": "we have this cycle count which is just counting upwards then we have an instruction pointer so that is the",
    "start": "1756070",
    "end": "1761970"
  },
  {
    "text": "instruction that's responsible for the memory access we have the memory address itself and we have two size and type of",
    "start": "1761970",
    "end": "1769600"
  },
  {
    "text": "this memory access so we know it's a read or if it's the right access and then for every unique instruction so a",
    "start": "1769600",
    "end": "1775960"
  },
  {
    "text": "single instruction will be responsible for a lot of memory accesses so only for every unique instruction we also store",
    "start": "1775960",
    "end": "1782530"
  },
  {
    "text": "liked instruction bytes we can later look at as well as the module name so I'm able to kind of perform offline",
    "start": "1782530",
    "end": "1790030"
  },
  {
    "text": "analysis to find out which module was responsible for this check so kernel module or Windows kernel Java and if we",
    "start": "1790030",
    "end": "1798310"
  },
  {
    "start": "1798000",
    "end": "1863000"
  },
  {
    "text": "have these trace and restores then the double fed algorithm so to identify that effects will be this is actually kind of",
    "start": "1798310",
    "end": "1805120"
  },
  {
    "text": "trivial this is a bit simplified version so I'm skipping a bit of details but",
    "start": "1805120",
    "end": "1810700"
  },
  {
    "text": "basically you just like iterate through this trace file look if it's a",
    "start": "1810700",
    "end": "1817150"
  },
  {
    "text": "privileged access if it's a privileged access and it's a read access then we",
    "start": "1817150",
    "end": "1822160"
  },
  {
    "text": "add this access to a map or dictionary and the first time we see an",
    "start": "1822160",
    "end": "1828900"
  },
  {
    "text": "unprivileged access which means we have a context switch then we analyze our current state of the dictionary and if",
    "start": "1828900",
    "end": "1835540"
  },
  {
    "text": "you find multiple read accesses to one memory address we probably have a double fetch learnability",
    "start": "1835540",
    "end": "1841030"
  },
  {
    "text": "as I said before this is kind of similar simplified you have a lot of problems with false positive false negatives",
    "start": "1841030",
    "end": "1848530"
  },
  {
    "text": "overlapping accesses and stuff so if you're interested you should look at the white paper that discusses this",
    "start": "1848530",
    "end": "1855040"
  },
  {
    "text": "algorithm in a lot more detail but this is like the core idea how I find them",
    "start": "1855040",
    "end": "1860830"
  },
  {
    "text": "effectual abilities now the approach has a couple of advantages as well as limitations so the",
    "start": "1860830",
    "end": "1866820"
  },
  {
    "start": "1863000",
    "end": "1935000"
  },
  {
    "text": "cool thing about this is you have a really low passive overhead like this nested virtualization it doesn't",
    "start": "1866820",
    "end": "1871860"
  },
  {
    "text": "introduce significant overhead the only thing that of course introduces overhead",
    "start": "1871860",
    "end": "1879210"
  },
  {
    "text": "is this if actually accesses to these shared memory pages occur because for",
    "start": "1879210",
    "end": "1885059"
  },
  {
    "text": "every access to a shared memory page you will have a VM exit so in the moment you",
    "start": "1885059",
    "end": "1890760"
  },
  {
    "text": "enable tracing and perform disk activity you will see the performance really suffers but you can set up the whole",
    "start": "1890760",
    "end": "1897419"
  },
  {
    "text": "system and configure it and target like which devices you want to look at all with a very low overhead so this is kind",
    "start": "1897419",
    "end": "1904590"
  },
  {
    "text": "of interesting the approach is largely targeted independent so to trace collector and everything more or less",
    "start": "1904590",
    "end": "1910140"
  },
  {
    "text": "stays the same only the stuff that identifies this shared memory page just needs to be adapted to a new target and",
    "start": "1910140",
    "end": "1916890"
  },
  {
    "text": "it's all user space C code so your C++ code so you can kind of easily extend it",
    "start": "1916890",
    "end": "1923480"
  },
  {
    "text": "but as I said before you have this high active overhead when you generate a lot of VM exit and it relies on nested",
    "start": "1923480",
    "end": "1930690"
  },
  {
    "text": "virtualization so that's kind of unfortunate because nested virtualization on xn is kind of",
    "start": "1930690",
    "end": "1936600"
  },
  {
    "start": "1935000",
    "end": "1972000"
  },
  {
    "text": "supported so if you look at our facial send documentation they say nested hvm",
    "start": "1936600",
    "end": "1942960"
  },
  {
    "text": "on intra CPUs should be considered a tech preview and it should work reliably and with low overhead for many use cases",
    "start": "1942960",
    "end": "1951169"
  },
  {
    "text": "for me it only really stable works focus on ox and KVM onyx and works most of the",
    "start": "1951169",
    "end": "1957990"
  },
  {
    "text": "time B - CIN also works kind of unfortunately I wasn't able to get hyper",
    "start": "1957990",
    "end": "1964110"
  },
  {
    "text": "bjergsen running so I'm still trying to do that because originally I wanted to",
    "start": "1964110",
    "end": "1969660"
  },
  {
    "text": "look at hyper-v vulnerabilities so I tested it on three different hypervisors",
    "start": "1969660",
    "end": "1975030"
  },
  {
    "start": "1972000",
    "end": "2047000"
  },
  {
    "text": "the first results for KVM are kind of I was disappointed by that because you don't find any security critical double",
    "start": "1975030",
    "end": "1981809"
  },
  {
    "text": "fetches on the back end the main real for this seems to be that to get I oh so the paravirtualized device mechanism",
    "start": "1981809",
    "end": "1988169"
  },
  {
    "text": "used by a KVM is actually engine independent so they support a guest operating system that's big-endian by",
    "start": "1988169",
    "end": "1995390"
  },
  {
    "text": "host systems little-endian so every time they access the guest memory they have this small access wrappers that",
    "start": "1995390",
    "end": "2001900"
  },
  {
    "text": "basically just decide on the end eunice and of course it's much harder to introduce double fetches if you have",
    "start": "2001900",
    "end": "2008049"
  },
  {
    "text": "these endianness weapons as it turns out if you actually start reading to be at i/o code there are other interesting",
    "start": "2008049",
    "end": "2014590"
  },
  {
    "text": "issues that are not double fetches so I have kind of a couple of disclosures going on so hopefully I can publish a",
    "start": "2014590",
    "end": "2021760"
  },
  {
    "text": "blog post about those beehive was kind of interesting because I only find one",
    "start": "2021760",
    "end": "2026860"
  },
  {
    "text": "double fetch but this one was kind of very interesting they are still trying to catch it so still ongoing disclosure",
    "start": "2026860",
    "end": "2035140"
  },
  {
    "text": "process but the same research is a list of those and they found three",
    "start": "2035140",
    "end": "2040540"
  },
  {
    "text": "interesting double fetches and all of them are patched so these are the ones I want to discuss and detail so the first",
    "start": "2040540",
    "end": "2047320"
  },
  {
    "start": "2047000",
    "end": "2164000"
  },
  {
    "text": "one of kind of interesting it's in the QM sent disk back-end so this is one",
    "start": "2047320",
    "end": "2052419"
  },
  {
    "text": "back-end that's normally used if you just push like abnormal this is a normal file as a disk into your virtual machine",
    "start": "2052419",
    "end": "2060190"
  },
  {
    "text": "and they have this plot interface get request function and if you look at the",
    "start": "2060190",
    "end": "2066280"
  },
  {
    "text": "lines highlighted so the sauce pointer is pointing into shared memory if you look at the lines that are highlighted",
    "start": "2066280",
    "end": "2072700"
  },
  {
    "text": "you can see three accesses to sauce pointer and the few number of segments",
    "start": "2072700",
    "end": "2079090"
  },
  {
    "text": "so the one highlighted the new apps and the top and then you have this if conditions and after the if condition",
    "start": "2079090",
    "end": "2085060"
  },
  {
    "text": "you have this assignment so the these are three memory accesses my two discovered there's a potential double",
    "start": "2085060",
    "end": "2090970"
  },
  {
    "text": "fetch and now if you look at the if condition so it's an upper limit check it checks that source number segments",
    "start": "2090970",
    "end": "2097030"
  },
  {
    "text": "shouldn't be larger than n and if these two lines actually would be compiled",
    "start": "2097030",
    "end": "2102400"
  },
  {
    "text": "into two memory accesses you would have a trivial buffer overflow because you can manipulate source number segments in",
    "start": "2102400",
    "end": "2110800"
  },
  {
    "text": "a way that when the memories access the first time it has like a little small value but then after that you have this",
    "start": "2110800",
    "end": "2117490"
  },
  {
    "text": "really big value and then the follow-up below that simply overflows however turns out that if you compare",
    "start": "2117490",
    "end": "2125260"
  },
  {
    "text": "this with normal optimally levels so GC co2 or something then this",
    "start": "2125260",
    "end": "2131530"
  },
  {
    "text": "if condition will be compiled into a single memory access so this is interesting because it's a BAC that is",
    "start": "2131530",
    "end": "2137920"
  },
  {
    "text": "kind of trivial to see in source code so this classic double set but it's not exploitable for most production systems",
    "start": "2137920",
    "end": "2144970"
  },
  {
    "text": "because compiler optimizations my tool is covered this park because the the",
    "start": "2144970",
    "end": "2150220"
  },
  {
    "text": "first line highlighted in word isn't second memory access so there are two",
    "start": "2150220",
    "end": "2155230"
  },
  {
    "text": "memory accesses but this one unfortunately isn't security critical so this is nearly an exploitable bug but",
    "start": "2155230",
    "end": "2161440"
  },
  {
    "text": "it's the kind of interesting the second park I discovered is in the block back",
    "start": "2161440",
    "end": "2167049"
  },
  {
    "start": "2164000",
    "end": "2216000"
  },
  {
    "text": "interface and purely from an exploitation perspective this is probably the most interesting one so you",
    "start": "2167049",
    "end": "2173230"
  },
  {
    "text": "have two segments airway and access this last sect and first sector numbers and I",
    "start": "2173230",
    "end": "2180700"
  },
  {
    "text": "use it to calculate a number of sectors and after I calculate this value they have this if condition where they check",
    "start": "2180700",
    "end": "2187859"
  },
  {
    "text": "the values are kind of harmless or lie in in the ballot arrange and if you can",
    "start": "2187859",
    "end": "2195819"
  },
  {
    "text": "flip the values in between this assignment and just highlight it if condition then you can trigger out of",
    "start": "2195819",
    "end": "2201609"
  },
  {
    "text": "bound read and wide vulnerabilities out of this using the block back interface in xn so this is probably if you want to",
    "start": "2201609",
    "end": "2208660"
  },
  {
    "text": "exploit this in the real world this is the most interesting one because the plot back interface of sense widely used",
    "start": "2208660",
    "end": "2215369"
  },
  {
    "text": "however my most favorite bug is in the PCI pack interface and this one is it's",
    "start": "2215369",
    "end": "2221619"
  },
  {
    "start": "2216000",
    "end": "2243000"
  },
  {
    "text": "not you probably don't find a lot of hosts that actually using this interface because it's only relevant if you have a",
    "start": "2221619",
    "end": "2227559"
  },
  {
    "text": "virtual machine it for example has a GPU or something so you have like a Virtual PC device inside the virtual machine",
    "start": "2227559",
    "end": "2234700"
  },
  {
    "text": "which happens but it's not like the default setup however the back is so technically interesting that it's still",
    "start": "2234700",
    "end": "2241690"
  },
  {
    "text": "my favorite world so you have to send PCE back to up function and as you can",
    "start": "2241690",
    "end": "2248049"
  },
  {
    "text": "see on the left hand side it's basically a big switch statement and it doesn't look vulnerable at all so if you just",
    "start": "2248049",
    "end": "2254319"
  },
  {
    "text": "look at the C code it doesn't do a lot I mean it cuts into functions but it's not really interesting as it turns out",
    "start": "2254319",
    "end": "2261200"
  },
  {
    "text": "the op CMD so up it's pointed into shared memory again and now if you look",
    "start": "2261200",
    "end": "2266900"
  },
  {
    "text": "at the compiled version of this function you will see a really interesting behavior because so the op CMD value",
    "start": "2266900",
    "end": "2274940"
  },
  {
    "text": "corresponds to the registers so are 13 plus 4 you can see in line 1 so this is",
    "start": "2274940",
    "end": "2282650"
  },
  {
    "text": "like the correspondents in the disassembly code and you can see in line 1 they have this comparison check where",
    "start": "2282650",
    "end": "2289760"
  },
  {
    "text": "I compare this value with an upper limit of 5 and if the limit is large or if the",
    "start": "2289760",
    "end": "2295220"
  },
  {
    "text": "value inside there is larger than 5 they jump to the default case of the switch statement so this is like a jump table",
    "start": "2295220",
    "end": "2301369"
  },
  {
    "text": "so it's classic compiler optimization but then you have inline 4 you can see",
    "start": "2301369",
    "end": "2306769"
  },
  {
    "text": "when they actually perform this jump so that they use the value you choose as a",
    "start": "2306769",
    "end": "2312819"
  },
  {
    "text": "as an offset into a jump table they fetch you the second time out of the",
    "start": "2312819",
    "end": "2317930"
  },
  {
    "text": "shared memory so you can see inline-four they have to move a X and XS the memory address second time and this is awesome",
    "start": "2317930",
    "end": "2325789"
  },
  {
    "text": "bug because basically you can skip over the upper limits check in this jump table complete optimization you can put",
    "start": "2325789",
    "end": "2333769"
  },
  {
    "text": "an arbitrary value inside there if you window is condition and then you almost directly gain indirect instruction",
    "start": "2333769",
    "end": "2340190"
  },
  {
    "text": "pointer control so it's interesting that",
    "start": "2340190",
    "end": "2346009"
  },
  {
    "text": "this is a valid compiler optimization because the mistake in the source code is that the OP variable or the pointer",
    "start": "2346009",
    "end": "2353059"
  },
  {
    "text": "isn't marked as volatile so the compiler doesn't think it's possible that this value could switch in between two",
    "start": "2353059",
    "end": "2358940"
  },
  {
    "text": "accesses but still I think not many people would actually discover this by looking at the source code so this shows",
    "start": "2358940",
    "end": "2365509"
  },
  {
    "text": "it's relevant to actually look at binary when looking for these kind of marks now",
    "start": "2365509",
    "end": "2370640"
  },
  {
    "start": "2370000",
    "end": "2425000"
  },
  {
    "text": "how to exploit this and exploiting PCI back turns out to be an interesting challenge so first of all you have a",
    "start": "2370640",
    "end": "2377390"
  },
  {
    "text": "really small weights because these these two memory accesses are more or less",
    "start": "2377390",
    "end": "2382430"
  },
  {
    "text": "directly behind each other there are really two instructions in between it turns out if you have a guest VM that",
    "start": "2382430",
    "end": "2388759"
  },
  {
    "text": "has moved cos this is kind of simple to exploit because you don't have any negative side",
    "start": "2388759",
    "end": "2394450"
  },
  {
    "text": "effects if you use the weights so you just can try infinite times and as you hopefully see my demo it normally works",
    "start": "2394450",
    "end": "2401020"
  },
  {
    "text": "after like five seconds or something so it's not hard to win dead weights and",
    "start": "2401020",
    "end": "2406150"
  },
  {
    "text": "it's incredibly simple to trigger basically you send PCI we press over this paravirtualized PCI back end and",
    "start": "2406150",
    "end": "2412420"
  },
  {
    "text": "just flip the value of this OP CMD parameter using X on a second sweat so",
    "start": "2412420",
    "end": "2418810"
  },
  {
    "text": "by flipping it you can manipulate this and then continue on so it's 10 hours",
    "start": "2418810",
    "end": "2425740"
  },
  {
    "start": "2425000",
    "end": "2532000"
  },
  {
    "text": "you have an indirect jump so you don't have immediate instruction pointer control and you need to find a reliable",
    "start": "2425740",
    "end": "2431800"
  },
  {
    "text": "offset to function pointer so you don't correct it directly controller in the instruction pointer instead you need to",
    "start": "2431800",
    "end": "2438220"
  },
  {
    "text": "find function pointer that's interesting to you the problem is normally San PCI back is",
    "start": "2438220",
    "end": "2443590"
  },
  {
    "text": "in kernel modules so the loader 2's will be random so you can't point to arbitrary addresses in the kernel you",
    "start": "2443590",
    "end": "2450970"
  },
  {
    "text": "also don't know the virtual address of your back-end mapping so that's also random so it's kind of similar to remote",
    "start": "2450970",
    "end": "2457240"
  },
  {
    "text": "kernel exploit the approach I've chosen is that as we get hype confusion to then",
    "start": "2457240",
    "end": "2463090"
  },
  {
    "text": "get a write primitive and from the write primitive on I walk forward and this has",
    "start": "2463090",
    "end": "2468130"
  },
  {
    "text": "some downsides as I show later on but it's kind of works for me so if you look",
    "start": "2468130",
    "end": "2474250"
  },
  {
    "text": "at the code of San PCI back you would see there's a second jump table that's generated for this it's almost directly",
    "start": "2474250",
    "end": "2480130"
  },
  {
    "text": "be high to jump table that's generated for the vulnerable function and you can",
    "start": "2480130",
    "end": "2486730"
  },
  {
    "text": "use so you can choose a arbitrary function pointer out of this junk table",
    "start": "2486730",
    "end": "2492130"
  },
  {
    "text": "so we can jump into an arbitrary K statement of the code shown in the upper left upper item so and if you look at",
    "start": "2492130",
    "end": "2500890"
  },
  {
    "text": "the dissembler again of this function you will see that they take our certain pointer as the first argument and then",
    "start": "2500890",
    "end": "2508240"
  },
  {
    "text": "call send PCI back attach and it's interesting because normally if you jump into this case statement are certain",
    "start": "2508240",
    "end": "2515680"
  },
  {
    "text": "should be a pointer to extend PCI back device structure but now it's simply pointer inside our shared memory",
    "start": "2515680",
    "end": "2521850"
  },
  {
    "text": "region so something we completely control so now we have a type confusion where we can call send PCI back attach",
    "start": "2521850",
    "end": "2529080"
  },
  {
    "text": "with arbitrary arguments the first thing this Sen PCI back attach function does",
    "start": "2529080",
    "end": "2534810"
  },
  {
    "start": "2532000",
    "end": "2582000"
  },
  {
    "text": "is it tries to lock the deathlok mutex of the structure you pass in so you can",
    "start": "2534810",
    "end": "2540480"
  },
  {
    "text": "see the normal pointer you would normally pass would point to the structure you can see on the upper right",
    "start": "2540480",
    "end": "2545640"
  },
  {
    "text": "and there's like a mutex in there and it tries to lock this mutex and now we have",
    "start": "2545640",
    "end": "2551670"
  },
  {
    "text": "the possibility to do call mutex lock with a fake mutex structure and at first",
    "start": "2551670",
    "end": "2558330"
  },
  {
    "text": "this doesn't sound too interesting because if you look at new Texas probably they just flip like the lock count or something but it turns out the",
    "start": "2558330",
    "end": "2565380"
  },
  {
    "text": "Linux mutex structure has a fast path that happens if the mutex currently is",
    "start": "2565380",
    "end": "2570900"
  },
  {
    "text": "unlocked and slow path so we need to trigger the slow path by manipulating",
    "start": "2570900",
    "end": "2576570"
  },
  {
    "text": "the shared memory section in a way we have a mutex that looks like it's locked",
    "start": "2576570",
    "end": "2582080"
  },
  {
    "start": "2582000",
    "end": "2689000"
  },
  {
    "text": "if we look at the lock slow path we can see they try to do an optimistic spin",
    "start": "2582080",
    "end": "2587430"
  },
  {
    "text": "lock we can make that fail and if it fails then they create a so-called mutex",
    "start": "2587430",
    "end": "2594210"
  },
  {
    "text": "beta structure so this is a structure that will later on we waked up to try to",
    "start": "2594210",
    "end": "2599240"
  },
  {
    "text": "get to you ticks again and if you look at how this works so this mutex major",
    "start": "2599240",
    "end": "2606060"
  },
  {
    "text": "structure is added to a linked list the lock wait list link list and by by",
    "start": "2606060",
    "end": "2613260"
  },
  {
    "text": "triggering this process we can write the pointer to this beta structure that",
    "start": "2613260",
    "end": "2618270"
  },
  {
    "text": "relies on the local struct or locus deck to attack a control location so this is",
    "start": "2618270",
    "end": "2623970"
  },
  {
    "text": "kind of an interesting right primitive it's a wide where but not a wide what so we can write a pointer to a pointer to",
    "start": "2623970",
    "end": "2631080"
  },
  {
    "text": "attack a control data but we can't simply overwrite like a function point",
    "start": "2631080",
    "end": "2637260"
  },
  {
    "text": "of outer we value so that doesn't work in step basically what we can do is we",
    "start": "2637260",
    "end": "2642600"
  },
  {
    "text": "can insert like a faked list head structure so we have this next pointer and the next pointer will point to",
    "start": "2642600",
    "end": "2649230"
  },
  {
    "text": "control data so we have double indirection in our right main problem of",
    "start": "2649230",
    "end": "2654510"
  },
  {
    "text": "South Florida's that is one shot so you only you are only able to trigger single right and",
    "start": "2654510",
    "end": "2660630"
  },
  {
    "text": "this stupid because then PCI back after that it's locked and whenever we chance you can't exploit",
    "start": "2660630",
    "end": "2667499"
  },
  {
    "text": "this vulnerability multiple times and what I'm going to do is I'm add a fake",
    "start": "2667499",
    "end": "2672839"
  },
  {
    "text": "and we true globally list which works quite well but it would cross that you know the color version of your target",
    "start": "2672839",
    "end": "2678900"
  },
  {
    "text": "system and it doesn't have car cell air or a channel hopefully that you find a different info leak in some other",
    "start": "2678900",
    "end": "2684930"
  },
  {
    "text": "component so this is like downside of this exploit approach and that basically",
    "start": "2684930",
    "end": "2690059"
  },
  {
    "start": "2689000",
    "end": "2733000"
  },
  {
    "text": "happens so the green stuff is the memory layout we we put into our shared memory",
    "start": "2690059",
    "end": "2695579"
  },
  {
    "text": "location and we have this fake previous pointer that points to global global",
    "start": "2695579",
    "end": "2701249"
  },
  {
    "text": "linked list insert econo and after which we get our override and after this mutex",
    "start": "2701249",
    "end": "2708390"
  },
  {
    "text": "lock function is triggered we get a memory layer that looks something like this so you have this list head dot next",
    "start": "2708390",
    "end": "2714960"
  },
  {
    "text": "then a pointer to this waiter structure and the problem is again the beta structure is kind of arbitrary junk so",
    "start": "2714960",
    "end": "2721859"
  },
  {
    "text": "we don't control that and after that if you follow the next point a second time we are landing in our control data so",
    "start": "2721859",
    "end": "2732229"
  },
  {
    "text": "doesn't look too powerful so we have a global data so we need to find a global data structure because we need to know",
    "start": "2732229",
    "end": "2738690"
  },
  {
    "start": "2733000",
    "end": "2759000"
  },
  {
    "text": "that where's of its list head pointer it shouldn't have new elements so this list",
    "start": "2738690",
    "end": "2743910"
  },
  {
    "text": "we won't ever wear shouldn't be like dynamic otherwise we get problems and it",
    "start": "2743910",
    "end": "2749219"
  },
  {
    "text": "needs to survive one junk entry because again we don't control this beta status so when this list is locked and should",
    "start": "2749219",
    "end": "2755910"
  },
  {
    "text": "just ignore the waiter structure so this took me couple or a bit of time until I",
    "start": "2755910",
    "end": "2761009"
  },
  {
    "start": "2759000",
    "end": "2832000"
  },
  {
    "text": "discovered something interesting and it's hidden and one of the oldest files of taluks kernel I guess it's the FS xx",
    "start": "2761009",
    "end": "2767759"
  },
  {
    "text": "dot C you can see the copyright is from nineteen one in this code and most of the code actually looks like it from",
    "start": "2767759",
    "end": "2775289"
  },
  {
    "text": "that date as well and it contains global linked list inside the Linux kernel that's called formats and formats",
    "start": "2775289",
    "end": "2782640"
  },
  {
    "text": "contains entry for different file formats that are supported by xx so if you execute an airphone shell script on",
    "start": "2782640",
    "end": "2788489"
  },
  {
    "text": "a to fire all these formats are stored insert is linked list and there",
    "start": "2788489",
    "end": "2794410"
  },
  {
    "text": "basically are the handler functions that are responsible for spawning the processes and the cool thing about this",
    "start": "2794410",
    "end": "2802450"
  },
  {
    "text": "list is that it's worked every time an x-axis call is caught to load such an input file and our junk and we will be",
    "start": "2802450",
    "end": "2810460"
  },
  {
    "text": "skipped because they caught you I'm what do you get on our junk entry which just doesn't make any sense so it will just",
    "start": "2810460",
    "end": "2817780"
  },
  {
    "text": "skip over our bait entry and then use our new data structure as like a as",
    "start": "2817780",
    "end": "2824940"
  },
  {
    "text": "input or as as variable for this for this loading of formats so when we have",
    "start": "2824940",
    "end": "2832210"
  },
  {
    "start": "2832000",
    "end": "2883000"
  },
  {
    "text": "this we need to get into code execution this time kind of easy so there's this",
    "start": "2832210",
    "end": "2838930"
  },
  {
    "text": "load binary point on inside this form it's entries we set this to our stack pivot and we have like a normal car drop",
    "start": "2838930",
    "end": "2846130"
  },
  {
    "text": "chain where we allocate executable memory we copy our shellcode we fix the",
    "start": "2846130",
    "end": "2852250"
  },
  {
    "text": "original forms list and then next time annex a string out one more or less when",
    "start": "2852250",
    "end": "2860109"
  },
  {
    "text": "this is triggered we can execute an arbitrary shell code like dollar check out in my case it's just a symbol we",
    "start": "2860109",
    "end": "2865960"
  },
  {
    "text": "were sure normally you would probably do something more complex because the management domain might not be network accessible and I'm just which harm to",
    "start": "2865960",
    "end": "2873250"
  },
  {
    "text": "use a space the GU thing about like the kernel Rob is kind of easy because inside the caller you have like infinite",
    "start": "2873250",
    "end": "2878980"
  },
  {
    "text": "gadgets and so this is not the hard part of it so I have a demo it's kind of stable so",
    "start": "2878980",
    "end": "2886000"
  },
  {
    "start": "2883000",
    "end": "3137000"
  },
  {
    "text": "I hope it will work otherwise I shall you do the video I've made of it so let",
    "start": "2886000",
    "end": "2895210"
  },
  {
    "text": "me check [Music]",
    "start": "2895210",
    "end": "2899670"
  },
  {
    "text": "so now connecting to my will books and hypervisor yeah no it worked",
    "start": "2906930",
    "end": "2919800"
  },
  {
    "text": "[Music]",
    "start": "2919800",
    "end": "2923289"
  },
  {
    "text": "and you can see like the hypervisor itself has the host named Sam while the guest system running inside",
    "start": "2931690",
    "end": "2939440"
  },
  {
    "text": "there so the unprivileged guest has the host name guest and what should happen is that we see a shell popping up that",
    "start": "2939440",
    "end": "2946849"
  },
  {
    "text": "goes from that so we see you reverse connection from the hypervisor to the",
    "start": "2946849",
    "end": "2953240"
  },
  {
    "text": "guest so you can see I can execute LS PCI and this basically just shows me one of the virtual LS PCI devices I have so",
    "start": "2953240",
    "end": "2961400"
  },
  {
    "text": "this will hopefully work now this is the",
    "start": "2961400",
    "end": "2969200"
  },
  {
    "text": "mobility or the tool that actually triggers the override so this is the",
    "start": "2969200",
    "end": "2976730"
  },
  {
    "text": "race condition so on the right hand side I trigger this LS PCI call while on the",
    "start": "2976730",
    "end": "2981920"
  },
  {
    "text": "left hand side I try to trigger the overflow so as we know we have to execute this or",
    "start": "2981920",
    "end": "2987380"
  },
  {
    "text": "the trigger this race condition and we can see the LS PCI call is hanging so that already shows that I've Bond awaits",
    "start": "2987380",
    "end": "2994490"
  },
  {
    "text": "so now basically I have the first step of exploit working",
    "start": "2994490",
    "end": "3002279"
  },
  {
    "text": "and now I'm going to open we Russia listening here and do the Sunnah prepare",
    "start": "3011940",
    "end": "3021119"
  },
  {
    "text": "shellcode and hopefully that's normal my experts are always shy their work in the",
    "start": "3021119",
    "end": "3027750"
  },
  {
    "text": "hotel room but never on stage so it",
    "start": "3027750",
    "end": "3034020"
  },
  {
    "text": "didn't trigger correctly I'm also more less over time so we do the quick back up I have a video of it so sorry about",
    "start": "3034020",
    "end": "3044940"
  },
  {
    "text": "that but now you can see if able to put",
    "start": "3044940",
    "end": "3055200"
  },
  {
    "text": "it on the screen",
    "start": "3055200",
    "end": "3058010"
  },
  {
    "text": "so Dennis it does the same thing I just",
    "start": "3072150",
    "end": "3080320"
  },
  {
    "text": "tried to demonstrate life but only this time it's working so you can see on the right hand side I'm triggering the LS",
    "start": "3080320",
    "end": "3086470"
  },
  {
    "text": "PCI activity and so the overbite winder staff tries to trigger the waste condition if LS pci hanks the virtual",
    "start": "3086470",
    "end": "3093640"
  },
  {
    "text": "PCI back and hangs we can see the override worked then I have a second",
    "start": "3093640",
    "end": "3098920"
  },
  {
    "text": "user space utility which actually prepares the shellcode into shared memory so before I execute that on the host",
    "start": "3098920",
    "end": "3105550"
  },
  {
    "text": "system everything that XR actually crashed so nothing bad happens but I",
    "start": "3105550",
    "end": "3110740"
  },
  {
    "text": "just wait until as PCI x out open my rebirth shell and then do the zoo",
    "start": "3110740",
    "end": "3116500"
  },
  {
    "text": "prepare shellcode on the left hand side you see we reversed connection from the same hypervisor and you can see I get a",
    "start": "3116500",
    "end": "3123130"
  },
  {
    "text": "root shell on the extend hypervisor so this is a full breakout out of the virtual machine and you can do on the",
    "start": "3123130",
    "end": "3129070"
  },
  {
    "text": "consent hypervisor thank you up just",
    "start": "3129070",
    "end": "3138730"
  },
  {
    "start": "3137000",
    "end": "3202000"
  },
  {
    "text": "choose final slides I have sent powerless finally open source I promise this couple of months ago already so",
    "start": "3138730",
    "end": "3145420"
  },
  {
    "text": "find it on github it's actually still private I have to get help and make it public but that will happen immediately",
    "start": "3145420",
    "end": "3151860"
  },
  {
    "text": "blackhat will release white paper which is also the master thesis I wrote on this so this contains a lot of more",
    "start": "3151860",
    "end": "3158050"
  },
  {
    "text": "technical detail on how we work so if I skipped about some details please find them in the white paper future work I",
    "start": "3158050",
    "end": "3164950"
  },
  {
    "text": "want to look at example hyper-v and VMware also interesting might be other shared memory boundaries like sandboxes",
    "start": "3164950",
    "end": "3171940"
  },
  {
    "text": "and the question is what type of box can we find if we not only look at memory accesses but also the full memory",
    "start": "3171940",
    "end": "3178720"
  },
  {
    "text": "content that access because this is kind of supported by my tool and also by su",
    "start": "3178720",
    "end": "3184120"
  },
  {
    "text": "trace so if you have any ideas how you could use that find cool box come talk",
    "start": "3184120",
    "end": "3189370"
  },
  {
    "text": "to me thanks for your attention happy to answer any questions oh yeah we",
    "start": "3189370",
    "end": "3196390"
  },
  {
    "text": "have to take it outside because I'm already over time so just find me somewhere in the hallway Thanks",
    "start": "3196390",
    "end": "3203940"
  }
]