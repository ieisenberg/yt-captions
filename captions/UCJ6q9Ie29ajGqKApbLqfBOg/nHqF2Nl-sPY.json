[
  {
    "text": "[Music]",
    "start": "2850",
    "end": "13309"
  },
  {
    "text": "all right welcome everyone this is detecting exploits with novel hardware performance counters and ml magic",
    "start": "13519",
    "end": "18960"
  },
  {
    "text": "uh before we begin a brief introduction to who we are so i'm nick gregory i'm a research scientist at capsule 8.",
    "start": "18960",
    "end": "25519"
  },
  {
    "text": "um have a background in low-level systems and binary exploitation",
    "start": "25519",
    "end": "30960"
  },
  {
    "text": "i'm a recent graduate of fenway tandon and the osiris lab shout out where i'm actually also now a",
    "start": "30960",
    "end": "37280"
  },
  {
    "text": "hacker in residence my contact info is on screen if you wanted to email with questions",
    "start": "37280",
    "end": "43440"
  },
  {
    "text": "ideas anything like that after the talk i'm happy to have you to talk",
    "start": "43440",
    "end": "48879"
  },
  {
    "text": "hello everyone my name is harini kanan i am a data scientist at capsule 8. my",
    "start": "48879",
    "end": "55039"
  },
  {
    "text": "background is in business statistics i am currently working on system user behavior profiling",
    "start": "55039",
    "end": "61520"
  },
  {
    "text": "text analytics uh interpretable ml mlaps uh you can hit me up at twitter at",
    "start": "61520",
    "end": "67439"
  },
  {
    "text": "jarvision or um through my website so without much to do let's get started",
    "start": "67439",
    "end": "74960"
  },
  {
    "text": "over to ghost so introduction to the talk uh what are we going to be covering",
    "start": "74960",
    "end": "80640"
  },
  {
    "text": "so first we're going to be covering what hardware performance counters are and why they exist uh then we'll be",
    "start": "80640",
    "end": "86560"
  },
  {
    "text": "going into some prior work that harini and i have done specifically on detecting spectre and meltdown but with documented",
    "start": "86560",
    "end": "92960"
  },
  {
    "text": "counters then we'll be going into this work particularly what what these undocumented hardware",
    "start": "92960",
    "end": "100400"
  },
  {
    "text": "counters are and kind of exploring them a little bit uh we'll be then training models on",
    "start": "100400",
    "end": "107360"
  },
  {
    "text": "undocumented counters uh seeing what we can detect with these trained models",
    "start": "107360",
    "end": "112399"
  },
  {
    "text": "and doing a little bit of interpretation on the results again given that these are undocumented we can't know for sure",
    "start": "112399",
    "end": "118000"
  },
  {
    "text": "exactly what they're measuring but we have some ideas and lastly we'll go over some future work ideas of which",
    "start": "118000",
    "end": "124399"
  },
  {
    "text": "there are plenty so the main question that we're out to answer is can we detect",
    "start": "124399",
    "end": "130720"
  },
  {
    "text": "exploits using undocumented hardware performance counters on intel cpus it's a mouthful so first what are these",
    "start": "130720",
    "end": "138959"
  },
  {
    "text": "hardware performance counters that we've been talking about so they're also known as performance",
    "start": "138959",
    "end": "145200"
  },
  {
    "text": "monitoring counters basically they're hardware devices that count events as they happen in a couple of different",
    "start": "145200",
    "end": "151920"
  },
  {
    "text": "performance monitoring units or pmus inside of the processor um they're usually used to debug things",
    "start": "151920",
    "end": "159920"
  },
  {
    "text": "like system slowness or program slowness measuring things like cache misses total number",
    "start": "159920",
    "end": "165200"
  },
  {
    "text": "instructions run things like that but as we'll see they have a lot more uses as well",
    "start": "165200",
    "end": "172080"
  },
  {
    "text": "um specifically we'll be focusing on the cpu pmu today and that",
    "start": "172080",
    "end": "178480"
  },
  {
    "text": "is the performance modern unit that lives on each core or on each hyper thread in a modern cpu",
    "start": "178480",
    "end": "185680"
  },
  {
    "text": "most modern intel cpus let you pick four or five depending on the exact generation",
    "start": "185680",
    "end": "190720"
  },
  {
    "text": "counters to monitor at once if you're on a hyper thread or eight or ten if you're on a non-hyper-threaded core",
    "start": "190720",
    "end": "197920"
  },
  {
    "text": "and you specify what you actually want to measure to the processor as two 8-bit integers an event id and a hue mask broadly",
    "start": "197920",
    "end": "204640"
  },
  {
    "text": "speaking the event id is the category or kind of the subsystem that you're wanting to measure",
    "start": "204640",
    "end": "209840"
  },
  {
    "text": "so the branch predictor or the caches something else like that and then",
    "start": "209840",
    "end": "216640"
  },
  {
    "text": "umass specifies exactly what counter you're interested in within that so l1 cache misses or",
    "start": "216640",
    "end": "223200"
  },
  {
    "text": "conditional branches on linux you interact with these through",
    "start": "223200",
    "end": "229680"
  },
  {
    "text": "the perf subsystem and usually through the perth cli there are some examples up there",
    "start": "229680",
    "end": "235200"
  },
  {
    "text": "if you wanted to mess around the first one as you may guess measures the number of cache misses that",
    "start": "235200",
    "end": "242080"
  },
  {
    "text": "the processor has while running bin ls and then the second one is specifying a specific",
    "start": "242080",
    "end": "248640"
  },
  {
    "text": "event id and umask and that one in particular you'll actually see show up in our models later",
    "start": "248640",
    "end": "255360"
  },
  {
    "text": "it's also worth noting that there's a couple different ways to actually sample these counters from the cpu you can get",
    "start": "255360",
    "end": "261120"
  },
  {
    "text": "them on a timer basis so every n milliseconds you can get them when the counter",
    "start": "261120",
    "end": "268000"
  },
  {
    "text": "overflows a certain value so when it reaches a threshold or you can just let them build up the entire",
    "start": "268000",
    "end": "273919"
  },
  {
    "text": "duration of the program run which will be what we'll be exploring to start with",
    "start": "273919",
    "end": "279680"
  },
  {
    "text": "so a couple years ago spectrum meltdown happened um for those who didn't hear at the time",
    "start": "279680",
    "end": "286240"
  },
  {
    "text": "or haven't heard since there are cpu level vulnerabilities that abuse processor speculation",
    "start": "286240",
    "end": "292160"
  },
  {
    "text": "basically the process of modern processors speculate what code should be run before they know for sure to make your code faster",
    "start": "292160",
    "end": "299919"
  },
  {
    "text": "this introduces a lot of ways to do bad things though so spectre v1 was speculating through a",
    "start": "300000",
    "end": "306880"
  },
  {
    "text": "bounce check so in your speculated code you could read an i don't know past the end of an array",
    "start": "306880",
    "end": "312560"
  },
  {
    "text": "for example um spectre rsv will let you speculate through a bad return address",
    "start": "312560",
    "end": "317759"
  },
  {
    "text": "inspector return stack buffer you could speculate reading a disabled fpu which is lazy fp",
    "start": "317759",
    "end": "324639"
  },
  {
    "text": "so potentially leaking secrets from other processes on the system entirely and there's a bunch more so",
    "start": "324639",
    "end": "332880"
  },
  {
    "text": "a bit of background here these speculative execution attacks by themselves don't do a whole lot",
    "start": "332880",
    "end": "338000"
  },
  {
    "text": "uh right you can speculate execute code but can't do anything with that because all",
    "start": "338000",
    "end": "343199"
  },
  {
    "text": "of the actual artifacts get they don't get committed to the system state",
    "start": "343199",
    "end": "349520"
  },
  {
    "text": "so what you can do is use a separate exultration technique like flush and",
    "start": "349520",
    "end": "354960"
  },
  {
    "text": "reload to actually exfiltrate data out of the speculative execution",
    "start": "354960",
    "end": "360319"
  },
  {
    "text": "so the one we'll be talking about today is flush and reload which is pretty consistent and easy",
    "start": "360319",
    "end": "367360"
  },
  {
    "text": "enough to do with assembly level access this can be done through like a javascript interpreter for",
    "start": "367360",
    "end": "372560"
  },
  {
    "text": "instance uh the basic idea is that you have a timing array and before you run whatever part of code",
    "start": "372560",
    "end": "379039"
  },
  {
    "text": "you want to spec you want to get data out of you still flush that entire array",
    "start": "379039",
    "end": "384080"
  },
  {
    "text": "out of memory or out of the cache so that any accesses to it will force a memory",
    "start": "384080",
    "end": "390240"
  },
  {
    "text": "read you then go through with your schedule of execution and have the speculation",
    "start": "390240",
    "end": "396000"
  },
  {
    "text": "load a cache line and what they'll do is mark a cache line active and then when",
    "start": "396000",
    "end": "402160"
  },
  {
    "text": "you can you come along later read through all the cache lines in the array and one of them will read faster than the others",
    "start": "402160",
    "end": "408160"
  },
  {
    "text": "because the other ones are still reading from main memory because you cl flushed it earlier but one of them will be fast because you",
    "start": "408160",
    "end": "413919"
  },
  {
    "text": "loaded it during speculative execution and that side effect on the cpu doesn't get",
    "start": "413919",
    "end": "419360"
  },
  {
    "text": "thrown away when the processor realized it's misspeculated so a hypothetical example here this is",
    "start": "419360",
    "end": "426639"
  },
  {
    "text": "super oversimplified cache lines are like one byte in this example so it's obviously not real but just to get the point across",
    "start": "426639",
    "end": "434319"
  },
  {
    "text": "let's say you have a conditional branch that is slow to load and usually true so the branch predictor",
    "start": "434319",
    "end": "440800"
  },
  {
    "text": "encounters this and says okay let me go dispatch the actual read but let me try and continue into this next instruction speculating",
    "start": "440800",
    "end": "448000"
  },
  {
    "text": "that the conditional come back true so in the speculation",
    "start": "448000",
    "end": "453520"
  },
  {
    "text": "we now load from secret number and load a cache line in our out array which is",
    "start": "453520",
    "end": "460160"
  },
  {
    "text": "our timing array based on the secret so in this case we're masking off the low two bits",
    "start": "460160",
    "end": "465520"
  },
  {
    "text": "and we're saying let's load from that so that'll make in this case the third cache line active",
    "start": "465520",
    "end": "472080"
  },
  {
    "text": "um now eventually the load will originally come through and",
    "start": "472080",
    "end": "477120"
  },
  {
    "text": "processor will realize and miss speculated and will throw away all the architectural state um but leave the cache line active",
    "start": "477120",
    "end": "485680"
  },
  {
    "text": "so we can come along later and measure how long it takes to actually access all these and we'll find that the first two are",
    "start": "485680",
    "end": "490879"
  },
  {
    "text": "slow but the third one's really fast because it's already in cash and so with this we can leave that at",
    "start": "490879",
    "end": "496319"
  },
  {
    "text": "least below two bits of our secret number r2 so",
    "start": "496319",
    "end": "501840"
  },
  {
    "text": "we developed detections for spectrum meltdown using three counters early in 2018.",
    "start": "501840",
    "end": "508960"
  },
  {
    "text": "we used the total number of cash misses the number of cash references and the number of branch misses the",
    "start": "508960",
    "end": "514719"
  },
  {
    "text": "first two form effectively the cash miss ratio and then the third was actually chosen just by",
    "start": "514719",
    "end": "520159"
  },
  {
    "text": "experimentation but makes sense kind of looking back after the fact basically it normalizes to the",
    "start": "520159",
    "end": "525760"
  },
  {
    "text": "complexity of the program so the idea is if a program",
    "start": "525760",
    "end": "530880"
  },
  {
    "text": "is branch mispredicting a lot it's also likely to cache miss a lot just it's not well optimized or it's",
    "start": "530880",
    "end": "536640"
  },
  {
    "text": "doing something really weird um so we sample all of these counters on",
    "start": "536640",
    "end": "542160"
  },
  {
    "text": "100 ml hertz and again on 100 millisecond ticker and this technique detects all the",
    "start": "542160",
    "end": "549440"
  },
  {
    "text": "public proof of concepts that we've tried so uh this is a visualization of the svm",
    "start": "549440",
    "end": "556160"
  },
  {
    "text": "model that we built around this hernia will go into details about what this actually means later and what svm is",
    "start": "556160",
    "end": "562080"
  },
  {
    "text": "but roughly speaking to you the green dots are non-attacks they're benign programs running the red dots are attacks uh they're",
    "start": "562080",
    "end": "569839"
  },
  {
    "text": "instances of spectral proof of concept running and you can see basically we've successfully drawn circles around",
    "start": "569839",
    "end": "575920"
  },
  {
    "text": "all the red dots which means we've caught the attacks um specifically if we actually look at",
    "start": "575920",
    "end": "581440"
  },
  {
    "text": "the accuracy if we combine the svm model and a deterministic model which is",
    "start": "581440",
    "end": "586800"
  },
  {
    "text": "just cachement's ratio and branchness ratio below a certain",
    "start": "586800",
    "end": "592560"
  },
  {
    "text": "threshold we can see that we get 100 accuracy and a zero false negative rate so we have effectively a perfect",
    "start": "592560",
    "end": "598720"
  },
  {
    "text": "detector here for all the proof of concepts that we've tried however",
    "start": "598720",
    "end": "604160"
  },
  {
    "text": "this detection can actually be really easily defeated if you know what it's looking for so all you have to do is mix in some",
    "start": "604160",
    "end": "610480"
  },
  {
    "text": "cache friendly code into the proof concept an example like this you have this stuff",
    "start": "610480",
    "end": "616880"
  },
  {
    "text": "array which we effectively always keep in cash uh and excuse all the register",
    "start": "616880",
    "end": "623920"
  },
  {
    "text": "old c style nonsense i just wanted to make sure that this doesn't end up writing something",
    "start": "623920",
    "end": "629200"
  },
  {
    "text": "into the stack which modifies the cache in another way this just does what i think it does and sure enough this will bypass",
    "start": "629200",
    "end": "635279"
  },
  {
    "text": "our detection we can even tune using the high bound of the round parameter how would our cache ratio what we want",
    "start": "635279",
    "end": "643279"
  },
  {
    "text": "it to be so we can mimic anything so with that done let's dive into",
    "start": "643279",
    "end": "651360"
  },
  {
    "text": "our current research so as i mentioned earlier harper performance counters are",
    "start": "651360",
    "end": "658640"
  },
  {
    "text": "specified with two 8-bit integers so we actually have room for 65",
    "start": "658640",
    "end": "665200"
  },
  {
    "text": "536 counters potentially but only a subset of those are actually",
    "start": "665200",
    "end": "671040"
  },
  {
    "text": "documented by intel um somewhere in the low hundreds to",
    "start": "671040",
    "end": "676720"
  },
  {
    "text": "a thousand-ish i think 1500-ish was the most they've ever documented",
    "start": "676720",
    "end": "682320"
  },
  {
    "text": "but that's not to say that the ones that aren't documented don't have any data behind them that they're not",
    "start": "682320",
    "end": "687760"
  },
  {
    "text": "counting anything so the idea basically came out what if we read",
    "start": "687760",
    "end": "693440"
  },
  {
    "text": "all of the counters even the undocumented ones um by doing this we're basically turning this x-ray detection problem into a",
    "start": "693440",
    "end": "700320"
  },
  {
    "text": "black box ml problem so just completely changing frame um so what are we going to run these",
    "start": "700320",
    "end": "708640"
  },
  {
    "text": "cameras on though i guess is the question that arises so we have four sample programs",
    "start": "708640",
    "end": "714160"
  },
  {
    "text": "that we were running on we have a minified exit zero which is basically theirs to detect",
    "start": "714160",
    "end": "719680"
  },
  {
    "text": "any overhead of the kernel actually starting the process um we have a scikit benchmark which was",
    "start": "719680",
    "end": "726959"
  },
  {
    "text": "known from prior research just to be something that was very that had a very high cache miss ratio so",
    "start": "726959",
    "end": "734160"
  },
  {
    "text": "it sort of looks like spectre we had the spectre proof concept itself and then we had our modified specter",
    "start": "734160",
    "end": "741040"
  },
  {
    "text": "proof of concept with our cache friendly code mixed in",
    "start": "741040",
    "end": "746079"
  },
  {
    "text": "so once we gather all that data we did a few filtering steps we removed all the counters that were always zero",
    "start": "746079",
    "end": "751760"
  },
  {
    "text": "just because they weren't doing anything we removed counters that had a difference between psychic and spectre less than 95",
    "start": "751760",
    "end": "760079"
  },
  {
    "text": "so the idea is basically we want things that are very different than we want things that",
    "start": "760079",
    "end": "768079"
  },
  {
    "text": "are very different between psychic and spectre then we removed counters that differed more than five percent",
    "start": "768079",
    "end": "773680"
  },
  {
    "text": "between our modified specter before the original proof of concept again the idea being",
    "start": "773680",
    "end": "779279"
  },
  {
    "text": "those two should should give a similar signature because we want to actually",
    "start": "779279",
    "end": "784399"
  },
  {
    "text": "detect the exploit running not like a side effect of it so since those are at their core doing the same exploit they should be",
    "start": "784399",
    "end": "790800"
  },
  {
    "text": "relatively similar in their accounts um at the end of that we were left with 81 counters",
    "start": "790800",
    "end": "795920"
  },
  {
    "text": "and interestingly enough none of them were documented so we thought okay maybe we're actually on something here",
    "start": "795920",
    "end": "802079"
  },
  {
    "text": "um it's worth noting at this point that all of our tests were run on a haswell machine and an iv bridge machine",
    "start": "802079",
    "end": "807120"
  },
  {
    "text": "so a bit older microarchitectures but should what we found should still be valid with",
    "start": "807120",
    "end": "812639"
  },
  {
    "text": "adaptation on newer microarchitectures but the results will differ because again these counters change from",
    "start": "812639",
    "end": "819440"
  },
  {
    "text": "generation to generation so we came up with two data sets of",
    "start": "819440",
    "end": "824959"
  },
  {
    "text": "counters that looked interesting the first one is one that we'll be covering from here on out um the second performed almost",
    "start": "824959",
    "end": "832320"
  },
  {
    "text": "identically but we just don't have time to cover both of them and interestingly enough you'll actually see",
    "start": "832320",
    "end": "838160"
  },
  {
    "text": "one of the counters appears in both which turns out to be a very significant counter",
    "start": "838160",
    "end": "843600"
  },
  {
    "text": "all right now that we have zeroed in on which undocumented counters we want to",
    "start": "843600",
    "end": "848800"
  },
  {
    "text": "use as features for our models let's see how the experiments run",
    "start": "848800",
    "end": "855279"
  },
  {
    "text": "so uh the exploits of interest for us where uh meltdown aka spectre v3",
    "start": "855279",
    "end": "861680"
  },
  {
    "text": "which is the road data cache load uh spectral v1 which is the bounce check",
    "start": "861680",
    "end": "866800"
  },
  {
    "text": "bypass spectral v2 which is the branch target injection spectrov4 which is the speculative store",
    "start": "866800",
    "end": "874160"
  },
  {
    "text": "bypass ghosting spectrov4 which is the same aspect of before but with invasive",
    "start": "874160",
    "end": "879760"
  },
  {
    "text": "changes that ghost made to make sure we bypass the existing uh detections",
    "start": "879760",
    "end": "886639"
  },
  {
    "text": "using known performance counters right uh we were also curious to see if we can",
    "start": "886639",
    "end": "892639"
  },
  {
    "text": "detect uh drop and stack pivot attacks using these same undocumented per features and",
    "start": "892639",
    "end": "900639"
  },
  {
    "text": "surprisingly we could let's see how",
    "start": "900639",
    "end": "905760"
  },
  {
    "text": "so for the data collection we are using linux perf counters of course",
    "start": "905760",
    "end": "911839"
  },
  {
    "text": "and along with the exploits mentioned before uh we also collected data for the",
    "start": "911839",
    "end": "916959"
  },
  {
    "text": "following uh baseline programs um they were limited unit tests uh scikit-learn",
    "start": "916959",
    "end": "922800"
  },
  {
    "text": "benchmark tests uh pharonix enginex test suit and linux stuff config compiler",
    "start": "922800",
    "end": "929680"
  },
  {
    "text": "and uh we selected uh these selected counters were measured for every 100 milliseconds and each of the test",
    "start": "929680",
    "end": "937279"
  },
  {
    "text": "script was run five times for uh statistical significance right",
    "start": "937279",
    "end": "942800"
  },
  {
    "text": "and uh these were the model metrics that we calculated um precision recall f1 score",
    "start": "942800",
    "end": "950320"
  },
  {
    "text": "false positive rate false negative rate area under the curve test accuracy and confusion matrix",
    "start": "950320",
    "end": "957759"
  },
  {
    "text": "now before going to the numbers uh let's uh quickly see what each of the metrics",
    "start": "957759",
    "end": "963759"
  },
  {
    "text": "mean um as a quick summary uh so precision is the ability of a",
    "start": "963759",
    "end": "970480"
  },
  {
    "text": "classifier to not label a true negative observation as possible it's the proportion of",
    "start": "970480",
    "end": "978160"
  },
  {
    "text": "positive identifications made by the classifier that are actually correct",
    "start": "978160",
    "end": "983440"
  },
  {
    "text": "so it's basically the percentage of your results uh which are relevant right uh next is recall",
    "start": "983440",
    "end": "991120"
  },
  {
    "text": "uh recall is the ability of the classifier to find uh positive examples uh basically what",
    "start": "991120",
    "end": "997279"
  },
  {
    "text": "proportion of actual positives were identified correctly so if we want",
    "start": "997279",
    "end": "1003199"
  },
  {
    "text": "to be certain to find all the positive examples uh we could maximize recall right the next one",
    "start": "1003199",
    "end": "1010880"
  },
  {
    "text": "is f1 score f1 score is basically the harmonic mean of precision and recall and it ranges",
    "start": "1010880",
    "end": "1017199"
  },
  {
    "text": "from zero to one so you want it to be as high as possible as close to one uh so instead of seeing precision and",
    "start": "1017199",
    "end": "1024240"
  },
  {
    "text": "recall uh separately you can just look at the f1 score and um look at the um",
    "start": "1024240",
    "end": "1030569"
  },
  {
    "text": "[Music] the goodness of the mod how how good it is",
    "start": "1030569",
    "end": "1035839"
  },
  {
    "text": "the next one is area under the curve this is an important metric for any classification problem",
    "start": "1035839",
    "end": "1041120"
  },
  {
    "text": "uh the rc curve represents the true positive rate and false positive rate for all",
    "start": "1041120",
    "end": "1046400"
  },
  {
    "text": "probability thresholds of a binary classifier right the auc evaluates the overall",
    "start": "1046400",
    "end": "1052160"
  },
  {
    "text": "quality of the model so more the um area of the curve the better right so in the plot you can",
    "start": "1052160",
    "end": "1059120"
  },
  {
    "text": "see uh in the left in the x-axis you can see the false positive rate in the y-axis",
    "start": "1059120",
    "end": "1064160"
  },
  {
    "text": "you can see the true positive rate so you want the um plot the graph to be pulled as",
    "start": "1064160",
    "end": "1072400"
  },
  {
    "text": "um close to the left top quadrant as possible right you want the lowest false positive",
    "start": "1072400",
    "end": "1079440"
  },
  {
    "text": "rate and the highest true positive rate right so this is a good metric to",
    "start": "1079440",
    "end": "1084640"
  },
  {
    "text": "measure a classification model the next one is confusion matrix another important one",
    "start": "1084640",
    "end": "1090720"
  },
  {
    "text": "this is also known as error matrix and is a specific table layout that allows visualization of the",
    "start": "1090720",
    "end": "1096880"
  },
  {
    "text": "performance of an algorithm right confusion matrix visualizes the accuracy of the classifier by comparing",
    "start": "1096880",
    "end": "1103760"
  },
  {
    "text": "the true and the predicted predicted classes as you can see",
    "start": "1103760",
    "end": "1109360"
  },
  {
    "text": "the diagonal squares are the are the correct predictions and the off diagonal squares are the",
    "start": "1109360",
    "end": "1115520"
  },
  {
    "text": "incorrect predictions um in the plot you can see the y axis is the true clause and the x-axis is the predicted class",
    "start": "1115520",
    "end": "1123919"
  },
  {
    "text": "so that makes all the diagonals as the true positives and uh and the two negatives",
    "start": "1123919",
    "end": "1130480"
  },
  {
    "text": "right so you want them to be as high as possible and you want the off diagonal squares which are the wrong",
    "start": "1130480",
    "end": "1136799"
  },
  {
    "text": "predictions uh to be as low as possible um so next we will see uh",
    "start": "1136799",
    "end": "1143200"
  },
  {
    "text": "the algorithms uh that we have used um these are the algorithm algorithms that",
    "start": "1143200",
    "end": "1149360"
  },
  {
    "text": "have performed the best for us the idea was to start from the simplest uh most interpretable model and go up from",
    "start": "1149360",
    "end": "1156559"
  },
  {
    "text": "there uh till we get good results and these are the four models that have worked really well for us so far",
    "start": "1156559",
    "end": "1164960"
  },
  {
    "text": "the first one is support vector machine uh random forest extreme gradient boosting which is the",
    "start": "1164960",
    "end": "1170320"
  },
  {
    "text": "xg boost and histogram based query and boosting now uh we'll quickly see what each model just",
    "start": "1170320",
    "end": "1177200"
  },
  {
    "text": "like a quick summary uh svm is a supervised ml",
    "start": "1177200",
    "end": "1182400"
  },
  {
    "text": "algorithm which can be used for classification as well as regression uh obviously we are using here for a",
    "start": "1182400",
    "end": "1188240"
  },
  {
    "text": "binary classification in svm we plot each data item as",
    "start": "1188240",
    "end": "1193280"
  },
  {
    "text": "a point in n-dimensional space where n is the number of features you have and",
    "start": "1193280",
    "end": "1198960"
  },
  {
    "text": "the value of the feature being its coordinate then we perform classification",
    "start": "1198960",
    "end": "1204640"
  },
  {
    "text": "by finding the hyperplane that differentiates the tool classes as you can see in the plot on the left",
    "start": "1204640",
    "end": "1212080"
  },
  {
    "text": "the objective is to maximize the distance between the nearest data point of either class and the hyperplane that",
    "start": "1212080",
    "end": "1219360"
  },
  {
    "text": "separates it right for us the hyperplane is not linear but it's it was rbf kernel radial basis function",
    "start": "1219360",
    "end": "1226799"
  },
  {
    "text": "uh you can see the distance boundaries of different kernels in the second plot",
    "start": "1226799",
    "end": "1231840"
  },
  {
    "text": "on the right all right the next one is uh random forest uh it's an ensemble",
    "start": "1231840",
    "end": "1237760"
  },
  {
    "text": "method where multiple decision trees are created uh using random subsets of features and",
    "start": "1237760",
    "end": "1242799"
  },
  {
    "text": "bootstrap data each distinct tree then boots by predicting the class",
    "start": "1242799",
    "end": "1249039"
  },
  {
    "text": "the words are then tallied to reach the final prediction before seeing the next model",
    "start": "1249039",
    "end": "1254799"
  },
  {
    "text": "which is the xt boost and which also performed the best for us let's see the basic behind the scenes",
    "start": "1254799",
    "end": "1261679"
  },
  {
    "text": "difference in concept for um both these models",
    "start": "1261679",
    "end": "1267200"
  },
  {
    "text": "random forest uses distant trees which are very prone to overfitting in order to",
    "start": "1267200",
    "end": "1273520"
  },
  {
    "text": "achieve higher accuracy random forest decides to create a large number of them",
    "start": "1273520",
    "end": "1278799"
  },
  {
    "text": "based on bagging now bagging the basic idea is to re-sample the data over and over again",
    "start": "1278799",
    "end": "1285600"
  },
  {
    "text": "for each sample and it trains a new classifier right so different classifiers over for the data",
    "start": "1285600",
    "end": "1292159"
  },
  {
    "text": "in different ways and through voting those differences are averaged out now gbm you know gradient boosting",
    "start": "1292159",
    "end": "1298640"
  },
  {
    "text": "method is um a boosting method which builds on weak classifiers the idea is to add a classifier at a",
    "start": "1298640",
    "end": "1306799"
  },
  {
    "text": "time so that the next classifier is trained to improve the already trained ensemble notice that for",
    "start": "1306799",
    "end": "1314080"
  },
  {
    "text": "random forest each iteration declassified string independently from the rest uh whereas it's the opposite for uh xd",
    "start": "1314080",
    "end": "1320559"
  },
  {
    "text": "boost right now uh hd boost which is extreme",
    "start": "1320559",
    "end": "1326159"
  },
  {
    "text": "gradient boosting this was the best model we had uh it builds on b class first as we saw before um it adds",
    "start": "1326159",
    "end": "1333360"
  },
  {
    "text": "uh one classifier distance free at a time so that the next classifier is trained",
    "start": "1333360",
    "end": "1338400"
  },
  {
    "text": "to improve the already trained ensemble right uh the next model",
    "start": "1338400",
    "end": "1343600"
  },
  {
    "text": "is histogram based and boosting it's a very similar model to xd boost it's a faster implementation of",
    "start": "1343600",
    "end": "1351120"
  },
  {
    "text": "gradient boosting classifier when the number of samples is high it binds the input samples into integer",
    "start": "1351120",
    "end": "1358880"
  },
  {
    "text": "valued bins which reduces the number of splitting points to consider",
    "start": "1358880",
    "end": "1364080"
  },
  {
    "text": "this allows the algorithm to leverage integer based data structures instead of relying on sorted continuous",
    "start": "1364080",
    "end": "1370080"
  },
  {
    "text": "values when building the trees right now",
    "start": "1370080",
    "end": "1375280"
  },
  {
    "text": "let's detect spectra again uh but this time even the ghost inspector which evaded us",
    "start": "1375280",
    "end": "1381520"
  },
  {
    "text": "before um here you can see the summary um",
    "start": "1381520",
    "end": "1386559"
  },
  {
    "text": "of all the uh model um that models that we have tested so far",
    "start": "1386559",
    "end": "1392799"
  },
  {
    "text": "uh the first three columns shows the the features themselves 3698 40 e3 and",
    "start": "1392799",
    "end": "1398559"
  },
  {
    "text": "eff4 the next column shows the intel architecture uh it's either iv",
    "start": "1398559",
    "end": "1403840"
  },
  {
    "text": "bridge or hassel and the four models that we have uh tested uh that worked really well",
    "start": "1403840",
    "end": "1410400"
  },
  {
    "text": "which are svm xd boost random forest and hg boost and then you can see um all the metrics",
    "start": "1410400",
    "end": "1417679"
  },
  {
    "text": "that we uh talked about before precision recall false posture rate false negative rate",
    "start": "1417679",
    "end": "1422799"
  },
  {
    "text": "area on the curve and accuracy and then you can see whether these models detected",
    "start": "1422799",
    "end": "1428840"
  },
  {
    "text": "um the attacks that we uh fed um the",
    "start": "1428840",
    "end": "1434720"
  },
  {
    "text": "green colored rows as you can see have the models that are doing really well and they are detecting",
    "start": "1434720",
    "end": "1440960"
  },
  {
    "text": "all the attack variants all these spectrum well down variants right let's see the um the best model",
    "start": "1440960",
    "end": "1447440"
  },
  {
    "text": "that we had so far uh which is the xg boost using the three features that we saw",
    "start": "1447440",
    "end": "1453679"
  },
  {
    "text": "and the metrics here you can see it has 99 precision 98 recall um",
    "start": "1453679",
    "end": "1461039"
  },
  {
    "text": "0.04 percent falls past a rate of 4 percent false negative rate and 98",
    "start": "1461039",
    "end": "1469039"
  },
  {
    "text": "area of the curve now false negative rate here doesn't imply that the attack itself was being missed",
    "start": "1469039",
    "end": "1475440"
  },
  {
    "text": "um it just shows the part of the exploit uh that was being missed so all the uh",
    "start": "1475440",
    "end": "1481600"
  },
  {
    "text": "as you can see in the uh table before all the attacks were caught by this model",
    "start": "1481600",
    "end": "1487039"
  },
  {
    "text": "uh so the false negative right just shows the part of the exploit that was missed uh so the next you can see the area",
    "start": "1487039",
    "end": "1494000"
  },
  {
    "text": "under the curve for um the the best model which was xt boost uh here you can see two plots the left",
    "start": "1494000",
    "end": "1501279"
  },
  {
    "text": "one is for the um test data set and the right uh plot is for the holdout data set so the",
    "start": "1501279",
    "end": "1508799"
  },
  {
    "text": "uh spectral v for uh the edited one the ghosting spectral v4",
    "start": "1508799",
    "end": "1514480"
  },
  {
    "text": "was part of the holdout data set we wanted to make sure the model has never seen that variant before and we",
    "start": "1514480",
    "end": "1520880"
  },
  {
    "text": "wanted to test whether it can still detect the newer variant when trained on",
    "start": "1520880",
    "end": "1526159"
  },
  {
    "text": "other existing variants right and it did so um that's why um",
    "start": "1526159",
    "end": "1533679"
  },
  {
    "text": "it's it's it's super interesting um so you can see in the left plot the test",
    "start": "1533679",
    "end": "1539440"
  },
  {
    "text": "accuracy was 98.99 percent uh adrian the curve was 98",
    "start": "1539440",
    "end": "1546480"
  },
  {
    "text": "uh false positive rate was uh 0.04 and false negative rate for was four",
    "start": "1546480",
    "end": "1552400"
  },
  {
    "text": "percent and the f1 score was 98 um which is good now let's see how it",
    "start": "1552400",
    "end": "1559919"
  },
  {
    "text": "um fares in the holdout data set uh it fares better than what we saw",
    "start": "1559919",
    "end": "1567120"
  },
  {
    "text": "in the test data set you can see the test accuracy was a 99.9 percent area under the curve 99.6 percent",
    "start": "1567120",
    "end": "1575840"
  },
  {
    "text": "zero false positive rate and 0.68 percent",
    "start": "1575840",
    "end": "1580960"
  },
  {
    "text": "false negative rate so it cost it caught almost all of the all parts of",
    "start": "1580960",
    "end": "1586960"
  },
  {
    "text": "the attack and a hundred percent um f1 score uh which is great now let's",
    "start": "1586960",
    "end": "1593919"
  },
  {
    "text": "see the uh confusion matrix for uh the same model right again the left shows the",
    "start": "1593919",
    "end": "1600480"
  },
  {
    "text": "normalized confusion matrix for um the test data set and the right plot",
    "start": "1600480",
    "end": "1605760"
  },
  {
    "text": "is for the holdout data set which had the edited ghosting spectre v4 right so again",
    "start": "1605760",
    "end": "1614159"
  },
  {
    "text": "as we saw before we need the diagonal to be as high as possible and the off",
    "start": "1614159",
    "end": "1619760"
  },
  {
    "text": "diagonal squares to be as low as possible um so the left top quadrant which is the",
    "start": "1619760",
    "end": "1627279"
  },
  {
    "text": "two negatives a 100 percent of the non malicious baseline data points have been",
    "start": "1627279",
    "end": "1633360"
  },
  {
    "text": "um classified correctly and 96 of malicious attack data points have",
    "start": "1633360",
    "end": "1638960"
  },
  {
    "text": "been classified correctly which is great now let's see in the right plot for the holdout",
    "start": "1638960",
    "end": "1644640"
  },
  {
    "text": "data set uh 100 of baseline non-malicious data points",
    "start": "1644640",
    "end": "1649919"
  },
  {
    "text": "have been classified correctly and 99 of um malicious attack data points have",
    "start": "1649919",
    "end": "1657120"
  },
  {
    "text": "been uh classified correctly so it it definitely fairs better",
    "start": "1657120",
    "end": "1662559"
  },
  {
    "text": "um than any other models that we have seen uh so far so next let's look at some model",
    "start": "1662559",
    "end": "1669279"
  },
  {
    "text": "interpretation this is a topic that um i'm very fond of um",
    "start": "1669279",
    "end": "1675679"
  },
  {
    "text": "so here we will see the modern information using the shop library um it's",
    "start": "1675679",
    "end": "1682000"
  },
  {
    "text": "a shapely additive explanation it's based on shapely values uh technique used in game",
    "start": "1682000",
    "end": "1689120"
  },
  {
    "text": "theory to determine how much each player in a collaborative game has contributed to its success so here",
    "start": "1689120",
    "end": "1695919"
  },
  {
    "text": "each shaft value measures how much each feature in our model",
    "start": "1695919",
    "end": "1701120"
  },
  {
    "text": "contributes to the prediction either positively or negatively right so here we'll see the",
    "start": "1701120",
    "end": "1708480"
  },
  {
    "text": "feature importance for the xc boost model um eff4 um seems to be the most important",
    "start": "1708480",
    "end": "1715840"
  },
  {
    "text": "feature followed by 4d e3 followed by 3698. now how",
    "start": "1715840",
    "end": "1722799"
  },
  {
    "text": "each feature um impacts the um target variable um let's see so uh",
    "start": "1722799",
    "end": "1730399"
  },
  {
    "text": "the next one the the plot that you're going to see is a partial dependence plot so this shows",
    "start": "1730399",
    "end": "1736320"
  },
  {
    "text": "the marginal effect that one or two variables have on the predicted outcome um whether the relationship between the",
    "start": "1736320",
    "end": "1743200"
  },
  {
    "text": "target and the feature variable is linear monotonic or more complex so let's see",
    "start": "1743200",
    "end": "1748880"
  },
  {
    "text": "the partial dependence plots for each of the three features separately so the first one we'll see",
    "start": "1748880",
    "end": "1754799"
  },
  {
    "text": "for the most important feature which is eff4 you can see it clearly influences",
    "start": "1754799",
    "end": "1761600"
  },
  {
    "text": "the outcome variable negatively helping the model classify the baseline",
    "start": "1761600",
    "end": "1767360"
  },
  {
    "text": "data correctly so if you see there is a big cluster of uh blue data points so",
    "start": "1767360",
    "end": "1772399"
  },
  {
    "text": "the blue data points here denote the non-malicious baseline um data points and the red ones denote",
    "start": "1772399",
    "end": "1779679"
  },
  {
    "text": "the attack uh data points right so there is a huge cluster of blue",
    "start": "1779679",
    "end": "1784720"
  },
  {
    "text": "on top left corner and uh clearly higher the shaft value for eff4 uh",
    "start": "1784720",
    "end": "1792000"
  },
  {
    "text": "there is a clear denomination where it classifies the baseline data correctly and",
    "start": "1792000",
    "end": "1799039"
  },
  {
    "text": "in the right y-axis you can see another feature 3698 this shows that eff4",
    "start": "1799039",
    "end": "1805360"
  },
  {
    "text": "interacts slightly with 3698 which is the yellow feature uh where the",
    "start": "1805360",
    "end": "1811200"
  },
  {
    "text": "value of uh the 3698 feature are between 10k and um 30k right so there is",
    "start": "1811200",
    "end": "1819120"
  },
  {
    "text": "definitely a small infraction going on there but eff4 clearly",
    "start": "1819120",
    "end": "1825279"
  },
  {
    "text": "with its huge and negative uh influence on the model um helps it to classify the",
    "start": "1825279",
    "end": "1832399"
  },
  {
    "text": "baseline data points um correctly the next one",
    "start": "1832399",
    "end": "1837760"
  },
  {
    "text": "is for uh the second feature which is 4d e3 the same partial dependence",
    "start": "1837760",
    "end": "1844480"
  },
  {
    "text": "plot it clearly shows there is approximately a linear positive trend between 40 e3 and",
    "start": "1844480",
    "end": "1851360"
  },
  {
    "text": "a target variable right higher the shaft values for 40 e3 the uh the classification becomes uh",
    "start": "1851360",
    "end": "1859600"
  },
  {
    "text": "one which is malicious right so um there is an approximate linear",
    "start": "1859600",
    "end": "1864880"
  },
  {
    "text": "relationship there and it clearly doesn't react with any other feature as you notice there is no a y-axis on",
    "start": "1864880",
    "end": "1872000"
  },
  {
    "text": "the right side meaning there is no other feature that's interacting with um this feature which is 483 which is",
    "start": "1872000",
    "end": "1879279"
  },
  {
    "text": "great uh the next one is the last feature which is 3698",
    "start": "1879279",
    "end": "1884480"
  },
  {
    "text": "uh this has a significant impact um it can be seen for the highest and the lowest values of the feature",
    "start": "1884480",
    "end": "1891120"
  },
  {
    "text": "right if you see in the right most uh uh corner right top corner there's a cluster of",
    "start": "1891120",
    "end": "1897360"
  },
  {
    "text": "red data points and in the left uh bottom corner you can see there's a cluster of blue data points",
    "start": "1897360",
    "end": "1903840"
  },
  {
    "text": "so there is a clear impact for the highest and the lowest features um classified as um",
    "start": "1903840",
    "end": "1909970"
  },
  {
    "text": "[Music] malicious and non-malicious respectively and there's also some interaction uh going on with the",
    "start": "1909970",
    "end": "1918080"
  },
  {
    "text": "feature 40 e3 as you can see in the right y axis um there is interaction for the values of",
    "start": "1918080",
    "end": "1925760"
  },
  {
    "text": "40 e3 lying in between 75 000 and 300 000 if you see the um the",
    "start": "1925760",
    "end": "1932720"
  },
  {
    "text": "parallel red and blue dots right so definitely some interaction going on um",
    "start": "1932720",
    "end": "1937840"
  },
  {
    "text": "the next plot is um called force plot uh the first thought shows",
    "start": "1937840",
    "end": "1943440"
  },
  {
    "text": "the interpretation of the prediction using a logistic regression right the red color denotes uh",
    "start": "1943440",
    "end": "1949760"
  },
  {
    "text": "features that push the prediction uh higher to the right and those pushing the prediction lower",
    "start": "1949760",
    "end": "1956000"
  },
  {
    "text": "are shown in the blue color right in the first plot it shows for one data point amongst the",
    "start": "1956000",
    "end": "1962080"
  },
  {
    "text": "whole test data set um so this is just for one data point and in this case it was a positive one",
    "start": "1962080",
    "end": "1967600"
  },
  {
    "text": "it was a malicious one right the features 40 e3 and 3698 have the most positive impact on the",
    "start": "1967600",
    "end": "1975279"
  },
  {
    "text": "prediction being malicious uh there's one and the feature eff4",
    "start": "1975279",
    "end": "1980880"
  },
  {
    "text": "has the most negative impact right it's bringing it down so you rotate this plot 90 degrees",
    "start": "1980880",
    "end": "1987840"
  },
  {
    "text": "and plot the same for all the data points in the test data set together and you get the second",
    "start": "1987840",
    "end": "1994240"
  },
  {
    "text": "plot right each data point here is a vertical line it clearly shows feature eff4 has a",
    "start": "1994240",
    "end": "2001279"
  },
  {
    "text": "negative effect on the outcome variable and the other two features push for the outcome",
    "start": "2001279",
    "end": "2007039"
  },
  {
    "text": "uh to be one you know that is malicious uh this intuitively retraces the uh feature importance graph where uh",
    "start": "2007039",
    "end": "2013760"
  },
  {
    "text": "eff4 is the most important feature um responsible for making sure",
    "start": "2013760",
    "end": "2019440"
  },
  {
    "text": "the baseline non-malicious programs are classified uh correctly and the other two features play their",
    "start": "2019440",
    "end": "2025120"
  },
  {
    "text": "secondary roles to push the classification towards one you know for the malicious data points um",
    "start": "2025120",
    "end": "2032320"
  },
  {
    "text": "here you can see the uh same force plot uh for each feature um",
    "start": "2032320",
    "end": "2039840"
  },
  {
    "text": "being filtered out right here's the force plot filter just showing eff4 clearly the blue dominates right showing",
    "start": "2039840",
    "end": "2046799"
  },
  {
    "text": "its negative impact uh negative effect on the um outcome variable uh the next one is the uh",
    "start": "2046799",
    "end": "2054960"
  },
  {
    "text": "force plot for 40 e3 uh filtered right clearly it has a positive impact and helps the",
    "start": "2054960",
    "end": "2061200"
  },
  {
    "text": "model push across the line to classify the malicious data points uh correctly",
    "start": "2061200",
    "end": "2067599"
  },
  {
    "text": "now let's see the uh force plot filter just for feature 3698 this again has a positive impact",
    "start": "2067599",
    "end": "2075118"
  },
  {
    "text": "on the target variable though not as strong as 483 but healthy model push across the line",
    "start": "2075119",
    "end": "2081520"
  },
  {
    "text": "to classify the malicious data points correctly",
    "start": "2081520",
    "end": "2087200"
  },
  {
    "text": "thanks rooney so at this point we've seen that we can detect specter and variants really well using",
    "start": "2087520",
    "end": "2093040"
  },
  {
    "text": "undocumented counters but we wanted to see if we could detect other exploits specifically rob",
    "start": "2093040",
    "end": "2099040"
  },
  {
    "text": "there's been prior work done on detecting rob with hardware performance counters or other",
    "start": "2099040",
    "end": "2104960"
  },
  {
    "text": "hardware performance monitoring things like the last branch record and intel processor trace",
    "start": "2104960",
    "end": "2111040"
  },
  {
    "text": "um the main thing with lbr and pt is that there's a lot of data right it's",
    "start": "2111040",
    "end": "2116320"
  },
  {
    "text": "measuring everywhere that the program is running and so you just end up with a lot of",
    "start": "2116320",
    "end": "2122160"
  },
  {
    "text": "overhead and actually trying to run these detections in theory rob should also have a signal",
    "start": "2122160",
    "end": "2129359"
  },
  {
    "text": "in branch miss bricks right rock chains make the return stack buffer and the",
    "start": "2129359",
    "end": "2134800"
  },
  {
    "text": "processor basically useless because you're returning all over the place to places where you're not coming from",
    "start": "2134800",
    "end": "2141359"
  },
  {
    "text": "problem here though is that rock chains are really short right you're looking at kind of 50 to",
    "start": "2141359",
    "end": "2146560"
  },
  {
    "text": "100 instructions at most you definitely could have longer one but there's often not a need for it and so",
    "start": "2146560",
    "end": "2152560"
  },
  {
    "text": "you're dealing with 50 to 100 branch missed predicts which in the grand scheme things just really isn't that",
    "start": "2152560",
    "end": "2158079"
  },
  {
    "text": "much so we wanted to take a crack at it though so we ran a rob exploit that i developed",
    "start": "2158079",
    "end": "2166560"
  },
  {
    "text": "about a hundred or so we ran a rob exploit that i developed",
    "start": "2166560",
    "end": "2172000"
  },
  {
    "text": "a hundred times uh per cycle to maximize whatever signal we could find which obviously means that the data from",
    "start": "2172000",
    "end": "2178480"
  },
  {
    "text": "this is not really productionizable it just means we're just looking to see if there is anything to be there",
    "start": "2178480",
    "end": "2184079"
  },
  {
    "text": "or to be seen there in the first place uh we also added a new baseline program which did exactly what the rock chain",
    "start": "2184079",
    "end": "2190560"
  },
  {
    "text": "did but without propping so same syscalls same memory creation same snack pivoting",
    "start": "2190560",
    "end": "2195920"
  },
  {
    "text": "all that this is just to make sure that we're actually picking up the rock chain itself and not side effects of whatever the",
    "start": "2195920",
    "end": "2203520"
  },
  {
    "text": "rock chain is doing and crazy enough after running all this and crunching the numbers",
    "start": "2203520",
    "end": "2210000"
  },
  {
    "text": "the exact same counters work for rob as did for spectre vector variants",
    "start": "2210000",
    "end": "2216560"
  },
  {
    "text": "and this absolutely blew my mind the first time that we got the data back for this because",
    "start": "2216560",
    "end": "2222880"
  },
  {
    "text": "this just doesn't make any sense and so i spent a good at least a good few hours trying to",
    "start": "2222880",
    "end": "2228160"
  },
  {
    "text": "figure out like how did we mess up there must be something wrong here what did we do um but no it turns out",
    "start": "2228160",
    "end": "2234240"
  },
  {
    "text": "as you can see we're we're doing pretty well it's definitely not as good as our spectre detections were but",
    "start": "2234240",
    "end": "2240720"
  },
  {
    "text": "it's better than the coin toss much better than the coin toss um as you can see from the confusion",
    "start": "2240720",
    "end": "2246079"
  },
  {
    "text": "matrix the main problem that we have isn't in false positiving",
    "start": "2246079",
    "end": "2252240"
  },
  {
    "text": "on normal programs it's that we don't always pick up the rock chain which again leads back to what we've",
    "start": "2252240",
    "end": "2259839"
  },
  {
    "text": "seen before with using the branch predictor and branch misses but using these undocumented counters",
    "start": "2259839",
    "end": "2266400"
  },
  {
    "text": "which again seem to not have anything to do with the branch predictor because they also picked up spectre um we're still getting",
    "start": "2266400",
    "end": "2273359"
  },
  {
    "text": "77 malicious classifications correct so there's a lot more research to be",
    "start": "2273359",
    "end": "2280640"
  },
  {
    "text": "done in this bit because again this just does not make much sense but nonetheless it's how it",
    "start": "2280640",
    "end": "2287680"
  },
  {
    "text": "is so now that we know all this now that we've covered basically everything else um i want to",
    "start": "2287680",
    "end": "2294800"
  },
  {
    "text": "spend a little bit of time talking about interpreting these results the little that we know about it so",
    "start": "2294800",
    "end": "2302320"
  },
  {
    "text": "for spectre there's a single support file inside of intel vtune which names",
    "start": "2302320",
    "end": "2309440"
  },
  {
    "text": "the ef event id has coarse new response with the helpful description of tvd",
    "start": "2309440",
    "end": "2314880"
  },
  {
    "text": "um thanks intel um supposedly though this is only for",
    "start": "2314880",
    "end": "2320320"
  },
  {
    "text": "skylake x and cascade lake so much newer microarchitectures than what we're testing on",
    "start": "2320320",
    "end": "2326079"
  },
  {
    "text": "however it does make a little bit of sense the hypothesis currently is that this ef",
    "start": "2326079",
    "end": "2334000"
  },
  {
    "text": "counter is detecting it's detecting the cl flush somehow if this is actually horse nuke",
    "start": "2334000",
    "end": "2341280"
  },
  {
    "text": "response it could be from other cores basically acknowledging the cl flush and responding to the core where the",
    "start": "2341280",
    "end": "2347119"
  },
  {
    "text": "seal flush originated or it could be something else entirely that's actually just completely",
    "start": "2347119",
    "end": "2352160"
  },
  {
    "text": "undocumented but it does seem to have some correlation with cl flush um the main reason we think",
    "start": "2352160",
    "end": "2358079"
  },
  {
    "text": "this is that the counters actually showed that the sample program was malicious that",
    "start": "2358079",
    "end": "2363680"
  },
  {
    "text": "the spectre of concept was malicious even when the actual like flush and reload exfiltration bit was",
    "start": "2363680",
    "end": "2369920"
  },
  {
    "text": "broken so we are correctly cl flushing things we just weren't retrieving data and this was still classified as",
    "start": "2369920",
    "end": "2376160"
  },
  {
    "text": "malicious so that's definitely an encouraging sign that we're not just picking up on",
    "start": "2376160",
    "end": "2382800"
  },
  {
    "text": "some other counter that's measuring cash misses this definitely seems to be something new and better",
    "start": "2382800",
    "end": "2390720"
  },
  {
    "text": "for rob very unsure as we saw before it's the same counter so we know that there can't be",
    "start": "2390880",
    "end": "2397680"
  },
  {
    "text": "too many other options for what the ef counter does at least it definitely seems related to cl",
    "start": "2397680",
    "end": "2403040"
  },
  {
    "text": "flushing so continuing on the idea that it has to do with uh cache flushing and cash",
    "start": "2403040",
    "end": "2410480"
  },
  {
    "text": "less level cash management stuff um a couple theories this could be",
    "start": "2410480",
    "end": "2415680"
  },
  {
    "text": "detecting the embedded stack pivot in the rop sample uh specifically",
    "start": "2415680",
    "end": "2421280"
  },
  {
    "text": "i don't know this for effect but if the processor keeps special store buffers around for the stack since it's used",
    "start": "2421280",
    "end": "2427359"
  },
  {
    "text": "so commonly uh if rsp changes perhaps it has to invalidate and flush all of those",
    "start": "2427359",
    "end": "2432640"
  },
  {
    "text": "which could cause a flood of effectively cl flushes um it could also be detecting the return",
    "start": "2432640",
    "end": "2440640"
  },
  {
    "text": "stack buffer mispredicts in kind of an odd way uh theory is if the caches are preemptively",
    "start": "2440640",
    "end": "2448560"
  },
  {
    "text": "loading based on what's in the return stack buffer then you'll cache miss every time right",
    "start": "2448560",
    "end": "2455359"
  },
  {
    "text": "because your return stack buffer is saying all right load this cache loads that and then suddenly you're not returning there you're",
    "start": "2455359",
    "end": "2460960"
  },
  {
    "text": "returning where else the route or wherever else the rop change is going um very unsure about these but",
    "start": "2460960",
    "end": "2467599"
  },
  {
    "text": "some initial ideas were very unsure so future work",
    "start": "2467599",
    "end": "2474560"
  },
  {
    "text": "the biggest thing here is in my mind generalizing and automating data",
    "start": "2475040",
    "end": "2480160"
  },
  {
    "text": "collection you have scripts that will run through all the perf counters for whatever program you want but we've only done it again on two micro architectures",
    "start": "2480160",
    "end": "2487200"
  },
  {
    "text": "so extending all that to be done on all the micro architectures that you could reasonably care about nowadays",
    "start": "2487200",
    "end": "2493520"
  },
  {
    "text": "and this is actually made somewhat easier by the fact that the cloud is so prevalent now you know in theory you could just buy a",
    "start": "2493520",
    "end": "2500880"
  },
  {
    "text": "instance out for each micro architecture for a couple hours run the script get your data and you're done we just",
    "start": "2500880",
    "end": "2506880"
  },
  {
    "text": "haven't done it yet um there's other also pmus to explore",
    "start": "2506880",
    "end": "2512560"
  },
  {
    "text": "specifically the uncore counters on intel chips could be very promising because they also deal with",
    "start": "2512560",
    "end": "2517760"
  },
  {
    "text": "cash coherency stuff i have less level cash stuff um there's also amd and he is a player",
    "start": "2517760",
    "end": "2524640"
  },
  {
    "text": "again in the x86 space and presumably has a similar pipeline",
    "start": "2524640",
    "end": "2529760"
  },
  {
    "text": "architecture didn't tell i don't know for sure but i would assume so and so they'll also have",
    "start": "2529760",
    "end": "2535440"
  },
  {
    "text": "probably similar counters whether they actually expose ones that aren't documented i'm not sure of but there's research to",
    "start": "2535440",
    "end": "2542000"
  },
  {
    "text": "be done there and then of course there's also arm yet another kind of player that's come up and coming on the",
    "start": "2542000",
    "end": "2550000"
  },
  {
    "text": "field um with arm in particular there's potentially some vendor specific",
    "start": "2550000",
    "end": "2555760"
  },
  {
    "text": "internals which could be interesting to poke at uh again haven't done any of this yet so",
    "start": "2555760",
    "end": "2562160"
  },
  {
    "text": "they could be very boring but there's potential there so a couple closing remarks just to",
    "start": "2562160",
    "end": "2569200"
  },
  {
    "text": "finish everything out as i've said a couple times now due to the nature of all this being undocumented we really can't know for",
    "start": "2569200",
    "end": "2575359"
  },
  {
    "text": "sure what's going on here um unless until releases more documentation you're listening it'd be great um that",
    "start": "2575359",
    "end": "2583119"
  },
  {
    "text": "said there are definitely other experiments that we could do to try and determine what these counters are counting and so if you have any ideas",
    "start": "2583119",
    "end": "2589359"
  },
  {
    "text": "for these let us know run on yourself and tag us in a post or something uh we're all very curious now",
    "start": "2589359",
    "end": "2595359"
  },
  {
    "text": "what's going on with this so our contact info is on the first few",
    "start": "2595359",
    "end": "2600720"
  },
  {
    "text": "slides again if you want to get in touch otherwise i think we're going to transition into a q a now so thanks",
    "start": "2600720",
    "end": "2606400"
  },
  {
    "text": "everyone all right hey everyone uh thanks for watching and thanks for the questions in",
    "start": "2606400",
    "end": "2612800"
  },
  {
    "text": "chat um we basically don't have any time to actually respond to stuff on camera unfortunately",
    "start": "2612800",
    "end": "2618800"
  },
  {
    "text": "so feel free to again contact us um i'm goest encapsulate.com or at tlsims on",
    "start": "2618800",
    "end": "2624640"
  },
  {
    "text": "twitter uh yeah and harini at capslick.com or uh jarvis twitter and uh",
    "start": "2624640",
    "end": "2631920"
  },
  {
    "text": "yeah we're happy to take your questions talk about future research any of that kind of stuff um and i think with that i think we're",
    "start": "2631920",
    "end": "2638880"
  },
  {
    "text": "done yeah thank you all thank you",
    "start": "2638880",
    "end": "2643920"
  }
]