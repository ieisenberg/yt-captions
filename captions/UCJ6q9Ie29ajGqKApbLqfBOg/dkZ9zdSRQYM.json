[
  {
    "start": "0",
    "end": "168000"
  },
  {
    "text": "Welcome to our talk uh just in time cus my name is Luca Davi I a research",
    "start": "120",
    "end": "5600"
  },
  {
    "text": "assistant at the Technical University of damer and this is Kevin snow from the",
    "start": "5600",
    "end": "10679"
  },
  {
    "text": "University of North Carolina at Chapel Hill as you can see from the title Slide the work that we both present today is a",
    "start": "10679",
    "end": "18000"
  },
  {
    "text": "collaboration with among different coers uh Affiliated to one of these universities namely Alexandra Treno",
    "start": "18000",
    "end": "25039"
  },
  {
    "text": "Christopher liian and our advisers Fabian monrose and Amad sadegi",
    "start": "25039",
    "end": "31080"
  },
  {
    "text": "today we will present you a novel attack technique that we refer to as just in time code reuse or just in time return",
    "start": "31080",
    "end": "38680"
  },
  {
    "text": "oriented programming in general code reuse attacks are based on the principle",
    "start": "38680",
    "end": "44239"
  },
  {
    "text": "of exploiting a software bar such as buffer overflow error to afterwards induce arbitrary malicious program",
    "start": "44239",
    "end": "50840"
  },
  {
    "text": "behavior and this is achieved without requiring any code injection from the attacker's side instead the attacker",
    "start": "50840",
    "end": "57800"
  },
  {
    "text": "reuses existing code pieces called return oriented programming gadgets that already reside in the address space of",
    "start": "57800",
    "end": "64400"
  },
  {
    "text": "the application however in the traditional model the attacker has to run a static",
    "start": "64400",
    "end": "71080"
  },
  {
    "text": "and offline analysis phase where he inspects the binaries and libraries to find and identify useful gadgets that he",
    "start": "71080",
    "end": "77720"
  },
  {
    "text": "wants to use for his exploit now a potential defense against these attacks is the enforcement of memory",
    "start": "77720",
    "end": "84240"
  },
  {
    "text": "randomization such as aslr however as you all may know aslr is one unble to",
    "start": "84240",
    "end": "90520"
  },
  {
    "text": "memory disclosure attacks where a single leak pointer is sufficient to uh still",
    "start": "90520",
    "end": "96399"
  },
  {
    "text": "launch code reuse attacks to tackle this shortcoming a couple of researchers",
    "start": "96399",
    "end": "102119"
  },
  {
    "text": "investigated F grain randomization techniques where you don't not only randomize The Base address of a code",
    "start": "102119",
    "end": "108360"
  },
  {
    "text": "segment but also the internal structure and the claim of these proposals is that",
    "start": "108360",
    "end": "115040"
  },
  {
    "text": "if you have fine Grant randomization a a single leak pointer is no longer sufficient to launch Cod use attacks",
    "start": "115040",
    "end": "121840"
  },
  {
    "text": "however as we will show you in our in the next minutes our technique is able",
    "start": "121840",
    "end": "126960"
  },
  {
    "text": "to bypass the schemes and reuse the existing memory disclosure vulnerabilities that are already out",
    "start": "126960",
    "end": "132879"
  },
  {
    "text": "there to leak a large amount of memory pages and afterwards calc identify",
    "start": "132879",
    "end": "138599"
  },
  {
    "text": "return oriented programming gadgets on the fly without requiring any static analysis before Kevin will walk you",
    "start": "138599",
    "end": "145840"
  },
  {
    "text": "through as the main developer of the attack will walk you through all the attack details and even show you an",
    "start": "145840",
    "end": "151879"
  },
  {
    "text": "exploit against IE 10 on running on Windows 8 using the latest uh",
    "start": "151879",
    "end": "157879"
  },
  {
    "text": "vulnerability that has been also exploited in the pawn to own contest this year I will briefly uh walk you",
    "start": "157879",
    "end": "163760"
  },
  {
    "text": "through the basics of return oriented programming and memory randomization the most widely exploited",
    "start": "163760",
    "end": "170200"
  },
  {
    "text": "software programs today are very rich reading processing programs as well as web browsers and typically these",
    "start": "170200",
    "end": "176879"
  },
  {
    "text": "applications have the ability to embed many typ types of data and also they feature scripting facilities such as",
    "start": "176879",
    "end": "183879"
  },
  {
    "text": "JavaScript which an attacker can utilize to uh facilitate his attacks moreover",
    "start": "183879",
    "end": "190519"
  },
  {
    "text": "these applications link by default to a large amount of native code which makes them subject to runtime attacks",
    "start": "190519",
    "end": "197840"
  },
  {
    "text": "nevertheless current operating systems deploy the principle of non-executable memory ensuring that a memory page",
    "start": "197840",
    "end": "204519"
  },
  {
    "text": "cannot be writable and executable at the same time thereby rendering code injection",
    "start": "204519",
    "end": "210400"
  },
  {
    "text": "attacks infeasible hence attackers today have to rely on code reuse attack strategies",
    "start": "210400",
    "end": "217920"
  },
  {
    "text": "where they already reuse Co code pieces that recite in memory and are marked as",
    "start": "217920",
    "end": "223080"
  },
  {
    "text": "executable and a prominent example for code reuse attacks is return oriented",
    "start": "223080",
    "end": "228360"
  },
  {
    "text": "programming a good analogy for code reuse attacks or return oriented programming is a newspaper article",
    "start": "228360",
    "end": "235079"
  },
  {
    "text": "consider this article that consists of a large number of letters that form words",
    "start": "235079",
    "end": "240280"
  },
  {
    "text": "and at the end sentences if we now are able to extract a couple of letters and",
    "start": "240280",
    "end": "245720"
  },
  {
    "text": "combine them in a malicious way we can derive new words that have been never intended by the author of the text for",
    "start": "245720",
    "end": "252519"
  },
  {
    "text": "instance in this example we have the new word return oriented programming and this is actually the basic idea behind",
    "start": "252519",
    "end": "259400"
  },
  {
    "text": "return oriented programming one has only to replace the letters with machine instructions meaning that an attacker",
    "start": "259400",
    "end": "266600"
  },
  {
    "text": "can generate new malicious programs out out of existing benign",
    "start": "266600",
    "end": "272240"
  },
  {
    "text": "programs a more technical view of the attack is shown on this slide consider an adversary and an abstract view of a",
    "start": "272240",
    "end": "279600"
  },
  {
    "text": "program memory layout where we have segments for code Heap and stack in the",
    "start": "279600",
    "end": "284960"
  },
  {
    "text": "code segment we have a couple of so-called return oriented programming gadgets where each Gadget fulfills a",
    "start": "284960",
    "end": "291759"
  },
  {
    "text": "particular task such as loading Aver from memory or adding two registers",
    "start": "291759",
    "end": "296880"
  },
  {
    "text": "another property of all these gadgets is that they termin in a x86 r or return",
    "start": "296880",
    "end": "302840"
  },
  {
    "text": "instruction and this instruction is actually giving return oriented programming its name as you will see",
    "start": "302840",
    "end": "308919"
  },
  {
    "text": "soon moreover in this simplified example we consider a couple of Stack variables",
    "start": "308919",
    "end": "314440"
  },
  {
    "text": "and the stack pointer is currently pointing to the top of the stack the first step now of the attack is to",
    "start": "314440",
    "end": "321039"
  },
  {
    "text": "inject the return oriented programming payload however the payload in this example does not consist of malicious",
    "start": "321039",
    "end": "327800"
  },
  {
    "text": "code directly but of a chain of return addresses where each return address is pointing to one of these",
    "start": "327800",
    "end": "334800"
  },
  {
    "text": "gadgets moreover we assume as a in this example a heap vulnerability which an",
    "start": "334800",
    "end": "340680"
  },
  {
    "text": "attacker can exploit to hijack the execution flow of the program in particular he redirects the execution",
    "start": "340680",
    "end": "347479"
  },
  {
    "text": "flow to the gadget that is pointed to by the first return address and this return",
    "start": "347479",
    "end": "352520"
  },
  {
    "text": "address points to the stack pivot Gadget this gadget has a particular task in",
    "start": "352520",
    "end": "358280"
  },
  {
    "text": "every return oriented programming payload and specifically it sets up the stack pointer so that the stack pointer",
    "start": "358280",
    "end": "365120"
  },
  {
    "text": "points to the beginning of our return oriented programming payload which in this example is return address",
    "start": "365120",
    "end": "371479"
  },
  {
    "text": "to once the final return instruction is issued by the stack P Gadget then we pop",
    "start": "371479",
    "end": "378160"
  },
  {
    "text": "return address to from the stack and redirect the execution to the next Gadget in our chain which is a load",
    "start": "378160",
    "end": "384800"
  },
  {
    "text": "Gadget and automatically the return instruction advances a stack pointer by 4X",
    "start": "384800",
    "end": "390680"
  },
  {
    "text": "and an attacker can now repeat repeat this procedure as long as he desires for",
    "start": "390680",
    "end": "395840"
  },
  {
    "text": "instance after the load load Gadget has been executed the return instruction would redirect the execution to the",
    "start": "395840",
    "end": "402599"
  },
  {
    "text": "final Gadget which is the add Gadget in this",
    "start": "402599",
    "end": "406840"
  },
  {
    "text": "example obviously code reuse attacks already exist for a couple of years and",
    "start": "407639",
    "end": "413120"
  },
  {
    "text": "to give you a very brief and selected overview of the most relevant papers in the space we have created this slide it",
    "start": "413120",
    "end": "420520"
  },
  {
    "text": "basically started in 1997 where solar designer presented an exploit where he",
    "start": "420520",
    "end": "426400"
  },
  {
    "text": "was able to redirect the execution to a library function ellip C in 2010 uh 2001",
    "start": "426400",
    "end": "433800"
  },
  {
    "text": "nargal advances this idea and showed how to call uh a couple a chain of functions",
    "start": "433800",
    "end": "440120"
  },
  {
    "text": "in a return into leap C like fashion in 2005 ker presented bored Co chun's",
    "start": "440120",
    "end": "446599"
  },
  {
    "text": "exploitation which already included the basic ideas of return oned programming",
    "start": "446599",
    "end": "451639"
  },
  {
    "text": "specifically he used a couple of gadgets to load registers and to afterwards call",
    "start": "451639",
    "end": "457360"
  },
  {
    "text": "functions in 2007 hovav shakam finalized this idea and presented his paper on",
    "start": "457360",
    "end": "463840"
  },
  {
    "text": "return oriented programming in particular he showed that the attack technique in contrast to standard return",
    "start": "463840",
    "end": "470360"
  },
  {
    "text": "and lip C is touring complete meaning that you can run arbitrary computation",
    "start": "470360",
    "end": "475879"
  },
  {
    "text": "and malicious behavior in 2008 have also presented return oned programming on",
    "start": "475879",
    "end": "482599"
  },
  {
    "text": "blackhead and moreover in the same year we have seen return oned programming attacks against spark processors and",
    "start": "482599",
    "end": "489720"
  },
  {
    "text": "admal a embedded processors in 2009 Ral hun at all showed",
    "start": "489720",
    "end": "495879"
  },
  {
    "text": "that return oriented programming can be also applied to rootkits moreover in the same year FX lner showed return on",
    "start": "495879",
    "end": "503680"
  },
  {
    "text": "programming against Cisco routs and Charlie Miller and Vincenzo yutu showed an exploit against iOS on arm",
    "start": "503680",
    "end": "510800"
  },
  {
    "text": "processors and finally in 2010 we had a couple of papers at blackhead and also",
    "start": "510800",
    "end": "516120"
  },
  {
    "text": "return programming has been used in the pawn to own contest to exploit the Safari browser on iPhone and to exploit",
    "start": "516120",
    "end": "522880"
  },
  {
    "text": "IE8 on Windows uh Windows 7 moreover we also have seen a paper on return on to",
    "start": "522880",
    "end": "529160"
  },
  {
    "text": "programming without returns showing that the attack does not necessarily require return instructions to be executed but",
    "start": "529160",
    "end": "535880"
  },
  {
    "text": "indirect jumps and indirect calls can be used as well",
    "start": "535880",
    "end": "540920"
  },
  {
    "start": "539000",
    "end": "673000"
  },
  {
    "text": "however all the mentioned Works require that static analysis phase to identify the gadgets that uh an attacker wants to",
    "start": "540920",
    "end": "547720"
  },
  {
    "text": "leverage in his attack now one potential in defense at least from a theoretical standpoint of view is to employ uh to",
    "start": "547720",
    "end": "555600"
  },
  {
    "text": "deploy address based layout randomization the basic idea of aslr is",
    "start": "555600",
    "end": "560959"
  },
  {
    "text": "to randomize the start or Base address of code and data segments consider for",
    "start": "560959",
    "end": "566519"
  },
  {
    "text": "this again an abstract view of a program memory layout where we have segments for Library executable Heap and stack if the",
    "start": "566519",
    "end": "573600"
  },
  {
    "text": "application is restarted then all the base addresses get randomized and an attacker does no can only guess where",
    "start": "573600",
    "end": "580880"
  },
  {
    "text": "his gadgets and codes that he wants to reuse recites in memory however aslr is",
    "start": "580880",
    "end": "586519"
  },
  {
    "text": "vulnerable to memory disclosure attacks where an attacker retrieves a single runtime address and based on that",
    "start": "586519",
    "end": "593000"
  },
  {
    "text": "runtime address such as the leak function pointer he adjusts all the addresses pointing to his gadgets by by",
    "start": "593000",
    "end": "599519"
  },
  {
    "text": "the randomization of that this attack is possible because aslr only randomizes",
    "start": "599519",
    "end": "605040"
  },
  {
    "text": "the start address but the internal structure Remains the Same a more detailed example of a memory",
    "start": "605040",
    "end": "612440"
  },
  {
    "text": "disclosure attack is shown on this slide where the example is taken from CERN last year's talk at",
    "start": "612440",
    "end": "618920"
  },
  {
    "text": "blackhead consider a couple of objects on the Heap where the first object is a vulnerable object that contains uh as a",
    "start": "618920",
    "end": "626720"
  },
  {
    "text": "member variable a buffer afterwards we have a JavaScript string and finally an object that contains some interesting",
    "start": "626720",
    "end": "633360"
  },
  {
    "text": "function pointers that we want to read the attack now works as follows we overflow the buffer and overwrite the",
    "start": "633360",
    "end": "641279"
  },
  {
    "text": "length field of the JavaScript string in particular we set it to the maximum size",
    "start": "641279",
    "end": "646320"
  },
  {
    "text": "which allows us to use standard string Methods in JavaScript to read any address from the memory space in",
    "start": "646320",
    "end": "653000"
  },
  {
    "text": "particular we can read the function pointer of the object that is just next to the JavaScript string",
    "start": "653000",
    "end": "660200"
  },
  {
    "text": "however the challenge here is that we can only read from addresses that are",
    "start": "660200",
    "end": "665639"
  },
  {
    "text": "mapped to the address base of an application otherwise the application would crash and the exploit would not",
    "start": "665639",
    "end": "673040"
  },
  {
    "start": "673000",
    "end": "802000"
  },
  {
    "text": "work now to tackle this shortcoming of address based layout randomization where",
    "start": "673040",
    "end": "678279"
  },
  {
    "text": "a single leak pointer is sufficient to bypass the entire scheme researchers",
    "start": "678279",
    "end": "683560"
  },
  {
    "text": "have proposed in the last two years the principle of fine grained address based layout randomization",
    "start": "683560",
    "end": "690200"
  },
  {
    "text": "and the idea is quite straightforward we do not only randomize The Base address",
    "start": "690200",
    "end": "695839"
  },
  {
    "text": "of an of a library but we also randomize the internal structure for instance in this example instruction sequence one is",
    "start": "695839",
    "end": "703399"
  },
  {
    "text": "moved from the top to the middle and the other instruction sequences their location are also",
    "start": "703399",
    "end": "709639"
  },
  {
    "text": "randomized now let us go in more detail for each of these proposals the first",
    "start": "709639",
    "end": "715079"
  },
  {
    "text": "proposal presented by presented by Papas at all enforces randomization within a",
    "start": "715079",
    "end": "720760"
  },
  {
    "text": "basic block and the authors specifically propose three randomization techniques",
    "start": "720760",
    "end": "726639"
  },
  {
    "text": "the first technique is based on instruction reordering which is obviously only possible if the",
    "start": "726639",
    "end": "732959"
  },
  {
    "text": "instruction sequence uh if the instructions have no dependency from each other so they that they can be",
    "start": "732959",
    "end": "738279"
  },
  {
    "text": "easily switched the second technique proposed is instruction substitution where we",
    "start": "738279",
    "end": "744000"
  },
  {
    "text": "replace an existing instruction with an equivalent instruction that has the same",
    "start": "744000",
    "end": "749240"
  },
  {
    "text": "same effect note that this technique does not directly prevent return oriented programming however recall that",
    "start": "749240",
    "end": "757399"
  },
  {
    "text": "return on programming can also be based on unintended instruction sequences where we have a C3 bite presenting",
    "start": "757399",
    "end": "765320"
  },
  {
    "text": "representing a return instruction in x86 within the op code of a move instruction",
    "start": "765320",
    "end": "770560"
  },
  {
    "text": "so to eliminate these unintended instruction sequences one could deploy this instruction substitution technique",
    "start": "770560",
    "end": "777320"
  },
  {
    "text": "and finally the authors propos register reallocation by if this is for instance",
    "start": "777320",
    "end": "783199"
  },
  {
    "text": "possible if a register is free to use then we can replace that with with another register however this scheme",
    "start": "783199",
    "end": "790079"
  },
  {
    "text": "only performs randomization within a basic block um so that functions remain",
    "start": "790079",
    "end": "795800"
  },
  {
    "text": "at their original position allowing return into lip C attacks still to happen where I call antire",
    "start": "795800",
    "end": "802560"
  },
  {
    "start": "802000",
    "end": "931000"
  },
  {
    "text": "functions the second proposal uses basic block randomization or basic block",
    "start": "802560",
    "end": "808120"
  },
  {
    "text": "permutation and the idea is as follows consider we have three basic blocks in",
    "start": "808120",
    "end": "813199"
  },
  {
    "text": "our program and each basic block consists of two instructions where we have also a call instruction that uh in",
    "start": "813199",
    "end": "821320"
  },
  {
    "text": "bbl1 that calls the bbl3 now we reshuffle all the bbls in",
    "start": "821320",
    "end": "827519"
  },
  {
    "text": "the memory so that they get get a new position so bbl1 is moved to the bottom bbl2 to the top and finally bbl3 to the",
    "start": "827519",
    "end": "836720"
  },
  {
    "text": "middle this reordering in also involves adjusting memory addresses for instance",
    "start": "836720",
    "end": "842519"
  },
  {
    "text": "the former call to the address of one FF has now to be adjusted to one a0 because",
    "start": "842519",
    "end": "850480"
  },
  {
    "text": "bbl3 has moved its position moreover the return instruction",
    "start": "850480",
    "end": "855759"
  },
  {
    "text": "issued in bbl3 will Target the uh the instruction following the call instruction in",
    "start": "855759",
    "end": "861519"
  },
  {
    "text": "bbl1 hence we have to add another jump instruction to preserve the semantic",
    "start": "861519",
    "end": "866920"
  },
  {
    "text": "original flow of uh of of the program as you can see this technique",
    "start": "866920",
    "end": "873120"
  },
  {
    "text": "requires a lot of binary rewriting techniques which is a challenging task the final randomization technique",
    "start": "873120",
    "end": "880399"
  },
  {
    "text": "that I want to present is instruction location randomization technique this technique offers the highest entropy for",
    "start": "880399",
    "end": "887800"
  },
  {
    "text": "randomization it basically randomizes the location of every instruction in the",
    "start": "887800",
    "end": "893320"
  },
  {
    "text": "memory so if you have an example of six instruction then all these instructions",
    "start": "893320",
    "end": "898519"
  },
  {
    "text": "are distributed over the entire memory and again we also have to adjust memory offsets at runtime the program is loaded",
    "start": "898519",
    "end": "906519"
  },
  {
    "text": "into a binary instrumentation framework and the execution is guided through a false uh so-called false through map",
    "start": "906519",
    "end": "913920"
  },
  {
    "text": "which indicates which instruction needs to be executed next and obviously this",
    "start": "913920",
    "end": "919040"
  },
  {
    "text": "antire binary instrumentation framework induces a lot of performance penalties",
    "start": "919040",
    "end": "924600"
  },
  {
    "text": "and also uses the benefits of cache models because every instruction is distributed",
    "start": "924600",
    "end": "931680"
  },
  {
    "text": "memory all right so the main question we were trying to answer in the work that we did was whether fine grain aslr",
    "start": "935279",
    "end": "942519"
  },
  {
    "text": "actually provides any benefit over the standard aslr scheme and if it does we",
    "start": "942519",
    "end": "947759"
  },
  {
    "text": "want to know if it is going to provide a viable defense in the long run so in our",
    "start": "947759",
    "end": "952959"
  },
  {
    "text": "pursuit of answering that question we made the following contributions in our work first we developed a novel attack",
    "start": "952959",
    "end": "958639"
  },
  {
    "text": "class that does in fact undermine fine grain aslr that we dubbed just in time",
    "start": "958639",
    "end": "963920"
  },
  {
    "text": "code reuse second we also show that memory disclosures are far far more",
    "start": "963920",
    "end": "969160"
  },
  {
    "text": "damaging than many have pre previously believed finally we don't just talk about this idea in theory we actually",
    "start": "969160",
    "end": "975600"
  },
  {
    "text": "developed a prototype exploit framework that demonstrates one instantiation of our idea and since that instantiation is",
    "start": "975600",
    "end": "982959"
  },
  {
    "text": "based on the Paradigm of return oriented programming we call it jit R before before I get into the details",
    "start": "982959",
    "end": "989920"
  },
  {
    "text": "of how jitr actually works let's talk about some assumptions on the defender side or the vulnerable application that",
    "start": "989920",
    "end": "995959"
  },
  {
    "text": "we're trying to protect we assume a non-executable stack and Heap and this",
    "start": "995959",
    "end": "1001240"
  },
  {
    "text": "essentially means that the adversary is not able to directly inject code to execute as a payload instead they have",
    "start": "1001240",
    "end": "1008120"
  },
  {
    "text": "to make use of some code reuse strategy second we also assume a strong",
    "start": "1008120",
    "end": "1014360"
  },
  {
    "text": "fine grained aslr scheme is used with no implementation specific flaws think about all the fine grain aslr schemes",
    "start": "1014360",
    "end": "1021399"
  },
  {
    "text": "that Luca just presented combined and just taking the best features of all those with none of the problems on the",
    "start": "1021399",
    "end": "1027280"
  },
  {
    "text": "adversary side we have similar assumptions to those that are required to defeat standard",
    "start": "1027280",
    "end": "1032839"
  },
  {
    "text": "aslr namely we do require that there is a memory disclosure vulnerability present that's going to enable us to",
    "start": "1032839",
    "end": "1038839"
  },
  {
    "text": "read the value of an arbitrary address in memory second we also require that",
    "start": "1038839",
    "end": "1044000"
  },
  {
    "text": "there is some control flow of vulnerability that's going to allow the adversary to redirect the normal control flow of the program to whatever payload",
    "start": "1044000",
    "end": "1050640"
  },
  {
    "text": "we're able to generate now in practice this control flow and memory disclosure vulnerability are often actually the",
    "start": "1050640",
    "end": "1057080"
  },
  {
    "text": "exact same vulnerability just exercise in different way to achieve these two different",
    "start": "1057080",
    "end": "1063320"
  },
  {
    "start": "1063000",
    "end": "1201000"
  },
  {
    "text": "goals so here's the basics of the workflow of our jitr framework first the",
    "start": "1063440",
    "end": "1068679"
  },
  {
    "text": "adversary needs to do a few things manually just as they would need to do to defeat standard aslr the adversary is",
    "start": "1068679",
    "end": "1075280"
  },
  {
    "text": "going to have to leak a code pointer and they can do that using the memory disclosure vulnerability that we assume",
    "start": "1075280",
    "end": "1080520"
  },
  {
    "text": "is present second the adversary needs to provide some sort of exploit description",
    "start": "1080520",
    "end": "1086120"
  },
  {
    "text": "that's going to be written in a high level language that we created and that exploit description is just telling is",
    "start": "1086120",
    "end": "1091600"
  },
  {
    "text": "just telling us what the adversary wants the actions to be taken after the exploit",
    "start": "1091600",
    "end": "1097080"
  },
  {
    "text": "completes finally keep in mind that all the steps I'm going to talk about are all happening at runtime within the",
    "start": "1097080",
    "end": "1103679"
  },
  {
    "text": "context of a vulnerable application that's making use of A fine grain aslr scheme",
    "start": "1103679",
    "end": "1109480"
  },
  {
    "text": "and because fine grain aslr is in use we know that just leaking a single code pointer is actually not going to give us",
    "start": "1109480",
    "end": "1115600"
  },
  {
    "text": "any additional useful information that's going to directly help us to generate a rot payload so the first thing the jit",
    "start": "1115600",
    "end": "1123559"
  },
  {
    "text": "rot framework takes care of for us is given a single initial leite code",
    "start": "1123559",
    "end": "1128600"
  },
  {
    "text": "pointer uh jit Rod frameworker will try to map as many pages of memory as it",
    "start": "1128600",
    "end": "1133919"
  },
  {
    "text": "possibly can and I'll get into the details of how we do that in a few slides",
    "start": "1133919",
    "end": "1139640"
  },
  {
    "text": "next because fine grain aslr is in use we don't know any useful information about pre-existing uh code sequences",
    "start": "1139640",
    "end": "1147080"
  },
  {
    "text": "that we can use as R gadgets we have to discover all that dynamically at runtime",
    "start": "1147080",
    "end": "1152159"
  },
  {
    "text": "and so that's the next step that jitr takes care of automatically for us next because any useful payload that an",
    "start": "1152159",
    "end": "1159200"
  },
  {
    "text": "adversary might want to run does eventually need to interact with the operating system and the canonical way",
    "start": "1159200",
    "end": "1164880"
  },
  {
    "text": "of doing that is through API calls uh we're going to need to search for the the API calls that the adversary",
    "start": "1164880",
    "end": "1170480"
  },
  {
    "text": "requires in their exploit description and provide those back to them finally we take all the information",
    "start": "1170480",
    "end": "1176799"
  },
  {
    "text": "that we collected in all these steps as well as the adversaries exploit description which is just this high",
    "start": "1176799",
    "end": "1181880"
  },
  {
    "text": "level language and we dynamically compile a rck payload based on all the information we found then we return that",
    "start": "1181880",
    "end": "1189280"
  },
  {
    "text": "rot payload back to the adversary script uh and the adversary can then leverage",
    "start": "1189280",
    "end": "1194600"
  },
  {
    "text": "the control flow of vulnerability to redirect the program control flow to the new generated rot",
    "start": "1194600",
    "end": "1200960"
  },
  {
    "text": "payload so I know that all looks very easy in our highle diagram there but we actually had encountered a number of",
    "start": "1200960",
    "end": "1207320"
  },
  {
    "start": "1201000",
    "end": "1291000"
  },
  {
    "text": "challenges along the way and the biggest one in my mind is that we have to find a way to map memory without crashing the",
    "start": "1207320",
    "end": "1214280"
  },
  {
    "text": "program although we do have a memory disclosure of vulnerability available allows us to read the value at an",
    "start": "1214280",
    "end": "1220120"
  },
  {
    "text": "arbitrary address it turns out that at least in all the applications we looked at over 90% of the memory space of the",
    "start": "1220120",
    "end": "1227159"
  },
  {
    "text": "program is actually unmapped and if we use the memory disclosure of vulnerability to read one of those addresses the program's going to crash",
    "start": "1227159",
    "end": "1233520"
  },
  {
    "text": "and our exploit is going to fail so we need to find a way to reliably do this without crashing the",
    "start": "1233520",
    "end": "1239600"
  },
  {
    "text": "program second keep in mind that we have no prior knowledge ahead of time we do no static analysis to determine what R",
    "start": "1239600",
    "end": "1246520"
  },
  {
    "text": "uh what R gadgets are available because fine gra aslr is going to change all that each time the program runs so we",
    "start": "1246520",
    "end": "1252360"
  },
  {
    "text": "have to be able to find all the gadgets we need find all the API calls we need and use all that information to compile",
    "start": "1252360",
    "end": "1257799"
  },
  {
    "text": "a payload all completely dynamically at the time the exploit is running on the victim's",
    "start": "1257799",
    "end": "1263400"
  },
  {
    "text": "machine and because this all has to be done at runtime the entire process needs to be fully automated there's no room",
    "start": "1263400",
    "end": "1270320"
  },
  {
    "text": "whatsoever for error the adversary can't step in and manually fix anything along the way because by the time this is all",
    "start": "1270320",
    "end": "1275960"
  },
  {
    "text": "running it's already on the victim's machine finally as I mentioned before we",
    "start": "1275960",
    "end": "1281480"
  },
  {
    "text": "don't want to just talk about all this we actually wanted to see if we could build this framework and demonstrate",
    "start": "1281480",
    "end": "1286679"
  },
  {
    "text": "that we can provide an efficient and practical exploit so here's how we address some of",
    "start": "1286679",
    "end": "1293600"
  },
  {
    "start": "1291000",
    "end": "1463000"
  },
  {
    "text": "those challenges first for mapping memory we made the observation that if we can leak just this single function",
    "start": "1293600",
    "end": "1300039"
  },
  {
    "text": "pointer that actually tells us that there is at least a whole page of memory present and that's just virtual memory",
    "start": "1300039",
    "end": "1306960"
  },
  {
    "text": "how virtual memory Works uh and if we know a page of memory is present since memory pages are aligned in memory we",
    "start": "1306960",
    "end": "1313240"
  },
  {
    "text": "also know exactly where that page of memory starts and where it ends so when we have that information we can leverage",
    "start": "1313240",
    "end": "1319760"
  },
  {
    "text": "the memory disclosure vulnerability to leak the content of that memory page",
    "start": "1319760",
    "end": "1325520"
  },
  {
    "text": "then again at run time we disassemble the contents of that of that code page",
    "start": "1325520",
    "end": "1330960"
  },
  {
    "text": "and we look for all call and jump instructions that point to another page in memory when we find those we cue them",
    "start": "1330960",
    "end": "1337919"
  },
  {
    "text": "up and perform the same analysis on those and we recursively repeat this",
    "start": "1337919",
    "end": "1343039"
  },
  {
    "text": "process until we've exhausted all the pages that are somehow interconnected with that initial leaked function",
    "start": "1343039",
    "end": "1349799"
  },
  {
    "text": "pointer page now that we have all the pages that",
    "start": "1349799",
    "end": "1356320"
  },
  {
    "text": "we need the next step is to look at API calls now consider that the adversary might want to write a payload like this",
    "start": "1356320",
    "end": "1362960"
  },
  {
    "text": "and this is your classic download a file from the web then execute it and try to cleanly exit the process",
    "start": "1362960",
    "end": "1369200"
  },
  {
    "text": "payload the problem is when we're iterating over all the code pages in memory what we usually find is something",
    "start": "1369200",
    "end": "1376600"
  },
  {
    "text": "like this we see a lot of just standard Windows function calls dealing with Windows etc etc and often these function",
    "start": "1376600",
    "end": "1383200"
  },
  {
    "text": "calls we find while iterating over uh the code Pages don't match up at all to",
    "start": "1383200",
    "end": "1388440"
  },
  {
    "text": "what the adversary wants to actually use in their payload so we need a way to actually find or look up those API calls",
    "start": "1388440",
    "end": "1396559"
  },
  {
    "text": "so as it turns out something that is very common in almost all programs is dynamically loading both libraries and",
    "start": "1396559",
    "end": "1404520"
  },
  {
    "text": "uh dynamically figuring out where function pointers are and those are done with the API calls standard Windows API",
    "start": "1404520",
    "end": "1410279"
  },
  {
    "text": "calls load library and get proc address and as it turns out these are scattered throughout uh most code pages so our",
    "start": "1410279",
    "end": "1418080"
  },
  {
    "text": "solution instead of actually looking for the API calls that the adversary really needs we just look up the load library",
    "start": "1418080",
    "end": "1424720"
  },
  {
    "text": "and get proc address calls and then require that the adversary writes a payload where all of the API calls need",
    "start": "1424720",
    "end": "1432200"
  },
  {
    "text": "to be dynamically looked up using the rot payload itself so the the payload on",
    "start": "1432200",
    "end": "1437440"
  },
  {
    "text": "the left would need to be Rew written to look like the payload on the right and this is very similar to how our highle",
    "start": "1437440",
    "end": "1442720"
  },
  {
    "text": "language looks essentially it's just loading a library to get the address of that library then getting the address of",
    "start": "1442720",
    "end": "1448400"
  },
  {
    "text": "the URL download to execute function and then calling that function and",
    "start": "1448400",
    "end": "1453600"
  },
  {
    "text": "continuing on and here the at symbol you're seeing simply represents the return value of the last uh of the last",
    "start": "1453600",
    "end": "1462799"
  },
  {
    "start": "1463000",
    "end": "1636000"
  },
  {
    "text": "function next we've mapped out all these code Pages we found the API calls that we need which were just those two API",
    "start": "1463120",
    "end": "1469720"
  },
  {
    "text": "calls uh the next step is to actually look for useful sequences of code that",
    "start": "1469720",
    "end": "1475840"
  },
  {
    "text": "we can use as Gadgets in the next step when we compile a payload so the way we do that is it by iterating over all the",
    "start": "1475840",
    "end": "1481880"
  },
  {
    "text": "code Pages we found and we use the Galileo algorithm originally introduced by shakam in 2007 and all that algorithm",
    "start": "1481880",
    "end": "1488799"
  },
  {
    "text": "does for us is give us an efficient way to extract all the short code sequences",
    "start": "1488799",
    "end": "1494159"
  },
  {
    "text": "from all the pages of memory that we've found now keep in mind that in the next",
    "start": "1494159",
    "end": "1499200"
  },
  {
    "text": "step we need a way to automatically use all these code sequences to compile a payload so we need to abstract some of",
    "start": "1499200",
    "end": "1505679"
  },
  {
    "text": "these code sequences into higher level Gadget types uh so we can work with them easily in The Next Step so the way we do",
    "start": "1505679",
    "end": "1512039"
  },
  {
    "text": "that is just by defining a few types and each of these types just represents a discrete action like moving a register",
    "start": "1512039",
    "end": "1518559"
  },
  {
    "text": "into another register and the way we map the code sequences to the types is by",
    "start": "1518559",
    "end": "1523640"
  },
  {
    "text": "looking at the first instruction in any code sequence for example this first in",
    "start": "1523640",
    "end": "1528720"
  },
  {
    "text": "this first code sequence is just moving the register EA into the register ebx",
    "start": "1528720",
    "end": "1533799"
  },
  {
    "text": "and that Maps up exactly to a move register Gadget um we also iterate through these",
    "start": "1533799",
    "end": "1540640"
  },
  {
    "text": "and if any of the instructions uh the first instructions in the sequences doesn't map up to one of our Gadget",
    "start": "1540640",
    "end": "1546320"
  },
  {
    "text": "types that's not useful to us so we just get rid of it next the first code sequence is",
    "start": "1546320",
    "end": "1553440"
  },
  {
    "text": "actually just just represented by one single instruction uh so now since",
    "start": "1553440",
    "end": "1558559"
  },
  {
    "text": "there's no adverse effects that could possibly happen in in subsequent uh instructions after that we say that yes",
    "start": "1558559",
    "end": "1564480"
  },
  {
    "text": "this is a good Gadget let's take it make it into a gadget put it into our bin so we can use it later in our compilation",
    "start": "1564480",
    "end": "1571120"
  },
  {
    "text": "phase when we do have more than one instruction in a sequence we need to examine all the subsequent instructions",
    "start": "1571120",
    "end": "1577320"
  },
  {
    "text": "and make sure that they're not that uh excuse me that they're not going to perform some action that's going to crash the program potentially so if we",
    "start": "1577320",
    "end": "1584320"
  },
  {
    "text": "look at this second instruction sequence with a pop eax that simply a value into the eax register then we are moving the",
    "start": "1584320",
    "end": "1592240"
  },
  {
    "text": "eax register into the memory address pointed to by the ECX register but we",
    "start": "1592240",
    "end": "1597880"
  },
  {
    "text": "haven't previously defined ECX potentially so this is something that could potentially write to add to an",
    "start": "1597880",
    "end": "1602960"
  },
  {
    "text": "address that's not mapped into memory and could potentially crash the program so we do our entire Gadget analysis uh",
    "start": "1602960",
    "end": "1610240"
  },
  {
    "text": "very conservatively and for these situations we just say we don't want to use that we don't want to take the chance and we discard that now in the",
    "start": "1610240",
    "end": "1617520"
  },
  {
    "text": "last instruction sequence uh the second instruction is just moving register edx into ebx it's not writing to a location",
    "start": "1617520",
    "end": "1624039"
  },
  {
    "text": "of memory and it's not killing the value that we just loaded into eax so we say that's okay that's not going to cause",
    "start": "1624039",
    "end": "1630240"
  },
  {
    "text": "any harm so let's just add that into our Gadget",
    "start": "1630240",
    "end": "1635440"
  },
  {
    "start": "1636000",
    "end": "1719000"
  },
  {
    "text": "bin the final step in all of this is taking the adversary's highlevel exploit",
    "start": "1636640",
    "end": "1642520"
  },
  {
    "text": "description and combining that with all the gadgets that we've actually found available in the pages we've iterated it",
    "start": "1642520",
    "end": "1648440"
  },
  {
    "text": "over and trying to trying to piece those together into a payload that's actually going to perform the actions that they",
    "start": "1648440",
    "end": "1655360"
  },
  {
    "text": "want so the way we do that is we look at each program statement and note that",
    "start": "1655360",
    "end": "1660440"
  },
  {
    "text": "there's any number of ways that we could potentially combine all the gadgets that we've actually found to perform the",
    "start": "1660440",
    "end": "1666519"
  },
  {
    "text": "actions in each of these lines so what we do is generate all the possible Gadget Arrangements that could fulfill",
    "start": "1666519",
    "end": "1673039"
  },
  {
    "text": "uh what's needed and then we look at the gadgets that we have available and we use uh algorithms",
    "start": "1673039",
    "end": "1679240"
  },
  {
    "text": "similar to those used in the Q Gadget compiler to do this and this is uh something that was proposed by short Z",
    "start": "1679240",
    "end": "1685320"
  },
  {
    "text": "all in 2011 basically we just at this point we have all the potential ways to create",
    "start": "1685320",
    "end": "1692120"
  },
  {
    "text": "our rot payload and we look at what we have available and then we try to fulfill at least one arrangement of",
    "start": "1692120",
    "end": "1699440"
  },
  {
    "text": "gadgets for each program statement and when we're able to do that we have a full R payload available now and we can",
    "start": "1699440",
    "end": "1706320"
  },
  {
    "text": "then serialize that into into a form that the adversary can use for example if this is all running in a web browser",
    "start": "1706320",
    "end": "1712600"
  },
  {
    "text": "as JavaScript this would be serialized just down to a JavaScript",
    "start": "1712600",
    "end": "1718278"
  },
  {
    "start": "1719000",
    "end": "1821000"
  },
  {
    "text": "string now keep in mind that everything I've presented so far is our initial implementation of jitop and so there's a",
    "start": "1719000",
    "end": "1726120"
  },
  {
    "text": "lot of room for improvement in this uh for example in our memory mapping phase a lot of times when you're disassembling",
    "start": "1726120",
    "end": "1732080"
  },
  {
    "text": "code there's also a lot of data intermixed within that code so we have the potential there's the potential to",
    "start": "1732080",
    "end": "1739039"
  },
  {
    "text": "misread data as code and accidentally point to uh to a page that's not actually code and crash the program",
    "start": "1739039",
    "end": "1745440"
  },
  {
    "text": "while we are mapping memory so one thing we could do to improve this is uh have some better algorithms for Discerning",
    "start": "1745440",
    "end": "1751840"
  },
  {
    "text": "actual code from what's just data but it's embedded in the code section another thing we could do is right now",
    "start": "1751840",
    "end": "1758240"
  },
  {
    "text": "we just look at finding API calls we haven't explored at all the direct use of system calls so that's something that",
    "start": "1758240",
    "end": "1764720"
  },
  {
    "text": "could potentially improve things as well in the gadget finding phase you notice probably that we're very very",
    "start": "1764720",
    "end": "1770320"
  },
  {
    "text": "conservative in the gadgets that we find we throw out anything that could potentially have any adverse effects so",
    "start": "1770320",
    "end": "1776080"
  },
  {
    "text": "something we could do is lower that conservativeness but that's going to be at the expense of complexity uh and",
    "start": "1776080",
    "end": "1781159"
  },
  {
    "text": "adding a lot code to ensure that uh nothing bad is going to happen in the",
    "start": "1781159",
    "end": "1786440"
  },
  {
    "text": "compilation phase we've basically just defined a very small subset of all the ways that you can combine gadgets to",
    "start": "1786440",
    "end": "1792919"
  },
  {
    "text": "achieve whatever actions the the adversary wants to wants to have um uh",
    "start": "1792919",
    "end": "1798440"
  },
  {
    "text": "so one thing another thing we could do to potentially reduce the total number of gadgets that we actually need to find",
    "start": "1798440",
    "end": "1803919"
  },
  {
    "text": "is by defining just more composite gadgets that Implement each operation finally we could optimize this",
    "start": "1803919",
    "end": "1809919"
  },
  {
    "text": "entire thing by uh improving the code throughout the entire framework but even",
    "start": "1809919",
    "end": "1815080"
  },
  {
    "text": "with all these things that we you know may do in the future we we can still show that our framework does pretty",
    "start": "1815080",
    "end": "1822279"
  },
  {
    "start": "1821000",
    "end": "1885000"
  },
  {
    "text": "well now one of the big questions is regarding page mapping and since all of",
    "start": "1822279",
    "end": "1827600"
  },
  {
    "text": "their step in our framework rely on our ability to map out a large number of code pages to find gadgets within them",
    "start": "1827600",
    "end": "1834120"
  },
  {
    "text": "to find API calls within them it's worth it's worth looking at how well we're able to do that page mapping in detail",
    "start": "1834120",
    "end": "1840679"
  },
  {
    "text": "so one of the questions that comes up is are there actually enough function pointers on the Heap or the stack that",
    "start": "1840679",
    "end": "1846840"
  },
  {
    "text": "we can leak in order to map out a significant chunk of the application's memory so we sort of took the easy way",
    "start": "1846840",
    "end": "1854120"
  },
  {
    "text": "out of this question and we just assume for all of our experiments that you only need to leak a single function pointer",
    "start": "1854120",
    "end": "1861279"
  },
  {
    "text": "and you'll see what we did in our our experiments in a second second once we have an an initial",
    "start": "1861279",
    "end": "1868039"
  },
  {
    "text": "page uh we need to check if those code pages are actually interconnected enough again to see if we're able to map enough",
    "start": "1868039",
    "end": "1875200"
  },
  {
    "text": "of the memory and so the way we looked at this was we just tested this on a bunch of different applications uh that",
    "start": "1875200",
    "end": "1881679"
  },
  {
    "text": "are popular and fun to exploit represented by their icons there",
    "start": "1881679",
    "end": "1887240"
  },
  {
    "start": "1885000",
    "end": "1934000"
  },
  {
    "text": "so here's how we did did our experiments for each application we open that application just with a blink document",
    "start": "1887240",
    "end": "1894000"
  },
  {
    "text": "used standard Windows facilities to generate a memory snapshot of each of these applications that includes all the",
    "start": "1894000",
    "end": "1900600"
  },
  {
    "text": "program code and data and where it's located at in memory then we built instead of a JavaScript version of jitr",
    "start": "1900600",
    "end": "1907399"
  },
  {
    "text": "we built it into a x86 a native x86 version and then we took as input to",
    "start": "1907399",
    "end": "1914919"
  },
  {
    "text": "that program each of the memory snapshots and Ked off our entire process using a single code pointer and then we",
    "start": "1914919",
    "end": "1922760"
  },
  {
    "text": "repeated that for each application for every single code page there was so we ran each one of these applications",
    "start": "1922760",
    "end": "1929120"
  },
  {
    "text": "thousands of times that's why we had to do it with a native x86 version so here's some of the results of",
    "start": "1929120",
    "end": "1936200"
  },
  {
    "start": "1934000",
    "end": "2330000"
  },
  {
    "text": "that experiment what you're seeing here is a box plot for each application the",
    "start": "1936200",
    "end": "1942360"
  },
  {
    "text": "light blue color represents the upper quartile of the number of pages we're able to map out the the darker blue uh",
    "start": "1942360",
    "end": "1950000"
  },
  {
    "text": "box represents the lower quartile of the number of pages and the line in the middle is just the median and keep in",
    "start": "1950000",
    "end": "1956399"
  },
  {
    "text": "mind that for each one of these bars here that represents thousands of runs where we kicked off the entire process",
    "start": "1956399",
    "end": "1961720"
  },
  {
    "text": "from a different initial code pointer so the way you can read this chart is that on average over over 50%",
    "start": "1961720",
    "end": "1969600"
  },
  {
    "text": "of the time regardless of where we started we're actually able to map out about 300 Pages or more of code memory",
    "start": "1969600",
    "end": "1979120"
  },
  {
    "text": "and it turns out PRI work has shown that you really only need 10 to 20 pages of memory to build a payload so this is",
    "start": "1979120",
    "end": "1987720"
  },
  {
    "text": "good so we continued on this experiment and now we're looking at just one of the",
    "start": "1987720",
    "end": "1992799"
  },
  {
    "text": "the results for just one of the applications regarding API calls and this is with aret explor",
    "start": "1992799",
    "end": "1998919"
  },
  {
    "text": "10 and again we have these box plots and what we're showing here is how often we're able to find the load library and",
    "start": "1998919",
    "end": "2006120"
  },
  {
    "text": "get proc address API calls these are the only API calls that we need then we can actually just build a rck payload that's",
    "start": "2006120",
    "end": "2012720"
  },
  {
    "text": "going to use these API calls to look up all the other functions that will be needed in the payload so again now we",
    "start": "2012720",
    "end": "2019200"
  },
  {
    "text": "find that on average we're able to find between 9 to 12 of these API calls",
    "start": "2019200",
    "end": "2024320"
  },
  {
    "text": "regardless of where we start our initial mapping from and we only need one of these in",
    "start": "2024320",
    "end": "2029720"
  },
  {
    "text": "each category and for load Library we either need the asky version of that or the Unicode",
    "start": "2029720",
    "end": "2036120"
  },
  {
    "text": "version and again the result here were similar for every application that we looked",
    "start": "2036120",
    "end": "2041480"
  },
  {
    "text": "at now the next step of our framework was to identify all the different Gadget",
    "start": "2041480",
    "end": "2046559"
  },
  {
    "text": "types and get as many of those as we could so what you're seeing here in this box plot is a bar for each type of",
    "start": "2046559",
    "end": "2052638"
  },
  {
    "text": "Gadget that we defined and it's showing the number of unique gadgets that we're able to find uh within that category so",
    "start": "2052639",
    "end": "2060599"
  },
  {
    "text": "you can see here that we find a good number of gadgets for every category except the stack pivot it's kind of an important Gadget uh we we only find just",
    "start": "2060599",
    "end": "2068679"
  },
  {
    "text": "a very few of those on average but right now the way we Define that is just simply as this one instruction exchange",
    "start": "2068679",
    "end": "2075480"
  },
  {
    "text": "eax ESP so it just swaps out the value of eax for the value of the stack uh and",
    "start": "2075480",
    "end": "2080638"
  },
  {
    "text": "that that could certainly be improved upon but so far we haven't found really a need to do anything else with that as",
    "start": "2080639",
    "end": "2086240"
  },
  {
    "text": "you'll see later on in our demo uh but the important thing here here is that we usually find one or more of each type of",
    "start": "2086240",
    "end": "2092000"
  },
  {
    "text": "Gadget regardless of uh the initial code pointer we use I think it's also important to note",
    "start": "2092000",
    "end": "2097480"
  },
  {
    "text": "here that we ran all of these experiments both with fine grain aslr enabled and without fine grain aslr",
    "start": "2097480",
    "end": "2104280"
  },
  {
    "text": "enabled the aslr implementation we looked at uh was the most cutting gauge",
    "start": "2104280",
    "end": "2109880"
  },
  {
    "text": "one we could find where the source code was available and that's uh or by Papas at all from",
    "start": "2109880",
    "end": "2115640"
  },
  {
    "text": "2012 and the results are similar because we do the same thing whether there F grain aslr enabl it or not our code PID",
    "start": "2115640",
    "end": "2121680"
  },
  {
    "text": "page mapping works the exact same way uh one interesting thing about this or implementation of fine Grand aslr",
    "start": "2121680",
    "end": "2128359"
  },
  {
    "text": "is that they actually include an extra step they also do Gadget elimination so each time the application is run or",
    "start": "2128359",
    "end": "2135119"
  },
  {
    "text": "actually searches through the code and tries to identify gadgets that might be useful to an adversary and tweaks the",
    "start": "2135119",
    "end": "2142680"
  },
  {
    "text": "code and changes it so that Gadget no longer does what it was originally intended to",
    "start": "2142680",
    "end": "2148400"
  },
  {
    "text": "do and so one of the interesting things here is that that had no effect on the jit rot framework at all because we're",
    "start": "2148400",
    "end": "2154400"
  },
  {
    "text": "finding all of these gadgets dynamically each time the exploit is running uh and",
    "start": "2154400",
    "end": "2160640"
  },
  {
    "text": "what's kind of funny actually is after this gadget elimination sometimes we actually found more gadgets then without",
    "start": "2160640",
    "end": "2167079"
  },
  {
    "text": "Gadget elimination so next we ran we ran into",
    "start": "2167079",
    "end": "2174400"
  },
  {
    "text": "in tests uh over a number of different exploit scenarios so what you're seeing here in these bar graphs is just four",
    "start": "2174400",
    "end": "2181359"
  },
  {
    "text": "different exploits and the number of seconds it took from the user browsing to the web",
    "start": "2181359",
    "end": "2187319"
  },
  {
    "text": "page to the payload being generated and executed on their machine so the first",
    "start": "2187319",
    "end": "2192440"
  },
  {
    "text": "box here is actually a real exploit cve 2012 1876 and the target is against Windows 7",
    "start": "2192440",
    "end": "2200280"
  },
  {
    "text": "on Internet Explorer 8 and this vulnerability we set up a memory disclosure similar to the one that Luca",
    "start": "2200280",
    "end": "2207040"
  },
  {
    "text": "talked about earlier where we overwrite the string size and then we're able to read from arbitrary addresses in",
    "start": "2207040",
    "end": "2212680"
  },
  {
    "text": "memory uh and we see that took about 22 seconds so not so great but not so bad",
    "start": "2212680",
    "end": "2218319"
  },
  {
    "text": "either uh then the next three bars are showing different exploit scenarios",
    "start": "2218319",
    "end": "2223480"
  },
  {
    "text": "where we uh have different types of memory disclosure vulnerabilities run running under different environments and",
    "start": "2223480",
    "end": "2229560"
  },
  {
    "text": "all of these are artificial they're just ones that we created to check the performance differences so the second bar here is",
    "start": "2229560",
    "end": "2236880"
  },
  {
    "text": "running the same type of exploit as the one that Luca described for the memory disclosure but instead of running on I8",
    "start": "2236880",
    "end": "2243520"
  },
  {
    "text": "we're now running in the Chrome V8 JavaScript engine and so just by switching the JavaScript engine it",
    "start": "2243520",
    "end": "2250000"
  },
  {
    "text": "actually improved our our performance uh double or half the",
    "start": "2250000",
    "end": "2255119"
  },
  {
    "text": "time next we do the same exploit but instead of uh Windows 7 and ie we do",
    "start": "2255119",
    "end": "2261160"
  },
  {
    "text": "Windows 8 and ie 10 again this is an artificial exploit that we injected uh that is basically that same string",
    "start": "2261160",
    "end": "2267800"
  },
  {
    "text": "overright vulnerability and so we found just running an I10 with its improved uh JavaScript engine uh one of the one of",
    "start": "2267800",
    "end": "2274960"
  },
  {
    "text": "the biggest things that improved the performance here in terms of the differences in the JavaScript engine is",
    "start": "2274960",
    "end": "2280440"
  },
  {
    "text": "the use of typed arrays in JavaScript so with this explo we're able to run the entire process in just a few seconds",
    "start": "2280440",
    "end": "2286280"
  },
  {
    "text": "which is great uh but then on the other hand again running an i an i1 on Windows",
    "start": "2286280",
    "end": "2291920"
  },
  {
    "text": "8 we did another type of memory disclosure exploit based on format strings and you can see that's a lot",
    "start": "2291920",
    "end": "2297960"
  },
  {
    "text": "slower at around 15 seconds and the reason for that is because it takes a lot more to disclose a single bite of",
    "start": "2297960",
    "end": "2303599"
  },
  {
    "text": "memory using a format string disclosure basically every bite of memory to read we have to allocate a number of strings",
    "start": "2303599",
    "end": "2309520"
  },
  {
    "text": "in memory and go through all these format string functions as well so so you can see that you know running under",
    "start": "2309520",
    "end": "2316000"
  },
  {
    "text": "different environments different JavaScript engines and depending on the actual exploit that's used the runtime",
    "start": "2316000",
    "end": "2323319"
  },
  {
    "text": "really varies pretty significantly but we feel this is pretty viable actually for real world",
    "start": "2323319",
    "end": "2329560"
  },
  {
    "text": "exploitation So speaking of real world exploitation uh want to get to probably the most enjoyable part of this talk",
    "start": "2329560",
    "end": "2335720"
  },
  {
    "start": "2330000",
    "end": "2494000"
  },
  {
    "text": "which is the live demo and as luuka mentioned earlier we are using uh cve",
    "start": "2335720",
    "end": "2341920"
  },
  {
    "text": "2013 2551 and this is the same exploit that was used to win the pond to own",
    "start": "2341920",
    "end": "2348760"
  },
  {
    "text": "competition a month or two ago uh and we're running this exploit on Windows 8",
    "start": "2348760",
    "end": "2354319"
  },
  {
    "text": "IE 10 and so IE 10 and windows8 is using basically the latest and greatest set of",
    "start": "2354319",
    "end": "2361000"
  },
  {
    "text": "deployed defenses that are available right now but at the same time jitr is targeted to work against fin grain aslr",
    "start": "2361000",
    "end": "2368200"
  },
  {
    "text": "which is actually not implemented at all on uh IE 10 Windows 8 uh so in this",
    "start": "2368200",
    "end": "2373680"
  },
  {
    "text": "scenario we're just generating a payload against standard aslr but the entire",
    "start": "2373680",
    "end": "2378960"
  },
  {
    "text": "process should work exactly the same if fine grain aslr were employed and so just to give credit where it's due here",
    "start": "2378960",
    "end": "2385119"
  },
  {
    "text": "I just want to make it clear that we did not discover this vulnerability it's discovered by Nicholas Jolie and there",
    "start": "2385119",
    "end": "2390720"
  },
  {
    "text": "was actually a metas module written I think a few weeks ago by Juan Vasquez",
    "start": "2390720",
    "end": "2396200"
  },
  {
    "text": "and that metas module Works only in Windows 7 and IE8 it doesn't work in uh",
    "start": "2396200",
    "end": "2402560"
  },
  {
    "text": "Windows 8 because aslr is enforced throughout all uh libraries in Windows 8",
    "start": "2402560",
    "end": "2408720"
  },
  {
    "text": "uh so there is no way to have a payload pre-written there so let me just go",
    "start": "2408720",
    "end": "2413960"
  },
  {
    "text": "straight over to the demo and this is a live demo and I'm hopeful that it will",
    "start": "2413960",
    "end": "2419560"
  },
  {
    "text": "work uh so first I'm just going to uh let's see open up this web page and the",
    "start": "2419560",
    "end": "2425480"
  },
  {
    "text": "web page contains a little HTML plus some JavaScript it also includes a library",
    "start": "2425480",
    "end": "2431319"
  },
  {
    "text": "which is the jitr library in its JavaScript form so let's open that",
    "start": "2431319",
    "end": "2438400"
  },
  {
    "text": "up and what you're seeing here is just a web page it just has a single button I'm going to press that button and you're",
    "start": "2440319",
    "end": "2446000"
  },
  {
    "text": "going to see some output in the debug console down here and hopefully this will work sometimes it takes a few tries",
    "start": "2446000",
    "end": "2453720"
  },
  {
    "text": "here to get the Heap funing working correctly",
    "start": "2453720",
    "end": "2458520"
  },
  {
    "text": "okay so there we go so what's happening right now is uh the memory disclosure",
    "start": "2460720",
    "end": "2466240"
  },
  {
    "text": "vulnerability was used it found a initial code pointer and provided that",
    "start": "2466240",
    "end": "2471800"
  },
  {
    "text": "initial code pointer to the jitr framework so that's it from there the jitr framework takes over and uses that",
    "start": "2471800",
    "end": "2478119"
  },
  {
    "text": "initial pointer to try and map out as much memory as possible to try and find all the gadgets that are going to be",
    "start": "2478119",
    "end": "2484160"
  },
  {
    "text": "needed to build a payload find all the API calls that are needed by the exploit description and then it'll compile that",
    "start": "2484160",
    "end": "2491359"
  },
  {
    "text": "payload and return it just as a JavaScript string and this particular exploit takes about 20 seconds to run as",
    "start": "2491359",
    "end": "2497880"
  },
  {
    "start": "2494000",
    "end": "2597000"
  },
  {
    "text": "you saw so let me just show you real quick before I trigger the exploit what",
    "start": "2497880",
    "end": "2503319"
  },
  {
    "text": "kind of debug output we get here so again keep in mind this is all running just as a JavaScript",
    "start": "2503319",
    "end": "2509880"
  },
  {
    "text": "library uh so what we get here is first an output of all the gadgets we found organized by category so we have no op",
    "start": "2509880",
    "end": "2516720"
  },
  {
    "text": "gadgets jump gadgets we have stack pivots now you saw earlier that one of",
    "start": "2516720",
    "end": "2522720"
  },
  {
    "text": "the ones that we have the most trouble finding is this exchange instruction but in this case we found 19 instances of it",
    "start": "2522720",
    "end": "2528240"
  },
  {
    "text": "so there's no problem here uh we have pets we have things for moving uh values between registers",
    "start": "2528240",
    "end": "2535760"
  },
  {
    "text": "loading values into registers some arithmetic gadgets uh things for loading and storing into memory arithmetic",
    "start": "2535760",
    "end": "2542960"
  },
  {
    "text": "versions of those and after all Gadget output we're",
    "start": "2542960",
    "end": "2550319"
  },
  {
    "text": "showing the API calls and how many of those we're able to find and remember we're just looking for get proc address",
    "start": "2550319",
    "end": "2555760"
  },
  {
    "text": "and load library in this case we found 22 instances of get proc address on the pages that that we iterated over and we",
    "start": "2555760",
    "end": "2562800"
  },
  {
    "text": "found only one instance of load library and it's the Unicode version of that even though we found only one that's all",
    "start": "2562800",
    "end": "2569200"
  },
  {
    "text": "we need to build the payload so after that the payload has already been built and this is just a",
    "start": "2569200",
    "end": "2575599"
  },
  {
    "text": "textual rep representation of what that payload looks like it's just listing all the gadgets out and the",
    "start": "2575599",
    "end": "2581920"
  },
  {
    "text": "values areed into various registers etc etc so this particular payload let me",
    "start": "2581920",
    "end": "2589839"
  },
  {
    "text": "show you what we are actually trying to",
    "start": "2589839",
    "end": "2593400"
  },
  {
    "text": "compile okay so this is the actual exploit here and this is what you as the adversary would need to provide for the",
    "start": "2596559",
    "end": "2603079"
  },
  {
    "start": "2597000",
    "end": "2676000"
  },
  {
    "text": "jit rot framework and it's just this highle language very simple highle language us basically a sequence of API",
    "start": "2603079",
    "end": "2609040"
  },
  {
    "text": "calls in this case we use load library to grab the address of colel 32 then we use git proc address with the result of",
    "start": "2609040",
    "end": "2616240"
  },
  {
    "text": "that kernel 32 Library location to grab the address of the wind exec API",
    "start": "2616240",
    "end": "2621680"
  },
  {
    "text": "call and just call wixc remember the at symbol here is just the result of the",
    "start": "2621680",
    "end": "2627680"
  },
  {
    "text": "last function so in this case the address of wixc and we call it and give it a parameter to execute the windows",
    "start": "2627680",
    "end": "2635119"
  },
  {
    "text": "calculator then we want to keep things nice and tidy so we look up the exit process call call exit and hopefully",
    "start": "2635119",
    "end": "2642599"
  },
  {
    "text": "this will all run and execute calculator and cleanly exit I can't guarantee it but let's",
    "start": "2642599",
    "end": "2649319"
  },
  {
    "text": "see and there we",
    "start": "2649319",
    "end": "2652839"
  },
  {
    "text": "go and I have a few more payloads that I want to show you let me check how I'm doing on",
    "start": "2655640",
    "end": "2661839"
  },
  {
    "text": "time okay great so I think I have time to do this uh the other thing I want to show you is just running that same",
    "start": "2661839",
    "end": "2670119"
  },
  {
    "text": "payload but instead of redirecting execution to the",
    "start": "2670119",
    "end": "2675119"
  },
  {
    "text": "payload let's redirect execution to an address in memory that I know is going to be invalid ahead of time so so we're",
    "start": "2675520",
    "end": "2682359"
  },
  {
    "start": "2676000",
    "end": "2739000"
  },
  {
    "text": "just going to redirect execution to the address of one which should be",
    "start": "2682359",
    "end": "2688520"
  },
  {
    "text": "unmapped okay let's go",
    "start": "2691200",
    "end": "2696240"
  },
  {
    "text": "takes a couple tries here for the Heap from Chang okay got it on the second try so now again we're just mapping out all",
    "start": "2700240",
    "end": "2706880"
  },
  {
    "text": "the code pages that are available finding all the gadgets finding all the API calls that we need and the reason I",
    "start": "2706880",
    "end": "2712480"
  },
  {
    "text": "changed the address to one is in order to crash the program and I want to crash the program because after that happens",
    "start": "2712480",
    "end": "2718839"
  },
  {
    "text": "I'm going to open it up in a debugger so you can actually see the rck gadgets as they",
    "start": "2718839",
    "end": "2724000"
  },
  {
    "text": "execute so while this is running takes about 20 seconds or so uh I can give you",
    "start": "2724000",
    "end": "2729359"
  },
  {
    "text": "a little preview of some other payloads I'm going to show you so this is just your your",
    "start": "2729359",
    "end": "2736040"
  },
  {
    "text": "standard does it work payload a Windows calculator the next one I want to show you after I go through this debugger is",
    "start": "2736040",
    "end": "2743040"
  },
  {
    "start": "2739000",
    "end": "2801000"
  },
  {
    "text": "just to show you that we can do a lot more complex things with this very simple high level language and here I'm",
    "start": "2743040",
    "end": "2748440"
  },
  {
    "text": "just Ching chaining together a whole bunch of calls I'm going to open a whole bunch of calculators uh I'm also going",
    "start": "2748440",
    "end": "2753839"
  },
  {
    "text": "to write some data to a file then I'm going to open up that data in notepad so",
    "start": "2753839",
    "end": "2759480"
  },
  {
    "text": "you can see that it was written and then again cleanly exit let's check on this here okay so we're all done again uh",
    "start": "2759480",
    "end": "2768200"
  },
  {
    "text": "what I need to do is in the debug output I'm outputting the address of our",
    "start": "2768200",
    "end": "2773359"
  },
  {
    "text": "payload but remember we're going to redirect to an invalid address so it should crash When I close",
    "start": "2773359",
    "end": "2778839"
  },
  {
    "text": "this okay it crashed so let's open it up in the",
    "start": "2778839",
    "end": "2783359"
  },
  {
    "text": "debugger this is just a Unity debugger and I hope you guys can read this when it comes",
    "start": "2785200",
    "end": "2792559"
  },
  {
    "text": "up does take a second okay all right so let me just move this around a little",
    "start": "2792559",
    "end": "2798520"
  },
  {
    "text": "bit so you can see it okay so what you're seeing here is in",
    "start": "2798520",
    "end": "2804119"
  },
  {
    "start": "2801000",
    "end": "2847000"
  },
  {
    "text": "this top left window is the current code that's being executed in the right hand window is the current value of some of",
    "start": "2804119",
    "end": "2811240"
  },
  {
    "text": "the registers and you can see in eax is one which is what we put there and on",
    "start": "2811240",
    "end": "2817040"
  },
  {
    "text": "the bottom is the current values of what you see on the program stack so what we're going to do is",
    "start": "2817040",
    "end": "2823640"
  },
  {
    "text": "instead of redirecting execution to o1 I'm going to paste in here the",
    "start": "2823640",
    "end": "2828800"
  },
  {
    "text": "address that I copied out of the debug output say okay and restart execution but I'm going to single step into this",
    "start": "2828800",
    "end": "2836000"
  },
  {
    "text": "so you can see the actual rap Gadgets in action so I'm going to step into this",
    "start": "2836000",
    "end": "2841119"
  },
  {
    "text": "call and this call here is just a call into a virtual table function that we've replaced",
    "start": "2841119",
    "end": "2847400"
  },
  {
    "start": "2847000",
    "end": "2873000"
  },
  {
    "text": "Okay so we've called into the very first address of our payload and we can see that the code that it pointed to which",
    "start": "2847400",
    "end": "2853599"
  },
  {
    "text": "is a gadget is that exchange eax ESP so this is your classic stack pivot to",
    "start": "2853599",
    "end": "2859880"
  },
  {
    "text": "change the stack over to point to our entire rot payload so after this instruction executes what you should see",
    "start": "2859880",
    "end": "2866680"
  },
  {
    "text": "on the stackup output down here is our entire",
    "start": "2866680",
    "end": "2871440"
  },
  {
    "text": "rchain okay so what you're seeing down here is just each address in our R chain and the debugger is kind enough to point",
    "start": "2873119",
    "end": "2879520"
  },
  {
    "text": "out where we're actually getting that Gadget from so you can see our code using our code page traversal we're",
    "start": "2879520",
    "end": "2885520"
  },
  {
    "text": "actually getting gadgets from a pretty wide variety of different modules that are loaded into memory and that's just",
    "start": "2885520",
    "end": "2891319"
  },
  {
    "text": "because all these modules are interconnected in some way so we get uh we get a gadget from the vgx dll gdi32",
    "start": "2891319",
    "end": "2899440"
  },
  {
    "text": "ntdll we get some from I shims and I could continue and go down this but I won't um instead when I want I'll show",
    "start": "2899440",
    "end": "2907079"
  },
  {
    "text": "you is just stepping through some of these gadgets so you can get an idea of what a rot payload looks like as it's",
    "start": "2907079",
    "end": "2912880"
  },
  {
    "text": "executing and you can see how we constructed our rot payload so we just step through each of these and all",
    "start": "2912880",
    "end": "2919720"
  },
  {
    "text": "that's happening is each address one by one is popped off the stack and each of",
    "start": "2919720",
    "end": "2925839"
  },
  {
    "text": "the addresses points to some code sequence that's our rck Gadget and we continue on and you can see values are",
    "start": "2925839",
    "end": "2932599"
  },
  {
    "text": "being popped from the stack and our rot payload is being consumed what's happening right now in the payload",
    "start": "2932599",
    "end": "2938599"
  },
  {
    "text": "actually is uh a small preface to the actual payload that goes in and patches",
    "start": "2938599",
    "end": "2944839"
  },
  {
    "text": "all the null bites into the payload itself uh null bites are something we had to get rid of for this particular",
    "start": "2944839",
    "end": "2951200"
  },
  {
    "text": "exploit so if I contined to step through this you'd see the entire uh payload be consumed and eventually Windows",
    "start": "2951200",
    "end": "2957520"
  },
  {
    "text": "calculator would pop up but I'm not going to go all the way through that it would take too long so I'm going to close",
    "start": "2957520",
    "end": "2963520"
  },
  {
    "text": "this and I think I should probably wrap up soon uh so maybe I'll skip the this",
    "start": "2963520",
    "end": "2969920"
  },
  {
    "start": "2964000",
    "end": "3023000"
  },
  {
    "text": "very large payload and instead I want to jump to what would be what most real",
    "start": "2969920",
    "end": "2976359"
  },
  {
    "text": "world adversaries will be interested in doing which is downloading a file from the internet and then executing it as a",
    "start": "2976359",
    "end": "2983960"
  },
  {
    "text": "payload so let me just change the payload that's going to be built and executed here to this download exec",
    "start": "2983960",
    "end": "2991079"
  },
  {
    "text": "payload and I got to remember to redirect execution to the correct place",
    "start": "2991079",
    "end": "2998480"
  },
  {
    "text": "okay that's that and we can now run",
    "start": "2999799",
    "end": "3004599"
  },
  {
    "text": "this okay we got it on the first try here and again this is going to take about 20 seconds jetra framework",
    "start": "3008839",
    "end": "3014520"
  },
  {
    "text": "automatically mapping all the pages gadgets and apis so let me show you real quick what this payload actually is",
    "start": "3014520",
    "end": "3021240"
  },
  {
    "text": "while it's mapping everything out so again we're just using load library and get proc address to dynamically find the",
    "start": "3021240",
    "end": "3028680"
  },
  {
    "start": "3023000",
    "end": "3055000"
  },
  {
    "text": "address of the wi exec call and for wi exec we're just giving it the command to execute the command",
    "start": "3028680",
    "end": "3034880"
  },
  {
    "text": "shell and telling the command shell to execute Powershell which in turn executes a small Powershell program that",
    "start": "3034880",
    "end": "3042760"
  },
  {
    "text": "downloads a file that I'm hosting right now on my own Local Host because I don't trust you guys to actually connect to",
    "start": "3042760",
    "end": "3048119"
  },
  {
    "text": "the internet uh and then execute that file after we've downloaded it so the goal is to download decaf bad.",
    "start": "3048119",
    "end": "3055000"
  },
  {
    "start": "3055000",
    "end": "3067000"
  },
  {
    "text": "exe okay and we can see see we've built the payload we've returned it as this JavaScript string and all that needs to",
    "start": "3055000",
    "end": "3061119"
  },
  {
    "text": "happen now is we close the browser to trigger the actual redirection of execution with any luck okay we see",
    "start": "3061119",
    "end": "3068280"
  },
  {
    "start": "3067000",
    "end": "3074000"
  },
  {
    "text": "Powershell popped up we didn't cleanly exit this particular example uh so we got the crash message but what happened",
    "start": "3068280",
    "end": "3075680"
  },
  {
    "start": "3074000",
    "end": "3103000"
  },
  {
    "text": "is the file was downloaded from the internet you can see it on the desktop down here decaf bad. exe and it opened",
    "start": "3075680",
    "end": "3081960"
  },
  {
    "text": "it up and it looks like Microsoft Paint but it's not Microsoft Paint actually this is a program this is a modified",
    "start": "3081960",
    "end": "3087559"
  },
  {
    "text": "version of Microsoft Paint written by a colleague of mine Nathan ESS at UNC called caffeine bad and it just shows",
    "start": "3087559",
    "end": "3094319"
  },
  {
    "text": "what happens when you have too much caffeine your drawing looks like",
    "start": "3094319",
    "end": "3099799"
  },
  {
    "text": "this so that's it for the demo I'm just going to quickly conclude",
    "start": "3099799",
    "end": "3105400"
  },
  {
    "start": "3103000",
    "end": "3120000"
  },
  {
    "text": "here uh basically our goal was to to try and see if fine grain aslr is actually",
    "start": "3105400",
    "end": "3110760"
  },
  {
    "text": "providing anything uh that's beneficial above standard aslr and I think we've",
    "start": "3110760",
    "end": "3115799"
  },
  {
    "text": "pretty clearly shown here that there is real no advantage to find gra aslr and a lot of people suggest these",
    "start": "3115799",
    "end": "3122880"
  },
  {
    "start": "3120000",
    "end": "3139000"
  },
  {
    "text": "quick fixes like okay it takes 20 seconds or so sometimes to generate a payload why not just randomize",
    "start": "3122880",
    "end": "3128760"
  },
  {
    "text": "periodically well we could do that but to do it fast enough to where it's actually going to prevent this sort of",
    "start": "3128760",
    "end": "3134200"
  },
  {
    "text": "attack it turns out that the performance trade-off in doing that is just way too impractical so what I think uh is that",
    "start": "3134200",
    "end": "3141520"
  },
  {
    "start": "3139000",
    "end": "3398000"
  },
  {
    "text": "we need to move towards more comprehensive mitigations like uh for example control flow integrity and we",
    "start": "3141520",
    "end": "3147839"
  },
  {
    "text": "don't need and we need to not just look at these comprehensive mechanisms but we also need to find practical Solutions so",
    "start": "3147839",
    "end": "3154000"
  },
  {
    "text": "efficient Solutions uh that don't take much runtime overhead to do so personally what I'm working towards and",
    "start": "3154000",
    "end": "3159920"
  },
  {
    "text": "what Luca is working towards is more efficient fine grained control flow integrity and data flow Integrity me",
    "start": "3159920",
    "end": "3166640"
  },
  {
    "text": "mechanisms and so that's it I think we'll take some questions now if we have time",
    "start": "3166640",
    "end": "3174480"
  },
  {
    "text": "[Applause] we have five minutes questions",
    "start": "3177860",
    "end": "3185400"
  },
  {
    "text": "[Music]",
    "start": "3198790",
    "end": "3201920"
  },
  {
    "text": "do you want to speak to Il um so it depends of course how which kind of randomization you enforce so the",
    "start": "3232520",
    "end": "3239960"
  },
  {
    "text": "paper that we have read about randomizing periodically was also reshuffling and enforcing fine R",
    "start": "3239960",
    "end": "3246480"
  },
  {
    "text": "randomization and there the overhead was quite big and they could only do it for a specific kernel so I'm not aware of",
    "start": "3246480",
    "end": "3254280"
  },
  {
    "text": "the work you are referring to but the overhead should be quite high if you uh in particular if you want to randomize",
    "start": "3254280",
    "end": "3260440"
  },
  {
    "text": "all the libraries that are included into your program",
    "start": "3260440",
    "end": "3266200"
  },
  {
    "text": "B",
    "start": "3269319",
    "end": "3272319"
  },
  {
    "text": "only",
    "start": "3297319",
    "end": "3300319"
  },
  {
    "text": "yeah that's definitely true I mean software Dynamic translation is an option for Rand",
    "start": "3346720",
    "end": "3351839"
  },
  {
    "text": "randomizing but as far as our experience have have shown uh software Dynamic",
    "start": "3351839",
    "end": "3357960"
  },
  {
    "text": "translation um Frameworks already add a lot of overhead to the application so",
    "start": "3357960",
    "end": "3364280"
  },
  {
    "text": "it's definitely a feel that one needs to explore to make these things more efficient I think it's just a trade-off",
    "start": "3364280",
    "end": "3370960"
  },
  {
    "text": "I mean if 10% is something you're willing to sacrifice for your web browsing then maybe that's",
    "start": "3370960",
    "end": "3378119"
  },
  {
    "text": "okay more questions please",
    "start": "3379799",
    "end": "3384640"
  },
  {
    "text": "I think everyone is hungry for",
    "start": "3387720",
    "end": "3391039"
  },
  {
    "text": "lunch okay well thanks everybody",
    "start": "3394319",
    "end": "3398960"
  }
]