[
  {
    "start": "0",
    "end": "44000"
  },
  {
    "text": "[Music]",
    "start": "1180",
    "end": "14730"
  },
  {
    "text": "hi everyone i'm diego again from wahoo's university and i'm here to present leatherlick our latest attack against ecds8",
    "start": "16240",
    "end": "23119"
  },
  {
    "text": "signatures using less than one bit of nose leakage this work has already appeared at the",
    "start": "23119",
    "end": "28160"
  },
  {
    "text": "ccs conference this year and it's available on new print it's a collaboration with a filipino",
    "start": "28160",
    "end": "33280"
  },
  {
    "text": "vice university of components in brazil akiga takahashi from all's university in denmark meditebushi from entity in japan",
    "start": "33280",
    "end": "40320"
  },
  {
    "text": "and yuvo vyagam from university of adelaide in australia in this talk i will describe new attacks",
    "start": "40320",
    "end": "46879"
  },
  {
    "start": "44000",
    "end": "395000"
  },
  {
    "text": "exploiting randomness leakage and bias from ecdsa type signature schemes based on newly",
    "start": "46879",
    "end": "52480"
  },
  {
    "text": "discovered vulnerabilities in ecdsa implementations contained in the openssl and relic cryptographic libraries",
    "start": "52480",
    "end": "59359"
  },
  {
    "text": "these vulnerabilities have led to theoretical improvements to the attack framework based on solving the hidden number problem",
    "start": "59359",
    "end": "65760"
  },
  {
    "text": "in the first part of the attack i will of the talk i will explain how to acquire sidechainer information",
    "start": "65760",
    "end": "71200"
  },
  {
    "text": "in the second part of the talk akiga will explain how to exploit sidechain information to recover the secret key",
    "start": "71200",
    "end": "77520"
  },
  {
    "text": "but let's first start with some background on attacking ecdsa nonces",
    "start": "77520",
    "end": "82720"
  },
  {
    "text": "ecdsa and schnorr signatures are among the most popular signature schemes rely on the hardness of the discrete",
    "start": "82720",
    "end": "88400"
  },
  {
    "text": "logarithmic problem for security modern instantiations of the signature schemes",
    "start": "88400",
    "end": "93600"
  },
  {
    "text": "use elliptic curves for efficiency in both of them the signing operation involves a random value k",
    "start": "93600",
    "end": "100159"
  },
  {
    "text": "sometimes called unknowns to randomize the signatures calling this value announce is a major",
    "start": "100159",
    "end": "105680"
  },
  {
    "text": "understatement because it needs to remain secret or well protected for a long amount of time",
    "start": "105680",
    "end": "110720"
  },
  {
    "text": "otherwise this the security of the signatory scheme is completely undermined",
    "start": "110720",
    "end": "115759"
  },
  {
    "text": "let's assume a scenario where alice and bob want to exchange digital signatures so alice generates a",
    "start": "115759",
    "end": "121439"
  },
  {
    "text": "private key and sends the public her public key to bob for verifying signatures",
    "start": "121439",
    "end": "126719"
  },
  {
    "text": "when alice wants to sign a message she generates unknowns and combines the nodes with the message",
    "start": "126719",
    "end": "132959"
  },
  {
    "text": "and the private key to compute the signature that can be sent by to bob for purification what's interesting",
    "start": "132959",
    "end": "140640"
  },
  {
    "text": "about the signature scheme is that the signing equation relates public values coming from the signatures to the two",
    "start": "140640",
    "end": "146879"
  },
  {
    "text": "unknowns the private key and the nodes this means that if the",
    "start": "146879",
    "end": "151920"
  },
  {
    "text": "nodes leaks or is exposed somehow this gives information to compute the private key directly",
    "start": "151920",
    "end": "157280"
  },
  {
    "text": "in particular if two signatures are computed over different messages and using the same nodes",
    "start": "157280",
    "end": "163519"
  },
  {
    "text": "this can also be used to compute the private key",
    "start": "163519",
    "end": "170080"
  },
  {
    "text": "but these are extreme cases for example we could have the case that due to implementation error or",
    "start": "170080",
    "end": "176080"
  },
  {
    "text": "malfunction in the random number generator some bits of the nodes are fixed or perhaps an",
    "start": "176080",
    "end": "182319"
  },
  {
    "text": "adversary is able to obtain leakage correlated with those bits with high probability in this case the",
    "start": "182319",
    "end": "188239"
  },
  {
    "text": "adversary could collect many signatures computed by alice under her private key and solve the hidden number problem to",
    "start": "188239",
    "end": "194480"
  },
  {
    "text": "compute this private key randomness failure is not only of academic interest and can actually",
    "start": "194480",
    "end": "200480"
  },
  {
    "text": "manifest many different ways in the real world perhaps due to a poorly designed or implemented random number generator",
    "start": "200480",
    "end": "207200"
  },
  {
    "text": "or maybe the initial state of the random number generator was predictable like a timestamp or perhaps a virtual",
    "start": "207200",
    "end": "214000"
  },
  {
    "text": "machine resets to a previous snapshot version and then repeats the internal state of the random number generator producing",
    "start": "214000",
    "end": "220480"
  },
  {
    "text": "the same nodes for two different signatures in the context of this talk i worry",
    "start": "220480",
    "end": "226080"
  },
  {
    "text": "about side channel leakage in which the attacker is able to obtain information correlated with bits of the nodes",
    "start": "226080",
    "end": "232879"
  },
  {
    "text": "one high profile case of randomness failure in practice was the playstation 3 when sony used the same nodes to sign",
    "start": "232879",
    "end": "239439"
  },
  {
    "text": "many games and this allowed the homebrew community to compute the signing key from just two different legit made games",
    "start": "239439",
    "end": "246159"
  },
  {
    "text": "and then be able to authorize software to run on the platform",
    "start": "246159",
    "end": "251280"
  },
  {
    "text": "there are many other cases involving bitcoin wallets and voting machines where randomness failure",
    "start": "251280",
    "end": "257440"
  },
  {
    "text": "completely broken the security properties imposed on those systems",
    "start": "257440",
    "end": "263280"
  },
  {
    "text": "our contributions in this talk are three-fold the first one is a novel class of cache attacks",
    "start": "263759",
    "end": "268960"
  },
  {
    "text": "against ecdsc implemented in openssl versions 102u and 110l",
    "start": "268960",
    "end": "274639"
  },
  {
    "text": "and also the research oriented cryptographic library called relic version 0.4 there are many",
    "start": "274639",
    "end": "282800"
  },
  {
    "text": "sets of parameters affected by this vulnerability essentially any curve in which the group order is",
    "start": "282800",
    "end": "288080"
  },
  {
    "text": "just below a power of 2 could be affected if the implementation is variable as well",
    "start": "288080",
    "end": "293520"
  },
  {
    "text": "this includes many curves standardized by nist and defined it over prime fields and also curves defined over binary",
    "start": "293520",
    "end": "300080"
  },
  {
    "text": "fields also the sum of the curves standardizing in the older seg standard",
    "start": "300080",
    "end": "306080"
  },
  {
    "text": "could be affected in particular the bitcoin curve sec p256 k1",
    "start": "306080",
    "end": "313600"
  },
  {
    "text": "in the initial version of our work we had the impression that curve p256 as implemented in openssl was affected",
    "start": "313600",
    "end": "321039"
  },
  {
    "text": "but later we found out that openssl has custom code to implement arithmetic on that curve",
    "start": "321039",
    "end": "326240"
  },
  {
    "text": "that's not vulnerable it's hard to know exactly what products are affected by leatherlick",
    "start": "326240",
    "end": "331680"
  },
  {
    "text": "but we could search over github and find that several projects bumped the library version of openssl in",
    "start": "331680",
    "end": "338479"
  },
  {
    "text": "their build systems this means that they at least included versions of the library that were",
    "start": "338479",
    "end": "344400"
  },
  {
    "text": "affected but we cannot claim that this could be exploited under some realistic threat model against those products",
    "start": "344400",
    "end": "351759"
  },
  {
    "text": "the second contribution of our work is theoretical improvements to attacks based on fourier analysis to",
    "start": "351759",
    "end": "358160"
  },
  {
    "text": "solve the hidden number problem that significantly reduces the amount of input data or the number of signatures",
    "start": "358160",
    "end": "363440"
  },
  {
    "text": "to be effective this allows the attack to be feasible given less than one bit of non-speed",
    "start": "363440",
    "end": "368960"
  },
  {
    "text": "bias leakage per signature which means that the attacker is able to obtain one bit of the nonce",
    "start": "368960",
    "end": "374080"
  },
  {
    "text": "with less than a hundred percent success probability so then less than one bit of bias in",
    "start": "374080",
    "end": "380400"
  },
  {
    "text": "average we implemented a full secret key recovery attack against openssl",
    "start": "380400",
    "end": "385680"
  },
  {
    "text": "over two sets of parameters a binary curve over a smaller field and a prime curve over",
    "start": "385680",
    "end": "392000"
  },
  {
    "text": "field p192 now let's move to some background on",
    "start": "392000",
    "end": "397120"
  },
  {
    "text": "curve based cryptography elliptic curves are sets of solutions x and y to a curve equation",
    "start": "397120",
    "end": "404400"
  },
  {
    "text": "and they come equipped with a geometric operation that defines a group law called point addition when you want to",
    "start": "404400",
    "end": "411280"
  },
  {
    "text": "add points p and q especially on this curve that's defined on the real numbers so the curve",
    "start": "411280",
    "end": "416479"
  },
  {
    "text": "is is continuous we can trace a line passive through p and q and reflect the interception between the",
    "start": "416479",
    "end": "424319"
  },
  {
    "text": "line and the curve across the x axis to get the result if the point is being doubled",
    "start": "424319",
    "end": "430240"
  },
  {
    "text": "we take the tangent line instead and this allows us to compute r in the same way for cryptographic",
    "start": "430240",
    "end": "438160"
  },
  {
    "text": "interest we take curves defined over finite fields such that the discrete logarithm problem is hard",
    "start": "438160",
    "end": "444800"
  },
  {
    "text": "what's interesting is that the same geometric intuition gives us a group law an",
    "start": "444800",
    "end": "451120"
  },
  {
    "text": "operation that defines a group in practice usually chosen to have prime",
    "start": "451120",
    "end": "456240"
  },
  {
    "text": "order with the point at infinity serving as the identity element efficient implementations will not",
    "start": "456240",
    "end": "462720"
  },
  {
    "text": "represent the points in a fine coordinates x and y because computing the slope of this line",
    "start": "462720",
    "end": "468639"
  },
  {
    "text": "requires to compute a field diversion or division that's computationally expensive so actual efficient implementations we",
    "start": "468639",
    "end": "475680"
  },
  {
    "text": "use a projective coordinate system instead in which the slope of the line is accumulated across multiple operations",
    "start": "475680",
    "end": "482479"
  },
  {
    "text": "and resolve it only at the end in this representation a point is",
    "start": "482479",
    "end": "487840"
  },
  {
    "text": "represented using coordinates x y and z such that the x and y coordinates are weighted by some power",
    "start": "487840",
    "end": "493840"
  },
  {
    "text": "of z when elliptic curves are used to",
    "start": "493840",
    "end": "500240"
  },
  {
    "text": "instantiate cryptographic protocols one operation becomes critical the so-called scalar multiplication",
    "start": "500240",
    "end": "507599"
  },
  {
    "text": "scale of multiplication amounts to add the point g to itself a secret number of times",
    "start": "507599",
    "end": "514240"
  },
  {
    "text": "it is indeed critical for both performance of ecc crypto systems and their security let's take a look at",
    "start": "514240",
    "end": "522080"
  },
  {
    "text": "the ecdsa signature generation for an example so ecdsa signing takes a private key",
    "start": "522080",
    "end": "528399"
  },
  {
    "text": "a message a group order a base point and a hash function as inputs and it computes a valid signature",
    "start": "528399",
    "end": "534720"
  },
  {
    "text": "it starts by generating the nodes k that's then multiplied by the base point g",
    "start": "534720",
    "end": "540800"
  },
  {
    "text": "to produce a point r this point r is then used at the remaining",
    "start": "540800",
    "end": "546320"
  },
  {
    "text": "part steps of the signature to to compute the pair of values that are produced as output",
    "start": "546320",
    "end": "553920"
  },
  {
    "text": "this operation here is actually sensitive because if there is any leakage about the nodes k this can be used by an attacker to",
    "start": "554000",
    "end": "561279"
  },
  {
    "text": "obtain information about the signing key if one is worried in particular about timing attacks",
    "start": "561279",
    "end": "567760"
  },
  {
    "text": "in which the adversary monitors the execution time of intermediate steps of the computation to to obtain information about k a",
    "start": "567760",
    "end": "576080"
  },
  {
    "text": "counter measure is to implement this operation in constant time such that the execution time doesn't depend",
    "start": "576080",
    "end": "581600"
  },
  {
    "text": "on the bit pattern of k this is very challenging on modern cpus because they",
    "start": "581600",
    "end": "587120"
  },
  {
    "text": "have because they have instructions like c flush that can reveal secrets through cache data eviction",
    "start": "587120",
    "end": "592720"
  },
  {
    "text": "when programs share a library in memory a flash and reload attack becomes possible so assume that there are a victim and",
    "start": "592720",
    "end": "599200"
  },
  {
    "text": "attacker programs running at the same time and the attacker program is willing to know if",
    "start": "599200",
    "end": "605600"
  },
  {
    "text": "the memory a certain memory access is being performed or not by the victims program",
    "start": "605600",
    "end": "611600"
  },
  {
    "text": "so for that to happen the attacker flushes that memory address and then waits certain number of cycles",
    "start": "611600",
    "end": "617920"
  },
  {
    "text": "that we call the slot before it reloads that address to cache",
    "start": "617920",
    "end": "623200"
  },
  {
    "text": "memory again if the reload step takes a long time this means that the victim",
    "start": "623200",
    "end": "628959"
  },
  {
    "text": "process did not read that memory access however if the reload step takes a short",
    "start": "628959",
    "end": "635519"
  },
  {
    "text": "amount of time this means that the victims process actually read that memory access and the",
    "start": "635519",
    "end": "640720"
  },
  {
    "text": "adversary can use this information to distinguish between the two cases notice however that this attack is not",
    "start": "640720",
    "end": "648720"
  },
  {
    "text": "deterministic in the sense that there could be overlaps between the memory access and",
    "start": "648720",
    "end": "653839"
  },
  {
    "text": "the reload part or some other cases in which it could be confusing for the attacker to",
    "start": "653839",
    "end": "659920"
  },
  {
    "text": "distinguish between the two cases that's why the attacker here is not assumed to obtain a",
    "start": "659920",
    "end": "667120"
  },
  {
    "text": "100 success probability but the attacker will try to choose parameters that are that maximize the",
    "start": "667120",
    "end": "674160"
  },
  {
    "text": "success probability and we actually achieve over 99 probability in our cases",
    "start": "674160",
    "end": "681279"
  },
  {
    "text": "when implementing scalar multiplication in constant time the montgomery ladder algorithm is a prime candidate it takes",
    "start": "682640",
    "end": "688399"
  },
  {
    "text": "a point p osps input defined by a pair of affine coordinates x and y",
    "start": "688399",
    "end": "694160"
  },
  {
    "text": "and the bit pattern of the nodes k as additional input and it computes this kilo multiplication",
    "start": "694160",
    "end": "699600"
  },
  {
    "text": "of k times p it works by initializing two accumulators r0 and r1",
    "start": "699600",
    "end": "706240"
  },
  {
    "text": "that are evaluated using the group law then it scans the bits of the scalar from left to",
    "start": "706240",
    "end": "713120"
  },
  {
    "text": "right and performs some group law operations depending on the key bit",
    "start": "713120",
    "end": "718639"
  },
  {
    "text": "this algorithm benefits constant time implementations because no matter",
    "start": "718639",
    "end": "723680"
  },
  {
    "text": "the value of the key bit the same number of group operations is called notice however",
    "start": "723680",
    "end": "730320"
  },
  {
    "text": "that for a constant time implementation to be performed we need to be careful about",
    "start": "730320",
    "end": "735839"
  },
  {
    "text": "the order in which the points are input and our output in this",
    "start": "735839",
    "end": "741920"
  },
  {
    "text": "instantiations are or disinvocations of the group law",
    "start": "741920",
    "end": "747120"
  },
  {
    "text": "another problem with this attack as it's presented here is the number of durations of the loop",
    "start": "747200",
    "end": "752959"
  },
  {
    "text": "that is that vary with the magnitude of k so we need to find a way to fix this",
    "start": "752959",
    "end": "759360"
  },
  {
    "text": "number of iterations as well so a more realistic version of or a more",
    "start": "759360",
    "end": "765360"
  },
  {
    "text": "protected version of this implementation can be seen in this slide first of all",
    "start": "765360",
    "end": "771760"
  },
  {
    "text": "before the scalar k is used a multiple of the group order is added to produce a",
    "start": "771760",
    "end": "778800"
  },
  {
    "text": "related scalar k prime that has fixed length which allows us to fix the number of iterations of the loop as",
    "start": "778800",
    "end": "785680"
  },
  {
    "text": "well what's interesting here is that the way we add multiples of the group",
    "start": "785680",
    "end": "792240"
  },
  {
    "text": "order preserves the most significant bit of k in the second most significant bit of k prime",
    "start": "792240",
    "end": "799040"
  },
  {
    "text": "also we need to be careful about the branches inside the loop because there could be branch prediction",
    "start": "799200",
    "end": "804320"
  },
  {
    "text": "or other marker architecture features that leak information about the branch being taken or not",
    "start": "804320",
    "end": "810480"
  },
  {
    "text": "so actually we can replace the branches with a conditional swap operation that will swap r0 and r1",
    "start": "810480",
    "end": "816639"
  },
  {
    "text": "without branches depending on the bit of k prime being processed in this iteration of the",
    "start": "816639",
    "end": "822160"
  },
  {
    "text": "loop typically this conditional swap operation is performed in assembly to",
    "start": "822160",
    "end": "828240"
  },
  {
    "text": "prevent interference from the compiler now what remains for this implementation",
    "start": "828240",
    "end": "833360"
  },
  {
    "text": "to be constant time is a careful implementation of the group law ladder leak is a vulnerability exactly",
    "start": "833360",
    "end": "840240"
  },
  {
    "start": "837000",
    "end": "907000"
  },
  {
    "text": "on that part of the algorithm so and if you consider for example that",
    "start": "840240",
    "end": "846160"
  },
  {
    "text": "r0 takes points p in a fine coordinates and r1 computes",
    "start": "846160",
    "end": "851279"
  },
  {
    "text": "two times p in projective coordinates there is a source of leakage on the first iteration of the loop if the group",
    "start": "851279",
    "end": "858000"
  },
  {
    "text": "law implementation is not careful this is what actually inspires the logo we assigned",
    "start": "858000",
    "end": "863360"
  },
  {
    "text": "to this vulnerability for example if the value r1 here can be",
    "start": "863360",
    "end": "869360"
  },
  {
    "text": "distinguished by an attacker as being stored in a fine coordinates this leaks information about the points being",
    "start": "869360",
    "end": "875519"
  },
  {
    "text": "swapped or not which further leaks information about a bit of the scalar the same observation",
    "start": "875519",
    "end": "880800"
  },
  {
    "text": "applies to the point edition here that might take r1 in either projective or fine",
    "start": "880800",
    "end": "886079"
  },
  {
    "text": "coordinates if the attacker is able to observe these differences on the first",
    "start": "886079",
    "end": "891440"
  },
  {
    "text": "iteration of the loop it can actually split a large number of signatures in two sets",
    "start": "891440",
    "end": "898000"
  },
  {
    "text": "which are from the attacker's perspective biased because they shared the same topic",
    "start": "898000",
    "end": "903199"
  },
  {
    "text": "in the scalar or in the gnomes",
    "start": "903199",
    "end": "906800"
  },
  {
    "start": "907000",
    "end": "1053000"
  },
  {
    "text": "our experimental setup involved two broadwell cpus running at different of clock frequencies but both with turbo",
    "start": "908399",
    "end": "916160"
  },
  {
    "text": "boost disabled for reducing noise in the measurements the binaries were executed in userland",
    "start": "916160",
    "end": "921519"
  },
  {
    "text": "runtime without requiring any privileges and openssl was built using the default configuration",
    "start": "921519",
    "end": "926880"
  },
  {
    "text": "with debugging symbols enabled for a slightly more convenient attack",
    "start": "926880",
    "end": "932480"
  },
  {
    "text": "in terms of tooling we used the fr trace binary from domestic sidechain analysis toolkit",
    "start": "932480",
    "end": "938320"
  },
  {
    "text": "which allows us to run flush and reload attacks we configured the slot to be 5000 cycles which was enough for high",
    "start": "938320",
    "end": "944959"
  },
  {
    "text": "precision we also used the other idle cores in our platforms to perform a performance",
    "start": "944959",
    "end": "950880"
  },
  {
    "text": "degradation attack in which they evict code from cache to penalize performance and amplify timing differences between",
    "start": "950880",
    "end": "958320"
  },
  {
    "text": "um these different cases we observed on the previous slide so let's",
    "start": "958320",
    "end": "963680"
  },
  {
    "text": "illustrate this attack by examining how openssl implements arithmetic on prime curves",
    "start": "963680",
    "end": "970000"
  },
  {
    "text": "in this particular case the adverse area will try to find out if point r1 inside the first iteration of the",
    "start": "970000",
    "end": "976079"
  },
  {
    "text": "montgomery ladder is stored in a fine coordinates which leaks in from during the point",
    "start": "976079",
    "end": "981279"
  },
  {
    "text": "doubling operation which leaks information about a bit of the scalar openssl um",
    "start": "981279",
    "end": "988639"
  },
  {
    "text": "actually optimizes for the case when point r1 is in a fine coordinates by performing just a buffer copy when",
    "start": "988639",
    "end": "996160"
  },
  {
    "text": "the coordinate c is one otherwise it computes a full field multiplication using the coordinates so the attacker",
    "start": "996160",
    "end": "1004240"
  },
  {
    "text": "starts two probes on two different parts of the code and measure measures the time it takes for reaching",
    "start": "1004240",
    "end": "1010240"
  },
  {
    "text": "each of these probes and by measuring the time from the first to the second probe it tries to infer",
    "start": "1010240",
    "end": "1016800"
  },
  {
    "text": "what type of computation happened in between observe that the performance",
    "start": "1016800",
    "end": "1022320"
  },
  {
    "text": "difference between this line and this line is not very high but actually a performance degradation attack can amplify the difference to",
    "start": "1022320",
    "end": "1028319"
  },
  {
    "text": "around 15 000 cycles which corresponds to three slots",
    "start": "1028319",
    "end": "1033678"
  },
  {
    "text": "so as a result the attacker is able to mount a flush and reload attack that detects if pn copy is called",
    "start": "1033679",
    "end": "1039839"
  },
  {
    "text": "which means that the z coordinate of the point is one which means that the point is in a fine coordinates which leaks a bit of the scalar and this",
    "start": "1039839",
    "end": "1047438"
  },
  {
    "text": "in our particular case this was possible with larger than 99 precision",
    "start": "1047439",
    "end": "1053440"
  },
  {
    "start": "1053000",
    "end": "1272000"
  },
  {
    "text": "let's take a look at the memory traces for illustration so in these graphs the y-axis has the",
    "start": "1053440",
    "end": "1060240"
  },
  {
    "text": "excess memory access time in cycles and um the threshold we use for a cache hit was",
    "start": "1060240",
    "end": "1066080"
  },
  {
    "text": "a hundred cycles so anything below the red line is considered to be a cache hit",
    "start": "1066080",
    "end": "1071760"
  },
  {
    "text": "so the adversary monitors the scalar multiplication and he observes two point doubly xenon coordinates",
    "start": "1071760",
    "end": "1078080"
  },
  {
    "text": "in the case that the second most significant bit is zero the first one is for initializing the accumulator",
    "start": "1078080",
    "end": "1083120"
  },
  {
    "text": "r1 outside of the loop the second one is related to the first point doubling in the loop",
    "start": "1083120",
    "end": "1088559"
  },
  {
    "text": "when r1 is still in a fine coordinates",
    "start": "1088559",
    "end": "1095120"
  },
  {
    "text": "observe that uh in this case here the time it takes for computing a point doubling",
    "start": "1095120",
    "end": "1100400"
  },
  {
    "text": "is basically dominated by the call to bn copy so we see a difference of three time",
    "start": "1100400",
    "end": "1105520"
  },
  {
    "text": "slots uh in this trace here and the same pattern cannot be observed",
    "start": "1105520",
    "end": "1111360"
  },
  {
    "text": "on the case when the second most simple bit of this killer is one because no",
    "start": "1111360",
    "end": "1118000"
  },
  {
    "text": "doublings of enough coordinates were performed inside the main loop",
    "start": "1118000",
    "end": "1124000"
  },
  {
    "text": "we can also take a look at how the same a similar attack can be mounted against binary curves so now the attacker",
    "start": "1124559",
    "end": "1130720"
  },
  {
    "text": "tries to detect if point r1 is represented in projective coordinates during point addition",
    "start": "1130720",
    "end": "1137200"
  },
  {
    "text": "the formula for point addition starts by multiplying the x coordinate of one accumulator by the z coordinate of the",
    "start": "1137200",
    "end": "1142640"
  },
  {
    "text": "other if r1 is in projective coordinates this means that the z2 value here will be",
    "start": "1142640",
    "end": "1148240"
  },
  {
    "text": "non-trivial and this field multiplication will be full so it will be more expensive than the case when",
    "start": "1148240",
    "end": "1153679"
  },
  {
    "text": "z2 is trivial and has value one so the adversary will try to monitor the",
    "start": "1153679",
    "end": "1159440"
  },
  {
    "text": "time between these two consecutive field multiplications to figure out if this value here is non-trivial",
    "start": "1159440",
    "end": "1166880"
  },
  {
    "text": "again the timing difference at first is not very large but the performance degradation can amplify the difference",
    "start": "1166880",
    "end": "1172240"
  },
  {
    "text": "to 100 000 cycles corresponding to 20 slots of flush and reload attack which allows the attacker to detect if",
    "start": "1172240",
    "end": "1178720"
  },
  {
    "text": "the z2 value here is trivial with larger than 99 precision so again the memory traces",
    "start": "1178720",
    "end": "1186000"
  },
  {
    "text": "illustrate the attack so um we can observe that when the second most",
    "start": "1186000",
    "end": "1192080"
  },
  {
    "text": "significant bit is one the first field multiplication will take a long time so the second field multiplication only starts",
    "start": "1192080",
    "end": "1198400"
  },
  {
    "text": "20 slots later this pattern is not observable when the second most",
    "start": "1198400",
    "end": "1204080"
  },
  {
    "text": "synthetic bit of the scalar is zero and the first field multiplication is fast",
    "start": "1204080",
    "end": "1209520"
  },
  {
    "text": "and finishes quickly and is then followed by the second field multiplication because the z coordinate of the",
    "start": "1209520",
    "end": "1217280"
  },
  {
    "text": "second input to point addition was 1 which led to a faster field multiplication",
    "start": "1217280",
    "end": "1223600"
  },
  {
    "text": "there are many software counter measures that can be used to protect implementations against this attack",
    "start": "1224000",
    "end": "1229360"
  },
  {
    "text": "we list here at least three possible fixes the first and most natural one is randomizing the z coordinates at the",
    "start": "1229360",
    "end": "1235679"
  },
  {
    "text": "beginning of scalar multiplications such that there are no trivial values for z being operated inside",
    "start": "1235679",
    "end": "1241600"
  },
  {
    "text": "the main loop second one is implementing the group law in constant time for example using complete edition formulas",
    "start": "1241600",
    "end": "1248159"
  },
  {
    "text": "without branches or corner cases but this imposes a performance penalty the third",
    "start": "1248159",
    "end": "1253919"
  },
  {
    "text": "possibility is implementing the montgomery ladder of over cos the arithmetic to not handle",
    "start": "1253919",
    "end": "1259039"
  },
  {
    "text": "z-coordinates directly we reported our vulnerabilities to open ssl in december last year and they were",
    "start": "1259039",
    "end": "1265600"
  },
  {
    "text": "ultimately fixed in april this year with the first country measured applied",
    "start": "1265600",
    "end": "1271840"
  },
  {
    "start": "1272000",
    "end": "1331000"
  },
  {
    "text": "the main takeaways of this part of the talk are that securely implementing cryptographic algorithms that are",
    "start": "1272320",
    "end": "1277760"
  },
  {
    "text": "brittle is still very hard many things can go wrong in very subtle ways in particular",
    "start": "1277760",
    "end": "1284720"
  },
  {
    "text": "it's important to not underestimate small timing leakage coming from insecure implementations because an",
    "start": "1284720",
    "end": "1290240"
  },
  {
    "text": "attacker may be able to find a way to exploit those and recover a long-term private key in a more",
    "start": "1290240",
    "end": "1296799"
  },
  {
    "text": "operational manner we recommend everyone to upgrade to openssl version 1.1.1 or version 3.0",
    "start": "1296799",
    "end": "1304960"
  },
  {
    "text": "when it's available as soon as possible the development community behind openssl has made",
    "start": "1304960",
    "end": "1311280"
  },
  {
    "text": "a wonderful effort to improve the code base and its implementation security since heartbleed",
    "start": "1311280",
    "end": "1316400"
  },
  {
    "text": "and should we should all benefit from that effort now akira continues the talk by",
    "start": "1316400",
    "end": "1323600"
  },
  {
    "text": "explaining how the private keys can be computed from biased signatures using a solution of the hidden number",
    "start": "1323600",
    "end": "1330320"
  },
  {
    "text": "problem thanks diego so hello everyone my name is akira takashi i'm currently a phd student at austin",
    "start": "1330320",
    "end": "1337440"
  },
  {
    "start": "1331000",
    "end": "1630000"
  },
  {
    "text": "university in denmark so in this part i'm going to discuss how to exploit the ecdsnos leakage that we",
    "start": "1337440",
    "end": "1343760"
  },
  {
    "text": "obtain from ladder league vulnerable implementations so here's the overview so the goal of",
    "start": "1343760",
    "end": "1350240"
  },
  {
    "text": "the second part is to recover the ecdsa secret signing key by solving the so-called hidden number",
    "start": "1350240",
    "end": "1355760"
  },
  {
    "text": "problem which i'm going to define soon so our attack essentially follows fourier analysis based attack",
    "start": "1355760",
    "end": "1362320"
  },
  {
    "text": "which was originally divided developed by blah blah so this attack method allows us to",
    "start": "1362320",
    "end": "1368799"
  },
  {
    "text": "recover the secret key using only one bit of knowledge information per signature",
    "start": "1368799",
    "end": "1374240"
  },
  {
    "text": "also in order to exploit the practical leakage information our analysis also considers side channel",
    "start": "1374240",
    "end": "1380640"
  },
  {
    "text": "attackers miss detection of those speeds i want to remark that the techniques that i present here",
    "start": "1380640",
    "end": "1386640"
  },
  {
    "text": "in principle applied to other sources of bias or leakage that are independent of ladder leak",
    "start": "1386640",
    "end": "1392880"
  },
  {
    "text": "vulnerability so let's define the hidden number problem so in the hidden number problem",
    "start": "1392880",
    "end": "1399840"
  },
  {
    "text": "the attacker is given the pairs h and z that satisfy this modular",
    "start": "1399840",
    "end": "1404880"
  },
  {
    "text": "equation also the attacker is given the most significant bit information",
    "start": "1404880",
    "end": "1410159"
  },
  {
    "text": "of a node's k and then the goal is to recover the secret key sk so here even though the equation",
    "start": "1410159",
    "end": "1417200"
  },
  {
    "text": "doesn't look like a ecdsa signature actually once you obtain a ucdc signature you can easily",
    "start": "1417200",
    "end": "1423360"
  },
  {
    "text": "convert the signature into an instance of the hidden number problem like this so why do we study the hidden",
    "start": "1423360",
    "end": "1430799"
  },
  {
    "text": "number problem so actually the hidden number problem has been around for more than 20 years",
    "start": "1430799",
    "end": "1436799"
  },
  {
    "text": "and the fundamental attack method was already developed in late 90s the first one is called lattice",
    "start": "1436799",
    "end": "1443279"
  },
  {
    "text": "attack originally proposed by how great graham and smart",
    "start": "1443279",
    "end": "1448720"
  },
  {
    "text": "and soon after that blah blah announced a completely different attack method called fourier analysis base attack",
    "start": "1448720",
    "end": "1455919"
  },
  {
    "text": "which we studied in detail in this work so since the proposal of this attack method",
    "start": "1455919",
    "end": "1461520"
  },
  {
    "text": "there have been a bunch of real-world vulnerabilities that rely on the hidden number problem",
    "start": "1461520",
    "end": "1468000"
  },
  {
    "text": "for example even looking at the last few years we have seen many vulnerabilities including cash quote bot",
    "start": "1468000",
    "end": "1475520"
  },
  {
    "text": "smash return of hidden number problem tpm fail minerva the java attack and raccoon attack all",
    "start": "1475520",
    "end": "1482799"
  },
  {
    "text": "these vulnerabilities essentially rely on the same hidden number problem so concretely by solving the hidden",
    "start": "1482799",
    "end": "1488960"
  },
  {
    "text": "number problem the attacker can steal the secret ecdsa key or",
    "start": "1488960",
    "end": "1494799"
  },
  {
    "text": "in the case of raccoon attack the attacker can still share a dv helmet key shared secret key",
    "start": "1494799",
    "end": "1502000"
  },
  {
    "text": "of the diffie-hellman key exchange so this is why it's very important to study the hidden number problem",
    "start": "1502000",
    "end": "1508000"
  },
  {
    "text": "and to evaluate the concrete attack cost in the hidden number problem",
    "start": "1508000",
    "end": "1513200"
  },
  {
    "text": "so as i mentioned there have been essentially two different approaches to the hidden number problem the first",
    "start": "1513200",
    "end": "1519600"
  },
  {
    "text": "one is called lattice attack which is more famous so the lattice attack is known to work very efficiently",
    "start": "1519600",
    "end": "1526159"
  },
  {
    "text": "if you have relatively large amount of bias or leakage information however if the amount of leakage",
    "start": "1526159",
    "end": "1532720"
  },
  {
    "text": "information is quite small like one bit then essentially a lattice attack doesn't work",
    "start": "1532720",
    "end": "1539200"
  },
  {
    "text": "so in such a case the other approach called fully analysis is known to work more effectively",
    "start": "1539200",
    "end": "1545679"
  },
  {
    "text": "however the measure of bottleneck of this approach is that it requires too much data complexity",
    "start": "1545679",
    "end": "1552640"
  },
  {
    "text": "so of course the main natural question is that can we reduce the data",
    "start": "1552640",
    "end": "1558159"
  },
  {
    "text": "complexity of fourier analysis based attack also we were interested in how far we can go",
    "start": "1558159",
    "end": "1564799"
  },
  {
    "text": "so more concretely can we attack even less than one bit of noise leakage so here less than one bit of nose",
    "start": "1564799",
    "end": "1570480"
  },
  {
    "text": "leakage means that the most significant bit information is only leaked with probability less than one",
    "start": "1570480",
    "end": "1576960"
  },
  {
    "text": "and finally we wanted to know whether there is such a small leakage coming from practical",
    "start": "1576960",
    "end": "1583279"
  },
  {
    "text": "ecdsa implementations in this work we answer these questions in the positive",
    "start": "1583279",
    "end": "1590400"
  },
  {
    "text": "so as a result we managed to set some new records of the solutions to the hidden number",
    "start": "1590559",
    "end": "1596320"
  },
  {
    "text": "problem here's a comparison with the previous work so as you can see in this table we",
    "start": "1596320",
    "end": "1601919"
  },
  {
    "text": "essentially solved all these four cases in the case of 160 bit hnp compared to",
    "start": "1601919",
    "end": "1607679"
  },
  {
    "text": "the compared to the previous method our attack required fewer fewer input",
    "start": "1607679",
    "end": "1612960"
  },
  {
    "text": "signatures to complete the entire secret key recovery",
    "start": "1612960",
    "end": "1618320"
  },
  {
    "text": "also to the best of our knowledge there have been no attack records against a 192 bit agent b",
    "start": "1618320",
    "end": "1625200"
  },
  {
    "text": "so here we set the two new records so now i'm going to give you a technical",
    "start": "1625200",
    "end": "1631760"
  },
  {
    "start": "1630000",
    "end": "1635000"
  },
  {
    "text": "overview of brian baja's fully analysis based attack so the attack consists of two phases",
    "start": "1631760",
    "end": "1638320"
  },
  {
    "start": "1635000",
    "end": "1710000"
  },
  {
    "text": "the first phases is to quantify the bias of nodes k so here we define some bias function",
    "start": "1638320",
    "end": "1645120"
  },
  {
    "text": "such that it outputs something close to zero if the node's k is uniform in integers modulus of the",
    "start": "1645120",
    "end": "1651120"
  },
  {
    "text": "group order on the other hand this bias function should be uh should be something close to one if k is",
    "start": "1651120",
    "end": "1658320"
  },
  {
    "text": "biased in zq so here our first contribution is that we analyze the behavior of this",
    "start": "1658320",
    "end": "1664880"
  },
  {
    "text": "of this bias function when the most significant bit of k is biased with probability less",
    "start": "1664880",
    "end": "1670799"
  },
  {
    "text": "than one then the second step is to find a find the candidate secret key",
    "start": "1670799",
    "end": "1676720"
  },
  {
    "text": "which leads to the peak of this bias function in practice this is carried out by computing",
    "start": "1676720",
    "end": "1682559"
  },
  {
    "text": "fast fourier transform also even though i do not discuss in detail",
    "start": "1682559",
    "end": "1687919"
  },
  {
    "text": "there's actually a critical intermediate step called collision search of integers h so",
    "start": "1687919",
    "end": "1693279"
  },
  {
    "text": "this step is important in order to detect the bias peak correctly and efficiently and actually",
    "start": "1693279",
    "end": "1699760"
  },
  {
    "text": "our second contribution is that we establish the unified time memory data trade-offs by applying a well-known algorithm in",
    "start": "1699760",
    "end": "1706720"
  },
  {
    "text": "the symmetric key a cryptology so now let's define a bias function so",
    "start": "1706720",
    "end": "1713520"
  },
  {
    "start": "1710000",
    "end": "1833000"
  },
  {
    "text": "the bias function can be essentially defined in the form of discrete fourier transform so to get the",
    "start": "1713520",
    "end": "1720000"
  },
  {
    "text": "intuition it's always better to imagine a complex plane and a unit circle on it",
    "start": "1720000",
    "end": "1726320"
  },
  {
    "text": "so for example if the noise k is uniformly distributed then we can imagine some corresponding",
    "start": "1726320",
    "end": "1734399"
  },
  {
    "text": "vectors to those nodes and those vectors are uniformly distributed",
    "start": "1734399",
    "end": "1740480"
  },
  {
    "text": "in the complex plane then if you take the sum of those vectors we can expect that the resulting sum is",
    "start": "1740480",
    "end": "1747600"
  },
  {
    "text": "quite small on the other hand let's think about the biased cases",
    "start": "1747600",
    "end": "1753440"
  },
  {
    "text": "so for example if the most string and bit of noise k is zero then we can imagine that",
    "start": "1753440",
    "end": "1760320"
  },
  {
    "text": "the the those corresponding vectors are concentrated in the upper half of the unit circle so",
    "start": "1760320",
    "end": "1767120"
  },
  {
    "text": "in this case we can expect that the sum of those vectors are much larger so this is how we can quantify the bias",
    "start": "1767120",
    "end": "1774000"
  },
  {
    "text": "of nodes and also this is how we detect a bias whether it is applicable",
    "start": "1774000",
    "end": "1782720"
  },
  {
    "text": "so in practice we have to consider some erroneous leakage information so let's begin with the easiest example",
    "start": "1783039",
    "end": "1790960"
  },
  {
    "text": "so of course in an ideal case if the attacker knows the most most significant bit of",
    "start": "1790960",
    "end": "1796240"
  },
  {
    "text": "nos k with probability 1 then the attacker can collect the completely biased signatures",
    "start": "1796240",
    "end": "1802480"
  },
  {
    "text": "like this however in practice attacker sometimes makes mistakes so the traces sometimes",
    "start": "1802480",
    "end": "1809279"
  },
  {
    "text": "contain errors like this so in this case uh the erroneous leakage information",
    "start": "1809279",
    "end": "1815360"
  },
  {
    "text": "affects the bias function so this is why we we analyze the",
    "start": "1815360",
    "end": "1821600"
  },
  {
    "text": "behavior of bias function under the mis-detection of the non-speeds and more concretely we",
    "start": "1821600",
    "end": "1827840"
  },
  {
    "text": "can estimate the absolute value of the bias function by this form",
    "start": "1827840",
    "end": "1834080"
  },
  {
    "start": "1833000",
    "end": "1896000"
  },
  {
    "text": "moreover we gave a detailed trade of studies in the complexity of the attack so here",
    "start": "1834559",
    "end": "1841200"
  },
  {
    "text": "once you fix the curve parameter and the amount of available leakage information",
    "start": "1841200",
    "end": "1846559"
  },
  {
    "text": "you can draw these trade-off graphs so these trade-off curves essentially mean that",
    "start": "1846559",
    "end": "1853039"
  },
  {
    "text": "if you can spend more time on attack then you require much less input signatures",
    "start": "1853039",
    "end": "1858320"
  },
  {
    "text": "to carry to complete the entire key recovery and vice versa so",
    "start": "1858320",
    "end": "1865279"
  },
  {
    "text": "so this is why if the attacker can carefully choose the point on this trade of curve then data can can",
    "start": "1865279",
    "end": "1872320"
  },
  {
    "text": "always find the optimal balance between time and data complexities",
    "start": "1872320",
    "end": "1877600"
  },
  {
    "text": "also even though i focused on one bit leakage case in the paper we also gave analysis",
    "start": "1877600",
    "end": "1884399"
  },
  {
    "text": "for even more general two or three bit leakage cases and we actually showed that much smaller",
    "start": "1884399",
    "end": "1890720"
  },
  {
    "text": "amount of signatures are needed to attack two or three bit leakage cases",
    "start": "1890720",
    "end": "1896799"
  },
  {
    "start": "1896000",
    "end": "1950000"
  },
  {
    "text": "and after analysis we implemented the entire attack and show that indeed the key recovery",
    "start": "1897360",
    "end": "1904000"
  },
  {
    "text": "attack works so in the case of p192 the attack was made possible",
    "start": "1904000",
    "end": "1909679"
  },
  {
    "text": "by executing our highly optimized pilot implementation in aws ec2",
    "start": "1909679",
    "end": "1916559"
  },
  {
    "text": "and the entire attack completed in a reasonable amount of time also in this attack experiment we",
    "start": "1916559",
    "end": "1924320"
  },
  {
    "text": "confirmed that the attacker even works under some errors by using a bit more",
    "start": "1924320",
    "end": "1931039"
  },
  {
    "text": "signatures than the non-errored case in the case of 163-bit curve and the attack complexity",
    "start": "1931039",
    "end": "1938960"
  },
  {
    "text": "was actually much more modest so in principle you could imbue execute the entire",
    "start": "1938960",
    "end": "1944720"
  },
  {
    "text": "attack against 163-bit case in a small laptop",
    "start": "1944720",
    "end": "1950880"
  },
  {
    "text": "so the main takeaways of the second part are as follows so as we show ac dslr nonce is extremely",
    "start": "1951279",
    "end": "1958320"
  },
  {
    "text": "sensitive and especially even less than one bit of noise leakage per signature is exploitable",
    "start": "1958320",
    "end": "1965679"
  },
  {
    "text": "and even though the hidden number program is too old this is still relevant nowadays because",
    "start": "1965679",
    "end": "1971760"
  },
  {
    "text": "there have been a bunch of other vulnerabilities discovered by other people so we can expect that in the near future",
    "start": "1971760",
    "end": "1979120"
  },
  {
    "text": "there might be some other vulnerability that stems from the nonce leakage of ect ecdsa",
    "start": "1979120",
    "end": "1987600"
  },
  {
    "text": "and after the analysis we got multiple interesting open questions so of course we want to know whether",
    "start": "1987679",
    "end": "1994720"
  },
  {
    "text": "it's possible to further improve time data trade-offs so in our analysis",
    "start": "1994720",
    "end": "2000399"
  },
  {
    "text": "even though we managed to attack one bit leakage still it required at least millions of signatures so of",
    "start": "2000399",
    "end": "2007600"
  },
  {
    "text": "course if you can find more efficient algorithm that gives better",
    "start": "2007600",
    "end": "2013360"
  },
  {
    "text": "trade-off curves then we might be able to reduce further reduce the input data complexity",
    "start": "2013360",
    "end": "2018960"
  },
  {
    "text": "of blahimba's attack also we'd like to know whether there are other social sources of small leakage that allows an",
    "start": "2018960",
    "end": "2026559"
  },
  {
    "text": "attacker to learn 2 or 3-bit leakage under some errors so we expect that in these cases",
    "start": "2026559",
    "end": "2033120"
  },
  {
    "text": "blackheadpass attack works very effectively so thank you very much for your",
    "start": "2033120",
    "end": "2039200"
  },
  {
    "start": "2037000",
    "end": "2051000"
  },
  {
    "text": "attention if you have any questions we are happy to answer also if you are interested in more details you can find",
    "start": "2039200",
    "end": "2047440"
  },
  {
    "text": "our paper in this url",
    "start": "2047440",
    "end": "2053358"
  }
]