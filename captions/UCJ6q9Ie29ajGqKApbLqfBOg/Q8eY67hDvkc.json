[
  {
    "text": "[Music]",
    "start": "1130",
    "end": "14690"
  },
  {
    "text": "hello and welcome to our talk my name is guillaume fornier i'm a security engineer at datadog and today silvambabu",
    "start": "14880",
    "end": "21199"
  },
  {
    "text": "and i are going to talk about a rootkit that we implemented using ebpf if you don't know what ebpf is don't",
    "start": "21199",
    "end": "27519"
  },
  {
    "text": "worry we are going to present this technology and tell you everything you need to know in order to understand the talk",
    "start": "27519",
    "end": "34800"
  },
  {
    "text": "let's start with a few words about us so we are the cloud workload security team we usually use a bpf for good our goal",
    "start": "35120",
    "end": "41760"
  },
  {
    "text": "is to detect threats at runtime and everything we do is integrated into the data kitchen so the data logging is an",
    "start": "41760",
    "end": "48800"
  },
  {
    "text": "open source project so if you are interested feel free to check it out that being said for black hats we",
    "start": "48800",
    "end": "55039"
  },
  {
    "text": "decided to use everything we knew about ebpf to build the ultimate roadkit",
    "start": "55039",
    "end": "61359"
  },
  {
    "text": "so as i said before we are going to start the talk with a brief introduction to ebpf then silva will take it over to",
    "start": "61920",
    "end": "68320"
  },
  {
    "text": "talk about how we implemented publiscation and present access in the rootkit after that i will come back to",
    "start": "68320",
    "end": "74240"
  },
  {
    "text": "present the command and control feature along with some data excitation examples and a few container breakouts finally",
    "start": "74240",
    "end": "81119"
  },
  {
    "text": "silvan will present a few detection and mitigation strategies that you can follow to detect rootkits such as hours",
    "start": "81119",
    "end": "87920"
  },
  {
    "text": "okay let's start with ebpf so a bpf stands for extended berkeley",
    "start": "87920",
    "end": "94640"
  },
  {
    "text": "bracket filter so it is a set of technologies that can run sandbox programs in the linux kernel without",
    "start": "94640",
    "end": "100320"
  },
  {
    "text": "changing the kernel source code or having to load a kernel module it was initially designed for network",
    "start": "100320",
    "end": "105920"
  },
  {
    "text": "packet processing but many new use cases were progressively added for example we can now use zbpi to do",
    "start": "105920",
    "end": "112799"
  },
  {
    "text": "kernel performance tracing or network security and more generally speaking runtime security",
    "start": "112799",
    "end": "118880"
  },
  {
    "text": "so how does it work bpf is simply a two-step process first you have to load your ebpi program in the linux kernel",
    "start": "118880",
    "end": "125759"
  },
  {
    "text": "and then you need to tell the kernel how to trigger your programs so let's have a look at the first step a",
    "start": "125759",
    "end": "131840"
  },
  {
    "text": "bpf programs are written in c so it's not exactly c it's more like a subset of c because of many restrictions that ebpf",
    "start": "131840",
    "end": "138319"
  },
  {
    "text": "has to follow but i'm going to talk about this later so once you have your c program you can",
    "start": "138319",
    "end": "143520"
  },
  {
    "text": "use lnvm to generate ebpf bytecode which you can then load into the kernel with the bpfc school",
    "start": "143520",
    "end": "150080"
  },
  {
    "text": "the bpf programs are made really of two things the first thing is evpn maps and then you have the actual upi programs",
    "start": "150080",
    "end": "157360"
  },
  {
    "text": "there are a lot of different pvpf maps so all you need to know is that they are",
    "start": "157360",
    "end": "162400"
  },
  {
    "text": "the only way to persist data generated by your api programs similarly there are many different types",
    "start": "162400",
    "end": "168959"
  },
  {
    "text": "of program and each program type has its own use case but regardless of the program type each program has to go",
    "start": "168959",
    "end": "175519"
  },
  {
    "text": "through the following two phases first there is the verified step i will talk about this later but for now just",
    "start": "175519",
    "end": "181920"
  },
  {
    "text": "know that this is a way to ensure that your program is vetted and second your ebpf bytecode will be",
    "start": "181920",
    "end": "188000"
  },
  {
    "text": "converted into machine code by your jit compiler when those two phases succeed your program is ready to be executed",
    "start": "188000",
    "end": "196159"
  },
  {
    "text": "step two is attaching vpf programs so this is a way for you to tell the kernel",
    "start": "196159",
    "end": "201440"
  },
  {
    "text": "how to trigger your programs um there are many different program types so i can't present them all but",
    "start": "201440",
    "end": "206879"
  },
  {
    "text": "i'm just going to talk about four of them for example you can use k probes to trigger an epf program whenever a",
    "start": "206879",
    "end": "212799"
  },
  {
    "text": "specific symbol in the kernel is called trace points are similar to k-probes but",
    "start": "212799",
    "end": "217840"
  },
  {
    "text": "the hook points on which they can be attached have to be declared manually by kernel developers",
    "start": "217840",
    "end": "223519"
  },
  {
    "text": "those two programs require another syscall called perf even open to be attached",
    "start": "223519",
    "end": "229120"
  },
  {
    "text": "the other types of programs i wanted to talk about are traffic control classifiers along with xdb programs so",
    "start": "229120",
    "end": "236000"
  },
  {
    "text": "those program types can be used to do packet processing whenever some network traffic is detected either at the host",
    "start": "236000",
    "end": "241599"
  },
  {
    "text": "level or at a specific network interface level those two require a network command to",
    "start": "241599",
    "end": "247200"
  },
  {
    "text": "be attached so the only thing you need to remember is that each program type has its own setup and",
    "start": "247200",
    "end": "252560"
  },
  {
    "text": "thus might require different levels of access another very important fact about uvpf is that wpf maps can be shared between",
    "start": "252560",
    "end": "259600"
  },
  {
    "text": "different programs regardless of their program types",
    "start": "259600",
    "end": "264560"
  },
  {
    "text": "all right so the verifier so the verifier ensures that ebpf programs will finish and won't crash so to do so it's",
    "start": "265520",
    "end": "272320"
  },
  {
    "text": "really just a checklist a list of rules that your programs have to comply with so first for example your program has to",
    "start": "272320",
    "end": "278639"
  },
  {
    "text": "be directed as a kid graph um no unchecked differences and you can't",
    "start": "278639",
    "end": "283680"
  },
  {
    "text": "either have unreachable code there is limits on for example the the size of the stack of your programs along",
    "start": "283680",
    "end": "290400"
  },
  {
    "text": "with the overall count of instructions on your program and finally what i think importantly um",
    "start": "290400",
    "end": "297120"
  },
  {
    "text": "what the verifier is most famous for is its cryptic output so i'm sure a lot of you guys have already used vbpn before",
    "start": "297120",
    "end": "303919"
  },
  {
    "text": "but you will definitely know what i'm talking about um yeah if your program doesn't pass the very first step you are",
    "start": "303919",
    "end": "309680"
  },
  {
    "text": "in for a very painful debugging session last but not least ebpf comes with a",
    "start": "309680",
    "end": "316800"
  },
  {
    "text": "list of wpbf efforts so those helpers will help you access data or execute versions that you",
    "start": "316800",
    "end": "323600"
  },
  {
    "text": "wouldn't be about able to to write natively so in short you have about 160 helpers today and",
    "start": "323600",
    "end": "331360"
  },
  {
    "text": "most of the heavy lifting of your vf programs will be based on those helpers so for example you have context helpers",
    "start": "331360",
    "end": "338080"
  },
  {
    "text": "that will tell you data i mean things about um the user space program that triggered the bpf program or um other",
    "start": "338080",
    "end": "345919"
  },
  {
    "text": "kinds of helpers such as map related helpers or memory related helpers that will let you read or write to memory",
    "start": "345919",
    "end": "354320"
  },
  {
    "text": "all right so that concludes this introduction to ebpf and i will hand it over to silva so that he can kick off",
    "start": "354320",
    "end": "360240"
  },
  {
    "text": "the presentation of the brackets thank you guillaume before we get into the details first let's see why ebpf is",
    "start": "360240",
    "end": "366479"
  },
  {
    "text": "an interesting technology to write the rootkit first the safety grammarity brought by ebpf means that a bug in our",
    "start": "366479",
    "end": "372880"
  },
  {
    "text": "rootkit simply cannot crash the host an error in the execution will not cause any log message to be emitted the user",
    "start": "372880",
    "end": "379520"
  },
  {
    "text": "therefore has no way to know that something actually went wrong and notices the presence of the rootkit as we saw earlier the ebpf by code is",
    "start": "379520",
    "end": "386319"
  },
  {
    "text": "converted into native code and the number of instructions is limited limiting by extensions the performance",
    "start": "386319",
    "end": "392240"
  },
  {
    "text": "impact that our kit can have on the machine that could otherwise be detected by the user",
    "start": "392240",
    "end": "397919"
  },
  {
    "text": "on a commercial note ebpf is used by an increasing number of vendors for various use cases with ebpf becoming widespread",
    "start": "397919",
    "end": "405120"
  },
  {
    "text": "the chance of one product being abused to load malicious programs also increases the safety guarantee we just",
    "start": "405120",
    "end": "411039"
  },
  {
    "text": "talked about should not give the security administrators the false feeling of security",
    "start": "411039",
    "end": "416880"
  },
  {
    "text": "as the set of features that is available for rebf programs is directly coupled to",
    "start": "416880",
    "end": "422160"
  },
  {
    "text": "the kernel version every new release bring new helpers and capabilities we must carefully choose the right balance",
    "start": "422160",
    "end": "428560"
  },
  {
    "text": "between the power of new ebpa features and their availability in real world environments",
    "start": "428560",
    "end": "434319"
  },
  {
    "text": "using helpers such as bpmd pass or technologies such as key rsi would probably have made our route kit easier",
    "start": "434319",
    "end": "441199"
  },
  {
    "text": "to write we decided though to use a set of features that would allow our root kit to run on widely used distribution",
    "start": "441199",
    "end": "447759"
  },
  {
    "text": "such as rail or the latest ubuntu lts one of the primary tasks of our rootkit",
    "start": "447759",
    "end": "453680"
  },
  {
    "text": "is to hide itself what does it mean in our case ebpf programs are bound to running process if this process gets",
    "start": "453680",
    "end": "459840"
  },
  {
    "text": "killed all the attached ebpf program will be unloaded for that reason it is essential that we both hide our program",
    "start": "459840",
    "end": "466720"
  },
  {
    "text": "and protect him from being killed the ebpf programs and maps used by our kids should also be hidden and we should",
    "start": "466720",
    "end": "473520"
  },
  {
    "text": "forbid other programs to gain access to them through file descriptors so let's see our wiki in action",
    "start": "473520",
    "end": "481199"
  },
  {
    "text": "so we start our wikis which is kind enough to deploy displays pid in the standard",
    "start": "483039",
    "end": "489199"
  },
  {
    "text": "output and then we look for this pid in the output of the ps utility",
    "start": "489199",
    "end": "495440"
  },
  {
    "text": "or in the proc file system of the directory and we cannot find any entry we can also",
    "start": "495440",
    "end": "501840"
  },
  {
    "text": "try to guess a file and under this underpinning same result we can also use a relative",
    "start": "501840",
    "end": "509280"
  },
  {
    "text": "class with the same results another way to detect the root kit would",
    "start": "509280",
    "end": "515360"
  },
  {
    "text": "be to send to send it a signal like a user one signal",
    "start": "515360",
    "end": "520479"
  },
  {
    "text": "and we can see here that it triggers an error no such process",
    "start": "520479",
    "end": "525519"
  },
  {
    "text": "so how does it work so this",
    "start": "525519",
    "end": "530959"
  },
  {
    "text": "the observation capabilities of our kit rely mainly on the use of two bpf helpers first one the bpf program user this",
    "start": "530959",
    "end": "537839"
  },
  {
    "text": "helper allows our ebpf program to write into the memory of the process that issues a system call this can be used",
    "start": "537839",
    "end": "544240"
  },
  {
    "text": "for instance to alter the data that is returned by your cisco it is also possible to alter the data provided by",
    "start": "544240",
    "end": "550560"
  },
  {
    "text": "the process as argument to the cisco one cabinet of this helper though is that the memory to be modified has to be",
    "start": "550560",
    "end": "557680"
  },
  {
    "text": "mapped into the kernel address space otherwise the mirror or major page fault will be triggered causing the call to",
    "start": "557680",
    "end": "563519"
  },
  {
    "text": "dpf pro right user to silently fail the other bpf helper is a bpf override retail this one makes it possible to",
    "start": "563519",
    "end": "570320"
  },
  {
    "text": "change the return value of this score it has an interesting property though if the helper is used at the system return",
    "start": "570320",
    "end": "576240"
  },
  {
    "text": "it will simply change the retail value of the executive score now if it's used at the entry of the cisco the execution",
    "start": "576240",
    "end": "582560"
  },
  {
    "text": "of the cisco will be completely skipped so let's look at how the authentication of the",
    "start": "582560",
    "end": "588640"
  },
  {
    "text": "file actually works at startup the rootkit will populate a map with the passwords pid folder now",
    "start": "588640",
    "end": "595680"
  },
  {
    "text": "the user space issues a file related cisco such as stats these syscalls usually come in two forms one that",
    "start": "595680",
    "end": "602320"
  },
  {
    "text": "accepts the pass to the stream to the file as a string another one that accepts a file street descriptor for the",
    "start": "602320",
    "end": "608079"
  },
  {
    "text": "file that the user space program must have previously retrieved using an open cisco",
    "start": "608079",
    "end": "613839"
  },
  {
    "text": "so let's consider the form the pass specified could be a relative pass now to properly identify the targeted file",
    "start": "613839",
    "end": "620880"
  },
  {
    "text": "the rootkit needs to do an accurate resolution of the past unfortunately there is simply not enough context to do",
    "start": "620880",
    "end": "626640"
  },
  {
    "text": "so at the entry of the syscall so we need to hook deeper into the kernel in the vfs code at this point it's too late",
    "start": "626640",
    "end": "633600"
  },
  {
    "text": "to what the cisco therefore at this is called the exit we need to change the return value to make the user space",
    "start": "633600",
    "end": "639839"
  },
  {
    "text": "believe the call failed for instance and also and also scrub the content of the structures that were filled by the curve",
    "start": "639839",
    "end": "647440"
  },
  {
    "text": "now let's consider the later this version that accepts a file descriptor we do the same pass resolution as before",
    "start": "647440",
    "end": "653839"
  },
  {
    "text": "but we pretend to user's method to call failed while storing the file descriptor that was effectively allocated by the",
    "start": "653839",
    "end": "660560"
  },
  {
    "text": "kernel into an ebpf map if the same process issues a cisco with the same file descriptor we can add the cisco",
    "start": "660560",
    "end": "666880"
  },
  {
    "text": "entry return and narrow and block a cisco blocking the cisco that accepts the pid",
    "start": "666880",
    "end": "673200"
  },
  {
    "text": "as argument is trivial using bpf override same for loading kernel module",
    "start": "673200",
    "end": "679120"
  },
  {
    "text": "so now let's look at the obfuscation of our ebpf programming maps",
    "start": "679120",
    "end": "685200"
  },
  {
    "text": "so we use the bpf tool that is provided",
    "start": "686640",
    "end": "692640"
  },
  {
    "text": "in the kernel sources and it allows us to list the program and the maps loading on the systems and",
    "start": "692640",
    "end": "699440"
  },
  {
    "text": "at this point our idpf on our rootkit is loaded and we cannot see any map any program associated to it",
    "start": "699440",
    "end": "705200"
  },
  {
    "text": "now if we start another program an ebpa program that is making use of maps and",
    "start": "705200",
    "end": "710639"
  },
  {
    "text": "keyproofs we can see the new and the new probes or programs",
    "start": "710639",
    "end": "715680"
  },
  {
    "text": "created and the new maps but still not the one associated with our without grid kit",
    "start": "715680",
    "end": "721680"
  },
  {
    "text": "so the idea here is to hook into the ppf call itself the two things are required",
    "start": "721680",
    "end": "728079"
  },
  {
    "text": "here first to avoid the user space to iterate through the ids of our entities programs and maps assigned by the kernel",
    "start": "728079",
    "end": "735040"
  },
  {
    "text": "using the bpf pro get next id and pro bpf map get next id",
    "start": "735040",
    "end": "740480"
  },
  {
    "text": "we also need to prevent user space from getting a file descriptor to the programmer map from an id that it might",
    "start": "740480",
    "end": "746800"
  },
  {
    "text": "it might have guessed using bpf pro get fd by id",
    "start": "746800",
    "end": "752480"
  },
  {
    "text": "so once these operations are handled by the rootkit the user space is not able to view or modify our programs and maps",
    "start": "752480",
    "end": "760800"
  },
  {
    "text": "bpf program user is a crucial part of our wiki but it comes with a pitfall when an ebpf program that makes use of",
    "start": "760800",
    "end": "766639"
  },
  {
    "text": "it is loaded the kernel prints a legitimate though pretty scary message in the canon ring buffer so let's look",
    "start": "766639",
    "end": "773360"
  },
  {
    "text": "at how the rootkit handles this case",
    "start": "773360",
    "end": "777120"
  },
  {
    "text": "so we can look at the contents of the canadian buffer before the rootkit is loaded",
    "start": "778880",
    "end": "784959"
  },
  {
    "text": "and we can start a program in this case it's cat and it's a slash key message and it will block and",
    "start": "784959",
    "end": "791600"
  },
  {
    "text": "waiting for new message to arrive into the ring buffer we then start our ebpf",
    "start": "791600",
    "end": "798839"
  },
  {
    "text": "request and we can see that the cat program exited because there was a new",
    "start": "798839",
    "end": "804160"
  },
  {
    "text": "message inserted in the personal green buffer but that's not the one that the kernel inserted to to warn us about the use of",
    "start": "804160",
    "end": "811519"
  },
  {
    "text": "bpa provide user and we can also look at the whole contents of the canadian buffer and still not find the",
    "start": "811519",
    "end": "819440"
  },
  {
    "text": "the message so so in this demo the cad slash dev key",
    "start": "819440",
    "end": "826240"
  },
  {
    "text": "message john d in our diagram is blocked on read syscalls that will return once a",
    "start": "826240",
    "end": "832240"
  },
  {
    "text": "new message arrives so two ebpf programs have to be loaded by the rootkit sequentially the first",
    "start": "832240",
    "end": "839120"
  },
  {
    "text": "one which doesn't use vpf for bright user will hook on read syscalls and will make it return zero",
    "start": "839120",
    "end": "846240"
  },
  {
    "text": "and write legit looking messages into the the performing buffer after a short delay the second program",
    "start": "846240",
    "end": "852880"
  },
  {
    "text": "this time using bpf for great user will be loaded at this point the read syscalls can be unblocked over and we",
    "start": "852880",
    "end": "860560"
  },
  {
    "text": "can safely override the contents of the first read messages with other alleged looking messages",
    "start": "860560",
    "end": "867920"
  },
  {
    "text": "now another important task for the rootkit is to set a persistent success across reboots for instance",
    "start": "868800",
    "end": "875519"
  },
  {
    "text": "for persistent access to the system a generic method close to the ones described in the appreciation part",
    "start": "875519",
    "end": "881279"
  },
  {
    "text": "allows replacing the red content of some critical files such as the ssh server",
    "start": "881279",
    "end": "886320"
  },
  {
    "text": "authorized keys or scripts executed by root demand such as prodi or systemd",
    "start": "886320",
    "end": "893440"
  },
  {
    "text": "persistent access to an application database can also be set up using another type of ebpf program called eu",
    "start": "893440",
    "end": "899199"
  },
  {
    "text": "probes so concepts conceptually there really are ebpf programs attached to user space",
    "start": "899199",
    "end": "905040"
  },
  {
    "text": "function in addition to being safer and easier to use than b traits they offer a",
    "start": "905040",
    "end": "910160"
  },
  {
    "text": "valuable advantage the camo will automatically set up for us the hooks on every new instance on the program of the",
    "start": "910160",
    "end": "917279"
  },
  {
    "text": "program so let's see an example targeting postgresql",
    "start": "917279",
    "end": "922720"
  },
  {
    "text": "so we have a postgresql server with a web app role with the bonsoir password but we don't know this password",
    "start": "923440",
    "end": "930320"
  },
  {
    "text": "and we would like to get access to it using a randomly chosen password in this case hello so we start our ebps with it",
    "start": "930320",
    "end": "938079"
  },
  {
    "text": "and it will set up the the year probe and using a value inside an ebpf map",
    "start": "938079",
    "end": "943759"
  },
  {
    "text": "it will override the accepted value for the password in this case we managed to",
    "start": "943759",
    "end": "949279"
  },
  {
    "text": "log in with the yellow so the idea here is to hook on the md5",
    "start": "949279",
    "end": "956639"
  },
  {
    "text": "script verify function of password sql that checks whether the user provided the right md5 for its role password and",
    "start": "956639",
    "end": "963680"
  },
  {
    "text": "the challenge sent by the server overwriting the expected hash contained in the variable shadow pass with a known",
    "start": "963680",
    "end": "970800"
  },
  {
    "text": "value makes the comparison succeed and gives persistent access to the database to the attacker",
    "start": "970800",
    "end": "977440"
  },
  {
    "text": "now i will head over to guillen that will show you the combination control capabilities of the rootkit",
    "start": "977440",
    "end": "983759"
  },
  {
    "text": "thank you silva let's talk about the command and control feature of the rootkit so what exactly do we want to do",
    "start": "983759",
    "end": "989839"
  },
  {
    "text": "we want to be able to send commands to the rootkit to exfoliate data and to get remote access to the infected hosts",
    "start": "989839",
    "end": "995759"
  },
  {
    "text": "unfortunately there are a few ebpf related challenges that we need to face in order to implement those features",
    "start": "995759",
    "end": "1002560"
  },
  {
    "text": "first you can't initiate a connection with a bpf second you can't open a port however ebpf can be used to hijack an",
    "start": "1002560",
    "end": "1010240"
  },
  {
    "text": "existing connection so in order to solve this feature we have set up a very simple infrastructure",
    "start": "1010240",
    "end": "1016880"
  },
  {
    "text": "on aws a simple web app was installed on an ec2 instance and we used a classic load",
    "start": "1016880",
    "end": "1023440"
  },
  {
    "text": "balancer to redirect https traffic to our instance over http the ip address of the load balancer is",
    "start": "1023440",
    "end": "1030079"
  },
  {
    "text": "resolved from the blackhead.demo.dns name and in other words the tls termination is done at the",
    "start": "1030079",
    "end": "1036240"
  },
  {
    "text": "load balancer level which means that http requests are sent to our instance unencrypted",
    "start": "1036240",
    "end": "1041600"
  },
  {
    "text": "so our goal is to implement cnc by hijacking the network traffic to our web app",
    "start": "1041600",
    "end": "1047760"
  },
  {
    "text": "first we need to figure out which vpnf program type we're going to use to in order to implement this feature",
    "start": "1047760",
    "end": "1054640"
  },
  {
    "text": "so although ebps provides a lot of options to choose from we decided to go with two different ebpf program types so",
    "start": "1054640",
    "end": "1060799"
  },
  {
    "text": "those two different program types are xdp programs and traffic control classifiers both of those program types are usually",
    "start": "1060799",
    "end": "1067440"
  },
  {
    "text": "used for deep packet inspection so while xdp works on ingress tc works",
    "start": "1067440",
    "end": "1073120"
  },
  {
    "text": "on both ingress and egress traffic another difference between the two programs are",
    "start": "1073120",
    "end": "1078400"
  },
  {
    "text": "is that xdp programs can be offloaded to network interface controllers which essentially means that your program will",
    "start": "1078400",
    "end": "1085679"
  },
  {
    "text": "be run before the packet enters any subsystem of the network stack on the other hand tc programs have to be",
    "start": "1085679",
    "end": "1092880"
  },
  {
    "text": "attached to a specific network interface which means that they are triggered much later in",
    "start": "1092880",
    "end": "1098720"
  },
  {
    "text": "the network stack with both programs you can drop allow or modify packets and with xzp program you",
    "start": "1098720",
    "end": "1106240"
  },
  {
    "text": "can also retransmit a packet so this option is super interesting because this means that you can essentially hide",
    "start": "1106240",
    "end": "1113200"
  },
  {
    "text": "data from the kernel entirely and you can receive and insert it up back to a packet even before it reaches um any",
    "start": "1113200",
    "end": "1120320"
  },
  {
    "text": "kind of network firewall or a network monitoring tool um",
    "start": "1120320",
    "end": "1126160"
  },
  {
    "text": "skipping the the network stack also explains why xdp programs are mainly used for ddos mitigation because um the",
    "start": "1126160",
    "end": "1132240"
  },
  {
    "text": "the overhead of the network stack is not there and you will be able to drop packets much faster",
    "start": "1132240",
    "end": "1138240"
  },
  {
    "text": "as for tc programs they are often used to monitor and secure network access to",
    "start": "1138240",
    "end": "1144000"
  },
  {
    "text": "containers um or at the container or at the pod level",
    "start": "1144000",
    "end": "1149600"
  },
  {
    "text": "all right so what you need to remember from this slide is network packets can be hidden from the kernel entirely and um data can be explicited with an ebp",
    "start": "1149600",
    "end": "1156799"
  },
  {
    "text": "ftc classifier because you can modify packets as they go out of the host",
    "start": "1156799",
    "end": "1162880"
  },
  {
    "text": "all right so first let's see how we used uh xdp programs to receive comments from",
    "start": "1163039",
    "end": "1168320"
  },
  {
    "text": "the rootkit so we've implemented a client to um for the rootkit and this client uh",
    "start": "1168320",
    "end": "1174880"
  },
  {
    "text": "simply does um you know like it emits https requests to the rootkit with a",
    "start": "1174880",
    "end": "1180559"
  },
  {
    "text": "custom rule and root sorry in a custom and data into the user agent so after going through the load balancer",
    "start": "1180559",
    "end": "1187600"
  },
  {
    "text": "the request eventually reaches the host and triggers our xdp program then our",
    "start": "1187600",
    "end": "1192960"
  },
  {
    "text": "programs parse the requests the http route for example and understand if that request is meant for us and not for the",
    "start": "1192960",
    "end": "1198960"
  },
  {
    "text": "web app after reading the user agent the rootkit executes the requested command and moves",
    "start": "1198960",
    "end": "1204720"
  },
  {
    "text": "on to the final step so the final step is probably the most important one of this entire process",
    "start": "1204720",
    "end": "1211360"
  },
  {
    "text": "so the final step consists in overwriting the entire request with a",
    "start": "1211360",
    "end": "1216400"
  },
  {
    "text": "health check request and we do so for two reasons first we don't want the malicious request to reach the web app",
    "start": "1216400",
    "end": "1222799"
  },
  {
    "text": "or any kind of user space monitoring tools that might detect the unusual traffic",
    "start": "1222799",
    "end": "1228640"
  },
  {
    "text": "second we want the client to receive an answer in order to know if the request was successful or not",
    "start": "1228640",
    "end": "1234400"
  },
  {
    "text": "so as i said before we could also have dropped the package entirely but since we're using tcp the load balancer would",
    "start": "1234400",
    "end": "1240480"
  },
  {
    "text": "have retransmitted the request over and over again until the request times out so this would generate noise and",
    "start": "1240480",
    "end": "1246880"
  },
  {
    "text": "increase our chances of getting discovered that said it would be a valid strategy for udp packets",
    "start": "1246880",
    "end": "1253120"
  },
  {
    "text": "let's have a look at how we can send postgresql credentials using this method",
    "start": "1253120",
    "end": "1259200"
  },
  {
    "text": "so um on the left here what you can see is two cells connected to the uh our",
    "start": "1260400",
    "end": "1265919"
  },
  {
    "text": "instance on aws and on the right this is my local shell so first let's try to log in to postgres",
    "start": "1265919",
    "end": "1272559"
  },
  {
    "text": "with the default password which is boswell so it works fine great now let's start the rootkit and do it again and as",
    "start": "1272559",
    "end": "1278799"
  },
  {
    "text": "expected it won't work okay and the reason why it won't work is because we have hardcoded into the",
    "start": "1278799",
    "end": "1284960"
  },
  {
    "text": "rootkit um you know to change i mean the new password and the new password is hello so this time with",
    "start": "1284960",
    "end": "1290559"
  },
  {
    "text": "hello it does work okay so now yet let's use cnc to send the new password so in",
    "start": "1290559",
    "end": "1296080"
  },
  {
    "text": "this request what you can see is that we are sending something to blackhead.demo.dag and we are telling the rootkit to",
    "start": "1296080",
    "end": "1302480"
  },
  {
    "text": "override the password of the web app role so that now it is uh black hat so as you can see there is a custom rule",
    "start": "1302480",
    "end": "1308880"
  },
  {
    "text": "root sorry and then the data is put into the user agent and this is the the 200",
    "start": "1308880",
    "end": "1315120"
  },
  {
    "text": "okay from the health check so we know that the request went through and that the ebpf kits did actually um you know",
    "start": "1315120",
    "end": "1322240"
  },
  {
    "text": "modify the password okay so if you try with hello again it won't work but this time if you do",
    "start": "1322240",
    "end": "1327600"
  },
  {
    "text": "black hat it does work",
    "start": "1327600",
    "end": "1332720"
  },
  {
    "text": "okay great",
    "start": "1332720",
    "end": "1335520"
  },
  {
    "text": "so um okay so this is how um we we can send a command to the rootkit",
    "start": "1338640",
    "end": "1344720"
  },
  {
    "text": "now let's see how we can exfiltrate data so to exfiltrate data the client has to",
    "start": "1344720",
    "end": "1349919"
  },
  {
    "text": "send an initial request to specify what we want to accelerate so the xdp part is basically the same as",
    "start": "1349919",
    "end": "1356880"
  },
  {
    "text": "before but this time the xdp program stores the network flow that made the request along with the requested",
    "start": "1356880",
    "end": "1363039"
  },
  {
    "text": "resource in an ebpf map and the reason why we do so is because when the web app enters the health check",
    "start": "1363039",
    "end": "1369039"
  },
  {
    "text": "request we want to be able to detect the packets that are meant to be sent back to our clients so when the http answer",
    "start": "1369039",
    "end": "1376320"
  },
  {
    "text": "reaches our tc egress classifier our bpf program looks up the network flow and",
    "start": "1376320",
    "end": "1382320"
  },
  {
    "text": "overrides the content of the answer with the file content if you wanted to exfiltrate file data or basically",
    "start": "1382320",
    "end": "1387919"
  },
  {
    "text": "anything you wanted to extra trade so now the question is um what can you exfiltrate with the roadkit",
    "start": "1387919",
    "end": "1394640"
  },
  {
    "text": "so everything we've showed so far work because we can share bbf maps",
    "start": "1394640",
    "end": "1400080"
  },
  {
    "text": "between multiple programs of multiple program types and what this means is anything that is",
    "start": "1400080",
    "end": "1405440"
  },
  {
    "text": "accessible to a bpf is expected it can be expected with the the the same technique so for example this includes",
    "start": "1405440",
    "end": "1412159"
  },
  {
    "text": "file contents environment variables database jump dumps and in-memory data",
    "start": "1412159",
    "end": "1419919"
  },
  {
    "text": "all right so let's have a look at a small demo um i want to show you that we can exfiltrate postgres credentials and",
    "start": "1420559",
    "end": "1426880"
  },
  {
    "text": "the content of the other files such as adc password all right so again on the left you have",
    "start": "1426880",
    "end": "1432080"
  },
  {
    "text": "the two shells connected to the instance on aws and my remote and my local shell on the right and as you can see",
    "start": "1432080",
    "end": "1438799"
  },
  {
    "text": "the ebpf grid kit is already running on the top here all right so um",
    "start": "1438799",
    "end": "1445600"
  },
  {
    "text": "all we have to do to exfiltrate postgresql purpose that passwords or credentials is i make a",
    "start": "1445600",
    "end": "1451919"
  },
  {
    "text": "request to blackhead.demoted.org and say process list so again everything is encoded into the requests and then",
    "start": "1451919",
    "end": "1458080"
  },
  {
    "text": "eventually the rootkit will insert and tell you that um yeah three different roles were used uh",
    "start": "1458080",
    "end": "1464720"
  },
  {
    "text": "since the rootkit was started and you have the hash passwords of those roles so keep in mind that with pausewise you",
    "start": "1464720",
    "end": "1470480"
  },
  {
    "text": "don't need to have the clear password to log in um you just need the hash password it's fine",
    "start": "1470480",
    "end": "1476240"
  },
  {
    "text": "all right so now um what i want to do is demo the um the other thing the other excitation example which is uh the",
    "start": "1476240",
    "end": "1482480"
  },
  {
    "text": "content of a file okay so it's a two-step process so what the way we do it is um we tell the root kits to start",
    "start": "1482480",
    "end": "1489279"
  },
  {
    "text": "looking for etc password d and whenever a process in user space tries to open the file and read the file then the the",
    "start": "1489279",
    "end": "1496159"
  },
  {
    "text": "workkit will make a copy of the data of the data that is read from the file as it is sent to um the user space process",
    "start": "1496159",
    "end": "1503279"
  },
  {
    "text": "so that we don't trigger i mean we can't trigger anything because we are um you know we are using a process that is",
    "start": "1503279",
    "end": "1508799"
  },
  {
    "text": "already starting the trying to read the file so this first step tells exactly that so",
    "start": "1508799",
    "end": "1514960"
  },
  {
    "text": "from now on whenever a user space program try tries to open uh etc password we will be able to catch the",
    "start": "1514960",
    "end": "1521200"
  },
  {
    "text": "data so as i said before um we need to in order for the demo to work we need a",
    "start": "1521200",
    "end": "1526400"
  },
  {
    "text": "user space program to open the file so let's just do that on the left and now let's go back and request the",
    "start": "1526400",
    "end": "1532320"
  },
  {
    "text": "content of etc password d and here we go",
    "start": "1532320",
    "end": "1538158"
  },
  {
    "text": "all right so what's cool about this method is that it technically applies to any unencrypted network protocol so for",
    "start": "1538480",
    "end": "1544559"
  },
  {
    "text": "example we also need it for dns and this method can be used for example to override either the requests domain name",
    "start": "1544559",
    "end": "1551120"
  },
  {
    "text": "or the uh the ip the resolved ips so yeah basically you can do dns poofing",
    "start": "1551120",
    "end": "1556480"
  },
  {
    "text": "with this all right let's move on to our container breakouts so",
    "start": "1556480",
    "end": "1562960"
  },
  {
    "text": "this first container breakout works because the rootkit can detect and take over pipes between two processes at time",
    "start": "1562960",
    "end": "1569919"
  },
  {
    "text": "so we have two variants of this breakout and we can do this either with k probes",
    "start": "1569919",
    "end": "1575600"
  },
  {
    "text": "or trace points and the reason why this breakout works is because k probes and trace points are not constrained by",
    "start": "1575600",
    "end": "1582480"
  },
  {
    "text": "namespaces or c groups so if you successfully load a k probe from a container and if with this k probe you",
    "start": "1582480",
    "end": "1589039"
  },
  {
    "text": "can trick a user space program into executing code then you essentially have found a new container breakout",
    "start": "1589039",
    "end": "1595440"
  },
  {
    "text": "um so let's talk about required access so as i said before we assume that you have potentially breached a service that",
    "start": "1595440",
    "end": "1602559"
  },
  {
    "text": "has access to ebpf this means that this service has at least caps this admin um",
    "start": "1602559",
    "end": "1607840"
  },
  {
    "text": "so uh or cap bpf uh and cap perform depending on the kernel version and then um we add other kernel capabilities",
    "start": "1607840",
    "end": "1615440"
  },
  {
    "text": "because we want to demo this container breakout through command and control so you also require capsis resource capnet",
    "start": "1615440",
    "end": "1622080"
  },
  {
    "text": "admin and to share the network namespace of the host again this line is optional this is because we are going to demo",
    "start": "1622080",
    "end": "1628159"
  },
  {
    "text": "this container breakout with common control but you don't need those to break out um then the default second profile can",
    "start": "1628159",
    "end": "1635279"
  },
  {
    "text": "be activated and finally depending on the variant that you want to use for this workout you might need to disable",
    "start": "1635279",
    "end": "1641440"
  },
  {
    "text": "app armor so i'm not going to talk about how we catch pipes at runtime because i don't",
    "start": "1641440",
    "end": "1648320"
  },
  {
    "text": "have time for that but also because it's not that much interesting to be honest however i'm going to explain what",
    "start": "1648320",
    "end": "1653919"
  },
  {
    "text": "happens when we catch a process trying to read data from the receiver end of a",
    "start": "1653919",
    "end": "1658960"
  },
  {
    "text": "pipe okay so let's take the example of a",
    "start": "1658960",
    "end": "1664159"
  },
  {
    "text": "batch process trying to read from a pipe so in a nutshell we keep in an eppf map",
    "start": "1664159",
    "end": "1669600"
  },
  {
    "text": "a buffer of the data that we want to pipe to bash so initially this buffer",
    "start": "1669600",
    "end": "1675360"
  },
  {
    "text": "contains what the rootkit was configured to pipe so in other words the payload but then if you use the k-pro variant",
    "start": "1675360",
    "end": "1682480"
  },
  {
    "text": "we are able to append the original piped data to that buffer so that when we are",
    "start": "1682480",
    "end": "1687520"
  },
  {
    "text": "done writing the payload we can seemingly start writing the initial data on a more technical level this means",
    "start": "1687520",
    "end": "1693919"
  },
  {
    "text": "that we are going to send more data than what was initially written to the pipe and to do so we need to use the bpf",
    "start": "1693919",
    "end": "1700880"
  },
  {
    "text": "override return helper unfortunately this helper is only available to k-probes and this explains",
    "start": "1700880",
    "end": "1707039"
  },
  {
    "text": "why we have two variants of the rootkit so if you want to do to have this feature you would use k-probes in other",
    "start": "1707039",
    "end": "1713279"
  },
  {
    "text": "words you would need to have 2d to visible or at least modify the apartment profile um so that you can actually",
    "start": "1713279",
    "end": "1719440"
  },
  {
    "text": "access the csfs file system so that you can register the k-probe or if you don't care about this",
    "start": "1719440",
    "end": "1724799"
  },
  {
    "text": "feature you can use a trace point in which means that you don't need and i mean you can lift the up armor profile",
    "start": "1724799",
    "end": "1731200"
  },
  {
    "text": "requirement all right so let's move on to the demo",
    "start": "1731200",
    "end": "1736240"
  },
  {
    "text": "so on the top there you can see again those two the two shells to uh the remote host",
    "start": "1737760",
    "end": "1743679"
  },
  {
    "text": "on ws and then my laptop is at the bottom here um and we're gonna start a container with all the requested access",
    "start": "1743679",
    "end": "1750000"
  },
  {
    "text": "that we i've just talked about so let's let's imagine that um you know some kind of administrator was trying to install",
    "start": "1750000",
    "end": "1756159"
  },
  {
    "text": "something and uh do this by you know fetching a script from a local",
    "start": "1756159",
    "end": "1761360"
  },
  {
    "text": "server and then piping the output to bash so this script is very simple it's just id so if you",
    "start": "1761360",
    "end": "1766960"
  },
  {
    "text": "pipe it to bash it will be it will answer the uid of the current user so let's start the rootkit now",
    "start": "1766960",
    "end": "1774480"
  },
  {
    "text": "all right and then when it's done we are going to configure the pipe data through cnc so using the ebpf client",
    "start": "1774480",
    "end": "1782960"
  },
  {
    "text": "um so you send a request to blackhat.demo dog saying that um if i mean i want to send you the data and i",
    "start": "1782960",
    "end": "1790080"
  },
  {
    "text": "want you to override data from if someone tries to pipe something and triggers a comment",
    "start": "1790080",
    "end": "1795360"
  },
  {
    "text": "that pipes data from curl to bash and this is the data that should be piped instead of what was initially packed",
    "start": "1795360",
    "end": "1802240"
  },
  {
    "text": "perfect so you get the answer so evpf kit understood that i mean what needs to be piped now and as",
    "start": "1802240",
    "end": "1808399"
  },
  {
    "text": "you can see if you pipe the data again you can say that it's a ping instead of the uid as before",
    "start": "1808399",
    "end": "1813679"
  },
  {
    "text": "all right so now i want to actually do something sneaky i don't want to you know show the user that you know some",
    "start": "1813679",
    "end": "1820240"
  },
  {
    "text": "random script was executed instead of what he wanted to execute so to do this i'm going to pipe the output of the ping",
    "start": "1820240",
    "end": "1825760"
  },
  {
    "text": "to a file and i also going to say um please backup the pipe data so i'm going to add a flag to the request here you go",
    "start": "1825760",
    "end": "1834080"
  },
  {
    "text": "and this will tell ebpf kits to you know do the mechanism that i talked about which is to pipe the initial data",
    "start": "1834080",
    "end": "1840880"
  },
  {
    "text": "after um our uh our scripts and here we go if you do it again you can see uid",
    "start": "1840880",
    "end": "1846480"
  },
  {
    "text": "gid and um you won't see that you know what our script was executed in the background",
    "start": "1846480",
    "end": "1852799"
  },
  {
    "text": "and if you look at the file at the blackhead file as you can see the ping is successful",
    "start": "1852799",
    "end": "1858080"
  },
  {
    "text": "all right so now let's talk about our second",
    "start": "1858080",
    "end": "1863840"
  },
  {
    "text": "container breakout so this second container breakout is based on the fact that the rootkits can",
    "start": "1863840",
    "end": "1869039"
  },
  {
    "text": "switch docker images at runtime so for this breakout to work we added a u probe on the docker demon and more",
    "start": "1869039",
    "end": "1874640"
  },
  {
    "text": "specifically on the parse normalized name function so this function is usually called whenever you make a",
    "start": "1874640",
    "end": "1881039"
  },
  {
    "text": "request to docker and and this function will parse the docker image name from your request",
    "start": "1881039",
    "end": "1887120"
  },
  {
    "text": "once again this your pro based container works because sorry your container breakout works because um your probes",
    "start": "1887120",
    "end": "1894480"
  },
  {
    "text": "are not constrained to namespaces or c grips and most precisely as long as you have access to the file that you want to",
    "start": "1894480",
    "end": "1901360"
  },
  {
    "text": "put a up on and the kernel will add the up to all the processes that actually",
    "start": "1901360",
    "end": "1906880"
  },
  {
    "text": "execute that file regardless of where they live so what about the required access so",
    "start": "1906880",
    "end": "1912159"
  },
  {
    "text": "it's basically the same as the previous container breakout with the only difference being that you need to share",
    "start": "1912159",
    "end": "1917200"
  },
  {
    "text": "the host directory with the container so the truth is you don't really need the entire root directory but simply the",
    "start": "1917200",
    "end": "1924559"
  },
  {
    "text": "docker demand binary however realistically speaking this will only happen if the directory is shared",
    "start": "1924559",
    "end": "1931519"
  },
  {
    "text": "so let's see how we leveraged this capability of the rootkits to break out of a container on communities",
    "start": "1931519",
    "end": "1939518"
  },
  {
    "text": "so whenever communities schedule the part on the host it will use a post container to set up",
    "start": "1939679",
    "end": "1944799"
  },
  {
    "text": "the network namespace of the pod and and hold the ip address of the pad so this container is meant to simply",
    "start": "1944799",
    "end": "1951120"
  },
  {
    "text": "wait and um will keep running until the part is deleted and because this container is not meant to do anything",
    "start": "1951120",
    "end": "1957760"
  },
  {
    "text": "quantities does not really monitor it so for example it does not apply any kind of cpu or memory limits",
    "start": "1957760",
    "end": "1964080"
  },
  {
    "text": "in other words this is a perfect target for us um if we can successfully take over this container we will have a",
    "start": "1964080",
    "end": "1969519"
  },
  {
    "text": "foothold on all the parts of the host and this foothold will basically be invisible to normal kubernetes",
    "start": "1969519",
    "end": "1975519"
  },
  {
    "text": "monitoring tools all right so when you schedule a pod",
    "start": "1975519",
    "end": "1980640"
  },
  {
    "text": "qubit will eventually ask docker to run a post container and when docker receives the requests it will try to",
    "start": "1980640",
    "end": "1986880"
  },
  {
    "text": "parse the image name and will inevitably trigger our u-probe on the parts normalized name function at this point",
    "start": "1986880",
    "end": "1993919"
  },
  {
    "text": "our program overrides the image name and docker will realize that the docker",
    "start": "1993919",
    "end": "1998960"
  },
  {
    "text": "image gear and pose does not exist locally so it will try to pull it from its",
    "start": "1998960",
    "end": "2004000"
  },
  {
    "text": "configured registries and if docker hub is one of them it will be able to pull the image and eventually start the rogue",
    "start": "2004000",
    "end": "2010320"
  },
  {
    "text": "container now we had to deal with um another tiny issue and we might have multiple",
    "start": "2010320",
    "end": "2016559"
  },
  {
    "text": "instances of the rogue container so we need to be able to control them through the rootkits so they do not all mine",
    "start": "2016559",
    "end": "2023279"
  },
  {
    "text": "crypto at the same time and to do so we implemented a local api to communicate with the red kit so that",
    "start": "2023279",
    "end": "2030159"
  },
  {
    "text": "the rogue container can talk with um i mean talk to the worker and and know what to do so to send a request to the",
    "start": "2030159",
    "end": "2036640"
  },
  {
    "text": "recruit you simply need to make a status call on the file with a very specific pattern",
    "start": "2036640",
    "end": "2042480"
  },
  {
    "text": "and here the request will simply be a ping and yeah the briquette will insert the",
    "start": "2042480",
    "end": "2048000"
  },
  {
    "text": "action that this specific instance of the post container should execute all right so let's um let's see it in",
    "start": "2048000",
    "end": "2055280"
  },
  {
    "text": "action okay so on the left again as usual this",
    "start": "2055280",
    "end": "2061280"
  },
  {
    "text": "is two shells connected to the instance on aws and on the right this is my local shuttle",
    "start": "2061280",
    "end": "2068158"
  },
  {
    "text": "so first let's start by listing all the images uh local i mean that are um on the host locally so you can see it's",
    "start": "2068159",
    "end": "2074398"
  },
  {
    "text": "mostly community stuff and a ubuntu image then let's schedule a new deployment",
    "start": "2074399",
    "end": "2080320"
  },
  {
    "text": "and this deployment is basically made just of one pod which is a postgres container",
    "start": "2080320",
    "end": "2086720"
  },
  {
    "text": "all right so we need to wait a little bit for the container to be downloaded since a postgres",
    "start": "2086720",
    "end": "2092398"
  },
  {
    "text": "container is usually quite big all right here we go so now the postgas container is running so if you look at",
    "start": "2092399",
    "end": "2098560"
  },
  {
    "text": "the different containers you can see that there is a pose container of our postgres pod",
    "start": "2098560",
    "end": "2104160"
  },
  {
    "text": "and this is the normal pose container great so now what i want to do is um",
    "start": "2104160",
    "end": "2110480"
  },
  {
    "text": "change i mean uninstall the deployment so that we can do this again but with the rootkit",
    "start": "2110480",
    "end": "2116960"
  },
  {
    "text": "so let's start the rootkit inside the container so this is a new docker container with all the the access we",
    "start": "2116960",
    "end": "2122320"
  },
  {
    "text": "talked about and on the right i'm going to configure the mechanism that i talked about before",
    "start": "2122320",
    "end": "2127680"
  },
  {
    "text": "so first what you want to do is know which post container is currently used by the cluster so keep in mind that",
    "start": "2127680",
    "end": "2134160"
  },
  {
    "text": "different communities versions or different clusters can run different post containers so it's not always going to be gates.gcr.io.pose",
    "start": "2134160",
    "end": "2142119"
  },
  {
    "text": "the next thing i want to do is i want to configure the rootkit to tell what action i mean to tell the word container",
    "start": "2142240",
    "end": "2147839"
  },
  {
    "text": "what action to take um when that road container starts so ping0 will simply mean um answer that the container the",
    "start": "2147839",
    "end": "2154960"
  },
  {
    "text": "post container should behave as any normal pose container then what you want to do is override the",
    "start": "2154960",
    "end": "2162079"
  },
  {
    "text": "post container as seen in the list before with our vogue pose container",
    "start": "2162079",
    "end": "2167440"
  },
  {
    "text": "perfect so now let's go back to our host and schedule a new deployment",
    "start": "2167440",
    "end": "2173838"
  },
  {
    "text": "all right so let's list the different parts to make sure that the pad is actually starting here you go and if you look at",
    "start": "2178400",
    "end": "2185280"
  },
  {
    "text": "the containers this time you'll see the postgres container but you will also see our own rogue post",
    "start": "2185280",
    "end": "2191040"
  },
  {
    "text": "container um which is the post container for the postgresql",
    "start": "2191040",
    "end": "2196640"
  },
  {
    "text": "great so let's uninstall the the web app again and try to play with the ping",
    "start": "2196640",
    "end": "2202160"
  },
  {
    "text": "parameter and so instead of saying zero this time we are going to say one so what one means is crush the pod",
    "start": "2202160",
    "end": "2209520"
  },
  {
    "text": "um so what it will do is simply crush the pose container and what's interesting is that we will see how",
    "start": "2209520",
    "end": "2215119"
  },
  {
    "text": "kubernetes behaves and we will try to you know look for um hints that will tell you why your",
    "start": "2215119",
    "end": "2222079"
  },
  {
    "text": "postgres container is in crashlock backup so you might want for example to describe the pos the postgres container",
    "start": "2222079",
    "end": "2231200"
  },
  {
    "text": "sorry the podcast put and what you can see is there is one specific log line that will tell you that a container",
    "start": "2232000",
    "end": "2237280"
  },
  {
    "text": "cannot start but you don't really know what it is and more definitely most definitely you do not see the the pose",
    "start": "2237280",
    "end": "2242800"
  },
  {
    "text": "name and if you look at the result count from collected by communities as you can see it's associated with postgres instead of",
    "start": "2242800",
    "end": "2250160"
  },
  {
    "text": "the post container so this makes debugging even harder for administrators",
    "start": "2250160",
    "end": "2256079"
  },
  {
    "text": "all right so now um we are going to stop the crash loop and we are going to change the ping 1 into",
    "start": "2256079",
    "end": "2262240"
  },
  {
    "text": "ping 2 and what ping 2 does is simulate a crypto miner",
    "start": "2262240",
    "end": "2267760"
  },
  {
    "text": "so as you can see once i send the ping to miner eventually",
    "start": "2267760",
    "end": "2274079"
  },
  {
    "text": "you'll have the post process that is using a lot of cpu um again the the word kit has the",
    "start": "2274079",
    "end": "2279760"
  },
  {
    "text": "ability to hide processes so we left it here so that we can see it for the demo but we could also",
    "start": "2279760",
    "end": "2285920"
  },
  {
    "text": "hide this process so that you can be using a lot of resources without anyone being able to know about it",
    "start": "2285920",
    "end": "2293040"
  },
  {
    "text": "all right that's all for our container breakouts i hope you had fun and i will hand it over to you silvan so that you",
    "start": "2295040",
    "end": "2300960"
  },
  {
    "text": "can present detection and mitigation strategies so how can we detect and protect",
    "start": "2300960",
    "end": "2306079"
  },
  {
    "text": "ourselves from this kind of root kit we should do this at different levels first if a vendor provided you with ebpf",
    "start": "2306079",
    "end": "2312640"
  },
  {
    "text": "programs you should go through an audit and assessment phase of their programs strong chances are that the code has to",
    "start": "2312640",
    "end": "2318320"
  },
  {
    "text": "be gpl as it probably uses some internal kernel symbols so you can ask for it",
    "start": "2318320",
    "end": "2323760"
  },
  {
    "text": "what should you be looking for well the program types that are used the ebpf elements they use the communication",
    "start": "2323760",
    "end": "2329760"
  },
  {
    "text": "through maps between programs may indicate a potential risk in the case the vendor program is compromised we",
    "start": "2329760",
    "end": "2336000"
  },
  {
    "text": "developed a tool to assist in this auditing phase by inspecting the health files containing the ebpf programs it is",
    "start": "2336000",
    "end": "2343040"
  },
  {
    "text": "able to list the entities programs and maps and compute a graph of the interactions between them",
    "start": "2343040",
    "end": "2350320"
  },
  {
    "text": "so the tool has run on our rootkit with the following result we can identify on the graph that the xdp program is",
    "start": "2350320",
    "end": "2356960"
  },
  {
    "text": "storing information into a map that is also used by some key probes which corresponds to the control and command",
    "start": "2356960",
    "end": "2362640"
  },
  {
    "text": "capabilities of the rootkit it is also possible to mitigate at runtime the loading of such programs by",
    "start": "2362640",
    "end": "2369440"
  },
  {
    "text": "monitoring costs to the bpfc's goals and log the usage of it it would even be possible to protect the bpfc scope by",
    "start": "2369440",
    "end": "2376560"
  },
  {
    "text": "either restricting calls to it only to some trusted processes or",
    "start": "2376560",
    "end": "2381760"
  },
  {
    "text": "have the programs inspected before loading and rejecting if they contain suspicious patterns or make use of some",
    "start": "2381760",
    "end": "2387200"
  },
  {
    "text": "dangerous helpers we could also compute and validate the signature of the programs before",
    "start": "2387200",
    "end": "2393119"
  },
  {
    "text": "learning an initiative exists to add this verification logic to the kernel itself",
    "start": "2393119",
    "end": "2400000"
  },
  {
    "text": "using tls everywhere for network traffic that also helps mitigating the risk of rogue bpf programs that may intercept",
    "start": "2400000",
    "end": "2407040"
  },
  {
    "text": "network data now if we were not able to block the loading of such a rid kit how difficult",
    "start": "2407040",
    "end": "2413599"
  },
  {
    "text": "would it be to detect its presence even if it's possible though very challenging to write an almost perfect",
    "start": "2413599",
    "end": "2419520"
  },
  {
    "text": "epf rootkit we should concentrate on the action that the rootkit would have to either block or lie about the results of",
    "start": "2419520",
    "end": "2425680"
  },
  {
    "text": "such actions for instance or would you disable the loading of kernel module",
    "start": "2425680",
    "end": "2430800"
  },
  {
    "text": "because such modules have the ability to list the ebf programs and the active k",
    "start": "2430800",
    "end": "2436079"
  },
  {
    "text": "verbs now let's imagine that we insert a module that executes specific actions",
    "start": "2436079",
    "end": "2441839"
  },
  {
    "text": "known only to us the blocking of the module by the rootkit would then be easy to detect",
    "start": "2441839",
    "end": "2447839"
  },
  {
    "text": "monitoring the network traffic at the infrastructure level could help detect hijacked connections or a strange packet",
    "start": "2447839",
    "end": "2453599"
  },
  {
    "text": "with transmission our our key being far from complete and far from perfect it should be relatively",
    "start": "2453599",
    "end": "2459760"
  },
  {
    "text": "easy to detect it that being said we hope it will bring to light the potential and the risk of vpn baseball",
    "start": "2459760",
    "end": "2466079"
  },
  {
    "text": "kit while presenting some interesting techniques so the code of both the rootkit and the",
    "start": "2466079",
    "end": "2472800"
  },
  {
    "text": "monitor is available at these urls or will be published in the next few days please have a look",
    "start": "2472800",
    "end": "2478240"
  },
  {
    "text": "thank you for your attention and have a great blackout conference",
    "start": "2478240",
    "end": "2483200"
  }
]