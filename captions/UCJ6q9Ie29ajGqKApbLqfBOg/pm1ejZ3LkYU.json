[
  {
    "start": "0",
    "end": "437000"
  },
  {
    "text": "[Music]",
    "start": "3860",
    "end": "16640"
  },
  {
    "text": "hi and welcome to black investment in secure kennel we are sergeant daniel kim security researchers from the msrc",
    "start": "16640",
    "end": "23119"
  },
  {
    "text": "and we are very excited to share with you today our story about how to insecure kernel to offensive research we have so much to cover today we are",
    "start": "23119",
    "end": "29840"
  },
  {
    "text": "going to see the shortest introduction ever to the architecture of vsm and the secure kernel then we are going to talk about two of",
    "start": "29840",
    "end": "35200"
  },
  {
    "text": "the vulnerabilities that we found bought by fuzzing anime statically auditing the code and we're going to have some fun and again i'll be record",
    "start": "35200",
    "end": "41280"
  },
  {
    "text": "execution in the secure channel by exploiting both of those vulnerabilities and then of course some takeaways what",
    "start": "41280",
    "end": "46559"
  },
  {
    "text": "you can take from this talk in order to kick off your own secure camera resource at home and what we can take from this talk is",
    "start": "46559",
    "end": "51840"
  },
  {
    "text": "microsoft in order to improve the security in our products so without any further ado let's talk",
    "start": "51840",
    "end": "57280"
  },
  {
    "text": "about vbs so with the new architecture of windows 10 and vbs we use virtualization in order to enforce isolation",
    "start": "57280",
    "end": "63280"
  },
  {
    "text": "and restrictions in the operating system this m introduces vtls which are virtual trust levels",
    "start": "63280",
    "end": "68560"
  },
  {
    "text": "which we use in order to isolate the operating system into different isolated security contexts",
    "start": "68560",
    "end": "75040"
  },
  {
    "text": "as for today we have two btls we have vtl0 for the normal world and we tell one for the secured",
    "start": "75040",
    "end": "80080"
  },
  {
    "text": "in the normal world kernel space we have endless kernel just as you know it and we can call it now the normal kernel and in the normal",
    "start": "80080",
    "end": "86720"
  },
  {
    "text": "world user space you have your own user space you know a few programs either etc in a secure world we keep all of the",
    "start": "86720",
    "end": "92400"
  },
  {
    "text": "most privileges and trusted components which we really want to protect and isolate from the normal load",
    "start": "92400",
    "end": "97520"
  },
  {
    "text": "so we actually assume here that attackers already gained redux primitives in the normal world kernel space",
    "start": "97520",
    "end": "102640"
  },
  {
    "text": "and we want to restrict them as much as possible and all of that has been managed by hyper-v so you have end of scanners in ring zero",
    "start": "102640",
    "end": "109759"
  },
  {
    "text": "vtl0 you have a secure kernel runs in ring zero one and hyper-v exposes two hyper chords for",
    "start": "109759",
    "end": "115360"
  },
  {
    "text": "normal calls and secure calls which are services provided by each kernel to the audio the",
    "start": "115360",
    "end": "120640"
  },
  {
    "text": "normal kernel clearly needs many services from the secure kernel for all of the most privileged functionalities",
    "start": "120640",
    "end": "125680"
  },
  {
    "text": "it can no longer do a secure kernel still needs many services from the normal kernel because most of the functionalities actually",
    "start": "125680",
    "end": "132080"
  },
  {
    "text": "remained in the normal kernel because we really want to keep the secure kernel as small as possible in order to decrease",
    "start": "132080",
    "end": "138080"
  },
  {
    "text": "its attack surface okay now the hypervisor exposes hyper calls for the for the secure kernel to restrict vtl0",
    "start": "138080",
    "end": "144800"
  },
  {
    "text": "and the secure canal uses the cyber calls in order to restrict vtl0 access to the both of the physical",
    "start": "144800",
    "end": "150319"
  },
  {
    "text": "addresses and the system registers this is exactly what let us create great mitigations such as hvci",
    "start": "150319",
    "end": "156480"
  },
  {
    "text": "which means that all of the pages that are marked as executable in a retail zero ept have to be signed it's mean that we can",
    "start": "156480",
    "end": "162640"
  },
  {
    "text": "hide secrets in a secure world user space and mark all of those pages as unreadable to vtl0",
    "start": "162640",
    "end": "168560"
  },
  {
    "text": "and clearly compromise of eater one of the secure kernel or of the hypervisor bypasses those mitigations and break the",
    "start": "168560",
    "end": "175120"
  },
  {
    "text": "model guarantees and this is the motivation for this research okay so our story begins with a great",
    "start": "175120",
    "end": "181599"
  },
  {
    "text": "steamwork daniel what an amazing father called hypersid its main purpose was to fuss the hypercalls interface exposed by hyper-v",
    "start": "181599",
    "end": "188480"
  },
  {
    "text": "i really encourage you to catch this talk by sean and daniel from offensive con 2019 it was absolutely amazing they found",
    "start": "188480",
    "end": "194000"
  },
  {
    "text": "many issues in hyper-v and when i joined the team i just saw this incredible work and i think daniel and i",
    "start": "194000",
    "end": "199680"
  },
  {
    "text": "asked him hey do you try to use hyperseed to further secure services interface exposed by the secure kernel",
    "start": "199680",
    "end": "205120"
  },
  {
    "text": "because this interface is actually very similar to the hypercalls interface exposed by hyperv and two weeks later daniel here just got",
    "start": "205120",
    "end": "211680"
  },
  {
    "text": "back to me with hey i i just found five different bugs with zero to retl one it was absolutely amazing",
    "start": "211680",
    "end": "218000"
  },
  {
    "text": "it moved to us there is still much to cover in this area so we teamed up we found more bugs and now we have a good",
    "start": "218000",
    "end": "223440"
  },
  {
    "text": "story to tell no bugs are really interesting if we can exploit them so let's talk about exploitation and",
    "start": "223440",
    "end": "230640"
  },
  {
    "text": "before we start to do this classic circle of life let's stop four minutes and ask ourselves what we can do",
    "start": "230640",
    "end": "236799"
  },
  {
    "text": "assuming that we gain read write primitives in ring zero vtl1 and in order to answer this question we",
    "start": "236799",
    "end": "242400"
  },
  {
    "text": "really need to talk about mitigations because as you know we have great mitigations in the normal kernel",
    "start": "242400",
    "end": "247519"
  },
  {
    "text": "but unfortunately not all of those mitigations made their way into the secure caramel for instance the",
    "start": "247519",
    "end": "253120"
  },
  {
    "text": "secure kernel image binary does go through randomization on every boot but there are still many hard coded addresses we don't have c5 and",
    "start": "253120",
    "end": "259919"
  },
  {
    "text": "unfortunately we don't have stat enforcement which is one of the key features of vbs so let's begin here all of those",
    "start": "259919",
    "end": "266080"
  },
  {
    "text": "addresses are hard coded in a secure kernel there are even more addresses which aren't hardcoded but they are still can",
    "start": "266080",
    "end": "272320"
  },
  {
    "text": "be predicted because because of the so predictable and deterministic boot process of the secure kernel i really want you",
    "start": "272320",
    "end": "279520"
  },
  {
    "text": "to take a closer look into this shell page vtl0 mapping this is a very special page as it's a one-to-one mapping of the",
    "start": "279520",
    "end": "286560"
  },
  {
    "text": "shared page from vtl0 to this fixed virtual address in vtl1 and therefore every byte that you write",
    "start": "286560",
    "end": "292720"
  },
  {
    "text": "through the shared page in vtl0 simply appears this fixed virtual address space in a secure kernel",
    "start": "292720",
    "end": "298479"
  },
  {
    "text": "this introduces a great exploitation permittive of control content at known address which we usually need to invest some",
    "start": "298479",
    "end": "304960"
  },
  {
    "text": "time before we can gain such a primitive and there is the pc of that in the first debugger which is attached to in the",
    "start": "304960",
    "end": "310560"
  },
  {
    "text": "scanner we just write arbitrary value in a second debugger which is which is attached to the secure canon we just",
    "start": "310560",
    "end": "316320"
  },
  {
    "text": "read this value and everything works great okay let's talk about flat enforcement in our model we only have ept",
    "start": "316320",
    "end": "323199"
  },
  {
    "text": "enforcement on lower videos from higher ones this is exactly how we implemented mitigations such as hvci conditional",
    "start": "323199",
    "end": "330000"
  },
  {
    "text": "guard and etc but this means that the secure kernel being the most higher vtl that we have",
    "start": "330000",
    "end": "335680"
  },
  {
    "text": "today isn't ept enforced which means that the pte in vtl1 have the final say this actually",
    "start": "335680",
    "end": "342400"
  },
  {
    "text": "tells us that given a the arbitrary right primitive in a secure kernel we just can create read write execute",
    "start": "342400",
    "end": "349280"
  },
  {
    "text": "chunk of memory in the secure kernel and we don't even need a red primitive for that because the pt",
    "start": "349280",
    "end": "354880"
  },
  {
    "text": "is best is fixed okay this is super interesting and just actually raises another question what about xox",
    "start": "354880",
    "end": "361360"
  },
  {
    "text": "because as as we know many researchers found several addresses that were marked as both writable and",
    "start": "361360",
    "end": "367120"
  },
  {
    "text": "executable in the vtl zero ptes and this is actually fine because",
    "start": "367120",
    "end": "372240"
  },
  {
    "text": "hdcis does a great job of mitigating this by state enforcement but",
    "start": "372240",
    "end": "379039"
  },
  {
    "text": "if we could find this pattern the same behavior in vtl1 then we really have something here and indeed we found four different",
    "start": "379039",
    "end": "385520"
  },
  {
    "text": "addresses in vtl1 that were marked as both writable and executable in the ptes",
    "start": "385520",
    "end": "391360"
  },
  {
    "text": "we fixed them all by now of course but this is just another great value of this research okay let's talk about setup setup is",
    "start": "391360",
    "end": "397919"
  },
  {
    "text": "super important we chose to use hyperc it's super convenient we can write all of the plcs and experts in user space",
    "start": "397919",
    "end": "403520"
  },
  {
    "text": "and we have our own kernel switch driver which wraps all of the secure cores for us if you don't want to go through all of this",
    "start": "403520",
    "end": "409440"
  },
  {
    "text": "troubles you can simply debug endoscope breakpoint on key functions and patch the registers in memory in runtime to trigger certain flows in the",
    "start": "409440",
    "end": "416560"
  },
  {
    "text": "secure kernel we don't ship the secure kernel release binaries with the debugger compiled in",
    "start": "416560",
    "end": "421840"
  },
  {
    "text": "but you can still achieve that and your machine is at home by using nested virtualization kvm qmu",
    "start": "421840",
    "end": "427440"
  },
  {
    "text": "many researchers are doing that here are some links that you can follow and now with this new spirit let's go",
    "start": "427440",
    "end": "432639"
  },
  {
    "text": "over to daniel which will tell us about the first vulnerability and the first extract",
    "start": "432639",
    "end": "438000"
  },
  {
    "start": "437000",
    "end": "780000"
  },
  {
    "text": "thanks sar for the introduction i am daniel now let me walk you through the first vulnerability and exploit in this talk",
    "start": "438000",
    "end": "446160"
  },
  {
    "text": "we will discuss two vulnerabilities they are very different from each other the only common part is that",
    "start": "446160",
    "end": "452639"
  },
  {
    "text": "they are in the same function the vulnerable function is named as km",
    "start": "452639",
    "end": "457680"
  },
  {
    "text": "obtain hot patch undo table it is a long name but you can tell it is related to the",
    "start": "457680",
    "end": "463599"
  },
  {
    "text": "hot patch implementation the function obtains an undo table this",
    "start": "463599",
    "end": "468639"
  },
  {
    "text": "table describes addresses that will be affected by reverting a hot patch",
    "start": "468639",
    "end": "474000"
  },
  {
    "text": "the first vulnerability is the autobahn right it is found by fuzzing with hyperseed",
    "start": "474000",
    "end": "479919"
  },
  {
    "text": "the second vulnerability is related to mdl and mapping it is found by source code review generally",
    "start": "479919",
    "end": "488080"
  },
  {
    "text": "secure calls use transfer mdl to transfer data from vtl0 the entos world to vtr1 to",
    "start": "488080",
    "end": "494800"
  },
  {
    "text": "secureworld those transfer mdios are fully controlled from vtl0",
    "start": "494800",
    "end": "500639"
  },
  {
    "text": "here in this vulnerable function in vtr1 it will first map the transfer mdl to vtr1 address",
    "start": "500639",
    "end": "507759"
  },
  {
    "text": "space it then construct a new mdl and initialize it with the content",
    "start": "507759",
    "end": "513440"
  },
  {
    "text": "stored in transfer mdl at last it will unmip and clean up this mdl the",
    "start": "513440",
    "end": "520000"
  },
  {
    "text": "security guideline here is to sanitize our refuels at rate from vtr0",
    "start": "520000",
    "end": "525760"
  },
  {
    "text": "including the bad count field in transfer ambia this is where the first vulnerability",
    "start": "525760",
    "end": "533360"
  },
  {
    "text": "this code snippet shows the first vulnerability the bad count field passed from the vtr0",
    "start": "533360",
    "end": "540560"
  },
  {
    "text": "can be any value and it will be used as the allocation length for the newly allocated",
    "start": "540560",
    "end": "546480"
  },
  {
    "text": "andu mdr and do mdr should be at least 48 bytes as an instance of mdl data structure",
    "start": "546480",
    "end": "554080"
  },
  {
    "text": "guess what will happen if bad count is smaller than 48 yeah you're right outer bound right will",
    "start": "554080",
    "end": "561680"
  },
  {
    "text": "happen let's see the mdl data structure layout it represents information for a buffer",
    "start": "561680",
    "end": "568800"
  },
  {
    "text": "in physical memory it consists of two parts the fixed title and the wearable pfn array the fixed",
    "start": "568800",
    "end": "576560"
  },
  {
    "text": "title occupies the first 48 bytes and contains several important",
    "start": "576560",
    "end": "581680"
  },
  {
    "text": "fields next is a pointer to another mdl in this way several mdls can be chained together",
    "start": "581680",
    "end": "588880"
  },
  {
    "text": "into a singularly linked list and as list size is the total length of the whole data",
    "start": "588880",
    "end": "595200"
  },
  {
    "text": "structure mapped system va points to the buffer after getting mapped into the address",
    "start": "595200",
    "end": "602000"
  },
  {
    "text": "space bad count is the length of the buffer",
    "start": "602000",
    "end": "607040"
  },
  {
    "text": "transfer mdl describes a piece of buffer transferred from vtl0 to vtr1",
    "start": "607120",
    "end": "612959"
  },
  {
    "text": "here the transfer buffer happened to be another mdr instance the vulnerable function guides the bad",
    "start": "612959",
    "end": "619440"
  },
  {
    "text": "count as the transfer buffer lens and allocate a new and dual mdr with the",
    "start": "619440",
    "end": "624640"
  },
  {
    "text": "same lines if we specify the bat count to be 16",
    "start": "624640",
    "end": "629680"
  },
  {
    "text": "then a 16 bytes sequence will be allocated for the undo mdl",
    "start": "629680",
    "end": "636560"
  },
  {
    "text": "here i only discussed the situation that undo mdl is allocated in we are skip i will explain the reason",
    "start": "636560",
    "end": "644320"
  },
  {
    "text": "later we can see that the next full allocation is also shown here",
    "start": "644320",
    "end": "649519"
  },
  {
    "text": "in blue color with 16 bytes we as chunk header the transfer mdr",
    "start": "649519",
    "end": "656399"
  },
  {
    "text": "gets mapped into the vtr1 address space then mapped system va can be used to",
    "start": "656399",
    "end": "662800"
  },
  {
    "text": "access the transfer buffer directly we call this transfer buffer the original mdl",
    "start": "662800",
    "end": "669200"
  },
  {
    "text": "original mdl is also fully controlled from vtl0",
    "start": "669200",
    "end": "674480"
  },
  {
    "text": "the undo mdr will be initialized according to the original mdl now we see how the auto bound right",
    "start": "674480",
    "end": "681680"
  },
  {
    "text": "happen when calling mm initialize mdl the next pool allocation will be",
    "start": "681680",
    "end": "687279"
  },
  {
    "text": "operated with the original mdl the overwriting capability is 16 bytes we see that the wii as trunk",
    "start": "687279",
    "end": "695519"
  },
  {
    "text": "hider is still intact after the override which is very good for exploitation",
    "start": "695519",
    "end": "701279"
  },
  {
    "text": "since this override won't be detected by pull system",
    "start": "701279",
    "end": "706640"
  },
  {
    "text": "if we try the poc for the first vulnerability we will see the typical back type caused",
    "start": "706640",
    "end": "712320"
  },
  {
    "text": "by access violation and we will see the gsod for windows insider build",
    "start": "712320",
    "end": "718639"
  },
  {
    "text": "the fix for the first vulnerability is also straightforward stop further precising if bad count is",
    "start": "718639",
    "end": "724560"
  },
  {
    "text": "smaller than 48 the fix is more intuitive by comparing other pro cfgs",
    "start": "724560",
    "end": "732560"
  },
  {
    "text": "what can we do with this upgrade right to the vtr1 world sar has some considerable insight this",
    "start": "732560",
    "end": "739360"
  },
  {
    "text": "is all what a hiker need let me show you why",
    "start": "739360",
    "end": "745120"
  },
  {
    "text": "now i have the capability to overwrite the neighbor pool allocation what should i do first yes i should",
    "start": "745120",
    "end": "752880"
  },
  {
    "text": "select a good neighbor to be the overwritten victim since i am already familiar with mdl",
    "start": "752880",
    "end": "759040"
  },
  {
    "text": "data structure why not choose another mdl as the neighbor",
    "start": "759040",
    "end": "764079"
  },
  {
    "text": "we can overwrite the first 16 bytes of the victim mdl including the next pointer size and",
    "start": "764079",
    "end": "771440"
  },
  {
    "text": "flags the inertial primitive is ready and seems promising",
    "start": "771440",
    "end": "776959"
  },
  {
    "text": "let me show you more essential backgrounds for the final exploit let me introduce the skpg context a",
    "start": "776959",
    "end": "784000"
  },
  {
    "text": "little bit it is a core data structure used for secure kernel hyper guard",
    "start": "784000",
    "end": "789600"
  },
  {
    "text": "we already know that its address is predictable a very good stable target i should take",
    "start": "789600",
    "end": "795680"
  },
  {
    "text": "advantage of this fact that request some interesting fields in it including two callback routine",
    "start": "795680",
    "end": "801920"
  },
  {
    "text": "function pointers i have to be very cautious since it is self-protected",
    "start": "801920",
    "end": "808800"
  },
  {
    "text": "there is an embedded timer in it the timer routine will be invoked when due time comes",
    "start": "808800",
    "end": "814639"
  },
  {
    "text": "the timer routine will trigger the runtime charge routine the later will verify the data integrity",
    "start": "814639",
    "end": "820800"
  },
  {
    "text": "of the whole data structure it will fast fail if anything wrong",
    "start": "820800",
    "end": "826399"
  },
  {
    "text": "corrupting any fields of skpg context will be noticed by the runtime check routine",
    "start": "826399",
    "end": "832240"
  },
  {
    "text": "except those two callback pointers in fact if i replace one of those two function",
    "start": "832240",
    "end": "838079"
  },
  {
    "text": "pointers the whole self protection is bypassed those two callback pointers are good",
    "start": "838079",
    "end": "844639"
  },
  {
    "text": "candidates for redirecting control flow to shell code i have mentioned secure kernel pool now",
    "start": "844639",
    "end": "851920"
  },
  {
    "start": "849000",
    "end": "904000"
  },
  {
    "text": "let's take a closer look secure kernel use segment heap which is typically",
    "start": "851920",
    "end": "857199"
  },
  {
    "text": "comprised of wearable size heap and low fragmentation keep in weight as heap allocations of",
    "start": "857199",
    "end": "864320"
  },
  {
    "text": "different sizes are put together side by side in rfh keep",
    "start": "864320",
    "end": "869360"
  },
  {
    "text": "allocations of the same size are put together and allocations of different sizes",
    "start": "869360",
    "end": "874399"
  },
  {
    "text": "are separated from each other in secure kernel the tag and prototype arguments are",
    "start": "874399",
    "end": "880079"
  },
  {
    "text": "ignored pools are always allocated in page 4. since undo mdl is 16 bytes well i cannot",
    "start": "880079",
    "end": "887920"
  },
  {
    "text": "make the victim mdl smaller than 48 bytes if i want to put them together",
    "start": "887920",
    "end": "893760"
  },
  {
    "text": "i have to use the we asked keep during the exploitation the main challenge here is in secure",
    "start": "893760",
    "end": "900399"
  },
  {
    "text": "world there is too few allocations i create",
    "start": "900399",
    "end": "906079"
  },
  {
    "start": "904000",
    "end": "948000"
  },
  {
    "text": "two and debug javascript extensions to help dump out the rfh and we asked keep",
    "start": "906079",
    "end": "912480"
  },
  {
    "text": "layout you don't need to understand the meaning of i refuse here i just want to show you",
    "start": "912480",
    "end": "917760"
  },
  {
    "text": "how scars the pull allocations are in secure world by default in the upper screenshot only 15 after",
    "start": "917760",
    "end": "926519"
  },
  {
    "text": "129 out of each buckets are activated they are highlighted in write in the",
    "start": "926519",
    "end": "932800"
  },
  {
    "text": "lower screenshot only 22 segments used in the vs heap",
    "start": "932800",
    "end": "937920"
  },
  {
    "text": "each segment ranges from 16 to 64 pages the fewer the poor allocations",
    "start": "937920",
    "end": "945040"
  },
  {
    "text": "the lesser possibility for push shipping for good push shipping i have to find",
    "start": "945040",
    "end": "950240"
  },
  {
    "start": "948000",
    "end": "1019000"
  },
  {
    "text": "out a persistent uncontrollable pool allocation create secure image",
    "start": "950240",
    "end": "955279"
  },
  {
    "text": "sql call can be used for this purpose it can allocate up to resized pool allocations the",
    "start": "955279",
    "end": "962079"
  },
  {
    "text": "minimal allocation size is 48 bytes a handle to each create",
    "start": "962079",
    "end": "967360"
  },
  {
    "text": "secure image is returned to the vtl0 closing this handle will free the",
    "start": "967360",
    "end": "972720"
  },
  {
    "text": "corresponding secure image allocation i can use this allocation to make holes",
    "start": "972720",
    "end": "978079"
  },
  {
    "text": "of 16 bytes another sql core level start will allocate a list of mdls",
    "start": "978079",
    "end": "985199"
  },
  {
    "text": "with controllable mdl size those mdls are good candidates for being victim mdl",
    "start": "985199",
    "end": "993519"
  },
  {
    "text": "there are two challenges here during push shipping first there is a guard page after each we ask",
    "start": "993519",
    "end": "999600"
  },
  {
    "text": "heap segment if the undo mdl is allocated at the end of this segment it will corrupt the",
    "start": "999600",
    "end": "1006959"
  },
  {
    "text": "guard page and call spark check second i cannot make too much allocations of the sim",
    "start": "1006959",
    "end": "1012480"
  },
  {
    "text": "size otherwise it will activate rfh bucket if a word threshold",
    "start": "1012480",
    "end": "1019759"
  },
  {
    "start": "1019000",
    "end": "1069000"
  },
  {
    "text": "this is how i do the shipping i have pasted some persons groups here",
    "start": "1019759",
    "end": "1024798"
  },
  {
    "text": "for reference first i make two series of push pull allocations which create secure",
    "start": "1024799",
    "end": "1031438"
  },
  {
    "text": "image sequel calls of different sizes a and b",
    "start": "1031439",
    "end": "1036839"
  },
  {
    "text": "repeatedly then i replace all of the b allocations with the left amp mdl of the",
    "start": "1036839",
    "end": "1042720"
  },
  {
    "text": "same size then i replace all of the a allocations",
    "start": "1042720",
    "end": "1047760"
  },
  {
    "text": "with smaller d allocations making 32 bytes holes which is suitable for undo mdr including",
    "start": "1047760",
    "end": "1054960"
  },
  {
    "text": "the wii as trunk hide further undo mdr allocation will be",
    "start": "1054960",
    "end": "1060080"
  },
  {
    "text": "allocated in these holes and cropped the neighbor left amp mdr with the first",
    "start": "1060080",
    "end": "1066799"
  },
  {
    "text": "vulnerability ascii laptop start this sequel call will",
    "start": "1066799",
    "end": "1072799"
  },
  {
    "start": "1069000",
    "end": "1091000"
  },
  {
    "text": "allocate a list of mdios and change them into the singularly linked list",
    "start": "1072799",
    "end": "1078320"
  },
  {
    "text": "ascii lab dump at buffer this sequel call will try to allocate a target mdl from the s list and right",
    "start": "1078320",
    "end": "1086080"
  },
  {
    "text": "to the pfn array at the end of of that mdl",
    "start": "1086080",
    "end": "1091840"
  },
  {
    "start": "1091000",
    "end": "1268000"
  },
  {
    "text": "left arm context is a global symbol it contains a pointer to the as list",
    "start": "1091840",
    "end": "1098160"
  },
  {
    "text": "pages added in the livedam context determines where to write to when calling livedump at buffer but",
    "start": "1098160",
    "end": "1105679"
  },
  {
    "text": "count in each mdr determines its capacity after filling up its capacity the",
    "start": "1105679",
    "end": "1111360"
  },
  {
    "text": "writing cursor will be moved to the next mdl in s list the calculation of writing cursor is",
    "start": "1111360",
    "end": "1118320"
  },
  {
    "text": "demonstrated here with this pseudocode with the push shipping approach i discussed",
    "start": "1118320",
    "end": "1124960"
  },
  {
    "text": "it is possible to make the level amdial the victim amdia and allocate it after the andu mdl",
    "start": "1124960",
    "end": "1132720"
  },
  {
    "text": "trigger the outer boundary will modify the next pointer of the victim mdl as list will be",
    "start": "1132720",
    "end": "1139120"
  },
  {
    "text": "diverted to a powered mdl under our control if we make the power",
    "start": "1139120",
    "end": "1145440"
  },
  {
    "text": "time they are in the shared memory which is readable from vtl0 we can fully control its content",
    "start": "1145440",
    "end": "1152000"
  },
  {
    "text": "including the next pointer and bad count this modification will be reflected",
    "start": "1152000",
    "end": "1157360"
  },
  {
    "text": "to the vtr1 in real time which can be used for repetitive adjustment of the next",
    "start": "1157360",
    "end": "1163840"
  },
  {
    "text": "pointer and overwrite to obturary address but the shared page is read only from",
    "start": "1163840",
    "end": "1171320"
  },
  {
    "text": "vtl1 writing to the piphan array of the powertime dial will backtrack",
    "start": "1171320",
    "end": "1177120"
  },
  {
    "text": "due to the access variation there is a trick here we can modify the bet count to be",
    "start": "1177120",
    "end": "1182720"
  },
  {
    "text": "smaller than page size which makes the power time dials capacity zero",
    "start": "1182720",
    "end": "1188160"
  },
  {
    "text": "and it will be skipped directly to the next mdr",
    "start": "1188160",
    "end": "1193600"
  },
  {
    "text": "now we have fully control of the powered ambiance and we can retarget worker mdl by modifying next pointer",
    "start": "1193600",
    "end": "1200799"
  },
  {
    "text": "we can write to anywhere but we need to know where to mod uh we need to know when to",
    "start": "1200799",
    "end": "1207440"
  },
  {
    "text": "modify the next pointer we use the second shared memory as the worker mdl and detect",
    "start": "1207440",
    "end": "1214080"
  },
  {
    "text": "if its pivot array has been overwritten after we call the left dump add buffer",
    "start": "1214080",
    "end": "1220400"
  },
  {
    "text": "once we detected that the worker mdl has been overwritten we add power time the bad count with",
    "start": "1220400",
    "end": "1227360"
  },
  {
    "text": "page size it makes sure next time we collect a buffer we are still writing to the beginning of",
    "start": "1227360",
    "end": "1234400"
  },
  {
    "text": "the worker mds pfm array in theory we can write to anywhere",
    "start": "1234400",
    "end": "1239600"
  },
  {
    "text": "the only constraint here is the worker mdl bad count should not be smaller than page size",
    "start": "1239600",
    "end": "1246159"
  },
  {
    "text": "otherwise it will be skipped and writing writing will be redirected",
    "start": "1246159",
    "end": "1251200"
  },
  {
    "text": "to its next mdr normally this constituent can be bypassed if we can find some non-zero content",
    "start": "1251200",
    "end": "1258480"
  },
  {
    "text": "before the overwriting target crafting a worker mdr there and adjusting the writing cursor",
    "start": "1258480",
    "end": "1264559"
  },
  {
    "text": "by changing the bad count accordingly you can see i take fully advantage of",
    "start": "1264559",
    "end": "1270880"
  },
  {
    "start": "1268000",
    "end": "1291000"
  },
  {
    "text": "the shared pages i use the first shared memory to craft power to mdl",
    "start": "1270880",
    "end": "1276320"
  },
  {
    "text": "i modify worker mdr repeatedly i use the second shell memory as the tentative",
    "start": "1276320",
    "end": "1282559"
  },
  {
    "text": "overwriting target and determine the good timing to modify the next pointer when the worker mdl has been activated",
    "start": "1282559",
    "end": "1291600"
  },
  {
    "start": "1291000",
    "end": "1332000"
  },
  {
    "text": "after the worker mdr has been activated i can do repeatable red what where where is determined by",
    "start": "1291600",
    "end": "1299200"
  },
  {
    "text": "the next pointer and bad count of the power time here writing cursor is pointing to the",
    "start": "1299200",
    "end": "1304880"
  },
  {
    "text": "operating target what is passed as parameters to the laptop at buffer sql call",
    "start": "1304880",
    "end": "1312080"
  },
  {
    "text": "here i use just one page from number which is exactly one keyword this is the",
    "start": "1312080",
    "end": "1318080"
  },
  {
    "text": "overwriting content trigger the left arm at buffer circle call which will do",
    "start": "1318080",
    "end": "1323760"
  },
  {
    "text": "the final override in this way i can do the red what where trick",
    "start": "1323760",
    "end": "1329039"
  },
  {
    "text": "accurately and repeatedly a little summary here first i cropped",
    "start": "1329039",
    "end": "1335440"
  },
  {
    "start": "1332000",
    "end": "1388000"
  },
  {
    "text": "the next pointer of the mdl get one up to the right then i fake a power time they are in the",
    "start": "1335440",
    "end": "1341919"
  },
  {
    "text": "shared page where i can modify repeatedly from vtr0 by design",
    "start": "1341919",
    "end": "1347360"
  },
  {
    "text": "with this up to write i cropped a node in the livedamp context mdr chain and",
    "start": "1347360",
    "end": "1353440"
  },
  {
    "text": "make it point to the power time dial in shared page call leveldumpadbuffer to trigger the",
    "start": "1353440",
    "end": "1359039"
  },
  {
    "text": "arbitrary write changing the sharp pitch content to adjust the overwriting target call level dump",
    "start": "1359039",
    "end": "1366080"
  },
  {
    "text": "at buffer again to trigger another override with this up to write capability i",
    "start": "1366080",
    "end": "1371919"
  },
  {
    "text": "modified page table entry of the shared page to executable place a piece of shellcode there",
    "start": "1371919",
    "end": "1378480"
  },
  {
    "text": "then i modify the skpgcontextcallbackroutine and jump to the shellcode in this way",
    "start": "1378480",
    "end": "1384960"
  },
  {
    "text": "arbitrary code execution is achieved this is the demo shell code",
    "start": "1384960",
    "end": "1390720"
  },
  {
    "start": "1388000",
    "end": "1415000"
  },
  {
    "text": "it first modifies the skpg context callback routine then it leaks the secure kernel base",
    "start": "1390720",
    "end": "1397520"
  },
  {
    "text": "pointer back to vtr0 through shard page it resets timer",
    "start": "1397520",
    "end": "1402559"
  },
  {
    "text": "configure 5 seconds relative due time shellcode will be invoked every 5 seconds",
    "start": "1402559",
    "end": "1408559"
  },
  {
    "text": "and shellcode is fully controlled from vtl0 and can be refactored for any purpose",
    "start": "1408559",
    "end": "1415120"
  },
  {
    "text": "the first vulnerability was fixed in january 2019. the secular pool then switched to",
    "start": "1415120",
    "end": "1422080"
  },
  {
    "text": "segment heap in the middle of 2019 and the exploit push shipping depends on the",
    "start": "1422080",
    "end": "1428320"
  },
  {
    "text": "segment heap this demo is against build in may 2020 where the first vulnerability has",
    "start": "1428320",
    "end": "1435039"
  },
  {
    "text": "already been fixed a trick to undo the fix is by one debugger command",
    "start": "1435039",
    "end": "1440159"
  },
  {
    "text": "this command will erase the fixed code to not slide so this exploit approach works well on",
    "start": "1440159",
    "end": "1446799"
  },
  {
    "text": "latest build but the vulnerability is already gone no customer will be at risk with this demo",
    "start": "1446799",
    "end": "1453520"
  },
  {
    "text": "since no build is both vulnerable and exploitable here is the demo i have pasted",
    "start": "1453520",
    "end": "1460320"
  },
  {
    "start": "1458000",
    "end": "1587000"
  },
  {
    "text": "screenshots of important output here as background i will play the demo video this video",
    "start": "1460320",
    "end": "1467120"
  },
  {
    "text": "has been edited to look smoothly",
    "start": "1467120",
    "end": "1473840"
  },
  {
    "text": "second kernel debugger is attached here and the fix has been unpatched by the debugger",
    "start": "1475919",
    "end": "1481520"
  },
  {
    "text": "command before the exploit the shared page is filled with zeros rather than the shell code and the",
    "start": "1481520",
    "end": "1488960"
  },
  {
    "text": "shared page is not executable i will play the demo video now",
    "start": "1488960",
    "end": "1495278"
  },
  {
    "text": "i run the first passing script which will do the push shaking place live damp mdr after the hole and",
    "start": "1498240",
    "end": "1505279"
  },
  {
    "text": "trigger the first vulnerability and modify the mdr next pointer it takes some time",
    "start": "1505279",
    "end": "1511039"
  },
  {
    "text": "for the pull shaping then i run the second person script",
    "start": "1511039",
    "end": "1517440"
  },
  {
    "text": "which will detect if the tentative shared memory has been modified or not",
    "start": "1517440",
    "end": "1522640"
  },
  {
    "text": "if it has been modified i can do further actually read what where the third person script",
    "start": "1522640",
    "end": "1529279"
  },
  {
    "text": "will modify the shard page pte to executable and the last person script will redirect",
    "start": "1529279",
    "end": "1535600"
  },
  {
    "text": "the skpg context callback routine to the show code i prepared in the",
    "start": "1535600",
    "end": "1540880"
  },
  {
    "text": "shared page after the due time comes the show code",
    "start": "1540880",
    "end": "1546240"
  },
  {
    "text": "gets executed successfully",
    "start": "1546240",
    "end": "1550158"
  },
  {
    "text": "now the shared page is executable and it is filled with the demo shell",
    "start": "1551440",
    "end": "1558080"
  },
  {
    "text": "code and this piece of shell code is invoked by redirecting the skpg context",
    "start": "1558080",
    "end": "1564000"
  },
  {
    "text": "callback routine and this shellcode will get executed periodically i can",
    "start": "1564000",
    "end": "1571360"
  },
  {
    "text": "modify the shellcode from vtl0 freely at any time for any purpose in this way",
    "start": "1571360",
    "end": "1578240"
  },
  {
    "text": "arbitrary code execution is achieved okay this is my part i will transfer",
    "start": "1578240",
    "end": "1584640"
  },
  {
    "text": "control to star thank you thank you so much daniel for this great analysis and exploit so yeah",
    "start": "1584640",
    "end": "1590480"
  },
  {
    "text": "we fixed this issue and now we make sure that the transfer mdl by country is valid but there's but there is something else",
    "start": "1590480",
    "end": "1596159"
  },
  {
    "text": "which is super interesting in the general flow in this function over over here and this is something which is related",
    "start": "1596159",
    "end": "1601440"
  },
  {
    "text": "to the way that we map in unmapped vtl1 mdls let's take a closer look so this is a the general flow in skma",
    "start": "1601440",
    "end": "1608559"
  },
  {
    "text": "obtained hotpatch on the table and as you can see we just allocate some chunk in a secure camera hip",
    "start": "1608559",
    "end": "1613679"
  },
  {
    "text": "we copy the entire transfer mdl into this new chunk we make some integrity check and if this check passes we call skma map mdl",
    "start": "1613679",
    "end": "1620960"
  },
  {
    "text": "to map this new mdl into the vtl1 outer space and if this check fails then we do go to",
    "start": "1620960",
    "end": "1626640"
  },
  {
    "text": "clean up we take the ballot flow and we hit the call to skmm mdl now the problem here is that we don't",
    "start": "1626640",
    "end": "1632960"
  },
  {
    "text": "make sure that we indeed called skmm up mdl before calling sk map mdl",
    "start": "1632960",
    "end": "1638720"
  },
  {
    "text": "and this is exactly what is going to happen if the integrity check fails now since we can control over the entire",
    "start": "1638720",
    "end": "1644480"
  },
  {
    "text": "undo mdl over here we can make this integrity check fails and therefore we just summed up to be the ability to call skmmdl",
    "start": "1644480",
    "end": "1651919"
  },
  {
    "text": "on a fully controlled mdl by vtr0 uh okay great and here you can see the",
    "start": "1651919",
    "end": "1657440"
  },
  {
    "text": "code at the beginning you you can see the integrity check at the end you can see the call to sqm of mdl and right there in the middle there",
    "start": "1657440",
    "end": "1664480"
  },
  {
    "text": "is the call to sqm up mdl which we clearly skipped okay plc's we have to write plcs for",
    "start": "1664480",
    "end": "1669679"
  },
  {
    "text": "everything that we find because otherwise everything is meaningless so let's cover the mdl set our phone for",
    "start": "1669679",
    "end": "1674960"
  },
  {
    "text": "one in the virtual address in the map system va trigger the vulnerability and boom",
    "start": "1674960",
    "end": "1680159"
  },
  {
    "text": "we got the exact expected call stack in the crash from the vulnerable function to skmm and mdl and then password in other area on",
    "start": "1680159",
    "end": "1687279"
  },
  {
    "text": "the virtual address aoa which is the pte address of the virtual rs4141",
    "start": "1687279",
    "end": "1692399"
  },
  {
    "text": "from the mdl this happened because skm skmmpfmdl resolves the pte address of",
    "start": "1692399",
    "end": "1697520"
  },
  {
    "text": "the virtual address in old drive zero into the pte okay great knowing this we can create",
    "start": "1697520",
    "end": "1703840"
  },
  {
    "text": "another plc let's try to custom arbitrary flow in a secure kernel and for this to happen we really need to find some virtual",
    "start": "1703840",
    "end": "1710559"
  },
  {
    "text": "address which is being used by something in within vtl1 i just show zero the shell page",
    "start": "1710559",
    "end": "1716080"
  },
  {
    "text": "vtl1 has its own shell page it's this fixed virtual address set it up in the mdl trigger the vulnerability and again",
    "start": "1716080",
    "end": "1722240"
  },
  {
    "text": "we got a crash in some arbitrary flow in the secure kernel uh in some thread they tried to dereference the",
    "start": "1722240",
    "end": "1728480"
  },
  {
    "text": "shell page and of course this page is no longer present because we wrote zero on its pt",
    "start": "1728480",
    "end": "1734159"
  },
  {
    "start": "1734000",
    "end": "1787000"
  },
  {
    "text": "okay great so we have the vulnerability we have the plc we know everything and now it's the time to get the actual work",
    "start": "1734159",
    "end": "1739840"
  },
  {
    "text": "starting uh so please note that we don't have here a memory corruption with a controlled",
    "start": "1739840",
    "end": "1744880"
  },
  {
    "text": "content permittive yet but we can clearly build one and in order to build one we really need to understand the functionality of sk",
    "start": "1744880",
    "end": "1752399"
  },
  {
    "text": "mdl now this happened to be super simple this function simply scans all of the pte is discarded",
    "start": "1752399",
    "end": "1757760"
  },
  {
    "text": "by this mdl it writes zeros over all of the speakers",
    "start": "1757760",
    "end": "1762960"
  },
  {
    "text": "please note that after this step everyday reference to every single page discard by this mdl will panic because all of the present",
    "start": "1762960",
    "end": "1769279"
  },
  {
    "text": "bits in all of the pte's are zeros and then we can choose if you want to take the call to skmi release",
    "start": "1769279",
    "end": "1775120"
  },
  {
    "text": "unknown ptes which in addition to the zeroing out of all of the pts goes to the bitmap and clear all of the relevant bits",
    "start": "1775120",
    "end": "1781279"
  },
  {
    "text": "just to indicate to the pt allocator hey all of the species are ready to be reclaimed and reuse",
    "start": "1781279",
    "end": "1787279"
  },
  {
    "start": "1787000",
    "end": "1825000"
  },
  {
    "text": "okay great please note that all of the rights done by skm and mdl are safe in the sense that all of",
    "start": "1787279",
    "end": "1792320"
  },
  {
    "text": "the rights to all of the ptes will for sure fall inside the pt's range due to the nature of the calculation",
    "start": "1792320",
    "end": "1798080"
  },
  {
    "text": "which converts from the virtual address to the pt address and all of the rights to all of the pages left currents will for sure fall",
    "start": "1798080",
    "end": "1804000"
  },
  {
    "text": "inside the pf and db range due to an explicit check in the code but we don't really need that",
    "start": "1804000",
    "end": "1810240"
  },
  {
    "text": "we can zero out arbitrary rpts and therefore we can clearly create some use after this scenario by replacing the underlying physical",
    "start": "1810240",
    "end": "1816720"
  },
  {
    "text": "page and if we want this to happen it would be very good of us to take the call to skma release unknown ptes just",
    "start": "1816720",
    "end": "1822080"
  },
  {
    "text": "to make sure that the pt allocator can reuse those pts okay now it's the time to talk about some structures",
    "start": "1822080",
    "end": "1828799"
  },
  {
    "start": "1825000",
    "end": "1852000"
  },
  {
    "text": "the secure canal maintains some structure in order to manage its own virtual address space makes sense one of the structure is the pte range",
    "start": "1828799",
    "end": "1835919"
  },
  {
    "text": "this structure simply describes a range of pts of a certain use there are some examples that over here and this structure has",
    "start": "1835919",
    "end": "1842640"
  },
  {
    "text": "exactly what you expect for me to have it has a pointer to all of the pts it has a pointer to the bitmap which",
    "start": "1842640",
    "end": "1847679"
  },
  {
    "text": "indicates which one of those pts are free and which one is in used and this is really important for us here because",
    "start": "1847679",
    "end": "1853679"
  },
  {
    "text": "the function skma releases unknown pts try to resolve the pte range which contains the pt address of the virtual",
    "start": "1853679",
    "end": "1860080"
  },
  {
    "text": "address from the mdl and here you can see that this function only looks for specific three pt ranges which which absolutely",
    "start": "1860080",
    "end": "1867600"
  },
  {
    "text": "don't cover the entire virtual other space there are more pt ranges and even after this function chooses one",
    "start": "1867600",
    "end": "1874240"
  },
  {
    "text": "it doesn't really make sure that the ptl is inside the pta range it's only check against the base so i",
    "start": "1874240",
    "end": "1880799"
  },
  {
    "text": "can just choose a virtual address which it spits here that is outside of all of those three pt ranges",
    "start": "1880799",
    "end": "1886080"
  },
  {
    "start": "1881000",
    "end": "1911000"
  },
  {
    "text": "set it up in mdl and therefore i gain the ability to write relatively to the bitmap of one of",
    "start": "1886080",
    "end": "1893279"
  },
  {
    "text": "those pt ranges so we gained a like relative right primitive fantastic",
    "start": "1893279",
    "end": "1898320"
  },
  {
    "text": "and there is the plc from the vulnerable function to skmm of mdl and then and then page for the",
    "start": "1898320",
    "end": "1903679"
  },
  {
    "text": "knowledge area during the the clearing of the bitmap",
    "start": "1903679",
    "end": "1909519"
  },
  {
    "text": "okay fantastic this is super great and it's really cool and really awesome but it actually doesn't help us a lot because",
    "start": "1909519",
    "end": "1915279"
  },
  {
    "start": "1911000",
    "end": "1939000"
  },
  {
    "text": "there are so many pages outside of all of those bitmaps of those specific 3pt ranges",
    "start": "1915279",
    "end": "1921519"
  },
  {
    "text": "that aren't mapped and they are not in use at all so i really could make it work of course",
    "start": "1921519",
    "end": "1927039"
  },
  {
    "text": "but i really prefer to do better tricks and therefore i just do the use after free idea it would be",
    "start": "1927039",
    "end": "1933039"
  },
  {
    "text": "much much better and i'm gonna target the sky system pts since it's the main pte range in the",
    "start": "1933039",
    "end": "1938240"
  },
  {
    "text": "secure kernel so we know exactly what we have to do right we need to find some some interesting structure",
    "start": "1938240",
    "end": "1943360"
  },
  {
    "start": "1939000",
    "end": "1996000"
  },
  {
    "text": "we need to trigger the vulnerability and unmap the like underlying physical page reclaim the pt use of the",
    "start": "1943360",
    "end": "1950880"
  },
  {
    "text": "free profit fantastic and it would be a very smart idea of us to understand the",
    "start": "1950880",
    "end": "1956080"
  },
  {
    "text": "allocator involved here because we need to reclaim the pte so let's talk about the pt allocator",
    "start": "1956080",
    "end": "1962240"
  },
  {
    "text": "this happens to be very very simple there are two functions the location function and the free function and the allocation function simply",
    "start": "1962240",
    "end": "1968559"
  },
  {
    "text": "checks out the pit the bitmap hints value from the relevant pte range and it uses this value as the",
    "start": "1968559",
    "end": "1974559"
  },
  {
    "text": "first index to scan form in the pte is bitmap and just looks for sequence of enough zeros",
    "start": "1974559",
    "end": "1980480"
  },
  {
    "text": "and note that this bitmap hint value wraps around only when the allocation function reaches to the end of the",
    "start": "1980480",
    "end": "1986240"
  },
  {
    "text": "pte range and you can see this in those debug traces you can see that all of the locations are continuous",
    "start": "1986240",
    "end": "1993039"
  },
  {
    "text": "independent of all of the freeze in the middle okay great now we really want to get a good",
    "start": "1993039",
    "end": "1998799"
  },
  {
    "start": "1996000",
    "end": "2031000"
  },
  {
    "text": "crush basically you know which area really isn't good enough and it's really doesn't interesting",
    "start": "1998799",
    "end": "2004000"
  },
  {
    "text": "uh so i gave you two options i chose not to allocate the target structure myself",
    "start": "2004000",
    "end": "2009360"
  },
  {
    "text": "because if i will i will also need to spray a lot in order to make the big pop hints to wrap around",
    "start": "2009360",
    "end": "2014640"
  },
  {
    "text": "and i really prefer to do a better tricks and stable exploits uh so i simply can rely on the fact that",
    "start": "2014640",
    "end": "2022480"
  },
  {
    "text": "the secure kernel boot process is so predictable and so deterministic that actually every time after boot i",
    "start": "2022480",
    "end": "2028880"
  },
  {
    "text": "have about the same bitmap hints so i can just look over the entire address space that i have after the",
    "start": "2028880",
    "end": "2035279"
  },
  {
    "text": "bitmap hint that i have after both and just see if i have already existing structure",
    "start": "2035279",
    "end": "2041200"
  },
  {
    "text": "and that it's in used and that and it comes after the bitmap pins",
    "start": "2041200",
    "end": "2047679"
  },
  {
    "text": "and of course i found the plcb structure which is great candidate for memory corruption exploits",
    "start": "2047679",
    "end": "2053358"
  },
  {
    "text": "please note that i can't corrupt specific data i have to corrupt at least at least one page due to the nature of",
    "start": "2053359",
    "end": "2059280"
  },
  {
    "text": "the vulnerability and but it's actually fine because this structure is very very large it spends over a few pages",
    "start": "2059280",
    "end": "2065679"
  },
  {
    "text": "and i can of course choose the specific page which is best for me to corrupt okay great so we know what the high",
    "start": "2065679",
    "end": "2071839"
  },
  {
    "text": "level plan here is right okay let's see it in action so this is the the bitmap of all of the pts in skmi",
    "start": "2071839",
    "end": "2080720"
  },
  {
    "start": "2074000",
    "end": "2101000"
  },
  {
    "text": "system pt is pt range there is the bitmap hints that i have after both right there so let's pray",
    "start": "2080720",
    "end": "2087200"
  },
  {
    "text": "just to get closer to the plc pages to regular vulnerability on the expected virtual address",
    "start": "2087200",
    "end": "2093118"
  },
  {
    "text": "and keeps brain in order to reclaim the pt of this single page inside the plc pages",
    "start": "2093119",
    "end": "2098960"
  },
  {
    "text": "and by implementing this and run the poc we got finally a great crash of",
    "start": "2098960",
    "end": "2104720"
  },
  {
    "start": "2101000",
    "end": "2122000"
  },
  {
    "text": "dereferencing arbitrary pointers from this point it's very trivial to",
    "start": "2104720",
    "end": "2109839"
  },
  {
    "text": "gain read write primitives and from this point we know exactly what we need to do and we don't have time to",
    "start": "2109839",
    "end": "2115280"
  },
  {
    "text": "see the full extract but but we already saw what we can do with right",
    "start": "2115280",
    "end": "2120720"
  },
  {
    "text": "primitive so it's game over okay now let's talk about what you can do after we gain arbitrary code execution",
    "start": "2120720",
    "end": "2126720"
  },
  {
    "start": "2122000",
    "end": "2215000"
  },
  {
    "text": "so of course we can bypass a both hvci and traditional guard as we said because",
    "start": "2126720",
    "end": "2131920"
  },
  {
    "text": "the secure can by design have the ability to issue hyper calls for the hypervisor and requesting setting arbitrary",
    "start": "2131920",
    "end": "2139599"
  },
  {
    "text": "permissions in the slots of course fantastic we keep work on",
    "start": "2139599",
    "end": "2144640"
  },
  {
    "text": "hardening the secure kernel we fix all of the issues we found in this research",
    "start": "2144640",
    "end": "2150240"
  },
  {
    "text": "we truly believe that there is so much high values in developing end-to-end exploits and",
    "start": "2150240",
    "end": "2155520"
  },
  {
    "text": "one of those is to spot an important behaviors to change uh so we made this for both writable and",
    "start": "2155520",
    "end": "2163119"
  },
  {
    "text": "executable addresses to be non-writable uh we are investigating right now options for",
    "start": "2163119",
    "end": "2169040"
  },
  {
    "text": "randomization of secure kernel regions there are actually more surprises to come so please stay with us and of course if",
    "start": "2169040",
    "end": "2175760"
  },
  {
    "text": "you have bugs please please submit to us we really want to work together and and just",
    "start": "2175760",
    "end": "2184160"
  },
  {
    "text": "like we said uh dos isn't in scope because a vtl0 can of course by design dos",
    "start": "2184160",
    "end": "2190880"
  },
  {
    "text": "vtl1 so we need to find plc's uh which actually can leak sensitive data",
    "start": "2190880",
    "end": "2196560"
  },
  {
    "text": "or can corrupt memory and etc okay great uh this this rituals could not have been done",
    "start": "2196560",
    "end": "2202640"
  },
  {
    "text": "like without a a a great fox so thank you all so much",
    "start": "2202640",
    "end": "2208800"
  },
  {
    "text": "and now would be the time for q a thank you so much",
    "start": "2208800",
    "end": "2215839"
  },
  {
    "start": "2215000",
    "end": "2454000"
  },
  {
    "text": "thank you hi thank you so much for for attending the talk",
    "start": "2216079",
    "end": "2224240"
  },
  {
    "text": "and we don't see any questions that we didn't answer right if there is some clarification",
    "start": "2224240",
    "end": "2232720"
  },
  {
    "text": "that you want to make some question some issue please um",
    "start": "2232720",
    "end": "2237760"
  },
  {
    "text": "write it right now in the chat",
    "start": "2237760",
    "end": "2243839"
  },
  {
    "text": "it might be worth uh to mention that we are about to upload the slides in about uh",
    "start": "2244560",
    "end": "2249760"
  },
  {
    "text": "five minutes also so you can find it on twitter and are there any",
    "start": "2249760",
    "end": "2257760"
  },
  {
    "text": "any questions",
    "start": "2257760",
    "end": "2271839"
  },
  {
    "text": "okay so you could find the slides again on twitter it will be on the msrc github",
    "start": "2290240",
    "end": "2298079"
  },
  {
    "text": "and thank you so much",
    "start": "2298079",
    "end": "2302160"
  },
  {
    "text": "thank you",
    "start": "2310079",
    "end": "2313839"
  },
  {
    "text": "oh wait i see are the plans to extend the vital zero mitigations to retail one secure kernel",
    "start": "2316079",
    "end": "2323119"
  },
  {
    "text": "yes so so this is a very very good point uh yes uh as i said at the end we are working",
    "start": "2323119",
    "end": "2330880"
  },
  {
    "text": "on porting some of the noble kernel mitigations into the secure kernel uh we are starting with investigating",
    "start": "2330880",
    "end": "2338240"
  },
  {
    "text": "some um randomization for all of the fixed addresses and all of the like",
    "start": "2338240",
    "end": "2344240"
  },
  {
    "text": "predictable ones and and there are some more like surprises to come",
    "start": "2344240",
    "end": "2349359"
  },
  {
    "text": "the devs team are talking on that uh stay tuned for some like interesting",
    "start": "2349359",
    "end": "2355440"
  },
  {
    "text": "news in the near future and yes so just like i said queso",
    "start": "2355440",
    "end": "2363920"
  },
  {
    "text": "will for show um they are working on it's like right now",
    "start": "2363920",
    "end": "2369520"
  },
  {
    "text": "and see if i it's and like interesting point yeah we definitely want to have c fighter",
    "start": "2369520",
    "end": "2375280"
  },
  {
    "text": "and then the the like interesting point is that unlike uh the k uh cfg that we",
    "start": "2375280",
    "end": "2382079"
  },
  {
    "text": "will have in in there like a normal kernel and we can protect uh",
    "start": "2382079",
    "end": "2387920"
  },
  {
    "text": "recover the bitmap uh with the uh extended vegetables we can't do that for the secure camera because",
    "start": "2387920",
    "end": "2393920"
  },
  {
    "text": "there isn't slot enforcement but we can shell have like a normal",
    "start": "2393920",
    "end": "2398960"
  },
  {
    "text": "sieve jitter it might happen in the future as well",
    "start": "2398960",
    "end": "2411839"
  },
  {
    "text": "okay",
    "start": "2422839",
    "end": "2425839"
  },
  {
    "text": "okay great so thank you so so much again er enjoy",
    "start": "2444880",
    "end": "2451359"
  },
  {
    "text": "the rest of brackets bye",
    "start": "2451359",
    "end": "2456400"
  }
]