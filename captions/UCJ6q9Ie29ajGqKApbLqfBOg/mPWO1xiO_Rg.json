[
  {
    "text": "welcome to Isis spurious why so serious this is a presentation on a hardware",
    "start": "140",
    "end": "6990"
  },
  {
    "text": "feature that exists in intel and AMD chips and operating system developers",
    "start": "6990",
    "end": "14460"
  },
  {
    "text": "didn't uh so the the instruction manual there's hundreds of tiny little tidbits",
    "start": "14460",
    "end": "20189"
  },
  {
    "text": "in this and there was a tiny little bit that they missed and we actually use",
    "start": "20189",
    "end": "25590"
  },
  {
    "text": "this to create an exploit turkic create an LP e and a spurious essentially means",
    "start": "25590",
    "end": "32130"
  },
  {
    "text": "unexpected so it's an appropriate name followed by batman these are our presentation topics",
    "start": "32130",
    "end": "40879"
  },
  {
    "text": "we're gonna go through introductions I'm going to introduce myself and then my colleague Nami is gonna introduce",
    "start": "40879",
    "end": "46559"
  },
  {
    "text": "himself in his background then we're gonna go over what is a CVE twenty",
    "start": "46559",
    "end": "51570"
  },
  {
    "text": "eighteen eight eight nine seven if you don't know what a CV is hopefully by the end of this presentation",
    "start": "51570",
    "end": "58489"
  },
  {
    "text": "hopefully you'll know what a CV is we're gonna go over some prerequisite",
    "start": "58670",
    "end": "63840"
  },
  {
    "text": "knowledge nemi's gonna kind of train you on some some high-level information that you",
    "start": "63840",
    "end": "70350"
  },
  {
    "text": "need to actually understand how this works granted that we only have fifty minutes it's important that you keep in",
    "start": "70350",
    "end": "76650"
  },
  {
    "text": "mind that we we have a white paper if you actually want to understand a lot of the technical details of how this works",
    "start": "76650",
    "end": "83000"
  },
  {
    "text": "we have a link to that at the end of this presentation after that I'm gonna",
    "start": "83000",
    "end": "89970"
  },
  {
    "text": "go over how move the SS and pop SS actually function what they do why",
    "start": "89970",
    "end": "95670"
  },
  {
    "text": "they're special in the x86 architecture and then we have three proof of concepts",
    "start": "95670",
    "end": "101570"
  },
  {
    "text": "it's kind of in order how special they are the first one is a local denial of service this kind of just blows up your",
    "start": "101570",
    "end": "108540"
  },
  {
    "text": "own machine it's not really that that incredible the second one is a local",
    "start": "108540",
    "end": "114240"
  },
  {
    "text": "privileged escalation using in three there's the one that I personally weaponized it's my personal favorite",
    "start": "114240",
    "end": "119790"
  },
  {
    "text": "and then we have the second one a local privilege escalation using Cisco that's the one that let me hear weaponized",
    "start": "119790",
    "end": "127140"
  },
  {
    "text": "himself that one's also incredible and then we have a conclusion at the end there's a couple heads",
    "start": "127140",
    "end": "134310"
  },
  {
    "text": "in the industry that we'd like to give shoutouts to people who weaponize it people who actually gave us some input",
    "start": "134310",
    "end": "140849"
  },
  {
    "text": "during this entire process and some really cool people we'd like to we'd like to give thanks to so I'm Nick",
    "start": "140849",
    "end": "149610"
  },
  {
    "text": "Peterson I got I got my start in this at a really young age in gaming a world of",
    "start": "149610",
    "end": "157319"
  },
  {
    "text": "warcraft actually I played hardcore through high school in fact I almost dropped out writing all the time I'm",
    "start": "157319",
    "end": "164580"
  },
  {
    "text": "sure if you're in this crowd you've probably played World of Warcraft at some point if you haven't I'm sure you at least know what it is I start while",
    "start": "164580",
    "end": "173459"
  },
  {
    "text": "playing World of Warcraft I did a lot of teleport hex bots and more per hex sort",
    "start": "173459",
    "end": "179940"
  },
  {
    "text": "of sort of vanity based skin modifications that you could do to the",
    "start": "179940",
    "end": "186510"
  },
  {
    "text": "game I sold some of that stuff some of the other stuff I didn't after that I",
    "start": "186510",
    "end": "193380"
  },
  {
    "text": "started a cheat site called subtle lane which I sold a subscription-based",
    "start": "193380",
    "end": "198829"
  },
  {
    "text": "Counter Strike global Offensive cheats to where you would you basically pay me",
    "start": "198829",
    "end": "204359"
  },
  {
    "text": "a monthly subscription to cheat and Counter Strike global Offensive and you",
    "start": "204359",
    "end": "211680"
  },
  {
    "text": "would get access to an aimbot and an ESP and use as long as you paid me $25 a",
    "start": "211680",
    "end": "216959"
  },
  {
    "text": "month you would be able to keep cheating and again after that I was hired into",
    "start": "216959",
    "end": "223799"
  },
  {
    "text": "Riot Games by let me actually seek me out where I currently do similar work",
    "start": "223799",
    "end": "230989"
  },
  {
    "text": "currently working on League of Legends we deal with a lot of cheaters there and working on future products so I'm going",
    "start": "230989",
    "end": "239040"
  },
  {
    "text": "to go ahead and hand it over to many awesome introduce himself you go cool thanks man",
    "start": "239040",
    "end": "244470"
  },
  {
    "text": "so yeah I actually started very similar to make I was game hacking when I first",
    "start": "244470",
    "end": "250709"
  },
  {
    "text": "you know got into information security and I actually got my start in the same game World of Warcraft yes it was a",
    "start": "250709",
    "end": "257489"
  },
  {
    "text": "popular game at the time and that's where I first really began you know game",
    "start": "257489",
    "end": "263490"
  },
  {
    "text": "hacking and what end up evolving was a piece I guess passionate security I worked in the government for",
    "start": "263490",
    "end": "270569"
  },
  {
    "text": "a couple years and then decided that it was very bureaucratic and I didn't want to stay in that business for long so I",
    "start": "270569",
    "end": "275729"
  },
  {
    "text": "looked to the west coast to find a job in gaming because that was really where",
    "start": "275729",
    "end": "280949"
  },
  {
    "text": "my passion started in this field I worked at Blizzard Entertainment for a",
    "start": "280949",
    "end": "286050"
  },
  {
    "text": "couple years I worked kind of over watches anti-cheat which is a popular first-person shooter game then from",
    "start": "286050",
    "end": "292020"
  },
  {
    "text": "there I moved to riot and now I work with Nick on League of Legends so to",
    "start": "292020",
    "end": "297599"
  },
  {
    "text": "understand really what CV 2018 88 97 is we have to explain what it could do",
    "start": "297599",
    "end": "303389"
  },
  {
    "text": "right so this CBE is a local privilege escalation vulnerability it allows you",
    "start": "303389",
    "end": "308550"
  },
  {
    "text": "to read and write kernel memory from user mode and it also lets you execute user mode code with kernel mode",
    "start": "308550",
    "end": "314520"
  },
  {
    "text": "privileges so it's pretty crazy like it gives you full compromise on a system that your honor and it impacted a ton of",
    "start": "314520",
    "end": "321659"
  },
  {
    "text": "different operating systems not just Windows which a lot of the demo code will focus on just because it's the most",
    "start": "321659",
    "end": "326939"
  },
  {
    "text": "prevalent operating system but it also affected Linux Mac OS FreeBSD and even",
    "start": "326939",
    "end": "333180"
  },
  {
    "text": "Xen configurations basically anything that was x86 based probably up",
    "start": "333180",
    "end": "339960"
  },
  {
    "text": "and handling how move and pop SS worked to really understand how this works you",
    "start": "339960",
    "end": "345750"
  },
  {
    "text": "have to kind of know how interrupts function and how hardware breakpoints work and we'll go over that knowledge",
    "start": "345750",
    "end": "352259"
  },
  {
    "text": "this is assuming that you already have a good understanding of assembly you have to have some level of assembly knowledge",
    "start": "352259",
    "end": "358589"
  },
  {
    "text": "I'm sure something a lot of you have done reverse engineering whether it's malware or maybe even game hacking so hopefully with this additional knowledge",
    "start": "358589",
    "end": "366029"
  },
  {
    "text": "you'll really understand how the core OS functions when it encounters some of these behaviors now everyone's seen this",
    "start": "366029",
    "end": "373199"
  },
  {
    "text": "probably a million times I'm sure other blackhat presenters actually used the same picture of the privilege levels on",
    "start": "373199",
    "end": "379589"
  },
  {
    "text": "an operating system is just on Wikipedia and really in the traditional sense",
    "start": "379589",
    "end": "384839"
  },
  {
    "text": "there's only ring 3 in ring 0 ring 1 & 2 are really never used ring 3 is where the untrusted user mode applications",
    "start": "384839",
    "end": "391460"
  },
  {
    "text": "execute these are your games your your favorite calculator exe that gets popped",
    "start": "391460",
    "end": "396690"
  },
  {
    "text": "all the time as well as you know basically anything that you interact with directly as an end user of that system",
    "start": "396690",
    "end": "403750"
  },
  {
    "text": "and then as you transcend into these rings you start gaining more and more privileges you can use more",
    "start": "403750",
    "end": "408760"
  },
  {
    "text": "functionality of the operating system and ring zero is intended to be the most privileged arena where the kernel",
    "start": "408760",
    "end": "414460"
  },
  {
    "text": "operates and where the core OS features are now this gets complicated obviously with hypervisors as well as",
    "start": "414460",
    "end": "421510"
  },
  {
    "text": "like Intel management engine but to our presentation this is the simplified view",
    "start": "421510",
    "end": "427390"
  },
  {
    "text": "and how things were a decade ago when a hardware breakpoint fires it's it's",
    "start": "427390",
    "end": "433780"
  },
  {
    "text": "super important to understand that and there's charts here that you don't really have to look through this is in",
    "start": "433780",
    "end": "439930"
  },
  {
    "text": "the SDM the Intel software development manual so you could browse this at your leisure when you're trying to fall",
    "start": "439930",
    "end": "445600"
  },
  {
    "text": "asleep but the software breakpoint is different from a hardware breakpoint I'm sure a lot of you guys have used",
    "start": "445600",
    "end": "451420"
  },
  {
    "text": "software breakpoints for debugging purposes a software breakpoint is in 3 or a CC and and hardware breakpoint",
    "start": "451420",
    "end": "459190"
  },
  {
    "text": "varies from that in that I'll use the term data breakpoint interchangeably to mean Hardware breakpoint there are only",
    "start": "459190",
    "end": "465700"
  },
  {
    "text": "four of them on the x86 architecture you can set them on access read and write you only get four per processor every",
    "start": "465700",
    "end": "473140"
  },
  {
    "text": "processor has its own view of Hardware breakpoints when a hardware breakpoint occurs or when any interrupt fires not",
    "start": "473140",
    "end": "480070"
  },
  {
    "text": "just Hardware breakpoints execution is given to the kernel by the CPU and we'll explain how that process works but",
    "start": "480070",
    "end": "487000"
  },
  {
    "text": "there's certain status bits in some other debug registers that explain what tripped and exactly how you can control",
    "start": "487000",
    "end": "494020"
  },
  {
    "text": "these Hardware breakpoints the most important thing to note is really that this is a privileged thing you can't",
    "start": "494020",
    "end": "499060"
  },
  {
    "text": "just set Hardware breakpoints from user mode but most operating systems provide a way to do that through api's that will",
    "start": "499060",
    "end": "505840"
  },
  {
    "text": "just issue system calls under the hood in Windows you can do this by using set thread context and other operating",
    "start": "505840",
    "end": "512590"
  },
  {
    "text": "systems do it differently but most offer this for any application that runs it",
    "start": "512590",
    "end": "517719"
  },
  {
    "text": "doesn't have to be an administrator application just because it's such a powerful debugging tool so when an",
    "start": "517719",
    "end": "523840"
  },
  {
    "text": "interrupt fires and 8/1 fires a DB fires the CPU transfers execution to an",
    "start": "523840",
    "end": "529030"
  },
  {
    "text": "interrupt Handler and this interrupt handler is it's located inside of this giant lookup table this IDT",
    "start": "529030",
    "end": "534840"
  },
  {
    "text": "set up early kernel initialization by the operating system so based on what",
    "start": "534840",
    "end": "541410"
  },
  {
    "text": "interrupts fires it's the index inside of this IDT so for hardware breakpoints",
    "start": "541410",
    "end": "546660"
  },
  {
    "text": "it's in one and that is the second index assuming you know you start at zero and in three is the fourth index which is",
    "start": "546660",
    "end": "553320"
  },
  {
    "text": "where your software breakpoints are firing so when an int 1 or an in 3 fires",
    "start": "553320",
    "end": "558570"
  },
  {
    "text": "the CPU will look at its interrupt descriptor table to figure out where to go in the kernel to process that",
    "start": "558570",
    "end": "566190"
  },
  {
    "text": "interrupt that's fired these are all the interrupts on Windows not super important to know all of them just that",
    "start": "566190",
    "end": "573060"
  },
  {
    "text": "the ant one handler which is the one for hardware breakpoints it's called ki D bug trapper fault additionally when that",
    "start": "573060",
    "end": "581160"
  },
  {
    "text": "in one fires there's some Stax artifacts that are pushed on by the CPU and this",
    "start": "581160",
    "end": "586980"
  },
  {
    "text": "is mostly so that your kernel mode handler that's handling the cinder up knows where it came from so there's",
    "start": "586980",
    "end": "592020"
  },
  {
    "text": "certain stuff that's placed onto the stack like the instruction pointer where the interrupt was fired the code segment",
    "start": "592020",
    "end": "598050"
  },
  {
    "text": "to figure out what previous mode of execution it was in that is it coming from user mode is it or is it coming",
    "start": "598050",
    "end": "604560"
  },
  {
    "text": "from kernel mode there's flags in the stack pointers and so on and so forth and traditionally for",
    "start": "604560",
    "end": "612080"
  },
  {
    "text": "mostly every single operating system we've looked at the OS interrupt handler can ID bug trapper fault for example for",
    "start": "612080",
    "end": "618810"
  },
  {
    "text": "the ant one handler and Windows looks at this code segment selector on the stack to determine what the previous privilege",
    "start": "618810",
    "end": "624570"
  },
  {
    "text": "level was where the codes coming from is it coming from kernel mode it's coming from user mode and the first two bits in",
    "start": "624570",
    "end": "630600"
  },
  {
    "text": "the CS value actually tell you what mode it is and will actually explain how that",
    "start": "630600",
    "end": "636180"
  },
  {
    "text": "looks a little bit more to really understand how segmentation works it's",
    "start": "636180",
    "end": "641850"
  },
  {
    "text": "complicated it's not really necessary for 64-bit mode it's kind of a stijl",
    "start": "641850",
    "end": "646980"
  },
  {
    "text": "apart of the x86 architecture the reason why I bring it up is because there are going to be call-outs to certain segment",
    "start": "646980",
    "end": "653640"
  },
  {
    "text": "selectors that you need to be aware of like for example the CS is the code segment that gets placed onto the stack",
    "start": "653640",
    "end": "660660"
  },
  {
    "text": "by the CPU when the int one fires then there's the stack segment selector SS",
    "start": "660660",
    "end": "665670"
  },
  {
    "text": "which is the move SS and the pop SS part and this",
    "start": "665670",
    "end": "671350"
  },
  {
    "text": "whole all of these segments electrics are just indices inside of this global descriptive table very similar to an IDT",
    "start": "671350",
    "end": "677580"
  },
  {
    "text": "setup during early kernel initialization describes kind of how that region of",
    "start": "677580",
    "end": "682600"
  },
  {
    "text": "memory works because paging exists nowadays it's super irrelevant what",
    "start": "682600",
    "end": "687910"
  },
  {
    "text": "operating systems still use our FS and GS segment selectors and the reason for that is because they actually you can",
    "start": "687910",
    "end": "695290"
  },
  {
    "text": "set arbitrary base address is still in 64-bit mode that means like assuming I'm",
    "start": "695290",
    "end": "702220"
  },
  {
    "text": "an OS developer and I want to read like kernel mode data structures I can actually you know set a base address or",
    "start": "702220",
    "end": "708970"
  },
  {
    "text": "for example FS to be one two three four five so when I read fs100 I'm actually",
    "start": "708970",
    "end": "714160"
  },
  {
    "text": "reading from FS from the relay near address one two four four five and again",
    "start": "714160",
    "end": "720370"
  },
  {
    "text": "as I mentioned earlier the first two bits of the segment selector index",
    "start": "720370",
    "end": "726310"
  },
  {
    "text": "explained what privilege level you're coming from so whether you're coming from kernel mode or user mode so and as",
    "start": "726310",
    "end": "731980"
  },
  {
    "text": "an example so that you understand that a CS value of ten and thirteen hex tenant X 13 describe the same index inside of",
    "start": "731980",
    "end": "738970"
  },
  {
    "text": "this gdt one describes a chroma mode segment selector the other describes a",
    "start": "738970",
    "end": "744100"
  },
  {
    "text": "user mode one so very fast overview on",
    "start": "744100",
    "end": "750280"
  },
  {
    "text": "segmentation you don't have to really understand too much of it just the fact that it exists and it's kind of based on",
    "start": "750280",
    "end": "756040"
  },
  {
    "text": "how the OS handles where execution is coming from when you enter it these",
    "start": "756040",
    "end": "761320"
  },
  {
    "text": "interrupt handlers so the int one handler in Windows can ID bug trapper fault it actually I'll use my mouse",
    "start": "761320",
    "end": "769270"
  },
  {
    "text": "pointer here because it's hard to use this thing so I went too far but anyway",
    "start": "769270",
    "end": "775810"
  },
  {
    "text": "you can see that there's a check on the code segment selector on the stack and then based on whether you're coming from",
    "start": "775810",
    "end": "781720"
  },
  {
    "text": "user mode or kernel mode different things will happen so if you're actually coming from kernel mode you skip this",
    "start": "781720",
    "end": "786940"
  },
  {
    "text": "code here the swap GS and then the move r10 you actually skip all that logic and you go directly into here which is the",
    "start": "786940",
    "end": "793180"
  },
  {
    "text": "CLD and that's because based on your mode of execution GS means different things the",
    "start": "793180",
    "end": "798640"
  },
  {
    "text": "GS base means different things in user mode your GS base is your threat environment block if you've done any",
    "start": "798640",
    "end": "804500"
  },
  {
    "text": "Windows programming you know that to be true for 64-bit you know windows and in",
    "start": "804500",
    "end": "809930"
  },
  {
    "text": "kernel mode it's not the threat environment block it's your processor control region it's whatever you're",
    "start": "809930",
    "end": "815270"
  },
  {
    "text": "executing under so if you're coming from user mode so you've entered this interrupt handler from user mode you",
    "start": "815270",
    "end": "821300"
  },
  {
    "text": "actually need to swap to a kernel GS right how else is the OS going to access these kernel data structures and use",
    "start": "821300",
    "end": "827930"
  },
  {
    "text": "that GS base and the way it's done is by issuing this assembly instruction called swap GS and that puts the GS base for",
    "start": "827930",
    "end": "835850"
  },
  {
    "text": "the kernel mode data structures there so that when you access GS 188 you're not",
    "start": "835850",
    "end": "841190"
  },
  {
    "text": "reading user mode memory which is under the control of a user mode application I explained what swap GS did but just an",
    "start": "841190",
    "end": "849410"
  },
  {
    "text": "overview all it does that it takes whatever's at that GS base just like what was it that FS base and just swaps",
    "start": "849410",
    "end": "855830"
  },
  {
    "text": "that with this MSR which is a model specific register a hidden CPU register and it'll allow the kernel to then",
    "start": "855830",
    "end": "863450"
  },
  {
    "text": "access the GS base to read kernel mode data structures pretty straightforward now Nix can explain how we leverage",
    "start": "863450",
    "end": "870740"
  },
  {
    "text": "remove SS and pop SS specifically to enter that these interrupt handlers and",
    "start": "870740",
    "end": "876520"
  },
  {
    "text": "confuse the operating system into actually thinking that we've entered from kernel mode and therefore avoiding",
    "start": "876520",
    "end": "882740"
  },
  {
    "text": "the swamp yes and this is like the heart of the exploit perfect so never kind of",
    "start": "882740",
    "end": "890150"
  },
  {
    "text": "gave us a good level overview of segmentation and kind of stuff that you're gonna need to actually understand",
    "start": "890150",
    "end": "895970"
  },
  {
    "text": "in order to grasp how this works and need a remind you that there's a quiz at",
    "start": "895970",
    "end": "901010"
  },
  {
    "text": "the end so if you don't pass it you're actually banned from blackhat for life that's what they tell me anyway so if",
    "start": "901010",
    "end": "906890"
  },
  {
    "text": "you look at if you look at the right the assembly if you're familiar with assembly this is kind of gonna be easy",
    "start": "906890",
    "end": "911900"
  },
  {
    "text": "for you so if you look at the top instruction exclusive-or eix and then you follow it by increment RDI after",
    "start": "911900",
    "end": "919130"
  },
  {
    "text": "every instruction cycle retires the CPU recognizes pending interrupts in a",
    "start": "919130",
    "end": "925370"
  },
  {
    "text": "priority order and that's defined specifically in the Intel manual but",
    "start": "925370",
    "end": "930770"
  },
  {
    "text": "there's a specific case where when SS is loaded either be a move SS or pop SS until the",
    "start": "930770",
    "end": "937560"
  },
  {
    "text": "instruction after it completely retires interrupts are held pending and in this",
    "start": "937560",
    "end": "943770"
  },
  {
    "text": "particular case what we were thinking is that it's best if you think of SS and",
    "start": "943770",
    "end": "951480"
  },
  {
    "text": "ESP as nemily explain what segments ation as combining themselves into a",
    "start": "951480",
    "end": "956520"
  },
  {
    "text": "single stack pointer so SS plus ESP would combine themselves to equal a",
    "start": "956520",
    "end": "962490"
  },
  {
    "text": "particular linear address and after SS move SS or poppets as completes its",
    "start": "962490",
    "end": "969000"
  },
  {
    "text": "execution all interrupts are held pending until the instruction after it is finished it doesn't matter what",
    "start": "969000",
    "end": "974700"
  },
  {
    "text": "instruction is after it it could be a branch it could be any of the ones that",
    "start": "974700",
    "end": "979800"
  },
  {
    "text": "you see above it complete execution no interrupts are gonna be recognized after",
    "start": "979800",
    "end": "984810"
  },
  {
    "text": "it and that's kind of the heart of how this vulnerability works and so how do",
    "start": "984810",
    "end": "991770"
  },
  {
    "text": "we discover this so an Emmy and I kind of both work in anti-cheat and in the",
    "start": "991770",
    "end": "997320"
  },
  {
    "text": "anti Chi space lots of people attack our software with virtual machines and the reason for that is is it gives them kind",
    "start": "997320",
    "end": "1004250"
  },
  {
    "text": "of a it kind of gives them a high granularity of instructions that they can trap on and spoof certain",
    "start": "1004250",
    "end": "1012200"
  },
  {
    "text": "instructions to give back information that would normally not be received by our anti Chi software and at the time my",
    "start": "1012200",
    "end": "1019970"
  },
  {
    "text": "thought was in the particular case intel vt-x cpuid is a it's an unconditional",
    "start": "1019970",
    "end": "1027140"
  },
  {
    "text": "exit my thought at the time was well what would happen if you followed CPU ID",
    "start": "1027140",
    "end": "1033339"
  },
  {
    "text": "and it followed a move SS load what would happen in in if if we had a VM",
    "start": "1033340",
    "end": "1041060"
  },
  {
    "text": "exit after move SS and in this particular case intel actually explicitly describes in their manual",
    "start": "1041060",
    "end": "1047930"
  },
  {
    "text": "that hey during this during this exit there's a there's a there's a blocking",
    "start": "1047930",
    "end": "1053390"
  },
  {
    "text": "by move SS for one instruction cycle AMD actually says nothing it was like hey it's it's whatever so just just to dive",
    "start": "1053390",
    "end": "1062240"
  },
  {
    "text": "into a deep technical detail for you quick AMD if we have a VM exit",
    "start": "1062240",
    "end": "1067820"
  },
  {
    "text": "for cpuid with a pending DB it just completely completely throws it out in Intel it's actually held pending and if",
    "start": "1067820",
    "end": "1075410"
  },
  {
    "text": "the if the vmm developer wrote their code correctly it will be thrown after",
    "start": "1075410",
    "end": "1081410"
  },
  {
    "text": "the cpuid increments its its instruction by one complete cycle and so two to",
    "start": "1081410",
    "end": "1091460"
  },
  {
    "text": "expand on that my thought was well what would happen if we had a move SS and",
    "start": "1091460",
    "end": "1097670"
  },
  {
    "text": "then appending DB and then a branch so what happens is if you have move SS or",
    "start": "1097670",
    "end": "1103130"
  },
  {
    "text": "pop SS and it accesses memory followed by a branch after that right after that",
    "start": "1103130",
    "end": "1109190"
  },
  {
    "text": "instruction it fires an n1 come right right after that instruction and what",
    "start": "1109190",
    "end": "1115340"
  },
  {
    "text": "happens if we do an inner privilege interrupt okay in the two ways that we can do that in user mode are with interrupted Cisco so if you look at the",
    "start": "1115340",
    "end": "1124910"
  },
  {
    "text": "assembly at the bottom and the white what's important here is that our DX is",
    "start": "1124910",
    "end": "1130340"
  },
  {
    "text": "actually primed with debug registers so if you don't know if you've done at least some type of user mode Linux",
    "start": "1130340",
    "end": "1138530"
  },
  {
    "text": "debugging or Windows debugging you can actually set with the set thread contacts function on a linear address we",
    "start": "1138530",
    "end": "1145970"
  },
  {
    "text": "could say that our ax is going to fire in in one after it accesses memory now",
    "start": "1145970",
    "end": "1153110"
  },
  {
    "text": "what would normally happen use after move SS accesses memory if our X was",
    "start": "1153110",
    "end": "1159440"
  },
  {
    "text": "actually primed with debug registers is it would fire in anyone after it",
    "start": "1159440",
    "end": "1164900"
  },
  {
    "text": "finishes its execution but as I described in the previous slide in this particular case and only this particular",
    "start": "1164900",
    "end": "1171560"
  },
  {
    "text": "case it's held off until after the instruction after it completes and this",
    "start": "1171560",
    "end": "1177050"
  },
  {
    "text": "is an image this is an interesting case because what happens what happens if after that instruction we have an inner",
    "start": "1177050",
    "end": "1183020"
  },
  {
    "text": "privilege interrupt so I tried that actually one random afternoon at my house and my machine just blew up so",
    "start": "1183020",
    "end": "1193580"
  },
  {
    "text": "what happens we execute an entry in the context of user mode in Windows this is",
    "start": "1193580",
    "end": "1199340"
  },
  {
    "text": "not privileged ok the DPL actually three so we can execute it without any type of issue the entry",
    "start": "1199340",
    "end": "1206990"
  },
  {
    "text": "would normally cause a branch to the windows version of the entry antler which is a breakpoint trap but since we",
    "start": "1206990",
    "end": "1214790"
  },
  {
    "text": "have a pending in one before it ever executes the first instruction of K",
    "start": "1214790",
    "end": "1219950"
  },
  {
    "text": "break boy trap it's actually you need to go to the windows in one handler which if you're familiar with single stepping",
    "start": "1219950",
    "end": "1225890"
  },
  {
    "text": "instructions it goes to the in one handler after every single instruction is executed so if we look at number four",
    "start": "1225890",
    "end": "1233330"
  },
  {
    "text": "it's actually going to go to kadiebug trap or fault which is the windows name",
    "start": "1233330",
    "end": "1238580"
  },
  {
    "text": "it's actually the windows symbol name for the in one handler in its at this",
    "start": "1238580",
    "end": "1244550"
  },
  {
    "text": "point in time that the windows kernel becomes completely confused because we're actually at execution at ki debug",
    "start": "1244550",
    "end": "1252200"
  },
  {
    "text": "chopper fault where it thinks it came from from kernel mode when in reality it",
    "start": "1252200",
    "end": "1258170"
  },
  {
    "text": "came from user mode so this is just a simple demo and as I explained at the",
    "start": "1258170",
    "end": "1263180"
  },
  {
    "text": "beginning this isn't this isn't entirely critical it's just a way to crash a machine we're gonna get to egg the",
    "start": "1263180",
    "end": "1268430"
  },
  {
    "text": "actual cool later so if you look we have we have execute it's wrapped in a",
    "start": "1268430",
    "end": "1276200"
  },
  {
    "text": "try except block this is just in case it crashes so if you look at the bottom right this is our this is actually",
    "start": "1276200",
    "end": "1283340"
  },
  {
    "text": "nemi's code for a github link so if your machine was not patched for pop SS this",
    "start": "1283340",
    "end": "1290510"
  },
  {
    "text": "would actually crash your machine and depending on the state of your machine at the time you can get a blue screen",
    "start": "1290510",
    "end": "1295670"
  },
  {
    "text": "your machine could completely Harlock it depends but if your machine was patch it's just gonna throw an exception and",
    "start": "1295670",
    "end": "1301940"
  },
  {
    "text": "it's just gonna cause an early exit this is our assembly I'm gonna kind of walk",
    "start": "1301940",
    "end": "1307430"
  },
  {
    "text": "you through this is a little bit so if you look at the top we do a move SS to",
    "start": "1307430",
    "end": "1312500"
  },
  {
    "text": "the stack selector that's important because later when we do a move SS it has to be a valid SS we don't if we",
    "start": "1312500",
    "end": "1318950"
  },
  {
    "text": "don't load a valid SS it's gonna cause a GP fault and our exploits not gonna work",
    "start": "1318950",
    "end": "1324110"
  },
  {
    "text": "at all because it's gonna cause an exception earlier than it should and then we if you look in the middle kind",
    "start": "1324110",
    "end": "1330170"
  },
  {
    "text": "of you'll see a call set data breakpoint that's important because of course we have to have we have to have a pending DB exception",
    "start": "1330170",
    "end": "1336710"
  },
  {
    "text": "by the time we reach the move SS otherwise otherwise we're not going to",
    "start": "1336710",
    "end": "1342230"
  },
  {
    "text": "have the pending DB fire at the wrong point that should then is nemi explained earlier we call the set thread context",
    "start": "1342230",
    "end": "1349880"
  },
  {
    "text": "so the higher-level kernel32 function we just call that to set the data break",
    "start": "1349880",
    "end": "1355160"
  },
  {
    "text": "point on the move SS the actual memory that it's going to access that's",
    "start": "1355160",
    "end": "1360440"
  },
  {
    "text": "important again because if it doesn't if it doesn't have the debug register armed then this inter up isn't gonna fire and",
    "start": "1360440",
    "end": "1368030"
  },
  {
    "text": "this is kind of the heart of it again it's nothing it's nothing fancy it's just gonna crash your machine so if you",
    "start": "1368030",
    "end": "1374360"
  },
  {
    "text": "look at the top we just have the move SS followed by an n3 so again move SS is",
    "start": "1374360",
    "end": "1380420"
  },
  {
    "text": "accessing memory and the RA X the dereference there is accessing memory that is currently armed by a debug",
    "start": "1380420",
    "end": "1387170"
  },
  {
    "text": "register followed by an entry so what happens is after the N three finishes its execution it's gonna fire ant 1 and",
    "start": "1387170",
    "end": "1396320"
  },
  {
    "text": "this is a quick video representation of how this works and then he's gonna go ahead and walk us through yeah so we'll",
    "start": "1396320",
    "end": "1401360"
  },
  {
    "text": "step through this using the gdb stub and we can actually debug vmware and see how it handles it so specifically what we do",
    "start": "1401360",
    "end": "1408620"
  },
  {
    "text": "is we start a timer just so that you can visually see when i break in to the debugger we run the move SS sample that",
    "start": "1408620",
    "end": "1415820"
  },
  {
    "text": "you just saw the code for and you can check the github link if you're confused about certain things there's a spin lock",
    "start": "1415820",
    "end": "1421820"
  },
  {
    "text": "there I'm not sure if you saw that in the code but this is just done so that I can break in at the point before we actually run the move SS in 3 I can just",
    "start": "1421820",
    "end": "1430040"
  },
  {
    "text": "patch this out to an OP and then we can single step through these instructions real quick using the hypervisor debugger of vmware",
    "start": "1430040",
    "end": "1437870"
  },
  {
    "text": "so the move SS is gonna do reference re x re x contains a hardware breakpoint",
    "start": "1437870",
    "end": "1444830"
  },
  {
    "text": "primed upon it now if this wasn't move SS or pop SS it would actually cause an",
    "start": "1444830",
    "end": "1451430"
  },
  {
    "text": "end 1 to happen as soon as that instruction completed but it doesn't because of the behavior of move SS it",
    "start": "1451430",
    "end": "1456830"
  },
  {
    "text": "suppresses that for one instruction that means that that happens upon entry of in theory and now we execute in three the",
    "start": "1456830",
    "end": "1465920"
  },
  {
    "text": "hardware break one hasn't hit the high road breakpoint applied now after we've entered in three",
    "start": "1465920",
    "end": "1471420"
  },
  {
    "text": "but look at where we're at we're actually at the Antoine handler we're at CAD debug trap our fault",
    "start": "1471420",
    "end": "1476460"
  },
  {
    "text": "so we've entered the Antoine handler not the in three handler as what we've expected and if you look at the stack",
    "start": "1476460",
    "end": "1482190"
  },
  {
    "text": "actually which I'll get to I'll highlight that using my mouse you seek a",
    "start": "1482190",
    "end": "1488310"
  },
  {
    "text": "breakpoint trap is on top of the stack and if you remember when I like short I",
    "start": "1488310",
    "end": "1495120"
  },
  {
    "text": "gave that explanation on how the CPU reacts when it interrupts fires it puts",
    "start": "1495120",
    "end": "1500550"
  },
  {
    "text": "the previous state of the processor on top of the call stack at the point of",
    "start": "1500550",
    "end": "1505590"
  },
  {
    "text": "the exception so ki breakpoint trap is apparently the cause of the ant one",
    "start": "1505590",
    "end": "1510810"
  },
  {
    "text": "exception which is great because that means it's coming from kernel mode it's",
    "start": "1510810",
    "end": "1516060"
  },
  {
    "text": "actually coming from kernel mode even though we caused the behavior to occur from a user mode program we ran an INT",
    "start": "1516060",
    "end": "1523560"
  },
  {
    "text": "one from user mode but we actually delivered it in kernel mode and that's",
    "start": "1523560",
    "end": "1529200"
  },
  {
    "text": "the beauty of the exploit that means we've entered a ID bug trapper fault with a kernel mode CS so that we don't",
    "start": "1529200",
    "end": "1535530"
  },
  {
    "text": "do the swap GS that I mentioned would happen later and you can see if we look farther down on the call stack you can",
    "start": "1535530",
    "end": "1542250"
  },
  {
    "text": "see where our user mode code fired this was the in theory branch to the kernel also add stuff to the interrupts the",
    "start": "1542250",
    "end": "1548550"
  },
  {
    "text": "screen to the stack as part of the interrupt handling of the processor and now if I resume the operating system its",
    "start": "1548550",
    "end": "1556380"
  },
  {
    "text": "hosed it's not going to continue at all it's stuck at eight seconds and if I",
    "start": "1556380",
    "end": "1562560"
  },
  {
    "text": "break in I'll be stuck in a perpetual page faulting loop so the machine is essentially not gonna progress anymore",
    "start": "1562560",
    "end": "1569730"
  },
  {
    "text": "and if I keep breaking into it you'll see that it's still stuck at that same point in code so we have successfully",
    "start": "1569730",
    "end": "1578250"
  },
  {
    "text": "caused the machine to deadlock by just executing two assembly instructions",
    "start": "1578250",
    "end": "1583470"
  },
  {
    "text": "pretty crazy so let's continue with that it gets better because we can actually",
    "start": "1583470",
    "end": "1590730"
  },
  {
    "text": "make that and use it as a weaponized thing instead of just hosing the machine",
    "start": "1590730",
    "end": "1596520"
  },
  {
    "text": "we can actually get system privileges but we'll get to that later so again as I just explained",
    "start": "1596520",
    "end": "1602380"
  },
  {
    "text": "the whole beauty of this is that you avoid the swaps yes so there's no need to do the swaps yes if you're coming",
    "start": "1602380",
    "end": "1608200"
  },
  {
    "text": "from Carla Mona we've looked at this code already in this test which compares that code segment that's put on the",
    "start": "1608200",
    "end": "1613360"
  },
  {
    "text": "stack when you enter an interrupt handler checks to see if it's coming from Colonel mode and because it is it",
    "start": "1613360",
    "end": "1618940"
  },
  {
    "text": "thinks it is it skips this code now because we control the threat",
    "start": "1618940",
    "end": "1624700"
  },
  {
    "text": "environment block and GS is the threat environment blocking user mode I believe we've entered this from user mode we",
    "start": "1624700",
    "end": "1630520"
  },
  {
    "text": "could overwrite parts of that threat environment block to cause the CPU to execute code wherever we want but we",
    "start": "1630520",
    "end": "1637630"
  },
  {
    "text": "don't want to do that because that gets a little more complicated what we can do is we can actually just choose an arbitrary GS base thanks to the fact",
    "start": "1637630",
    "end": "1644919"
  },
  {
    "text": "there's an instruction called Ride GS base that lets you set any address there so when the colonel reads GS memory it",
    "start": "1644919",
    "end": "1652330"
  },
  {
    "text": "doesn't dereference your threat environment block it doesn't dereference your processor control region it",
    "start": "1652330",
    "end": "1657700"
  },
  {
    "text": "actually D references memory that you completely control and that makes it even easier to exploit as opposed to",
    "start": "1657700",
    "end": "1663159"
  },
  {
    "text": "just overriding your tab so Nick's gonna do that quick recap just to explain",
    "start": "1663159",
    "end": "1669070"
  },
  {
    "text": "where we're at and what we have now all",
    "start": "1669070",
    "end": "1674470"
  },
  {
    "text": "right perfect so if you're paying attention basically what happens is we we end up firing a DB",
    "start": "1674470",
    "end": "1680890"
  },
  {
    "text": "exception at an entirely unexpected location and operating system developers",
    "start": "1680890",
    "end": "1686200"
  },
  {
    "text": "at the time per the intel and AMD instruction manual were not prepared for",
    "start": "1686200",
    "end": "1692559"
  },
  {
    "text": "this particular case and the handler that they wrote which would be in one handler was not aware the the interrupt",
    "start": "1692559",
    "end": "1700870"
  },
  {
    "text": "that it was currently handling was coming from an untrusted location and so",
    "start": "1700870",
    "end": "1706240"
  },
  {
    "text": "what happens is this gonna start using data that was sent to it that it thinks",
    "start": "1706240",
    "end": "1712659"
  },
  {
    "text": "is kernel data but in reality it's it's user mode data instance says let me explain we control GS base most CPUs to",
    "start": "1712659",
    "end": "1721330"
  },
  {
    "text": "this day support the wor GS based instruction in the event that it did it",
    "start": "1721330",
    "end": "1727020"
  },
  {
    "text": "we can still send it easier mode data from from what's basically the user mode",
    "start": "1727020",
    "end": "1732370"
  },
  {
    "text": "tab it would just be substantially more difficult in at this point basically we need to find",
    "start": "1732370",
    "end": "1738899"
  },
  {
    "text": "instructions that are gonna capitalize on this fact that we're using data that",
    "start": "1738899",
    "end": "1744309"
  },
  {
    "text": "it thinks it's kernel-mode data but in reality it's from user mode and at the",
    "start": "1744309",
    "end": "1750220"
  },
  {
    "text": "very bottom in the event that you might need a new prescription for your glasses",
    "start": "1750220",
    "end": "1755710"
  },
  {
    "text": "we want to we want to turn this into some kind of profit we want to weaponize this so these are my initial weaponizing",
    "start": "1755710",
    "end": "1763090"
  },
  {
    "text": "attempts we're gonna do go through mine then we're gonna go through nemi's over here so at the very beginning I erroneously assumed that",
    "start": "1763090",
    "end": "1771249"
  },
  {
    "text": "there was no encoding for move SS re x which as you can see since it's",
    "start": "1771249",
    "end": "1776320"
  },
  {
    "text": "surrounded in brackets dereferences memory i thought at the time that there was only a mu s SI x which is an",
    "start": "1776320",
    "end": "1783340"
  },
  {
    "text": "immediate value which is in the instruction stream so if you're really actually familiar with how debug",
    "start": "1783340",
    "end": "1788409"
  },
  {
    "text": "registers work you would know that what you see there the move s si X would not actually work as far as the debug",
    "start": "1788409",
    "end": "1795789"
  },
  {
    "text": "register is concerned it would not fire any type of ant one and this was pointed",
    "start": "1795789",
    "end": "1800950"
  },
  {
    "text": "out to us in error by some of the Linux developers thankfully later after we",
    "start": "1800950",
    "end": "1806440"
  },
  {
    "text": "released this exploit but at the time what's important is I tried to weaponize it through pop s s because pop s s is if",
    "start": "1806440",
    "end": "1813940"
  },
  {
    "text": "you're familiar again with assembly pop pops data from the stack he accesses stack memory and so I tried the",
    "start": "1813940",
    "end": "1822999"
  },
  {
    "text": "assumption there is that pop s s is gonna access stack memory so if we arm it with the type of debug register it's",
    "start": "1822999",
    "end": "1828879"
  },
  {
    "text": "going to dereference stack memory and it's going to fire in one unfortunately pop SS in AMD 64 and Intel's version of",
    "start": "1828879",
    "end": "1838029"
  },
  {
    "text": "a 64-bit code it's not valid in their 32-bit compiled a compatibility code",
    "start": "1838029",
    "end": "1844509"
  },
  {
    "text": "segment and on Intel chips syscall is not valid and the reason that that's",
    "start": "1844509",
    "end": "1849730"
  },
  {
    "text": "important is we wanted to use a user mode stack when we execute sis call so",
    "start": "1849730",
    "end": "1855879"
  },
  {
    "text": "at the time I just focus on the invariant and the invariant is basically we execute int and we check the we check",
    "start": "1855879",
    "end": "1863350"
  },
  {
    "text": "the windows and one Handler into using data that we pass it when",
    "start": "1863350",
    "end": "1869530"
  },
  {
    "text": "should have done swaps yes but it actually does it so if you look basically we our goal was to try and",
    "start": "1869530",
    "end": "1877060"
  },
  {
    "text": "find some type of instruction that's going to use or I should say a set of",
    "start": "1877060",
    "end": "1882340"
  },
  {
    "text": "instructions that's going to use GS and if you see right here in the bug check",
    "start": "1882340",
    "end": "1887770"
  },
  {
    "text": "function and the reason bug check if you're from if you're familiar with bug check is actually a blue screen ke bug",
    "start": "1887770",
    "end": "1894130"
  },
  {
    "text": "check X is basically the the initial function of starting a blue screen on the Windows kernel it starts using our",
    "start": "1894130",
    "end": "1902830"
  },
  {
    "text": "CX from data that is actually sent that we send to it so the goal is hey it's",
    "start": "1902830",
    "end": "1909430"
  },
  {
    "text": "reading data it's reading data from a GS that we send it and hopefully it's gonna turn it into something else I mean right",
    "start": "1909430",
    "end": "1915760"
  },
  {
    "text": "now as you can see by the highlighted instructions is reading it but if it's not if it's just gonna read it we're",
    "start": "1915760",
    "end": "1921970"
  },
  {
    "text": "kind of out of luck we kind of have to we kind of have to hope that it's gonna use it for something else and in",
    "start": "1921970",
    "end": "1927700"
  },
  {
    "text": "the actual function that it calls you can see our tail capture contest excuse me RT I'll capture context you see the",
    "start": "1927700",
    "end": "1933850"
  },
  {
    "text": "ends up writing data and if you look carefully all the instructions before",
    "start": "1933850",
    "end": "1939670"
  },
  {
    "text": "the yellow highlight it writes data to a",
    "start": "1939670",
    "end": "1945670"
  },
  {
    "text": "pointer that we put in so RI x RS CX r DX r 8 or 9 r 10 unfortunately those are",
    "start": "1945670",
    "end": "1953890"
  },
  {
    "text": "all collaborate during the interrupt dispatch path process and you'll in our",
    "start": "1953890",
    "end": "1959200"
  },
  {
    "text": "luck the only debt the only register that we controlled was our 11 or 11 would be whatever we send it on input so",
    "start": "1959200",
    "end": "1966550"
  },
  {
    "text": "if we send an input to the exploit at 0 it will be 0 if we send 1 it would be 1",
    "start": "1966550",
    "end": "1971620"
  },
  {
    "text": "in in this particular case we want to do attack GCI options which is the code",
    "start": "1971620",
    "end": "1978670"
  },
  {
    "text": "integrity variable in Windows because we want to load the driver but at the same time we don't want to continue the bug",
    "start": "1978670",
    "end": "1986590"
  },
  {
    "text": "check process because that would completely destroy system state and by the time we actually run kernel code we",
    "start": "1986590",
    "end": "1993010"
  },
  {
    "text": "would be in a situation where where we were recovering the entire system would",
    "start": "1993010",
    "end": "1998320"
  },
  {
    "text": "be very difficult so if you actually look at the highlighted instruction move ApS requires 16 byte alignment so",
    "start": "1998320",
    "end": "2007460"
  },
  {
    "text": "we sent in a particular linear memory address that was not 16 by the lined so",
    "start": "2007460",
    "end": "2013100"
  },
  {
    "text": "since it's not a 16 by the line move ApS actually causes the general protection Fault in since it causes general",
    "start": "2013100",
    "end": "2018890"
  },
  {
    "text": "protection fault it starts the entire bug check process all over executing this entire process",
    "start": "2018890",
    "end": "2024100"
  },
  {
    "text": "repetitive repetitively spinning over and over and over so what we have here is a right what we're voting the same",
    "start": "2024100",
    "end": "2035530"
  },
  {
    "text": "very keeps writing the same memory over and over repetitively and since we have",
    "start": "2035530",
    "end": "2041570"
  },
  {
    "text": "access to other CPUs we can change the memory that it keeps writing to so the",
    "start": "2041570",
    "end": "2048710"
  },
  {
    "text": "goal here was to load a driver obviously an unsigned driver and without getting",
    "start": "2048710",
    "end": "2054050"
  },
  {
    "text": "into deep technical detail you can have you can ask us later at the QA CPU zero",
    "start": "2054050",
    "end": "2059419"
  },
  {
    "text": "has to do the driver loading the reason for that is related to a Peck priority",
    "start": "2059419",
    "end": "2066050"
  },
  {
    "text": "type of interrupts so CPU zero would be the only one that could respond to disk",
    "start": "2066050",
    "end": "2071210"
  },
  {
    "text": "interrupts so CPU zero actually had to do the driver loading well anything",
    "start": "2071210",
    "end": "2076429"
  },
  {
    "text": "other than CPU zero could run the the actual right what where stuff so what",
    "start": "2076429",
    "end": "2083148"
  },
  {
    "text": "that means is that this particular vulnerability requires more than one CPU",
    "start": "2083149",
    "end": "2088190"
  },
  {
    "text": "which in most cases most computers today have more than one CPU on them and this",
    "start": "2088190",
    "end": "2098170"
  },
  {
    "text": "we were stuck because a CPU zero would actually send down TLB shoot downs to",
    "start": "2098170",
    "end": "2103670"
  },
  {
    "text": "the other CPUs and we were kind of screwed because we didn't have we didn't",
    "start": "2103670",
    "end": "2109220"
  },
  {
    "text": "have a rule way to resolve the the packet barrier pointer and we were stuck",
    "start": "2109220",
    "end": "2115970"
  },
  {
    "text": "we we had nothing we could do thankfully by chance Demming he discovered a look every",
    "start": "2115970",
    "end": "2124910"
  },
  {
    "text": "didn't by depth by completely dumb luck while the while just working on some random other than this then we",
    "start": "2124910",
    "end": "2130940"
  },
  {
    "text": "actually discovered up point early to the K PCR so we were able to",
    "start": "2130940",
    "end": "2136050"
  },
  {
    "text": "resolve a pointer to the K PCR and we were able to add that to our right what we're spinning CPU to add that to say",
    "start": "2136050",
    "end": "2143250"
  },
  {
    "text": "that hey all the CPUs are done with their TLB shoot downs and you can continue on with your execution we ran",
    "start": "2143250",
    "end": "2149670"
  },
  {
    "text": "into another problem where that CPU would run out of its double fault stack space and that would flow into its K PCR",
    "start": "2149670",
    "end": "2156480"
  },
  {
    "text": "luckily his pointer leak also gave us appointed to the TSS and we were able to",
    "start": "2156480",
    "end": "2161670"
  },
  {
    "text": "overwrite the double fault stack in that particular case we overrode the double pulse stack to point to user mode memory",
    "start": "2161670",
    "end": "2167850"
  },
  {
    "text": "and I completely solved that problem for us so quick recap here at the end of the",
    "start": "2167850",
    "end": "2175980"
  },
  {
    "text": "day this was really complicated I spent I would say an entire month of my life",
    "start": "2175980",
    "end": "2181470"
  },
  {
    "text": "trying to make this work but end of the day it worked it worked really well and",
    "start": "2181470",
    "end": "2187590"
  },
  {
    "text": "that was the invariant where we're gonna dive into next is Cisco and again with Cisco we end up using a user mode stack",
    "start": "2187590",
    "end": "2194130"
  },
  {
    "text": "executing kernel code nemi's gonna kick it walk us through that yeah it's much",
    "start": "2194130",
    "end": "2199530"
  },
  {
    "text": "much much much easier because you don't have to deal with a lot of complicated",
    "start": "2199530",
    "end": "2204840"
  },
  {
    "text": "things that the int handler forces you to do so what the best thing about system calls when they occur they",
    "start": "2204840",
    "end": "2211350"
  },
  {
    "text": "actually don't do a stack swap so in the terms of the previous exploit when we fire an entry and then we get that",
    "start": "2211350",
    "end": "2218850"
  },
  {
    "text": "pending in one that fires afterwards what ends up happening is because there's a privilege level change we're going from user mode to kernel mode we",
    "start": "2218850",
    "end": "2225210"
  },
  {
    "text": "stop we swap stack now with system calls that doesn't happen actually as part of",
    "start": "2225210",
    "end": "2231420"
  },
  {
    "text": "this just call instruction it's documented well documented you're supposed to update the stack yourself",
    "start": "2231420",
    "end": "2237360"
  },
  {
    "text": "and you can actually see down here this is the system call handler so when assist call fires it goes into ki system",
    "start": "2237360",
    "end": "2243300"
  },
  {
    "text": "call 64 on Windows it does a swap GS and then it loads the appropriate stack pointer on that CPU now because we never",
    "start": "2243300",
    "end": "2252060"
  },
  {
    "text": "actually execute any instructions in cache system call 64 we enter kernel",
    "start": "2252060",
    "end": "2257370"
  },
  {
    "text": "mode with a user mode step and that makes it so so so much easier to exploit",
    "start": "2257370",
    "end": "2264150"
  },
  {
    "text": "so it's functions very similar to in theory but better system call execute in",
    "start": "2264150",
    "end": "2269340"
  },
  {
    "text": "the comp so we user mode at code it branches to the system calls handler which is cat",
    "start": "2269340",
    "end": "2275029"
  },
  {
    "text": "system call 64 before any instruction execute and cache system call 64 that means that swaps yes doesn't execute",
    "start": "2275029",
    "end": "2281630"
  },
  {
    "text": "before any instruction execute that DB that we suppressed by move SS and Papas",
    "start": "2281630",
    "end": "2287420"
  },
  {
    "text": "as fires and we go to the ant one handler which is ki debug trap or fall and then that's entered with the kernel",
    "start": "2287420",
    "end": "2294079"
  },
  {
    "text": "mode CS and with the user mode stack now we're gonna go through the demo code that actually makes this possible it's",
    "start": "2294079",
    "end": "2300380"
  },
  {
    "text": "on git so you should really just check it out there there's a lot of stuff here that happens but a lot of it is just",
    "start": "2300380",
    "end": "2305479"
  },
  {
    "text": "like boilerplate code that needs to happen we need two cpus for this exploit similar to the in three variant the most",
    "start": "2305479",
    "end": "2312019"
  },
  {
    "text": "important thing is we have to figure out where certain key locations of the",
    "start": "2312019",
    "end": "2317989"
  },
  {
    "text": "Windows kernel are in memory so we need to override the driver signing enforcement check so we can load",
    "start": "2317989",
    "end": "2324229"
  },
  {
    "text": "unsigned drivers and then we also need to steal the system token so that we",
    "start": "2324229",
    "end": "2329359"
  },
  {
    "text": "have admin privileges from a trusted application so what we do to do that",
    "start": "2329359",
    "end": "2336619"
  },
  {
    "text": "achieve that functionalities we just load symbols using the Microsoft symbol server so Microsoft has a public website",
    "start": "2336619",
    "end": "2341869"
  },
  {
    "text": "where you can just hit up and contact and get symbols for your particular",
    "start": "2341869",
    "end": "2346880"
  },
  {
    "text": "kernel version that you're running on so as long as that box that we're trying to exploit has Internet activity we can",
    "start": "2346880",
    "end": "2353179"
  },
  {
    "text": "just download symbols that are appropriate for your kernel version touch these undocumented structures",
    "start": "2353179",
    "end": "2358819"
  },
  {
    "text": "things that may change per patch and reliably exploit all the different kernel versions that you know exist",
    "start": "2358819",
    "end": "2367029"
  },
  {
    "text": "furthermore there is a little bit of rap gadgetry that has to happen because",
    "start": "2367029",
    "end": "2372880"
  },
  {
    "text": "nowadays there's a lot of security mitigations especially in Windows 10 that prevent you from executing user",
    "start": "2372880",
    "end": "2379039"
  },
  {
    "text": "mode code with kernel mode privileges that's done through supervisor mode execution prevention that's inside of",
    "start": "2379039",
    "end": "2385640"
  },
  {
    "text": "cr4 and we actually have to disable snap and we do that by using these rap",
    "start": "2385640",
    "end": "2390890"
  },
  {
    "text": "gadgets that allow us to execute in the context of the kernel disable snap and then we jump to our user mode code to",
    "start": "2390890",
    "end": "2397999"
  },
  {
    "text": "make it easy because we don't want to stay in this return oriented programming world forever",
    "start": "2397999",
    "end": "2403060"
  },
  {
    "text": "furthermore again we get all these offsets through those symbols that we'll",
    "start": "2403060",
    "end": "2408460"
  },
  {
    "text": "need and we'll go over why we need those later finally one of the last things that we do is we prepare the process it",
    "start": "2408460",
    "end": "2415480"
  },
  {
    "text": "sounds super generic but because you're not running as an admin you have no way",
    "start": "2415480",
    "end": "2421240"
  },
  {
    "text": "of guaranteeing that windows won't page out parts of your process and if it's paging out memory in the side of your",
    "start": "2421240",
    "end": "2427060"
  },
  {
    "text": "user mode application that you need for your exploit to work like screws you over so we make strong suggestions to",
    "start": "2427060",
    "end": "2434140"
  },
  {
    "text": "the memory manager to be like hey try not to page out this GS base that we've",
    "start": "2434140",
    "end": "2439150"
  },
  {
    "text": "allocated otherwise we'll throw a page fault and then the exploit will get screwed up and then far finally what we",
    "start": "2439150",
    "end": "2447010"
  },
  {
    "text": "do is we set that Hardware breakpoint prime it on that location that move SS will read from we execute our ASM",
    "start": "2447010",
    "end": "2454390"
  },
  {
    "text": "function which will prepare the CPU and then start the core of the exploit again",
    "start": "2454390",
    "end": "2459910"
  },
  {
    "text": "this is gonna be more or less step through in the next slide so we won't go too much into details here CPU 1 then we",
    "start": "2459910",
    "end": "2469090"
  },
  {
    "text": "need 2 CPU CPU 0 execute the exploit CPU one constantly probes stack memory that",
    "start": "2469090",
    "end": "2475180"
  },
  {
    "text": "CPU 0 is executing under and the goal is to override a return address that CPU 0",
    "start": "2475180",
    "end": "2480880"
  },
  {
    "text": "is going to return from and then we're gonna go into our wrap gadgets that we found earlier which will then disable",
    "start": "2480880",
    "end": "2488080"
  },
  {
    "text": "snap and jump to our user mode code finally this will also be demonstrated",
    "start": "2488080",
    "end": "2494530"
  },
  {
    "text": "later so we'll just go to the video that's necessary to re-enable snap and",
    "start": "2494530",
    "end": "2499660"
  },
  {
    "text": "then restore the kernel back so in our VM we have this little batch file all it does is it loads a driver and then",
    "start": "2499660",
    "end": "2507220"
  },
  {
    "text": "starts it using the service manager very simple we try to run this batch file from an admin command prompt but we can",
    "start": "2507220",
    "end": "2514330"
  },
  {
    "text": "see that's clearly not signed with a valid digital certificate there's a little error and the machine isn't",
    "start": "2514330",
    "end": "2519610"
  },
  {
    "text": "booted in test signing mode so it won't accept this so if we run this in an admin power shell it said it says",
    "start": "2519610",
    "end": "2525520"
  },
  {
    "text": "Windows cannot verify the digital signature for this file it's not valid it's not a valid digital signature now",
    "start": "2525520",
    "end": "2531520"
  },
  {
    "text": "if we try to run this from a power shell that doesn't have a admin access you don't even get to the driver signing check",
    "start": "2531520",
    "end": "2536680"
  },
  {
    "text": "it just as access is denied you don't have privileges to even get that far so what we do is we run the exploit first",
    "start": "2536680",
    "end": "2542020"
  },
  {
    "text": "and then we install the driver and that should give us everything so to get to",
    "start": "2542020",
    "end": "2547510"
  },
  {
    "text": "how a lot of this works we're gonna break in again using that gdb stop that VMware provides that we can debug the",
    "start": "2547510",
    "end": "2554349"
  },
  {
    "text": "hypervisor we break in in a spin lock similar to the denial-of-service proof-of-concept I'm gonna load symbols",
    "start": "2554349",
    "end": "2561790"
  },
  {
    "text": "for my exploit just so that it's easier to read what's going on on the screen shouldn't take too long",
    "start": "2561790",
    "end": "2569130"
  },
  {
    "text": "and then we specify that address the base address of where it's loaded into memory we're gonna knock out this jump",
    "start": "2569130",
    "end": "2575559"
  },
  {
    "text": "like we did for the previous example so we can progress all right so now we set",
    "start": "2575559",
    "end": "2586059"
  },
  {
    "text": "the GS base to whatever we want in this case this is our GS base that's under our control",
    "start": "2586059",
    "end": "2591490"
  },
  {
    "text": "we run move SS and then we enter using sis call so what should happen is we",
    "start": "2591490",
    "end": "2597309"
  },
  {
    "text": "should go to the system call handler but because of CAD debug trap or faults behavior we get thrown into the Antwone",
    "start": "2597309",
    "end": "2602859"
  },
  {
    "text": "handler because of the move SS behavior and you can see that we're coming from ki system call 64 and this means that",
    "start": "2602859",
    "end": "2611309"
  },
  {
    "text": "now we're assuming that we're coming from kernel mode so when we access this memory this GS memory that we're",
    "start": "2611309",
    "end": "2617319"
  },
  {
    "text": "touching all over the kernel it has to be valid and that's part of what our exploit does our code exploit has to set",
    "start": "2617319",
    "end": "2622750"
  },
  {
    "text": "up this GS memory to be valid and all of this is under our control everything that touches GS is directly under our",
    "start": "2622750",
    "end": "2628510"
  },
  {
    "text": "control eventually we get to the dispatching of the exception and then we",
    "start": "2628510",
    "end": "2636549"
  },
  {
    "text": "choose a return address on the stack to override and we chose an arbitrary function later on during exception",
    "start": "2636549",
    "end": "2642700"
  },
  {
    "text": "handling that CPU one will override in this case the function that we chose is ke context from K frames you can see at",
    "start": "2642700",
    "end": "2649809"
  },
  {
    "text": "the bottom of the stack we've actually overwritten the return address to go to our wrap gadget that we found now you",
    "start": "2649809",
    "end": "2655390"
  },
  {
    "text": "can see on CPU one which I just swapped to you can see that stack pointer points to that memory that we just over on CPU",
    "start": "2655390",
    "end": "2662410"
  },
  {
    "text": "zero so if we go to the CPU zero you can see that's the same address and you can validate that by looking at the slides",
    "start": "2662410",
    "end": "2668230"
  },
  {
    "text": "later and the vid later finally this functions pretty big and that's why we chose to overwrite return its return address because it's",
    "start": "2668230",
    "end": "2674780"
  },
  {
    "text": "long and that's the goal like hopefully it takes a while to execute so that we are able to override it on CPU one lots",
    "start": "2674780",
    "end": "2681470"
  },
  {
    "text": "of xmm operations eventually we will do a return to get out of this function and",
    "start": "2681470",
    "end": "2686630"
  },
  {
    "text": "then we go into our wrap gadget a wrap gadget does a big stack change so we do",
    "start": "2686630",
    "end": "2691850"
  },
  {
    "text": "that massive ad RSP so that we don't have bad memory to work with we load cr4",
    "start": "2691850",
    "end": "2700280"
  },
  {
    "text": "with the value that we choose the disable supervisor mode execution prevention and then we return out and",
    "start": "2700280",
    "end": "2707030"
  },
  {
    "text": "finally we're executing our payload so in user mode as CPL zero we are setting",
    "start": "2707030",
    "end": "2714950"
  },
  {
    "text": "up a way to come back and recover the operating system we steal the system token from the system process so that we",
    "start": "2714950",
    "end": "2721940"
  },
  {
    "text": "have admin rights to load the driver we disable driver signing enforcement to get past that second barrier finally we",
    "start": "2721940",
    "end": "2729230"
  },
  {
    "text": "set up the IRET stack so we can return back to our user mode code we re-enable snap and we're in user mode we're back",
    "start": "2729230",
    "end": "2738140"
  },
  {
    "text": "in our program we're gonna hit play and we're executing under empty authority system and now we'll run the driver and",
    "start": "2738140",
    "end": "2745910"
  },
  {
    "text": "we actually loaded there's no error message anymore we have ring zero",
    "start": "2745910",
    "end": "2751660"
  },
  {
    "text": "privileges and the Machine is pop",
    "start": "2751660",
    "end": "2756880"
  },
  {
    "text": "cool so too I don't have a lot of time left so I'll go over this really quickly",
    "start": "2757980",
    "end": "2764859"
  },
  {
    "text": "a lot of this was patched in May that Microsoft Research did a nsrc the really",
    "start": "2764859",
    "end": "2770560"
  },
  {
    "text": "good inter company as well as like reaching out to other OS vendors that",
    "start": "2770560",
    "end": "2776080"
  },
  {
    "text": "were impacted by this so shout out to them to helping coordinate a lot of these fixes they fix a lot of these",
    "start": "2776080",
    "end": "2781180"
  },
  {
    "text": "problems in May I think most operating systems should be patched now they followed the suggestion that was made in",
    "start": "2781180",
    "end": "2786609"
  },
  {
    "text": "our white paper so you can you know check that out the may s the magic is",
    "start": "2786609",
    "end": "2791859"
  },
  {
    "text": "that ki debug trap our fault now we'll use a known good stack regardless of how",
    "start": "2791859",
    "end": "2797170"
  },
  {
    "text": "you enter it even if you enter it from kernel mode it will use a known good stack just like the double fault handler",
    "start": "2797170",
    "end": "2802599"
  },
  {
    "text": "that means you can't abuse this call anymore and farther more GS GS memory is never",
    "start": "2802599",
    "end": "2807910"
  },
  {
    "text": "dereferenced until you're known to be in a good state and the way you're known to be in the good States by checking ki",
    "start": "2807910",
    "end": "2813160"
  },
  {
    "text": "debug traps and caddy about traps is basically an array that contains function pointers that you could enter",
    "start": "2813160",
    "end": "2819310"
  },
  {
    "text": "from user mode and the goal is if you throw an INT one from any one of these",
    "start": "2819310",
    "end": "2825099"
  },
  {
    "text": "you're not allowed to progress and you just I read out so it avoids that exploit now Nick's gonna wrap it up with",
    "start": "2825099",
    "end": "2831010"
  },
  {
    "text": "some shoutouts to some industry folks all right so we have a couple of shots we'd like to give Alex I and sq I don't",
    "start": "2831010",
    "end": "2837970"
  },
  {
    "text": "know if he's out there maybe you are maybe you're not he actually named our exploit why so serious I think it's appropriate I actually",
    "start": "2837970",
    "end": "2843849"
  },
  {
    "text": "think it's a pretty cool name and then a jam Baluch he did a weaponizing on the invariant it's actually really cool he",
    "start": "2843849",
    "end": "2850599"
  },
  {
    "text": "did it much faster than I did so you actually see the link here to his blog and then to his weaponizing work it's",
    "start": "2850599",
    "end": "2858339"
  },
  {
    "text": "definitely some cool there you should check that out and then uh so what are some lessons we learned here on how to make how to do bug bounties",
    "start": "2858339",
    "end": "2865210"
  },
  {
    "text": "so you have to have a really cool name for your exploit maybe you want to get",
    "start": "2865210",
    "end": "2870490"
  },
  {
    "text": "that off a light goes box for ages 6 to 12 maybe I don't know how to expect their meltdown you you know come up with",
    "start": "2870490",
    "end": "2876369"
  },
  {
    "text": "a cool name and then you might want to pay a graphics designer to come up with some type of some type of graphic for",
    "start": "2876369",
    "end": "2883060"
  },
  {
    "text": "vulnerability because apparently that's the thing today and then you also want to have a great soundtrack for your",
    "start": "2883060",
    "end": "2888760"
  },
  {
    "text": "vulnerability all the vulnerabilities have a great soundtracks these days definitely want",
    "start": "2888760",
    "end": "2894100"
  },
  {
    "text": "to come up with some some good music - hi Pierre your vulnerability and then last but not least world star exclusive",
    "start": "2894100",
    "end": "2899560"
  },
  {
    "text": "if you're not world star exclusive you just it's not a good vulnerability at the end of the day thank you that's our",
    "start": "2899560",
    "end": "2906760"
  },
  {
    "text": "logo that's the white paper like retweet and subscribe",
    "start": "2906760",
    "end": "2913290"
  }
]