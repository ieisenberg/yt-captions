[
  {
    "start": "0",
    "end": "60000"
  },
  {
    "text": "[Music]",
    "start": "910",
    "end": "8720"
  },
  {
    "text": "hello everyone welcome to our presentation at blackhead europe today our topic is the out of exporting user 3",
    "start": "8720",
    "end": "14799"
  },
  {
    "text": "by written to bpf in android kernel here's the gender we will introduce the internals of the effective model in the",
    "start": "14799",
    "end": "22000"
  },
  {
    "text": "android common kernel including the path vulnerabilities and then analyze the user-free bug cbe",
    "start": "22000",
    "end": "28240"
  },
  {
    "text": "2021 0399 we will later talk about how to exploit the vulnerability or modern",
    "start": "28240",
    "end": "34480"
  },
  {
    "text": "android device including a demo video moreover i will talk about another user",
    "start": "34480",
    "end": "40000"
  },
  {
    "text": "free bug found in this kind of module while i'm writing the park richard will talk about android",
    "start": "40000",
    "end": "45280"
  },
  {
    "text": "kind of mitigations and how google detects as excellent code at scale fibrous approaches",
    "start": "45280",
    "end": "51840"
  },
  {
    "text": "cool so let's take a look at the affected endocrine model xt on the score qtgid",
    "start": "51840",
    "end": "59359"
  },
  {
    "text": "the module is mainly used for tracking the network traffic on a per second basis for unique app 693 it is replaced",
    "start": "59359",
    "end": "67680"
  },
  {
    "start": "60000",
    "end": "60000"
  },
  {
    "text": "by ebpf since ngq so on android pi and or versions are affected and basically",
    "start": "67680",
    "end": "73360"
  },
  {
    "text": "how it works is that a user space program may send command data to the",
    "start": "73360",
    "end": "78960"
  },
  {
    "text": "current module such as asking kernel to tag a socket or on text socket",
    "start": "78960",
    "end": "85360"
  },
  {
    "text": "circuit basically means we want the engine kernel to check the specific socket file descriptor and provide",
    "start": "85360",
    "end": "91759"
  },
  {
    "text": "network usage information back to the user space and you can interact with the kernel",
    "start": "91759",
    "end": "97280"
  },
  {
    "text": "module by adb or you may use android apis like traffic status",
    "start": "97280",
    "end": "102560"
  },
  {
    "text": "i'm cool now i will introduce three different uh scenarios open the module tag socket and contact socket",
    "start": "102560",
    "end": "111360"
  },
  {
    "start": "111000",
    "end": "111000"
  },
  {
    "text": "one use this program open the kernel module the model will allocate two different structures in respect of per",
    "start": "111680",
    "end": "118240"
  },
  {
    "text": "uid and pid and as you can see there will be only one unique uid tag data",
    "start": "118240",
    "end": "123360"
  },
  {
    "text": "structure but there might be multiple procedure data structures for every pid which are essentially linked to the uid",
    "start": "123360",
    "end": "130720"
  },
  {
    "text": "tab data structure and while i use this space program text socket it has to provide all sorts of",
    "start": "130720",
    "end": "138800"
  },
  {
    "text": "information such as the socket file description user id etc",
    "start": "138800",
    "end": "144239"
  },
  {
    "text": "and two different data structures will be allocated in terms of the uid and the",
    "start": "144239",
    "end": "149440"
  },
  {
    "text": "pid so first of all the model will find the corresponding ui detect data structure",
    "start": "149440",
    "end": "156800"
  },
  {
    "text": "from ui detect data tree which is a global variable advocate structure tech graph and",
    "start": "156800",
    "end": "162800"
  },
  {
    "text": "initialize the tag and the reference columns and also following the similar pattern the kernel will find prog q2",
    "start": "162800",
    "end": "169519"
  },
  {
    "text": "data from a global variable and allocate a structure called subtab and different subtext structures are",
    "start": "169519",
    "end": "175840"
  },
  {
    "text": "linked together as you can see please remember the subtext structure",
    "start": "175840",
    "end": "180959"
  },
  {
    "text": "because later we will see a user free happens here cool so here is the overview of all the",
    "start": "180959",
    "end": "188720"
  },
  {
    "text": "related kernel data structures while socket is tactic and as we mentioned in the last slide",
    "start": "188720",
    "end": "195200"
  },
  {
    "text": "the model will create tech rep structure and subtext structures so",
    "start": "195200",
    "end": "201360"
  },
  {
    "text": "when a circuit is untacted the relevance come in the tag wrap is decreased",
    "start": "201360",
    "end": "208080"
  },
  {
    "text": "and subtac is unlinked from the linked list and three later you may also",
    "start": "208080",
    "end": "213519"
  },
  {
    "text": "imagine the basic idea of how cleanup works when a user decides to cross module is",
    "start": "213519",
    "end": "219680"
  },
  {
    "text": "that all the related socket tag and proxy to this data structure will be unlinked and free",
    "start": "219680",
    "end": "227280"
  },
  {
    "text": "cool so since the model was introduced in android since 2011 there were two",
    "start": "227280",
    "end": "233840"
  },
  {
    "text": "vulnerabilities reported to google in the past so the first bug is cv 2016 3809 this",
    "start": "233840",
    "end": "242400"
  },
  {
    "text": "one is pretty well known it's very important kernel information leak issue for leaking the kernel stock address",
    "start": "242400",
    "end": "248640"
  },
  {
    "text": "you may just read the certified system and the raw pointer is written to the",
    "start": "248640",
    "end": "253680"
  },
  {
    "text": "user space it helps a lot of exploit to make them more stable and easier to exploit the",
    "start": "253680",
    "end": "259120"
  },
  {
    "text": "kernel such as the pinball expert the root cause is pretty obvious because",
    "start": "259120",
    "end": "264240"
  },
  {
    "text": "the format string is not applied properly so a novel user may might be able to",
    "start": "264240",
    "end": "271199"
  },
  {
    "text": "read the draw pointed address cool the other one is a user-free on",
    "start": "271199",
    "end": "277600"
  },
  {
    "start": "275000",
    "end": "275000"
  },
  {
    "text": "tag wrap tree by risk condition due to improv blocking so as you can see from",
    "start": "277600",
    "end": "283919"
  },
  {
    "text": "2011 to 2020 there are only two vulnerabilities in this model and the",
    "start": "283919",
    "end": "289520"
  },
  {
    "text": "model got replaced since ngq by ebpl so what can possibly go wrong in 2021",
    "start": "289520",
    "end": "297199"
  },
  {
    "text": "um the bug was reported by the external researcher earlier this year saying that",
    "start": "297199",
    "end": "302400"
  },
  {
    "text": "there is a financial user free under certain conditions no proof of concept or exploitation details provided",
    "start": "302400",
    "end": "310960"
  },
  {
    "text": "but researchers believe it's impossible to export our modern devices because of",
    "start": "310960",
    "end": "316400"
  },
  {
    "text": "the hardware level mitigation user access overwrite which is enabled on kernel 4.14 by",
    "start": "316400",
    "end": "322960"
  },
  {
    "text": "default and usually android x3 will choose to temper the address limit so",
    "start": "322960",
    "end": "328080"
  },
  {
    "text": "the expert can use pipe cisco to do actually kind of read and write there are a lot of ways to",
    "start": "328080",
    "end": "334720"
  },
  {
    "text": "temper the address limit like for instance you may set up a drop job",
    "start": "334720",
    "end": "340240"
  },
  {
    "text": "to several well no kind of functions and the kernel is happy to override the address limit for you",
    "start": "340240",
    "end": "346320"
  },
  {
    "text": "but with the user access override mitigation it's not likely to export currently this way and",
    "start": "346320",
    "end": "353520"
  },
  {
    "text": "that's why external researchers believe the vulnerability might not be able to export on modern devices and thus the",
    "start": "353520",
    "end": "360960"
  },
  {
    "text": "google industry team decided to investigate the likelihood of exploitation this vulnerability",
    "start": "360960",
    "end": "366479"
  },
  {
    "text": "and see if it still works on modern devices therefore when the bug was reported to",
    "start": "366479",
    "end": "372800"
  },
  {
    "text": "google richard quickly wrote a minimum part for kendall crash it's very simple as you can see a text",
    "start": "372800",
    "end": "379120"
  },
  {
    "text": "socket and then untag the socket from chart process x to program and kind of",
    "start": "379120",
    "end": "384479"
  },
  {
    "text": "crash so how is it possible let's take a closer look at how on text",
    "start": "384479",
    "end": "390720"
  },
  {
    "text": "okay actually works because one a user space program opens the module as",
    "start": "390720",
    "end": "396960"
  },
  {
    "text": "we said before the model will create procured data structure by pid",
    "start": "396960",
    "end": "402800"
  },
  {
    "text": "so first of all the kernel module tries to find the corresponding pro qd data",
    "start": "402800",
    "end": "408400"
  },
  {
    "text": "structure based on pid then unlinks the subtab structure and",
    "start": "408400",
    "end": "414319"
  },
  {
    "text": "free it however as you can see there is a starting check it says like if the",
    "start": "414319",
    "end": "421680"
  },
  {
    "text": "procured data structure is not found by pid the model will complain without",
    "start": "421680",
    "end": "427120"
  },
  {
    "text": "doing anything but the subject text structure will still get free later so we have a free",
    "start": "427120",
    "end": "433759"
  },
  {
    "text": "subtext structure resize in the subtab link list",
    "start": "433759",
    "end": "439360"
  },
  {
    "text": "cool so next step is about how to actually this vulnerability so let's see how to accelerate this that",
    "start": "439360",
    "end": "446639"
  },
  {
    "text": "this vulnerability to modern android pipe device which has the adjusted limit check user access",
    "start": "446639",
    "end": "452960"
  },
  {
    "text": "overwrite slap release random and harden mitigations and later i will show video",
    "start": "452960",
    "end": "458400"
  },
  {
    "text": "on how to exploit xiaomi mi 9 device with the latest kind of version 4.14 for",
    "start": "458400",
    "end": "463919"
  },
  {
    "text": "android pi with the aforementioned mitigations cool um so",
    "start": "463919",
    "end": "469440"
  },
  {
    "start": "467000",
    "end": "467000"
  },
  {
    "text": "first of all if you are not very familiar with android kind of expectations most android",
    "start": "469440",
    "end": "475120"
  },
  {
    "text": "devices nowadays use k malloc 108 as the minimum size of the step object so the",
    "start": "475120",
    "end": "482000"
  },
  {
    "text": "size of the object allocated by k malloc is actually 128 bytes",
    "start": "482000",
    "end": "488639"
  },
  {
    "text": "the first kind of system we want to abuse is eventfd so as you can see the member count",
    "start": "488639",
    "end": "495360"
  },
  {
    "text": "overlaps the leasehold in the subtext structure the idea for",
    "start": "495360",
    "end": "501520"
  },
  {
    "text": "doing kernel heap league is that well subtech is already free",
    "start": "501520",
    "end": "507840"
  },
  {
    "text": "spread event fd to make sure an event of these structures occupy the free uh sub",
    "start": "507840",
    "end": "513919"
  },
  {
    "text": "tax structure and now you can see two stock tax structure linked together",
    "start": "513919",
    "end": "519518"
  },
  {
    "text": "and the left side is spread by event of d",
    "start": "519519",
    "end": "524880"
  },
  {
    "text": "cool and then we untag the subtext structure on the right side",
    "start": "524880",
    "end": "530000"
  },
  {
    "text": "so the only primitive will overwrite come to the address of the list head",
    "start": "530000",
    "end": "536320"
  },
  {
    "text": "and then we can read the certified system to get the count from the event empty so we can",
    "start": "536320",
    "end": "544080"
  },
  {
    "text": "leak kernel keep addresses and later turn this into a special kind of w3",
    "start": "544080",
    "end": "550240"
  },
  {
    "start": "550000",
    "end": "550000"
  },
  {
    "text": "so a knife idea for getting double free in this case is that",
    "start": "550240",
    "end": "556640"
  },
  {
    "text": "you may ask for this user free vulnerability and probably craft to",
    "start": "556640",
    "end": "561680"
  },
  {
    "text": "same subtext structure so kernel might be able to like release a sub",
    "start": "561680",
    "end": "567839"
  },
  {
    "text": "structure twice but essentially the kernel model also has to like unlink the subtext structure",
    "start": "567839",
    "end": "574560"
  },
  {
    "text": "and free them later so what happens if we have uh two identical stock tax",
    "start": "574560",
    "end": "579839"
  },
  {
    "text": "structures or the stock tax charge has the invalid attack",
    "start": "579839",
    "end": "585360"
  },
  {
    "text": "obvious silicon will crash because there are several security checks in the cleanup code so for example if we crop a",
    "start": "585360",
    "end": "592640"
  },
  {
    "text": "circuit structure with embedded tag the kernel crashes because the corresponding tag rep structure does not",
    "start": "592640",
    "end": "599200"
  },
  {
    "text": "exist and if we create two identical subtext structure the reference card will become",
    "start": "599200",
    "end": "605360"
  },
  {
    "text": "invalid so kind of word crash 2. therefore in order to bypass all the security",
    "start": "605360",
    "end": "612720"
  },
  {
    "text": "checks here is the way i figure out so first of all untapped the subtab b structure by a",
    "start": "612720",
    "end": "620800"
  },
  {
    "text": "chart process so we have a user free first okay",
    "start": "620800",
    "end": "626560"
  },
  {
    "text": "and then we spray event fd to occupy the subtext b structure",
    "start": "626560",
    "end": "633279"
  },
  {
    "text": "and then on tag the circuit text structure c so the unlinked primitive will help us",
    "start": "633279",
    "end": "639200"
  },
  {
    "text": "link the address of the subtext tag c okay and similarly you may leak the list head",
    "start": "639200",
    "end": "646720"
  },
  {
    "text": "address as we mentioned earlier and there are also the subtext structure e f and g",
    "start": "646720",
    "end": "653040"
  },
  {
    "text": "in the linked list but we will talk about them later so uh now in order to bypass the",
    "start": "653040",
    "end": "658640"
  },
  {
    "text": "security checks we have to spray the first two objects and do tech impersonation",
    "start": "658640",
    "end": "665360"
  },
  {
    "text": "okay so the original tag are b and d and now we already overwrite the tag to",
    "start": "665360",
    "end": "672640"
  },
  {
    "text": "enf and then overwrite the next list to the",
    "start": "672640",
    "end": "677760"
  },
  {
    "text": "this header node so we actually unlink the subtext structure e fg from the linked list and the model cleanup code",
    "start": "677760",
    "end": "684959"
  },
  {
    "text": "will never see them on the subtac link list we may also have to free these two",
    "start": "684959",
    "end": "690160"
  },
  {
    "text": "crafted objects because the first eight bytes of the object must be a valid address for rb erase operation",
    "start": "690160",
    "end": "697279"
  },
  {
    "text": "okay so in this we may free the crafted circuit text gestures without changing any",
    "start": "697279",
    "end": "704480"
  },
  {
    "text": "kernel checks we will later use this primitive for performing a specialty free",
    "start": "704480",
    "end": "710639"
  },
  {
    "text": "okay and by the way four devices are still vulnerable to cv 2016-3809",
    "start": "710639",
    "end": "718760"
  },
  {
    "text": "exporting the kernel might be much easier because we can abuse the subpoena",
    "start": "718800",
    "end": "724240"
  },
  {
    "text": "from the model cleanup code and craft a corrupted kind of stock structure okay and",
    "start": "724240",
    "end": "731360"
  },
  {
    "start": "729000",
    "end": "729000"
  },
  {
    "text": "if you check the size of the subtext gesture it's 64 bytes",
    "start": "731360",
    "end": "736720"
  },
  {
    "text": "so luckily a 128 by slab object can hold two subtext structure and thus we may",
    "start": "736720",
    "end": "742720"
  },
  {
    "text": "impersonate the tag g and craft another subtext structure in the same slab object",
    "start": "742720",
    "end": "749200"
  },
  {
    "text": "and when the model is doing a clean up the mod the kind of model will free the",
    "start": "749200",
    "end": "754320"
  },
  {
    "text": "suck tag and free the sub tag in the middle consequently which will help us the canoeists area by this special",
    "start": "754320",
    "end": "761120"
  },
  {
    "text": "candidate free and to recognize here we may consider",
    "start": "761120",
    "end": "766639"
  },
  {
    "text": "smearing the slab at the beginning of the x-ray in this following way and keep",
    "start": "766639",
    "end": "771760"
  },
  {
    "text": "opening the proc cpu info for asking the kernel allocated in terms of sequence file",
    "start": "771760",
    "end": "777519"
  },
  {
    "text": "structures because of the w3 the sequence file structures are likely to overlap each other in this",
    "start": "777519",
    "end": "784839"
  },
  {
    "text": "case okay the overlapped event fd and sequence",
    "start": "784839",
    "end": "790160"
  },
  {
    "text": "file leads to a very interesting result that comes from the event fd",
    "start": "790160",
    "end": "796720"
  },
  {
    "text": "now becomes a sequence operation and luckily the spin lock from the event fd context just works because it",
    "start": "796720",
    "end": "804079"
  },
  {
    "text": "overlapped the spin lock from the sequence file structure so we can easily connect there",
    "start": "804079",
    "end": "811519"
  },
  {
    "start": "811000",
    "end": "811000"
  },
  {
    "text": "and if the staff release is not hardened you may also abuse double free primitive to do kernel space mirror attack",
    "start": "811519",
    "end": "818639"
  },
  {
    "text": "but unfortunately the mitigation is enabled in midnight device so abusing the double free primate",
    "start": "818639",
    "end": "826000"
  },
  {
    "text": "directly is not very possible there are also other candidates such as",
    "start": "826000",
    "end": "831760"
  },
  {
    "text": "escape underscore put where you may control the sub gesture",
    "start": "831760",
    "end": "836880"
  },
  {
    "text": "it might be possible to use this preemptive to disable assignments and could canopy restriction",
    "start": "836880",
    "end": "843839"
  },
  {
    "start": "843000",
    "end": "843000"
  },
  {
    "text": "but my approach is to override the sequence operation because sequence operation contains several kind of",
    "start": "844480",
    "end": "849839"
  },
  {
    "text": "function pointer so tempering the sequence operation might be a king injection for us so",
    "start": "849839",
    "end": "857920"
  },
  {
    "text": "let's take a look at event fdm not only you can use event fd to leak kernel information",
    "start": "857920",
    "end": "865279"
  },
  {
    "text": "we can also write data to the event of defined exclusion and override the count so in this case",
    "start": "865279",
    "end": "872240"
  },
  {
    "text": "we can control the count from the eventfd which is equivalent to",
    "start": "872240",
    "end": "877920"
  },
  {
    "text": "overwriting the sequence operation but since we have a lot of file descriptor over in the cpu info how can",
    "start": "877920",
    "end": "885519"
  },
  {
    "text": "we find the file descriptor of the overlapped sequence or sequence file object",
    "start": "885519",
    "end": "891760"
  },
  {
    "text": "my solution is to overwrite the sequence operation from cpu info op to consolesub and read data",
    "start": "891760",
    "end": "899120"
  },
  {
    "text": "from every file descriptor so we can find the corresponding file description",
    "start": "899120",
    "end": "905920"
  },
  {
    "start": "905000",
    "end": "905000"
  },
  {
    "text": "and as we mentioned before now the challenge is to craft a sequence operation to control",
    "start": "905920",
    "end": "912959"
  },
  {
    "text": "kernel ip and perform an escalation of privilege we might need to spray a sequence file",
    "start": "912959",
    "end": "919519"
  },
  {
    "text": "again in order to ask kernel to use the crafted sequence operation correctly and if user access override is not",
    "start": "919519",
    "end": "926639"
  },
  {
    "text": "enabled you may use the drop gadget on the kernel guest software function to",
    "start": "926639",
    "end": "932160"
  },
  {
    "text": "gracefully temper the address limit but unfortunately it doesn't work on 4.4 in kernel the kernel will check the address",
    "start": "932160",
    "end": "939199"
  },
  {
    "text": "and limit during error ciscos and kernel enables hardware level mitigation user access overwrite",
    "start": "939199",
    "end": "945600"
  },
  {
    "text": "so we have to find another way to properly fill the",
    "start": "945600",
    "end": "951120"
  },
  {
    "text": "drop gadget um as mentioned by project zero we can invoke bpf program as the",
    "start": "951120",
    "end": "959040"
  },
  {
    "start": "953000",
    "end": "953000"
  },
  {
    "text": "ultimate rob if the second argument is the address of",
    "start": "959040",
    "end": "964240"
  },
  {
    "text": "the bpf instructions then kernel is very happy to ask you arbitrary bpf",
    "start": "964240",
    "end": "969360"
  },
  {
    "text": "instructions without verification thus we can use this ultimate drop to do the local escalation",
    "start": "969360",
    "end": "976639"
  },
  {
    "text": "of privilege and as a consequence you can get an abstract kind of read and write",
    "start": "976639",
    "end": "983120"
  },
  {
    "text": "primitive for instance you may disable kernel pointed risk and say linux",
    "start": "983120",
    "end": "989600"
  },
  {
    "start": "989000",
    "end": "989000"
  },
  {
    "text": "and also you can you can hammer the",
    "start": "989600",
    "end": "994480"
  },
  {
    "text": "stock escape correct by executing upgrade bpf instructions and finally get a routine you can put",
    "start": "994959",
    "end": "1002880"
  },
  {
    "text": "the bvf instructions in a step 110 bytes object because these bvf",
    "start": "1002880",
    "end": "1008839"
  },
  {
    "text": "instructions are just 108 bytes okay cool so",
    "start": "1008839",
    "end": "1014480"
  },
  {
    "text": "here is the video demo video about tons midnight device",
    "start": "1014480",
    "end": "1020240"
  },
  {
    "text": "in 10 seconds",
    "start": "1020240",
    "end": "1023720"
  },
  {
    "text": "so now we have russia",
    "start": "1030640",
    "end": "1033760"
  },
  {
    "text": "cool",
    "start": "1036880",
    "end": "1039839"
  },
  {
    "text": "one more thing about this kind of module is that i found another user free vulnerability when writing the puck uh",
    "start": "1042000",
    "end": "1048400"
  },
  {
    "text": "it's basically a risk condition so when cpu0 gets the lock retrieve an object",
    "start": "1048400",
    "end": "1055679"
  },
  {
    "text": "from q release the log and read the tag from the object uh however another cpu may grab the lock",
    "start": "1055679",
    "end": "1063600"
  },
  {
    "text": "free object and drop the log so on project applications may talk to",
    "start": "1063600",
    "end": "1071200"
  },
  {
    "text": "uh network standard manager in a very conventional way and lead kind of",
    "start": "1071200",
    "end": "1076480"
  },
  {
    "text": "information it's probably going to take some time for leaking kernel information but it works",
    "start": "1076480",
    "end": "1082320"
  },
  {
    "text": "so the patch is to make sure the object read operation is also protected by the lock",
    "start": "1082320",
    "end": "1089440"
  },
  {
    "start": "1089000",
    "end": "1089000"
  },
  {
    "text": "so the summary of x protein cv 2021 0399 is that first of all we have to get a",
    "start": "1089440",
    "end": "1096160"
  },
  {
    "text": "special kind of free primitive and the overlapping event and sequence",
    "start": "1096160",
    "end": "1101679"
  },
  {
    "text": "file structures can hijack the control flow by crafting sequence operation by",
    "start": "1101679",
    "end": "1107039"
  },
  {
    "text": "writing to the event fd descriptor and also by reading the event id5",
    "start": "1107039",
    "end": "1113039"
  },
  {
    "text": "descriptor we can leak kernel information also if user's override mitigation is",
    "start": "1113039",
    "end": "1119120"
  },
  {
    "text": "enabled return to bpf might be on your friends and now please work on regional for the",
    "start": "1119120",
    "end": "1125520"
  },
  {
    "text": "rest of presentation about defensive side now that xinyu has explained the",
    "start": "1125520",
    "end": "1131440"
  },
  {
    "text": "exploitation i'll look at some of the mitigations making this more difficult or impossible and then review some of",
    "start": "1131440",
    "end": "1138000"
  },
  {
    "text": "our defensive systems that help us find malicious software starting with kernel mitigations the",
    "start": "1138000",
    "end": "1145120"
  },
  {
    "start": "1142000",
    "end": "1142000"
  },
  {
    "text": "first one is a compilation setting affecting pointers in the free lists maintained by memory management",
    "start": "1145120",
    "end": "1151760"
  },
  {
    "text": "added in linux 4.14 in november 2017 config slab free list hardened excels",
    "start": "1151760",
    "end": "1158960"
  },
  {
    "text": "the free list pointer in slub caches with a per cash random value this makes",
    "start": "1158960",
    "end": "1164000"
  },
  {
    "text": "exploiting free list pointer overrides more difficult as unless the attacker also knows the xor value they don't get",
    "start": "1164000",
    "end": "1171280"
  },
  {
    "text": "control of the memory address this can be bypassed using the signal fd technique shown on the slide and",
    "start": "1171280",
    "end": "1177679"
  },
  {
    "text": "described earlier spraying signal fd context structures allows a mostly user-specified value to",
    "start": "1177679",
    "end": "1184400"
  },
  {
    "text": "be set via the mask argument i say mostly because two additional bits are set in the value written so the attacker",
    "start": "1184400",
    "end": "1191760"
  },
  {
    "text": "doesn't have complete control over it but detection of the list corruption can be avoided",
    "start": "1191760",
    "end": "1198960"
  },
  {
    "start": "1198000",
    "end": "1198000"
  },
  {
    "text": "kernel electric fence is a low overhead sampling based memory safety error",
    "start": "1199039",
    "end": "1204080"
  },
  {
    "text": "detector added to linux in 2020 it detects out of bounds heap access use",
    "start": "1204080",
    "end": "1210640"
  },
  {
    "text": "after free and invalid free errors k-fence uses a sampling interval to",
    "start": "1210640",
    "end": "1216000"
  },
  {
    "text": "determine whether to apply guards to a memory allocation when the sample interval is reached the next memory",
    "start": "1216000",
    "end": "1222720"
  },
  {
    "text": "allocation made will be guarded and the sample interval is reset the guarded memory allocation requires",
    "start": "1222720",
    "end": "1229280"
  },
  {
    "text": "additional page table entries one page of memory for the allocation itself and the guard page either side of it",
    "start": "1229280",
    "end": "1236320"
  },
  {
    "text": "the actual memory allocation is made either at the beginning or the end of its page the remainder of this page is not used",
    "start": "1236320",
    "end": "1243280"
  },
  {
    "text": "for other allocations but is filled with known patterns to enable detecting incorrect rights into this area",
    "start": "1243280",
    "end": "1250240"
  },
  {
    "text": "other underflows or overflows will be caught by the guard pages k fence will not detect every memory",
    "start": "1250240",
    "end": "1256880"
  },
  {
    "text": "safety error as not every allocation will be guarded an individual kernel is very unlikely to apply guards to a given",
    "start": "1256880",
    "end": "1264320"
  },
  {
    "text": "memory allocation however with enough systems running it code paths which cause errors will get",
    "start": "1264320",
    "end": "1270240"
  },
  {
    "text": "exercised with guards applied to those allocations identifying bugs",
    "start": "1270240",
    "end": "1276960"
  },
  {
    "text": "the common technique in kernel exploitation was to overwrite the user mode address limit value this was used",
    "start": "1276960",
    "end": "1283280"
  },
  {
    "text": "by the kernel to check whether an address provided by user mode via assist call is allowable or safe to access are",
    "start": "1283280",
    "end": "1289919"
  },
  {
    "text": "you whether it was a user mode address addresses below the limit are okay addresses above the limit are not",
    "start": "1289919",
    "end": "1296640"
  },
  {
    "text": "if the address limit could be overwritten by -1 the kernel would think that it was okay for user mode to access",
    "start": "1296640",
    "end": "1302880"
  },
  {
    "text": "the entire address space including kernel memory having overwritten the address limit",
    "start": "1302880",
    "end": "1308080"
  },
  {
    "text": "using an exploit to read kernel memory from user mode a pipe would be created",
    "start": "1308080",
    "end": "1313600"
  },
  {
    "text": "next a write syscall to the pipe using a kernel memory address for its buffer would copy from the desired kernel",
    "start": "1313600",
    "end": "1320000"
  },
  {
    "text": "memory into the pipes buffer this will be followed by a read syscall to read the data from the pipe buffer",
    "start": "1320000",
    "end": "1326480"
  },
  {
    "text": "and place it into the given user mode buffer a similar two-step process can be used",
    "start": "1326480",
    "end": "1331520"
  },
  {
    "text": "to write the kernel memory the right cisco writes data into the pipes buffer then the read syscall",
    "start": "1331520",
    "end": "1337760"
  },
  {
    "text": "reached from the pipe into a kernel address this exploitation technique was mitigated using arm's user access",
    "start": "1337760",
    "end": "1344960"
  },
  {
    "text": "override bit uao changes the behavior of the ldtr and stdr instructions when they",
    "start": "1344960",
    "end": "1351280"
  },
  {
    "text": "are used by the kernel to perform memory copy operations for example those required by read write",
    "start": "1351280",
    "end": "1357280"
  },
  {
    "text": "syscalls in the technique just given if the uao bit is set then the instructions behave as privileged load",
    "start": "1357280",
    "end": "1364000"
  },
  {
    "text": "store and cannot access user memory if the uao bit is clear the instructions",
    "start": "1364000",
    "end": "1369120"
  },
  {
    "text": "are unprivileged and cannot access kernel memory so whichever state the uao bit is in one of the read or write",
    "start": "1369120",
    "end": "1376080"
  },
  {
    "text": "operations will fail and the attacker cannot access kernel memory using this technique",
    "start": "1376080",
    "end": "1381919"
  },
  {
    "text": "this can be worked around using the return to bpf technique described earlier address limit protection has",
    "start": "1381919",
    "end": "1387840"
  },
  {
    "text": "also changed in more recent versions of linux resulting in the removal of this configuration option",
    "start": "1387840",
    "end": "1395200"
  },
  {
    "text": "from the explanation of the exploitation earlier you may remember the sequence file structure was used overlapping",
    "start": "1395679",
    "end": "1402720"
  },
  {
    "text": "event fd context and sequence file allowed shinyu to use the sequence file",
    "start": "1402720",
    "end": "1407840"
  },
  {
    "text": "structures sequence operation member as the event fd context structures count",
    "start": "1407840",
    "end": "1413039"
  },
  {
    "text": "member and therefore leak kernel memory addresses later on in the exploitation process",
    "start": "1413039",
    "end": "1418960"
  },
  {
    "text": "overwriting sequence operations was used to demonstrate control of the instruction pointer",
    "start": "1418960",
    "end": "1424799"
  },
  {
    "text": "sequence file has been used in many linux kernel experts moving it into a dedicated cache would obviously make the",
    "start": "1424799",
    "end": "1431279"
  },
  {
    "text": "techniques mentioned stop working as it would not be possible to confuse structure types",
    "start": "1431279",
    "end": "1438159"
  },
  {
    "start": "1437000",
    "end": "1437000"
  },
  {
    "text": "control flow integrity tries to make sure that indirect calls and functions go where they are supposed to",
    "start": "1438559",
    "end": "1444480"
  },
  {
    "text": "without this attackers can hijack the control flow of the program or in this case the kernel by changing function",
    "start": "1444480",
    "end": "1450799"
  },
  {
    "text": "pointer addresses or return addresses cfi is implemented for android using",
    "start": "1450799",
    "end": "1456240"
  },
  {
    "text": "clang and is performed at the final link stage so all information is available regarding function addresses and their",
    "start": "1456240",
    "end": "1462400"
  },
  {
    "text": "callers this does somewhat increase the link time when building the kernel image",
    "start": "1462400",
    "end": "1467520"
  },
  {
    "text": "for indirect calls the compiler essentially inserts a check on the target address just before the call",
    "start": "1467520",
    "end": "1473760"
  },
  {
    "text": "happens if the target address is not in the list of allowed addresses for that call site",
    "start": "1473760",
    "end": "1478880"
  },
  {
    "text": "the kernel panics as shown on the slide in this case trying to use the modified sequence file",
    "start": "1478880",
    "end": "1484840"
  },
  {
    "text": "operations would have been detected so an alternative way to execute return to",
    "start": "1484840",
    "end": "1489919"
  },
  {
    "text": "bpf would have been required cfi usage in android has been increasing",
    "start": "1489919",
    "end": "1495520"
  },
  {
    "text": "each year as more oems enable the feature in their kernels cfi is also used in the generic kernel",
    "start": "1495520",
    "end": "1501840"
  },
  {
    "text": "image project so as newer android devices start shipping with gki kernels",
    "start": "1501840",
    "end": "1506960"
  },
  {
    "text": "cfi support across android will continue to increase",
    "start": "1506960",
    "end": "1512080"
  },
  {
    "text": "this kernel configuration setting causes bpf to always use the just-in-time compiler the bpf instruction interpreter",
    "start": "1512640",
    "end": "1520400"
  },
  {
    "text": "itself is not compiled with this setting enabled so it is not present in the kernel image as xingi demonstrated",
    "start": "1520400",
    "end": "1527600"
  },
  {
    "text": "earlier if the bpf interpreter is present then having control of the instruction",
    "start": "1527600",
    "end": "1532960"
  },
  {
    "text": "pointer and some arguments allows it to be called to execute arbitrary bpf instructions without them having gone",
    "start": "1532960",
    "end": "1539520"
  },
  {
    "text": "through the verifier this blocks the return to bpf technique that was used to bypass other mitigation",
    "start": "1539520",
    "end": "1546080"
  },
  {
    "text": "techniques the final kernel mitigation config debug",
    "start": "1546080",
    "end": "1551600"
  },
  {
    "start": "1548000",
    "end": "1548000"
  },
  {
    "text": "list is another one recommended by project xero this time by maddie stone which is also now required for android",
    "start": "1551600",
    "end": "1559279"
  },
  {
    "text": "after an operation on a linked list element the forward and backward pointers are checked to ensure that the",
    "start": "1559279",
    "end": "1565039"
  },
  {
    "text": "links between elements in the list are valid this means that list corruption is detected as it occurs which would stop",
    "start": "1565039",
    "end": "1572000"
  },
  {
    "text": "the techniques described earlier from being used so there are a number of mitigations",
    "start": "1572000",
    "end": "1577679"
  },
  {
    "text": "which could have and in some cases actually did block various parts of the exploit some of these were encountered",
    "start": "1577679",
    "end": "1583679"
  },
  {
    "text": "on devices during development of the exploit and these were able to be worked around",
    "start": "1583679",
    "end": "1588799"
  },
  {
    "text": "multiple mitigations that together block all parts of the exploitation techniques described here are required now on",
    "start": "1588799",
    "end": "1595520"
  },
  {
    "text": "android so other vulnerabilities in the future will require different methods",
    "start": "1595520",
    "end": "1602158"
  },
  {
    "text": "now we'll talk about some of the other ways we protect android users starting with on-device protection",
    "start": "1602640",
    "end": "1609760"
  },
  {
    "start": "1607000",
    "end": "1607000"
  },
  {
    "text": "android's application verification feature is something you may be familiar with when an app is side loaded for",
    "start": "1609760",
    "end": "1615840"
  },
  {
    "text": "example the verifier will check to see if it's known to be malware as well as",
    "start": "1615840",
    "end": "1621039"
  },
  {
    "text": "checking for specific apks this also looks at the similarity of the apk on device",
    "start": "1621039",
    "end": "1627039"
  },
  {
    "text": "information about known bad applications for the similarity check is provided by google servers this is to handle small",
    "start": "1627039",
    "end": "1633919"
  },
  {
    "text": "differences in an apk's contents which would defeat hash comparisons for example",
    "start": "1633919",
    "end": "1639039"
  },
  {
    "text": "this covers the case where a side loaded application contains a local privilege elevation exploit to support malicious",
    "start": "1639039",
    "end": "1645200"
  },
  {
    "text": "activities advanced protection is an opt-in system that most visibly enables two-factor",
    "start": "1645200",
    "end": "1650960"
  },
  {
    "text": "authentication and restricts app installations to a subset of those available on google play",
    "start": "1650960",
    "end": "1656960"
  },
  {
    "text": "site loading is disabled and cannot be enabled limiting the pool of apps that can be installed makes users less likely to",
    "start": "1656960",
    "end": "1663760"
  },
  {
    "text": "encounter malware moving to server-side analysis we have a",
    "start": "1663760",
    "end": "1669360"
  },
  {
    "start": "1666000",
    "end": "1666000"
  },
  {
    "text": "lot of infrastructure analyzing android applications all applications are constantly",
    "start": "1669360",
    "end": "1674399"
  },
  {
    "text": "re-analyzed so that any new detection rules or analysis systems are applied to everything over time we use static",
    "start": "1674399",
    "end": "1681039"
  },
  {
    "text": "analysis to generate information from apk contents and dynamic analysis to run",
    "start": "1681039",
    "end": "1686080"
  },
  {
    "text": "the app in an instrumented environment to get information about what it does we inspect packers and obfuscators to",
    "start": "1686080",
    "end": "1692799"
  },
  {
    "text": "support better static analysis the graph here shows the proportion of malware apps that are protected by different",
    "start": "1692799",
    "end": "1699039"
  },
  {
    "text": "packers data like this shows trends in the ecosystem and allows us to identify",
    "start": "1699039",
    "end": "1704159"
  },
  {
    "text": "changes in packer popularity which can indicate that there's a new packer available for example the long-term",
    "start": "1704159",
    "end": "1710960"
  },
  {
    "text": "objective of any analysis work that we do is to automate the process of extracting new information or performing",
    "start": "1710960",
    "end": "1717200"
  },
  {
    "text": "additional detection based off what we learned static analysis scales better than",
    "start": "1717200",
    "end": "1723120"
  },
  {
    "start": "1720000",
    "end": "1720000"
  },
  {
    "text": "dynamic analysis but it can be difficult to understand what's happening the image on the left here shows the control flow",
    "start": "1723120",
    "end": "1730000"
  },
  {
    "text": "for a very simple exploit sample cve 2016-5195",
    "start": "1730000",
    "end": "1735600"
  },
  {
    "text": "the characteristic m advise and seek right loops are easy to see on the right is a different larger",
    "start": "1735600",
    "end": "1741600"
  },
  {
    "text": "exploit and the middle image shows an obfuscated function as displayed by ida which is considerably harder to",
    "start": "1741600",
    "end": "1747919"
  },
  {
    "text": "understand dynamic analysis lets you see what the code actually does provided you can get",
    "start": "1747919",
    "end": "1753919"
  },
  {
    "text": "it to run and perform its malicious actions exploits are generally straightforward in that they try to exploit the device",
    "start": "1753919",
    "end": "1761440"
  },
  {
    "text": "there may be checks for whether the device is supported particularly if the exploit needs known memory addresses or",
    "start": "1761440",
    "end": "1767440"
  },
  {
    "text": "offsets and cannot derive these at runtime but these can always be knocked out if you don't mind the risk of crashing your",
    "start": "1767440",
    "end": "1774000"
  },
  {
    "text": "test device routing exploits generally need to interact with the os",
    "start": "1774000",
    "end": "1779760"
  },
  {
    "text": "obviously if an exploit needs a certain device driver you have to have the right device to run it on",
    "start": "1779760",
    "end": "1785840"
  },
  {
    "text": "if you can see what the exploit asks the kernel to do then you can start to understand what's happening",
    "start": "1785840",
    "end": "1792000"
  },
  {
    "text": "ebpf one of a number of tracing and monitoring systems for linux allows",
    "start": "1792000",
    "end": "1797039"
  },
  {
    "text": "monitoring of kernel calls and the parameters they are given which will show any suspect behavior the exploit",
    "start": "1797039",
    "end": "1803600"
  },
  {
    "text": "described by junior relies on kernel heap sprays to control use after freeze by manipulating kernel heat layout",
    "start": "1803600",
    "end": "1811440"
  },
  {
    "text": "heap sprays are typically performed by allocating and releasing large numbers of particular objects for example files",
    "start": "1811440",
    "end": "1817919"
  },
  {
    "text": "or sockets the technical paper covers the behavioral detection example in more",
    "start": "1817919",
    "end": "1824399"
  },
  {
    "text": "detail than we have time for now so please take a look at that on the left we can see the start of the",
    "start": "1824399",
    "end": "1830240"
  },
  {
    "text": "output from xinhu's exploit on the right we can see output from the trace at about the same time",
    "start": "1830240",
    "end": "1836559"
  },
  {
    "text": "at this point you can see 25 000 calls to event fd which is not normal behavior",
    "start": "1836559",
    "end": "1842240"
  },
  {
    "text": "for an android application the next thing that happens is every",
    "start": "1842240",
    "end": "1847760"
  },
  {
    "text": "second event fd handle is closed which is again unusual behavior",
    "start": "1847760",
    "end": "1852880"
  },
  {
    "text": "the suspicious behavior continues in similar fashion the exploit launches threads to perform more memory",
    "start": "1852880",
    "end": "1859120"
  },
  {
    "text": "manipulation work this exploit has to perform these actions so if we can see them or similar",
    "start": "1859120",
    "end": "1866080"
  },
  {
    "text": "happening we can see it interleaving these required actions with garbage calls might help disguise the",
    "start": "1866080",
    "end": "1872559"
  },
  {
    "text": "activities but could affect timing and hence expert reliability and we may be",
    "start": "1872559",
    "end": "1878080"
  },
  {
    "text": "able to identify and ignore garbage calls as well",
    "start": "1878080",
    "end": "1882960"
  },
  {
    "start": "1882000",
    "end": "1882000"
  },
  {
    "text": "xingyu encountered a number of problems developing the exploit but with a lot of work heap manipulation and help from",
    "start": "1883279",
    "end": "1889840"
  },
  {
    "text": "other people he overcame them the workarounds were themselves defeated by further mitigations which you can",
    "start": "1889840",
    "end": "1896240"
  },
  {
    "text": "find on current android devices we mentioned the generic kernel image project this means kernel updates get",
    "start": "1896240",
    "end": "1903039"
  },
  {
    "text": "onto user devices faster as there is less effort involved across the android ecosystem in updating kernels resulting",
    "start": "1903039",
    "end": "1910399"
  },
  {
    "text": "in better protection for android users thank you to two people without whom",
    "start": "1910399",
    "end": "1915760"
  },
  {
    "text": "this work would not have happened janhorn for discussing exploitation techniques suggesting workarounds for",
    "start": "1915760",
    "end": "1922159"
  },
  {
    "text": "mitigations and more mitigations for the workarounds and zyjo for donating his",
    "start": "1922159",
    "end": "1927519"
  },
  {
    "text": "mi9 phone for exploit development and testing finally thank you for watching this",
    "start": "1927519",
    "end": "1933120"
  },
  {
    "text": "presentation [Music]",
    "start": "1933120",
    "end": "1945289"
  }
]