[
  {
    "start": "0",
    "end": "34000"
  },
  {
    "text": "hello everybody and welcome to blackhat I appreciate everybody showing up for this talk today we're going over hosts",
    "start": "0",
    "end": "6330"
  },
  {
    "text": "split which is X Co exploitable anti-patterns and Unicode normalization so I appreciate you guys joining us and",
    "start": "6330",
    "end": "14099"
  },
  {
    "text": "I want to go ahead and introduce Jonathan Burch hi Jonathan you give him a round of applause thank",
    "start": "14099",
    "end": "21300"
  },
  {
    "text": "you okay so I'm Jonathan Burch with",
    "start": "21300",
    "end": "26760"
  },
  {
    "text": "Microsoft Office security and this is host split exploitable anti-patterns and unicode normalization what I'm talking",
    "start": "26760",
    "end": "34710"
  },
  {
    "start": "34000",
    "end": "240000"
  },
  {
    "text": "about today is essentially a new category of vulnerability this is an attack pattern that I found to work",
    "start": "34710",
    "end": "39960"
  },
  {
    "text": "against a broad range of software and although this is a unicode vulnerability this is not a homograft attack this is",
    "start": "39960",
    "end": "46739"
  },
  {
    "text": "not about fooling human eyeballs this is about fooling software bypassing security checks also I want to emphasize",
    "start": "46739",
    "end": "53610"
  },
  {
    "text": "that though I work for Microsoft and I'll be discussing Microsoft vulnerabilities in this talk I've also",
    "start": "53610",
    "end": "59129"
  },
  {
    "text": "found vulnerabilities of this type in a number of other products that are not Microsoft and I'll be discussing those",
    "start": "59129",
    "end": "64559"
  },
  {
    "text": "as well I'm giving this talk because this is a vulnerability that works too well this is something I'm hoping people",
    "start": "64559",
    "end": "70770"
  },
  {
    "text": "in this room will go and fix you probably have software that is vulnerable to this or maybe you'll go",
    "start": "70770",
    "end": "76229"
  },
  {
    "text": "hack someone else's software that tool novel to this that will make it better too so here's an agenda for my talk I'm",
    "start": "76229",
    "end": "83220"
  },
  {
    "text": "gonna give some background on how Unicode host names work that's internationalized domain names ID ends",
    "start": "83220",
    "end": "88439"
  },
  {
    "text": "I'll describe what I call the hosts split attack which allows an attacker to create a URL which is parsed as",
    "start": "88439",
    "end": "94439"
  },
  {
    "text": "belonging to one host name but resolved as belonging to a different host name I'll then give you a rundown of an",
    "start": "94439",
    "end": "101909"
  },
  {
    "text": "example exploit where I show how you could have used host split to steal ooofff tokens from office 365 I'll talk",
    "start": "101909",
    "end": "109320"
  },
  {
    "text": "about other software I found that's vulnerable I'll tell you what was vulnerable and what's still vulnerable I'll explain host bond which is a",
    "start": "109320",
    "end": "116969"
  },
  {
    "text": "variant attack it works like in somewhat different software I'll explain how you can test for these issues even either in",
    "start": "116969",
    "end": "123810"
  },
  {
    "text": "your own software or something you're trying to attack and I'll give you some best practices for preventing this issue",
    "start": "123810",
    "end": "129330"
  },
  {
    "text": "or for fixing it so I penetration tester at Microsoft i hack",
    "start": "129330",
    "end": "135420"
  },
  {
    "text": "office Word Excel the services that go with those so why am I looking at Unicode URLs well a couple of years ago",
    "start": "135420",
    "end": "141540"
  },
  {
    "text": "I was at lunch with some other penetration testers at Microsoft and someone mentioned oh you can now get host names in the.net TLD that have",
    "start": "141540",
    "end": "149579"
  },
  {
    "text": "Unicode or sorry have hieroglyphic characters so you could get single character host names and this was kind",
    "start": "149579",
    "end": "155010"
  },
  {
    "text": "of cool we all just went and got one over lunch and I got this one and yeah that's a man writings huger off",
    "start": "155010",
    "end": "160739"
  },
  {
    "text": "simultaneously maybe it's a metaphor for something but this got me to thinking how does this work how do a Unicode host",
    "start": "160739",
    "end": "167219"
  },
  {
    "text": "names in URLs work and well in my position I get to do some open-ended",
    "start": "167219",
    "end": "172290"
  },
  {
    "text": "security research so I spent some time looking at that I will to see if there were vulnerabilities and how Unicode host names are processed and yes there",
    "start": "172290",
    "end": "179250"
  },
  {
    "text": "are but in order to explain them I'll have to give you the same background I learned I'll have to explain to you a",
    "start": "179250",
    "end": "184889"
  },
  {
    "text": "bit about how internationalized domain names that's ID ends work so the first",
    "start": "184889",
    "end": "190530"
  },
  {
    "text": "thing that's important to understand is that really the internet just runs on a ski so if you're doing a DNS lookup if",
    "start": "190530",
    "end": "197849"
  },
  {
    "text": "you're doing a same-origin check that's all done with ascii so by the end these",
    "start": "197849",
    "end": "203310"
  },
  {
    "text": "internationalized domain names the way they work is that every host name actually has two forms there's a-you",
    "start": "203310",
    "end": "208680"
  },
  {
    "text": "label which contains Unicode characters it's nice for maybe showing a URL to someone in their native language but if",
    "start": "208680",
    "end": "215370"
  },
  {
    "text": "there's a corresponding a label that's an ASCII string and these have a direct",
    "start": "215370",
    "end": "220530"
  },
  {
    "text": "one-to-one relationship with each other and there are RFC defined algorithms for converting between them so there is two",
    "start": "220530",
    "end": "227310"
  },
  {
    "text": "ascii to go from the unicode to the ascii and there's two unicode to go from the ascii to the unicode how those",
    "start": "227310",
    "end": "233489"
  },
  {
    "text": "algorithms work is the crux of the vulnerabilities i'll be talking about today's so I'm going to give some details on those so going from Unicode",
    "start": "233489",
    "end": "241650"
  },
  {
    "text": "to ASCII that to ASCII algorithm has two steps there is a normalization step",
    "start": "241650",
    "end": "246989"
  },
  {
    "text": "where you convert all of the Unicode characters to a standardized form it's called a KC normalized form and this is",
    "start": "246989",
    "end": "252599"
  },
  {
    "text": "sort of like making a string lower case before indexing it it's to make it sort of standardized and comparable and then",
    "start": "252599",
    "end": "259139"
  },
  {
    "text": "there's the second step to convert the host names to ASCII this is called Punic coding and you're going to take Unicode",
    "start": "259139",
    "end": "265380"
  },
  {
    "text": "characters and convert them into an ASCII encoding I'll detail those a little bit so if you look",
    "start": "265380",
    "end": "271570"
  },
  {
    "text": "at the characters on the left side of this slide there is this a with combining ring above character there's",
    "start": "271570",
    "end": "276850"
  },
  {
    "text": "the angstrom symbol and then there's an ASCII a with a combining ring above character after it these all look the",
    "start": "276850",
    "end": "282820"
  },
  {
    "text": "same but someone trying to type this character might have typed any one of these you really want software to treat",
    "start": "282820",
    "end": "288910"
  },
  {
    "text": "them as the same thing though that's where the normalization step is there so when you're converting any of these to",
    "start": "288910",
    "end": "295480"
  },
  {
    "text": "an ASCII hostname you normalize them first and these all normalize to this lowercase a with combining ring above",
    "start": "295480",
    "end": "301450"
  },
  {
    "text": "character now there's a couple of important things to notice about this first in one of these cases we've got",
    "start": "301450",
    "end": "307060"
  },
  {
    "text": "two characters that become one character also we've got an ASCII character with a Unicode character that just becomes one",
    "start": "307060",
    "end": "313240"
  },
  {
    "text": "unicode character both of those can happen the other way around also you sometimes have unicode characters that",
    "start": "313240",
    "end": "319150"
  },
  {
    "text": "normalized to ASCII and one character that more normalized this to multiple characters and I will get back to this",
    "start": "319150",
    "end": "325420"
  },
  {
    "text": "step because it's kind of critical after normalization does what's called punic coding this is where you convert Unicode",
    "start": "325420",
    "end": "332230"
  },
  {
    "text": "characters to ASCII so if you look at this string this is this mask which is I guess the Norwegian word for seagull",
    "start": "332230",
    "end": "337690"
  },
  {
    "text": "this has a single Unicode character in it which is that a with a combining ring above it when this gets Punic coded you",
    "start": "337690",
    "end": "343900"
  },
  {
    "text": "get the string at the bottom of the slide this starts with an X and - which is called an ace that just means this part",
    "start": "343900",
    "end": "350590"
  },
  {
    "text": "of the host name is Punic code this is followed by the ASCII characters from the original host name in the same order",
    "start": "350590",
    "end": "356260"
  },
  {
    "text": "so everything but that a with a ring above it and then after that you have a - with this mu a this mu a is actually a",
    "start": "356260",
    "end": "363820"
  },
  {
    "text": "set of instructions for an RFC to find state machine which can be executed to put the a with a ring above it back in",
    "start": "363820",
    "end": "369940"
  },
  {
    "text": "there so those are just instructions that say put an A with a ring above it between the next-to-last and last",
    "start": "369940",
    "end": "375700"
  },
  {
    "text": "characters of the ASCII now going the other way going from the ascii to",
    "start": "375700",
    "end": "381280"
  },
  {
    "text": "unicode is simple you just run that RFC defined state machine so you just take that anyway and you run it and you get",
    "start": "381280",
    "end": "387490"
  },
  {
    "text": "an A with a combining ring above it back in your string then you throw away the ACE and then you've got your host name you don't try to reverse the",
    "start": "387490",
    "end": "394210"
  },
  {
    "text": "normalization because there's no way to do that so you end up getting the normalized form out of this now the RFC that defines how this works",
    "start": "394210",
    "end": "401770"
  },
  {
    "text": "the i-dna RFC says that when you take an ASCII hostname and convert it to a Unicode hostname you have to then take",
    "start": "401770",
    "end": "407830"
  },
  {
    "text": "the Unicode host and you get converted back to ASCII again and make sure it's the same thing you started with",
    "start": "407830",
    "end": "412920"
  },
  {
    "text": "otherwise you're supposed to go into some sort of an error flow throw an exception that kind of thing but if you",
    "start": "412920",
    "end": "418240"
  },
  {
    "text": "think about it the average user scenario is never going to hit this so you can imagine that some",
    "start": "418240",
    "end": "423820"
  },
  {
    "text": "people implementing this might not have actually added that check well there's",
    "start": "423820",
    "end": "430240"
  },
  {
    "text": "one other thing to understand here which is that there's three different standards for how all of this works",
    "start": "430240",
    "end": "435430"
  },
  {
    "text": "there's ID in a 2003 which is from 2003 and was the first way that I DNA worked",
    "start": "435430",
    "end": "440590"
  },
  {
    "text": "there's ID in a 2008 which tried to fix ID in a 2003 by not allowing as many characters and also changing the way",
    "start": "440590",
    "end": "446920"
  },
  {
    "text": "certain characters normalized but I caused a lot of problems for certain languages this meant that in some cases",
    "start": "446920",
    "end": "452620"
  },
  {
    "text": "you might have a host name that under ID in a 2003 had one ASCII version but under ID and a 2008 had a different",
    "start": "452620",
    "end": "458560"
  },
  {
    "text": "ASCII version and different people might own those so then there was ID and a 2008 plus UTS 46 which tried to patch",
    "start": "458560",
    "end": "465610"
  },
  {
    "text": "this by essentially having a conversion layer before I DNA 2008 this said well",
    "start": "465610",
    "end": "471040"
  },
  {
    "text": "we're gonna take all the characters that ID and a 2008 treats differently and we're going to try to convert them into what ID in a 2003 would have done and",
    "start": "471040",
    "end": "477460"
  },
  {
    "text": "then hand the whole thing out off to ID and a 2008 the result is that none of these are really the same as each other",
    "start": "477460",
    "end": "483190"
  },
  {
    "text": "they're all a little bit different and different vulnerabilities work on each one so I've now given you some",
    "start": "483190",
    "end": "490180"
  },
  {
    "start": "488000",
    "end": "650000"
  },
  {
    "text": "background on how ideas work how ID ends work rather and now I'll just go",
    "start": "490180",
    "end": "495220"
  },
  {
    "text": "describe what I call the host split vulnerability so if you remember that normalization step I mentioned where all",
    "start": "495220",
    "end": "501940"
  },
  {
    "text": "of those aids with rings above them became that lowercase a with a ring above it well what if there were unicode",
    "start": "501940",
    "end": "508000"
  },
  {
    "text": "character is that when you normalize them they became ASCII characters but specifically ASCII characters that had",
    "start": "508000",
    "end": "513130"
  },
  {
    "text": "syntax significance wherever you were going to use them like say this so here",
    "start": "513130",
    "end": "518770"
  },
  {
    "text": "you have u plus 2100 this is the account of character it's supposed to be used for addressing envelopes but it turns",
    "start": "518770",
    "end": "525250"
  },
  {
    "text": "out that when you normalize this unicode character it becomes asking a /c so if you think about this this is",
    "start": "525250",
    "end": "533079"
  },
  {
    "text": "kind of a funny thing that forward-slash is an important character in URLs that's the path separator so what happens if",
    "start": "533079",
    "end": "539170"
  },
  {
    "text": "you use one of these characters in a hostname like this so here we have evil see account of example comm well if we",
    "start": "539170",
    "end": "547899"
  },
  {
    "text": "run the task e algorithm against this if we do the conversion to make this an ASCII hostname so we could do say a DNS",
    "start": "547899",
    "end": "554200"
  },
  {
    "text": "lookup you get this you get evil dot C a / C dot example comm and now the punic",
    "start": "554200",
    "end": "560680"
  },
  {
    "text": "coding doesn't happen because you only be unicode when you've still got unicode characters after normalization so we",
    "start": "560680",
    "end": "566290"
  },
  {
    "text": "just have this new ASCII host name instead and if you look at this it started off as a subdomain of example",
    "start": "566290",
    "end": "573339"
  },
  {
    "text": "comm but now it's not now it's just evil dot CA with a path and presumably this",
    "start": "573339",
    "end": "578769"
  },
  {
    "text": "is like some place where evil Canadian people hang out or something but the",
    "start": "578769",
    "end": "584019"
  },
  {
    "text": "host name here has changed because of this normalization step so that seems",
    "start": "584019",
    "end": "589660"
  },
  {
    "text": "problematic but does that work and yes that works really really well unfortunately it doesn't work as well as",
    "start": "589660",
    "end": "596740"
  },
  {
    "text": "it did when I started doing my research but I found this whole nor build in a lot of places I first found this in edge",
    "start": "596740",
    "end": "602620"
  },
  {
    "text": "and ie but I found issues also in dotnet Python Java and also a lot of other",
    "start": "602620",
    "end": "607870"
  },
  {
    "text": "places I'm going to talk about today I'll start without edge and I Eve owner ability though so it turns out that some",
    "start": "607870",
    "end": "614740"
  },
  {
    "text": "websites will return how HTTP response header is using utf-8 and if edge",
    "start": "614740",
    "end": "621040"
  },
  {
    "text": "encountered an HTTP redirect response see a 302 where the location header in",
    "start": "621040",
    "end": "626709"
  },
  {
    "text": "the response contained unicode characters it would normalize those unicode characters in the response header so if you had this URL this evil",
    "start": "626709",
    "end": "634449"
  },
  {
    "text": "dot c account of example comm as the location header for a redirect edge and ie would actually just go to evil about",
    "start": "634449",
    "end": "641199"
  },
  {
    "text": "CA instead so that's clearly a bug that's clearly not what you want the browser to do but why does it matter how",
    "start": "641199",
    "end": "648310"
  },
  {
    "text": "do you exploit that well I'll tell you how you could have stolen OAuth tokens from office 365 using that vulnerability",
    "start": "648310",
    "end": "656160"
  },
  {
    "text": "so a little background on Oh a sort of a refresher if you look at the OAuth authorization",
    "start": "656160",
    "end": "661740"
  },
  {
    "text": "code flow this is what you're going to use if you've got some website where you want users to authenticate to it but you",
    "start": "661740",
    "end": "668220"
  },
  {
    "text": "don't want to deal with usernames and passwords yourself you're going to let some other service do that so you redirect to that other service you say",
    "start": "668220",
    "end": "674700"
  },
  {
    "text": "here's my application ID and here's the redirect URI I want you to send and off the kindy authentication token to that",
    "start": "674700",
    "end": "681330"
  },
  {
    "text": "other service is going to ascend to get the user maybe they enter a username and password maybe they've just got a cookie and then it redirects to that redirect",
    "start": "681330",
    "end": "688200"
  },
  {
    "text": "URI with a token probably in a query string something like that so this would",
    "start": "688200",
    "end": "694410"
  },
  {
    "text": "be problematic if any website could start this flow and have the redirect URI go to itself so if I could make my",
    "start": "694410",
    "end": "700710"
  },
  {
    "text": "evil calm and say oh I'm going to redirect to say the office Authenticator and my redirect URI is evil calm and my",
    "start": "700710",
    "end": "708660"
  },
  {
    "text": "application ideas office it would be bad if the office that then they catered just authenticated the user and sent the token be my evil com because then I'd",
    "start": "708660",
    "end": "715200"
  },
  {
    "text": "have some users token this is prevented and OAuth by essentially having a low list for where this redirect can go for",
    "start": "715200",
    "end": "722400"
  },
  {
    "text": "any given application ID there is some pattern that says well these are the okay redirect your eyes for this",
    "start": "722400",
    "end": "728400"
  },
  {
    "text": "application but how does that work well in olaf 1.0 it was really common to see",
    "start": "728400",
    "end": "734400"
  },
  {
    "text": "redirect URI allow lists that were just start on something calm like start out office com so if you had this URI with",
    "start": "734400",
    "end": "741720"
  },
  {
    "text": "the ebola account of that office com then ends with dot office com so it's okay it's important to remember that",
    "start": "741720",
    "end": "748500"
  },
  {
    "text": "when software is dealing with URLs mostly it doesn't think about is this a Unicode URL or is this an ASCII URL it",
    "start": "748500",
    "end": "754470"
  },
  {
    "text": "just says oh I've got a string it's a hostname well I'll do a regular expression against it so normally no one",
    "start": "754470",
    "end": "760380"
  },
  {
    "text": "normalizes their URLs before doing these sort of security checks so that comparison works and you get a flow like",
    "start": "760380",
    "end": "766800"
  },
  {
    "text": "this you have some attacker website it says to the office Authenticator well ok",
    "start": "766800",
    "end": "773190"
  },
  {
    "text": "I'm office comm I want to use the office application ID and my redirect URI is this evil dot C account of that office",
    "start": "773190",
    "end": "780630"
  },
  {
    "text": "com the service says well that ends with office comm or dot office com so that's",
    "start": "780630",
    "end": "785940"
  },
  {
    "text": "ok I'll get a token I'll redirect to it and then it goes to edge if you're browsing an edge and edge actually goes",
    "start": "785940",
    "end": "792030"
  },
  {
    "text": "to evil dot CA so it's not actually a subdomain of office calm and evil that CA gets your token instead but this is oweth 1.0 and",
    "start": "792030",
    "end": "800950"
  },
  {
    "text": "no one uses oauth 1.0 anymore at least not a lot of software does modern oweth",
    "start": "800950",
    "end": "806020"
  },
  {
    "text": "doesn't work this way modern OAuth generally has an allow less pattern that says it has to be this",
    "start": "806020",
    "end": "811540"
  },
  {
    "text": "exact hostname and often you'll see this exact path for a given application so",
    "start": "811540",
    "end": "817540"
  },
  {
    "text": "the attack I've been describing won't work for that the attack I've been describing only works for essentially a",
    "start": "817540",
    "end": "822610"
  },
  {
    "text": "subdomain check something with a wild-card and that's not what we've got anymore but there is a tool we can use",
    "start": "822610",
    "end": "829180"
  },
  {
    "text": "to get around this and that's redirects so in 2014 a researcher named Wang Jing",
    "start": "829180",
    "end": "834700"
  },
  {
    "text": "publicized a vulnerability he described he called covert redirect which said",
    "start": "834700",
    "end": "840610"
  },
  {
    "text": "essentially well if you've got an OAuth Authenticator that will send the token to some endpoint which also has an open",
    "start": "840610",
    "end": "846640"
  },
  {
    "text": "the redirect vulnerability then maybe you can steal that token by essentially redirecting the token to your site maybe",
    "start": "846640",
    "end": "852580"
  },
  {
    "text": "you can pull it out of the referre or maybe you actually have redirect behavior that forwards the token this",
    "start": "852580",
    "end": "858070"
  },
  {
    "text": "didn't receive a really good and was well reception from the security",
    "start": "858070",
    "end": "863650"
  },
  {
    "text": "community no one seemed very impressed by this but it turns out the host split attack to make this much easier to do it",
    "start": "863650",
    "end": "869500"
  },
  {
    "text": "makes it much easier to find open redirects and that is how you could have attacked office 365 so often start live",
    "start": "869500",
    "end": "876400"
  },
  {
    "text": "comm was a valid redirect endpoint for office o auth tokens it also had",
    "start": "876400",
    "end": "881860"
  },
  {
    "text": "redirect functionality that would try to make to redirect to any sub domain of Dropbox com in combination you could",
    "start": "881860",
    "end": "889240"
  },
  {
    "text": "have used this URL as your OAuth redirect target to actually steal tokens so if you look at this URL the target",
    "start": "889240",
    "end": "896890"
  },
  {
    "text": "here for the redirect once you get to often start live comm is evil dot C",
    "start": "896890",
    "end": "902260"
  },
  {
    "text": "account of Dropbox com and that ends with Dropbox com so office thought live",
    "start": "902260",
    "end": "908530"
  },
  {
    "text": "comm said well that's ok but it sent that as a redirect to edge and I'd said oh I'll go to evil dot CA and that's",
    "start": "908530",
    "end": "914710"
  },
  {
    "text": "where the token got forwarded to accept this didn't quite work because we were lucky it turned out that some of our",
    "start": "914710",
    "end": "921760"
  },
  {
    "text": "middleware had a utf-8 double encoding bug so that any utf-8 response header",
    "start": "921760",
    "end": "926770"
  },
  {
    "text": "acts utf8 mm hooded and so that redirect actually went to evil dot C and a bunch",
    "start": "926770",
    "end": "933050"
  },
  {
    "text": "of garbage Dropbox comm and it turns out that browsers wouldn't even do that but",
    "start": "933050",
    "end": "938300"
  },
  {
    "text": "this put in kind of an awkward position this meant we had a bug in our middleware that we couldn't allow to be patched on",
    "start": "938300",
    "end": "944750"
  },
  {
    "text": "our middleware until we fixed edge and ie so we actually had the monitor patches for a middleware to make sure",
    "start": "944750",
    "end": "951170"
  },
  {
    "text": "that this didn't get fixed or that we didn't accept the patch where it got fixed until we fixed our stuff okay so",
    "start": "951170",
    "end": "959750"
  },
  {
    "start": "958000",
    "end": "1572000"
  },
  {
    "text": "that's how the vulnerability works what's vulnerable to this well first",
    "start": "959750",
    "end": "964910"
  },
  {
    "text": "it's not just the example I gave it's not just oh ah 'the host names are security identifiers there's a whole RFC",
    "start": "964910",
    "end": "971540"
  },
  {
    "text": "about if you misinterpret security identifiers is bad stuff this can do",
    "start": "971540",
    "end": "977570"
  },
  {
    "text": "lots of different things because a lot of places host names are used to essentially decide whether something is",
    "start": "977570",
    "end": "982670"
  },
  {
    "text": "an okay place to do something it's also not just edge I've found this vulnerability all over the place I'll be",
    "start": "982670",
    "end": "988400"
  },
  {
    "text": "going through a lot of different places later in this talk and it's also not just this account of character there's a",
    "start": "988400",
    "end": "993770"
  },
  {
    "text": "really long list of unicode characters you can do this trick with I've got them at the end of this slide deck it's also",
    "start": "993770",
    "end": "999590"
  },
  {
    "text": "in my white paper here's a few examples though so like an interrobang character normalizes the question mark exclamation",
    "start": "999590",
    "end": "1005500"
  },
  {
    "text": "point so it pushes everything after it just into the query string a full-width",
    "start": "1005500",
    "end": "1010720"
  },
  {
    "text": "solidus character turns into just a forward slash full width number sign becomes number sign full width app",
    "start": "1010720",
    "end": "1017410"
  },
  {
    "text": "becomes commercial at which is nice for attacking email so there's a lot of possibilities here it's also important",
    "start": "1017410",
    "end": "1025660"
  },
  {
    "text": "to understand the specific idna version that's being implemented in software matters pure i-dna 2008 is not",
    "start": "1025660",
    "end": "1032620"
  },
  {
    "text": "vulnerable to host split pure ID and a 2008 does not allow any of the characters that let you do these",
    "start": "1032620",
    "end": "1037810"
  },
  {
    "text": "shenanigans ID in a 2003 or ID in a 2008 plus UTS 46 are vulnerable though",
    "start": "1037810",
    "end": "1045839"
  },
  {
    "text": "however in both of those cases there's a flag we could have used which was used STD 3 ASCII rules which says essentially",
    "start": "1045839",
    "end": "1052030"
  },
  {
    "text": "when you normalize a host name make sure afterwards the host name only contains characters that are supposed to be there",
    "start": "1052030",
    "end": "1057460"
  },
  {
    "text": "in host names but nobody uses that lack and nobody uses pure ID in a 2008",
    "start": "1057460",
    "end": "1063160"
  },
  {
    "text": "and why do they not do that well it's because of underscores so the STD three",
    "start": "1063160",
    "end": "1069310"
  },
  {
    "text": "rules for URLs from way back old RFC's say that a hostname can only have alphanumeric characters dashes and",
    "start": "1069310",
    "end": "1076630"
  },
  {
    "text": "periods but it turns out that lots of old URIs especially internet host names",
    "start": "1076630",
    "end": "1081940"
  },
  {
    "text": "have underscores in them and if you use the STD 3 ASCII rules you just can't talk to host names that contain",
    "start": "1081940",
    "end": "1088150"
  },
  {
    "text": "underscores anymore and that wasn't really acceptable to anyone so no one",
    "start": "1088150",
    "end": "1093910"
  },
  {
    "text": "uses this flag and everyone's vulnerable because they want to talk to host names that have underscores in them that said",
    "start": "1093910",
    "end": "1102040"
  },
  {
    "text": "browsers at least are safe now I reported the ad to naïve ulnar ability to nsrc this was patched in February now",
    "start": "1102040",
    "end": "1108820"
  },
  {
    "text": "it's the case that edge and ie when they encounter an HTTP redirect like this they just won't redirect if the location",
    "start": "1108820",
    "end": "1115150"
  },
  {
    "text": "header has one of these characters in it that would suddenly change something with syntax significance so the host",
    "start": "1115150",
    "end": "1120820"
  },
  {
    "text": "name changes the redirect isn't followed Firefox and Chrome never had this bug so",
    "start": "1120820",
    "end": "1126070"
  },
  {
    "text": "they've always been safe from it Safari does something very strange where if it gets a utf-8 location header for a",
    "start": "1126070",
    "end": "1131920"
  },
  {
    "text": "redirect at % encodes it and then does the DNS lookup on the % encoded version which doesn't work so I don't know what",
    "start": "1131920",
    "end": "1139330"
  },
  {
    "text": "that's about it's probably not exploitable but maybe someone can figure out something they can do with that but other Microsoft",
    "start": "1139330",
    "end": "1147760"
  },
  {
    "text": "stuff was vulnerable as well Don net was vulnerable so that on that framework has classes for dealing with your eyes it",
    "start": "1147760",
    "end": "1154240"
  },
  {
    "text": "has the URI builder which can be used to pull the hostname out of a URL and it has the ID n mapping class which can be",
    "start": "1154240",
    "end": "1160420"
  },
  {
    "text": "used to convert a hostname between unicode and ascii and it turns out that if you used URI builder on one of these",
    "start": "1160420",
    "end": "1165850"
  },
  {
    "text": "host names so this canada dot c account of dot products at office com it would say well the host name is that whole",
    "start": "1165850",
    "end": "1171700"
  },
  {
    "text": "thing but then if you used ID and mapping to convert the host name from unicode to ascii so you could say do a",
    "start": "1171700",
    "end": "1178270"
  },
  {
    "text": "DNS lookup make a request to this URL well suddenly the host name is actually now canada dot CA because it would do",
    "start": "1178270",
    "end": "1184720"
  },
  {
    "text": "that normalization for you and there was nothing that said this wasn't ok this meant that if you're writing software",
    "start": "1184720",
    "end": "1190180"
  },
  {
    "text": "that's dealing with URLs and you're probably just dealing with the URL as string and probably doing comparisons on",
    "start": "1190180",
    "end": "1196540"
  },
  {
    "text": "it without trying to convert it to ascii you would do the wrong thing you would",
    "start": "1196540",
    "end": "1201550"
  },
  {
    "text": "see a URL as being a subdomain of some host name but it wasn't and then when you try to make a request to it you would make a request to something else",
    "start": "1201550",
    "end": "1208800"
  },
  {
    "text": "this is also fixed now I reported this to nsrc as well and this was also patched in February and it was back",
    "start": "1208800",
    "end": "1215920"
  },
  {
    "text": "ported so even Don that - oh is good now the way it works now is when you've got a hostname and it's going to be",
    "start": "1215920",
    "end": "1222070"
  },
  {
    "text": "converted to ascii then they pull out just a hostname they converted to ascii they say well does the host thing we",
    "start": "1222070",
    "end": "1227650"
  },
  {
    "text": "ended up with have characters in it that shouldn't be in a host name if it does throw an exception so the code on that",
    "start": "1227650",
    "end": "1233080"
  },
  {
    "text": "previous slide now shows a system that URI format exception fixing frameworks",
    "start": "1233080",
    "end": "1239140"
  },
  {
    "text": "is a big deal because a lot of stuff was vulnerable because Don net was vulnerable an example of this is fiddler",
    "start": "1239140",
    "end": "1245170"
  },
  {
    "text": "fiddler was a product made by telluric it's an HTTP traffic monitoring tool a lot of people use it to do penetration",
    "start": "1245170",
    "end": "1251590"
  },
  {
    "text": "testing but also just testing software that talks to networks and it turned out that if you were running fiddler every",
    "start": "1251590",
    "end": "1257110"
  },
  {
    "text": "browser was vulnerable to host plate redirects because fiddler would do the thing where would intercept that HTTP",
    "start": "1257110",
    "end": "1263170"
  },
  {
    "text": "redirect response it would take the location header and it would normalize it for you and then hand the normalized",
    "start": "1263170",
    "end": "1268270"
  },
  {
    "text": "version off to the browser and so Chrome and Firefox would also have the wrong redirects if you were running fiddler",
    "start": "1268270",
    "end": "1274060"
  },
  {
    "text": "but they didn't have to fix anything we fixed net and because the framework is better now because the classes they rely",
    "start": "1274060",
    "end": "1279910"
  },
  {
    "text": "on are fixed fiddler no longer has a vulnerability either but dotnet was not the only vulnerable framework Python was",
    "start": "1279910",
    "end": "1287920"
  },
  {
    "text": "also vulnerable so in Python there's a built-in library called URL Lib which is",
    "start": "1287920",
    "end": "1293140"
  },
  {
    "text": "used for parsing host names and things out of URLs and Python also has encoding",
    "start": "1293140",
    "end": "1298600"
  },
  {
    "text": "is where you can map hostname astray from i-dna to utf-8 and things like that and this is essentially the same",
    "start": "1298600",
    "end": "1304990"
  },
  {
    "text": "vulnerability that don net had if you tried to parse the host name out of a URL where you've got one of these hosts",
    "start": "1304990",
    "end": "1310570"
  },
  {
    "text": "split characters so here it's Canada see a count of that Microsoft com",
    "start": "1310570",
    "end": "1316290"
  },
  {
    "text": "it would say the host name is that whole thing it wouldn't break it where that host split character is but if you took",
    "start": "1316350",
    "end": "1323710"
  },
  {
    "text": "that same URL and then you said well I want to convert the host name a ski so you can do like an actual",
    "start": "1323710",
    "end": "1329049"
  },
  {
    "text": "request to it well that a oversee becomes a /c and now when your request",
    "start": "1329049",
    "end": "1335169"
  },
  {
    "text": "is made it's going somewhere else and the host name is something different and I need to share this with the credit for",
    "start": "1335169",
    "end": "1340570"
  },
  {
    "text": "this vulnerability with penny he was an intern at Microsoft when I found this he helped me work out the details in Python",
    "start": "1340570",
    "end": "1345940"
  },
  {
    "text": "we actually did this at a hackathon a while back now this was one vulnerability in Python that was similar",
    "start": "1345940",
    "end": "1351190"
  },
  {
    "text": "to dotnet but Python actually had a different vulnerability as well so the issue I've been talking about here",
    "start": "1351190",
    "end": "1357640"
  },
  {
    "text": "allows you to essentially make something that was a subdomain of some URL or some hostname and now isn't but Python how to",
    "start": "1357640",
    "end": "1364030"
  },
  {
    "text": "vulnerability that let you just swap the hostname in a URL and it works like this so here we're using the sort of",
    "start": "1364030",
    "end": "1371650"
  },
  {
    "text": "old-school basic auth syntax you got user name colon password at some host name except the user name here has",
    "start": "1371650",
    "end": "1378039"
  },
  {
    "text": "a full-width number sign in it and the trick here is that before the normalization happens that full-width",
    "start": "1378039",
    "end": "1384460"
  },
  {
    "text": "number sign is just part of the username so the hostname is actually the thing after the ACT and that's what Python",
    "start": "1384460",
    "end": "1389590"
  },
  {
    "text": "will tell you it is but once he normalized this well it turns out that the username would also get normalized",
    "start": "1389590",
    "end": "1395500"
  },
  {
    "text": "and that full-width number son becomes a pound sign now and so everything after it is defragment and the hostname is",
    "start": "1395500",
    "end": "1402010"
  },
  {
    "text": "just whatever was before it so in this case the host name goes from being products dot office comm to being",
    "start": "1402010",
    "end": "1407110"
  },
  {
    "text": "bing.com I reported both of these to Python and they fixed both of these they",
    "start": "1407110",
    "end": "1414640"
  },
  {
    "text": "were different CVEs but at this point if you're using Python you should be okay",
    "start": "1414640",
    "end": "1419880"
  },
  {
    "text": "Python was not the only third-party framework that was vulnerable either though Java also had this issue",
    "start": "1419880",
    "end": "1427559"
  },
  {
    "text": "and I'll give you a second to look at that while I take a drink but this is",
    "start": "1429830",
    "end": "1437749"
  },
  {
    "text": "essentially the same vulnerability to the dotnet and Python hat we're here we're using the URL class in Java along",
    "start": "1437749",
    "end": "1445190"
  },
  {
    "text": "with the IDN class we're pulling the hostname out using the URL class and one",
    "start": "1445190",
    "end": "1450289"
  },
  {
    "text": "before we convert the hostname to ascii the URL here is again going to have the",
    "start": "1450289",
    "end": "1455330"
  },
  {
    "text": "hostname be the whole thing the evil dot c and this is the account of character the microsoft calm but",
    "start": "1455330",
    "end": "1461989"
  },
  {
    "text": "after we use the ID n dot ascii method to convert the host him to ASCII which you have to do in java if you want to",
    "start": "1461989",
    "end": "1467119"
  },
  {
    "text": "make a request now the host name is evil dot CA I reported this issue to Oracle",
    "start": "1467119",
    "end": "1473539"
  },
  {
    "text": "and this was fixed in July I haven't had a chance to review the fix because this was pretty recent but hopefully this is",
    "start": "1473539",
    "end": "1480980"
  },
  {
    "text": "good now as well okay so that was a bunch of frameworks but what if you're writing native code well if you're",
    "start": "1480980",
    "end": "1486440"
  },
  {
    "text": "writing native code in Windows your code probably is vulnerable so if you're using IDM to ask you to convert a",
    "start": "1486440",
    "end": "1493489"
  },
  {
    "text": "Unicode hostname to an ASCII hostname that windows API will actually also",
    "start": "1493489",
    "end": "1498889"
  },
  {
    "text": "convert the account a character to a /c and all of the other characters that I mentioned that also let you do these",
    "start": "1498889",
    "end": "1504379"
  },
  {
    "text": "tricks work as well but this is necessary ID and ASCII is an RFC defined",
    "start": "1504379",
    "end": "1509749"
  },
  {
    "text": "algorithm there are things that it's used for that are not host names if the behavior of this changed a lot of other",
    "start": "1509749",
    "end": "1516049"
  },
  {
    "text": "things would break it does have a flag which is the use STD 3 ASCII rules flag",
    "start": "1516049",
    "end": "1521149"
  },
  {
    "text": "I mentioned before if you use that it is safe but then it won't accept host names with underscores so there's a trade-off",
    "start": "1521149",
    "end": "1527029"
  },
  {
    "text": "there you'll have the same issue of your writing native code in Linux so in Linux",
    "start": "1527029",
    "end": "1533480"
  },
  {
    "text": "there's the cannula by DN in Lib ID in two libraries which I use to convert hostname is between unicode mouse key",
    "start": "1533480",
    "end": "1539989"
  },
  {
    "text": "and in both cases they will also convert a count of two a forward slash c and all",
    "start": "1539989",
    "end": "1546379"
  },
  {
    "text": "of the other host splits stuff works as well for libido n you can fix it by using the use STD 3 ox key rules flag",
    "start": "1546379",
    "end": "1552830"
  },
  {
    "text": "for the body and two you can use node TR 46 again no underscores if you use those",
    "start": "1552830",
    "end": "1559190"
  },
  {
    "text": "flags I did contact the maintainer zuv live ID n about this in they said it was by design and I agree",
    "start": "1559190",
    "end": "1565100"
  },
  {
    "text": "they're in exactly the same boat as Windows is with this this is an RFC defined algorithm they can't change how",
    "start": "1565100",
    "end": "1570440"
  },
  {
    "text": "it works either okay so that was host split and that only worked against Ida in a 2003 or",
    "start": "1570440",
    "end": "1578480"
  },
  {
    "start": "1572000",
    "end": "1937000"
  },
  {
    "text": "idat 2008 plus UTS 46 but I've got a different attack that works against pure ID and a 2008 so I didn't a 2008 doesn't",
    "start": "1578480",
    "end": "1588679"
  },
  {
    "text": "allow any of the characters that an able host split they won't normalize them but it does allow two characters that the",
    "start": "1588679",
    "end": "1595249"
  },
  {
    "text": "other two specifications don't and that's the zero with Joyner and the 0 with non joiner characters identity 2003",
    "start": "1595249",
    "end": "1602179"
  },
  {
    "text": "doesn't let you use these in host names because they're invisible so you would have the problem where user couldn't",
    "start": "1602179",
    "end": "1607220"
  },
  {
    "text": "tell the difference between some host name and the same hosting plus an invisible character somewhere in it but",
    "start": "1607220",
    "end": "1613549"
  },
  {
    "text": "it turns out that these characters are important for rendering certain languages for languages that use daven agario through script for instance they",
    "start": "1613549",
    "end": "1619970"
  },
  {
    "text": "change the way the ligatures work so I'd na 2008 allows these characters and host names but conditionally only if the",
    "start": "1619970",
    "end": "1627230"
  },
  {
    "text": "joiner character is between two characters that would render differently because it's there so if you put one of",
    "start": "1627230",
    "end": "1635929"
  },
  {
    "text": "these characters in a host name if you just make some hosting like micro and then a 0 with Joyner soft calm and then",
    "start": "1635929",
    "end": "1641809"
  },
  {
    "text": "try to use itna 2008 to convert it to a ski that won't get you anywhere it'll just throw away the 0 with Joyner so",
    "start": "1641809",
    "end": "1647240"
  },
  {
    "text": "it's just Microsoft calm but you remember what I said about the round-trip check that when you're going from ascii to Unicode you're supposed to",
    "start": "1647240",
    "end": "1653960"
  },
  {
    "text": "go back from Unicode to ask you and make sure you ended up with the same thing well that isn't really implemented very",
    "start": "1653960",
    "end": "1659899"
  },
  {
    "text": "often so it turns out that in i-dna 2008 implementations is often the case that if you write your own software to do the",
    "start": "1659899",
    "end": "1665929"
  },
  {
    "text": "punic coding and put app unicode at 0 with Joyner in there they're ok with that so you can make a hostname like",
    "start": "1665929",
    "end": "1671840"
  },
  {
    "text": "this this is xn - - Microsoft - for 690 com where that's got app Unicode at 0",
    "start": "1671840",
    "end": "1677149"
  },
  {
    "text": "with joinha between micro and soft and most ID and a 2008 implementations were happy to accept that host name but",
    "start": "1677149",
    "end": "1685340"
  },
  {
    "text": "that's problematic so there's two issues here first you've got this ASCII host name but if you're going to show this to",
    "start": "1685340",
    "end": "1690740"
  },
  {
    "text": "a user you're going to convert it to Unicode again and if you do that well then it just looks like Microsoft com",
    "start": "1690740",
    "end": "1696360"
  },
  {
    "text": "zero with Joyner somewhere in it sure but it's an invisible character the user can't tell and also if you remember what",
    "start": "1696360",
    "end": "1702420"
  },
  {
    "text": "I said about zero with Joyner is getting thrown away when you go from Unicode to ASCII that's what happens here so if you",
    "start": "1702420",
    "end": "1707790"
  },
  {
    "text": "convert this hostname from ASCII to Unicode then back to ASCII is just Microsoft comm so you've got the host",
    "start": "1707790",
    "end": "1713700"
  },
  {
    "text": "names that essentially mutate they go from not being something to actually being something and that is exploitable",
    "start": "1713700",
    "end": "1721100"
  },
  {
    "text": "so the host plant owner ability as an example say you've got some email server",
    "start": "1721100",
    "end": "1727830"
  },
  {
    "text": "out there that's that emailed out some cloud host net that you want to impersonate so you go register your own",
    "start": "1727830",
    "end": "1732900"
  },
  {
    "text": "domain and you stick up Unicode to deal with Joyner in it but it's otherwise the same as theirs so you make this xn - -",
    "start": "1732900",
    "end": "1738870"
  },
  {
    "text": "email - xt3 B dot some cloud host net where that's got a p-- unicode at 0 with Joyner between the E and the M what",
    "start": "1738870",
    "end": "1745650"
  },
  {
    "text": "happens if we send an email from that server well let's say we set the server up we go use let's encrypt to get a",
    "start": "1745650",
    "end": "1752640"
  },
  {
    "text": "certificate because you can they're okay with anything that's an ASCII host name and if you can set actual DNS records",
    "start": "1752640",
    "end": "1758970"
  },
  {
    "text": "you can set up D kam SPF d mark make it all look legit you send email from this to Gmail and Gmail will decode the punic",
    "start": "1758970",
    "end": "1767280"
  },
  {
    "text": "code and it will show it as coming from the server you're trying to impersonate so xn - - email etc will just show up as",
    "start": "1767280",
    "end": "1775350"
  },
  {
    "text": "email about some cloud host on that in Gmail they do the SPF and DKIM checks but they do it on the ASCII before doing",
    "start": "1775350",
    "end": "1781679"
  },
  {
    "text": "the decode so it looks legitimate but it's not and then if you try to reply to that email Gmail will throw away the 0",
    "start": "1781679",
    "end": "1788549"
  },
  {
    "text": "with Joyner again and then it goes to the real thing you're trying to impersonate so it lets you do kind of an",
    "start": "1788549",
    "end": "1794400"
  },
  {
    "text": "interesting phishing attack you can send email as anybody but you can't receive the replies I did report this to Google",
    "start": "1794400",
    "end": "1802140"
  },
  {
    "text": "in February they've acknowledged the issue they've said that they're monitoring their services to make sure that no one is exploiting this attack",
    "start": "1802140",
    "end": "1808290"
  },
  {
    "text": "against their users it's still there though also besides Google besides T",
    "start": "1808290",
    "end": "1814470"
  },
  {
    "text": "mail lib ID and - is also vulnerable to this host bond issue if you take that same host name with the punic coded 0",
    "start": "1814470",
    "end": "1820380"
  },
  {
    "text": "with Joyner in it that I described the one where it's micro 0 with during a soft calm and you tell lib ID and - to",
    "start": "1820380",
    "end": "1827010"
  },
  {
    "text": "decode it or if you did then it would do that and you would get Microsoft comm with a zero with joiner in the middle of it",
    "start": "1827010",
    "end": "1832770"
  },
  {
    "text": "which you can't see if you're in bass you'd probably get a box and you'd notice but if you're in a GUI you probably wouldn't I did report this to",
    "start": "1832770",
    "end": "1840390"
  },
  {
    "text": "the maintainer of the by the end and this was fixed in Lib IDN to version 2.2 point o as far as I'm aware the only",
    "start": "1840390",
    "end": "1847470"
  },
  {
    "text": "district at use is out right now is Debbie and unstable so you might want to talk to whoever maintains your distro to",
    "start": "1847470",
    "end": "1852660"
  },
  {
    "text": "get them to pick this up as well and I need the share credit with for this vulnerability with Tim Florian and",
    "start": "1852660",
    "end": "1857820"
  },
  {
    "text": "Nico's they helped work out the fix for this they helped worked out additional test cases they made sure fixing this",
    "start": "1857820",
    "end": "1863429"
  },
  {
    "text": "didn't break anything else so thanks to them there are a lot of limitations on",
    "start": "1863429",
    "end": "1869460"
  },
  {
    "text": "this host bond vulnerability though first like I said it only works against pure ID and a 2008 ID in a 2003 does not",
    "start": "1869460",
    "end": "1877200"
  },
  {
    "text": "allow 0 with joiners and so on it's also only ever going to be exploitable where you've got software that takes a URL",
    "start": "1877200",
    "end": "1884250"
  },
  {
    "text": "that could be a nasty URL as Punic coded and it's gonna decode it to Unicode and usually that only happens if it's",
    "start": "1884250",
    "end": "1890130"
  },
  {
    "text": "displaying it to a user so this is usually only exploitable if there's a GUI somewhere involved most",
    "start": "1890130",
    "end": "1896460"
  },
  {
    "text": "significantly though you can't get host names like this if you go to do a domain registrar like say I don't know GoDaddy",
    "start": "1896460",
    "end": "1903299"
  },
  {
    "text": "or something and you try to get like that xn - - Microsoft etc com they'll just say no some of them think they can",
    "start": "1903299",
    "end": "1910169"
  },
  {
    "text": "get it they'll take your money and then later this is a oh no we couldn't get that so you can't get host names like",
    "start": "1910169",
    "end": "1915840"
  },
  {
    "text": "this from domain registrar's but providers of third level domains generally do let you get these there's",
    "start": "1915840",
    "end": "1921360"
  },
  {
    "text": "lots of services out there we'll let that we'll let you buy a subdomain of their host name and those services",
    "start": "1921360",
    "end": "1927120"
  },
  {
    "text": "generally don't care about whether the punic code in your ascii sub domain is actually not Punic code you're supposed",
    "start": "1927120",
    "end": "1933090"
  },
  {
    "text": "to be able to use so that's how you attack this sort of thing okay so I've described host split and",
    "start": "1933090",
    "end": "1940350"
  },
  {
    "start": "1937000",
    "end": "2197000"
  },
  {
    "text": "host on how do you test for these issues well testing for host split is pretty",
    "start": "1940350",
    "end": "1946559"
  },
  {
    "text": "easy if you can monitor network traffic if you got some application running on your machine you can see what we're across that's making that all you do is",
    "start": "1946559",
    "end": "1953669"
  },
  {
    "text": "you give it a URL that has one of these magic hosts split characters in it and you see what kind of DNS lookup it tries",
    "start": "1953669",
    "end": "1958980"
  },
  {
    "text": "to perform if you use a URL like this like this see account of binkham what you want to",
    "start": "1958980",
    "end": "1966430"
  },
  {
    "text": "look for is a DNS lookup for Canada CA that means it's actually decoding that",
    "start": "1966430",
    "end": "1971470"
  },
  {
    "text": "character in the hostname into ASCII and then making a DNS lookup for the wrong thing",
    "start": "1971470",
    "end": "1976710"
  },
  {
    "text": "the ideal result for this sort of a test case is that it just doesn't make the request but if it makes your request or",
    "start": "1976710",
    "end": "1983650"
  },
  {
    "text": "a DNS lookup for some weird Unicode is subdomain of Bing comm that's also okay",
    "start": "1983650",
    "end": "1988710"
  },
  {
    "text": "it's not ideal but it's probably not exploitable if you can't monitor a",
    "start": "1988710",
    "end": "1993760"
  },
  {
    "text": "network traffic though there's a somewhat more complicated test case that you can use and that's this what you can",
    "start": "1993760",
    "end": "2000630"
  },
  {
    "text": "do is you can go and register a couple of domains in here I'll call them a calm and be calm and free be calm you'll make",
    "start": "2000630",
    "end": "2007200"
  },
  {
    "text": "a DNS wildcard record that says all subdomains of be com go to the same server and then for both",
    "start": "2007200",
    "end": "2013530"
  },
  {
    "text": "a calm and be calm you'll set up servers that will just record all the network traffic that goes to them then you'll give a URL like this to the thing you're",
    "start": "2013530",
    "end": "2020250"
  },
  {
    "text": "trying to test say it's someone else's web service where it's a calm and then a full-width solidus and then like X be",
    "start": "2020250",
    "end": "2027420"
  },
  {
    "text": "calm and what this is going to do is if this is vulnerable to hosts split the",
    "start": "2027420",
    "end": "2033360"
  },
  {
    "text": "software that you're looking at it's going to decode that full-width solidus into a forward slash and it will try to make a request to a calm if it's not",
    "start": "2033360",
    "end": "2040560"
  },
  {
    "text": "vulnerable it either won't make a request or it'll make a request to be calm and since you're recording network",
    "start": "2040560",
    "end": "2045780"
  },
  {
    "text": "traffic on both servers you know which one of those it did this lets you test",
    "start": "2045780",
    "end": "2050970"
  },
  {
    "text": "things that you can directly monitor the traffic for host bond is a little more",
    "start": "2050970",
    "end": "2058290"
  },
  {
    "text": "complicated to test for for host bond you need to consider cases where there might be an untrusted URL that's",
    "start": "2058290",
    "end": "2064648"
  },
  {
    "text": "provided to your software that it's going to be converted to unicode this usually means that someone's providing",
    "start": "2064649",
    "end": "2069840"
  },
  {
    "text": "you a URL that's going to show up inside of a GUI somewhere and once you've",
    "start": "2069840",
    "end": "2075750"
  },
  {
    "text": "identified the cases where that's going to happen there's a lot of different test cases you need to try so there's a",
    "start": "2075750",
    "end": "2080970"
  },
  {
    "text": "zero with joiner I mentioned so you can use a Punic coded 0 with joiner and there's an example here and that should",
    "start": "2080970",
    "end": "2087750"
  },
  {
    "text": "not be rendered as a zero with joiner that should always either show off this Punic code not be rendered but it should",
    "start": "2087750",
    "end": "2092790"
  },
  {
    "text": "never happen that it just turns into something that looks like it's not there you can also you should also test what",
    "start": "2092790",
    "end": "2099340"
  },
  {
    "text": "I'm calling the bubble numbers these are unicode characters that are essentially numerals with circles around them they",
    "start": "2099340",
    "end": "2104890"
  },
  {
    "text": "normalized to just asking numerals so sometimes you'll see essentially a 2-step normalization and for those what",
    "start": "2104890",
    "end": "2112840"
  },
  {
    "text": "you want is essentially that it's either rejected or it shows up as Punic code it shouldn't show up as the circled numeral",
    "start": "2112840",
    "end": "2118060"
  },
  {
    "text": "and it should not show up as just an ASCII numeral finally there's the Greek question mark character which is kind of",
    "start": "2118060",
    "end": "2125320"
  },
  {
    "text": "a magical unicode character that lots of software likes to turn into semicolons even if it's not trying to do normalization for complicated reasons so",
    "start": "2125320",
    "end": "2133660"
  },
  {
    "text": "you computer code one of those and if you stick that in a host name it should never look like a semicolon anything",
    "start": "2133660",
    "end": "2139090"
  },
  {
    "text": "that looks like a semicolon from that Punic code is a vulnerability and this is a sort of thing that you might use to",
    "start": "2139090",
    "end": "2144490"
  },
  {
    "text": "attack lists of host names or maybe email where you have semicolons to separate different things and you also",
    "start": "2144490",
    "end": "2153010"
  },
  {
    "text": "need to remember that the host spawned vulnerability is not just a web vulnerability so I explained earlier how",
    "start": "2153010",
    "end": "2159430"
  },
  {
    "text": "this could be used against email but a host bond can also be used as an attack against I am protocols like sip or other",
    "start": "2159430",
    "end": "2165460"
  },
  {
    "text": "network protocols that use host names either directly or an email addresses or something like that one useful test case",
    "start": "2165460",
    "end": "2173200"
  },
  {
    "text": "for host bond if you're using it with or trying to test email is to essentially send email to an email address you",
    "start": "2173200",
    "end": "2179500"
  },
  {
    "text": "control but at a second recipient which has one of these vApp unicode host names",
    "start": "2179500",
    "end": "2184900"
  },
  {
    "text": "in it it probably won't receive email but you can see what it looks like when you receive the email and if that second",
    "start": "2184900",
    "end": "2191350"
  },
  {
    "text": "recipient shows up with the bad punic code it decoded that's also a vulnerability okay so that's how you",
    "start": "2191350",
    "end": "2199030"
  },
  {
    "start": "2197000",
    "end": "2417000"
  },
  {
    "text": "test for this what are some best practices for preventing this vulnerability or fixing it in your",
    "start": "2199030",
    "end": "2204610"
  },
  {
    "text": "software well first and this is something I really want to emphasize software needs to make all of its",
    "start": "2204610",
    "end": "2210910"
  },
  {
    "text": "decisions about host names using ASCII most software if it's dealing with a",
    "start": "2210910",
    "end": "2216070"
  },
  {
    "text": "host name has something that's just a string some type called string maybe and it's not thinking about well is this an",
    "start": "2216070",
    "end": "2222670"
  },
  {
    "text": "ascii URL is this a unicode URL so if you're doing some sort of a comparison or a regular expression against a",
    "start": "2222670",
    "end": "2228520"
  },
  {
    "text": "hostname before you do that you must convert it to an ascii hostname if",
    "start": "2228520",
    "end": "2233900"
  },
  {
    "text": "this is something you can set as a security policy it's a good rule only compare host names as ascii lots of code",
    "start": "2233900",
    "end": "2240680"
  },
  {
    "text": "does this wrong lots of platform code does this wrong this is really pervasive as a vulnerability second if you're",
    "start": "2240680",
    "end": "2248870"
  },
  {
    "text": "doing conversions in your own software between unicode and ascii host names you need to use the STD three ASCII Rules",
    "start": "2248870",
    "end": "2255020"
  },
  {
    "text": "flag if you're using the STD three ASCII rules flag and you try to convert a",
    "start": "2255020",
    "end": "2260060"
  },
  {
    "text": "Unicode hostname to an ASCII hostname and it's going to introduce some syntax character like a forward slash it'll just fail this does mean that you",
    "start": "2260060",
    "end": "2268190"
  },
  {
    "text": "can no longer talk to host names that contain underscores you might want to set a policy that says we don't make",
    "start": "2268190",
    "end": "2273710"
  },
  {
    "text": "host names with underscores anymore it makes this issue easier to fix finally",
    "start": "2273710",
    "end": "2280160"
  },
  {
    "text": "you might have code that relies on platform code that's already vulnerable there's lots of api's out there that are",
    "start": "2280160",
    "end": "2286820"
  },
  {
    "text": "vulnerable to host split what you can do is write a wrapper function that says before I call this API I'm going to make",
    "start": "2286820",
    "end": "2293150"
  },
  {
    "text": "sure the URL I passed to it isn't going to cause a hosted vulnerability so what you can do is essentially do an ASCII",
    "start": "2293150",
    "end": "2299930"
  },
  {
    "text": "conversion yourself on just the host name and see if the host name you end up with contains syntax characters or you",
    "start": "2299930",
    "end": "2306350"
  },
  {
    "text": "can just use the STD three off scheme Google's five when you do that before you pass it off to the platform code for",
    "start": "2306350",
    "end": "2312500"
  },
  {
    "text": "the other side of things for host pond vulnerabilities you need to worry about cases where an ASCII URL is being passed",
    "start": "2312500",
    "end": "2318650"
  },
  {
    "text": "to something maybe just a URL string that's going to display it or otherwise",
    "start": "2318650",
    "end": "2324710"
  },
  {
    "text": "deal with it might convert it to Unicode a lot of how this is going to be controls of different sort that you might be using if you're going to pass a",
    "start": "2324710",
    "end": "2332030"
  },
  {
    "text": "hostname off to a control what you want to do is essentially try converting it to Unicode if it's punic code and then",
    "start": "2332030",
    "end": "2338570"
  },
  {
    "text": "convert it back to ASCII and make sure you end up with the same thing you started with if the host name you end up",
    "start": "2338570",
    "end": "2344990"
  },
  {
    "text": "with at the end isn't what you started with you want to just throw away the URL not hand it off to the control not hand",
    "start": "2344990",
    "end": "2350780"
  },
  {
    "text": "it off to the API so your wrapper function prevents about the thing from happening",
    "start": "2350780",
    "end": "2356529"
  },
  {
    "text": "so I'm hoping that people in this audience people who see this talk though and make this better please test your",
    "start": "2357800",
    "end": "2363620"
  },
  {
    "text": "software for Unicode normalization vulnerabilities please only compare host names as ASCII make a policy for that if",
    "start": "2363620",
    "end": "2370970"
  },
  {
    "text": "it's something that you can do and if you're someone who attacks things if you're on the other side of things please go get bounties with this this",
    "start": "2370970",
    "end": "2377780"
  },
  {
    "text": "vulnerability has worked in almost everything I've looked at and so I'm expecting it still works in a lot of a",
    "start": "2377780",
    "end": "2383240"
  },
  {
    "text": "lot of things I haven't looked at all the software out there I haven't even looked at most of the platforms people",
    "start": "2383240",
    "end": "2388280"
  },
  {
    "text": "build web services on so there's probably lots of places you can go and get fun CVEs maybe some money out of",
    "start": "2388280",
    "end": "2394730"
  },
  {
    "text": "this and if you do that people will pay attention and this will also start to get better and that's my goal for the",
    "start": "2394730",
    "end": "2403850"
  },
  {
    "text": "day and that's all I had to say so are there any questions from that",
    "start": "2403850",
    "end": "2409000"
  },
  {
    "text": "[Applause]",
    "start": "2409000",
    "end": "2419760"
  }
]