[
  {
    "start": "0",
    "end": "0"
  },
  {
    "text": "foreign",
    "start": "1979",
    "end": "4159"
  },
  {
    "text": "welcome I'm going to talk about attacking Kerberos as it's used in",
    "start": "9780",
    "end": "16980"
  },
  {
    "text": "Windows Active Directory from a small theoretical crypto bug to",
    "start": "16980",
    "end": "24960"
  },
  {
    "text": "eventually turning that into a practical exploit my name is Tonto forz I work for sa pen",
    "start": "24960",
    "end": "33960"
  },
  {
    "text": "tester and vulnerability researcher for Sakura a security specialist based in the Netherlands in a subsidiary of",
    "start": "33960",
    "end": "39960"
  },
  {
    "text": "Bureau veritas uh two years ago I discovered the zero logon of vulnerability which was due to",
    "start": "39960",
    "end": "47460"
  },
  {
    "text": "a crypto bug in ad that turned out uh to have some pretty big consequences uh and",
    "start": "47460",
    "end": "53760"
  },
  {
    "text": "it also got me it's all cats uh black hat USA so I thought well Windows uh",
    "start": "53760",
    "end": "59039"
  },
  {
    "text": "active directory crypto stuff seems like a nice research area maybe it can get me into blackheads again and uh well it did",
    "start": "59039",
    "end": "66840"
  },
  {
    "text": "so uh first I'm going to give a brief introduction about Kerberos",
    "start": "66840",
    "end": "74400"
  },
  {
    "text": "um and the specific uh encryption type uh where I found a vulnerability",
    "start": "74400",
    "end": "79920"
  },
  {
    "text": "uh then I'm going to relate that to the protocol where that's vulnerability can actually be exploited the uh pack",
    "start": "79920",
    "end": "86640"
  },
  {
    "text": "protocol uh showing how to exploit it uh",
    "start": "86640",
    "end": "92220"
  },
  {
    "text": "then exploiting it in a different manner and seeing what we can actually do with that and how well Microsoft responded to",
    "start": "92220",
    "end": "100140"
  },
  {
    "text": "this and some lessons learned ah so Kerberos is a network Authentication",
    "start": "100140",
    "end": "108659"
  },
  {
    "start": "104000",
    "end": "104000"
  },
  {
    "text": "Protocol uh it was originally designed by MIT in the late 80s but probably the",
    "start": "108659",
    "end": "115200"
  },
  {
    "text": "most common implementation in practice is actually active directory which uses Kerberos for Authentication",
    "start": "115200",
    "end": "121560"
  },
  {
    "text": "and the main idea behind it is that members of a network can authenticate to each other without having to send",
    "start": "121560",
    "end": "129300"
  },
  {
    "text": "passwords to each other but instead there's one single Central Surfer a key distribution",
    "start": "129300",
    "end": "135239"
  },
  {
    "text": "center in active directory that's domain controller and they maintain shared secrets in the form of cryptographic",
    "start": "135239",
    "end": "141840"
  },
  {
    "text": "keys that I share with every single member of the domain so when Alice wants",
    "start": "141840",
    "end": "147420"
  },
  {
    "text": "to uh log in to Bob or to communicate securely with Bob Ellis asks this KDC uh",
    "start": "147420",
    "end": "154920"
  },
  {
    "text": "Hey I want to talk to Bob KDC says okay here is a so-called tickets and a ticket",
    "start": "154920",
    "end": "160200"
  },
  {
    "text": "is really just an encrypted message intended for Bob that only Bob and the KDC themselves can encrypt for Alice",
    "start": "160200",
    "end": "167040"
  },
  {
    "text": "cannot decrypt it it's just an opaque a block of bytes so then Alice passes this tickets on to Bob Bob decrypts it and",
    "start": "167040",
    "end": "173640"
  },
  {
    "text": "sees inside the tickets okay the owner of this ticket is named Alice has these privileges and then Bob knows that this",
    "start": "173640",
    "end": "180959"
  },
  {
    "text": "is else this of course Very simplified um but what's important here is that um",
    "start": "180959",
    "end": "186540"
  },
  {
    "text": "the type of encryption that you can use to make these tickets and to run the",
    "start": "186540",
    "end": "192480"
  },
  {
    "text": "various steps of the protocols um there's various options there",
    "start": "192480",
    "end": "197580"
  },
  {
    "text": "um over time these changed and I'm going to zoom in on one specific",
    "start": "197580",
    "end": "202860"
  },
  {
    "text": "encryption type namely rc4 hmac",
    "start": "202860",
    "end": "208379"
  },
  {
    "start": "207000",
    "end": "207000"
  },
  {
    "text": "so the rc4 hmac or the rc4 hmac md5 type is one of the three standard default",
    "start": "208379",
    "end": "215159"
  },
  {
    "text": "support encryption types in Kerberos and windows but it generally also supported",
    "start": "215159",
    "end": "220620"
  },
  {
    "text": "by MIT or Heimdall implementations because they have to interact with Windows",
    "start": "220620",
    "end": "226159"
  },
  {
    "text": "there's also desk encryption types and a bunch of others but in a default active",
    "start": "226159",
    "end": "231840"
  },
  {
    "text": "directory setup you won't see those um and any and someone who is familiar with cryptography uh and sees this name",
    "start": "231840",
    "end": "239940"
  },
  {
    "text": "May uh well this may erase some red flags first of all we have rc4",
    "start": "239940",
    "end": "245760"
  },
  {
    "text": "uh a stream Cipher that is well known to be broken and by broken I mean is that",
    "start": "245760",
    "end": "250980"
  },
  {
    "text": "the key stream it generates has statistical biases and that means that if you encrypt the same uh the same",
    "start": "250980",
    "end": "257100"
  },
  {
    "text": "thing a lot of times um eventually you may be able to recover this uh plain text uh so that's already",
    "start": "257100",
    "end": "265440"
  },
  {
    "text": "not very good in an Authentication Protocol of course actually exploiting this aspect in in Kerberos there's not",
    "start": "265440",
    "end": "272520"
  },
  {
    "text": "that many uh static secrets that are encrypted uh with the same key A lot of times uh seems a bit difficult but still",
    "start": "272520",
    "end": "280320"
  },
  {
    "text": "uh potentially problematic another red flag is md5 md5 is a hash",
    "start": "280320",
    "end": "286979"
  },
  {
    "text": "function uh where it is possible to compute collisions so two different inputs that produce the same hash that's",
    "start": "286979",
    "end": "293580"
  },
  {
    "text": "not something you want a hash function to do uh but luckily uh they also use hmac and",
    "start": "293580",
    "end": "299580"
  },
  {
    "text": "this is the one uh cryptographic primitive that shouldn't raise red flags hmac is actually great it's",
    "start": "299580",
    "end": "305759"
  },
  {
    "text": "um converts a hash function into an cryptographic authentication function a message authentication codes or Mac",
    "start": "305759",
    "end": "313139"
  },
  {
    "text": "um and if and it works well even if the hash function in question is no longer",
    "start": "313139",
    "end": "318600"
  },
  {
    "text": "Collision free so hmd5 by itself is a broken hash function but when you",
    "start": "318600",
    "end": "324300"
  },
  {
    "text": "combine it with the hmac instruction it is still a perfectly adequate authenticator there are no known",
    "start": "324300",
    "end": "330419"
  },
  {
    "text": "practical attacks on HVAC md5 whenever it's used correctly",
    "start": "330419",
    "end": "335520"
  },
  {
    "text": "uh well besides these potentially Troublesome Primitives",
    "start": "335520",
    "end": "340800"
  },
  {
    "text": "there's also some known issues with this Cipher and it mostly has to do with the way it actually derives the uh",
    "start": "340800",
    "end": "347940"
  },
  {
    "start": "341000",
    "end": "341000"
  },
  {
    "text": "encryption key which is based on the user passwords and specifically the ntlm hash of a user's password that's also",
    "start": "347940",
    "end": "354479"
  },
  {
    "text": "used for legacy ntlm protocol and also the thing that's domain controllers store uh one of the problems is that once you",
    "start": "354479",
    "end": "360900"
  },
  {
    "text": "have an antelam hash obtained to some other means you can uh you can already",
    "start": "360900",
    "end": "366120"
  },
  {
    "text": "request a ticket you have enough material to authenticate a so-called overpass the hazard hash attacks which",
    "start": "366120",
    "end": "371880"
  },
  {
    "text": "is very useful for pen testers also the key derivation function it uses",
    "start": "371880",
    "end": "377220"
  },
  {
    "text": "to turn your ntlm hash into an encryption key and also nclam itself",
    "start": "377220",
    "end": "382740"
  },
  {
    "text": "neither of these are built to resist a dictionary or Brute Force attacks you can compute them very efficiently so you",
    "start": "382740",
    "end": "389039"
  },
  {
    "text": "can try millions of passwords and click succession and see which one matches the key so once you obtain something",
    "start": "389039",
    "end": "394740"
  },
  {
    "text": "encrypted with the passwords you can go brute forcing very easily and figure out which password the material was",
    "start": "394740",
    "end": "402120"
  },
  {
    "text": "encrypted with and it's used to make kerberosting attacks a lot more efficient",
    "start": "402120",
    "end": "408300"
  },
  {
    "text": "um there are also some downgrade problems where you could uh cause her first to use the uh this week of Cypher",
    "start": "408300",
    "end": "414720"
  },
  {
    "text": "for encryption and there's also a very interesting reason to take by James Forshaw that involved downgrading",
    "start": "414720",
    "end": "421560"
  },
  {
    "text": "um active directory to a legacy variant of the cipher that didn't include the hmac md5 part so basically it was",
    "start": "421560",
    "end": "427819"
  },
  {
    "text": "unauthenticated rc4 and it allowed you to do all kinds of interesting attacks",
    "start": "427819",
    "end": "433620"
  },
  {
    "text": "um and also because especially due to the use of rc4 and generally you this",
    "start": "433620",
    "end": "438780"
  },
  {
    "text": "Cipher is recommended against um it's deprecated uh by CIS benchmarks",
    "start": "438780",
    "end": "444900"
  },
  {
    "text": "and rfcs but if you have a standards Windows setup and to be fair almost every active directory instantiation I",
    "start": "444900",
    "end": "451860"
  },
  {
    "text": "encounter in practice this Cipher is still supported as some fallback function uh specialist fallback",
    "start": "451860",
    "end": "458220"
  },
  {
    "text": "functionality when the more recent ciphers are not available",
    "start": "458220",
    "end": "463400"
  },
  {
    "text": "so what I was interested in because most of the uh prior weaknesses uh well mostly about the key derivation or like",
    "start": "464400",
    "end": "471240"
  },
  {
    "text": "variants of this Cipher I wanted to look at how this mechanism was designed itself",
    "start": "471240",
    "end": "477120"
  },
  {
    "text": "um rc4 hmac as used in Kerberos is defined in RFC uh 4757 and it defines",
    "start": "477120",
    "end": "484440"
  },
  {
    "text": "four different algorithms um one or two message authentication code",
    "start": "484440",
    "end": "492000"
  },
  {
    "text": "algorithms and two authenticated encryption algorithms the first two are",
    "start": "492000",
    "end": "497460"
  },
  {
    "text": "used within Kerberos related protocols themselves and the second two are exported through the GSS API which",
    "start": "497460",
    "end": "505259"
  },
  {
    "text": "basically a standardized interface to do encryption to other protocols like",
    "start": "505259",
    "end": "512719"
  },
  {
    "text": "RPC protocols ldap win a rem and the like and usually well off the",
    "start": "512719",
    "end": "520200"
  },
  {
    "text": "authenticated with Kerberos you can negotiate a key and then these protocols can then use these algorithms to perform",
    "start": "520200",
    "end": "528240"
  },
  {
    "text": "transport encryption for example uh probably the most important of these functions is the encrypt function",
    "start": "528240",
    "end": "533940"
  },
  {
    "text": "because that is actually used to create Kerberos tickets",
    "start": "533940",
    "end": "538519"
  },
  {
    "text": "um so I started to take a look at the specification and how these different algorithms were defined and I already",
    "start": "539880",
    "end": "546300"
  },
  {
    "text": "noticed something that looks a little bit problematic here and maybe some of you will already be able to spot it and",
    "start": "546300",
    "end": "552540"
  },
  {
    "text": "this is this the checksum function it's basically to provide a cryptographic",
    "start": "552540",
    "end": "557640"
  },
  {
    "text": "authentication within Kerberos protocols themselves and what I noticed here is that",
    "start": "557640",
    "end": "564779"
  },
  {
    "text": "um this function takes uh well a type indicator and the data it wants to authenticate computes an md5 hash over",
    "start": "564779",
    "end": "572160"
  },
  {
    "text": "this data and then calculates hmac and D5 over this hash so it hashes first and",
    "start": "572160",
    "end": "578399"
  },
  {
    "text": "then does hmac again well if it would just hmac the data directly there would be no problem",
    "start": "578399",
    "end": "584760"
  },
  {
    "text": "but in this case well md5 is vulnerable to Collision attacks so if this data if",
    "start": "584760",
    "end": "591420"
  },
  {
    "text": "you have two different pieces of data and they would collide uh you would be hmacking the exact same",
    "start": "591420",
    "end": "596459"
  },
  {
    "text": "hash so even though hmac itself is secure even when used with amd5 if you",
    "start": "596459",
    "end": "601560"
  },
  {
    "text": "try to hmac and md5 hash um and you have two inputs that's uh",
    "start": "601560",
    "end": "607260"
  },
  {
    "text": "whose md5 hashes collides you'll also get a checksum coalition which basically",
    "start": "607260",
    "end": "613140"
  },
  {
    "text": "means there's a theoretical forgery attack possible here that was not just the case for just a",
    "start": "613140",
    "end": "618779"
  },
  {
    "text": "checksum function also the two GSS API functions uh basically had the exact",
    "start": "618779",
    "end": "624480"
  },
  {
    "text": "same uh problem uh they would first compute an nd5 hash of the data and then",
    "start": "624480",
    "end": "631560"
  },
  {
    "text": "they would authenticate that nd5 hash so if you could have nd5 collisions in your",
    "start": "631560",
    "end": "636779"
  },
  {
    "text": "data you could have collisions in your authentication tag in the case of the encryption function it would allow a",
    "start": "636779",
    "end": "642720"
  },
  {
    "text": "type of chosen ciphertext attack as well um the only function that was not vulnerable luckily or maybe not so lucky",
    "start": "642720",
    "end": "649440"
  },
  {
    "text": "for me was the most important one the one to create gerberos tickets this one actually used hmac md5 properly I didn't",
    "start": "649440",
    "end": "656279"
  },
  {
    "text": "do any pre-hashing so um this one was not vulnerable at all so any kind of collision attacks would not",
    "start": "656279",
    "end": "663060"
  },
  {
    "text": "work directly on Kerberos tickets only on any kind of mechanism that used the other functions",
    "start": "663060",
    "end": "669980"
  },
  {
    "start": "670000",
    "end": "670000"
  },
  {
    "text": "also the other problem with actually trying to exploit this theoretical vulnerability is that there are some",
    "start": "670140",
    "end": "677880"
  },
  {
    "text": "constraints in what you can actually do with an nd5 Collision there's different types of collisions you can compute the",
    "start": "677880",
    "end": "684000"
  },
  {
    "text": "uh the one that's really cheap and efficient is a so-called identical prefix Collision there you pick some",
    "start": "684000",
    "end": "690899"
  },
  {
    "text": "prefix or message you choose yourself and you do the computation and you get",
    "start": "690899",
    "end": "697019"
  },
  {
    "text": "two different variants that have some uh well basically random data appended different random data you can also add",
    "start": "697019",
    "end": "703260"
  },
  {
    "text": "some suffix to that and these two messages available have the same prefix and suffix the random part in the middle",
    "start": "703260",
    "end": "709320"
  },
  {
    "text": "will be different so you have two different messages with the same hash and that can be if you employed",
    "start": "709320",
    "end": "714779"
  },
  {
    "text": "carefully and depending on the protocol you can do useful things with this but it's pretty restrictive uh basically the",
    "start": "714779",
    "end": "721140"
  },
  {
    "text": "most powerful known Collision attack is it chosen prefix Collision there you have two completely different prefixes",
    "start": "721140",
    "end": "727100"
  },
  {
    "text": "then you do an X more expensive computation well expensive",
    "start": "727100",
    "end": "732380"
  },
  {
    "text": "let's say on commodity Hardware takes a few hours it's it's not that uh infeasible",
    "start": "732380",
    "end": "740120"
  },
  {
    "text": "um you do some calculating you produce a lot of random bytes that you add to both messages",
    "start": "740279",
    "end": "745980"
  },
  {
    "text": "and then you create two messages with these two different prefixes that you",
    "start": "745980",
    "end": "751320"
  },
  {
    "text": "picked a lot of random garbage data and they have the same md5 hash and afterwards you can also add the same",
    "start": "751320",
    "end": "757440"
  },
  {
    "text": "suffix to both messages um and yeah you have two different",
    "start": "757440",
    "end": "762600"
  },
  {
    "text": "messages with a lot more control that have the same md5 hash unfortunately what you can't do is you",
    "start": "762600",
    "end": "770700"
  },
  {
    "text": "just have some message with a certain hash that's defined by someone else uh in this case uh you would have hxm",
    "start": "770700",
    "end": "777120"
  },
  {
    "text": "computed over some interesting message and you just come up with another message that happens to have the same",
    "start": "777120",
    "end": "782220"
  },
  {
    "text": "hash that would be a type of free image attack and no practically executable pre-image attacks against nd5 are",
    "start": "782220",
    "end": "789360"
  },
  {
    "text": "possible so we can't just get grab some authenticated message come up with something else with the same hash and",
    "start": "789360",
    "end": "795839"
  },
  {
    "text": "attach the attack again so we are pretty Limited",
    "start": "795839",
    "end": "801079"
  },
  {
    "start": "800000",
    "end": "800000"
  },
  {
    "text": "so let's say we want to exploit this uh these vulnerabilities",
    "start": "801500",
    "end": "806540"
  },
  {
    "text": "uh we need to find a scenario where a number of",
    "start": "806540",
    "end": "812279"
  },
  {
    "text": "um uh constraints apply uh we need",
    "start": "812279",
    "end": "817320"
  },
  {
    "text": "to be able to prepare two different messages that have the same md5 hash that here is like an identical prefix",
    "start": "817320",
    "end": "823980"
  },
  {
    "text": "Collision or a chosen prefix Collision so they will probably include a lot of random data in the middle their suffixes",
    "start": "823980",
    "end": "830639"
  },
  {
    "text": "must be identical you can only control their prefixes really and the first of these two messages actually needs to be produced or",
    "start": "830639",
    "end": "838079"
  },
  {
    "text": "authenticated by a server um so if you have this Jackson function",
    "start": "838079",
    "end": "843600"
  },
  {
    "text": "the server needs to be executing the detection function on this first message including all these Coalition bytes",
    "start": "843600",
    "end": "850860"
  },
  {
    "text": "um this is probably the trickiest part of the attack like there's a famous attack against x509 certificates that",
    "start": "850860",
    "end": "857519"
  },
  {
    "text": "was also used by the flame malware back when it was still possible to have nd5 signatures in there in those",
    "start": "857519",
    "end": "863639"
  },
  {
    "text": "certificates there's a serial number and the tricky part is when you request a certificate you cannot determine the",
    "start": "863639",
    "end": "868860"
  },
  {
    "text": "serial number so the attackers actually had to do a lot of effort in trying to guess what the schedule number would be",
    "start": "868860",
    "end": "873899"
  },
  {
    "text": "and pre-computing a lot of collisions and here there's some similar issues you",
    "start": "873899",
    "end": "879000"
  },
  {
    "text": "need to be able to get something uh authenticated that you can completely predict but that you have to pre-compute",
    "start": "879000",
    "end": "886320"
  },
  {
    "text": "so when when a surfer gives you this M1 message you can then well take the",
    "start": "886320",
    "end": "893399"
  },
  {
    "text": "authentication tag from that and put it on your other colliding message and then this other message needs to give you",
    "start": "893399",
    "end": "899459"
  },
  {
    "text": "some achieve some kind of attack or goal because if the attacker already knows",
    "start": "899459",
    "end": "904500"
  },
  {
    "text": "the key well this is not very useful and if an attacker is capable of getting M1 signs there needs to be some other M2",
    "start": "904500",
    "end": "912060"
  },
  {
    "text": "that they cannot get signs through other means uh so yeah the challenges here are you",
    "start": "912060",
    "end": "917279"
  },
  {
    "text": "have to find um basically uh something that will produce this first type of message this",
    "start": "917279",
    "end": "923040"
  },
  {
    "text": "first type of message needs to complain a lot of random data that you control and you need to break some type of",
    "start": "923040",
    "end": "928500"
  },
  {
    "text": "security boundary so with this in mind I started going through uh active directory protocols",
    "start": "928500",
    "end": "935940"
  },
  {
    "text": "trying to look for something that used any of these functions I use them in a way where this attack and all these",
    "start": "935940",
    "end": "942540"
  },
  {
    "text": "conditions May potentially apply and that's where I landed on the back",
    "start": "942540",
    "end": "947940"
  },
  {
    "text": "signature protocol um this is a open protocol specification",
    "start": "947940",
    "end": "954959"
  },
  {
    "start": "950000",
    "end": "950000"
  },
  {
    "text": "for Microsoft and I noticed uh on a page there's a feature called a pack",
    "start": "954959",
    "end": "960180"
  },
  {
    "text": "signature and it makes use of the vulnerable checks and function that I showed you before so the Kerberos",
    "start": "960180",
    "end": "966959"
  },
  {
    "text": "authentication mechanism that first computes an nd5 hash and then does an hmac this is part of the so-called spec",
    "start": "966959",
    "end": "975380"
  },
  {
    "start": "973000",
    "end": "973000"
  },
  {
    "text": "protocol the privileged attribute certificates this is basically a Windows",
    "start": "975380",
    "end": "980699"
  },
  {
    "text": "extension to Kerberos to provide authorization information inside the tickets because Kerberos by itself only",
    "start": "980699",
    "end": "987060"
  },
  {
    "text": "provides authentication and it gives you like an identifier of who's trying to log in but it doesn't really tell any",
    "start": "987060",
    "end": "994019"
  },
  {
    "text": "surface what the Privileges of that user are that's basically an extension that's left up to implementations so in active",
    "start": "994019",
    "end": "1000380"
  },
  {
    "text": "directory a pack data structure is used and this data structure is embedded in",
    "start": "1000380",
    "end": "1006920"
  },
  {
    "text": "an already encrypted ticket and what's in the part that interests me are these signatures on the data",
    "start": "1006920",
    "end": "1013579"
  },
  {
    "text": "structure so first of all there is a surfer so-called server signature which uses the same key that's already used in",
    "start": "1013579",
    "end": "1020240"
  },
  {
    "text": "that encrypted tickets and there is a KDC signature",
    "start": "1020240",
    "end": "1025520"
  },
  {
    "text": "um that is made by uh the prb TTT key which is a key that only the domain",
    "start": "1025520",
    "end": "1030918"
  },
  {
    "text": "controller knows and what's interesting here is that",
    "start": "1030919",
    "end": "1036079"
  },
  {
    "text": "normally you would say well this is already part of an encrypted tickets if I get a ticket I should not",
    "start": "1036079",
    "end": "1043280"
  },
  {
    "text": "be able to decrypt it or mess with any contents of it so the pack should already protect it so why are there is",
    "start": "1043280",
    "end": "1050780"
  },
  {
    "text": "there still any cryptography being done here now according to the documentation this",
    "start": "1050780",
    "end": "1055820"
  },
  {
    "text": "is to facilitate a functionality called pack validation and that addresses back",
    "start": "1055820",
    "end": "1060919"
  },
  {
    "text": "spoofing uh well guiding against certain types of privilege elevation attacks in",
    "start": "1060919",
    "end": "1067700"
  },
  {
    "text": "certain contexts so there are cases when you actually are in a position to mess with the pack in uh in a checkup like",
    "start": "1067700",
    "end": "1075080"
  },
  {
    "text": "you have and this security feature is supposed to prevent this so okay apparently you can achieve",
    "start": "1075080",
    "end": "1082160"
  },
  {
    "text": "interesting uh uh goes with this otherwise the security feature would not be here",
    "start": "1082160",
    "end": "1087500"
  },
  {
    "text": "so let's take a look at how we could use this uh cryptographic vulnerability to",
    "start": "1087500",
    "end": "1094760"
  },
  {
    "text": "spoof one of these back data structures",
    "start": "1094760",
    "end": "1099160"
  },
  {
    "text": "so first of all we need to get a lot of random bytes",
    "start": "1100160",
    "end": "1105919"
  },
  {
    "text": "inside our back data structure and then gets the domain controller to authenticate it for us",
    "start": "1105919",
    "end": "1113000"
  },
  {
    "text": "um when you're a you have a low prefetched domain user you can't really",
    "start": "1113000",
    "end": "1118039"
  },
  {
    "text": "contain the contents of your own pack you can get a copy of your pack that shows you all your privileges but",
    "start": "1118039",
    "end": "1125179"
  },
  {
    "text": "basically all the fields in there are not directly under your control uh however",
    "start": "1125179",
    "end": "1131059"
  },
  {
    "text": "um Regular domain users by default can join up to 10 computer accounts to the XF directory and once you add a computer",
    "start": "1131059",
    "end": "1138260"
  },
  {
    "text": "account that gives you control to a lot of ldap properties of that computer account that you can't control for your",
    "start": "1138260",
    "end": "1143539"
  },
  {
    "text": "own accounts which includes properties like uh the script pulse property which",
    "start": "1143539",
    "end": "1151039"
  },
  {
    "text": "is basically a long string containing a parts it's supposed to points to something to run when logging in it's",
    "start": "1151039",
    "end": "1156980"
  },
  {
    "text": "not actually really used for computer accounts but it is included inside a pack data structure and it gives us more",
    "start": "1156980",
    "end": "1162799"
  },
  {
    "text": "than enough space to put in all these Collision bytes only problem though this field and",
    "start": "1162799",
    "end": "1168380"
  },
  {
    "text": "basically all the other pack Fields uh when needs to be textural strings they",
    "start": "1168380",
    "end": "1174140"
  },
  {
    "text": "need to contain valid unicodes and they will be encoded as utf-16 while if we",
    "start": "1174140",
    "end": "1179360"
  },
  {
    "text": "compute an nd5 Collision are the bytes that this Collision algorithm generates are basically random I do not have to",
    "start": "1179360",
    "end": "1186020"
  },
  {
    "text": "match unicorns luckily the chance that a bunch of",
    "start": "1186020",
    "end": "1191660"
  },
  {
    "text": "random bytes just happen to be valid utf-16 or at least valid and off for",
    "start": "1191660",
    "end": "1197020"
  },
  {
    "text": "Windows to accept it it's pretty large utf-16",
    "start": "1197020",
    "end": "1203679"
  },
  {
    "text": "uses 16 bits words that each represent a single Unicode code points",
    "start": "1203679",
    "end": "1210039"
  },
  {
    "text": "and most of them uh basically most two byte combinations uh will just be",
    "start": "1210039",
    "end": "1216500"
  },
  {
    "text": "accepted and mapped to some kind of code points and even if it's not assigned anywhere",
    "start": "1216500",
    "end": "1221539"
  },
  {
    "text": "um windows will not mind if you said put that in an ldap property the only exception to this are a few uh surrogate",
    "start": "1221539",
    "end": "1228380"
  },
  {
    "text": "characters and these basically indicates they always need to be two of these in a row and these allow you to kind of",
    "start": "1228380",
    "end": "1235220"
  },
  {
    "text": "extend the character space and allow you to encode even more characters by using",
    "start": "1235220",
    "end": "1240740"
  },
  {
    "text": "uh 32 bits instead of 16 bits and when a surrogates",
    "start": "1240740",
    "end": "1246940"
  },
  {
    "text": "word is put next to something that's not uh a correctly matching other circuits",
    "start": "1246940",
    "end": "1253400"
  },
  {
    "text": "words then it's no longer valid unicodes then it can no longer be properly encoded using utf-16 and a huge F16",
    "start": "1253400",
    "end": "1261740"
  },
  {
    "text": "parser or writer will not accept it so if we want to create a an mb5",
    "start": "1261740",
    "end": "1269179"
  },
  {
    "start": "1267000",
    "end": "1267000"
  },
  {
    "text": "Collision we need to basically make sure there are none of these surrogates uh",
    "start": "1269179",
    "end": "1275179"
  },
  {
    "text": "words in there and it turns out this was actually not that difficult to achieve I used Mark",
    "start": "1275179",
    "end": "1281120"
  },
  {
    "text": "Steven's hash Clash tool to compute chosen prefix collisions it's a an excellent tool and",
    "start": "1281120",
    "end": "1288559"
  },
  {
    "text": "um I didn't even really need to dive too much into the details of how uh md5 charge and prefix collisions works",
    "start": "1288559",
    "end": "1294500"
  },
  {
    "text": "because what this tool basically does it produces uh 64 bytes blocks block by",
    "start": "1294500",
    "end": "1300320"
  },
  {
    "text": "block intellective uh that each get a little bit closer to the collision and",
    "start": "1300320",
    "end": "1305659"
  },
  {
    "text": "it already had it was a probabilistic algorithm that could fail at these steps and when it would fail it would just",
    "start": "1305659",
    "end": "1311299"
  },
  {
    "text": "retry generating the last block and does it probabilistically so then it would generate some other outputs so I just",
    "start": "1311299",
    "end": "1317900"
  },
  {
    "text": "included a very simple hack into um scripts that would just check if any",
    "start": "1317900",
    "end": "1325159"
  },
  {
    "text": "block that was produced happened to contain invalid utf-16 and if that was",
    "start": "1325159",
    "end": "1330260"
  },
  {
    "text": "the case it would just reject it and the algorithm would just try Computing that block again and because it's",
    "start": "1330260",
    "end": "1336500"
  },
  {
    "text": "probabilistic probably something else would come out because the chance that a random 64",
    "start": "1336500",
    "end": "1343460"
  },
  {
    "text": "bytes block just happens to be valid huge F-16 by coincidences one in",
    "start": "1343460",
    "end": "1349360"
  },
  {
    "text": "is one in three we basically have to take three times as long to compute the",
    "start": "1349360",
    "end": "1354919"
  },
  {
    "text": "Collision but when you do that you have a completely utf-16 compatible md5",
    "start": "1354919",
    "end": "1361280"
  },
  {
    "text": "Collision which may have some other applications as well but it's very useful here and it",
    "start": "1361280",
    "end": "1366320"
  },
  {
    "text": "allows us to carry out an attack so now we'll go through how the actual attack works first of all you um well",
    "start": "1366320",
    "end": "1374780"
  },
  {
    "text": "come up with some completely fictional pack that you can give all privileges that you want uh here um it shows some",
    "start": "1374780",
    "end": "1381559"
  },
  {
    "text": "uh attacker user that gives themselves domain admin privileges Enterprise admin",
    "start": "1381559",
    "end": "1387860"
  },
  {
    "text": "privileges basically anything you can config in a data structure you can just completely come up with yourself this is",
    "start": "1387860",
    "end": "1394039"
  },
  {
    "text": "what we are trying to spoof and then we'll obtain an authentic pack",
    "start": "1394039",
    "end": "1399320"
  },
  {
    "text": "that belongs to the computer accounts it was just created and",
    "start": "1399320",
    "end": "1404480"
  },
  {
    "text": "um well there's means uh you can use the utu protocol in Windows to get a copy of a pack of any domain user there's",
    "start": "1404480",
    "end": "1410840"
  },
  {
    "text": "standard tools for that so it's no problem to see what the pack looks like so first you can create these computer",
    "start": "1410840",
    "end": "1416059"
  },
  {
    "text": "accounts maybe already fill up the logon part with some padding and you can get that back",
    "start": "1416059",
    "end": "1421640"
  },
  {
    "text": "both of these um well you don't know what the signature is supposed to be of the spoof backyards but you do get a valid",
    "start": "1421640",
    "end": "1428419"
  },
  {
    "text": "signature of the authentic one and both of them will of course have completely different md5 hashes",
    "start": "1428419",
    "end": "1435280"
  },
  {
    "start": "1434000",
    "end": "1434000"
  },
  {
    "text": "so now we're going to do the uh the expensive step the hash Collision",
    "start": "1435400",
    "end": "1443419"
  },
  {
    "text": "um we take the entire spoofed back as a prefix and the authentic pack we basically cut",
    "start": "1443419",
    "end": "1449659"
  },
  {
    "text": "off at the start of this logon path uh data structure that's where we want to inject our Collision bytes we'll run the",
    "start": "1449659",
    "end": "1456740"
  },
  {
    "text": "Collision algorithm and well it adds a lot of bytes to both of our packs",
    "start": "1456740",
    "end": "1464240"
  },
  {
    "text": "and the results this complete spoofed pack filled with some garbage at the ends and this half of an authentic pack",
    "start": "1464240",
    "end": "1471500"
  },
  {
    "text": "with also some garbage at the end they will both have the same md5 hash",
    "start": "1471500",
    "end": "1477760"
  },
  {
    "text": "now at this point what we can do is uh do an ldap update to this computer",
    "start": "1477980",
    "end": "1484039"
  },
  {
    "text": "accounts and copy all the bytes that would previously appear at the bottom",
    "start": "1484039",
    "end": "1491299"
  },
  {
    "text": "here basically we put this in ldap query update the logon Parts property so",
    "start": "1491299",
    "end": "1498400"
  },
  {
    "start": "1496000",
    "end": "1496000"
  },
  {
    "text": "the authentic pads would actually contain the same types of collision bytes and then we request this new",
    "start": "1498400",
    "end": "1505460"
  },
  {
    "text": "updated pack the domain controller would give us a signature again and what's interesting",
    "start": "1505460",
    "end": "1513380"
  },
  {
    "text": "about that because nothing else changed in this prefix at the md5 hash of the",
    "start": "1513380",
    "end": "1519020"
  },
  {
    "text": "first part of the pack would still be identical to the spoofed",
    "start": "1519020",
    "end": "1525220"
  },
  {
    "text": "pack that we can that we computed now mb5 has the nice property that's",
    "start": "1525220",
    "end": "1531260"
  },
  {
    "text": "um if you have two inputs with the same hash and you add the same suffix to both",
    "start": "1531260",
    "end": "1537380"
  },
  {
    "text": "inputs they will both share the same hash as well so we can kind of swap these two uh",
    "start": "1537380",
    "end": "1542840"
  },
  {
    "text": "merge these two packs together we take the suffix of the authentic pack stake it to the",
    "start": "1542840",
    "end": "1551059"
  },
  {
    "text": "end of our spoofed pack which results in the entire thing having the same md5",
    "start": "1551059",
    "end": "1556159"
  },
  {
    "text": "hash as the entire authentic pack uh so we can plug in the signature from",
    "start": "1556159",
    "end": "1562940"
  },
  {
    "text": "there as well and these will be computed using the same hash so they will remain valid and the end result is a pack that",
    "start": "1562940",
    "end": "1569900"
  },
  {
    "text": "starts with well a valid back data structure that tells uh that says that my user is a domain admin and there's a",
    "start": "1569900",
    "end": "1577460"
  },
  {
    "text": "whole bunch of garbage data at the end luckily the parser that is used to process packs it will basically allow it",
    "start": "1577460",
    "end": "1586940"
  },
  {
    "text": "to be extended with garbage bytes these are all uh well basically all these fields are prefixed by lengths",
    "start": "1586940",
    "end": "1593840"
  },
  {
    "text": "so the parser will just ignore this whole part but it will still include this whole garbage part insights into",
    "start": "1593840",
    "end": "1601039"
  },
  {
    "text": "the signature computation so um even though this will this will just",
    "start": "1601039",
    "end": "1607220"
  },
  {
    "text": "be accepted and when a validator would try to compute the signatures again and the",
    "start": "1607220",
    "end": "1613460"
  },
  {
    "text": "five hash would be the same signature would be the same we now have created a valid back",
    "start": "1613460",
    "end": "1620080"
  },
  {
    "text": "and while I was basically uh getting this attack to work",
    "start": "1620080",
    "end": "1625340"
  },
  {
    "text": "I also noticed something else because this still all took advantage of the uh",
    "start": "1625340",
    "end": "1630500"
  },
  {
    "text": "weakness in the rc4 hmx cipher and the alternative of which are AES based",
    "start": "1630500",
    "end": "1635779"
  },
  {
    "text": "encryption types that don't have this weakness but I know just a little bit of another problem with the back protocol as well",
    "start": "1635779",
    "end": "1642620"
  },
  {
    "start": "1642000",
    "end": "1642000"
  },
  {
    "text": "and it is the way that this how these signatures work so there is a server signature that's",
    "start": "1642620",
    "end": "1649940"
  },
  {
    "text": "just a Mac using the key of um that's the same as the key used for",
    "start": "1649940",
    "end": "1655760"
  },
  {
    "text": "the tickets that contains the pack and there is a second mac o computed",
    "start": "1655760",
    "end": "1661820"
  },
  {
    "text": "over a Mac with a key controlled by a domain controller and when this spec is validated by a",
    "start": "1661820",
    "end": "1668539"
  },
  {
    "text": "domain controller it will first compute the first Mac and then computes the second Mac over",
    "start": "1668539",
    "end": "1673940"
  },
  {
    "text": "that first Mac with a different key and the whole idea behind this second signature is that even if somebody knows",
    "start": "1673940",
    "end": "1680900"
  },
  {
    "text": "the key for the first Mac they will not be able to spoof the second Mac this creates some problems first of all",
    "start": "1680900",
    "end": "1687980"
  },
  {
    "text": "if the second Mac is computed using the secure as based algorithm the first Mac is computed using rc4 and",
    "start": "1687980",
    "end": "1695900"
  },
  {
    "text": "that's actually what happens in practice because she it turns out you could downgrades to rc4 for your surface",
    "start": "1695900",
    "end": "1701600"
  },
  {
    "text": "signature but not for the KDC signature that's determined by the domain controller not under the attacker control",
    "start": "1701600",
    "end": "1707419"
  },
  {
    "text": "uh but yeah if you have a secure Mac over an insecure Mac if two values have",
    "start": "1707419",
    "end": "1712940"
  },
  {
    "text": "the same insecure Mac they will also get the same uh well KDC signature over that Mech as well",
    "start": "1712940",
    "end": "1719900"
  },
  {
    "text": "second of all uh we have an attack scenario here where this first share for",
    "start": "1719900",
    "end": "1725120"
  },
  {
    "text": "Signature is computed with a key that the attacker knows and a cryptographic Mac is supposed to",
    "start": "1725120",
    "end": "1732500"
  },
  {
    "text": "protect to be unforgeable by those who do not know the key a cryptographic Mac could have as a side",
    "start": "1732500",
    "end": "1741140"
  },
  {
    "text": "effect the property that if I know the key I still can't compute two Maxes are the same for different data but it's not",
    "start": "1741140",
    "end": "1747620"
  },
  {
    "text": "guarantees that is not a required property of a secure Mac so secure Macs exists",
    "start": "1747620",
    "end": "1752720"
  },
  {
    "text": "the that still allow me if I know the key to just have two completed different pieces of data two different messages",
    "start": "1752720",
    "end": "1758860"
  },
  {
    "text": "and use my key to somehow compute a Mac that matches with both of them",
    "start": "1758860",
    "end": "1765440"
  },
  {
    "text": "and it turns out this is exactly what is the case for the um well secure alternative for rc4 mhmac and those are",
    "start": "1765440",
    "end": "1772760"
  },
  {
    "text": "the other AES based encryption types actually for cryptographic authentication they just don't use as",
    "start": "1772760",
    "end": "1779120"
  },
  {
    "text": "but hmac Shavon truncated to 12 bytes",
    "start": "1779120",
    "end": "1785360"
  },
  {
    "text": "um hmx chavon even though Shavon itself is not collected free anymore but hmx Chevron is secure uh this construction",
    "start": "1785360",
    "end": "1792200"
  },
  {
    "text": "also doesn't have the whole pre-hatching filter ability so by itself this construction is safe uh truncating the",
    "start": "1792200",
    "end": "1799940"
  },
  {
    "text": "results with 12 bytes is normally not really a problem uh into a context where",
    "start": "1799940",
    "end": "1805580"
  },
  {
    "text": "an attacker well doesn't know the key um has uh has limited options for spoofing uh",
    "start": "1805580",
    "end": "1813679"
  },
  {
    "text": "message authentication codes but when you do know the key this whole cryptographic authenticator is hmac",
    "start": "1813679",
    "end": "1819980"
  },
  {
    "text": "function basically just turns into a regular old hash function um an attacker can do offline attacks",
    "start": "1819980",
    "end": "1826760"
  },
  {
    "text": "where they can just try Computing hmax of two randomly inputs or two Junction",
    "start": "1826760",
    "end": "1833120"
  },
  {
    "text": "prefixes with random additions and the chance that just by coincidence",
    "start": "1833120",
    "end": "1839360"
  },
  {
    "text": "these 12 bytes will be the same it's about a one in two to the power of 48",
    "start": "1839360",
    "end": "1845059"
  },
  {
    "text": "and that is well this is a lot more expensive than Computing an mv5 collage Collision this is still very much in the",
    "start": "1845059",
    "end": "1850820"
  },
  {
    "text": "realm of feasibility and um all you need to would need to make an optimized implementation for this this",
    "start": "1850820",
    "end": "1856399"
  },
  {
    "text": "is something you could compute in like half a week with a bunch of gpus so in theory it's even also possible to",
    "start": "1856399",
    "end": "1863299"
  },
  {
    "text": "spoof backed signatures when the secure as Cipher is used so that was kind of like not something I was originally",
    "start": "1863299",
    "end": "1869419"
  },
  {
    "text": "looking for it was like office and additional finding I made as well that was basically really just looking for",
    "start": "1869419",
    "end": "1875779"
  },
  {
    "text": "ways to exploit rc4 hmac so okay we have now spoofed a pack",
    "start": "1875779",
    "end": "1882679"
  },
  {
    "text": "how can we do something useful with this uh this was actually uh kind of tricky",
    "start": "1882679",
    "end": "1888020"
  },
  {
    "text": "pack validation is used in different places but actually making a useful",
    "start": "1888020",
    "end": "1893539"
  },
  {
    "text": "exploit that achieves a useful attacker goal uh with a fake back",
    "start": "1893539",
    "end": "1899960"
  },
  {
    "text": "um was not always trivial and well the one exploit I could actually get to work in a well a",
    "start": "1899960",
    "end": "1908059"
  },
  {
    "text": "realistic setting is an attack on constraint delegation now I'm not going",
    "start": "1908059",
    "end": "1914059"
  },
  {
    "text": "into the details of how exactly it works but constraint delegation is basically a feature where in a domain you can",
    "start": "1914059",
    "end": "1919880"
  },
  {
    "text": "configure two surfaces to allow uh delegation of usual accounts",
    "start": "1919880",
    "end": "1926840"
  },
  {
    "text": "so for example let's say the first surface is a web interface that allows you to click through files and the",
    "start": "1926840",
    "end": "1932299"
  },
  {
    "text": "second surface is an SMB share um when you say surface this web service",
    "start": "1932299",
    "end": "1939020"
  },
  {
    "text": "is allowed to delegates to that SMB share that means this servers can impersonate",
    "start": "1939020",
    "end": "1945679"
  },
  {
    "text": "um any user within the domain where it's allowed and then log into that second service as if it was the first user so",
    "start": "1945679",
    "end": "1952399"
  },
  {
    "text": "that's very useful I log in to the surface one with my domain account and then that surface uses my account to",
    "start": "1952399",
    "end": "1959059"
  },
  {
    "text": "communicate with some other surface so it can only access files that I can access and any file access events are locked as",
    "start": "1959059",
    "end": "1966140"
  },
  {
    "text": "if they came from the original user and well they ask for you to proxy protocol",
    "start": "1966140",
    "end": "1971360"
  },
  {
    "text": "that facilitates this whole mechanism involves KDC signature validation and",
    "start": "1971360",
    "end": "1976640"
  },
  {
    "text": "according to the protocol specification a domain controller would verify the signatures and basically just accept a",
    "start": "1976640",
    "end": "1984620"
  },
  {
    "text": "pack and also the reason why this was necessary is because this whole protocol",
    "start": "1984620",
    "end": "1989840"
  },
  {
    "text": "involved somebody handling a ticket encrypted to themselves so basically a",
    "start": "1989840",
    "end": "1996220"
  },
  {
    "text": "surface one here has a ticket that is aimed at themselves encrypted with a key",
    "start": "1996220",
    "end": "2001960"
  },
  {
    "text": "day control so they can decrypt the stickers Mess With The Pack if an updated server signature then re-encrypt",
    "start": "2001960",
    "end": "2008260"
  },
  {
    "text": "the pack again so the signature validation is necessary to make sure that during this process the surface is",
    "start": "2008260",
    "end": "2015700"
  },
  {
    "text": "not going to mess with any privileges now what this enables uh enables there",
    "start": "2015700",
    "end": "2022659"
  },
  {
    "start": "2017000",
    "end": "2017000"
  },
  {
    "text": "already is a well-known attack where well basically you compromise a surface a that has a constraint delegation",
    "start": "2022659",
    "end": "2029440"
  },
  {
    "text": "relationship with surface B when you can do that you can impersonate users do the same uh to This Server B and if there's",
    "start": "2029440",
    "end": "2037480"
  },
  {
    "text": "no restrictions on that you could basically just say hey Surfer B um I I want to impersonate the domain",
    "start": "2037480",
    "end": "2043720"
  },
  {
    "text": "admin and well if you own server a then that will allow you to probably own server b as well",
    "start": "2043720",
    "end": "2051398"
  },
  {
    "text": "um for this there's uh there are mitigations you can Implement to uh to",
    "start": "2051399",
    "end": "2057520"
  },
  {
    "text": "reduce the scope of these types of attacks or mitigate them all together and that is by not allowing certain user",
    "start": "2057520",
    "end": "2063158"
  },
  {
    "text": "accounts to be delegated for example any user account in a protected users group is not allowed to be delegated you can",
    "start": "2063159",
    "end": "2069638"
  },
  {
    "text": "also set a separate property on usual accounts preventing delegation of them as well",
    "start": "2069639",
    "end": "2075220"
  },
  {
    "text": "and if you put all your administrators in the protected usage group for example which is a good practice then an",
    "start": "2075220",
    "end": "2081580"
  },
  {
    "text": "attacker that compromises server a can no longer impersonate an admin when attacking server B",
    "start": "2081580",
    "end": "2088679"
  },
  {
    "text": "uh and what you can achieve by box proofing is bypassing this whole restriction so you can turn",
    "start": "2088679",
    "end": "2096339"
  },
  {
    "text": "uh you can just come up with some potentially non-existent user that is",
    "start": "2096339",
    "end": "2101380"
  },
  {
    "text": "domain admin and does allow delegation because whether or not a user allows delegation is included inside the pack",
    "start": "2101380",
    "end": "2109960"
  },
  {
    "text": "so in the end what I've got here with descriptor bug is a practical security feature bypass Works in practice it is a",
    "start": "2109960",
    "end": "2118420"
  },
  {
    "text": "little bit limited it's similar to another uh attack called the brown speed attack in the effect that it achieves",
    "start": "2118420",
    "end": "2126400"
  },
  {
    "text": "um it basically allows well privilege escalation on the very specific circumstances",
    "start": "2126400",
    "end": "2132940"
  },
  {
    "text": "um and it is definitely um useful in these circumstances when you are dealing with a domain where you",
    "start": "2132940",
    "end": "2139180"
  },
  {
    "text": "compromise a server uses constraint delegation and there are other controls in place that would stop your attack in",
    "start": "2139180",
    "end": "2144880"
  },
  {
    "text": "your tracks um but in general it's not the uh it",
    "start": "2144880",
    "end": "2150700"
  },
  {
    "text": "doesn't have super high impacts however it does show this that is theoretical",
    "start": "2150700",
    "end": "2155740"
  },
  {
    "text": "crypto bug can lead to practical consequences it may not be the most exciting exploit but",
    "start": "2155740",
    "end": "2161440"
  },
  {
    "text": "it is an exploit it is a security feature but uh the Bible saying ad and",
    "start": "2161440",
    "end": "2166540"
  },
  {
    "text": "of course there's a lot more mechanisms relying on this broken Cipher so while I",
    "start": "2166540",
    "end": "2174820"
  },
  {
    "text": "have not been able to find uh interesting other exploits that doesn't",
    "start": "2174820",
    "end": "2180160"
  },
  {
    "text": "mean that they are there so there's a whole bunch of new attack surface here",
    "start": "2180160",
    "end": "2185099"
  },
  {
    "text": "so last month this issue got batched even though I already disclosed it in",
    "start": "2185260",
    "end": "2193060"
  },
  {
    "start": "2189000",
    "end": "2189000"
  },
  {
    "text": "May 2021 so yeah one and a half years time to implement a fix it's a little bit longer",
    "start": "2193060",
    "end": "2200500"
  },
  {
    "text": "than usual I would say not really a 30 day disclosure timeline but you would do",
    "start": "2200500",
    "end": "2205540"
  },
  {
    "text": "have to take into account that this is a protocol buck and there's a lot of",
    "start": "2205540",
    "end": "2210700"
  },
  {
    "text": "Legacy software uh relying on this Legacy protocol",
    "start": "2210700",
    "end": "2216300"
  },
  {
    "text": "and actually get uh getting these fixes implemented",
    "start": "2216300",
    "end": "2222700"
  },
  {
    "text": "take a whole amount of regression testing in a whole bunch of settings also hold the work let's use active",
    "start": "2222700",
    "end": "2228400"
  },
  {
    "text": "directories is fairly tricky and so you can imagine it's must have been quite a pain to get it to work",
    "start": "2228400",
    "end": "2234040"
  },
  {
    "text": "so uh our two CVS got registered there were two batches uh for the the one the",
    "start": "2234040",
    "end": "2239380"
  },
  {
    "text": "rc4hmec issue and the other for the more General pack issue uh the first batch",
    "start": "2239380",
    "end": "2244800"
  },
  {
    "text": "basically changes defaults and disables rc4 hmac on user accounts by default",
    "start": "2244800",
    "end": "2252640"
  },
  {
    "text": "um there are some ways to get around that and still use the insecure type but if you don't change anything and you",
    "start": "2252640",
    "end": "2259300"
  },
  {
    "text": "don't have any configurations diverting from the defaults suddenly this weak encryption",
    "start": "2259300",
    "end": "2264520"
  },
  {
    "text": "type is no longer allowed but it's going to have some beneficial side effects or not so beneficial if you're a red team",
    "start": "2264520",
    "end": "2270040"
  },
  {
    "text": "or a pen tester because this should have entirely verified this yet but this",
    "start": "2270040",
    "end": "2275440"
  },
  {
    "text": "should probably make gerberos thing more difficult and limits the impact of overpass the hash attacks which probably",
    "start": "2275440",
    "end": "2281440"
  },
  {
    "text": "are actually more useful than actually mitigating my far more restricted attack so that's a nice side effect and finally",
    "start": "2281440",
    "end": "2287920"
  },
  {
    "text": "we're getting a step further and getting rid of this Legacy encryption type the other fix is supposed to address the",
    "start": "2287920",
    "end": "2294700"
  },
  {
    "text": "general issue with tax and that's also supposed to address the issue where you used to secure",
    "start": "2294700",
    "end": "2299980"
  },
  {
    "text": "um uh Mega Collision issue with the as ciphers and that's basically to add a new uh",
    "start": "2299980",
    "end": "2306940"
  },
  {
    "text": "back signature with the KDC key that covers the entire contents of the pack",
    "start": "2306940",
    "end": "2312880"
  },
  {
    "text": "so it doesn't just apply to some other signature doesn't use the insecure Mega for Mac structure but it just signs the",
    "start": "2312880",
    "end": "2320740"
  },
  {
    "text": "whole thing again um it is not really enforced yet though uh only in July next year a patch will",
    "start": "2320740",
    "end": "2329380"
  },
  {
    "text": "cost uh checking of the signature to be enforced in the meantime it will just generate order defense when somebody",
    "start": "2329380",
    "end": "2335320"
  },
  {
    "text": "tries to do the spec proofing attack which means that this attack is still actually possible in current Windows",
    "start": "2335320",
    "end": "2341140"
  },
  {
    "text": "domains uh you would need to first come up with an optimized implementation it finds uh hmax Shavon collisions with a",
    "start": "2341140",
    "end": "2348700"
  },
  {
    "text": "known key uh that's something that is not entirely trivial and takes on",
    "start": "2348700",
    "end": "2353740"
  },
  {
    "text": "computational resources but the attack is still possible unless you actually go ahead and enforce the signature",
    "start": "2353740",
    "end": "2362320"
  },
  {
    "text": "validation Yourself Microsoft profiles instructions on how to do that but if you don't take any actions you will",
    "start": "2362320",
    "end": "2368859"
  },
  {
    "text": "remain vulnerable until July next year",
    "start": "2368859",
    "end": "2373799"
  },
  {
    "start": "2373000",
    "end": "2373000"
  },
  {
    "text": "so some conclusions uh well first of all I hope that with this uh practical",
    "start": "2373980",
    "end": "2379540"
  },
  {
    "text": "attack even though the impact is limited does definitively show that rc4 hmac is broken and we should really try to get",
    "start": "2379540",
    "end": "2388240"
  },
  {
    "text": "rid of it and there are some good steps by at least disabling it by default it also shows that it's still possible",
    "start": "2388240",
    "end": "2394780"
  },
  {
    "text": "in 2022 to achieve attacker goals with nd5 Collision attacks even though most",
    "start": "2394780",
    "end": "2401980"
  },
  {
    "text": "people would probably think that mb5 collisions are something of the past because well we're not really using md5",
    "start": "2401980",
    "end": "2407920"
  },
  {
    "text": "anywhere anymore right um and it also shows especially the long time it took to implement a patch and",
    "start": "2407920",
    "end": "2414400"
  },
  {
    "text": "even when they did the patch still broke things that active directory relies on a",
    "start": "2414400",
    "end": "2420040"
  },
  {
    "text": "lot of Legacy crypto not just this but also a bunch of other protocols that are very hard to modify or to get rid of",
    "start": "2420040",
    "end": "2427839"
  },
  {
    "text": "so yeah that was my talk and unfortunately the counter was broken",
    "start": "2427839",
    "end": "2433060"
  },
  {
    "text": "for most of the time so I'm not sure do we still have five minutes left for questions or okay well",
    "start": "2433060",
    "end": "2440079"
  },
  {
    "text": "are there any questions [Applause]",
    "start": "2440079",
    "end": "2449840"
  },
  {
    "text": "[Music]",
    "start": "2449840",
    "end": "2452949"
  },
  {
    "text": "[Music]",
    "start": "2456800",
    "end": "2459899"
  }
]