[
  {
    "text": "[Music]",
    "start": "1130",
    "end": "14400"
  },
  {
    "text": "hello everyone thanks for attending my talk crushing your way to medium integrity exploiting the pdb parser for",
    "start": "14400",
    "end": "21279"
  },
  {
    "text": "privilege escalation my name is gal and in the past few years i've been doing security research for",
    "start": "21279",
    "end": "27840"
  },
  {
    "text": "palo alto networks mainly in the fields of fuzzing vulnerabilities exploits and mitigations",
    "start": "27840",
    "end": "33920"
  },
  {
    "text": "i've also been awarded as microsoft msrc most valuable security researcher for the past three years in evo for",
    "start": "33920",
    "end": "40960"
  },
  {
    "text": "discovering over 40 different vulnerabilities in microsoft products",
    "start": "40960",
    "end": "46559"
  },
  {
    "text": "today in this talk we'll discuss one of the more interesting bugs i discovered last year and how it can be exploited",
    "start": "46559",
    "end": "53520"
  },
  {
    "text": "and i'd start by explaining what our pdb files how i discovered vulnerabilities in microsoft's pdb parser",
    "start": "53520",
    "end": "60239"
  },
  {
    "text": "followed by the different attack surface into that parser and exploit and a demo",
    "start": "60239",
    "end": "67040"
  },
  {
    "text": "so pdb file store debugging information also known as symbols about a windows executable program",
    "start": "67040",
    "end": "73680"
  },
  {
    "text": "those are stored on top of these files rather than the executable files themselves",
    "start": "73680",
    "end": "78799"
  },
  {
    "text": "they contain things like function names globals type information and so on and",
    "start": "78799",
    "end": "84320"
  },
  {
    "text": "are created from source files during the build process then they are used by debuggers to",
    "start": "84320",
    "end": "89840"
  },
  {
    "text": "display the debugging information in a meaningful way throughout the debugging session",
    "start": "89840",
    "end": "95680"
  },
  {
    "text": "here is an example of using windebug to load the pdb file of notepad and then use the x command to simply dump all",
    "start": "95680",
    "end": "103360"
  },
  {
    "text": "symbols from it the pdb file format itself is a propriety file format invented by",
    "start": "103360",
    "end": "110159"
  },
  {
    "text": "microsoft it is binary and is built on top of another file format called msf",
    "start": "110159",
    "end": "116560"
  },
  {
    "text": "which is a simple file system-like format that allows to store different streams onto a single file",
    "start": "116560",
    "end": "123280"
  },
  {
    "text": "while there's no public rfc document by microsoft for that format they open",
    "start": "123280",
    "end": "128560"
  },
  {
    "text": "source the code for producing pdb files so non-microsoft compilers can produce them too",
    "start": "128560",
    "end": "135200"
  },
  {
    "text": "the parser for pdb files is implemented in debughelp.dll which is a shared library that's shipped",
    "start": "135200",
    "end": "141599"
  },
  {
    "text": "by windows by default on every windows installation and it provides an api to debug process",
    "start": "141599",
    "end": "148560"
  },
  {
    "text": "load pdb files extract symbols data and so on",
    "start": "148560",
    "end": "153760"
  },
  {
    "text": "so the initial goal for this project was trying to identify vulnerabilities in the pdb person code",
    "start": "153760",
    "end": "160080"
  },
  {
    "text": "and the way i decided to do so is to use fuzzing and my fuzzing setup was quite",
    "start": "160080",
    "end": "165920"
  },
  {
    "text": "straightforward i started by collecting a corpus or an initial set of valid pdb files from",
    "start": "165920",
    "end": "172239"
  },
  {
    "text": "several sources then i coded my test harness program which is a program that simply loads a",
    "start": "172239",
    "end": "179040"
  },
  {
    "text": "single pdb file from disk and parse it using the debug help seam load module",
    "start": "179040",
    "end": "184480"
  },
  {
    "text": "api then i used the very well-known open source fuzzer called win afl to do the",
    "start": "184480",
    "end": "191200"
  },
  {
    "text": "actual fuzzing and win nfl is a mutation based fuzzer and the basic workflow for",
    "start": "191200",
    "end": "197280"
  },
  {
    "text": "mutation-based fuzzers is that they select a single input from the corpus they then create a new test case by",
    "start": "197280",
    "end": "204000"
  },
  {
    "text": "mutating that sample doing things like bit flips and byte flips they run the test case through the test",
    "start": "204000",
    "end": "210480"
  },
  {
    "text": "harness and check if it crashed and then repeats that process infinitely",
    "start": "210480",
    "end": "216799"
  },
  {
    "text": "there are many optimizations when afl does on that basic workflow but i won't go into details about it right now",
    "start": "216799",
    "end": "223519"
  },
  {
    "text": "because winfl is very well documented and this is not a fuzzy talk",
    "start": "223519",
    "end": "228959"
  },
  {
    "text": "but what i want you to take away from here if you haven't done fuzzing yourself is that setting this up is very",
    "start": "228959",
    "end": "234239"
  },
  {
    "text": "simple and in a couple of hours collecting a corpus and writing the test harness in the way when afl expects you",
    "start": "234239",
    "end": "241760"
  },
  {
    "text": "can bootstrap your fuzzing campaign and this requires no much knowledge of the pdb file format at that stage",
    "start": "241760",
    "end": "249519"
  },
  {
    "text": "and here is win afl's dashboard from fuzzing the pdb parser on a single core",
    "start": "249519",
    "end": "255360"
  },
  {
    "text": "for three days and as you can see it discovered over 200 different crashes in",
    "start": "255360",
    "end": "260400"
  },
  {
    "text": "that fuzzer in that parser so that was a pretty good starting point",
    "start": "260400",
    "end": "266479"
  },
  {
    "text": "for that project and then i decided to look for an attack surface to exploit those bugs",
    "start": "266479",
    "end": "272400"
  },
  {
    "text": "and my initial talk was to use remote symbol servers remote symbol servers is a feature of",
    "start": "272400",
    "end": "278160"
  },
  {
    "text": "debuggers when you debug some program you can set the path to remote symbol",
    "start": "278160",
    "end": "283199"
  },
  {
    "text": "server either by http or smb and then the debugger would fetch simple",
    "start": "283199",
    "end": "288639"
  },
  {
    "text": "files from that server throughout the debugging session the most common pdb symbol server in the",
    "start": "288639",
    "end": "295360"
  },
  {
    "text": "world is probably microsoft symbol server which hosts the binaries the pdb",
    "start": "295360",
    "end": "301120"
  },
  {
    "text": "files for most binaries ever shipped with windows but many software development groups",
    "start": "301120",
    "end": "306639"
  },
  {
    "text": "have their own internal pdb server where they push symbols to their software",
    "start": "306639",
    "end": "312080"
  },
  {
    "text": "throughout the cicd process and my thought was that given the attacker controls or many in the middle",
    "start": "312080",
    "end": "318400"
  },
  {
    "text": "the connection between the victim machine and that symbol server he could serve arbitrary",
    "start": "318400",
    "end": "323600"
  },
  {
    "text": "pdbs and crush or exploit the victim's debugger remotely",
    "start": "323600",
    "end": "329280"
  },
  {
    "text": "this is a screenshot showing that actually works i was debugging notepad with that wind debug below setting the",
    "start": "329280",
    "end": "335919"
  },
  {
    "text": "sim pad to remote server by smb and then loading one of the pdb files when afl",
    "start": "335919",
    "end": "341600"
  },
  {
    "text": "discovered and as you can see that debugger itself crashed with an access validation in the",
    "start": "341600",
    "end": "348080"
  },
  {
    "text": "pdb parsing code so this shows that the attack surface can work and at this point and this was about a",
    "start": "348080",
    "end": "355039"
  },
  {
    "text": "year ago i decided to report that issue to microsoft msrc i chose one of the pdb files that seemed",
    "start": "355039",
    "end": "362000"
  },
  {
    "text": "more likely to be exploited and reported that info along with the attack surface",
    "start": "362000",
    "end": "367840"
  },
  {
    "text": "and microsoft replied about a month later saying that this bug doesn't meet the bar for security servicing and they",
    "start": "367840",
    "end": "374800"
  },
  {
    "text": "closed that case my understanding from the reply is that the reason why is that they thought the",
    "start": "374800",
    "end": "381520"
  },
  {
    "text": "attack surface is too complex or too unlikely and as you can see they said that the",
    "start": "381520",
    "end": "387440"
  },
  {
    "text": "attacker would have to control the symbol servers or man in the middle of the connection and the victim would have",
    "start": "387440",
    "end": "392479"
  },
  {
    "text": "to manually load the pdb file from that server and they did say they are likely going",
    "start": "392479",
    "end": "398400"
  },
  {
    "text": "to fix that in some future product release but no cve is going to be assigned",
    "start": "398400",
    "end": "404479"
  },
  {
    "text": "so at this point i left this project aside for a while and didn't report the other bugs to microsoft because they",
    "start": "404479",
    "end": "410160"
  },
  {
    "text": "didn't seem to be interested but then following a conversation with a friend of mine i realized that they",
    "start": "410160",
    "end": "417120"
  },
  {
    "text": "rejected this because of the attack surface so maybe i should look for other attack surfaces",
    "start": "417120",
    "end": "423199"
  },
  {
    "text": "maybe there are other flows or other components in windows that parse pdb files",
    "start": "423199",
    "end": "428720"
  },
  {
    "text": "and it doesn't necessarily have to be a remote code execution flow maybe there is some privilege service or process",
    "start": "428720",
    "end": "436240"
  },
  {
    "text": "that loads pdb files from disk that i can exploit for elevating privileges on a local machine",
    "start": "436240",
    "end": "443280"
  },
  {
    "text": "and the way i approached this was very simple i started by doing a text search for the stream debug help in all",
    "start": "443280",
    "end": "449360"
  },
  {
    "text": "binaries under the same windows directory and that search will dead about 30",
    "start": "449360",
    "end": "454560"
  },
  {
    "text": "different executables and two of them immediately caught my attention those",
    "start": "454560",
    "end": "459840"
  },
  {
    "text": "are fault wrap.dll and wear.dll and the reason why is they are part of",
    "start": "459840",
    "end": "465280"
  },
  {
    "text": "the windows aero reporting suit which is a component of windows which already researched into quite depth in the last",
    "start": "465280",
    "end": "472240"
  },
  {
    "text": "two years discovering over 15 different vulnerabilities in it and you can check out my blue talk from",
    "start": "472240",
    "end": "478319"
  },
  {
    "text": "last year if you're interested in that topic so let me do a quick recap of how",
    "start": "478319",
    "end": "484000"
  },
  {
    "text": "windows error reporting works windows error report in purpose is to collect information regarding crashes or",
    "start": "484000",
    "end": "490000"
  },
  {
    "text": "hangs in a windows endpoint and report them to microsoft cloud for further diagnostics and the way it works is that",
    "start": "490000",
    "end": "497680"
  },
  {
    "text": "each time a process crash from its exception handler it talks through alpc to where svc the windows",
    "start": "497680",
    "end": "505199"
  },
  {
    "text": "error reporting service pretty much saying hey where's vc i am about to crush",
    "start": "505199",
    "end": "511360"
  },
  {
    "text": "where's vcn10 will end up calling the function create processes user to spawn",
    "start": "511360",
    "end": "516640"
  },
  {
    "text": "a new instance of a worker process called warfall.exe warfall.exe in turn would actually read",
    "start": "516640",
    "end": "525040"
  },
  {
    "text": "the data from that crashing process producing that crash report and report it to microsoft",
    "start": "525040",
    "end": "531519"
  },
  {
    "text": "now despite the fact that where svc is the one creating wareholt it creates it as a child process of that crushing",
    "start": "531519",
    "end": "538080"
  },
  {
    "text": "process rather than of its own i reverse engineer webfall to see how it",
    "start": "538080",
    "end": "544080"
  },
  {
    "text": "used debug help and i found out that it is being used to parse the stack trace of the crushing thread in that crushing",
    "start": "544080",
    "end": "551200"
  },
  {
    "text": "process and then it produces a stack phrase hash based on it and adds it on top of the",
    "start": "551200",
    "end": "556640"
  },
  {
    "text": "error report and i guess the reason why is that microsoft are getting millions of",
    "start": "556640",
    "end": "561920"
  },
  {
    "text": "crashes a day and they want to be able to group those crashes by stacked race",
    "start": "561920",
    "end": "567920"
  },
  {
    "text": "so that's the actual soda code from warefold showing the usage of the bug help",
    "start": "567920",
    "end": "573360"
  },
  {
    "text": "and it is used in a function called util gut stack trace which gets the process id and thread id of the crashing process",
    "start": "573360",
    "end": "580480"
  },
  {
    "text": "it then opens that process with all access and passes the handle to that",
    "start": "580480",
    "end": "585600"
  },
  {
    "text": "process onto the debug help function sim initialize",
    "start": "585600",
    "end": "590720"
  },
  {
    "text": "the purpose of sim initialize is to initialize the symbols handler for that specific crushing process",
    "start": "590720",
    "end": "597760"
  },
  {
    "text": "later on wherefold will end up calling the function stack walk in a loop obtaining one stack frame at a time from",
    "start": "597760",
    "end": "605360"
  },
  {
    "text": "that crushing process now one thing we have to more carefully examine is the third argument to sim",
    "start": "605360",
    "end": "612079"
  },
  {
    "text": "initialize which is a boolean flag called f invade process",
    "start": "612079",
    "end": "617600"
  },
  {
    "text": "f invite process is set to true by where fault and that means that at that time",
    "start": "617600",
    "end": "622959"
  },
  {
    "text": "sim initialize would try to load the pdb file for every loaded module or dll in",
    "start": "622959",
    "end": "628720"
  },
  {
    "text": "that crashing process and you can see it here in that process monitor snipped where i crashed notepad",
    "start": "628720",
    "end": "636480"
  },
  {
    "text": "and the warehole handling that crush try to load the pdb file from notepad",
    "start": "636480",
    "end": "641519"
  },
  {
    "text": "ntdl kernel 32 kernel base and it will do that for every module loaded into",
    "start": "641519",
    "end": "648079"
  },
  {
    "text": "notepad so now that we know that warehold parse pdb files let's discuss what permissions",
    "start": "648079",
    "end": "655040"
  },
  {
    "text": "or privileges warehold runs as and warfald usually runs with the same",
    "start": "655040",
    "end": "660320"
  },
  {
    "text": "permissions as of the crushing process and this makes sense because it has to open that process and read its memory in",
    "start": "660320",
    "end": "667120"
  },
  {
    "text": "order to produce the cross report but there's one exception for that which i was already familiar with at that",
    "start": "667120",
    "end": "673440"
  },
  {
    "text": "point because i discovered another vulnerability in that flow and",
    "start": "673440",
    "end": "678640"
  },
  {
    "text": "if the crushing process runs under the low integrity level then the werefold handling that crush runs under medium",
    "start": "678640",
    "end": "685680"
  },
  {
    "text": "integrity level which is more privileged so for non-windows folks let's discuss",
    "start": "685680",
    "end": "692079"
  },
  {
    "text": "what are integrity levels and integrity levels is a feature that was introduced",
    "start": "692079",
    "end": "697519"
  },
  {
    "text": "by microsoft at windows vista because they realized that most users run as local administrator accounts on their",
    "start": "697519",
    "end": "704079"
  },
  {
    "text": "machines and that means that if an attacker exploits vulnerability in the context of a process running as local",
    "start": "704079",
    "end": "711120"
  },
  {
    "text": "administrator it completely owns that system and microsoft wanted to come up with",
    "start": "711120",
    "end": "716639"
  },
  {
    "text": "some mechanism to further restrict processes or contact sets that run under",
    "start": "716639",
    "end": "722000"
  },
  {
    "text": "the same user accounts this is a process explorer snipped from my windows 10 machine and as you can see",
    "start": "722000",
    "end": "730279"
  },
  {
    "text": "explorer.exe the windows shell for instance runs under medium integrity",
    "start": "730279",
    "end": "735360"
  },
  {
    "text": "under my account as opposed to process explorer itself which runs under high",
    "start": "735360",
    "end": "740959"
  },
  {
    "text": "integrity level which is more privileged now the law integrity is usually used",
    "start": "740959",
    "end": "747279"
  },
  {
    "text": "for application sandboxing for instance the internet explorer renderer processes run under low",
    "start": "747279",
    "end": "754320"
  },
  {
    "text": "integrity level those processes render all the html and javascript provided by remote http",
    "start": "754320",
    "end": "760560"
  },
  {
    "text": "servers which is a logic that's very much likely to have security vulnerabilities in",
    "start": "760560",
    "end": "766160"
  },
  {
    "text": "so microsoft wanted to restrict those processes and if an attacker exploits a vulnerability in that context you'd only",
    "start": "766160",
    "end": "773440"
  },
  {
    "text": "run at low integrity and be limited with what you can do to that system so browser exploit chains nowadays",
    "start": "773440",
    "end": "780240"
  },
  {
    "text": "usually chain a renderer rc exploit followed by another bug to escape the",
    "start": "780240",
    "end": "786000"
  },
  {
    "text": "sandbox and that's the game plan for our attack surface this is exactly what i'm going",
    "start": "786000",
    "end": "791839"
  },
  {
    "text": "to try to achieve elevate privileges from low integrity to medium integrity",
    "start": "791839",
    "end": "797839"
  },
  {
    "text": "and i'd assume i'll already run code at native level on low integrity on the system that i'm exploiting",
    "start": "797839",
    "end": "804399"
  },
  {
    "text": "so from that low integrity process i'd write the malphone pdb file discovered",
    "start": "804399",
    "end": "809600"
  },
  {
    "text": "to disk then i crash my own process which will spawn where fault at medium integrity to",
    "start": "809600",
    "end": "815760"
  },
  {
    "text": "handle that crash and hopefully that instance of warehouse would load the pdb file from disk and",
    "start": "815760",
    "end": "822639"
  },
  {
    "text": "the pdb parsing bug would be triggered in its context and if i exploit that i",
    "start": "822639",
    "end": "827680"
  },
  {
    "text": "could elevate privileges so to do so there's one problem i have to solve",
    "start": "827680",
    "end": "833920"
  },
  {
    "text": "i cannot write to most paths on disk as low integrity and this is one of the",
    "start": "833920",
    "end": "839440"
  },
  {
    "text": "basic restrictions that no integrity level poses so",
    "start": "839440",
    "end": "845680"
  },
  {
    "text": "there are a few directories that are writable by intention like the app data local load directory and are the users",
    "start": "845680",
    "end": "851839"
  },
  {
    "text": "directory so i can write my malform pdb files to that directory but how can i",
    "start": "851839",
    "end": "857600"
  },
  {
    "text": "get wherefold to load it from there and apparently there's a very easy",
    "start": "857600",
    "end": "862880"
  },
  {
    "text": "workaround for that when you compile some binary the compiler puts the path to the pdb file",
    "start": "862880",
    "end": "869440"
  },
  {
    "text": "at the time of compilation onto the pe executable header of that binary",
    "start": "869440",
    "end": "875120"
  },
  {
    "text": "and if you later debug your code on the same machine you compiled it then the debugger would know where to fetch that",
    "start": "875120",
    "end": "880880"
  },
  {
    "text": "pdb file from and apparently the bug help honors that value which means that given that i can",
    "start": "880880",
    "end": "887600"
  },
  {
    "text": "run my own executable at low intermediate level i could set the pdb file path on that pe header onto the app",
    "start": "887600",
    "end": "895279"
  },
  {
    "text": "data local load directory and wherefall would load the pdb file from there",
    "start": "895279",
    "end": "900720"
  },
  {
    "text": "and you can see it here in this snipped and the process explorer snipped above i",
    "start": "900720",
    "end": "906079"
  },
  {
    "text": "ran self crash at low integrity and when it crashed it spawned wherefold on medium integrity to handle that crash",
    "start": "906079",
    "end": "913440"
  },
  {
    "text": "and the windy bug's name below is debugging that instance of wherefold and as you can see warehold crashed with",
    "start": "913440",
    "end": "921120"
  },
  {
    "text": "an access violation in the pdb parsing code at medium integrity which shows that this attack surface in",
    "start": "921120",
    "end": "928240"
  },
  {
    "text": "fact works and can be used to elevate privileges so now let's start the second part of",
    "start": "928240",
    "end": "934880"
  },
  {
    "text": "this talk where i discussed into depth one of the pdb parsing bugs in debug",
    "start": "934880",
    "end": "940160"
  },
  {
    "text": "help and how it can be exploited in that context so this is a very simplified soda code",
    "start": "940160",
    "end": "947519"
  },
  {
    "text": "of the bug in debug help first some integer index value is read",
    "start": "947519",
    "end": "953279"
  },
  {
    "text": "directly from that pdb file and attacker has full control over that",
    "start": "953279",
    "end": "958639"
  },
  {
    "text": "value then there are certain checks on that index which we'll discuss later on",
    "start": "958639",
    "end": "964480"
  },
  {
    "text": "and that index is used to select an object from an array of objects that's already been initialized at that point",
    "start": "964480",
    "end": "971680"
  },
  {
    "text": "but that index value is not used as is but the value 1 is subtracted from that",
    "start": "971680",
    "end": "977360"
  },
  {
    "text": "index value and the reason why is that this is a one based index onto the array while array",
    "start": "977360",
    "end": "983120"
  },
  {
    "text": "access in cnc plus plus is a zero based access so debugger had to correlate the two",
    "start": "983120",
    "end": "990959"
  },
  {
    "text": "finally on that selected object a virtual function call is being called",
    "start": "990959",
    "end": "996720"
  },
  {
    "text": "now microsoft did have a few checks on that index value to make sure that it",
    "start": "996720",
    "end": "1002000"
  },
  {
    "text": "doesn't go out of bound of the array and its value is not too high or too low but they were missing a check for the",
    "start": "1002000",
    "end": "1008560"
  },
  {
    "text": "value of zero and if that index value is zero this one is still subtracted from",
    "start": "1008560",
    "end": "1014320"
  },
  {
    "text": "that index and the negative one cell of the array is going to be selected and",
    "start": "1014320",
    "end": "1020079"
  },
  {
    "text": "this results in a type confusion vulnerability confusing whatever data we have just prior to that array",
    "start": "1020079",
    "end": "1027280"
  },
  {
    "text": "with an object pointer so what's on the negative one index of that array",
    "start": "1027280",
    "end": "1033600"
  },
  {
    "text": "i found out that that array itself is allocated on the windows hip and prior",
    "start": "1033600",
    "end": "1038959"
  },
  {
    "text": "to every hip location you have the hip header which describes some metadata regarding that specific location",
    "start": "1038959",
    "end": "1046400"
  },
  {
    "text": "and that means that the only primitive that this bug allows is to type confuse the hip header with an object pointer",
    "start": "1046400",
    "end": "1054960"
  },
  {
    "text": "so i decided to take a look at what the heap header looks like and it is an eight bytes header prior to",
    "start": "1054960",
    "end": "1060799"
  },
  {
    "text": "every hip allocation and given that i try to exploit that vulnerability in the context of a 32-bit",
    "start": "1060799",
    "end": "1067039"
  },
  {
    "text": "process which i promise i will later tell you why this means that i'm going to treat the",
    "start": "1067039",
    "end": "1072720"
  },
  {
    "text": "lower part the lower d word or four bytes of that header as an object",
    "start": "1072720",
    "end": "1078160"
  },
  {
    "text": "pointer so the hip entry structure describes the actual",
    "start": "1078160",
    "end": "1084000"
  },
  {
    "text": "struct of that hip header and as you can see those last four byte meaning is the",
    "start": "1084000",
    "end": "1090320"
  },
  {
    "text": "previous size segment offset and unused bytes part of that hipaa location",
    "start": "1090320",
    "end": "1097039"
  },
  {
    "text": "and my initial toll was that maybe i can control or predict those values somehow",
    "start": "1097039",
    "end": "1102640"
  },
  {
    "text": "because i do have a certain degree of control over the objects array but then i found out that windows has a",
    "start": "1102640",
    "end": "1109120"
  },
  {
    "text": "feature that's called hip encoding that prevents me from doing so hip encoding is a security cookie-like",
    "start": "1109120",
    "end": "1115919"
  },
  {
    "text": "feature that aims to prevent exploitation of hip overrun vulnerabilities",
    "start": "1115919",
    "end": "1121280"
  },
  {
    "text": "and the way it works is that the allocator encodes or source the value of",
    "start": "1121280",
    "end": "1126480"
  },
  {
    "text": "the hip headers in memory with a random sort key and what that poses on attackers imagine",
    "start": "1126480",
    "end": "1133919"
  },
  {
    "text": "in the past they had a primitive to overflow the hip so what they used to do is to",
    "start": "1133919",
    "end": "1140400"
  },
  {
    "text": "override the adjacent or next hip header for the next chunk",
    "start": "1140400",
    "end": "1145600"
  },
  {
    "text": "and set it to arbitrary values and there were pretty good exploitation primitives you could construct with that",
    "start": "1145600",
    "end": "1151840"
  },
  {
    "text": "but given that hip encoding feature unless they leak that random key they cannot do so",
    "start": "1151840",
    "end": "1160080"
  },
  {
    "text": "so the key itself is an 8 byte key that's generated per hip at runtime in the empty dll rtlp create encoding",
    "start": "1160080",
    "end": "1168400"
  },
  {
    "text": "function but i found out that there's a weakness in its in its implementation",
    "start": "1168400",
    "end": "1174160"
  },
  {
    "text": "and part of that key is always set to zeros more specifically the higher two",
    "start": "1174160",
    "end": "1180480"
  },
  {
    "text": "bytes of the lower part of that header are set to zero and if you recall if you saw something",
    "start": "1180480",
    "end": "1186960"
  },
  {
    "text": "with zero then its value would remain clear text and that means that microsoft",
    "start": "1186960",
    "end": "1192080"
  },
  {
    "text": "wanted to keep those two bytes of their original content and not encoded and i'm not really sure",
    "start": "1192080",
    "end": "1199440"
  },
  {
    "text": "why it could be for some compatibility reason or for some optimization",
    "start": "1199440",
    "end": "1206480"
  },
  {
    "text": "given that is the hip header value predictable now imagine this is the content of that",
    "start": "1206480",
    "end": "1213919"
  },
  {
    "text": "hip header so the fake object pointer is going to be treated as its lower part and the",
    "start": "1213919",
    "end": "1220799"
  },
  {
    "text": "most significant bite in that fake pointer meaning is the unused bytes part",
    "start": "1220799",
    "end": "1226720"
  },
  {
    "text": "of that hip buffer and unused bytes meaning is the difference between the",
    "start": "1226720",
    "end": "1232400"
  },
  {
    "text": "size the user asked for when he allocated that hip chunk and the size of",
    "start": "1232400",
    "end": "1237760"
  },
  {
    "text": "buffer he actually got because there might be a difference between the two depending on how the allocator manages",
    "start": "1237760",
    "end": "1243840"
  },
  {
    "text": "the hip and that value remains of clear text and",
    "start": "1243840",
    "end": "1249039"
  },
  {
    "text": "i found out that for object array which is a very small location from my test",
    "start": "1249039",
    "end": "1254320"
  },
  {
    "text": "case it only consists three pointers or 12 bytes in size then the unused bytes part of that",
    "start": "1254320",
    "end": "1261360"
  },
  {
    "text": "header is predictable and most of the times would be equal to the value of 18",
    "start": "1261360",
    "end": "1267760"
  },
  {
    "text": "and this means that despite the fact i cannot fully predict the content of that",
    "start": "1267760",
    "end": "1272960"
  },
  {
    "text": "fake object pointer i can tell for sure that it would only only point to a low",
    "start": "1272960",
    "end": "1278240"
  },
  {
    "text": "user mode address and as you'll see later on this is sufficient for me to exploit this bug",
    "start": "1278240",
    "end": "1286159"
  },
  {
    "text": "now what i'm trying to achieve here is to set the index value to zero which would trigger the type confusion",
    "start": "1286159",
    "end": "1292400"
  },
  {
    "text": "vulnerability and then because a virtual function called is called upon that buffer a con",
    "start": "1292400",
    "end": "1298880"
  },
  {
    "text": "opponent object that fake object pointer then this means that that value is going",
    "start": "1298880",
    "end": "1304080"
  },
  {
    "text": "to be the reference twice to obtain the address of that virtual function",
    "start": "1304080",
    "end": "1309440"
  },
  {
    "text": "and that address is likely not even allocated in the context of where fault so if as an attacker i'd be able to",
    "start": "1309440",
    "end": "1317280"
  },
  {
    "text": "allocate it and control its content this means i'd be able to hijack the execution flow",
    "start": "1317280",
    "end": "1323280"
  },
  {
    "text": "and trigger a primitive to call any absolute address i want in the context",
    "start": "1323280",
    "end": "1328320"
  },
  {
    "text": "of wherefolds and to do that i've told you before",
    "start": "1328320",
    "end": "1333600"
  },
  {
    "text": "why would i be exploiting this bug in the context of 32 bit and i found out that if a 32-bit",
    "start": "1333600",
    "end": "1340480"
  },
  {
    "text": "executable crushes then the worse we see that spawns where fault for that crash",
    "start": "1340480",
    "end": "1346640"
  },
  {
    "text": "handling would spawn the 32-bit version of warefold and that makes exploitation of this bug",
    "start": "1346640",
    "end": "1353360"
  },
  {
    "text": "much easier because it is easier to spray the memory of a 32-bit address",
    "start": "1353360",
    "end": "1359039"
  },
  {
    "text": "space versus to 64-bit which is much larger and also the allocators are way",
    "start": "1359039",
    "end": "1364880"
  },
  {
    "text": "more predictable in their 32-bit version so how exactly would i spray the memory",
    "start": "1364880",
    "end": "1375200"
  },
  {
    "text": "i had to come up with a primitive that allows me to alter somewhere false address space from that crashing process",
    "start": "1375200",
    "end": "1381600"
  },
  {
    "text": "running at low integrity i can obviously cannot write to its memory directly",
    "start": "1381600",
    "end": "1387600"
  },
  {
    "text": "directly because i run at a lower integrity level and if you recall i told you before that",
    "start": "1387600",
    "end": "1394799"
  },
  {
    "text": "sim initialize loads the pdb files for all loaded modules in that crashing",
    "start": "1394799",
    "end": "1400000"
  },
  {
    "text": "process so i decided to split my exploit functionality into two pdb files",
    "start": "1400000",
    "end": "1406720"
  },
  {
    "text": "the first one would spray the address space of where fault and the second one",
    "start": "1406720",
    "end": "1411919"
  },
  {
    "text": "would trigger the vulnerability in the context of fault and the reason why i chose to do so is",
    "start": "1411919",
    "end": "1418400"
  },
  {
    "text": "that i have a lot of constraints on the pdb file that triggers the vulnerability",
    "start": "1418400",
    "end": "1424080"
  },
  {
    "text": "its file format has to be in a certain way and i didn't want to solve those",
    "start": "1424080",
    "end": "1430480"
  },
  {
    "text": "constraints along with the ability to spray the memory of wherefold from that",
    "start": "1430480",
    "end": "1435679"
  },
  {
    "text": "same pdb file so this is why i split that functionality and i had to come up with a spray primitive from the first pdb",
    "start": "1435679",
    "end": "1444799"
  },
  {
    "text": "so my initial attempt was to create a very large pdb file with some repeated",
    "start": "1444799",
    "end": "1450480"
  },
  {
    "text": "pattern that i can look up in warehouse memory and i found out that debug help maps",
    "start": "1450480",
    "end": "1456799"
  },
  {
    "text": "that entire pdb file into memory regardless of its size using the map view of file api",
    "start": "1456799",
    "end": "1464960"
  },
  {
    "text": "and map viewer file maps memory at very predictable locations in 32-bit it would",
    "start": "1464960",
    "end": "1471039"
  },
  {
    "text": "try to allocate the top most option with 64",
    "start": "1471039",
    "end": "1476640"
  },
  {
    "text": "k bits alignment so that's quite predictable and that's pretty good from my spray primitive and i found out that",
    "start": "1476640",
    "end": "1483440"
  },
  {
    "text": "the bug help doesn't unmap that pdb file from memory up until sim initialize",
    "start": "1483440",
    "end": "1489440"
  },
  {
    "text": "exits even if the content of that pdb file is completely invalid and not a pdb",
    "start": "1489440",
    "end": "1496559"
  },
  {
    "text": "file at all so this is really good for me because it means that by the time i trigger the",
    "start": "1496559",
    "end": "1502799"
  },
  {
    "text": "vulnerability and the second pdb file is loaded the spread memory of the first",
    "start": "1502799",
    "end": "1508640"
  },
  {
    "text": "pdb file remains in place which i can count off",
    "start": "1508640",
    "end": "1513760"
  },
  {
    "text": "so how exactly is my exploit going to look like i'd start by running my code at low",
    "start": "1513760",
    "end": "1519919"
  },
  {
    "text": "integrity and then i write two pdb files onto the disk to the appdata local loan",
    "start": "1519919",
    "end": "1526240"
  },
  {
    "text": "directory spray dot pdb and trigger.pdb then i'd crush my own process at low",
    "start": "1526240",
    "end": "1533600"
  },
  {
    "text": "integrity which would spawn an instance of where fault at medium integrity to handle that crash",
    "start": "1533600",
    "end": "1540640"
  },
  {
    "text": "now the address space of where fault at that point is going to be quite clean because it is a newly created process",
    "start": "1540640",
    "end": "1548080"
  },
  {
    "text": "and then it would call sim initialize with the handle from my own crushing process at low integrity",
    "start": "1548080",
    "end": "1554799"
  },
  {
    "text": "and i would set it up in such a way that it would first load spray dot pdb and",
    "start": "1554799",
    "end": "1560240"
  },
  {
    "text": "then would load trigger.pdb and i can control that because the pdbs are loaded",
    "start": "1560240",
    "end": "1565760"
  },
  {
    "text": "by the order in the pebb ldr loaded modules list",
    "start": "1565760",
    "end": "1570880"
  },
  {
    "text": "so spray dot pdb file would be first read and mapped into memory which would",
    "start": "1570880",
    "end": "1576799"
  },
  {
    "text": "allocate a very large portion of the user mode address space of where fault with content that as an attacker i fully",
    "start": "1576799",
    "end": "1584559"
  },
  {
    "text": "control then trigger.pdb file is going to be mapped into memory",
    "start": "1584559",
    "end": "1591200"
  },
  {
    "text": "and that would trigger the pdb parsing vulnerability in the context of warehouse treating the hip header as an",
    "start": "1591200",
    "end": "1597840"
  },
  {
    "text": "object pointer and hopefully that pointer being pointing to a very low user mode address",
    "start": "1597840",
    "end": "1604240"
  },
  {
    "text": "is going to point somewhere onto my spray pdb file buffer and this means",
    "start": "1604240",
    "end": "1609600"
  },
  {
    "text": "that i would have full control over the content of that object and i'd be able to hijack the execution flow and call",
    "start": "1609600",
    "end": "1616720"
  },
  {
    "text": "any absolute address i want in the context of warehouse and this is a windy bug snipped",
    "start": "1616720",
    "end": "1623200"
  },
  {
    "text": "debugging warehouse itself at that state proving that i can call any address i",
    "start": "1623200",
    "end": "1629520"
  },
  {
    "text": "want as you can see the esi register points to the zero e0 address and i could set it to",
    "start": "1629520",
    "end": "1637039"
  },
  {
    "text": "any arbitrary address i want at that point which means that i could hijack the flow",
    "start": "1637039",
    "end": "1643360"
  },
  {
    "text": "but the next question would be where should i call to because my goal is to be able to execute arbitrary code",
    "start": "1643360",
    "end": "1650640"
  },
  {
    "text": "at the context of warehouse and if you closely examined the slide before you probably see that cfg or",
    "start": "1650640",
    "end": "1658480"
  },
  {
    "text": "control flow integrity which is a mitigation and microsoft added at windows 10",
    "start": "1658480",
    "end": "1663760"
  },
  {
    "text": "windows 8 is enabled on warehouse and cfg is a control flow integrity",
    "start": "1663760",
    "end": "1669760"
  },
  {
    "text": "mitigation that aims to prevent drop and code we use attacks",
    "start": "1669760",
    "end": "1674799"
  },
  {
    "text": "and the way it works is that the compiler instruments every indirect call or jump and add a call to a to a stub in",
    "start": "1674799",
    "end": "1683679"
  },
  {
    "text": "anti-dll which verifies that the call target was in fact supposed to be called",
    "start": "1683679",
    "end": "1689279"
  },
  {
    "text": "indirectly and the pe itself manages all the locations that are supposed to be called",
    "start": "1689279",
    "end": "1696240"
  },
  {
    "text": "in directory and the loader works with that list so i cannot just jump to a rock chain",
    "start": "1696240",
    "end": "1703520"
  },
  {
    "text": "and pivot the stack as i used to do before with exploits prior to cfg",
    "start": "1703520",
    "end": "1709279"
  },
  {
    "text": "but i found out that current32 load library is a valid cfg target at that",
    "start": "1709279",
    "end": "1715200"
  },
  {
    "text": "context and this means i can simply call it a load library is a function that",
    "start": "1715200",
    "end": "1720320"
  },
  {
    "text": "allows you to load a dll dynamically into the process so all i have to do is write another",
    "start": "1720320",
    "end": "1727120"
  },
  {
    "text": "file a dll file into the appdata local load directory then have load library load it and run",
    "start": "1727120",
    "end": "1733679"
  },
  {
    "text": "my payload from its entry point now aslr is not really an issue here and",
    "start": "1733679",
    "end": "1740000"
  },
  {
    "text": "what i mean by that is that i have to find the address of load library at runtime and put it onto my spray pdb",
    "start": "1740000",
    "end": "1747039"
  },
  {
    "text": "file but dls are loaded at the same base address at windows regardless of",
    "start": "1747039",
    "end": "1752960"
  },
  {
    "text": "integrity level and this means that i can simply fetch the address of load library at runtime from my low integrity",
    "start": "1752960",
    "end": "1760480"
  },
  {
    "text": "process and then build my spray buffer dynamically based on that address and",
    "start": "1760480",
    "end": "1766320"
  },
  {
    "text": "put it onto my pdb file now the last thing i have to take care",
    "start": "1766320",
    "end": "1771679"
  },
  {
    "text": "about is how to control the argument to load library because it is the path of the dll that's about to be loaded",
    "start": "1771679",
    "end": "1779440"
  },
  {
    "text": "and there's a different calling convention between the original virtual function call and that call to load",
    "start": "1779440",
    "end": "1785360"
  },
  {
    "text": "library which means that i don't control the argument pushed onto the stack",
    "start": "1785360",
    "end": "1790960"
  },
  {
    "text": "but i found a workaround for that i found a gadget function in the bug help itself which is a valid call target",
    "start": "1790960",
    "end": "1799440"
  },
  {
    "text": "and that function accepts one argument in as the this pointer which i do control",
    "start": "1799440",
    "end": "1805200"
  },
  {
    "text": "and it reads some buffer from that object and pushes it back onto the stack",
    "start": "1805200",
    "end": "1811200"
  },
  {
    "text": "then it also reads another function pointer from that same object and calls it indirectly",
    "start": "1811200",
    "end": "1817440"
  },
  {
    "text": "again with cfgna build so all i had to do is to change the two i have my exploit called this gadget",
    "start": "1817440",
    "end": "1824559"
  },
  {
    "text": "function which reorders the arguments and then it would call load library for me",
    "start": "1824559",
    "end": "1831360"
  },
  {
    "text": "and this is a demo showing that actually works i start by running cmd as low integrity",
    "start": "1831360",
    "end": "1838480"
  },
  {
    "text": "level which i'll show you by the output of the omi command then i go to the updater local load",
    "start": "1838480",
    "end": "1844480"
  },
  {
    "text": "directory and run my exploit code from there as you can see that spawned another",
    "start": "1844480",
    "end": "1851360"
  },
  {
    "text": "instance of cmd but this time it runs under medium integrity level which shows that i was",
    "start": "1851360",
    "end": "1857600"
  },
  {
    "text": "able to elevate privileges from low to medium",
    "start": "1857600",
    "end": "1863600"
  },
  {
    "text": "so now after we've seen the first demo for the stock i wanted to make thing a little bit harder and use that same",
    "start": "1863600",
    "end": "1870880"
  },
  {
    "text": "exploit to escape the internet explorer enhanced protected mod sandbox now enhanced protected mode is a feature",
    "start": "1870880",
    "end": "1877919"
  },
  {
    "text": "of internet explorer that is not enabled by default you have to check it through internet explorer settings",
    "start": "1877919",
    "end": "1884799"
  },
  {
    "text": "and if you do so then the renderer processes run under app container",
    "start": "1884799",
    "end": "1890080"
  },
  {
    "text": "which is an even more strict environment than the low integrity process but i don't have the time to go into the",
    "start": "1890080",
    "end": "1897120"
  },
  {
    "text": "exact details of how app container works so i won't discuss it right now but what you need to do to know for this",
    "start": "1897120",
    "end": "1904080"
  },
  {
    "text": "exploit is that if that random process of internet explorer crashes under app container the warehouse handling that",
    "start": "1904080",
    "end": "1911039"
  },
  {
    "text": "crash would also run under medium integrity level so my plan was to run my code at that",
    "start": "1911039",
    "end": "1918399"
  },
  {
    "text": "rendered process crush it and exploit the bug the same way but i found out that the pdb bug behaves",
    "start": "1918399",
    "end": "1924880"
  },
  {
    "text": "differently in that context and that effect object pointer or lower part of the hip entry points to a kernel",
    "start": "1924880",
    "end": "1932799"
  },
  {
    "text": "mod address rather than a very low user mode address and after some debugging i figure out",
    "start": "1932799",
    "end": "1939760"
  },
  {
    "text": "why in case internet explorer crashes that object survey is allocated on the",
    "start": "1939760",
    "end": "1946159"
  },
  {
    "text": "low fragmentation hip which is the optimized hip implementation of windows",
    "start": "1946159",
    "end": "1952080"
  },
  {
    "text": "and the ip entry structure on the lfh looks a little bit different and that",
    "start": "1952080",
    "end": "1958080"
  },
  {
    "text": "address because of that ends up being a kernel mod address which i obviously cannot allocate and the referencing it",
    "start": "1958080",
    "end": "1965120"
  },
  {
    "text": "will result in an access violation and the reason why it happens is that",
    "start": "1965120",
    "end": "1970480"
  },
  {
    "text": "warehouse reads a lot of memory from that crashing process and from my own",
    "start": "1970480",
    "end": "1975519"
  },
  {
    "text": "process that didn't do much work at the time the lfh was not kicked in because the l",
    "start": "1975519",
    "end": "1981600"
  },
  {
    "text": "phage kicks in only after a certain number of allocations at a specific size",
    "start": "1981600",
    "end": "1986880"
  },
  {
    "text": "are done and then it would put that bucket of buffers onto the lfh",
    "start": "1986880",
    "end": "1993279"
  },
  {
    "text": "so for internet explorer that's a very busy process that's not the case and this is why that bug behaved differently",
    "start": "1993279",
    "end": "2000960"
  },
  {
    "text": "so my original thought was that maybe i'd exploit another pdb parsing bug to exploit the enhanced protected mod",
    "start": "2000960",
    "end": "2007519"
  },
  {
    "text": "sandbox but then i found out that i am allowed to create child processes from internet",
    "start": "2007519",
    "end": "2013679"
  },
  {
    "text": "explorer sandbox they would still run under app container but this is sufficient for me",
    "start": "2013679",
    "end": "2019600"
  },
  {
    "text": "and all i had to do was to chain a proxy process here in the middle internet",
    "start": "2019600",
    "end": "2025279"
  },
  {
    "text": "explorer would run it and then that process would crash and i just simply tried the bug that same way",
    "start": "2025279",
    "end": "2033519"
  },
  {
    "text": "and this is the final demo for this talk showing this actually works i'd be running internet explorer and show you",
    "start": "2033519",
    "end": "2040240"
  },
  {
    "text": "that the rendering process runs under an app container then i would inject my code into that",
    "start": "2040240",
    "end": "2047200"
  },
  {
    "text": "app container process mimicking an attacker exploiting a vulnerability in the context of that",
    "start": "2047200",
    "end": "2052878"
  },
  {
    "text": "renderer and as you can see another instance of cmd was spawned",
    "start": "2052879",
    "end": "2058800"
  },
  {
    "text": "again at medium integrity level showing i was able to escape the internet explorer enhanced protected",
    "start": "2058800",
    "end": "2065040"
  },
  {
    "text": "mode sandbox and run code at medium level",
    "start": "2065040",
    "end": "2070158"
  },
  {
    "text": "so after writing those pocs i reported the bug to microsoft again with the new attack surface",
    "start": "2070159",
    "end": "2076800"
  },
  {
    "text": "details and now they agreed that it does meet the bar for security servicing and that it should be fixed",
    "start": "2076800",
    "end": "2083679"
  },
  {
    "text": "and their fix was quite simple it was shipped a few months later and all they did is to make warfall long no longer",
    "start": "2083679",
    "end": "2091118"
  },
  {
    "text": "parse pdb files from disk and the way they did that is to call the",
    "start": "2091119",
    "end": "2096480"
  },
  {
    "text": "function sim set extended option which tweaks the way sim initialize works and",
    "start": "2096480",
    "end": "2102640"
  },
  {
    "text": "they used an undocumented argument of the value 3 which reverse engineer and debug help i found out that simply means",
    "start": "2102640",
    "end": "2110400"
  },
  {
    "text": "do not load pdb files and that basically killed the attack",
    "start": "2110400",
    "end": "2115440"
  },
  {
    "text": "surface of having wherefold parsed malformed pdbs",
    "start": "2115440",
    "end": "2121119"
  },
  {
    "text": "now that would be all for this talk and a few takeaways i want you to take from here",
    "start": "2121119",
    "end": "2126720"
  },
  {
    "text": "is first of all that fuzzing is a very efficient tool to find vulnerabilities in the right targets and that's",
    "start": "2126720",
    "end": "2133119"
  },
  {
    "text": "something that every security researcher should have in his toolbelt next my exploit worked on the latest",
    "start": "2133119",
    "end": "2140400"
  },
  {
    "text": "windows 10 at the time despite all mitigations and the main reason it was quite easy to",
    "start": "2140400",
    "end": "2146000"
  },
  {
    "text": "exploit was that i could trigger the bug in the context of the 32-bit compatibility layer which is just not as",
    "start": "2146000",
    "end": "2153119"
  },
  {
    "text": "strongly mitigated as 64-bit next if you have one bug there might be",
    "start": "2153119",
    "end": "2159040"
  },
  {
    "text": "multiple attack surfaces into exploiting it especially if that bug is in some shared library",
    "start": "2159040",
    "end": "2165760"
  },
  {
    "text": "and finally the fix by microsoft didn't fix the debug help bug and it exists in",
    "start": "2165760",
    "end": "2171760"
  },
  {
    "text": "code until today they only kill the attack surface so maybe you guys can find other attack",
    "start": "2171760",
    "end": "2178079"
  },
  {
    "text": "surfaces into that parser and trigger that bag on your own thank you very much that be all",
    "start": "2178079",
    "end": "2185440"
  },
  {
    "text": "if you have any questions now be a good time to ask and otherwise you can always ping me on twitter",
    "start": "2185440",
    "end": "2191359"
  },
  {
    "text": "thank you very much",
    "start": "2191359",
    "end": "2194400"
  }
]