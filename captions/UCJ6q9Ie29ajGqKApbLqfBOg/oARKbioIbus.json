[
  {
    "text": "[Music]",
    "start": "70",
    "end": "3100"
  },
  {
    "text": "welcome to black hat briefings held November 21st through the 22nd 2001 in Amsterdam this is video tape number two",
    "start": "17880",
    "end": "25480"
  },
  {
    "text": "third generation exploits on NT win 2K platforms",
    "start": "25480",
    "end": "31920"
  },
  {
    "text": "right I think I'm scheduled to start now um my name is harar I'm a reverse engineer for blackout",
    "start": "32599",
    "end": "38640"
  },
  {
    "text": "Consulting and I'm going to speak about third generation exploits um that's pretty much it there",
    "start": "38640",
    "end": "46440"
  },
  {
    "text": "are a few basic rules when I speak which um basically include um I'm just the speaker you're the person who's trying",
    "start": "46440",
    "end": "53000"
  },
  {
    "text": "to get something out of the speech so whenever I speak too quickly or I speech slurred I'm not making myself clear yell",
    "start": "53000",
    "end": "59719"
  },
  {
    "text": "at me and if there's any question in the middle of the speech Just raise your hand or if you don't feel like raising",
    "start": "59719",
    "end": "66360"
  },
  {
    "text": "your hand just ask right away okay um I'm a bit nervous about",
    "start": "66360",
    "end": "71880"
  },
  {
    "text": "this because I haven't held the speech before and um those who have seen one of my previous speeches probably remember",
    "start": "71880",
    "end": "77439"
  },
  {
    "text": "the previous speech to go rather smooth and I can assure you this one won't go very smoothly",
    "start": "77439",
    "end": "84479"
  },
  {
    "text": "so all right um we're in for quite right the speech consists of two rather large",
    "start": "84479",
    "end": "89600"
  },
  {
    "text": "harves of one and A4 hour and during the first half I'll",
    "start": "89600",
    "end": "95240"
  },
  {
    "text": "cover a quick recapitulation of the first generation exploits I'll not really go into them deeply as everybody",
    "start": "95240",
    "end": "101720"
  },
  {
    "text": "knows about these I'll speak a bit about second generation exploits I'll not to go too deeply into those either because",
    "start": "101720",
    "end": "107840"
  },
  {
    "text": "they've been documented somewhere then I'll start speaking about third generation exploits and what's different",
    "start": "107840",
    "end": "114079"
  },
  {
    "text": "about them why they're important and well yeah m how to take advantage of",
    "start": "114079",
    "end": "121479"
  },
  {
    "text": "those and then I'll speak about the first component of third generation exploits which is Heap structure",
    "start": "121479",
    "end": "127599"
  },
  {
    "text": "exploitation basically it's buffer overruns in Malo buffers and um I'll",
    "start": "127599",
    "end": "133480"
  },
  {
    "text": "specifically focus on the NT side here because the Unix side has been documented in the last Frack by Max from",
    "start": "133480",
    "end": "139879"
  },
  {
    "text": "Synergy and as far as I know nobody has ever documented how this works under NT or with NT compilers and so on so I'll",
    "start": "139879",
    "end": "147440"
  },
  {
    "text": "speak a bit about that I'll start with some heat generalities because you need to have at least basic understanding on",
    "start": "147440",
    "end": "154000"
  },
  {
    "text": "what a heat manager is how it works and so on um then I'll speak specifically about",
    "start": "154000",
    "end": "159800"
  },
  {
    "text": "exploiting buffer overruns under the wind 2K heat manager I'll have a short demonstration",
    "start": "159800",
    "end": "165000"
  },
  {
    "text": "concerning this then I'll speak specifically about how to exploit these Malo overruns in the ball and sea heat",
    "start": "165000",
    "end": "172280"
  },
  {
    "text": "manager and um have a demonstration concerning that as well and finally I'll speak a bit about",
    "start": "172280",
    "end": "179360"
  },
  {
    "text": "the future of exploitation because the field of exploiting buffer overruns is going to change drastically within the next few years especially with new CPUs",
    "start": "179360",
    "end": "186840"
  },
  {
    "text": "like the I64 coming in and um things like non-executable Heap and stack Pages",
    "start": "186840",
    "end": "192080"
  },
  {
    "text": "being a standard feature and the fact that you'll most likely not be able to execute Shell Code anymore in a year",
    "start": "192080",
    "end": "197239"
  },
  {
    "text": "from now or in two years from now so um the entire way how buffer overuns will",
    "start": "197239",
    "end": "202519"
  },
  {
    "text": "be exploited will change a bit then we'll all take a well-deserved",
    "start": "202519",
    "end": "207840"
  },
  {
    "text": "break especially I'll need one and um the second half is going to recapitulate on how to",
    "start": "207840",
    "end": "215640"
  },
  {
    "text": "exploit format string bugs in the beginning I think everybody's pretty familiar with it but just to have a common level of understanding in the",
    "start": "215640",
    "end": "222159"
  },
  {
    "text": "audience I'll go quickly over it um I speak about the history of format string bugs I'll speak about the automated",
    "start": "222159",
    "end": "229720"
  },
  {
    "text": "detection of format string bugs and I'll speak about exploitation of format string",
    "start": "229720",
    "end": "235239"
  },
  {
    "text": "bugs and then the core of the second half will run around which is exploitation",
    "start": "235239",
    "end": "240280"
  },
  {
    "text": "reliability we all know that it's quite hard to exploit reliably in the wild I",
    "start": "240280",
    "end": "246040"
  },
  {
    "text": "mean it's always easy to write and exploit that works in the lab but if you actually go out there and want to own boxes you need need exploits that have a",
    "start": "246040",
    "end": "252879"
  },
  {
    "text": "pretty high probability of getting in there and getting in there without knocking over the service too many times",
    "start": "252879",
    "end": "257880"
  },
  {
    "text": "so the admin doesn't notice I mean stupid admins will usually restart the service three or four times before they actually notice something fish is going",
    "start": "257880",
    "end": "264240"
  },
  {
    "text": "on but still it's nicer if you can just walk in there without leaving traces",
    "start": "264240",
    "end": "270039"
  },
  {
    "text": "um I'll Define the problem of exploitation reliability later on then I'll present something you can do under",
    "start": "270039",
    "end": "275800"
  },
  {
    "text": "NT which will um give you a very very high probability of getting control",
    "start": "275800",
    "end": "281639"
  },
  {
    "text": "without messing with the stack in any way which is called the unhandled exception filter attack which is um nice",
    "start": "281639",
    "end": "289000"
  },
  {
    "text": "for lab environment but only only really good if you know very much about the",
    "start": "289000",
    "end": "294360"
  },
  {
    "text": "attack system and then I'll speak about the thre thread environment structure override which is something I've",
    "start": "294360",
    "end": "300000"
  },
  {
    "text": "invented um which works very well if you know pretty much nothing about the target box beside it's an an",
    "start": "300000",
    "end": "306960"
  },
  {
    "text": "machine so um we'll get into that later and afterwards I'll have some free time",
    "start": "306960",
    "end": "312400"
  },
  {
    "text": "for questions answers and discussions and if your head isn't hurting too much I think I'll come up with something else",
    "start": "312400",
    "end": "318199"
  },
  {
    "text": "to speak about later on if we still have time okay any questions concerning",
    "start": "318199",
    "end": "325440"
  },
  {
    "text": "this no we all know first generation exploits those are the standard stack",
    "start": "325440",
    "end": "331080"
  },
  {
    "text": "smashes where somebody's copying data into a stack buffer and smashes the EIP which or the the instruction pointer",
    "start": "331080",
    "end": "338000"
  },
  {
    "text": "which has been saved on the stack in this nice diagram you have the local variables of a function in green",
    "start": "338000",
    "end": "343880"
  },
  {
    "text": "you have the save frame pointer in what I'd call a light blue and you have the",
    "start": "343880",
    "end": "349319"
  },
  {
    "text": "return address in red and somebody starts copying lots of data into this buffer and just completely overwrites",
    "start": "349319",
    "end": "356199"
  },
  {
    "text": "all the data that's behind your original buffer and when the function that smashed the stack",
    "start": "356199",
    "end": "361600"
  },
  {
    "text": "returns it will read the user supplied return address from the stack and um",
    "start": "361600",
    "end": "368080"
  },
  {
    "text": "therefore the attacker can point the instruction pointer to any location in memory where he has put his shell code and execute that Shell Code I think this",
    "start": "368080",
    "end": "375000"
  },
  {
    "text": "is um pretty basic and common knowledge amongst",
    "start": "375000",
    "end": "380120"
  },
  {
    "text": "everybody so first generation exploits are the simple stack smashes they've",
    "start": "380120",
    "end": "385919"
  },
  {
    "text": "been documented in about a million documents a few very good ones by lf1 and then um a few very bad ones recently",
    "start": "385919",
    "end": "393560"
  },
  {
    "text": "because everybody thinks to need to document it once more um the EIP is completely taken so",
    "start": "393560",
    "end": "401520"
  },
  {
    "text": "we're taking advantage of a hardware specific feature we're exploiting the functionality of the return instruction",
    "start": "401520",
    "end": "407520"
  },
  {
    "text": "which reads the return address from the stack we're fairly low level at that",
    "start": "407520",
    "end": "412560"
  },
  {
    "text": "point so this is very CPU specific I mean it happens on many CPUs but still",
    "start": "412560",
    "end": "418520"
  },
  {
    "text": "it's very CPU specific the usual way these bugs occur are the basic CS everybody knows string copy",
    "start": "418520",
    "end": "425800"
  },
  {
    "text": "gets Sprint if the top three on every GP list when you're looking in source code",
    "start": "425800",
    "end": "431680"
  },
  {
    "text": "and they're fairly trivial to exploit I mean you just point the instruction pointer somewhere useful and then",
    "start": "431680",
    "end": "437120"
  },
  {
    "text": "execute code there that can be a bit trickier to exploit if the input is filtered like if you only have uppercase",
    "start": "437120",
    "end": "443120"
  },
  {
    "text": "characters from a to c it's going to be tricky to exploit it but unless the",
    "start": "443120",
    "end": "449720"
  },
  {
    "text": "input is very heavily filtered it's usually no problem I mean there's shell codes around which only consists of A to",
    "start": "449720",
    "end": "455400"
  },
  {
    "text": "Z 0 to 9 and so on at least on x86 these kind of bugs can be detected",
    "start": "455400",
    "end": "461319"
  },
  {
    "text": "via stress testing you just fire long strings into an application and hope it'll fall and um there'll usually be a",
    "start": "461319",
    "end": "467479"
  },
  {
    "text": "SE fault when you override EIP completely so everybody has played with",
    "start": "467479",
    "end": "473639"
  },
  {
    "text": "Pro scripts I assume or um e Elite security scanner with the same",
    "start": "473639",
    "end": "480120"
  },
  {
    "text": "artificial intelligence to find buffer overuns as Pearl has anyways due to the easy to find",
    "start": "480120",
    "end": "486479"
  },
  {
    "text": "nature and the easy way to exploit these bugs they're almost ex extinct in open source software it's bit like um a",
    "start": "486479",
    "end": "494840"
  },
  {
    "text": "biological analogy you have a beautiful animals out in the woods it can be spotted and it gets a high high value on",
    "start": "494840",
    "end": "501680"
  },
  {
    "text": "the market so people will hunt it and in open source they've been pretty much",
    "start": "501680",
    "end": "508120"
  },
  {
    "text": "hunted to Extinction they're still around somewhere hiding in the closed Source woods but um I don't think you'll",
    "start": "508120",
    "end": "514919"
  },
  {
    "text": "find too many of these These Days whoops then there's second generation",
    "start": "514919",
    "end": "520640"
  },
  {
    "text": "exploits which are a tad more complex there are cast screw-ups and off by ones",
    "start": "520640",
    "end": "525959"
  },
  {
    "text": "which um occur from oh I told you this was not going to be",
    "start": "525959",
    "end": "533600"
  },
  {
    "text": "smooth which occur from misusage of so-called save functions like sdrn cat",
    "start": "534839",
    "end": "541480"
  },
  {
    "text": "sdn copy and so on they are fairly well documented their Frack articles on exploiting off by ones in this case you",
    "start": "541480",
    "end": "549120"
  },
  {
    "text": "do normally not overwrite EIP as you only write one null B past the end of the original",
    "start": "549120",
    "end": "554320"
  },
  {
    "text": "buffer and therefore you don't take advantage of a hardware specific features such as the return instruction",
    "start": "554320",
    "end": "560760"
  },
  {
    "text": "but you take advantage of compiler functionality you're basically exp exporting the standard C prologue and",
    "start": "560760",
    "end": "566200"
  },
  {
    "text": "epilogue of a function I'll explain how this actually gets exploited in the Wilds in a minute",
    "start": "566200",
    "end": "571560"
  },
  {
    "text": "in the wild in a minute these ones can be quite hard to detect as um uh there are a few very",
    "start": "571560",
    "end": "579120"
  },
  {
    "text": "subtle things that can happen for example if you define a Char buffer with 20 bytes and you access the 20th element",
    "start": "579120",
    "end": "585480"
  },
  {
    "text": "element of that buffer like buff Square braet 20 you're not in that buffer anymore because the buffer starts at",
    "start": "585480",
    "end": "591480"
  },
  {
    "text": "null and ends at 19 so a lot of these things are a bit",
    "start": "591480",
    "end": "596959"
  },
  {
    "text": "tricky in the C language so there are a bit tricky to detect and they cannot be automatically detected secondly um You Take Control",
    "start": "596959",
    "end": "604720"
  },
  {
    "text": "after a small detour you don't immediately take control by overriding the stack You Take Control by",
    "start": "604720",
    "end": "610800"
  },
  {
    "text": "manipulating a compiler internal variable the frame pointer and then taking control afterwards after you've",
    "start": "610800",
    "end": "617399"
  },
  {
    "text": "manipulated this so um a few of these can still be found I mean um well pretty",
    "start": "617399",
    "end": "625279"
  },
  {
    "text": "much all exploits that have been posted recently somewhere are off by ones or similar subtle",
    "start": "625279",
    "end": "630959"
  },
  {
    "text": "bugs now the way to exploit these uh is a bit tricky",
    "start": "630959",
    "end": "637079"
  },
  {
    "text": "um we have the buffer to which we append in blue here and we have the safed frame pointer in white and we have the safed",
    "start": "637079",
    "end": "644959"
  },
  {
    "text": "EIP in red now the frame pointer is used by the compiler to index into local",
    "start": "644959",
    "end": "650800"
  },
  {
    "text": "variables so when we write a null bite behind our original buffer the terminating n bite for our buffer we",
    "start": "650800",
    "end": "656959"
  },
  {
    "text": "override the safed frame pointers lowest B with a null therefore we decrease its",
    "start": "656959",
    "end": "662360"
  },
  {
    "text": "value now my diagram is upside down to a certain extent because the stack",
    "start": "662360",
    "end": "667600"
  },
  {
    "text": "grows top to bottom instead of bottom to top and this diagram it's inverted but",
    "start": "667600",
    "end": "672920"
  },
  {
    "text": "doesn't really matter so the saf EBP is manipulated and when the function which",
    "start": "672920",
    "end": "678519"
  },
  {
    "text": "smashed the stack at that point returns it executes the standard C function epilog which is move ESP EBP to erase",
    "start": "678519",
    "end": "687120"
  },
  {
    "text": "local variables and then pop EBP P which pops the manipulated frame pointer into",
    "start": "687120",
    "end": "692920"
  },
  {
    "text": "the EBP register then the function returns as usual and nothing great happens we just",
    "start": "692920",
    "end": "698920"
  },
  {
    "text": "have to keep in mind that we've manipulated the frame pointer to point elsewhere now the next function the",
    "start": "698920",
    "end": "704480"
  },
  {
    "text": "calling function returns as well and the calling function executes the same code",
    "start": "704480",
    "end": "710240"
  },
  {
    "text": "move ESP EBP now as we've manipulated EBP to be decreased it would",
    "start": "710240",
    "end": "718000"
  },
  {
    "text": "slide downwards in memory and and in this diagram upwards so the ESP slides upwards from Saved EVP where it should",
    "start": "718000",
    "end": "726639"
  },
  {
    "text": "Point into the user Supply data and when",
    "start": "726639",
    "end": "734360"
  },
  {
    "text": "whoops and when the program then executes the return instruction it takes the data instead of out of Saved EIP out",
    "start": "734360",
    "end": "741360"
  },
  {
    "text": "of the user Supply data this is where the attacker gets full control and can point the instruction pointer to any location he",
    "start": "741360",
    "end": "748160"
  },
  {
    "text": "wishes any questions on this okay then there's the third",
    "start": "748160",
    "end": "754600"
  },
  {
    "text": "generation which is basically split up into two variants first off there's format string bugs it's a new bug class",
    "start": "754600",
    "end": "761880"
  },
  {
    "text": "that was discovered in summer 2000 I mean I think we all remember the day when that tf8 exploit for wo ftpd hit",
    "start": "761880",
    "end": "769959"
  },
  {
    "text": "buck trk and a bunch of people were trying to figure out what exactly it was doing it seems that this class of bug",
    "start": "769959",
    "end": "776959"
  },
  {
    "text": "has been around for a few years in the hands of a few people who didn't give it out and that means that these few people",
    "start": "776959",
    "end": "783160"
  },
  {
    "text": "had General keys to any computer in the world for a few years",
    "start": "783160",
    "end": "788199"
  },
  {
    "text": "nice okay um these bugs come from a misuse of the printf family of functions",
    "start": "788199",
    "end": "793720"
  },
  {
    "text": "where people don't actually Supply a format string like percent s but they just pass the user Supply data as format",
    "start": "793720",
    "end": "800360"
  },
  {
    "text": "string nothing happens as long as the user doesn't put a percent sign in there they are fairly trivial to spot",
    "start": "800360",
    "end": "807040"
  },
  {
    "text": "they're probably the only Buck class that can be spotted completely automatically and they're fairly well",
    "start": "807040",
    "end": "812760"
  },
  {
    "text": "documented by now and widely exploited after the first exploited Buck track there was like an an entire wagon load",
    "start": "812760",
    "end": "819279"
  },
  {
    "text": "of exploit hitting the mailing list within the next few weeks I mean everything was vulnerable but due to the",
    "start": "819279",
    "end": "825760"
  },
  {
    "text": "easy to find nature of these bugs they're very quickly hunted to Extinction almost um the funny thing",
    "start": "825760",
    "end": "831720"
  },
  {
    "text": "about format strings is that you don't really smash anything which gets you direct control it just allows you to",
    "start": "831720",
    "end": "837759"
  },
  {
    "text": "write to an arbitrary address or read data from an arbitrary address if the output is echoed back to you so you",
    "start": "837759",
    "end": "845079"
  },
  {
    "text": "don't override any CPU registers directly and you're not exactly taking",
    "start": "845079",
    "end": "850360"
  },
  {
    "text": "advantage of a CPU specific feature at all you're taking advantage of something that has been documented and is standard",
    "start": "850360",
    "end": "857279"
  },
  {
    "text": "and was there in the ANC EOC specification so basically we're moving away from the hardware to a higher",
    "start": "857279",
    "end": "863560"
  },
  {
    "text": "abstraction level when it comes to the proceed like to new generation of exploits the lowest level has been",
    "start": "863560",
    "end": "868759"
  },
  {
    "text": "exploited the return instruction then there's a higher level which is the compiler functionality the frame poter",
    "start": "868759",
    "end": "874160"
  },
  {
    "text": "overrides which have been exploited and now we're moving a bit higher to the level where we are dealing with standard",
    "start": "874160",
    "end": "880560"
  },
  {
    "text": "functionality in the lipy which nobody has ever thought about before I mean it's there nobody reads the",
    "start": "880560",
    "end": "886639"
  },
  {
    "text": "specification did anyone of you know there is a percent n in prth I",
    "start": "886639",
    "end": "892720"
  },
  {
    "text": "didn't so um anyways these bugs are very simple to exploit they're very power",
    "start": "892720",
    "end": "899040"
  },
  {
    "text": "powerful and they're very easy to find which is a property that is not very",
    "start": "899040",
    "end": "904279"
  },
  {
    "text": "good for the bugs because they're hunted to Extinction very quickly um you have",
    "start": "904279",
    "end": "909399"
  },
  {
    "text": "to imagine that form string bugs are pretty much very very beautiful bugs with very shiny shells and they're very",
    "start": "909399",
    "end": "915560"
  },
  {
    "text": "very trivial to spot and they're very valuable can imagine that they won't last long I doubt you'll find any",
    "start": "915560",
    "end": "921240"
  },
  {
    "text": "high-profile format string bugs in any open source application these days because everybody has a tool that scans",
    "start": "921240",
    "end": "926519"
  },
  {
    "text": "for forance string bugs and about a week after the W fpd exploit hit they're just running those tools over entire code",
    "start": "926519",
    "end": "933759"
  },
  {
    "text": "freeze and um you might still find a few of them in close Source software but",
    "start": "933759",
    "end": "939519"
  },
  {
    "text": "it's getting fewer and fewer I mean even checkpoint cleaned up all the remotely exploitable",
    "start": "939519",
    "end": "944839"
  },
  {
    "text": "ones and that took quite a while oh well they claim to have a tool",
    "start": "945040",
    "end": "951480"
  },
  {
    "text": "to find these things they claimed that before too but um now they are actually",
    "start": "951480",
    "end": "957720"
  },
  {
    "text": "gone okay the second half of third generation exploits is Heap structure",
    "start": "957720",
    "end": "963160"
  },
  {
    "text": "overrides most programmers or many security researchers thought that an",
    "start": "963160",
    "end": "968399"
  },
  {
    "text": "overflowing Malo buffer is not dangerous unless there is data behind that Mello",
    "start": "968399",
    "end": "973639"
  },
  {
    "text": "buffer used by the program that can be manipulated to gain access or gain raised privileges solar designer was the",
    "start": "973639",
    "end": "981199"
  },
  {
    "text": "first to publicly document that you can actually override the control structures that the Malo and free algorithms use to",
    "start": "981199",
    "end": "987639"
  },
  {
    "text": "write to arbitrary addresses most unixes there wasn't a post on Bure I think or",
    "start": "987639",
    "end": "992800"
  },
  {
    "text": "vde concerning an exploit for a trace M um these kind of exploits take",
    "start": "992800",
    "end": "998440"
  },
  {
    "text": "advantage of the lipy specific implementations for Malo and free basically they're even more",
    "start": "998440",
    "end": "1005480"
  },
  {
    "text": "abstract than generation one and two and they are way less standardized than the format string bucks format strings are",
    "start": "1005480",
    "end": "1011920"
  },
  {
    "text": "in the standard every compiler has to implement them in the same way the maloc",
    "start": "1011920",
    "end": "1017440"
  },
  {
    "text": "and free algorithm just has to work transparently to the programmer but",
    "start": "1017440",
    "end": "1022880"
  },
  {
    "text": "there's no standard on how to implement it there's a wide VAR variance or",
    "start": "1022880",
    "end": "1027959"
  },
  {
    "text": "variation between free and or Malo and free alos there's heaps of them out",
    "start": "1027959",
    "end": "1034600"
  },
  {
    "text": "there and um they're all subtly different and you need to know the exact",
    "start": "1034600",
    "end": "1040600"
  },
  {
    "text": "algorithm in order to exploit this properly so there's a lot of work to be done and if you enjoy reading source",
    "start": "1040600",
    "end": "1046079"
  },
  {
    "text": "code or binary then there's something you can do in your time um they allow writing to arbitrary",
    "start": "1046079",
    "end": "1052480"
  },
  {
    "text": "addresses arbitrary data and they have been documented for Unix in fra 57 as I",
    "start": "1052480",
    "end": "1057600"
  },
  {
    "text": "mentioned before and up until today they are undocumented for n and they're very hard to detect V",
    "start": "1057600",
    "end": "1064520"
  },
  {
    "text": "stress testing if not impossible because depending on the Malo algorithm used you need specific data to override that Heap",
    "start": "1064520",
    "end": "1071320"
  },
  {
    "text": "structure with in order for anything useful to trigger now um if you just override it",
    "start": "1071320",
    "end": "1076799"
  },
  {
    "text": "with Straight A's or straight Z's or straight numbers or whatever nothing will happen as you have to manipulate",
    "start": "1076799",
    "end": "1081840"
  },
  {
    "text": "the internal logic of the free algorithm in order to do anything useful so without knowing the exact um algorithm",
    "start": "1081840",
    "end": "1088799"
  },
  {
    "text": "used you can't really know what you should write to the end of the buffer",
    "start": "1088799",
    "end": "1094159"
  },
  {
    "text": "Furthermore with stress testing you never know how large the original buffer is so you're probably shifting around by",
    "start": "1094159",
    "end": "1102039"
  },
  {
    "text": "a bite or two and you're not overwriting or writing the right bits into the right locations in that control structure so",
    "start": "1102039",
    "end": "1108480"
  },
  {
    "text": "most likely the heaps and heaps of Moc overrides in Clos Source software and",
    "start": "1108480",
    "end": "1114080"
  },
  {
    "text": "nobody's ever found them because nobody knew how to look for them unless you're reading the binary which only a handful",
    "start": "1114080",
    "end": "1119520"
  },
  {
    "text": "of people do you're not going to get anywhere furthermore most or many of the",
    "start": "1119520",
    "end": "1126400"
  },
  {
    "text": "Malo free handlers use exception handling at least under NT so even if an exception occurs by luck the handle",
    "start": "1126400",
    "end": "1133000"
  },
  {
    "text": "themselves and return a failure for the free call have you ever seen a programmer check for the rides return",
    "start": "1133000",
    "end": "1138919"
  },
  {
    "text": "value of a free call no so these ones are still around",
    "start": "1138919",
    "end": "1144480"
  },
  {
    "text": "and they will be still around for the next few years I assume they're here to",
    "start": "1144480",
    "end": "1150280"
  },
  {
    "text": "stay any questions so far",
    "start": "1150280",
    "end": "1157039"
  },
  {
    "text": "right first off before we start getting into the abusing we have to get into the",
    "start": "1161280",
    "end": "1166679"
  },
  {
    "text": "abstract architecture of Heap managers there is quite a lot of different alos",
    "start": "1166679",
    "end": "1172440"
  },
  {
    "text": "around I mentioned that before every compiler and thus every lipy supplies",
    "start": "1172440",
    "end": "1177640"
  },
  {
    "text": "its own algorithm pretty much for heat management and if you want to have a",
    "start": "1177640",
    "end": "1182840"
  },
  {
    "text": "like just an estimate on how many algorithms are out there um has anyone",
    "start": "1182840",
    "end": "1188440"
  },
  {
    "text": "written or read rania's book on Unix internals like Unix internals New Frontiers or whatever I mean it has a",
    "start": "1188440",
    "end": "1196000"
  },
  {
    "text": "fairly extensive chapter on kernel memory allocators and that book lists",
    "start": "1196000",
    "end": "1201320"
  },
  {
    "text": "eight different kernel memory allocation algorithms just for kernel memory now you can assume that if there",
    "start": "1201320",
    "end": "1208799"
  },
  {
    "text": "is eight different algorithms on various unixes just for kernel memory allocation that the variety of Kernel mem or of",
    "start": "1208799",
    "end": "1215440"
  },
  {
    "text": "memory allocators in total is going to be huge secondly many programmers are being",
    "start": "1215440",
    "end": "1221360"
  },
  {
    "text": "taught in optimization classes that they're supposed to create an allocation profile of their application like to see",
    "start": "1221360",
    "end": "1227760"
  },
  {
    "text": "what size of buffers it allocates frequently and then optimize the heat management towards that so they Supply",
    "start": "1227760",
    "end": "1234159"
  },
  {
    "text": "their own heat management algorithms if you look at any large application like um Netscape Enterprise server or Oracle",
    "start": "1234159",
    "end": "1241400"
  },
  {
    "text": "they have their own heat managers in there with their own specific control structures and they're not documented",
    "start": "1241400",
    "end": "1246880"
  },
  {
    "text": "anywhere so unless you take it apart and read the disassembly you will not know what to",
    "start": "1246880",
    "end": "1252440"
  },
  {
    "text": "do and thirdly many operating systems Supply their own so ONN you have the the",
    "start": "1252440",
    "end": "1258960"
  },
  {
    "text": "entire heat management API supplied by the kernel as well or Not by the kernel but by the Wind 32",
    "start": "1258960",
    "end": "1265159"
  },
  {
    "text": "API so there is three major branches of heat managers in any application I even",
    "start": "1265159",
    "end": "1270440"
  },
  {
    "text": "have created a nice spiffy diagram",
    "start": "1270440",
    "end": "1275559"
  },
  {
    "text": "um I doubt I'll make it any clear if I try to explain what's actually going on there is there any question concerning",
    "start": "1275559",
    "end": "1283679"
  },
  {
    "text": "this no",
    "start": "1284200",
    "end": "1288200"
  },
  {
    "text": "I'll quickly go over it um on the far right you have the anti Heap memory API which is the Heap AOC local AOC Global",
    "start": "1295200",
    "end": "1302919"
  },
  {
    "text": "AOC function calls whatever which are used to you or which can be used to",
    "start": "1302919",
    "end": "1308640"
  },
  {
    "text": "access the windows 32 Heap and those change through to the virtual memory API to allocate pages and then chop off",
    "start": "1308640",
    "end": "1315799"
  },
  {
    "text": "small chunks of that pages and Dish them out now an application can either call those directly with a arrow on the far",
    "start": "1315799",
    "end": "1322520"
  },
  {
    "text": "right over there or they can use their own lipy like the compiler they use supplies their own Lipsy maloc which",
    "start": "1322520",
    "end": "1329600"
  },
  {
    "text": "either uses the virtual memory API directly or uses the anti Heap API thus",
    "start": "1329600",
    "end": "1335159"
  },
  {
    "text": "the two dash lines and then there might be a customized he implementation inside",
    "start": "1335159",
    "end": "1340520"
  },
  {
    "text": "the application which either calls the virtual memory API directly or calls the",
    "start": "1340520",
    "end": "1345760"
  },
  {
    "text": "lipy Heap management API and to be honest there there's one error missing it could also call the anti heat",
    "start": "1345760",
    "end": "1350840"
  },
  {
    "text": "management API so things can get quite complex",
    "start": "1350840",
    "end": "1357559"
  },
  {
    "text": "here and you have to remember a lot of weird structures and start documenting as many compilers as",
    "start": "1359200",
    "end": "1365159"
  },
  {
    "text": "possible okay for the wind 2K Heap major we have three major functions which are",
    "start": "1365159",
    "end": "1370799"
  },
  {
    "text": "used local aloc Heap aloc and Global aloc and basically local aloc Global",
    "start": "1370799",
    "end": "1376760"
  },
  {
    "text": "aloc and Heap Heap alloc are only there for historical reasons and they pretty",
    "start": "1376760",
    "end": "1382600"
  },
  {
    "text": "much chain through to R allocate Heap all of them which resides an",
    "start": "1382600",
    "end": "1388760"
  },
  {
    "text": "ntdll now interrupt me if I'm going too fast here um let's assume we have a program which allocates two blocks of 32",
    "start": "1393120",
    "end": "1399960"
  },
  {
    "text": "bytes each using the ARL allocate Heap API the memory will actually look like",
    "start": "1399960",
    "end": "1406640"
  },
  {
    "text": "this um the first point to the first Moc which is returned like the the",
    "start": "1406640",
    "end": "1412960"
  },
  {
    "text": "return value of the first Mello will be the beginning of memory block a but not block a which lies before the buffer",
    "start": "1412960",
    "end": "1420240"
  },
  {
    "text": "that is returned so we have some Control Data Windows uses internally in that",
    "start": "1420240",
    "end": "1426400"
  },
  {
    "text": "gray field block a control data and then the second buffer is allocated and again",
    "start": "1426400",
    "end": "1431600"
  },
  {
    "text": "we get the pointer to memory block b returned and a control block before that",
    "start": "1431600",
    "end": "1437760"
  },
  {
    "text": "now assume we have one of those standard overflows where we can just overwrite a few bytes behind our original buffer and",
    "start": "1437760",
    "end": "1443679"
  },
  {
    "text": "we overwrite the entire Block B Control",
    "start": "1443679",
    "end": "1448480"
  },
  {
    "text": "Data now if we manipulate this smartly or in an intelligent manner we can get",
    "start": "1449159",
    "end": "1456600"
  },
  {
    "text": "um RTL free Heap to WR to arbitrary addresses I'll start up a disassembly of",
    "start": "1456600",
    "end": "1463520"
  },
  {
    "text": "ant DL formats",
    "start": "1463520",
    "end": "1467279"
  },
  {
    "text": "okay now I know this looks scary this is um the disassembly provided by a very",
    "start": "1477960",
    "end": "1483120"
  },
  {
    "text": "good disassembler from Belgium if you disassemble the antd dll",
    "start": "1483120",
    "end": "1488600"
  },
  {
    "text": "and look at RTL allocate Heap I'll have a sip of water and then explain what's going on",
    "start": "1488600",
    "end": "1495559"
  },
  {
    "text": "okay um this function takes three arguments a handle to the Heap where",
    "start": "1503120",
    "end": "1508600"
  },
  {
    "text": "it's trying to free some flags and a pointer to the memory actually we'll skip all this crap this",
    "start": "1508600",
    "end": "1515039"
  },
  {
    "text": "is standard function setup pretty much go down a",
    "start": "1515039",
    "end": "1522120"
  },
  {
    "text": "bit here we can see that it checks for a null pointer being supplied to free if",
    "start": "1522120",
    "end": "1528159"
  },
  {
    "text": "the the pointer which it has supplied is in fact zero it jumps here and returns",
    "start": "1528159",
    "end": "1534200"
  },
  {
    "text": "true so it doesn't do anything then it checks some Flags in the Heap which have",
    "start": "1534200",
    "end": "1540679"
  },
  {
    "text": "to be specifically enabled using the G Flags utility so um they're not really",
    "start": "1540679",
    "end": "1547039"
  },
  {
    "text": "interesting and then here they load the ESI register with the",
    "start": "1550240",
    "end": "1555640"
  },
  {
    "text": "pointer to our control block edx points to the buffer edx minus one is the pointer to the to the control block so",
    "start": "1555640",
    "end": "1563720"
  },
  {
    "text": "ESI gets loaded with it and then they test field five which is in my slides",
    "start": "1563720",
    "end": "1570640"
  },
  {
    "text": "called Field Four which is a bit of a bad naming convention they test field five for its",
    "start": "1570640",
    "end": "1578200"
  },
  {
    "text": "lowermost bit so unless the lowermost bit of field five is",
    "start": "1578200",
    "end": "1584679"
  },
  {
    "text": "set they'll bail out an error and nothing will happen so I'll Advance the slides by one um",
    "start": "1584679",
    "end": "1593399"
  },
  {
    "text": "Field Five are these eight bits for Flags here I call it five because it's",
    "start": "1593399",
    "end": "1598559"
  },
  {
    "text": "at offset five of the structure so the structure is 8 by in total and at offset",
    "start": "1598559",
    "end": "1604480"
  },
  {
    "text": "offset five here there's the 8 bit so what they do here is they test whether",
    "start": "1604480",
    "end": "1609799"
  },
  {
    "text": "the lowest bit of the flag is set if not they jump out and bail",
    "start": "1609799",
    "end": "1616399"
  },
  {
    "text": "out d L is um a part of the pointer this is not really interesting to us because this will never occur and then they",
    "start": "1616960",
    "end": "1623799"
  },
  {
    "text": "compare a block for like the the control blocks Field Four to 40 hex and if it's",
    "start": "1623799",
    "end": "1630520"
  },
  {
    "text": "not below they'll bail out an error as well so if you overwrite the control",
    "start": "1630520",
    "end": "1636520"
  },
  {
    "text": "block with all A's nothing will happen because Field Four this one here needs to be lower",
    "start": "1636520",
    "end": "1644159"
  },
  {
    "text": "than 40 which means you'll probably have to override it with a number",
    "start": "1644159",
    "end": "1650158"
  },
  {
    "text": "okay skipping down a bit",
    "start": "1651440",
    "end": "1655278"
  },
  {
    "text": "further we see here we want to actually get to the is",
    "start": "1657880",
    "end": "1663360"
  },
  {
    "text": "larger block code I'll explain later why they test whether Al which is our flags",
    "start": "1663360",
    "end": "1669559"
  },
  {
    "text": "has bit8 set that one must be set as well then they jump to this point here",
    "start": "1669559",
    "end": "1679320"
  },
  {
    "text": "where they check whether the Heap is serialized and so on then they enter a critical section so they don't get any",
    "start": "1680200",
    "end": "1686320"
  },
  {
    "text": "Heap corruption on multi-threaded allocations and freeze and then we reach this point here",
    "start": "1686320",
    "end": "1693760"
  },
  {
    "text": "where they test field five for the fourth bit and that one must be set as",
    "start": "1693760",
    "end": "1701080"
  },
  {
    "text": "well and then we jump here to the arbitrary memory override of course this",
    "start": "1701080",
    "end": "1706279"
  },
  {
    "text": "isn't named that way in the disassem assmbly I I named it this way but okay ESI which is the pointer to the",
    "start": "1706279",
    "end": "1714000"
  },
  {
    "text": "beginning of the structure is subtracted from with 24 bytes so they are moving backwards to",
    "start": "1714000",
    "end": "1721600"
  },
  {
    "text": "the previous buffer save this in some local variable",
    "start": "1721600",
    "end": "1726880"
  },
  {
    "text": "here then they load eax from that location which we have supplied because",
    "start": "1727039",
    "end": "1732760"
  },
  {
    "text": "we've smashed the buffer and our the the control structure our buffer is buffer previous to the buffer we're freeing",
    "start": "1732760",
    "end": "1740880"
  },
  {
    "text": "currently that value gets saved in a local variable and then the value at four like",
    "start": "1740880",
    "end": "1747080"
  },
  {
    "text": "the at an offset of four is loaded into ESI it's saved into a local variable and",
    "start": "1747080",
    "end": "1753720"
  },
  {
    "text": "here we have an arbitrary memory overwrite we Supply ESI we Supply eax we",
    "start": "1753720",
    "end": "1760240"
  },
  {
    "text": "can write any value to any location looks a bit nicer whoops in the",
    "start": "1760240",
    "end": "1766720"
  },
  {
    "text": "slides here we the criteria which our block has to fulfill on a win 2K it's",
    "start": "1766720",
    "end": "1772960"
  },
  {
    "text": "enough to override the eth bite at eight bytes at the end of the buffer with XXXX",
    "start": "1772960",
    "end": "1778320"
  },
  {
    "text": "99xx yes excuse me do you have any idea what's the real use of that routine uh",
    "start": "1778320",
    "end": "1784799"
  },
  {
    "text": "basically they're doing a lot of very complicated checking is the previous buffer free is it free and larger than",
    "start": "1784799",
    "end": "1790799"
  },
  {
    "text": "something if yes then coales the two buffers basically they're trying to prevent a fragmentation of the Heap",
    "start": "1790799",
    "end": "1797360"
  },
  {
    "text": "assuming that you have a lot of small allocations and then you start freeing them they have to check whether two blocks are to get like next to each",
    "start": "1797360",
    "end": "1803799"
  },
  {
    "text": "other and free if they are then they need to be put together so that a larger allocation can",
    "start": "1803799",
    "end": "1810320"
  },
  {
    "text": "fill in that Gap otherwise you'll have the Heap very badly fragmented that doesn't mean that the",
    "start": "1810320",
    "end": "1815480"
  },
  {
    "text": "Heap can't get fragmented friend of mine is riding device drivers for mastering programs and he actually had to like",
    "start": "1815480",
    "end": "1821399"
  },
  {
    "text": "Implement his own kernel memory allocation routine because the ant konel memory allocation routine would crap out",
    "start": "1821399",
    "end": "1826679"
  },
  {
    "text": "if you were too many strangely sized buffers was pretty bad because the bug",
    "start": "1826679",
    "end": "1832559"
  },
  {
    "text": "only occurred after some company in Asia had burned 50,000 not working",
    "start": "1832559",
    "end": "1838720"
  },
  {
    "text": "CDs he had a bad day but",
    "start": "1838720",
    "end": "1846240"
  },
  {
    "text": "well well if you want my advice don't rely on",
    "start": "1846240",
    "end": "1851200"
  },
  {
    "text": "computers okay so to illustrate it again we have memory block a which we've",
    "start": "1852039",
    "end": "1857440"
  },
  {
    "text": "overwritten and we overwrite the Block B Control Data and then we've put all the criteria",
    "start": "1857440",
    "end": "1863360"
  },
  {
    "text": "which I've mentioned before in there and ESI instead of pointing to the beginning",
    "start": "1863360",
    "end": "1868679"
  },
  {
    "text": "of Block B gets subtracted 24 and points in the middle of our buffer and then they read eax from there",
    "start": "1868679",
    "end": "1877320"
  },
  {
    "text": "and ESI from there and at this point we can write to any location in memory any",
    "start": "1877320",
    "end": "1883000"
  },
  {
    "text": "value that we wish to write",
    "start": "1883000",
    "end": "1886919"
  },
  {
    "text": "any questions concerning this",
    "start": "1888840",
    "end": "1895760"
  },
  {
    "text": "okay so what we can safely claim is that if we can overwrite a complete control",
    "start": "1899440",
    "end": "1904919"
  },
  {
    "text": "block or at least the lower six bytes of it and have control over the data 25 bytes before that location we can easily",
    "start": "1904919",
    "end": "1911480"
  },
  {
    "text": "write any value to any location in memory of course neither the location nor the value may contain a null B if",
    "start": "1911480",
    "end": "1917679"
  },
  {
    "text": "it's there was a string operation that smashed the buffer but that doesn't need to be the case always so it could be a M",
    "start": "1917679",
    "end": "1924159"
  },
  {
    "text": "Copy override or whatever and something that should be important or is important is that we've",
    "start": "1924159",
    "end": "1930559"
  },
  {
    "text": "ignored a lot of other branches I mean we've jumped to a certain location in memory where the easiest way to get the",
    "start": "1930559",
    "end": "1936320"
  },
  {
    "text": "override is happening now there are other ways to override arbitrary memory and depending on how much you're",
    "start": "1936320",
    "end": "1942760"
  },
  {
    "text": "overriding and what you're overriding with and so on it just takes a lot of creativity and time to look through antd",
    "start": "1942760",
    "end": "1949720"
  },
  {
    "text": "and you'll probably find a way to write to arbitrary addresses a friend of mine Joey who used to speak at blackhead as",
    "start": "1949720",
    "end": "1955519"
  },
  {
    "text": "well has actually sent me a document a few weeks ago where he told me he has found ways of exporting Heap overuns I",
    "start": "1955519",
    "end": "1962200"
  },
  {
    "text": "looked at in it was completely different from my what I was doing it worked it exploited the same function but he took",
    "start": "1962200",
    "end": "1968080"
  },
  {
    "text": "a different branch now I like to think that my solution is nicer than his but in fact",
    "start": "1968080",
    "end": "1974480"
  },
  {
    "text": "it isn't it's just two ways of skinning a cat",
    "start": "1974480",
    "end": "1979559"
  },
  {
    "text": "so I think we should have a short demonstration showing this",
    "start": "1979679",
    "end": "1985158"
  },
  {
    "text": "off okay here we have a small example of vulnerable program and in order to have it a bit",
    "start": "1995480",
    "end": "2002440"
  },
  {
    "text": "more understandable for the audience I'll compile it with or I have compiled it with debug information which will",
    "start": "2002440",
    "end": "2008159"
  },
  {
    "text": "make it a bit more readable to those not very fluent in assembly which also means that we have",
    "start": "2008159",
    "end": "2014639"
  },
  {
    "text": "some alignment issues that will like normally we only need to read 30 bytes",
    "start": "2014639",
    "end": "2021559"
  },
  {
    "text": "in here and due to the debug information being put into the binary and the compiler acting differently we actually",
    "start": "2021559",
    "end": "2027039"
  },
  {
    "text": "have to support 112 minus 8 which is I'm not good at math um bites into there and",
    "start": "2027039",
    "end": "2035080"
  },
  {
    "text": "um then we'll exploit it but I think it should be fairly obvious so we're",
    "start": "2035080",
    "end": "2040519"
  },
  {
    "text": "allocating two blocks then we issue a gets into the first buffer and that",
    "start": "2040519",
    "end": "2046120"
  },
  {
    "text": "should show us that we can overflow the buffer with anything we like okay here we have the program in",
    "start": "2046120",
    "end": "2051839"
  },
  {
    "text": "the dis u in the debugger we had have9",
    "start": "2051839",
    "end": "2057639"
  },
  {
    "text": "here let the program run and now first we send",
    "start": "2058960",
    "end": "2065118"
  },
  {
    "text": "Adas 80 90",
    "start": "2065480",
    "end": "2071839"
  },
  {
    "text": "100 110 112 now here's the control",
    "start": "2071839",
    "end": "2080440"
  },
  {
    "text": "block with enter we go into disassembly",
    "start": "2082159",
    "end": "2088118"
  },
  {
    "text": "mode this chains through to RTL fre Heap we have the standard setup",
    "start": "2088119",
    "end": "2097040"
  },
  {
    "text": "they test those strange Flags we load ESI with a pointer to the control",
    "start": "2098520",
    "end": "2104960"
  },
  {
    "text": "block they load Al with ESI plus 5 which",
    "start": "2105079",
    "end": "2110280"
  },
  {
    "text": "is um the supplied X oh no 39 is the supply nine the second Supply nine they",
    "start": "2110280",
    "end": "2117320"
  },
  {
    "text": "test the lowest bit they test ESI plus 4 for being below",
    "start": "2117320",
    "end": "2123760"
  },
  {
    "text": "40",
    "start": "2123760",
    "end": "2126760"
  },
  {
    "text": "we land here they enter a critical section to make it safe for multi",
    "start": "2129599",
    "end": "2135720"
  },
  {
    "text": "thirding they test ESI plus 5 for bit 8 which is set we land",
    "start": "2135720",
    "end": "2142960"
  },
  {
    "text": "here ESI points to our block they subtract 24 18",
    "start": "2142960",
    "end": "2148160"
  },
  {
    "text": "hex we land here they Lo eax with the value we've",
    "start": "2148160",
    "end": "2155359"
  },
  {
    "text": "supplied they Lo ESA I with the value we've supplied and anybody can imagine what",
    "start": "2155640",
    "end": "2162400"
  },
  {
    "text": "this does it just moves the contents of the",
    "start": "2162400",
    "end": "2167800"
  },
  {
    "text": "eax register to the location pointed to at ESI so if I let this run there's going",
    "start": "2167800",
    "end": "2173839"
  },
  {
    "text": "to be an",
    "start": "2173839",
    "end": "2176200"
  },
  {
    "text": "exception um just to demonstrate that regular stress testing wouldn't have found this",
    "start": "2179599",
    "end": "2187040"
  },
  {
    "text": "we go into the routine here into RTL 3 Heap and we run through",
    "start": "2198440",
    "end": "2204359"
  },
  {
    "text": "it and one of the checks fail they issue an error",
    "start": "2204359",
    "end": "2209760"
  },
  {
    "text": "message jump and return so goodbye rtina goodbye Pearl",
    "start": "2209760",
    "end": "2219519"
  },
  {
    "text": "actually do you want me to write to some special address you supply or do you believe me that this can be done with",
    "start": "2221920",
    "end": "2228079"
  },
  {
    "text": "pretty much anything we",
    "start": "2228079",
    "end": "2230920"
  },
  {
    "text": "Supply okay um you tell me any value in",
    "start": "2234119",
    "end": "2239440"
  },
  {
    "text": "well which can be easily entered right here",
    "start": "2239440",
    "end": "2244040"
  },
  {
    "text": "now so location underscore underscore or value",
    "start": "2244599",
    "end": "2250400"
  },
  {
    "text": "underscore underscore underscore to",
    "start": "2250400",
    "end": "2254599"
  },
  {
    "text": "location I don't know",
    "start": "2256760",
    "end": "2261359"
  },
  {
    "text": "okay now this should be 90",
    "start": "2264720",
    "end": "2270560"
  },
  {
    "text": "100 110 112",
    "start": "2270560",
    "end": "2275359"
  },
  {
    "text": "RL free",
    "start": "2281160",
    "end": "2283960"
  },
  {
    "text": "Heap enter critical section load",
    "start": "2289880",
    "end": "2296960"
  },
  {
    "text": "eax with underscore underscore underscore underscore load",
    "start": "2296960",
    "end": "2303480"
  },
  {
    "text": "ESI with i i i i i I write underscore underscore",
    "start": "2303480",
    "end": "2308720"
  },
  {
    "text": "underscore underscore to i i i i i that was one I too",
    "start": "2308720",
    "end": "2315119"
  },
  {
    "text": "much any questions yes what's the use of the third",
    "start": "2317440",
    "end": "2324079"
  },
  {
    "text": "um I think I used it in testing at some point I never bothered to take it",
    "start": "2324079",
    "end": "2330760"
  },
  {
    "text": "[Laughter] out I don't write good code I just point",
    "start": "2331790",
    "end": "2338119"
  },
  {
    "text": "out others other people's",
    "start": "2338119",
    "end": "2341318"
  },
  {
    "text": "mistakes okay um for those of you not used to reading",
    "start": "2350200",
    "end": "2355720"
  },
  {
    "text": "disassembly we can have a short look I wrote a small program that um the",
    "start": "2355720",
    "end": "2361480"
  },
  {
    "text": "disassembler can create call graphs but they don't always work especially not with weird code like ntl so myself a",
    "start": "2361480",
    "end": "2368520"
  },
  {
    "text": "small plugin that creates a flow graph which might be a tad easier to follow so you have the entire block of",
    "start": "2368520",
    "end": "2375760"
  },
  {
    "text": "initialization here which we'll gladly ignore you have the comparison if this",
    "start": "2375760",
    "end": "2380920"
  },
  {
    "text": "is a null free here if it's a n free it follows this Branch down here and bails out if not we go here it tests some",
    "start": "2380920",
    "end": "2389119"
  },
  {
    "text": "weird Flags whether it wants to do a slow free or not we don't want to do a slow free or it never does a slow three",
    "start": "2389119",
    "end": "2395760"
  },
  {
    "text": "slow free so we land here where it loads the Heap description",
    "start": "2395760",
    "end": "2401200"
  },
  {
    "text": "Block in edx minus 8 and does the check whether the lowest bit of field five is",
    "start": "2401200",
    "end": "2408838"
  },
  {
    "text": "set and I'm wondering where the next error is heading to oh it's heading down here if it is zero then it adds to error",
    "start": "2409720",
    "end": "2418000"
  },
  {
    "text": "in our case it doesn't error so it goes on to some more checks it tests the l47",
    "start": "2418000",
    "end": "2423359"
  },
  {
    "text": "it checks whether the BTE is below 40",
    "start": "2423359",
    "end": "2428400"
  },
  {
    "text": "then we land at this point where we actually want to take this Branch down",
    "start": "2428400",
    "end": "2434200"
  },
  {
    "text": "here I should start making colored graphs I think black and white is kind of",
    "start": "2434200",
    "end": "2439520"
  },
  {
    "text": "dull okay and",
    "start": "2439520",
    "end": "2444160"
  },
  {
    "text": "then they check for the bit 8 and it is set in our case so we jump down here",
    "start": "2445079",
    "end": "2453040"
  },
  {
    "text": "to the enter critical section and to the arbitrary memory",
    "start": "2459880",
    "end": "2465240"
  },
  {
    "text": "overright which is down this Branch those call graphs are not easy to",
    "start": "2465240",
    "end": "2474279"
  },
  {
    "text": "navigate and apparently there's no good graphing utility that can display very large graphs because I was playing with",
    "start": "2475440",
    "end": "2481040"
  },
  {
    "text": "pointer control flow graphs recently and um all the utilities I have crash after",
    "start": "2481040",
    "end": "2487280"
  },
  {
    "text": "eating up all CPU power for about 20 minutes it's a fairly large graph I don't intend to like be able to read it",
    "start": "2487280",
    "end": "2493400"
  },
  {
    "text": "but I would like to debug some code and seems there's nothing out",
    "start": "2493400",
    "end": "2498960"
  },
  {
    "text": "there okay I think we've pretty much covered NT",
    "start": "2498960",
    "end": "2504480"
  },
  {
    "text": "here so we'll move on to the Ballon C++ runtime Library",
    "start": "2508560",
    "end": "2516359"
  },
  {
    "text": "and in ball and C we have a bit of a different situation I'll quickly fire up the disassembly so we can look at",
    "start": "2519079",
    "end": "2526280"
  },
  {
    "text": "it whoops",
    "start": "2530599",
    "end": "2534599"
  },
  {
    "text": "so here we go let's just assume that we have the same situation again where we",
    "start": "2547880",
    "end": "2553240"
  },
  {
    "text": "have memory block a and memory block b and we overwrite memory block a to overwrite the Control Data of Block B",
    "start": "2553240",
    "end": "2560839"
  },
  {
    "text": "now we can look a bit at the free Handler in band CES Lipsy in the",
    "start": "2560839",
    "end": "2568240"
  },
  {
    "text": "disassembly here we see that it checks for null free like for a free zero again",
    "start": "2568359",
    "end": "2574079"
  },
  {
    "text": "if it's null it bails out this line loads the control block",
    "start": "2574079",
    "end": "2579720"
  },
  {
    "text": "into edx and then Compares it to 1",
    "start": "2579720",
    "end": "2587519"
  },
  {
    "text": "Megabyte if it is lower it jumps to small three down here if it is larger it",
    "start": "2587640",
    "end": "2593160"
  },
  {
    "text": "jumps to the page the allocator because if a very large memory block was allocated it was not chopped off a small",
    "start": "2593160",
    "end": "2598800"
  },
  {
    "text": "page but it was multiple Pages being served out to the application so the large allocator here",
    "start": "2598800",
    "end": "2604800"
  },
  {
    "text": "does not do anything of use I just the virtual memory API and they just deallocate the pages and don't mess with",
    "start": "2604800",
    "end": "2611280"
  },
  {
    "text": "any structures in memory so we can't really do anything here with like",
    "start": "2611280",
    "end": "2616960"
  },
  {
    "text": "assuming that we write a value larger than 1 Megabyte to that control block",
    "start": "2616960",
    "end": "2623000"
  },
  {
    "text": "now from this we can see that no matter what happens if we",
    "start": "2623000",
    "end": "2628960"
  },
  {
    "text": "completely smash B with data then we're not going to get anywhere because to completely smash B with like the block b",
    "start": "2628960",
    "end": "2635880"
  },
  {
    "text": "b control block with data we would be writing a value larger than 1 Megabyte and that wouldn't mean that",
    "start": "2635880",
    "end": "2641440"
  },
  {
    "text": "nothing would happen they would just call the page allocator de allocator and that would be it so we actually want to",
    "start": "2641440",
    "end": "2648280"
  },
  {
    "text": "have something like an off by one exploit in heat memory",
    "start": "2648280",
    "end": "2653240"
  },
  {
    "text": "here if we look at the small free algorithm a",
    "start": "2656280",
    "end": "2661279"
  },
  {
    "text": "bit we can see that there's another check for a null free",
    "start": "2661960",
    "end": "2669040"
  },
  {
    "text": "then they load the control Block in ECX and um do some tests on",
    "start": "2670800",
    "end": "2677440"
  },
  {
    "text": "them I'll quickly try to figure out what I was thinking when I Was preparing",
    "start": "2677440",
    "end": "2683720"
  },
  {
    "text": "this oh yeah okay yes",
    "start": "2683720",
    "end": "2690440"
  },
  {
    "text": "okay actually I think we have many ways here to override memory but this is just",
    "start": "2690440",
    "end": "2695880"
  },
  {
    "text": "one okay okay now assuming that we have an off by one and we overwrite the lowest order byte of the control block",
    "start": "2695880",
    "end": "2703839"
  },
  {
    "text": "then reach this code here first it tests whether the um pointer being passed to",
    "start": "2703839",
    "end": "2709240"
  },
  {
    "text": "this um to this routine was null it then loads the value into ECX like the",
    "start": "2709240",
    "end": "2715160"
  },
  {
    "text": "control block into ECX and tests whether bit 2 is set bit 2 is normally set and",
    "start": "2715160",
    "end": "2722480"
  },
  {
    "text": "our it indicates that the previous block is in use uh to those of you that have played",
    "start": "2722480",
    "end": "2728280"
  },
  {
    "text": "with Malo overrides under Unix this should be very familiar because band just copy and paste the G",
    "start": "2728280",
    "end": "2734760"
  },
  {
    "text": "implementation anyways um that bit two in B's control block indicates a is not",
    "start": "2734760",
    "end": "2744440"
  },
  {
    "text": "free so if a is not free they don't do much they just bail",
    "start": "2744520",
    "end": "2751040"
  },
  {
    "text": "out so what we want it to do is we want it to think that block a is actually",
    "start": "2751040",
    "end": "2757440"
  },
  {
    "text": "free so as we have an off by one exploit here we overwrite the lowest order bite",
    "start": "2757440",
    "end": "2762880"
  },
  {
    "text": "of that control block with null so when it tests bit two",
    "start": "2762880",
    "end": "2770319"
  },
  {
    "text": "here it actually jumps here because it thinks the previous block is free and",
    "start": "2770319",
    "end": "2776240"
  },
  {
    "text": "then it tries to coales the two blocks so we",
    "start": "2776240",
    "end": "2780920"
  },
  {
    "text": "land I does some arbitrary checks here zeros out some bits checks for some",
    "start": "2781960",
    "end": "2788520"
  },
  {
    "text": "more flags and down here this comparison for",
    "start": "2788520",
    "end": "2794240"
  },
  {
    "text": "some reason always passes it seems to be some kind of debug implementation and then we jump to the arbitr memory",
    "start": "2794240",
    "end": "2800720"
  },
  {
    "text": "overwrite now edx is the pointer to our control",
    "start": "2800720",
    "end": "2806079"
  },
  {
    "text": "block so it reads the data at edx Plus 8 which is in memory block",
    "start": "2806079",
    "end": "2811400"
  },
  {
    "text": "b and reads the data at edx plus 4 and then writes to ECX + 4 which we",
    "start": "2811400",
    "end": "2820280"
  },
  {
    "text": "have supplied if we control memory block b it writes",
    "start": "2820280",
    "end": "2827839"
  },
  {
    "text": "basically well it takes takes a value out of memory block b because it thinks it's free and expects some internal",
    "start": "2827839",
    "end": "2834760"
  },
  {
    "text": "structure to be there and writes to the pointer in that structure some data in that structure as",
    "start": "2834760",
    "end": "2841640"
  },
  {
    "text": "well and if we control memory block b as well we can supply that entire structure",
    "start": "2841640",
    "end": "2847079"
  },
  {
    "text": "and as we've manipulated the internal logic of the free algorithm it's pretty well we are manipulating it to think the",
    "start": "2847079",
    "end": "2852800"
  },
  {
    "text": "structure was there when it wasn't and we're supplying all pointers so we can",
    "start": "2852800",
    "end": "2858119"
  },
  {
    "text": "again write to any location in memory I try to demonstrate that it looks a bit more complicated while in fact it's",
    "start": "2858119",
    "end": "2863880"
  },
  {
    "text": "simpler than the NT allocator just has more weight offsets with plus something",
    "start": "2863880",
    "end": "2868960"
  },
  {
    "text": "here so",
    "start": "2868960",
    "end": "2872960"
  },
  {
    "text": "oops okay here we have this program we allocate block a we allocate",
    "start": "2893400",
    "end": "2900359"
  },
  {
    "text": "Block B and we assume that we can supply data in both blocks",
    "start": "2900359",
    "end": "2906799"
  },
  {
    "text": "and then we call free",
    "start": "2906880",
    "end": "2909838"
  },
  {
    "text": "here we want to say the breakpoint on the",
    "start": "2914160",
    "end": "2920760"
  },
  {
    "text": "free call here 401",
    "start": "2921119",
    "end": "2927440"
  },
  {
    "text": "a64 somebody try to remember that",
    "start": "2927599",
    "end": "2931680"
  },
  {
    "text": "number okay",
    "start": "2935559",
    "end": "2938720"
  },
  {
    "text": "okay this is the first 30 bite buffer we're going after",
    "start": "2946280",
    "end": "2951839"
  },
  {
    "text": "so 10",
    "start": "2951839",
    "end": "2955680"
  },
  {
    "text": "oops 20 30 of course all buffer sizes are round up to a four by boundary so we",
    "start": "2957799",
    "end": "2965640"
  },
  {
    "text": "Supply some extra nles now we're at the end of the buffer and now we can see that nothing will happen",
    "start": "2965640",
    "end": "2970720"
  },
  {
    "text": "if we override this control block completely I hit enter and we enter the same stuff again",
    "start": "2970720",
    "end": "2977520"
  },
  {
    "text": "in the next buffer and here we have the free implementation of",
    "start": "2977520",
    "end": "2983920"
  },
  {
    "text": "Balland eax is the pointer to the second buffer eax minus",
    "start": "2985760",
    "end": "2991400"
  },
  {
    "text": "four is the controlled structure we which we have overwritten with all A's",
    "start": "2991400",
    "end": "2998558"
  },
  {
    "text": "they zero out the lowest few B bits and then they compare it here to edx uh they",
    "start": "3000000",
    "end": "3005040"
  },
  {
    "text": "compare edx which is the structure we've overwritten like the value of it to 1",
    "start": "3005040",
    "end": "3011000"
  },
  {
    "text": "megab our value is not below so the pat de allocator gets",
    "start": "3011000",
    "end": "3016960"
  },
  {
    "text": "called and nothing happens f",
    "start": "3016960",
    "end": "3024920"
  },
  {
    "text": "so we only want to exploit or to only write one bite extra 30",
    "start": "3028880",
    "end": "3036319"
  },
  {
    "text": "32 and that should be it and the next buffer should contain",
    "start": "3036319",
    "end": "3042119"
  },
  {
    "text": "our",
    "start": "3042119",
    "end": "3044400"
  },
  {
    "text": "data okay we're in the free again we have this comparison here and this time",
    "start": "3049839",
    "end": "3056880"
  },
  {
    "text": "edx is completely zered out as we've overwritten the lowest order bite and it",
    "start": "3056880",
    "end": "3062480"
  },
  {
    "text": "jumps to the small D",
    "start": "3062480",
    "end": "3066000"
  },
  {
    "text": "allocator it checks for the null it ends minus 4 to get the control block it",
    "start": "3068839",
    "end": "3075799"
  },
  {
    "text": "loads it into ECX tests whether the previous block is free the previous block is not like is",
    "start": "3075799",
    "end": "3084400"
  },
  {
    "text": "free as we've said it we made it believe that it is free so it jumps down",
    "start": "3084400",
    "end": "3091160"
  },
  {
    "text": "here does some manipulations and finally",
    "start": "3091160",
    "end": "3099880"
  },
  {
    "text": "lands wait here we seem to have landed elsewhere",
    "start": "3102640",
    "end": "3108640"
  },
  {
    "text": "than I claimed before but we're Landing in an arbitrary memory overwrite anyways",
    "start": "3108640",
    "end": "3115520"
  },
  {
    "text": "these ones are to be",
    "start": "3118599",
    "end": "3121400"
  },
  {
    "text": "ignored it seems that something is going horribly wrong okay we hit an exception which is",
    "start": "3126200",
    "end": "3132280"
  },
  {
    "text": "good I just Tred to figure out what's going on I think I made a mistake in my preparation",
    "start": "3132280",
    "end": "3139000"
  },
  {
    "text": "gets weirder I have to excuse myself I'll need a few seconds to figure this one",
    "start": "3160599",
    "end": "3168599"
  },
  {
    "text": "out if anyone has any questions in the meantime go ahead",
    "start": "3173200",
    "end": "3178440"
  },
  {
    "text": "ah crap Miss",
    "start": "3180839",
    "end": "3185480"
  },
  {
    "text": "yeah now you can see Heap overruns are not always",
    "start": "3189040",
    "end": "3193880"
  },
  {
    "text": "easy it's been a while since I played with it and just looked at it yesterday evening again",
    "start": "3199480",
    "end": "3207000"
  },
  {
    "text": "okay okay this now it works I don't know what I did incorrectly the first time",
    "start": "3222040",
    "end": "3229119"
  },
  {
    "text": "but it seems that something unexpected happened which shouldn't have happened and which will most likely not happen",
    "start": "3229119",
    "end": "3234920"
  },
  {
    "text": "again okay we have the N bite we write to after the end of the buffer we write",
    "start": "3234920",
    "end": "3241160"
  },
  {
    "text": "some data into this buffer as well and here we go we passed the",
    "start": "3241160",
    "end": "3246799"
  },
  {
    "text": "comparison concerning the size move down",
    "start": "3246799",
    "end": "3252720"
  },
  {
    "text": "here and then at this point edx points to the beginning of our",
    "start": "3254280",
    "end": "3261839"
  },
  {
    "text": "buffer and now ebx is loaded with the value there",
    "start": "3261839",
    "end": "3267760"
  },
  {
    "text": "ECX is loaded with a value in buffer b as well namely the value at offset n",
    "start": "3267760",
    "end": "3272880"
  },
  {
    "text": "like the very first value okay so we can see that we've",
    "start": "3272880",
    "end": "3278359"
  },
  {
    "text": "supplied ebx as it it was at offset 8 uh at",
    "start": "3278359",
    "end": "3284359"
  },
  {
    "text": "offset 4 in the buffer B and we've supplied ECX as it was was at offset null in buffer B and what's happening",
    "start": "3284359",
    "end": "3292520"
  },
  {
    "text": "now is he's writing a value to ECX Plus 8 and that value has been supplied by us",
    "start": "3292520",
    "end": "3299440"
  },
  {
    "text": "we have supplied ECX and we've supplied ebx so again we",
    "start": "3299440",
    "end": "3304760"
  },
  {
    "text": "can write an arbitrary value to an arbitrary location I'm sorry if I confused you a bit with me fumbling",
    "start": "3304760",
    "end": "3310160"
  },
  {
    "text": "around here I'm not quite sure what happened but I might have just made a stupid typo or whatever that led us to",
    "start": "3310160",
    "end": "3317920"
  },
  {
    "text": "the wrong location I assume that as you didn't believe me that this works with Heap",
    "start": "3317920",
    "end": "3324119"
  },
  {
    "text": "overuns under NT you don't believe me that this works either so I have to demonstrate it",
    "start": "3324119",
    "end": "3329558"
  },
  {
    "text": "again if you're ping it into thinking block a is already free so it should with that why does it think there a",
    "start": "3331160",
    "end": "3337280"
  },
  {
    "text": "control structure in Block B that's the one that you're freeing actually I think we're making it",
    "start": "3337280",
    "end": "3345039"
  },
  {
    "text": "believe that Block B is free or aren't we you you smash the control block",
    "start": "3345039",
    "end": "3353440"
  },
  {
    "text": "for it's true and then you and then we free B",
    "start": "3353440",
    "end": "3360079"
  },
  {
    "text": "apparently let me Ponder this for a second to be honest um I never ask the why I ask the",
    "start": "3360079",
    "end": "3368680"
  },
  {
    "text": "how now um this might be a bit strange because most people dealing with the source side",
    "start": "3368680",
    "end": "3375359"
  },
  {
    "text": "of um exploiting Heap overruns are actually understanding the entire thing but if you look at the anti Heap",
    "start": "3375359",
    "end": "3381640"
  },
  {
    "text": "allocator and you have the choice of either spending 10 hours figuring out how to exploit it are spending 60 hours",
    "start": "3381640",
    "end": "3388240"
  },
  {
    "text": "understanding why the hell it does what it does which way do you choose so um I have to admit I have no",
    "start": "3388240",
    "end": "3396240"
  },
  {
    "text": "idea why this is going on just plain simple but I can assure you that if",
    "start": "3396240",
    "end": "3402520"
  },
  {
    "text": "anyone of us sits down and looks at the disassembly for a few more days then we'll know it but who wants to",
    "start": "3402520",
    "end": "3410039"
  },
  {
    "text": "know I mean this is not about heat management this is about Heap abuse",
    "start": "3410039",
    "end": "3416920"
  },
  {
    "text": "but yes I got caught with my pants down okay",
    "start": "3419000",
    "end": "3426359"
  },
  {
    "text": "um I just quickly show that we can write to any",
    "start": "3426359",
    "end": "3433280"
  },
  {
    "text": "location now which location do we choose underscore underscore underscore",
    "start": "3437520",
    "end": "3443039"
  },
  {
    "text": "underscore Plus 8 let's look at the disassembly whether it's actually",
    "start": "3443039",
    "end": "3448640"
  },
  {
    "text": "true the memory override happens here edx + 8 is the value and edx + 4",
    "start": "3452400",
    "end": "3462559"
  },
  {
    "text": "plus 8 is the location",
    "start": "3462559",
    "end": "3467359"
  },
  {
    "text": "okay so the value is i i i i i and the program will add",
    "start": "3468039",
    "end": "3477000"
  },
  {
    "text": "eight to the underscore underscore underscore underscore down",
    "start": "3477000",
    "end": "3482400"
  },
  {
    "text": "here so we'll not be actually writing to underscore underscore underscore underscore but to underscore underscore underscore Plus 8 which I think is all",
    "start": "3482400",
    "end": "3490359"
  },
  {
    "text": "right to be classified as arbitrary",
    "start": "3490359",
    "end": "3496760"
  },
  {
    "text": "okay now let's hope it doesn't take any unexpected branches again",
    "start": "3500359",
    "end": "3507559"
  },
  {
    "text": "okay here we go ebx is loaded with I made a",
    "start": "3513240",
    "end": "3521640"
  },
  {
    "text": "mistake I told you this was not going to be smooth I promise to be better in the",
    "start": "3522079",
    "end": "3528240"
  },
  {
    "text": "second half if you're still here then okay now let's do it like this",
    "start": "3528240",
    "end": "3538039"
  },
  {
    "text": "okay I'm completely lost we'll eventually get",
    "start": "3557039",
    "end": "3563760"
  },
  {
    "text": "there I mean we still got plenty of time that way I can hide that I don't have enough stuff for the first",
    "start": "3563760",
    "end": "3569720"
  },
  {
    "text": "half the firstes second foures was the value yes",
    "start": "3569720",
    "end": "3575160"
  },
  {
    "text": "and the third byes should",
    "start": "3575160",
    "end": "3579200"
  },
  {
    "text": "be uh it seems to read at it seems to read at this location plus four and plus",
    "start": "3580240",
    "end": "3588039"
  },
  {
    "text": "eight yeah and yeah so let's see what happens here",
    "start": "3588039",
    "end": "3596240"
  },
  {
    "text": "it passes the check concerning the size all right jumps into this",
    "start": "3596240",
    "end": "3602079"
  },
  {
    "text": "part jumps down here does the",
    "start": "3602079",
    "end": "3607520"
  },
  {
    "text": "compare jumps here and edx is not pointing where we",
    "start": "3607520",
    "end": "3614200"
  },
  {
    "text": "expected it to point for some silly",
    "start": "3614200",
    "end": "3618960"
  },
  {
    "text": "reason or we still get the exception",
    "start": "3620079",
    "end": "3624920"
  },
  {
    "text": "okay okay we pass this",
    "start": "3641079",
    "end": "3646319"
  },
  {
    "text": "part we make it believe that the structure was empty",
    "start": "3648880",
    "end": "3655319"
  },
  {
    "text": "jump down",
    "start": "3659680",
    "end": "3662359"
  },
  {
    "text": "here okay I",
    "start": "3664720",
    "end": "3668319"
  },
  {
    "text": "think this is not working at all now um I promise you I'll tell you",
    "start": "3672960",
    "end": "3679839"
  },
  {
    "text": "how this works in the second half um we get an exception",
    "start": "3679839",
    "end": "3686440"
  },
  {
    "text": "it worked during preparation it doesn't work now we all know how computers are all",
    "start": "3686440",
    "end": "3693519"
  },
  {
    "text": "right",
    "start": "3695119",
    "end": "3698119"
  },
  {
    "text": "so I think I explained this before in the debugger and the disassemble what I have in mind with what doesn't work",
    "start": "3700720",
    "end": "3706200"
  },
  {
    "text": "currently we have the buffer which we overrun we write a n bite to the control structure and we control the next buffer",
    "start": "3706200",
    "end": "3712760"
  },
  {
    "text": "as well which leads to to data being read from the next buffer",
    "start": "3712760",
    "end": "3721079"
  },
  {
    "text": "and actually leading to an arbitrary memory",
    "start": "3721079",
    "end": "3724799"
  },
  {
    "text": "override so to sum things up is I feel like a complete cheat right",
    "start": "3729079",
    "end": "3735880"
  },
  {
    "text": "now but I promise I'll do it in the second half all right um we've shown at",
    "start": "3735880",
    "end": "3741279"
  },
  {
    "text": "least for Windows 2k not for B and C that we can overwrite um heat control",
    "start": "3741279",
    "end": "3746520"
  },
  {
    "text": "structures and thus right to an arbitrary location in memory and to sum things up concerning exploits and buff",
    "start": "3746520",
    "end": "3752119"
  },
  {
    "text": "overruns in general is that stack based overflows are slowly being hunted to near extin",
    "start": "3752119",
    "end": "3757400"
  },
  {
    "text": "Extinction and that easy to spot bugs are slowly being weeded out and the hard",
    "start": "3757400",
    "end": "3763000"
  },
  {
    "text": "to spot buxs are the ones that are still left and something that's interesting",
    "start": "3763000",
    "end": "3770000"
  },
  {
    "text": "about heat bugs is that with the advance of object-oriented programming and STL",
    "start": "3770000",
    "end": "3775079"
  },
  {
    "text": "and so on we will be seeing less and less um stack based bugs or stack based",
    "start": "3775079",
    "end": "3781000"
  },
  {
    "text": "overflows because people just don't use the Char buffer 20 anymore but they use some class with an internal buffer where",
    "start": "3781000",
    "end": "3787200"
  },
  {
    "text": "they me copy into or whatever and if we're going to have overflows in in the",
    "start": "3787200",
    "end": "3792480"
  },
  {
    "text": "oop world then it's going to be Heap overrides it's not going to be the stack smash furthermore even in STL and even",
    "start": "3792480",
    "end": "3800279"
  },
  {
    "text": "with um C++ and oop and everything off by ones are possible not necessarily",
    "start": "3800279",
    "end": "3806279"
  },
  {
    "text": "with a null bite but just imagine an iterator going too far and so on so some people claim that bugs will go away with",
    "start": "3806279",
    "end": "3813839"
  },
  {
    "text": "new programming par paradigms but they're here to stay and The elusive",
    "start": "3813839",
    "end": "3819640"
  },
  {
    "text": "nature of Heap overruns will basically well make the tools retina fuzz all the",
    "start": "3819640",
    "end": "3825720"
  },
  {
    "text": "pro scripts and so on Obsolete because the future is heat bugs and they can't be found using stress testing but only",
    "start": "3825720",
    "end": "3832240"
  },
  {
    "text": "with Source or binary analysis reverse Engineers if they don't scrub as I do are at an advantage they can understand",
    "start": "3832240",
    "end": "3838799"
  },
  {
    "text": "and document the compiler if you have a compiler um I don't know whether the",
    "start": "3838799",
    "end": "3844240"
  },
  {
    "text": "vendor of the compiler will give you the source to the Lipsy and the source to the Heap allocation and you can bet that",
    "start": "3844240",
    "end": "3850480"
  },
  {
    "text": "Oracle will not give you the source for their Heap implementation and you can bet that Netscape will not give you the source for their Heap implementation",
    "start": "3850480",
    "end": "3855880"
  },
  {
    "text": "either so unless you're you a bit used to reading disassembly um you don't really know",
    "start": "3855880",
    "end": "3861640"
  },
  {
    "text": "what to do and how to do it furthermore there's a lot of bugs in",
    "start": "3861640",
    "end": "3867119"
  },
  {
    "text": "the compiler themselves which we're dealing with in the future I think if you look at ban C for example we've seen",
    "start": "3867119",
    "end": "3874079"
  },
  {
    "text": "that they need control structures for um controlling their blocks so when you",
    "start": "3874079",
    "end": "3879160"
  },
  {
    "text": "allocate a certain amount of memory they actually need four bytes more because they need the size for the control structure as well now what they do is",
    "start": "3879160",
    "end": "3885559"
  },
  {
    "text": "they take the value of what you put in there the amount of memory you want and then they add the control block size and",
    "start": "3885559",
    "end": "3893839"
  },
  {
    "text": "then they allocate that now assume you request a memory block of a bit like 4",
    "start": "3893839",
    "end": "3900200"
  },
  {
    "text": "GB size minus two they add four it wraps around to positive and they allocate you",
    "start": "3900200",
    "end": "3906960"
  },
  {
    "text": "four bytes and return it and there's no error message so compiler bugs are",
    "start": "3906960",
    "end": "3912480"
  },
  {
    "text": "really going to um screw programmers over badly and especially in the embedded world there's a lot of bad",
    "start": "3912480",
    "end": "3919400"
  },
  {
    "text": "compilers and while we added Java is claimed to be secure but after I've done",
    "start": "3919400",
    "end": "3926119"
  },
  {
    "text": "a survey over buggy compilers during the past few months when it came to C compilers I'm not really sure that the",
    "start": "3926119",
    "end": "3933000"
  },
  {
    "text": "Java run times of the Java compilers are any better and even then if the language is working correctly and has strong type",
    "start": "3933000",
    "end": "3939559"
  },
  {
    "text": "checking and so on there are logic bugs everywhere that can go insanely wrong and programmers don't read",
    "start": "3939559",
    "end": "3945079"
  },
  {
    "text": "specifications a nice example I like to bring up at this point is usually that how many C programmers you know that can",
    "start": "3945079",
    "end": "3951160"
  },
  {
    "text": "answer the following question if you compare a signed to an unsigned value like is the unsigned value a smaller",
    "start": "3951160",
    "end": "3958520"
  },
  {
    "text": "than the signed value B what comparison will the compar like what sign will the",
    "start": "3958520",
    "end": "3964039"
  },
  {
    "text": "comparison have will it be an unsigned or a signed comparison unsigned unsigned unsigned a smaller than signed",
    "start": "3964039",
    "end": "3973960"
  },
  {
    "text": "B had a good chance there now has anyone ever bothered to read the specification",
    "start": "3978119",
    "end": "3984480"
  },
  {
    "text": "what the specification says because it's a clearly defined State no actually I did and the right",
    "start": "3984480",
    "end": "3991200"
  },
  {
    "text": "side of the comparison dictates the sness so unsigned a smaller than signed",
    "start": "3991200",
    "end": "3997240"
  },
  {
    "text": "B will have a different result than signed B greater than unsigned",
    "start": "3997240",
    "end": "4005440"
  },
  {
    "text": "a if you think those bugs are going away with new oop classes you're wrong just",
    "start": "4005440",
    "end": "4011240"
  },
  {
    "text": "plain wrong okay something else that I mentioned is that our heat bugs are not",
    "start": "4011240",
    "end": "4017520"
  },
  {
    "text": "actually taking control over EIP directly anymore and as we see more and",
    "start": "4017520",
    "end": "4023240"
  },
  {
    "text": "more advances towards the prevention of buffer overruns like non-executable Heap Pages stack guard and so on at least to",
    "start": "4023240",
    "end": "4030760"
  },
  {
    "text": "prevent the stack based overflows which execute code and um we have ways of making Pages readable but",
    "start": "4030760",
    "end": "4037720"
  },
  {
    "text": "non-executable we can kiss our share codes goodbye it's just a matter of time but",
    "start": "4037720",
    "end": "4043720"
  },
  {
    "text": "with I64 people people will start making all Heap Pages all stack pages non-executable and any user Supply data",
    "start": "4043720",
    "end": "4050760"
  },
  {
    "text": "will not be able to execute so with a heap bugs we are already demonstrating the next or the future of bugs we're",
    "start": "4050760",
    "end": "4058039"
  },
  {
    "text": "manipulating the internal logic of a program we're manipulating structures it uses to store its own data and then make",
    "start": "4058039",
    "end": "4064400"
  },
  {
    "text": "the program do evil things now the simplest example is overflowing a buffer and right behind your buffer there's a",
    "start": "4064400",
    "end": "4069799"
  },
  {
    "text": "bleen is authenticated that would be the easy way or we do it like this we're manipulating",
    "start": "4069799",
    "end": "4075599"
  },
  {
    "text": "the compiler to do something which we want which is not smashing the stack so",
    "start": "4075599",
    "end": "4081520"
  },
  {
    "text": "we can safely assume that in the future we'll have to have more of a program",
    "start": "4081520",
    "end": "4086720"
  },
  {
    "text": "understanding to actually do anything useful because we're manipulating the way it logic Works we're not just smash the stack put in the Shell Code execute",
    "start": "4086720",
    "end": "4093039"
  },
  {
    "text": "bins H and we're in we'll have to play with how the thing works all right um yeah I I'm trying to",
    "start": "4093039",
    "end": "4101798"
  },
  {
    "text": "brag a bit at the bottom that reverse Engineers are useful but after we've seen how I I'll just skip that part and",
    "start": "4101799",
    "end": "4108199"
  },
  {
    "text": "I think we're pretty much scheduled to have a break right now aren't we right thanks and I'll try to figure",
    "start": "4108199",
    "end": "4116000"
  },
  {
    "text": "out what was went wrong for the second half any questions concerning this so",
    "start": "4116000",
    "end": "4121640"
  },
  {
    "text": "far yes",
    "start": "4121640",
    "end": "4124880"
  },
  {
    "text": "please for what",
    "start": "4127159",
    "end": "4131480"
  },
  {
    "text": "um the question is whether you can scan binary code to find buffer",
    "start": "4138920",
    "end": "4144640"
  },
  {
    "text": "overruns well they they are overruns in a way I mean they're overrunning the MEO buffer so uh yes you can I'm actually",
    "start": "4145759",
    "end": "4152400"
  },
  {
    "text": "holding a training class on that or I held a training class on that on Monday um where basically you analyze the",
    "start": "4152400",
    "end": "4158120"
  },
  {
    "text": "binary and read the disassembly and scan for commonly misused Library functions and how they might override stuff",
    "start": "4158120",
    "end": "4165880"
  },
  {
    "text": "but you cannot simply scan the binary for an arbitrary memory override in general because um there's a lot of",
    "start": "4165880",
    "end": "4172238"
  },
  {
    "text": "writing and reading in an application normally and if you just scan for the instructions overriding arbitrary memory",
    "start": "4172239",
    "end": "4178480"
  },
  {
    "text": "you'll get about every eighth or nth instruction will be one and if you look",
    "start": "4178480",
    "end": "4183798"
  },
  {
    "text": "at the common disassembly consisting of a few million you can grow looking whether you can do anything useful with",
    "start": "4183799",
    "end": "4190000"
  },
  {
    "text": "them any other questions",
    "start": "4190000",
    "end": "4194440"
  },
  {
    "text": "all right then have a good break thanks",
    "start": "4196040",
    "end": "4203960"
  },
  {
    "text": "e",
    "start": "4344159",
    "end": "4347159"
  },
  {
    "text": "e",
    "start": "4374120",
    "end": "4377120"
  },
  {
    "text": "e",
    "start": "4404120",
    "end": "4407120"
  },
  {
    "text": "e e",
    "start": "4434040",
    "end": "4438080"
  },
  {
    "text": "e",
    "start": "4583920",
    "end": "4586920"
  },
  {
    "text": "for",
    "start": "4613840",
    "end": "4616840"
  },
  {
    "text": "e",
    "start": "4643840",
    "end": "4646840"
  },
  {
    "text": "e",
    "start": "4673840",
    "end": "4676840"
  },
  {
    "text": "e",
    "start": "4703760",
    "end": "4706760"
  },
  {
    "text": "e",
    "start": "4733719",
    "end": "4736719"
  },
  {
    "text": "e",
    "start": "4763719",
    "end": "4766719"
  },
  {
    "text": "e",
    "start": "4793639",
    "end": "4796639"
  },
  {
    "text": "e",
    "start": "4823639",
    "end": "4826639"
  },
  {
    "text": "e",
    "start": "4853639",
    "end": "4856639"
  },
  {
    "text": "e",
    "start": "4883560",
    "end": "4886560"
  },
  {
    "text": "e",
    "start": "4913520",
    "end": "4916520"
  },
  {
    "text": "e",
    "start": "4943520",
    "end": "4946520"
  },
  {
    "text": "e",
    "start": "4973440",
    "end": "4976440"
  },
  {
    "text": "e",
    "start": "5003440",
    "end": "5006440"
  },
  {
    "text": "e",
    "start": "5033440",
    "end": "5036440"
  },
  {
    "text": "e",
    "start": "5063320",
    "end": "5066320"
  },
  {
    "text": "e",
    "start": "5093320",
    "end": "5096320"
  },
  {
    "text": "e",
    "start": "5123320",
    "end": "5126320"
  },
  {
    "text": "e",
    "start": "5153239",
    "end": "5156239"
  },
  {
    "text": "e",
    "start": "5183239",
    "end": "5186239"
  },
  {
    "text": "e",
    "start": "5213239",
    "end": "5216239"
  },
  {
    "text": "e",
    "start": "5243119",
    "end": "5246119"
  },
  {
    "text": "e",
    "start": "5273119",
    "end": "5276119"
  },
  {
    "text": "e",
    "start": "5303119",
    "end": "5306119"
  },
  {
    "text": "e",
    "start": "5333040",
    "end": "5336040"
  },
  {
    "text": "e",
    "start": "5363040",
    "end": "5366040"
  },
  {
    "text": "e",
    "start": "5393040",
    "end": "5396040"
  },
  {
    "text": "e",
    "start": "5422960",
    "end": "5425960"
  },
  {
    "text": "e",
    "start": "5452920",
    "end": "5455920"
  },
  {
    "text": "e",
    "start": "5482920",
    "end": "5485920"
  },
  {
    "text": "e",
    "start": "5512840",
    "end": "5515840"
  },
  {
    "text": "e",
    "start": "5542840",
    "end": "5545840"
  },
  {
    "text": "e",
    "start": "5572840",
    "end": "5575840"
  },
  {
    "text": "e",
    "start": "5602760",
    "end": "5605760"
  },
  {
    "text": "e",
    "start": "5632719",
    "end": "5635719"
  },
  {
    "text": "e",
    "start": "5662719",
    "end": "5665719"
  },
  {
    "text": "e",
    "start": "5692639",
    "end": "5695639"
  },
  {
    "text": "e",
    "start": "5722639",
    "end": "5725639"
  },
  {
    "text": "e",
    "start": "5752639",
    "end": "5755639"
  },
  {
    "text": "e",
    "start": "5782560",
    "end": "5785560"
  },
  {
    "text": "e",
    "start": "5812520",
    "end": "5815520"
  },
  {
    "text": "e",
    "start": "5842520",
    "end": "5845520"
  },
  {
    "text": "e",
    "start": "5872440",
    "end": "5875440"
  },
  {
    "text": "e",
    "start": "5902440",
    "end": "5905440"
  },
  {
    "text": "e",
    "start": "5932440",
    "end": "5935440"
  },
  {
    "text": "e",
    "start": "5962360",
    "end": "5965360"
  },
  {
    "text": "e",
    "start": "5992320",
    "end": "5995320"
  },
  {
    "text": "e",
    "start": "6022320",
    "end": "6025320"
  },
  {
    "text": "e",
    "start": "6052239",
    "end": "6055239"
  },
  {
    "text": "e",
    "start": "6082239",
    "end": "6085239"
  },
  {
    "text": "e",
    "start": "6112239",
    "end": "6115239"
  },
  {
    "text": "e",
    "start": "6142159",
    "end": "6145159"
  },
  {
    "text": "e",
    "start": "6172119",
    "end": "6175119"
  },
  {
    "text": "e",
    "start": "6202119",
    "end": "6205119"
  },
  {
    "text": "e",
    "start": "6232040",
    "end": "6235040"
  },
  {
    "text": "e",
    "start": "6262040",
    "end": "6265040"
  },
  {
    "text": "e",
    "start": "6292040",
    "end": "6295040"
  },
  {
    "text": "e",
    "start": "6321960",
    "end": "6324960"
  },
  {
    "text": "e",
    "start": "6351920",
    "end": "6354920"
  },
  {
    "text": "e",
    "start": "6381920",
    "end": "6384920"
  },
  {
    "text": "e",
    "start": "6411840",
    "end": "6414840"
  },
  {
    "text": "e",
    "start": "6441840",
    "end": "6444840"
  },
  {
    "text": "e",
    "start": "6471840",
    "end": "6474840"
  },
  {
    "text": "e",
    "start": "6501760",
    "end": "6504760"
  },
  {
    "text": "e",
    "start": "6531719",
    "end": "6534719"
  },
  {
    "text": "e",
    "start": "6561719",
    "end": "6564719"
  },
  {
    "text": "e",
    "start": "6591639",
    "end": "6594639"
  },
  {
    "text": "e",
    "start": "6621639",
    "end": "6624639"
  },
  {
    "text": "e",
    "start": "6651639",
    "end": "6654639"
  },
  {
    "text": "e",
    "start": "6681560",
    "end": "6684560"
  },
  {
    "text": "e",
    "start": "6711520",
    "end": "6714520"
  },
  {
    "text": "e",
    "start": "6741520",
    "end": "6744520"
  },
  {
    "text": "e",
    "start": "6771440",
    "end": "6774440"
  },
  {
    "text": "e",
    "start": "6801440",
    "end": "6804440"
  },
  {
    "text": "e",
    "start": "6831440",
    "end": "6834440"
  },
  {
    "text": "e",
    "start": "6861360",
    "end": "6864360"
  },
  {
    "text": "e",
    "start": "6891320",
    "end": "6894320"
  },
  {
    "text": "e",
    "start": "6921320",
    "end": "6924320"
  },
  {
    "text": "e",
    "start": "6951239",
    "end": "6954239"
  },
  {
    "text": "e",
    "start": "6981239",
    "end": "6984239"
  },
  {
    "text": "e",
    "start": "7011239",
    "end": "7014239"
  },
  {
    "text": "e",
    "start": "7041159",
    "end": "7044159"
  },
  {
    "text": "e",
    "start": "7071119",
    "end": "7074119"
  },
  {
    "text": "e",
    "start": "7101119",
    "end": "7104119"
  },
  {
    "text": "e",
    "start": "7131040",
    "end": "7134040"
  },
  {
    "text": "e",
    "start": "7161040",
    "end": "7164040"
  },
  {
    "text": "e",
    "start": "7191040",
    "end": "7194040"
  },
  {
    "text": "e",
    "start": "7220960",
    "end": "7223960"
  },
  {
    "text": "e",
    "start": "7250920",
    "end": "7253920"
  },
  {
    "text": "e",
    "start": "7280920",
    "end": "7283920"
  },
  {
    "text": "e for",
    "start": "7310840",
    "end": "7314880"
  }
]