[
  {
    "start": "0",
    "end": "72000"
  },
  {
    "text": "so uh my name is nishad her one second we can so and this is",
    "start": "120",
    "end": "8000"
  },
  {
    "text": "Anders and um I'm not even going to try to pronounce his last name because I'm",
    "start": "8000",
    "end": "14080"
  },
  {
    "text": "pretty sure that I'll get it wrong but um so what we're going to talk about",
    "start": "14080",
    "end": "19600"
  },
  {
    "text": "today is actually using the hardware feature that has been present in the Intel CPUs or compatible CPUs for quite",
    "start": "19600",
    "end": "26800"
  },
  {
    "text": "some time but in a way that was not necessarily um something that it was",
    "start": "26800",
    "end": "32640"
  },
  {
    "text": "intended for we we we're trying to talk about how we can use it for better security",
    "start": "32640",
    "end": "39160"
  },
  {
    "text": "outcomes just give a second rather than um using it for what it was already",
    "start": "39160",
    "end": "45440"
  },
  {
    "text": "intended for which was basically to collect low level performance statistics on software that's running on the",
    "start": "45440",
    "end": "51359"
  },
  {
    "text": "processes so um you want to introduce yourself you",
    "start": "51359",
    "end": "57039"
  },
  {
    "text": "not I think introduction slides well okay fair enough um if you want to just",
    "start": "57039",
    "end": "63399"
  },
  {
    "text": "um yeah we have some oh okay makes it easy",
    "start": "63399",
    "end": "70640"
  },
  {
    "text": "all right so like um what we'll do is I'll give",
    "start": "70640",
    "end": "77119"
  },
  {
    "start": "72000",
    "end": "207000"
  },
  {
    "text": "you a quick rundown of what we're going to like some of the aspects that we'll be looking at so first of all what we're",
    "start": "77119",
    "end": "82960"
  },
  {
    "text": "going to do is we're going to give you a brief introduction to the hardware performing performance monitoring",
    "start": "82960",
    "end": "88240"
  },
  {
    "text": "counters on the Intel CPUs well I'm going to use the term Intel CPUs for the architecture because I'm",
    "start": "88240",
    "end": "94759"
  },
  {
    "text": "like that comes naturally but U it's the same with compatible CPUs as well to a large degree and uh we're going to talk",
    "start": "94759",
    "end": "101960"
  },
  {
    "text": "about how these performance monitoring counters can be used as a detection or",
    "start": "101960",
    "end": "107680"
  },
  {
    "text": "mitigation method for return oriented programming and here we'll we won't be",
    "start": "107680",
    "end": "114159"
  },
  {
    "text": "really talking about what we have researched into it per se as much as we'll be pointing out some of the things",
    "start": "114159",
    "end": "119360"
  },
  {
    "text": "that people have done with this and uh we will be talking about using the",
    "start": "119360",
    "end": "124560"
  },
  {
    "text": "performance monitoring counters to detect and mitigate and attack a lowlevel attack like raw hammer and uh",
    "start": "124560",
    "end": "131440"
  },
  {
    "text": "we will also briefly discuss uh what we can do against root kits and um also",
    "start": "131440",
    "end": "139080"
  },
  {
    "text": "last we'll be looking at how we can use a performance mod en counters to basically detect and mitigate cash side",
    "start": "139080",
    "end": "148360"
  },
  {
    "text": "attacks so so um so now to give you guys quick background I'm working as a principal malware technologist at pois",
    "start": "148560",
    "end": "156800"
  },
  {
    "text": "and um I've been involved in reest engineering and security for a very long time and um I mean",
    "start": "156800",
    "end": "165879"
  },
  {
    "text": "yeah less the rest is less important really right um I'm Anders and I'm the",
    "start": "165879",
    "end": "173200"
  },
  {
    "text": "vice president of engineering and co-founder of protect software gmbh I have been involved in innovation",
    "start": "173200",
    "end": "180040"
  },
  {
    "text": "research and leading development team leading development teams um I'm a bit of a weo in this",
    "start": "180040",
    "end": "188280"
  },
  {
    "text": "business I have a master's degree in E Eon economics and malware has been a hobby",
    "start": "188280",
    "end": "193640"
  },
  {
    "text": "for me since ' 92 so I have a lot of experience with it",
    "start": "193640",
    "end": "199159"
  },
  {
    "text": "um so this is why malware for me is listed as a hobby and not uh as a job so",
    "start": "199159",
    "end": "207400"
  },
  {
    "start": "207000",
    "end": "453000"
  },
  {
    "text": "more of the stories that hopefully we've done some conven that we may actually know what we're talking about to some",
    "start": "207400",
    "end": "213879"
  },
  {
    "text": "degree okay so uh first we are going to discuss um how and the why and where",
    "start": "213879",
    "end": "221080"
  },
  {
    "text": "these performance counters really come from right so to get a better understanding of the",
    "start": "221080",
    "end": "229120"
  },
  {
    "text": "Fe the features and what is possible there the Integrity differences between",
    "start": "229120",
    "end": "234480"
  },
  {
    "text": "different core architectures different versions and all these things really really you like the best source of",
    "start": "234480",
    "end": "240879"
  },
  {
    "text": "information for this is the Intel manuals and um basically these days they",
    "start": "240879",
    "end": "249159"
  },
  {
    "text": "pretty much document almost all of it and um it's a very good source source of",
    "start": "249159",
    "end": "255239"
  },
  {
    "text": "information when you want to start implementing some of these things and um it's only 350 pages so you know it's a",
    "start": "255239",
    "end": "263080"
  },
  {
    "text": "breeze so um these features have been",
    "start": "263080",
    "end": "268120"
  },
  {
    "text": "around in the in x36 x64 compatible CPUs since the 1990s uh the mid '90s and um",
    "start": "268120",
    "end": "277400"
  },
  {
    "text": "the early Intel Pentium processes did have an implementation of it which was",
    "start": "277400",
    "end": "282720"
  },
  {
    "text": "docu undocumented at the time and uh T Madison basically published his um his",
    "start": "282720",
    "end": "290280"
  },
  {
    "text": "insights into how these things work by reverse engineering a piece of oftware that Intel releas called Eon and um that",
    "start": "290280",
    "end": "297880"
  },
  {
    "text": "explained how this work in the Intel pendium Intel pendium processes and uh",
    "start": "297880",
    "end": "303880"
  },
  {
    "text": "with Intel pendium MMX technology so the p-55 C Core the in Intel basically came",
    "start": "303880",
    "end": "312000"
  },
  {
    "text": "out and started offering it as a standard architectural feature and um",
    "start": "312000",
    "end": "317759"
  },
  {
    "text": "with the Intel um PM implementation there were two",
    "start": "317759",
    "end": "322800"
  },
  {
    "text": "performance monitoring counters but um they were implemented as machines model",
    "start": "322800",
    "end": "328319"
  },
  {
    "text": "specific registered or MSR and um they were both readable with Rd",
    "start": "328319",
    "end": "333560"
  },
  {
    "text": "MSR instruction but only in ring zero now when when it came to the Pentium MMX",
    "start": "333560",
    "end": "340840"
  },
  {
    "text": "the p55 C Intel basically in introduced a new instruction called rpmc which",
    "start": "340840",
    "end": "347520"
  },
  {
    "text": "allowed you to read this performance wondering counters and you could also do it from ring three or any other ring",
    "start": "347520",
    "end": "353000"
  },
  {
    "text": "basically and uh also with the p55 c they introduced rdtsc which is basically",
    "start": "353000",
    "end": "359720"
  },
  {
    "text": "read timestamp counter which does provide very high resolution timestamping information for the Intel",
    "start": "359720",
    "end": "367240"
  },
  {
    "text": "processes and um so the evolution from there gets um it gets bit complicated",
    "start": "367360",
    "end": "373199"
  },
  {
    "text": "because they change inel change the way these features are implemented like to",
    "start": "373199",
    "end": "379000"
  },
  {
    "text": "what degree these features are implemented and so on so with the Intel P6 based processes like the penum pro",
    "start": "379000",
    "end": "386560"
  },
  {
    "text": "the penum 2 the penum 2 zons the penum 3s so on these in these PM P6 based um",
    "start": "386560",
    "end": "395240"
  },
  {
    "text": "architectures you have two 40 bit pmcs and on the Intel net netb based",
    "start": "395240",
    "end": "402160"
  },
  {
    "text": "architectures you get 18 40 bit pmcs and then at at some point Intel basically um",
    "start": "402160",
    "end": "410599"
  },
  {
    "text": "change to have fixed function and programmable function pmcs as well now",
    "start": "410599",
    "end": "416039"
  },
  {
    "text": "on the atom you get two programmable uh PMC which basically can be programmed to",
    "start": "416039",
    "end": "421360"
  },
  {
    "text": "monitor different performance events and um you get three fixed function counters so there is some variation in",
    "start": "421360",
    "end": "429280"
  },
  {
    "text": "the Silicon implementation of these things so this feature set is not consistent across all the Intel Hardware",
    "start": "429280",
    "end": "435639"
  },
  {
    "text": "so when you're implementing some of these things you need to take into account which actual Hardware you're",
    "start": "435639",
    "end": "440680"
  },
  {
    "text": "running on which CPU you're running on and then query the CPU to see what features are available to you and using",
    "start": "440680",
    "end": "446840"
  },
  {
    "text": "start using the features the performance monitoring features that are present in that",
    "start": "446840",
    "end": "452360"
  },
  {
    "text": "CPU so in general the performance monitoring counters can monitor two main",
    "start": "452360",
    "end": "460520"
  },
  {
    "start": "453000",
    "end": "608000"
  },
  {
    "text": "categories of things in terms of uh the performance events as well as event",
    "start": "460520",
    "end": "466400"
  },
  {
    "text": "duration so in terms of events there's like these days there's so many events so you really need to look in the manual",
    "start": "466400",
    "end": "472800"
  },
  {
    "text": "for description of all events that are available for any microarchitecture that you're interested in um but in general",
    "start": "472800",
    "end": "479560"
  },
  {
    "text": "what Intel has done these days is that there are there is a set of performance events that can be used with pmcs uh",
    "start": "479560",
    "end": "486639"
  },
  {
    "text": "that are considered architecture elements so these are essentially part of the architecture and not considered",
    "start": "486639",
    "end": "491960"
  },
  {
    "text": "model specific anymore so the idea is that the architectural events are meant",
    "start": "491960",
    "end": "497400"
  },
  {
    "text": "to be a lot more consistent than model specific events but even architectural",
    "start": "497400",
    "end": "502680"
  },
  {
    "text": "events there's um like Intel does give you a mechanism to see which",
    "start": "502680",
    "end": "508960"
  },
  {
    "text": "architecture events are available on a given microarchitecture so it is Al it",
    "start": "508960",
    "end": "515279"
  },
  {
    "text": "is not still a solid Target it's still moving Target because inel keeps on adding to this there's like uh I think",
    "start": "515279",
    "end": "521640"
  },
  {
    "text": "the current PM performance monitoring version is like version four so there there is",
    "start": "521640",
    "end": "527839"
  },
  {
    "text": "variation and um with the new CPUs you have a lot of model specific performance",
    "start": "527839",
    "end": "534720"
  },
  {
    "text": "events that you can that you can uh Monitor and some of these things are really cool like some of these things are really really low level of cool",
    "start": "534720",
    "end": "540279"
  },
  {
    "text": "stuff like um for example one of the one of the useful ones is like um Branch",
    "start": "540279",
    "end": "545640"
  },
  {
    "text": "misprediction so where the branch predictor fails to predict branches that you can get a Performance Event based on",
    "start": "545640",
    "end": "551480"
  },
  {
    "text": "that so things like this now what other things are available you can have number",
    "start": "551480",
    "end": "556560"
  },
  {
    "text": "of instructions decoded the number of in interrupts received um number of cash loads number of cash",
    "start": "556560",
    "end": "564279"
  },
  {
    "text": "misses and all these things available to you and these things are not really available by any other means to directly",
    "start": "564279",
    "end": "571519"
  },
  {
    "text": "have this information without using the CPU performance counters from St software that is running on the system",
    "start": "571519",
    "end": "579160"
  },
  {
    "text": "um and another really cool feature is that you can actually have a performance monitoring interrupt that will be",
    "start": "579160",
    "end": "585120"
  },
  {
    "text": "triggered when a certain condition is met when it comes to a given Performance Event so you can basically set up a",
    "start": "585120",
    "end": "592240"
  },
  {
    "text": "count and say I want the CPU to be interrupted every time n number of performance countering monitoring events",
    "start": "592240",
    "end": "599160"
  },
  {
    "text": "of this description has taken place so for our purposes this the PMI mechanism",
    "start": "599160",
    "end": "604800"
  },
  {
    "text": "is actually quite useful so just quickly the relevant",
    "start": "604800",
    "end": "611000"
  },
  {
    "start": "608000",
    "end": "793000"
  },
  {
    "text": "control registers for setting this up is cr0 and cr4 I'm not going to go into the details of it it's in the manuals it's",
    "start": "611000",
    "end": "618320"
  },
  {
    "text": "just a screenshot from the manuals and quickly the C4",
    "start": "618320",
    "end": "624560"
  },
  {
    "text": "contains like basically the protection enable flag and um",
    "start": "624560",
    "end": "630399"
  },
  {
    "text": "basically that allows us to um Set set set the processor",
    "start": "630399",
    "end": "636880"
  },
  {
    "text": "modes and um in in basically the protected mode the cr4 contains the bits",
    "start": "636880",
    "end": "646360"
  },
  {
    "text": "that to enable the performance monitoring events so the bit8 of the cr4 which enables rdpc instruction and um",
    "start": "646360",
    "end": "654760"
  },
  {
    "text": "this basically means that this instruction is available at any protection level you can change this bit and you can make sure you can make it",
    "start": "654760",
    "end": "661440"
  },
  {
    "text": "such that if and if it is used in a non-privileged level say from anything under CPL Z you will basically get a",
    "start": "661440",
    "end": "669240"
  },
  {
    "text": "fault and that can be tracked to see if rpmc was used in by unpr software so so",
    "start": "669240",
    "end": "676079"
  },
  {
    "text": "this is usually like if you set this up you can basically Define how rpmc",
    "start": "676079",
    "end": "681320"
  },
  {
    "text": "behaves and you can use it for various different things and uh the time stamp kind of disabl bit is basically a that",
    "start": "681320",
    "end": "689639"
  },
  {
    "text": "is ex that limits how rdtsc instruction can be used and by using this we can",
    "start": "689639",
    "end": "696959"
  },
  {
    "text": "again receive a for when rtsc is used and basically intercept it and do things",
    "start": "696959",
    "end": "702000"
  },
  {
    "text": "so that becomes useful as well so this is briefly this is",
    "start": "702000",
    "end": "707160"
  },
  {
    "text": "description of the rpmc instruction and um do you want to go into it or shall we",
    "start": "707160",
    "end": "714320"
  },
  {
    "text": "just um refer to the manual yeah refer to the manual okay because we going to PR material to col so we're not going to",
    "start": "714320",
    "end": "720560"
  },
  {
    "text": "get into the specifics of using that apmc instruction but I'll quickly say um so basically it's it's a simple CPU",
    "start": "720560",
    "end": "727639"
  },
  {
    "text": "instruction where you basically type which monitor that you want to read and it'll give you the the count in that",
    "start": "727639",
    "end": "733199"
  },
  {
    "text": "monitor counter so it's a fairly use easy instruction and then there's um there are certain things like um high",
    "start": "733199",
    "end": "739560"
  },
  {
    "text": "resolution reads low resolution reads and all that but I mean all this information is in the manual I'm sorry",
    "start": "739560",
    "end": "744880"
  },
  {
    "text": "that we can't go to it because we want to make sure that we cover pretty much um all the stuff that we have to",
    "start": "744880",
    "end": "750800"
  },
  {
    "text": "cover so um basically like I said before it's B by an index and um there slight",
    "start": "750800",
    "end": "757880"
  },
  {
    "text": "differences between how the results are returned in 64-bit mode and 32-bit mode but um yeah just uh everything is",
    "start": "757880",
    "end": "764920"
  },
  {
    "text": "basically the manuals and rdtsc is basically there's no indexing of anything rdtsc is to read the time stamp",
    "start": "764920",
    "end": "772399"
  },
  {
    "text": "counters so you call the instruction and the results are returned in edfx and um again 64 bit it's basically",
    "start": "772399",
    "end": "781519"
  },
  {
    "text": "returning the same result but in a slightly different register",
    "start": "781519",
    "end": "786839"
  },
  {
    "text": "format so so like this yeah okay um",
    "start": "788800",
    "end": "795920"
  },
  {
    "start": "793000",
    "end": "889000"
  },
  {
    "text": "so now going back to figuring out what PMC information is available to us",
    "start": "795920",
    "end": "803399"
  },
  {
    "text": "on a given micro architecture uh we can use a CPU ID instruction and uh CPU ID",
    "start": "803399",
    "end": "809480"
  },
  {
    "text": "instruction provides different leaves that give you different information about the uh the process so this is um",
    "start": "809480",
    "end": "816279"
  },
  {
    "text": "the leaf oxa and um this is how what basic what the basic information that they return",
    "start": "816279",
    "end": "823040"
  },
  {
    "text": "in terms of all the different things related to the performance monitoring and again um you can go and have a look",
    "start": "823040",
    "end": "831519"
  },
  {
    "text": "at the manual and it'll give you a clear idea of what information you can get and",
    "start": "831519",
    "end": "836959"
  },
  {
    "text": "how you can get it and how you can determine which events are supported and how you can use",
    "start": "836959",
    "end": "844120"
  },
  {
    "text": "it so um the specific part of the manuals for this particular information",
    "start": "844120",
    "end": "850199"
  },
  {
    "text": "uh in terms of the monitoring events themselves is in chapter 19 performance monitoring events in the volume three",
    "start": "850199",
    "end": "856279"
  },
  {
    "text": "which is a system programming guide and um there's they basically document um",
    "start": "856279",
    "end": "862279"
  },
  {
    "text": "all the events that are available so there's massive tables of all events and uh listings of it so uh like",
    "start": "862279",
    "end": "869759"
  },
  {
    "text": "unfortunately in the manuals they don't really go into the specificities of each of the",
    "start": "869759",
    "end": "875600"
  },
  {
    "text": "events they just give you a short enough description and that should give you enough information to make an inference",
    "start": "875600",
    "end": "881360"
  },
  {
    "text": "as to what it is doing and how it and then work on that and see what is useful",
    "start": "881360",
    "end": "888399"
  },
  {
    "text": "for okay so um in terms of how this all comes together in a runtime setting is",
    "start": "888399",
    "end": "896040"
  },
  {
    "start": "889000",
    "end": "1024000"
  },
  {
    "text": "uh when after the CPU set after the CPU is reset um the all all the programming counters",
    "start": "896040",
    "end": "903160"
  },
  {
    "text": "are basically um reset to zero and uh",
    "start": "903160",
    "end": "908759"
  },
  {
    "text": "all the programming counters are disabled by control regist being disabled and cleared and reset to zero",
    "start": "908759",
    "end": "915279"
  },
  {
    "text": "and um so this is the kind of state that the CPU is in after it reset so to set",
    "start": "915279",
    "end": "920720"
  },
  {
    "text": "it up to set up the pmcs to record events we need to take certain steps so",
    "start": "920720",
    "end": "926120"
  },
  {
    "text": "I'll quickly run on to the steps so you get a rough idea of the workflow so basically to setting up for to set up",
    "start": "926120",
    "end": "932079"
  },
  {
    "text": "pmc's record Events first of all we can either um we can um either like um",
    "start": "932079",
    "end": "940639"
  },
  {
    "text": "disable all counting or selectively reset the counters by selecting the",
    "start": "940639",
    "end": "946319"
  },
  {
    "text": "control register to disable the particular counter so basically you can",
    "start": "946319",
    "end": "952120"
  },
  {
    "text": "um do this by setting i32 per Global control MSR to zero or set individual",
    "start": "952120",
    "end": "960440"
  },
  {
    "text": "event selectors for each register so so for the performance counters you get the event selector and the event counters so",
    "start": "960440",
    "end": "966120"
  },
  {
    "text": "by controlling the event event selector by setting it to zero you can disable the counting and um basically if you",
    "start": "966120",
    "end": "975199"
  },
  {
    "text": "like uh if you're using um the the the the technique or the method I um was",
    "start": "975199",
    "end": "982360"
  },
  {
    "text": "describing before where the CPU is interrupted when certain amount of performance events have been generated",
    "start": "982360",
    "end": "989639"
  },
  {
    "text": "that is they call it the PBS which is a position event based sampling so to do",
    "start": "989639",
    "end": "996199"
  },
  {
    "text": "PBS we basically set a um so for each",
    "start": "996199",
    "end": "1002120"
  },
  {
    "text": "PMC register performance control contr register that we want to use we basically set the number of events as a",
    "start": "1002120",
    "end": "1009399"
  },
  {
    "text": "negative value after which we need the interrupt to occur so the interrupt occurs in overflow so if you set a",
    "start": "1009399",
    "end": "1016199"
  },
  {
    "text": "negative value after that many number of events after the when the register turns to zero you'll get an",
    "start": "1016199",
    "end": "1023880"
  },
  {
    "start": "1024000",
    "end": "1096000"
  },
  {
    "text": "interrupt so um basically that's a performance monitoring interrupt so to",
    "start": "1024000",
    "end": "1029400"
  },
  {
    "text": "use the PBS we have to hook the PMI interrupt and set up our own ISR",
    "start": "1029400",
    "end": "1035760"
  },
  {
    "text": "interrup service routine so like most operating systems will provide you the",
    "start": "1035760",
    "end": "1041160"
  },
  {
    "text": "functionality to basically set up your own ISR and um in Windows there's undent",
    "start": "1041160",
    "end": "1047798"
  },
  {
    "text": "H function and that how function can be used to basically um set up the is",
    "start": "1047799",
    "end": "1055520"
  },
  {
    "text": "BBS and uh if you wanted to do it bare metal um you can basically set up the",
    "start": "1055520",
    "end": "1061720"
  },
  {
    "text": "appropriate um local Vector table entry in the Epic and um hook the IDT entry",
    "start": "1061720",
    "end": "1068080"
  },
  {
    "text": "for the what you have set up in the Epic already and um in Windows the ISR uh",
    "start": "1068080",
    "end": "1076600"
  },
  {
    "text": "for the there's a very specific is R for the PMI event which is a HP P interrupt",
    "start": "1076600",
    "end": "1082520"
  },
  {
    "text": "so uh technically you can use this to maybe Brute Force the ISR that is",
    "start": "1082520",
    "end": "1090400"
  },
  {
    "text": "actually mapped for this particular interrup because you know what the OS likes to set it",
    "start": "1090400",
    "end": "1096080"
  },
  {
    "start": "1096000",
    "end": "1183000"
  },
  {
    "text": "to so once you have if you use PBS if you have sub ISR now to start recording",
    "start": "1096080",
    "end": "1103120"
  },
  {
    "text": "events all you need to do is that for each performance monitoring counter there's um two registers one is the",
    "start": "1103120",
    "end": "1109320"
  },
  {
    "text": "event selector and one is the count itself so basically you need to set up the performance um event selector for",
    "start": "1109320",
    "end": "1116440"
  },
  {
    "text": "the relevant counter and um this can be set up to instruct the CPU that which",
    "start": "1116440",
    "end": "1123159"
  },
  {
    "text": "event which type of events you want to monitor with this particular counter and um basically it can be so you you have",
    "start": "1123159",
    "end": "1131200"
  },
  {
    "text": "what is called an event select and Unit mask and this is all documented in the int documentation so for each event you",
    "start": "1131200",
    "end": "1137640"
  },
  {
    "text": "figure out what M you want and what what um event SEL what the event select event",
    "start": "1137640",
    "end": "1143280"
  },
  {
    "text": "ID and then you set it up and um that's how you set up the BMC to detect the",
    "start": "1143280",
    "end": "1149080"
  },
  {
    "text": "event that you want and uh to start recording events once the event select is set up you have",
    "start": "1149080",
    "end": "1155880"
  },
  {
    "text": "to set up the the enable bit for that particular event select and then you have also make sure that the first",
    "start": "1155880",
    "end": "1161640"
  },
  {
    "text": "Global control is enabled and when you're done recording events you set the per Global control to",
    "start": "1161640",
    "end": "1167679"
  },
  {
    "text": "zero so the performance colle EV turn to zero and all the PMC counter registers",
    "start": "1167679",
    "end": "1174000"
  },
  {
    "text": "you can basically reset them and um basically you also need to clean up the ISR that you have set up if you're using",
    "start": "1174000",
    "end": "1182240"
  },
  {
    "text": "PBS so how well does the pmcs perform I mean",
    "start": "1182240",
    "end": "1188400"
  },
  {
    "start": "1183000",
    "end": "1286000"
  },
  {
    "text": "like clearly it's quite powerful uh what is the performance impact well um using",
    "start": "1188400",
    "end": "1194880"
  },
  {
    "text": "this mechanism is virtually free really because it's implemented in silic and um other than in latencies and",
    "start": "1194880",
    "end": "1202559"
  },
  {
    "text": "things like that it is largely well for lack of better word",
    "start": "1202559",
    "end": "1209320"
  },
  {
    "text": "free really um there are I mean there are obviously instruction timings and whatnot that come into play like for",
    "start": "1209320",
    "end": "1215640"
  },
  {
    "text": "example on some processes doing a 40 bit fast read of a counter is actually",
    "start": "1215640",
    "end": "1221080"
  },
  {
    "text": "faster than doing a 48 bit read but I mean they're very minimal performance impact in terms of actually using it in",
    "start": "1221080",
    "end": "1228679"
  },
  {
    "text": "real life scenarios um I mean obviously if you were ping it like excessively",
    "start": "1228679",
    "end": "1234520"
  },
  {
    "text": "it'll compare to what the compared to what else that you're doing it will be",
    "start": "1234520",
    "end": "1239679"
  },
  {
    "text": "um it will have an impact but realistically for real use real life use cases it is quite low cost depending on",
    "start": "1239679",
    "end": "1247360"
  },
  {
    "text": "how you uh depending on how you go about doing things so it can be free almost",
    "start": "1247360",
    "end": "1253840"
  },
  {
    "text": "and uh with the interrupts you can get the incidence count obviously and you can also see the duration",
    "start": "1253840",
    "end": "1259799"
  },
  {
    "text": "between two events if you wanted to and um so in terms of the cost of using the",
    "start": "1259799",
    "end": "1266360"
  },
  {
    "text": "PBS system the user mode cost of rece",
    "start": "1266360",
    "end": "1272440"
  },
  {
    "text": "receiving this interrupt could be like you know 500 NS plus and the",
    "start": "1272440",
    "end": "1277720"
  },
  {
    "text": "event processing cost as in like your decision making after you have seen this event is on top of",
    "start": "1277720",
    "end": "1285039"
  },
  {
    "start": "1286000",
    "end": "1408000"
  },
  {
    "text": "that so you're okay so um we have different incidents count for different",
    "start": "1286440",
    "end": "1293240"
  },
  {
    "text": "type of of events so we what we did we time for about 30 seconds of different",
    "start": "1293240",
    "end": "1298799"
  },
  {
    "text": "kinds of activities and if you use all Micro Ops counter you get billions so",
    "start": "1298799",
    "end": "1307600"
  },
  {
    "text": "doing an interrupt on every one of these will surely slow you down um if you take",
    "start": "1307600",
    "end": "1313559"
  },
  {
    "text": "something like return misses that is when the return instruction is falsely predicted Ed by the",
    "start": "1313559",
    "end": "1319600"
  },
  {
    "text": "CPU then you get about 400,000 30 seconds and this what we tested was in a",
    "start": "1319600",
    "end": "1326200"
  },
  {
    "text": "bad case scenario where we force the CPU to do task switching task switching",
    "start": "1326200",
    "end": "1331679"
  },
  {
    "text": "causes return Miss misses because the internal U Shadow",
    "start": "1331679",
    "end": "1337279"
  },
  {
    "text": "stack um is invalidated when you switch to another task obviously the list of",
    "start": "1337279",
    "end": "1342679"
  },
  {
    "text": "returns that are supposed to take and is no longer value from the other task so",
    "start": "1342679",
    "end": "1348120"
  },
  {
    "text": "it's not too bad return misses um another particular event that",
    "start": "1348120",
    "end": "1353400"
  },
  {
    "text": "we think are particularly interesting is last level cast bous uh this is when the",
    "start": "1353400",
    "end": "1360279"
  },
  {
    "text": "cast uh memory access is not found in the last level of caching typically",
    "start": "1360279",
    "end": "1365520"
  },
  {
    "text": "level three but in some CPUs it could be level two you",
    "start": "1365520",
    "end": "1371480"
  },
  {
    "text": "get around 10 to the 9 events if you're row hammering if you your computer is",
    "start": "1371480",
    "end": "1379400"
  },
  {
    "text": "Idle we are talking about 100,000 so there is no such thing as",
    "start": "1379400",
    "end": "1385080"
  },
  {
    "text": "free lunch you can't call the interrupt on every event but you can use the",
    "start": "1385080",
    "end": "1393240"
  },
  {
    "text": "interrupt accordingly to to the event you're actually loging to get more",
    "start": "1393360",
    "end": "1398480"
  },
  {
    "text": "information so so using interrupt on every event is unlikely to be",
    "start": "1398480",
    "end": "1404200"
  },
  {
    "text": "a reasonable strategy",
    "start": "1404200",
    "end": "1408840"
  },
  {
    "start": "1408000",
    "end": "1581000"
  },
  {
    "text": "um can I take this um okay so so um so to minimize um the performance penalties",
    "start": "1410080",
    "end": "1415960"
  },
  {
    "text": "that we are talking about um so we here are some ideas in terms of",
    "start": "1415960",
    "end": "1422360"
  },
  {
    "text": "when you put some of these things together how we can minimize the performance impact of using these things",
    "start": "1422360",
    "end": "1427440"
  },
  {
    "text": "um so basically we can use uh probability probabilistic detection and",
    "start": "1427440",
    "end": "1433080"
  },
  {
    "text": "mitigation and um basically use the trigger count on the interrupt rather than counting every event and um",
    "start": "1433080",
    "end": "1441320"
  },
  {
    "text": "basically that way you you the actual processing cost will be basically",
    "start": "1441320",
    "end": "1446440"
  },
  {
    "text": "segmented into the number of event Parcels that you're discussing and um we",
    "start": "1446440",
    "end": "1451919"
  },
  {
    "text": "can also limit this to particular CPU ring levels so like the ring zero or",
    "start": "1451919",
    "end": "1457559"
  },
  {
    "text": "ring three between unprivileged and privilege code so by limiting this scope we can basically limit the number of events and therefore reduce the",
    "start": "1457559",
    "end": "1464960"
  },
  {
    "text": "performance penalties and uh we can also do this on a process specific level so",
    "start": "1464960",
    "end": "1470640"
  },
  {
    "text": "we can basically use this to only monitor the cord execution statistics",
    "start": "1470640",
    "end": "1477440"
  },
  {
    "text": "generated when a certain process is a current process that is active so this could be used as well for only like high",
    "start": "1477440",
    "end": "1484840"
  },
  {
    "text": "like high impact processes and uh you can also make you can also set",
    "start": "1484840",
    "end": "1491720"
  },
  {
    "text": "set this up so that it can be evaluated or triggered only at certain points in",
    "start": "1491720",
    "end": "1497720"
  },
  {
    "text": "the systems operation not all the time and um you can also add things in",
    "start": "1497720",
    "end": "1503080"
  },
  {
    "text": "compile time that basically allows you to generate statistics on what those things you added in the compile time",
    "start": "1503080",
    "end": "1509279"
  },
  {
    "text": "generated so this is also a good an interesting way to start using this in a",
    "start": "1509279",
    "end": "1515480"
  },
  {
    "text": "in a in a more um in a more performance wise acceptable fashion like",
    "start": "1515480",
    "end": "1522120"
  },
  {
    "text": "the idea is that rather than looking for something that's already happening you can you can instrument the program and",
    "start": "1522120",
    "end": "1528320"
  },
  {
    "text": "compile time so that the generated in code will be generating events that are visible with pmc's that you can look for",
    "start": "1528320",
    "end": "1535120"
  },
  {
    "text": "them and um in runtime we can do it by installing type of instrumentation or",
    "start": "1535120",
    "end": "1542240"
  },
  {
    "text": "hooks at certain points in the O functional functioning and we can start we can evaluate at those certain points",
    "start": "1542240",
    "end": "1549440"
  },
  {
    "text": "and um so like um generally when you're using",
    "start": "1549440",
    "end": "1555360"
  },
  {
    "text": "generally when you're using um like um processing that is uh that is costly it",
    "start": "1555360",
    "end": "1562600"
  },
  {
    "text": "is better to do that on rarer events rather than on more frequent events",
    "start": "1562600",
    "end": "1568520"
  },
  {
    "text": "obviously okay I just wanted to say that we will return to the topics in this",
    "start": "1568520",
    "end": "1573919"
  },
  {
    "text": "slide again and again over the rest of this talk so if you remember one slide",
    "start": "1573919",
    "end": "1579039"
  },
  {
    "text": "this one is it okay so um basically we're going to",
    "start": "1579039",
    "end": "1585559"
  },
  {
    "start": "1581000",
    "end": "1668000"
  },
  {
    "text": "have quickly briefly look at um what what kind of r mitigations that you can be that can be used and um to a give an",
    "start": "1585559",
    "end": "1593520"
  },
  {
    "text": "idea of R I don't really want to get into this too much but I mean I'm sure you guys are familiar with Rob so Rob is",
    "start": "1593520",
    "end": "1599279"
  },
  {
    "text": "generally basically generalized return to LIC I mean you know like we didn't have Rob when we were growing up it it",
    "start": "1599279",
    "end": "1605960"
  },
  {
    "text": "used to be called liy and you know Dr is more generalized version of it and um",
    "start": "1605960",
    "end": "1611039"
  },
  {
    "text": "basically what Dr does is that it circumvents dead exe like dead execution prevention of that areas where",
    "start": "1611039",
    "end": "1617720"
  },
  {
    "text": "executable Court can't execute from that areas and um so the first line of defense against drop is basically SLR",
    "start": "1617720",
    "end": "1625360"
  },
  {
    "text": "where they basically change things around in the address space so you don't really know where to return to and um",
    "start": "1625360",
    "end": "1632080"
  },
  {
    "text": "now the thing with SLR is that it can be defeated in many ways under the right circumstances and um info Leakes can be",
    "start": "1632080",
    "end": "1639559"
  },
  {
    "text": "quite handy this sort of thing so slrs are not really the like I mean it raises",
    "start": "1639559",
    "end": "1645640"
  },
  {
    "text": "the bar but it doesn't solve the problem mental and um we draw there are other schemes",
    "start": "1645640",
    "end": "1651760"
  },
  {
    "text": "like jump oriented programming call like basically call ored programming we using indirect calls or the counterfeit object",
    "start": "1651760",
    "end": "1658360"
  },
  {
    "text": "oriented programming where you're basically using the features the memory representation of objects to set up a",
    "start": "1658360",
    "end": "1664360"
  },
  {
    "text": "similar um State machine so now",
    "start": "1664360",
    "end": "1669679"
  },
  {
    "start": "1668000",
    "end": "1783000"
  },
  {
    "text": "yeah we need to spe up yeah okay so um in terms of Rob",
    "start": "1669679",
    "end": "1675840"
  },
  {
    "text": "detection um some of the interesting stuff is um done by these guys which is",
    "start": "1675840",
    "end": "1682080"
  },
  {
    "text": "basically they call it K bouncer they basically want the Microsoft um blue ha challenge for this so what it basically",
    "start": "1682080",
    "end": "1689320"
  },
  {
    "text": "does is that um it's U they did the proof of concept on Windows Professional",
    "start": "1689320",
    "end": "1695559"
  },
  {
    "text": "Service P one and what it does is it uses the last Branch recording or the lbr stack in Intel CPUs and um basically",
    "start": "1695559",
    "end": "1703039"
  },
  {
    "text": "what it does is that it uh intercepts certain Key System calls and at the",
    "start": "1703039",
    "end": "1708640"
  },
  {
    "text": "point of the system in the in user mode and when this when the API calls is",
    "start": "1708640",
    "end": "1713760"
  },
  {
    "text": "intercepted at that point they will basically issue an arle to their driver to read the performance events in kernel",
    "start": "1713760",
    "end": "1720320"
  },
  {
    "text": "mode basically in this case the lbr stack which is which is a stack of the last 16 branches recorded and then it",
    "start": "1720320",
    "end": "1727399"
  },
  {
    "text": "will see if the last 16 branches recorded is consistent with the standard",
    "start": "1727399",
    "end": "1732519"
  },
  {
    "text": "the standard coil flow for that particular API or whether it was highly deviating from",
    "start": "1732519",
    "end": "1740518"
  },
  {
    "text": "that um a comment here they are using um",
    "start": "1740760",
    "end": "1746279"
  },
  {
    "text": "uh user mode hooks to install this yep uh and this is a particular case of what we call",
    "start": "1746279",
    "end": "1752640"
  },
  {
    "text": "instrumentation um they use this technique to get by that the stack of the lbr is only 16 large uh so if you",
    "start": "1752640",
    "end": "1760480"
  },
  {
    "text": "can lock it globally you will get nothing so this is a way you can use instrumentation to get specific dat out",
    "start": "1760480",
    "end": "1768640"
  },
  {
    "text": "yeah so going back to that point where we were talking about how to optimize on our usage here they're basically",
    "start": "1768640",
    "end": "1775159"
  },
  {
    "text": "instrumenting critical points in the OS where at these points you inspect to see if the coal flow to that point within",
    "start": "1775159",
    "end": "1781159"
  },
  {
    "text": "limitations obviously of the 16 large stack that it is consistent with the coil flow that is usually meant to get",
    "start": "1781159",
    "end": "1789120"
  },
  {
    "start": "1783000",
    "end": "1902000"
  },
  {
    "text": "there and um this one is an interesting one by G weski this is a US pattern from",
    "start": "1789120",
    "end": "1794440"
  },
  {
    "text": "crowd strike and basically what they're doing here for up detection is is that they're usually they're using the",
    "start": "1794440",
    "end": "1799880"
  },
  {
    "text": "performance measuring counters from ring zero and they're looking for the red misses that we were talking about so red",
    "start": "1799880",
    "end": "1805600"
  },
  {
    "text": "misses is basically when the return address is mispredicted by the CPU and",
    "start": "1805600",
    "end": "1810760"
  },
  {
    "text": "in in case of something like rob you are likely to get rmes because the addresses",
    "start": "1810760",
    "end": "1816240"
  },
  {
    "text": "that you're returning to in a Rob setting are not are not usual addresses",
    "start": "1816240",
    "end": "1822480"
  },
  {
    "text": "that are returned to they are basically different addresses of gadgets so the prediction in this case it's the the CPU",
    "start": "1822480",
    "end": "1830600"
  },
  {
    "text": "will not have predicted these things beforehand to these things",
    "start": "1830600",
    "end": "1835640"
  },
  {
    "text": "occurring because in the normal operation of the C normal operation of code it's not really returned to these",
    "start": "1835640",
    "end": "1842080"
  },
  {
    "text": "points at all so they you don't return like normally you don't return to the gadgets directly on in the normal",
    "start": "1842080",
    "end": "1847720"
  },
  {
    "text": "operation of the CPU or the OS so this is an example of using limitation during",
    "start": "1847720",
    "end": "1855519"
  },
  {
    "text": "zero to get somewhere I talked a bit about before that return misses uh are",
    "start": "1855519",
    "end": "1862080"
  },
  {
    "text": "made Difficult by task switches this is a way to to eliminate this problem by limiting the scope using ring",
    "start": "1862080",
    "end": "1870080"
  },
  {
    "text": "zero um I think before we proceed I would just say you could actually use",
    "start": "1870080",
    "end": "1875840"
  },
  {
    "text": "the instrumentation method that K bounds are used to do the same thing for user",
    "start": "1875840",
    "end": "1881360"
  },
  {
    "text": "mode if you wish to do so the advantage of doing that with the normal performance counters is that you you get",
    "start": "1881360",
    "end": "1888120"
  },
  {
    "text": "a much deeper stack than 16 okay so if you wish to do a stack of 200 you have",
    "start": "1888120",
    "end": "1893960"
  },
  {
    "text": "no issue you just need to instrument instrumentalize like you're doing with",
    "start": "1893960",
    "end": "1899600"
  },
  {
    "text": "the K bouncing yeah so again like K bounc is using the lbr stack like what",
    "start": "1899600",
    "end": "1906279"
  },
  {
    "text": "un is basically discussing with how we can use pmc's as well for the same purpose but done slightly different in",
    "start": "1906279",
    "end": "1913039"
  },
  {
    "text": "C okay so um basically that's that's roughly a basic idea of what people have",
    "start": "1913039",
    "end": "1919519"
  },
  {
    "text": "done with drop mitigation and especially and the first approach using lbr and second approach using RS now I've seen",
    "start": "1919519",
    "end": "1927200"
  },
  {
    "text": "some other people do I mean I mentioned it here but um they have they have done some stack pivoting um detection and",
    "start": "1927200",
    "end": "1933440"
  },
  {
    "text": "things like that as well using um as as a um defense against roing and uh",
    "start": "1933440",
    "end": "1941240"
  },
  {
    "text": "they've done it using pmcs as well so there's these are not obviously the only ways you can use pmc's there's there's",
    "start": "1941240",
    "end": "1948039"
  },
  {
    "text": "scope there it was just something that we want to mention as examples and it's like it's unlikely to",
    "start": "1948039",
    "end": "1953480"
  },
  {
    "text": "be to be by far the only things that you can do and um",
    "start": "1953480",
    "end": "1958679"
  },
  {
    "text": "so like um before we move on um do you have anything to add before we okay so",
    "start": "1958679",
    "end": "1965840"
  },
  {
    "text": "now we are going to start we're going to look at how we can mitigate a lowlevel problem like row Hammer using the",
    "start": "1965840",
    "end": "1972760"
  },
  {
    "text": "performance counters so um so basically the rammer",
    "start": "1972760",
    "end": "1978799"
  },
  {
    "text": "stuff was based on some the original research that was published in this paper about bit flipping in DDR3",
    "start": "1978799",
    "end": "1986279"
  },
  {
    "text": "RAM and you can refer to the original paper they they have quite a significant discussion there and um then uh Mark",
    "start": "1986279",
    "end": "1995159"
  },
  {
    "text": "cbor and Thomas L who happen to be giving their rammer talk right around now in a different room um basically",
    "start": "1995159",
    "end": "2002840"
  },
  {
    "text": "exploited this and uh I believe that they I believe they they basically modif by the pte using bit flipping in raw",
    "start": "2002840",
    "end": "2009960"
  },
  {
    "text": "Hammer to gain kernel mode and uh so uh and then quite recently there",
    "start": "2009960",
    "end": "2017360"
  },
  {
    "text": "was a JavaScript implementation that um that basically exploited the rammer from",
    "start": "2017360",
    "end": "2023200"
  },
  {
    "text": "JavaScript and um sorry we're going to have to really speed up I think um so I",
    "start": "2023200",
    "end": "2029159"
  },
  {
    "text": "don't think we'll really have any time to um go into discussing this uh but the",
    "start": "2029159",
    "end": "2034679"
  },
  {
    "text": "bottom line is that with DDR3 memory if you if you read like basically the same",
    "start": "2034679",
    "end": "2040360"
  },
  {
    "text": "memory like memory address fast enough then you can basically cost bitss and",
    "start": "2040360",
    "end": "2046440"
  },
  {
    "text": "adjacent memory in the same U memory chip itself so that's basically the",
    "start": "2046440",
    "end": "2051839"
  },
  {
    "text": "whole point of R so you keep on you keep on hitting the same memory address and cause bit flips in other addresses in",
    "start": "2051839",
    "end": "2058520"
  },
  {
    "text": "the same proximity so that's basically um discussion into how the DDR is set up",
    "start": "2058520",
    "end": "2064158"
  },
  {
    "text": "and uh all these things so quickly um for memory access in DDR3 so basically",
    "start": "2064159",
    "end": "2070679"
  },
  {
    "start": "2065000",
    "end": "2102000"
  },
  {
    "text": "um you transfer the data like data in a memory line into a Rob buffer and that",
    "start": "2070679",
    "end": "2077240"
  },
  {
    "text": "basically discharges the row and then basically you redite the row buffer contents which is basically accessing",
    "start": "2077240",
    "end": "2083800"
  },
  {
    "text": "the values in the RAM and then when you when you copy back the buffer contents of the row buffer into the memory the",
    "start": "2083800",
    "end": "2089118"
  },
  {
    "text": "memory gets recharged again and since the charge doesn't stay forever you have",
    "start": "2089119",
    "end": "2094919"
  },
  {
    "text": "at at every refresh interval the memory control will ref refresh the contents to make sure that the content remains",
    "start": "2094919",
    "end": "2102280"
  },
  {
    "start": "2102000",
    "end": "2154000"
  },
  {
    "text": "consistent so this is basically uh the code that they published to trigger",
    "start": "2102280",
    "end": "2109119"
  },
  {
    "text": "rammer and um I probably wouldn't go into that I think we should talk a",
    "start": "2109119",
    "end": "2114520"
  },
  {
    "text": "little bit about refresh rate um as you said U memory degrades with time and to",
    "start": "2114520",
    "end": "2121760"
  },
  {
    "text": "avoid the bits flip automatically DDR ramp refreshes itself",
    "start": "2121760",
    "end": "2127720"
  },
  {
    "text": "on a refresh interval the default is 64 milliseconds and um you can yeah so this",
    "start": "2127720",
    "end": "2136839"
  },
  {
    "text": "I think this is important because yes this is important because um the we like",
    "start": "2136839",
    "end": "2142520"
  },
  {
    "text": "to basically cause a bit flips you have to basically Hammer within that refresh interval otherwise the M gets refreshed",
    "start": "2142520",
    "end": "2149359"
  },
  {
    "text": "again so it has to occur within that refreshing",
    "start": "2149359",
    "end": "2154200"
  },
  {
    "start": "2154000",
    "end": "2186000"
  },
  {
    "text": "to and um so in general memory is most likely to increase in density so so",
    "start": "2154440",
    "end": "2161599"
  },
  {
    "text": "basically and the magnetic field properties are that is inversely proportional to the square of the distance so as memory gets more dense",
    "start": "2161599",
    "end": "2168680"
  },
  {
    "text": "this type of electrical disturbance issues are likely to be more and more",
    "start": "2168680",
    "end": "2173920"
  },
  {
    "text": "prominent and um with with mobile devices where there where there smaller form factor and they're going into",
    "start": "2173920",
    "end": "2179839"
  },
  {
    "text": "higher and higher memory so there's likely to have similar issues like raw Hammer affecting these things in the",
    "start": "2179839",
    "end": "2184920"
  },
  {
    "text": "future as well so to in in in Nell to basically cause",
    "start": "2184920",
    "end": "2191359"
  },
  {
    "start": "2186000",
    "end": "2253000"
  },
  {
    "text": "raw Hammer issues you basically have to read a lot of physical memory from Ram which means that you have to bypass any",
    "start": "2191359",
    "end": "2197400"
  },
  {
    "text": "CPU caching and um so you going to read fast before the dam refreshes so between a",
    "start": "2197400",
    "end": "2203839"
  },
  {
    "text": "refresh interval and then you need to know which memory address to read to",
    "start": "2203839",
    "end": "2209040"
  },
  {
    "text": "cause the bit flips in adjacent memory in areas that are significant in terms of Crossing privilege",
    "start": "2209040",
    "end": "2215520"
  },
  {
    "text": "boundaries and um basically um what the Google guys did",
    "start": "2215520",
    "end": "2220920"
  },
  {
    "text": "was that they did what is called double-sided row hammering where they were actually using like attacking two",
    "start": "2220920",
    "end": "2226480"
  },
  {
    "text": "memory lines where they flipping what the one in the middle and obviously the vulnerable gam",
    "start": "2226480",
    "end": "2235119"
  },
  {
    "text": "modules um well before we go on for this slide like to notice that all",
    "start": "2235119",
    "end": "2240359"
  },
  {
    "text": "mitigations that I so far seen can be plotted into the Matrix that is listed",
    "start": "2240359",
    "end": "2245960"
  },
  {
    "text": "here uh it works by denying either one of these points on the list or more of",
    "start": "2245960",
    "end": "2252319"
  },
  {
    "text": "them yep ours as well yes okay so this this is basically um original Source",
    "start": "2252319",
    "end": "2259400"
  },
  {
    "start": "2253000",
    "end": "2267000"
  },
  {
    "text": "documentation that you can um have a look at and some test that tested for R this one is quite interesting because",
    "start": "2259400",
    "end": "2265760"
  },
  {
    "text": "the JavaScript implementation and um so basically some of the ideas that came out was that",
    "start": "2265760",
    "end": "2271680"
  },
  {
    "start": "2267000",
    "end": "2311000"
  },
  {
    "text": "because it's a physical flow that this can't be mitigated or Del with in software which is which we like to",
    "start": "2271680",
    "end": "2277000"
  },
  {
    "text": "disagree with because we can address it um to at least to a large degree by",
    "start": "2277000",
    "end": "2282760"
  },
  {
    "text": "software only means uh one of the other things that came up as solution was to increase refresh rate but this has",
    "start": "2282760",
    "end": "2288000"
  },
  {
    "text": "problems if you look at the original paper the original paper states that the refresh rate has to be like something like 8 milliseconds to completely um",
    "start": "2288000",
    "end": "2295880"
  },
  {
    "text": "rule out any rmer type problems so it's not the uh ultimate solution and uh",
    "start": "2295880",
    "end": "2302160"
  },
  {
    "text": "basically increase in refresh rate is costly in terms of power and in terms of performance because when you refresh memory for that period in time you can't",
    "start": "2302160",
    "end": "2308960"
  },
  {
    "text": "actually um read the contents and which increases power",
    "start": "2308960",
    "end": "2314079"
  },
  {
    "start": "2311000",
    "end": "2343000"
  },
  {
    "text": "consumption so so this was something that was U for ddr4 specification",
    "start": "2314079",
    "end": "2319920"
  },
  {
    "text": "something that um was uh basically proposed as a algorithm that can be",
    "start": "2319920",
    "end": "2325520"
  },
  {
    "text": "implemented at the dam level to um the the idea is if you read a lot from a",
    "start": "2325520",
    "end": "2331720"
  },
  {
    "text": "particularly place in memory you cause a refresh of that piece of memory so that",
    "start": "2331720",
    "end": "2337480"
  },
  {
    "text": "refresh time is faster this I'll quickly um go through the",
    "start": "2337480",
    "end": "2343359"
  },
  {
    "text": "slides okay so so one of the medication me they were talking about in terms of first one of the things we talking being talked about was um to disable flushing",
    "start": "2344319",
    "end": "2352440"
  },
  {
    "text": "the cach so that because for you had to read physical memory so if the memory is Cash well then you're not reading from",
    "start": "2352440",
    "end": "2358680"
  },
  {
    "text": "the you're not reading from the physical memory you're reading from the cache so CL flush is an instruction on the X",
    "start": "2358680",
    "end": "2364599"
  },
  {
    "text": "architecture or architecture that allows you to do this and",
    "start": "2364599",
    "end": "2370319"
  },
  {
    "start": "2370000",
    "end": "2385000"
  },
  {
    "text": "um the the thing is that um the CL flush is not necessarily needed so so this the",
    "start": "2370319",
    "end": "2376720"
  },
  {
    "text": "solution which works with cl flush is not really that useful in the greatest",
    "start": "2376720",
    "end": "2381960"
  },
  {
    "text": "sense of things because you can work around it and like these are some of the other",
    "start": "2381960",
    "end": "2387400"
  },
  {
    "start": "2385000",
    "end": "2405000"
  },
  {
    "text": "ways that you can flush the cache so um I won't get into that but um",
    "start": "2387400",
    "end": "2394079"
  },
  {
    "text": "and like basically ECC dam was offered as solution but I mean eccd ram even if it was practical for everybody to use",
    "start": "2394079",
    "end": "2400720"
  },
  {
    "text": "eccd Ram doesn't actually detect all multiple bit flip",
    "start": "2400720",
    "end": "2405920"
  },
  {
    "start": "2405000",
    "end": "2447000"
  },
  {
    "text": "ARS um um yeah one other way of mitigating row Hammer is to make sure",
    "start": "2405920",
    "end": "2411920"
  },
  {
    "text": "that you cannot find the physical address of the victim address where you need to flip bibs to to gain higher",
    "start": "2411920",
    "end": "2418880"
  },
  {
    "text": "security per and this is good because it's a need to know basis uh um Linux",
    "start": "2418880",
    "end": "2426920"
  },
  {
    "text": "have removed moved the physical mappings for aess for user mode applications U",
    "start": "2426920",
    "end": "2432720"
  },
  {
    "text": "well this is specifically pointing out because one one of the like I mean this obviously not the way to only way to cross privilege boundaries but uh in the",
    "start": "2432720",
    "end": "2440119"
  },
  {
    "text": "original one of the exploit what the guys did was that they basically modify the page table entries to um go into",
    "start": "2440119",
    "end": "2445560"
  },
  {
    "text": "penel mode so um so basically what we're doing",
    "start": "2445560",
    "end": "2450960"
  },
  {
    "start": "2447000",
    "end": "2468000"
  },
  {
    "text": "like basically our solution to detecting and mitigating raw Hammer is to basically",
    "start": "2450960",
    "end": "2457359"
  },
  {
    "text": "detect the LFC cache misses because when the cach is when the data in the cach is evicted or it is flushed to directly",
    "start": "2457359",
    "end": "2463319"
  },
  {
    "text": "access the ram we generate a performance monitoring event which is a lowlevel cast",
    "start": "2463319",
    "end": "2468560"
  },
  {
    "start": "2468000",
    "end": "2508000"
  },
  {
    "text": "Miss so um in terms of in terms of using this method you can run with without an",
    "start": "2468560",
    "end": "2473720"
  },
  {
    "text": "interrupt really and um you can look for peaks of LSC mies within a refresh interval because R",
    "start": "2473720",
    "end": "2480000"
  },
  {
    "text": "hammering has to happen in the refresh interval and um to minimize performance cost you can apply it on a Sandbox only",
    "start": "2480000",
    "end": "2485680"
  },
  {
    "text": "or for Relevant processes or in user mode only and um so there could",
    "start": "2485680",
    "end": "2491079"
  },
  {
    "text": "be potential false positive but um in some ways you'll see how the potential Force positives are not necessarily that",
    "start": "2491079",
    "end": "2497599"
  },
  {
    "text": "relevant and um well when if the the exploit is successful or potentially we have",
    "start": "2497599",
    "end": "2504240"
  },
  {
    "text": "detected such an attempt we can possibly shut down the attempt um in terms of",
    "start": "2504240",
    "end": "2510839"
  },
  {
    "start": "2508000",
    "end": "2624000"
  },
  {
    "text": "mitigation um basically we have two mitigation methods one is blind mitigation and one is mitigation through",
    "start": "2510839",
    "end": "2516319"
  },
  {
    "text": "identification so this blind mitigation is actually uh one of those areas where you talked about like there's no problem",
    "start": "2516319",
    "end": "2522359"
  },
  {
    "text": "of not like detecting it wrongly uh in terms of false positives because what",
    "start": "2522359",
    "end": "2528440"
  },
  {
    "text": "we're doing it is that when we have an attempt what looks like an low hammering attempt what we do is we introduce a",
    "start": "2528440",
    "end": "2534319"
  },
  {
    "text": "delay to that offending thread such that any other attempt to keep on doing it",
    "start": "2534319",
    "end": "2539800"
  },
  {
    "text": "will for go out of the refreshing interval so the hammering won't happen within the same refresh interval because we'll be progressively introducing",
    "start": "2539800",
    "end": "2545880"
  },
  {
    "text": "delays uh the basic idea is is uh back to the",
    "start": "2545880",
    "end": "2551200"
  },
  {
    "text": "slide I said that was important we use the one of performance counter in rare",
    "start": "2551200",
    "end": "2556440"
  },
  {
    "text": "events say every 10,000 cash measures and if that happens twice very short",
    "start": "2556440",
    "end": "2561680"
  },
  {
    "text": "periods of time we up the Andy and look at more so we add to the performance",
    "start": "2561680",
    "end": "2568680"
  },
  {
    "text": "penalty and we do this successively until we we Buck down the memory reads so that the next refresh interval will",
    "start": "2568680",
    "end": "2575359"
  },
  {
    "text": "arrive in in memory yeah so so the hammering will cross the refresh interval and it won't be sufficient",
    "start": "2575359",
    "end": "2580520"
  },
  {
    "text": "hammering to C the problem and um so basically mitigation through identification is essentially we",
    "start": "2580520",
    "end": "2588160"
  },
  {
    "text": "talking about the same method but we're talking about mitigating once we see such an attempt by introducing a delay",
    "start": "2588160",
    "end": "2593520"
  },
  {
    "text": "at the right place or reading that address to course a refresh and I'm sorry we had to rush through this",
    "start": "2593520",
    "end": "2598880"
  },
  {
    "text": "because we need to get go through all the slides oh at Le some of them um so basically to disrupt this what we're",
    "start": "2598880",
    "end": "2605319"
  },
  {
    "text": "going to do at uh if we see an attempt that looks like a roham event we will read data at this victim memory address",
    "start": "2605319",
    "end": "2611800"
  },
  {
    "text": "and um that way the memory will get refreshed and any Ro hammering attempt will have to start over again from that",
    "start": "2611800",
    "end": "2618440"
  },
  {
    "text": "point onwards so and and this way the false positives are quite",
    "start": "2618440",
    "end": "2624200"
  },
  {
    "start": "2624000",
    "end": "2665000"
  },
  {
    "text": "unlikely and um you want to talk about the root kit stuff really quickly uh first we have to differentiate between",
    "start": "2624800",
    "end": "2630359"
  },
  {
    "text": "two kinds of root kits uh there is what I call the well- behaved kind of root kits those are root kits that basically",
    "start": "2630359",
    "end": "2636680"
  },
  {
    "text": "loaded driver and execute nicely and well behaved in this driver The Not So",
    "start": "2636680",
    "end": "2642280"
  },
  {
    "text": "well- behaved rootkit is one that allocates itself's memory and executes",
    "start": "2642280",
    "end": "2650119"
  },
  {
    "text": "itself from that this is not very well behaved and it's a great way to hide",
    "start": "2650119",
    "end": "2656040"
  },
  {
    "text": "yourselves from scanning we are not going to talk about the well- behaved rot kid we're going to",
    "start": "2656040",
    "end": "2661559"
  },
  {
    "text": "talk about you not so well behaved kids um the idea here is any code that",
    "start": "2661559",
    "end": "2668480"
  },
  {
    "start": "2665000",
    "end": "2734000"
  },
  {
    "text": "executes will trigger pmc's and rootkits execute code so with an interro robed on PMC",
    "start": "2668480",
    "end": "2676839"
  },
  {
    "text": "overflow we will automatically get an IEP or an r and thus we know that code",
    "start": "2676839",
    "end": "2683400"
  },
  {
    "text": "is being executed here then we can Traverse all known",
    "start": "2683400",
    "end": "2688440"
  },
  {
    "text": "modules and see if it's in in those modules if it's not then we have a",
    "start": "2688440",
    "end": "2694640"
  },
  {
    "text": "suspect we think this might be a rootkit the a suspect can be dealt with by",
    "start": "2694640",
    "end": "2700559"
  },
  {
    "text": "standard methods the problem with just searching the ram is it's quite possible to upos skate memory uh yeah so you",
    "start": "2700559",
    "end": "2708760"
  },
  {
    "text": "don't identify it as code but when you actually have an interrupt there you know that is execution at this point",
    "start": "2708760",
    "end": "2715319"
  },
  {
    "text": "yeah so generally the idea is that rather than looking for memory regions in memory which look like executable and",
    "start": "2715319",
    "end": "2720480"
  },
  {
    "text": "seeing like what the content is in there we look at the actual statistics about the code that actually executes and see",
    "start": "2720480",
    "end": "2725800"
  },
  {
    "text": "if code is meant to be executing in from these areas in general operation of the operating system and if it is not then",
    "start": "2725800",
    "end": "2732440"
  },
  {
    "text": "there's something fishy going on there so a practical implementation first we thought of all Micro Ops which",
    "start": "2732440",
    "end": "2741119"
  },
  {
    "start": "2734000",
    "end": "2794000"
  },
  {
    "text": "Just Hits too often um we also tried instructions retired which triggers bit",
    "start": "2741119",
    "end": "2747119"
  },
  {
    "text": "less um but we ended up using L2 cach misses this is because um they're much",
    "start": "2747119",
    "end": "2753440"
  },
  {
    "text": "rarer than uh than the the instructions retired but it's virtually impossible to",
    "start": "2753440",
    "end": "2760079"
  },
  {
    "text": "avoid triggering L2 cach hits at some point and also the relative performance",
    "start": "2760079",
    "end": "2767040"
  },
  {
    "text": "penalty for using L2 cast measures versus uh other things is that in Loops",
    "start": "2767040",
    "end": "2772960"
  },
  {
    "text": "you tend to get the the cash will be loaded and we don't see the loop twice in the performance",
    "start": "2772960",
    "end": "2779400"
  },
  {
    "text": "counting so um actual processing we have deferred",
    "start": "2779400",
    "end": "2785040"
  },
  {
    "text": "to another thread so we just record that here was an event and pass it on to",
    "start": "2785040",
    "end": "2790640"
  },
  {
    "text": "another thread and that it do Stand Out testing for M where code obviously we",
    "start": "2790640",
    "end": "2797359"
  },
  {
    "text": "have false negative problems um we could identify any code execution",
    "start": "2797359",
    "end": "2804800"
  },
  {
    "text": "outside of Kernel mode and inside of Kernel mode as well uh the problem is that execution outside of out of modules",
    "start": "2804800",
    "end": "2812960"
  },
  {
    "text": "and user mode is quite common so we have too many false positives false negatives and it's",
    "start": "2812960",
    "end": "2820480"
  },
  {
    "text": "also a performance problem um also we realize that it's only probabilistic",
    "start": "2820480",
    "end": "2827640"
  },
  {
    "text": "detection there is no way to guarantee that a root kit will actually trigger one of these thing um however it is",
    "start": "2827640",
    "end": "2836839"
  },
  {
    "text": "unlikely that any rot could actually doing something or survive a year without being detected with this",
    "start": "2836839",
    "end": "2842000"
  },
  {
    "text": "method um also there is a chance that critical areas say true type fun",
    "start": "2842000",
    "end": "2847680"
  },
  {
    "text": "processing could be instrumented to be more rigorously tested we have not done this but there's you have the option",
    "start": "2847680",
    "end": "2854079"
  },
  {
    "text": "that means that basically any kind of overflow here would be outside of a module and we would",
    "start": "2854079",
    "end": "2861040"
  },
  {
    "text": "trigger and find out y that potentially uh as an example the much High equation",
    "start": "2861040",
    "end": "2868440"
  },
  {
    "text": "group grayfish users has a thousand times to find a key before decrypting more code we think that might trigger an",
    "start": "2868440",
    "end": "2875359"
  },
  {
    "text": "interrupt at some point right yes um by the way the sarcasm um far equation group stuff course I mean some of that",
    "start": "2875359",
    "end": "2881319"
  },
  {
    "text": "stuff especially with the hard drive for modification stuff is really cool so you find anyone in the audience with an au of that no offense",
    "start": "2881319",
    "end": "2889280"
  },
  {
    "start": "2889000",
    "end": "2990000"
  },
  {
    "text": "meant well we have another problem the problem is that we need a list of known",
    "start": "2890440",
    "end": "2896119"
  },
  {
    "text": "good drivers type two type funds Etc it is strictly required if we don't have",
    "start": "2896119",
    "end": "2901359"
  },
  {
    "text": "such a list it doesn't work and this is feasible only in kernel mode in user mode there's just too much around and we",
    "start": "2901359",
    "end": "2907920"
  },
  {
    "text": "can't do it um also in user mode you have things",
    "start": "2907920",
    "end": "2913119"
  },
  {
    "text": "like jit compilers and this is probably very rare in C I hope",
    "start": "2913119",
    "end": "2919880"
  },
  {
    "text": "um from the point that we have detected code usage outside of no good areas",
    "start": "2919880",
    "end": "2926280"
  },
  {
    "text": "traditional an analysis will have to take over to check if this is really a",
    "start": "2926280",
    "end": "2931640"
  },
  {
    "text": "rootkit and the questions you can ask yourself is does this C use stealth technology to have like Delta offset",
    "start": "2931640",
    "end": "2938319"
  },
  {
    "text": "technology where the code can run in any location in memory you could have known good signatures to sort out false",
    "start": "2938319",
    "end": "2944960"
  },
  {
    "text": "positives further you could also have no bad signatures standard antivirus stuff",
    "start": "2944960",
    "end": "2952720"
  },
  {
    "text": "so um obviously our method can be defeated um we're not the only client",
    "start": "2952720",
    "end": "2958559"
  },
  {
    "text": "using the PMC so other boot kit could override uh our PMC usage however the",
    "start": "2958559",
    "end": "2965359"
  },
  {
    "text": "idsc instruction might statistically tell on attackers turning off the PMC so we might actually know if somebody's",
    "start": "2965359",
    "end": "2971280"
  },
  {
    "text": "trying to detect us or avoid detection by these",
    "start": "2971280",
    "end": "2977599"
  },
  {
    "text": "means and we might actually get a chance to um check the msrs and um detected",
    "start": "2978200",
    "end": "2983799"
  },
  {
    "text": "that way as well and um also PMC virtualization by vmm add another layer of complexity to the whole process so um",
    "start": "2983799",
    "end": "2992079"
  },
  {
    "text": "obviously we won't have any time to cover the cash side Channel attacks so um that have to wait for another",
    "start": "2992079",
    "end": "2997839"
  },
  {
    "text": "conference but um but the slides will be available on the website so you guys can go through it we have and generally the",
    "start": "2997839",
    "end": "3004680"
  },
  {
    "text": "slide should give you a rough idea as to what we were going to discuss so um if there are any questions at this point",
    "start": "3004680",
    "end": "3009920"
  },
  {
    "text": "I'd like to take a quick question if there is one or",
    "start": "3009920",
    "end": "3014119"
  },
  {
    "text": "two okay it doesn't look like there's any questions so uh you can do okay",
    "start": "3016280",
    "end": "3021559"
  },
  {
    "text": "couple of slides of Catal attack okay the idea behind",
    "start": "3021559",
    "end": "3028240"
  },
  {
    "start": "3024000",
    "end": "3143000"
  },
  {
    "text": "cach attacks is that the third level cach is shared on all cores U and all",
    "start": "3028240",
    "end": "3034240"
  },
  {
    "text": "virtual threads or hyper threading and that means that accessing memory from",
    "start": "3034240",
    "end": "3040400"
  },
  {
    "text": "One Core will be able to be spotted in other core because the latency because it's placed into cast by the first core",
    "start": "3040400",
    "end": "3047240"
  },
  {
    "text": "the second core will be able to see this because memory access is faster so",
    "start": "3047240",
    "end": "3052280"
  },
  {
    "text": "measure the time for accessing the memory you can know if it a victim used",
    "start": "3052280",
    "end": "3058359"
  },
  {
    "text": "a certain address so basically what you the flush and load attack is you flush a",
    "start": "3058359",
    "end": "3063520"
  },
  {
    "text": "memory address and you wait a second and then you try to read it and if the read",
    "start": "3063520",
    "end": "3069160"
  },
  {
    "text": "is fast somebody else used this memory and if the read is slow nobody used it so you get information about other",
    "start": "3069160",
    "end": "3075599"
  },
  {
    "text": "processes and other privilege levels outside of a Sandbox outside outside the",
    "start": "3075599",
    "end": "3081119"
  },
  {
    "text": "VM sometimes maybe and um yeah so so basically that's the kind of information you can gather by cash side Channel",
    "start": "3081119",
    "end": "3087480"
  },
  {
    "text": "attacks and we basically using pmc's you can address them to some degree as well",
    "start": "3087480",
    "end": "3092680"
  },
  {
    "text": "um how are we doing for time by the way are we yeah okay so we're going to have to wrap it up there because um we",
    "start": "3092680",
    "end": "3098040"
  },
  {
    "text": "obviously out of time so summing summing up very quickly uh I think we have shown that performance counters can actually",
    "start": "3098040",
    "end": "3104880"
  },
  {
    "text": "say a lot about things that are going on inside the CPU that are not normal and",
    "start": "3104880",
    "end": "3111200"
  },
  {
    "text": "is directly related to malaya's activity or at least abnormal activity in the",
    "start": "3111200",
    "end": "3116240"
  },
  {
    "text": "world and in some cases directly malicious activity like for example like in case like",
    "start": "3116240",
    "end": "3123000"
  },
  {
    "text": "roam okay so that's it thank you very sorry that we couldn't um get through all the slides but um we'll put the",
    "start": "3123240",
    "end": "3130720"
  },
  {
    "text": "slides up on the website I'm sure it'll come on like in the next couple of days so um you can go through the slides and",
    "start": "3130720",
    "end": "3136280"
  },
  {
    "text": "that should give you a rough idea of what we're going to talk about so thank you very much",
    "start": "3136280",
    "end": "3142040"
  }
]