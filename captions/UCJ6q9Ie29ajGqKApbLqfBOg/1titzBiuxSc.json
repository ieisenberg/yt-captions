[
  {
    "start": "0",
    "end": "96000"
  },
  {
    "text": "[Music] foreign",
    "start": "1740",
    "end": "6720"
  },
  {
    "text": "who is working for Samsung research and Samsung Mobile Security today I'll be talking about taking Corner hardening to",
    "start": "15139",
    "end": "22080"
  },
  {
    "text": "the next level so let's begin with a brief introduction of today's talk we'll focus on how to",
    "start": "22080",
    "end": "29820"
  },
  {
    "text": "secure today's OS colors particularly we focused on two well-story defenses CFI",
    "start": "29820",
    "end": "37079"
  },
  {
    "text": "and uaf defense and how to take both of them to the next level",
    "start": "37079",
    "end": "43399"
  },
  {
    "text": "this is an overview of CFI we only need to read Corner CFI that",
    "start": "43399",
    "end": "50100"
  },
  {
    "text": "they utilize on point and authentication that is the latest security feature unpleasant",
    "start": "50100",
    "end": "56039"
  },
  {
    "text": "and I first introduced what the problems are in more detail by then by",
    "start": "56039",
    "end": "61680"
  },
  {
    "text": "demystifying the state-of-the-art solutions including iOS connection fi and then I introduce our new approach",
    "start": "61680",
    "end": "68640"
  },
  {
    "text": "called KL there's an academic paper plan to appear at using security this year",
    "start": "68640",
    "end": "76979"
  },
  {
    "text": "and as for our second topic uaf I first explain on existing approaches and why",
    "start": "76979",
    "end": "83700"
  },
  {
    "text": "they are not scalable up to us corners and then I'll introduce our new approach",
    "start": "83700",
    "end": "89280"
  },
  {
    "text": "called Big this is another accounting paper that is published at S Plus this",
    "start": "89280",
    "end": "94320"
  },
  {
    "text": "year so let's move on to the first topic I'm",
    "start": "94320",
    "end": "99659"
  },
  {
    "start": "96000",
    "end": "310000"
  },
  {
    "text": "pointer authentication based chronic CFI I will give you a brief information for",
    "start": "99659",
    "end": "105420"
  },
  {
    "text": "background so step by and to inverse indirect branches jump to only valid destinations",
    "start": "105420",
    "end": "113520"
  },
  {
    "text": "for example we have three functions here and in original CFI this function",
    "start": "113520",
    "end": "120299"
  },
  {
    "text": "pointer is only allowed to go their function entries so we can say that a",
    "start": "120299",
    "end": "126420"
  },
  {
    "text": "loud Target is 3 in original CFI and if you take into account the",
    "start": "126420",
    "end": "132780"
  },
  {
    "text": "function pointer type which is known as type base fi fptr function pointer is",
    "start": "132780",
    "end": "138000"
  },
  {
    "text": "not allowed to go function three because the type of function three void ins is",
    "start": "138000",
    "end": "143940"
  },
  {
    "text": "not different from it's different from the function point of type in",
    "start": "143940",
    "end": "149099"
  },
  {
    "text": "so allow Targets in type basic fi decreases by one compared to original",
    "start": "149099",
    "end": "154980"
  },
  {
    "text": "xfi so with this simple comparison between original and type based CFI you can you",
    "start": "154980",
    "end": "162780"
  },
  {
    "text": "can get to know two things first lower low targets means a strong security",
    "start": "162780",
    "end": "168720"
  },
  {
    "text": "and context is a key to lower allowed targets this means that if we use",
    "start": "168720",
    "end": "174900"
  },
  {
    "text": "another value as a context other than function point of type allow targets can",
    "start": "174900",
    "end": "180599"
  },
  {
    "text": "get even lowered so this is how type base CFI can be",
    "start": "180599",
    "end": "187019"
  },
  {
    "text": "implemented on top of OnPoint authentication when generating a function pointer there's a newly added",
    "start": "187019",
    "end": "194580"
  },
  {
    "text": "instruction Tech IA executed this instruction takes as input a pointer and",
    "start": "194580",
    "end": "201120"
  },
  {
    "text": "a context that can be hash of the function point of time in type base cf5",
    "start": "201120",
    "end": "207180"
  },
  {
    "text": "this instruction goes through a lightweight block Cipher named Karma inside Hardware which signs the given",
    "start": "207180",
    "end": "214860"
  },
  {
    "text": "pointer with the given context and key that serves as a secret",
    "start": "214860",
    "end": "220620"
  },
  {
    "text": "and his outcome looked like a pointer that contains methodly authentication",
    "start": "220620",
    "end": "225959"
  },
  {
    "text": "code this code is called pack pointer authentication code",
    "start": "225959",
    "end": "231060"
  },
  {
    "text": "and this pack will be stored in the unmute speech of a pointer like this we",
    "start": "231060",
    "end": "236760"
  },
  {
    "text": "call this pointer assign the pointer and then with the sound pointer is used",
    "start": "236760",
    "end": "243840"
  },
  {
    "text": "there is another new instruction named autia which authenticates the sign",
    "start": "243840",
    "end": "250140"
  },
  {
    "text": "pointer with the given context if both of context and key match the",
    "start": "250140",
    "end": "257280"
  },
  {
    "text": "pack in the onion speed will be released towards to the original bit",
    "start": "257280",
    "end": "262380"
  },
  {
    "text": "what you call low pointer so this low pointer is can be used without any",
    "start": "262380",
    "end": "267479"
  },
  {
    "text": "trouble okay let's see what happens if a context",
    "start": "267479",
    "end": "272580"
  },
  {
    "text": "mismatch occurs this case represents when attack happens it signs with the type of voidance",
    "start": "272580",
    "end": "280680"
  },
  {
    "text": "but authenticates it with intent so in this case the pack in the audio",
    "start": "280680",
    "end": "288300"
  },
  {
    "text": "speeds will transform into an unpredictable one that is completely different from the original bit",
    "start": "288300",
    "end": "296100"
  },
  {
    "text": "so a system goes down when this abnormal pointer is used",
    "start": "296100",
    "end": "301199"
  },
  {
    "text": "so this is how um PA detects pointer modifications and guarantees security",
    "start": "301199",
    "end": "309319"
  },
  {
    "text": "okay let's see the first pain point the current currency of our systems have a",
    "start": "309900",
    "end": "315419"
  },
  {
    "start": "310000",
    "end": "662000"
  },
  {
    "text": "low Set Fire Security as I mentioned earlier what context to",
    "start": "315419",
    "end": "321660"
  },
  {
    "text": "use you directly relate to security and comparability of CFI system so we use",
    "start": "321660",
    "end": "328139"
  },
  {
    "text": "two factors as a basis to evaluate how good our context is first a more unique context is a more",
    "start": "328139",
    "end": "337259"
  },
  {
    "text": "secure CFR system will be second context is invariance it likely",
    "start": "337259",
    "end": "344280"
  },
  {
    "text": "has no compatibility issue so building a secure and reliable CFO",
    "start": "344280",
    "end": "350520"
  },
  {
    "text": "Econo system it comes down to a problem of figuring out the best context in",
    "start": "350520",
    "end": "355800"
  },
  {
    "text": "considering these two aspects the most widely adopted kind of sapphire",
    "start": "355800",
    "end": "362580"
  },
  {
    "text": "is a type A CFI we discussed earlier slide we can make the original guess on",
    "start": "362580",
    "end": "368880"
  },
  {
    "text": "Y in considering its context the function pointer type actually the function pointer type is",
    "start": "368880",
    "end": "375600"
  },
  {
    "text": "not that much unique because there are lots of function pointers that share the same type",
    "start": "375600",
    "end": "381479"
  },
  {
    "text": "so several attacks have demonstrated it can be broken but it is totally invariant because the",
    "start": "381479",
    "end": "388740"
  },
  {
    "text": "function point of time can be determined at builds time and is guaranteed not being modified a long time",
    "start": "388740",
    "end": "395699"
  },
  {
    "text": "so it has no compatibility issue since many of commodity or scanners",
    "start": "395699",
    "end": "401600"
  },
  {
    "text": "prioritize compatibility over security is understandable to go for type A CFI",
    "start": "401600",
    "end": "410419"
  },
  {
    "text": "okay iOS connect CFI goes one step further by using a better context as you",
    "start": "410580",
    "end": "416340"
  },
  {
    "text": "know iOS color is made of different languages they use a better context for",
    "start": "416340",
    "end": "422400"
  },
  {
    "text": "C plus plus and Objective C but not for C this is why iOS currency Sapphire is not",
    "start": "422400",
    "end": "429600"
  },
  {
    "text": "directly applicable to other C based oscanner such as Linux or previously",
    "start": "429600",
    "end": "436020"
  },
  {
    "text": "I will detail why they do nothing perceived function pointers later",
    "start": "436020",
    "end": "442099"
  },
  {
    "text": "okay let's look at how iOS CFI protect C plus plus function pointers V table",
    "start": "442740",
    "end": "448020"
  },
  {
    "text": "entries interestingly they use a combination of State Dynamic and static context storage",
    "start": "448020",
    "end": "456060"
  },
  {
    "text": "address and hash of function name for example we have a obja of Class A",
    "start": "456060",
    "end": "462900"
  },
  {
    "text": "which is located at a00 address and function one there is one of member",
    "start": "462900",
    "end": "469500"
  },
  {
    "text": "functions is signed with 800 search address and hash of function name as a",
    "start": "469500",
    "end": "476699"
  },
  {
    "text": "context so function 2 does likewise",
    "start": "476699",
    "end": "482479"
  },
  {
    "text": "okay let's evaluate how this context is good in the two aspects that I mentioned",
    "start": "483120",
    "end": "490080"
  },
  {
    "text": "earlier the first hash of function name is unique within a class",
    "start": "490080",
    "end": "495300"
  },
  {
    "text": "so sine the function two pointer cannot be used for function one",
    "start": "495300",
    "end": "500580"
  },
  {
    "text": "and vice versa and but and this is invariant because uh",
    "start": "500580",
    "end": "505860"
  },
  {
    "text": "it is a static value so it looks perfect but second storage address is also",
    "start": "505860",
    "end": "512880"
  },
  {
    "text": "unique within an address system so sine the function pointer at a02",
    "start": "512880",
    "end": "518520"
  },
  {
    "text": "address cannot be used for another address but this is not invariance because a",
    "start": "518520",
    "end": "526380"
  },
  {
    "text": "certain address can be freed and reallocated to another object",
    "start": "526380",
    "end": "532320"
  },
  {
    "text": "so you may remember that I mentioned using not invariant value as a context may cause a compatibility issue",
    "start": "532320",
    "end": "540360"
  },
  {
    "text": "so I will show you what problem could come up in reality in next slide",
    "start": "540360",
    "end": "546420"
  },
  {
    "text": "actually a problem can arise when it comes to protecting C function pointers",
    "start": "546420",
    "end": "552660"
  },
  {
    "text": "here we have a simple function that contains mem copy and there are two pointers of struct obj",
    "start": "552660",
    "end": "560279"
  },
  {
    "text": "destination and servers and their function pointers are signed with corresponding storage address as context",
    "start": "560279",
    "end": "569540"
  },
  {
    "text": "and then after mem copy destinations function pointer will be identical to",
    "start": "569700",
    "end": "574920"
  },
  {
    "text": "search this function pointer that is signed with sources storage address",
    "start": "574920",
    "end": "581940"
  },
  {
    "text": "finally when destination's function pointer is used of course it takes the destination",
    "start": "581940",
    "end": "588480"
  },
  {
    "text": "storage address as context but obviously there will be context mismatch occurring",
    "start": "588480",
    "end": "594420"
  },
  {
    "text": "Because the actual destinations function pointer is signed with sources storage address",
    "start": "594420",
    "end": "600540"
  },
  {
    "text": "basically this is because a context a storage address is not copied along with",
    "start": "600540",
    "end": "606660"
  },
  {
    "text": "a function pointer in mem copy okay with this example we can get to",
    "start": "606660",
    "end": "612060"
  },
  {
    "text": "know that a dynamic context would trade compatibility in memory related functions",
    "start": "612060",
    "end": "618320"
  },
  {
    "text": "that are very commonplace in OS colors so this is why iOS decided to leave C",
    "start": "618320",
    "end": "625019"
  },
  {
    "text": "function pointers on protected okay here is the takeaways user of",
    "start": "625019",
    "end": "632339"
  },
  {
    "text": "steady context solely is not as secure so iOS uses a combination of dynamic and",
    "start": "632339",
    "end": "638880"
  },
  {
    "text": "static context which promises a better security the use of dynamic context is likely",
    "start": "638880",
    "end": "645060"
  },
  {
    "text": "prone to compatibility issues especially in c-based OS colors Linux for example",
    "start": "645060",
    "end": "652380"
  },
  {
    "text": "so the next thing we have to do is to figure out the new context to improve",
    "start": "652380",
    "end": "657660"
  },
  {
    "text": "security while preserving compatibility",
    "start": "657660",
    "end": "662180"
  },
  {
    "start": "662000",
    "end": "1101000"
  },
  {
    "text": "okay to this end we propose a new combination of context",
    "start": "663000",
    "end": "668519"
  },
  {
    "text": "we newly proposed a combination of two study contexts and two dynamic contexts",
    "start": "668519",
    "end": "674640"
  },
  {
    "text": "among among other things obj bind plays the most crucial role in our system so I",
    "start": "674640",
    "end": "680339"
  },
  {
    "text": "focused on describing what obj bind is and its implication",
    "start": "680339",
    "end": "687259"
  },
  {
    "text": "first our Baseline concept is identical to develop type A CFI in this example of",
    "start": "687740",
    "end": "695100"
  },
  {
    "text": "swap II action in Linux to sign Handler we take is type II candle t as the first",
    "start": "695100",
    "end": "703440"
  },
  {
    "text": "context on top of that we use the type of an",
    "start": "703440",
    "end": "709019"
  },
  {
    "text": "object struct II Connection in this example which contains a Target function pointer",
    "start": "709019",
    "end": "715980"
  },
  {
    "text": "this can enhance cfy Precision a lot because lots of function pointer in OS",
    "start": "715980",
    "end": "721320"
  },
  {
    "text": "planners are used along with this object type as you can see in function one",
    "start": "721320",
    "end": "729560"
  },
  {
    "text": "okay next this is the dynamic context what you call obj point it Blends a certain build value into a context what",
    "start": "730500",
    "end": "738180"
  },
  {
    "text": "field to use is up to Developers for example if we choose the name field",
    "start": "738180",
    "end": "743459"
  },
  {
    "text": "for obj bind the field value the address of o1 will be taken and used in signing",
    "start": "743459",
    "end": "751980"
  },
  {
    "text": "instruction so finally these three different contexts are going to be securely mixed",
    "start": "751980",
    "end": "758040"
  },
  {
    "text": "and used in signing instruction okay so far I've been saying about what",
    "start": "758040",
    "end": "765060"
  },
  {
    "text": "obj bind is not why obj bind is good and how you can solve the problem iOS Corner",
    "start": "765060",
    "end": "772079"
  },
  {
    "text": "CFI has so from this slide I'll talk about what motivates the need of J buying any",
    "start": "772079",
    "end": "778680"
  },
  {
    "text": "simplification to highlight the benefit from obj buying",
    "start": "778680",
    "end": "783779"
  },
  {
    "text": "actually doing our research ongoing we found several OS design patterns",
    "start": "783779",
    "end": "789360"
  },
  {
    "text": "beneficial for CFI system that is a lot of struct Has a Field that",
    "start": "789360",
    "end": "795540"
  },
  {
    "text": "is unique as well as invariant obj bond is meant to Target such a field",
    "start": "795540",
    "end": "802980"
  },
  {
    "text": "so I'll explain on why obj bind is unique for example the name field",
    "start": "802980",
    "end": "809519"
  },
  {
    "text": "in II collection most likely differently initialized for different codes",
    "start": "809519",
    "end": "815700"
  },
  {
    "text": "function wants that o1 to the name field but another function most likely sets",
    "start": "815700",
    "end": "821519"
  },
  {
    "text": "another value to the same field in other words this name field serves as",
    "start": "821519",
    "end": "827279"
  },
  {
    "text": "a unique identifier for different instances of the same object type",
    "start": "827279",
    "end": "832500"
  },
  {
    "text": "so the signed Handler of name one name or one cannot be used for the signed",
    "start": "832500",
    "end": "839160"
  },
  {
    "text": "pointer of o2 name so we found this this very common",
    "start": "839160",
    "end": "844920"
  },
  {
    "text": "pattern shared across from Linux to previously",
    "start": "844920",
    "end": "850500"
  },
  {
    "text": "so next obj bind is invariance a unique third you know you know object",
    "start": "850500",
    "end": "856519"
  },
  {
    "text": "is most likely defined as constant value there is a symbol for invariant",
    "start": "856519",
    "end": "863100"
  },
  {
    "text": "so this is initialized at the time of object creation and it's not changed until it's free",
    "start": "863100",
    "end": "869339"
  },
  {
    "text": "so we can say that it's easy to maintain and it's not involved in compatibility issues",
    "start": "869339",
    "end": "875639"
  },
  {
    "text": "because if it's not invariance value we have to resign a function pointer",
    "start": "875639",
    "end": "880800"
  },
  {
    "text": "whenever the field value changes but with this kind of invariant field we",
    "start": "880800",
    "end": "887160"
  },
  {
    "text": "don't need to care about such a resigning okay lastly let's visit the map",
    "start": "887160",
    "end": "894620"
  },
  {
    "text": "problematic main copy example but with obj bind we have a similar code it has two",
    "start": "894620",
    "end": "901320"
  },
  {
    "text": "pointers destination and Source but their handlers are assigned with corresponding name field as context of",
    "start": "901320",
    "end": "909839"
  },
  {
    "text": "course they have different names destination and source okay after mem copy destinations Handler",
    "start": "909839",
    "end": "917339"
  },
  {
    "text": "will be identical to sources Handler that is signed with sources name",
    "start": "917339",
    "end": "924440"
  },
  {
    "text": "and finally when this nation's Handler is used it takes the destination's name that is identical to sources name as a",
    "start": "924959",
    "end": "933240"
  },
  {
    "text": "context so there will be no context mismatch and no compatibility compatibility issue happening this is",
    "start": "933240",
    "end": "940860"
  },
  {
    "text": "because a context the main field is copied along with an Associated Handler in mem copy",
    "start": "940860",
    "end": "948240"
  },
  {
    "text": "function in conclusion obj bind can enhance step by Precision while still being",
    "start": "948240",
    "end": "954540"
  },
  {
    "text": "compatible to them copy functions well let's see the security enhancement",
    "start": "954540",
    "end": "961860"
  },
  {
    "text": "of our method we applied our solution to Linux and also part obj bind to 87",
    "start": "961860",
    "end": "969660"
  },
  {
    "text": "Strokes that are used the most throughout the windows not the parts",
    "start": "969660",
    "end": "975779"
  },
  {
    "text": "is a PA based type-based CFR implementation that comes from an Academia and for comparison we counted",
    "start": "975779",
    "end": "983399"
  },
  {
    "text": "the number of indirect costs that share the same context if uh if it's shared for less than five",
    "start": "983399",
    "end": "990480"
  },
  {
    "text": "places we treat this secure and if it's shared for more than 100 indirect calls we treat this insecure",
    "start": "990480",
    "end": "998220"
  },
  {
    "text": "and this percent indicates how much each case accounts for of all context",
    "start": "998220",
    "end": "1006259"
  },
  {
    "text": "okay you can see parts has the smallest number of secure contexts is because",
    "start": "1006259",
    "end": "1012040"
  },
  {
    "text": "Paris is the only thing that doesn't use a dynamic context and iOS shows a decent number of secure",
    "start": "1012040",
    "end": "1020000"
  },
  {
    "text": "context because it uses a storage address as a context but at least for large",
    "start": "1020000",
    "end": "1026660"
  },
  {
    "text": "Arctic surface that has 6 000 indirect costs sharing the same context",
    "start": "1026660",
    "end": "1032058"
  },
  {
    "text": "because they use the same context for all C function pointers",
    "start": "1032059",
    "end": "1037760"
  },
  {
    "text": "but with KL most of contacts are not shared in more than five places and zero",
    "start": "1037760",
    "end": "1045020"
  },
  {
    "text": "percent in insecure context okay for performance evaluation we made",
    "start": "1045020",
    "end": "1051740"
  },
  {
    "text": "a PA enabled when else they can be running on amount shape or apple and",
    "start": "1051740",
    "end": "1057740"
  },
  {
    "text": "install these Linux into the latest mini the support um PA",
    "start": "1057740",
    "end": "1063020"
  },
  {
    "text": "as a result we observe from seven three to seven percent in post",
    "start": "1063020",
    "end": "1070480"
  },
  {
    "text": "okay let's sum up this section A currency fi can make use of os design",
    "start": "1071600",
    "end": "1077059"
  },
  {
    "text": "patterns to enhance CFI security without compatibility issues",
    "start": "1077059",
    "end": "1082700"
  },
  {
    "text": "so but to be honest use of good context is not the only thing needed to build a",
    "start": "1082700",
    "end": "1088880"
  },
  {
    "text": "secure kind of CFI system there are other things that must be addressed but",
    "start": "1088880",
    "end": "1093980"
  },
  {
    "text": "were not discussed today to check them all I recommend you read our full paper",
    "start": "1093980",
    "end": "1101559"
  },
  {
    "start": "1101000",
    "end": "1330000"
  },
  {
    "text": "okay let's move on to the next pain point in the previous section uh we",
    "start": "1102140",
    "end": "1107240"
  },
  {
    "text": "discussed on a matter of chronic CFI rather than on PA itself",
    "start": "1107240",
    "end": "1112340"
  },
  {
    "text": "in this session I will focus on a security problem of um PA itself that is",
    "start": "1112340",
    "end": "1118460"
  },
  {
    "text": "a complex compiler Behavior can introduce solid bugs that are hard to",
    "start": "1118460",
    "end": "1123559"
  },
  {
    "text": "detect this is a pipeline producing PA enabled",
    "start": "1123559",
    "end": "1129320"
  },
  {
    "text": "kernel the this rectangle on the middle of the slide represents a modern parallel framework at every VM for",
    "start": "1129320",
    "end": "1135740"
  },
  {
    "text": "example and this framework takes color code AS input and it goes through three",
    "start": "1135740",
    "end": "1141200"
  },
  {
    "text": "different phases front-end IR intermediate representation layer and I'm 64 backend",
    "start": "1141200",
    "end": "1147740"
  },
  {
    "text": "if you want to add a new function into this core compiler framework the most",
    "start": "1147740",
    "end": "1152960"
  },
  {
    "text": "common way is to write your own path or write your own compiler plugin and",
    "start": "1152960",
    "end": "1158600"
  },
  {
    "text": "attach it to the IR layer like this so PA pass here means a compiler plugin",
    "start": "1158600",
    "end": "1166280"
  },
  {
    "text": "that inserts Security checks for on pointer Authentication",
    "start": "1166280",
    "end": "1171820"
  },
  {
    "text": "okay let's see an ideal flow of how compiler how color binary is produced we",
    "start": "1172340",
    "end": "1179120"
  },
  {
    "text": "have a simple C code generating a function pointer to function two",
    "start": "1179120",
    "end": "1184220"
  },
  {
    "text": "and it breaks into two IR instructions that this IR layer can recognize and our",
    "start": "1184220",
    "end": "1190700"
  },
  {
    "text": "play pass takes this as input and our our pass interposes a signing",
    "start": "1190700",
    "end": "1197720"
  },
  {
    "text": "instruction between these two so finally it transforms into I'm 64",
    "start": "1197720",
    "end": "1206000"
  },
  {
    "text": "assembly by going through um 64 backend in an ideal situation as you can see the",
    "start": "1206000",
    "end": "1212539"
  },
  {
    "text": "II code perfectly matched with the finer kind of binary",
    "start": "1212539",
    "end": "1218620"
  },
  {
    "text": "but in reality the IR code RPA pass produced it would pass through other",
    "start": "1218780",
    "end": "1224900"
  },
  {
    "text": "compiler passes that are out of our hands which result in an undesirable color",
    "start": "1224900",
    "end": "1231080"
  },
  {
    "text": "binary for example there will be unexpected instructions between what we intend",
    "start": "1231080",
    "end": "1237380"
  },
  {
    "text": "customers here and it can be any form of instructions let's look at why and how it will be",
    "start": "1237380",
    "end": "1245000"
  },
  {
    "text": "problematic let me clarify our swap model first we assume attackers can corrupt memory but not registers",
    "start": "1245000",
    "end": "1252500"
  },
  {
    "text": "in this secure sequence L1 loss the address of function 2 into",
    "start": "1252500",
    "end": "1259340"
  },
  {
    "text": "X1 register and but actual never spills onto memory",
    "start": "1259340",
    "end": "1265220"
  },
  {
    "text": "and install it onto memory as a side form always so we can say for sure is secure",
    "start": "1265220",
    "end": "1273200"
  },
  {
    "text": "in our slave model okay but in reality there are three more",
    "start": "1273200",
    "end": "1278900"
  },
  {
    "text": "instructions can be added for example due to a complex compiler",
    "start": "1278900",
    "end": "1284600"
  },
  {
    "text": "behavior from F2 to Apple L2 stores the low pointer which is the",
    "start": "1284600",
    "end": "1289880"
  },
  {
    "text": "stack memory and assume uh stand vulnerability exists in H3 then attackers can put an",
    "start": "1289880",
    "end": "1297860"
  },
  {
    "text": "arbitrary pointer onto the stack memory and then A4 and L5 would load and assign",
    "start": "1297860",
    "end": "1305179"
  },
  {
    "text": "the attacker chosen pointer by exploring this sequence attackers can make an arbitrarily signed pointer this",
    "start": "1305179",
    "end": "1312860"
  },
  {
    "text": "sequence is called signing Oracle okay here is the takeaway small and",
    "start": "1312860",
    "end": "1319039"
  },
  {
    "text": "compiler framers are so complicated that Solid box can arise and attackers can this um CF file",
    "start": "1319039",
    "end": "1326539"
  },
  {
    "text": "defenses by exploring such blocks okay to solve this problem we propose",
    "start": "1326539",
    "end": "1332720"
  },
  {
    "start": "1330000",
    "end": "1618000"
  },
  {
    "text": "what we call static validator we Define four principles that the final",
    "start": "1332720",
    "end": "1339440"
  },
  {
    "text": "current binary must respect for security this validator attacks these four principles by performing a binary level",
    "start": "1339440",
    "end": "1346640"
  },
  {
    "text": "static analysis on a whole kind of binary but in the scope of interrupt function we ran this validator on three",
    "start": "1346640",
    "end": "1353960"
  },
  {
    "text": "different kind of binaries iOS and Linux compiled by parts and Linux compiled by our PA pass",
    "start": "1353960",
    "end": "1363340"
  },
  {
    "text": "there are four principles we predefined I'll explain on each of them in next",
    "start": "1363500",
    "end": "1368539"
  },
  {
    "text": "slide okay before looking at the first example",
    "start": "1368539",
    "end": "1373880"
  },
  {
    "text": "of violation I'd like to explain on a template used in saying about violations we found you",
    "start": "1373880",
    "end": "1380960"
  },
  {
    "text": "can see a secure sequence on the left slide and an insecure sequence on the right",
    "start": "1380960",
    "end": "1387440"
  },
  {
    "text": "side which is an actual violation we found well first case is a case of absence of",
    "start": "1387440",
    "end": "1395299"
  },
  {
    "text": "PA instructions this function takes extra register of",
    "start": "1395299",
    "end": "1400340"
  },
  {
    "text": "this is a pointer and and loads a function pointer from the given pointer",
    "start": "1400340",
    "end": "1406340"
  },
  {
    "text": "and authenticate and uses the function pointer this is the secure sequence but",
    "start": "1406340",
    "end": "1412039"
  },
  {
    "text": "in the real binary we have several cases that have no authentication instructions",
    "start": "1412039",
    "end": "1418039"
  },
  {
    "text": "so we were suspecting that this is an implementation bug of compiler past",
    "start": "1418039",
    "end": "1424899"
  },
  {
    "text": "next one is the simple function that calls a function pointer pass through a function parameter so this takes",
    "start": "1424940",
    "end": "1433520"
  },
  {
    "text": "as input a function assigned function pointer and authenticates the function",
    "start": "1433520",
    "end": "1438559"
  },
  {
    "text": "pointer and uses the function pointer but in the real binary there was a spill",
    "start": "1438559",
    "end": "1444260"
  },
  {
    "text": "to the step memory and L2 and immediately after Authentication",
    "start": "1444260",
    "end": "1450080"
  },
  {
    "text": "as I mentioned earlier after authentication X2 register will transform into the low pointer so A2",
    "start": "1450080",
    "end": "1458780"
  },
  {
    "text": "stores the low pointer onto the stack memory then by corrupting the pointer on stack",
    "start": "1458780",
    "end": "1465140"
  },
  {
    "text": "attackers can make it jump to anywhere from nfo",
    "start": "1465140",
    "end": "1470659"
  },
  {
    "text": "this is what we call Toc tou problem Primal check and time of use because the",
    "start": "1470659",
    "end": "1476659"
  },
  {
    "text": "point of check L1 is not adjacent to the point of use F4",
    "start": "1476659",
    "end": "1484059"
  },
  {
    "text": "okay this example is a secure signing code that loads address into x21",
    "start": "1484100",
    "end": "1491299"
  },
  {
    "text": "register and signs it in place but in the rear binary an address to be",
    "start": "1491299",
    "end": "1498380"
  },
  {
    "text": "signed comes from the X2 register that is one of function parameters",
    "start": "1498380",
    "end": "1503780"
  },
  {
    "text": "this means that if attackers can control this function parameter they can make an",
    "start": "1503780",
    "end": "1508940"
  },
  {
    "text": "arbitrary signed pointer by using this sequence this is an instance of signing Oracle",
    "start": "1508940",
    "end": "1516860"
  },
  {
    "text": "okay let's see one more example of signing Oracle there was a function called intervened",
    "start": "1516860",
    "end": "1523400"
  },
  {
    "text": "between these two instructions okay it seems no problem at the first",
    "start": "1523400",
    "end": "1528500"
  },
  {
    "text": "glance but it's definitely problematic because there are a lot of instructions",
    "start": "1528500",
    "end": "1534559"
  },
  {
    "text": "to execute in the Quality Function I will go in more detail and one and one",
    "start": "1534559",
    "end": "1542059"
  },
  {
    "text": "here loads an address into X20 to register that is uh that is one of",
    "start": "1542059",
    "end": "1547700"
  },
  {
    "text": "poorly saved register in arm6 for architecture this is the key then the correlate function is first to",
    "start": "1547700",
    "end": "1555140"
  },
  {
    "text": "store The Exchange to register the quality save register onto the stack memory because this is what the Quality",
    "start": "1555140",
    "end": "1562880"
  },
  {
    "text": "Function has to do in the view of compiler and CPU architecture so this example also forced into",
    "start": "1562880",
    "end": "1571120"
  },
  {
    "text": "assigning Oracle problem okay we found several violations on all",
    "start": "1571120",
    "end": "1578000"
  },
  {
    "text": "of those binaries but it's worth noting that violation does not mean explodable",
    "start": "1578000",
    "end": "1583340"
  },
  {
    "text": "because there are many variables involved in exploitation for example",
    "start": "1583340",
    "end": "1588740"
  },
  {
    "text": "the inter function binary analysis that is out of scope for now",
    "start": "1588740",
    "end": "1594760"
  },
  {
    "text": "okay here is takeaways we should uh we should trust a binary level validator",
    "start": "1594880",
    "end": "1600740"
  },
  {
    "text": "instead of a complex compiler and we believe a major event expander",
    "start": "1600740",
    "end": "1606559"
  },
  {
    "text": "can incorporate this validator into current development life cycle to make sure their color release is",
    "start": "1606559",
    "end": "1614240"
  },
  {
    "text": "completely secure okay let's move on to the next topic use",
    "start": "1614240",
    "end": "1621500"
  },
  {
    "start": "1618000",
    "end": "1921000"
  },
  {
    "text": "a complete difference okay the main problem here is that no one cares about counter uaf defenses",
    "start": "1621500",
    "end": "1629120"
  },
  {
    "text": "okay this is mainly because of two things first West corner is huge in size",
    "start": "1629120",
    "end": "1634279"
  },
  {
    "text": "and second corner is most in most cases the lowest level software",
    "start": "1634279",
    "end": "1639740"
  },
  {
    "text": "that is not managed by another software in more devs so to understand what the problems are",
    "start": "1639740",
    "end": "1646820"
  },
  {
    "text": "in more detail we will go over existing approaches and why they are not scalable",
    "start": "1646820",
    "end": "1652640"
  },
  {
    "text": "up to OS colors so first approach is called pointer invalidation which aims to make no",
    "start": "1652640",
    "end": "1659480"
  },
  {
    "text": "dangling pooner by precisely tracking the reference count of object",
    "start": "1659480",
    "end": "1664640"
  },
  {
    "text": "C plus plus has a mechanism known as smart pointer this is similar to IC and",
    "start": "1664640",
    "end": "1670340"
  },
  {
    "text": "Arc in lust and this can be realized by a special class shared PTR for example if",
    "start": "1670340",
    "end": "1677840"
  },
  {
    "text": "developers called a pointer as a smart pointer is reference count gets recorded",
    "start": "1677840",
    "end": "1683120"
  },
  {
    "text": "as one and when a pointer copy happens the reference count will increase this by",
    "start": "1683120",
    "end": "1690320"
  },
  {
    "text": "one and when this function ends the reference count will drop to zero and",
    "start": "1690320",
    "end": "1697039"
  },
  {
    "text": "naturally the object will be de-allocated because there is no reference to the object as you can see",
    "start": "1697039",
    "end": "1703640"
  },
  {
    "text": "there is no possibility for dangling pointer but the thing is to take",
    "start": "1703640",
    "end": "1708679"
  },
  {
    "text": "advantages of this approach developers have to turn all pointers into smart",
    "start": "1708679",
    "end": "1714740"
  },
  {
    "text": "pointers which is unrealistic in terms of engineering approach",
    "start": "1714740",
    "end": "1720200"
  },
  {
    "text": "to tackle this problem researchers propose an automatic solution they designed a new compiler tasks that",
    "start": "1720200",
    "end": "1727640"
  },
  {
    "text": "analyze source code and interposes on all memory allocations and 0.0 copy",
    "start": "1727640",
    "end": "1733460"
  },
  {
    "text": "operations to automatically manage reference counts without having to use Smart pointers",
    "start": "1733460",
    "end": "1741799"
  },
  {
    "text": "however this automation comes from comes with a new problem for example we have a",
    "start": "1741799",
    "end": "1747919"
  },
  {
    "text": "testing operation here from pointer to integer okay how should we deal with it",
    "start": "1747919",
    "end": "1755120"
  },
  {
    "text": "this is an obvious polar copy operation in some sense but it's not in other sense",
    "start": "1755120",
    "end": "1761299"
  },
  {
    "text": "actually increment account or not it's hard to determine which which one",
    "start": "1761299",
    "end": "1766520"
  },
  {
    "text": "is correct Behavior because it depends on application specific semantics",
    "start": "1766520",
    "end": "1772220"
  },
  {
    "text": "this wouldn't be a big problem in user space application because Developers can find all of such cases and fix them",
    "start": "1772220",
    "end": "1780320"
  },
  {
    "text": "by hand manually but this is only a realistic way in OS colors because",
    "start": "1780320",
    "end": "1786520"
  },
  {
    "text": "are huge inside second approach is to Simply never allow",
    "start": "1786520",
    "end": "1792679"
  },
  {
    "text": "reallocation some of you may think this doesn't make sense but it does in practice for user",
    "start": "1792679",
    "end": "1799340"
  },
  {
    "text": "space application due to the large size of virtual memory six forward to be reserved",
    "start": "1799340",
    "end": "1805220"
  },
  {
    "text": "but when it comes to OS colors this wouldn't work because a current memory",
    "start": "1805220",
    "end": "1811039"
  },
  {
    "text": "or location directly takes up a part of physical memory that is much smaller than a virtual memory",
    "start": "1811039",
    "end": "1817820"
  },
  {
    "text": "so this brings um out of memory issues very quickly this is mainly because of the fact that",
    "start": "1817820",
    "end": "1823460"
  },
  {
    "text": "OS content memory is not managed by anyone in more devs",
    "start": "1823460",
    "end": "1829340"
  },
  {
    "text": "so last one is called access validation that checks if a pointer the reference",
    "start": "1829340",
    "end": "1835039"
  },
  {
    "text": "is valid in this approach when memory allocation happens it generates random",
    "start": "1835039",
    "end": "1840980"
  },
  {
    "text": "ID and this ID is given to two different places",
    "start": "1840980",
    "end": "1846380"
  },
  {
    "text": "first this is going to be stored in the all new speech of a pointer as ampere",
    "start": "1846380",
    "end": "1851539"
  },
  {
    "text": "does we call this point outside ID and second this is stored in a separate",
    "start": "1851539",
    "end": "1857419"
  },
  {
    "text": "table that is kind of key value storage where K is object address and value is",
    "start": "1857419",
    "end": "1863720"
  },
  {
    "text": "random ID recall this object side ID so finally when a pointer is referenced",
    "start": "1863720",
    "end": "1870380"
  },
  {
    "text": "it Compares if the two IDs are same",
    "start": "1870380",
    "end": "1875860"
  },
  {
    "text": "the problem is every pointer we reference demands additional memory accesses to locate and read object site",
    "start": "1876440",
    "end": "1884120"
  },
  {
    "text": "ID typically three additional memory accesses needed so it brings on",
    "start": "1884120",
    "end": "1891679"
  },
  {
    "text": "substantial performance over here this is because the implementation of this mapping table looks like a multi-level",
    "start": "1891679",
    "end": "1898880"
  },
  {
    "text": "page table where the level is three in general okay so far we got to know why they're",
    "start": "1898880",
    "end": "1906559"
  },
  {
    "text": "not scalable up to Oscars of of these three approaches we decided to go and",
    "start": "1906559",
    "end": "1912320"
  },
  {
    "text": "optimize the access validation approach because we believe there is still room for optimization in that approach",
    "start": "1912320",
    "end": "1921020"
  },
  {
    "start": "1921000",
    "end": "2300000"
  },
  {
    "text": "so it's time to explain on what you did to optimize access validation approach",
    "start": "1921020",
    "end": "1927200"
  },
  {
    "text": "so our objective is to have only one memory access needed to obtain an object",
    "start": "1927200",
    "end": "1933020"
  },
  {
    "text": "ID so I'd like to introduce the first attempt we did which ended in Failure",
    "start": "1933020",
    "end": "1940460"
  },
  {
    "text": "actually we kept the point aside ID as it is but we moved the object side ID to the",
    "start": "1940460",
    "end": "1948799"
  },
  {
    "text": "start of the object instead of maintaining a separate table",
    "start": "1948799",
    "end": "1954820"
  },
  {
    "text": "in this setting when this pointer is accessed the pointer -8 always points to",
    "start": "1955460",
    "end": "1961940"
  },
  {
    "text": "the start of the object object ID so you can see everything can be done in",
    "start": "1961940",
    "end": "1969200"
  },
  {
    "text": "just one memory access there was another problem occurring in",
    "start": "1969200",
    "end": "1974659"
  },
  {
    "text": "either lookup for the middle of a pointer okay say that we have another pointer let's get P2 that gets the",
    "start": "1974659",
    "end": "1981980"
  },
  {
    "text": "middle of this object and when this middle pointer is accessed the pointer minus a will still point to",
    "start": "1981980",
    "end": "1990500"
  },
  {
    "text": "the middle of this object which result in an incorrect ideal lookup",
    "start": "1990500",
    "end": "1996320"
  },
  {
    "text": "so the next thing we need to do is to get around this problem",
    "start": "1996320",
    "end": "2001779"
  },
  {
    "text": "okay we came up with base identifier to reserve this issue before the random ID",
    "start": "2001779",
    "end": "2007480"
  },
  {
    "text": "was the only thing the prices in a unused page but we divided it into two",
    "start": "2007480",
    "end": "2013419"
  },
  {
    "text": "different parts based identifier and random ID and dedicate KB to chip base",
    "start": "2013419",
    "end": "2019179"
  },
  {
    "text": "identifier to hold information for locating object ID",
    "start": "2019179",
    "end": "2024840"
  },
  {
    "text": "before we're getting into how it works all together I'd like to explain two assumptions necessary in our system we",
    "start": "2024960",
    "end": "2032559"
  },
  {
    "text": "have a focusable region this is our first assumption every object is remitted up to four kilobytes in size",
    "start": "2032559",
    "end": "2039360"
  },
  {
    "text": "and this region is divided into multiple slots where each slot is 64 bytes in",
    "start": "2039360",
    "end": "2046899"
  },
  {
    "text": "size this is our second assumption that is every object is aligned with 64 bytes",
    "start": "2046899",
    "end": "2052960"
  },
  {
    "text": "and base identifier is put to use to certain slot index",
    "start": "2052960",
    "end": "2059679"
  },
  {
    "text": "so of course such size limitation can be adjusted for the need of Developers",
    "start": "2059679",
    "end": "2065878"
  },
  {
    "text": "but there is a one trade-off in these two assumptions let's take",
    "start": "2065879",
    "end": "2071378"
  },
  {
    "text": "another memory alignment for assumption two and see what happens now we take 60",
    "start": "2071379",
    "end": "2077500"
  },
  {
    "text": "bytes alignment instead of 64 byte it can bring a less memory over here to",
    "start": "2077500",
    "end": "2083440"
  },
  {
    "text": "our system but consequently there will be more number of slots demanding a",
    "start": "2083440",
    "end": "2089138"
  },
  {
    "text": "larger bit of Base identifier 8 bit to be exact",
    "start": "2089139",
    "end": "2094480"
  },
  {
    "text": "then the capacity of random ID will decrease by 2 bit accordingly because we",
    "start": "2094480",
    "end": "2099760"
  },
  {
    "text": "have only 16 bit to accommodate both space identifier and random ID as a",
    "start": "2099760",
    "end": "2105160"
  },
  {
    "text": "result it gets a lower security because the random ID indicates a security",
    "start": "2105160",
    "end": "2111280"
  },
  {
    "text": "entropy so in our system developers have to take",
    "start": "2111280",
    "end": "2116440"
  },
  {
    "text": "a responsibility of figuring figuring a configuring this trade-off",
    "start": "2116440",
    "end": "2123579"
  },
  {
    "text": "based upon their need anyway we recommend using photo byte and 64 bytes by default",
    "start": "2123579",
    "end": "2131260"
  },
  {
    "text": "okay let's see an actual example of how it works all together suppose that this",
    "start": "2131260",
    "end": "2136300"
  },
  {
    "text": "is 90 bytes allocation and we first Force this location 64 bytes aligned so",
    "start": "2136300",
    "end": "2143920"
  },
  {
    "text": "we assign 128 bytes for this allocation and put the start slot number four in",
    "start": "2143920",
    "end": "2150940"
  },
  {
    "text": "base identifier this is where the object ID is located",
    "start": "2150940",
    "end": "2157740"
  },
  {
    "text": "okay next it gets the middle pointer as you can see bi is still preserved but why why",
    "start": "2157900",
    "end": "2166480"
  },
  {
    "text": "pointers altered to point to the middle",
    "start": "2166480",
    "end": "2171359"
  },
  {
    "text": "finally when this middle pointer is accessed we try to locate the object ID",
    "start": "2171640",
    "end": "2177820"
  },
  {
    "text": "by using both base identifier and pointer refers to masking with",
    "start": "2177820",
    "end": "2186300"
  },
  {
    "text": "first video masking the pointer we focus by this maximum size in our assumption",
    "start": "2186300",
    "end": "2191700"
  },
  {
    "text": "and its outcome would be slot zero address and then we add a multiplication of 64",
    "start": "2191700",
    "end": "2199359"
  },
  {
    "text": "and the base identifier of 4 this is slight index as a result we can obtain",
    "start": "2199359",
    "end": "2205060"
  },
  {
    "text": "the location of object ID correctly there is no additional memory access",
    "start": "2205060",
    "end": "2210640"
  },
  {
    "text": "needed in locating object ID everything can be done in just one",
    "start": "2210640",
    "end": "2215680"
  },
  {
    "text": "memory access okay we evaluate our Solution on two",
    "start": "2215680",
    "end": "2222160"
  },
  {
    "text": "different colors Ubuntu and Android on two different CPUs x86 and I'm 64. they",
    "start": "2222160",
    "end": "2229359"
  },
  {
    "text": "are imposed an overhead of around 20 percent",
    "start": "2229359",
    "end": "2234420"
  },
  {
    "text": "to be honest but to be honest many of you many of you may still think 20 is",
    "start": "2234420",
    "end": "2240640"
  },
  {
    "text": "still high in real world system so we also developed a performance first",
    "start": "2240640",
    "end": "2246820"
  },
  {
    "text": "variant using On Top Bike ignore feature with this with this way uh its",
    "start": "2246820",
    "end": "2252640"
  },
  {
    "text": "performance reduces down to one or two percent overhead but its security gets",
    "start": "2252640",
    "end": "2258640"
  },
  {
    "text": "lowered alongside let's be not able to inspect the middle pointer so in this setting we are only able to",
    "start": "2258640",
    "end": "2267220"
  },
  {
    "text": "the start pointer of an object",
    "start": "2267220",
    "end": "2271140"
  },
  {
    "text": "okay my presentation ended I can take any questions from audience now okay",
    "start": "2273280",
    "end": "2280480"
  },
  {
    "text": "thanks for attending by my my session and if you have any question please contact me on Swap card",
    "start": "2280480",
    "end": "2286540"
  },
  {
    "text": "or email please thank you thank you everyone",
    "start": "2286540",
    "end": "2291900"
  },
  {
    "text": "[Music]",
    "start": "2292690",
    "end": "2295749"
  },
  {
    "text": "[Music]",
    "start": "2299610",
    "end": "2302689"
  }
]