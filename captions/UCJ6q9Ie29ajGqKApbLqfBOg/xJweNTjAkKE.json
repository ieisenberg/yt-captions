[
  {
    "text": "[Music]",
    "start": "1130",
    "end": "14690"
  },
  {
    "text": "hello everyone and thank you for attending our talk on hp ilo 5 security",
    "start": "16000",
    "end": "21199"
  },
  {
    "text": "so first let's introduce ourselves so with me alexandre who is a security engineer in airbus security lab he is",
    "start": "21199",
    "end": "27519"
  },
  {
    "text": "also the co-author of the practical reverse engineering book and i'm fabian perrigo i'm the reverse",
    "start": "27519",
    "end": "32960"
  },
  {
    "text": "engineering team technical lead at scenic team i'm also a vulnerability researcher and a ctf and security",
    "start": "32960",
    "end": "38320"
  },
  {
    "text": "challenge enthusiast our third partner in crime jeffrey charney couldn't attend the recording of",
    "start": "38320",
    "end": "43360"
  },
  {
    "text": "this video so let's talk about silo so ilo is a",
    "start": "43360",
    "end": "48559"
  },
  {
    "text": "full system running on a dedicated hardware in every hp servers in the world so it allows system",
    "start": "48559",
    "end": "55840"
  },
  {
    "text": "administrators to be able to perform various administrative tasks on the server as if they were physically close",
    "start": "55840",
    "end": "61920"
  },
  {
    "text": "to them so it for example they can recover values information such as the temperature",
    "start": "61920",
    "end": "68720"
  },
  {
    "text": "graph you can see on the image but also uh have all the features of an",
    "start": "68720",
    "end": "74240"
  },
  {
    "text": "ipk vm such as rebooting the server to boot on another media etc",
    "start": "74240",
    "end": "80000"
  },
  {
    "text": "so ilo is a technology we already know we did a deep dive analysis of hp ilo4",
    "start": "80000",
    "end": "86080"
  },
  {
    "text": "and ilo 5 back in 2018 so we found various vulnerabilities such as a",
    "start": "86080",
    "end": "91520"
  },
  {
    "text": "pre-authentication rce on ilo4 to a full secure boot bypass on ilo 5",
    "start": "91520",
    "end": "97680"
  },
  {
    "text": "and we also abused the gma feature to be able to compromise the host operating system by executing code on ilo",
    "start": "97680",
    "end": "106960"
  },
  {
    "text": "so how did this new study started back in early 2020 new ilo 5 firmware",
    "start": "106960",
    "end": "112640"
  },
  {
    "text": "versions appeared versions2.x when we downloaded this new firmware",
    "start": "112640",
    "end": "117840"
  },
  {
    "text": "versions we thought that they were in fact high entropy data blobs so it seems that these new updates were encrypted",
    "start": "117840",
    "end": "124320"
  },
  {
    "text": "while looking at the installation notes we saw that to be able to upgrade to these new versions",
    "start": "124320",
    "end": "129360"
  },
  {
    "text": "we first had to install ilo 5 version 1.4 x so it seems that these",
    "start": "129360",
    "end": "135440"
  },
  {
    "text": "firmware versions were transitional versions and fortunately they are unencrypted so we can start studying",
    "start": "135440",
    "end": "141520"
  },
  {
    "text": "them to understand the new format okay so right now our objective is to",
    "start": "141520",
    "end": "147040"
  },
  {
    "text": "understand where the firmware are decrypted by the io system",
    "start": "147040",
    "end": "152319"
  },
  {
    "text": "and of course we want to hopefully re-implement that mechanism and update your firmware analysis",
    "start": "152319",
    "end": "157760"
  },
  {
    "text": "toolbox our first guess was that the decryption will be implemented quite early in the",
    "start": "157760",
    "end": "164239"
  },
  {
    "text": "boot process of the ilo 5 systems possibly in one of the first two bootloaders secure microboot or neba 9",
    "start": "164239",
    "end": "171519"
  },
  {
    "text": "or possibly within the kernel however if we compared versions from",
    "start": "171519",
    "end": "176560"
  },
  {
    "text": "firmware 1.3x and version 1.4x the versions were actually exactly the same",
    "start": "176560",
    "end": "182560"
  },
  {
    "text": "there was no change so the decryption mechanism is not implemented during that stage of the boot stages",
    "start": "182560",
    "end": "191120"
  },
  {
    "text": "the next hypothesis we made was that it could be in the username image and more",
    "start": "191360",
    "end": "197440"
  },
  {
    "text": "specifically in one of the username tasks that we know very well which is",
    "start": "197440",
    "end": "202640"
  },
  {
    "text": "the firmware update manager or fume this task is responsible to verify the",
    "start": "202640",
    "end": "208799"
  },
  {
    "text": "cryptographic signature of the new firmware update file and if the check is",
    "start": "208799",
    "end": "215040"
  },
  {
    "text": "successful to write that firmware update within the spy flash memory",
    "start": "215040",
    "end": "220640"
  },
  {
    "text": "and indeed if we give quickly two versions of this user on task we discovered the decryption mechanism",
    "start": "220640",
    "end": "228959"
  },
  {
    "text": "so to give you a quick overview what is used is called envelope encryption",
    "start": "228959",
    "end": "234640"
  },
  {
    "text": "it relies upon open cell primitives and an authenticated symmetric ciphering of",
    "start": "234640",
    "end": "240080"
  },
  {
    "text": "the data is used an an algorithm is a aes in galway counter mode or gcm",
    "start": "240080",
    "end": "246799"
  },
  {
    "text": "and the symmetric key of the ies algorithm is actually sealed by an asymmetric encryption algorithm and",
    "start": "246799",
    "end": "253920"
  },
  {
    "text": "erasa is used if you want to open the envelope or",
    "start": "253920",
    "end": "259440"
  },
  {
    "text": "unsealed the symmetry key you have to use and access the rsr private key",
    "start": "259440",
    "end": "266320"
  },
  {
    "text": "so now we are looking for this private key we quickly located this key private key in the data in the resource of the",
    "start": "266320",
    "end": "273840"
  },
  {
    "text": "user on task it is in format pkcs8 and the rsi private key is protected by a passphrase",
    "start": "273840",
    "end": "280880"
  },
  {
    "text": "again it the code relies upon open the cell primitive and in this in",
    "start": "280880",
    "end": "287040"
  },
  {
    "text": "this time must be specifically pm read bio errors private key and actually there is a callback",
    "start": "287040",
    "end": "294080"
  },
  {
    "text": "function that feeds the passphrase to this open cell primitive",
    "start": "294080",
    "end": "299120"
  },
  {
    "text": "so if we pursue her analysis and we look at how this callback function is",
    "start": "299120",
    "end": "305520"
  },
  {
    "text": "implemented we have named it pm password cb what we observe is that the buffer",
    "start": "305520",
    "end": "310960"
  },
  {
    "text": "renamed hw secret is actually built from very specific memory ranges that we knew",
    "start": "310960",
    "end": "318080"
  },
  {
    "text": "from our previous research on the topics and these memory ranges actually are",
    "start": "318080",
    "end": "323120"
  },
  {
    "text": "configuration registers from the ilo 5 system chip the processor itself so kind",
    "start": "323120",
    "end": "329440"
  },
  {
    "text": "of hardware registers mapped into the virtual memory of the user on task",
    "start": "329440",
    "end": "334479"
  },
  {
    "text": "so that means that the aw secret buffer is actually kind of a hardware key",
    "start": "334479",
    "end": "341759"
  },
  {
    "text": "so we have an understanding of the global picture here our objective is to gain",
    "start": "341759",
    "end": "347919"
  },
  {
    "text": "access to the ilo 5 system to read these stock registers and hopefully extract the key",
    "start": "347919",
    "end": "353919"
  },
  {
    "text": "the simplest way to do that is to exploit the vulnerability on the idler 5 system",
    "start": "353919",
    "end": "359280"
  },
  {
    "text": "at this step we were very pragmatic we reused an exploit released an",
    "start": "359280",
    "end": "364639"
  },
  {
    "text": "availability released in 2018 by nicolios it impacted hilo ilo 4 and 5.",
    "start": "364639",
    "end": "372560"
  },
  {
    "text": "it is a remote execution of arbitrary code in the proprietary ssh restricted shell",
    "start": "372560",
    "end": "379520"
  },
  {
    "text": "the vulnerability is a type of type format string and a nicola released expectation code for ilo 4 so what we",
    "start": "379520",
    "end": "387280"
  },
  {
    "text": "did was to port the first stage of this exploit to ilo 5.",
    "start": "387280",
    "end": "392638"
  },
  {
    "text": "in order to do so we encounter a couple of difficulties the first one is that the vulnerability is located within the",
    "start": "393360",
    "end": "400000"
  },
  {
    "text": "task on app cli which is the implementation of the restricted shell and within this task the stock secret",
    "start": "400000",
    "end": "406400"
  },
  {
    "text": "the stock registers are not mapped the second difficulty is that",
    "start": "406400",
    "end": "412080"
  },
  {
    "text": "with the format string of vulnerability we obtain a read write memory primitive",
    "start": "412080",
    "end": "418479"
  },
  {
    "text": "however there is there are some constraints first of all addresses with null bytes are forbidden as well as some",
    "start": "418479",
    "end": "425440"
  },
  {
    "text": "special characters in the addresses again like backslash or backlasher to",
    "start": "425440",
    "end": "431120"
  },
  {
    "text": "bypass these difficulties we had to implement a couple of tricks so to solve the first issue we used a hook of a",
    "start": "431120",
    "end": "438479"
  },
  {
    "text": "function pointer in the memory of the user on task to actually call a primitive exposed by the",
    "start": "438479",
    "end": "444960"
  },
  {
    "text": "operating system that is quite close to a map function i will come back on it just after",
    "start": "444960",
    "end": "451199"
  },
  {
    "text": "for the second difficulty we use a double mapping kind of double mapping trick to remove null bytes from",
    "start": "451199",
    "end": "457919"
  },
  {
    "text": "addresses so back to the map equivalent function so it is kind of",
    "start": "457919",
    "end": "465120"
  },
  {
    "text": "on request memory mapping it is uh what we are the function we have named it map",
    "start": "465120",
    "end": "470400"
  },
  {
    "text": "it is a high level high level wrapper upon kernel primitives but what is really interesting is that",
    "start": "470400",
    "end": "477120"
  },
  {
    "text": "the behavior of this function depends upon structures that are defined within the username task",
    "start": "477120",
    "end": "483680"
  },
  {
    "text": "in the memory of the user on task and more specifically if you look at the top left of the slide you can observe",
    "start": "483680",
    "end": "491280"
  },
  {
    "text": "that the structures are defined in a readable and writable memory area of the",
    "start": "491280",
    "end": "496639"
  },
  {
    "text": "username task so each one of these structures is really simple it's kind of a mapping",
    "start": "496639",
    "end": "503440"
  },
  {
    "text": "descriptor it this we guess that it describes some devices",
    "start": "503440",
    "end": "508720"
  },
  {
    "text": "that can be mapped within the username task for example it's not possible to directly map",
    "start": "508720",
    "end": "514000"
  },
  {
    "text": "the full memory of the kernel in the username task it could have been too simple so each structure is a kind of a mapping",
    "start": "514000",
    "end": "522240"
  },
  {
    "text": "between physical memory and virtual memory and we also have what we have called a mask that is used to tell to",
    "start": "522240",
    "end": "528560"
  },
  {
    "text": "the api which which memory range you want to uh to map into memory",
    "start": "528560",
    "end": "534560"
  },
  {
    "text": "and yes the these structures are defined in a readable and writable memory of the task",
    "start": "534560",
    "end": "542320"
  },
  {
    "text": "so as you can guess we have abused this fact for example we have patched one of the descriptors to make sure that",
    "start": "542560",
    "end": "549040"
  },
  {
    "text": "one physical memory which was of specific interest for us because that's where the",
    "start": "549040",
    "end": "554480"
  },
  {
    "text": "hardware registers are mapped we have used this descriptor to map it at another virtual memory virtual",
    "start": "554480",
    "end": "562480"
  },
  {
    "text": "addresses where actually to remove the new null bytes from the addresses so it's all one of",
    "start": "562480",
    "end": "568480"
  },
  {
    "text": "four difficulties so at the end we actually quickly managed to",
    "start": "568480",
    "end": "574640"
  },
  {
    "text": "extract the key from the ilo files from the memory of the allo 5 system performing as a",
    "start": "574640",
    "end": "581839"
  },
  {
    "text": "key extraction using a format string over the vpn over vpn because those servers were located elsewhere and very",
    "start": "581839",
    "end": "587600"
  },
  {
    "text": "quickly we were successfully decrypting the firmware.2x",
    "start": "587600",
    "end": "594279"
  },
  {
    "text": "so what do we have new in this firmware in version.2. xory",
    "start": "594560",
    "end": "601200"
  },
  {
    "text": "what is really new is that we know we have three username images",
    "start": "601200",
    "end": "606240"
  },
  {
    "text": "there used to be only two main image where all the idler firmware",
    "start": "606240",
    "end": "611440"
  },
  {
    "text": "will be located and a recovery image only now we have three images like i said",
    "start": "611440",
    "end": "619040"
  },
  {
    "text": "what we observe is that there is a new kind of image and it is very very small",
    "start": "619040",
    "end": "624720"
  },
  {
    "text": "it is actually even smaller than the recovery image and what is really important it",
    "start": "624720",
    "end": "631040"
  },
  {
    "text": "what used to be the main image the biggest one i would say no it is",
    "start": "631040",
    "end": "636399"
  },
  {
    "text": "again encrypted so we have a new images very small that is not encrypted and that will be your",
    "start": "636399",
    "end": "643040"
  },
  {
    "text": "lead to understand what happened and that's exactly the feeling we had at",
    "start": "643040",
    "end": "648399"
  },
  {
    "text": "that time that the princess was indeed in another castle so quite quickly we",
    "start": "648399",
    "end": "655360"
  },
  {
    "text": "come to the conclusion that there is a second encryption layer and again our objective will be to extract",
    "start": "655360",
    "end": "661519"
  },
  {
    "text": "the encryption key and hopefully re-implement all the stuff in our firmware analysis toolbox",
    "start": "661519",
    "end": "668320"
  },
  {
    "text": "so if we dissect a little the new very small use of an image that we find in",
    "start": "668320",
    "end": "674880"
  },
  {
    "text": "the new firmware we observe that it is it only embeds three shared modules",
    "start": "674880",
    "end": "681920"
  },
  {
    "text": "three libraries the first one is limited gritty so lim integrity sorry so basically the interface with the",
    "start": "681920",
    "end": "687839"
  },
  {
    "text": "operating system we have the ellipsi and libopen ssl so we as you can guess we",
    "start": "687839",
    "end": "692959"
  },
  {
    "text": "will have cryptography involved if we look at the list of tasks this image is a single task image so the only",
    "start": "692959",
    "end": "700320"
  },
  {
    "text": "task that runs is name key manager key or kmgr and we will name this image kmjr as well",
    "start": "700320",
    "end": "709680"
  },
  {
    "text": "so to give you again an overview of what is at stack here actually we have a kind",
    "start": "709680",
    "end": "715279"
  },
  {
    "text": "of an augmented blue chain instead of the kernel jumps directly to the main",
    "start": "715279",
    "end": "721200"
  },
  {
    "text": "images we have now what we have called stager that is key manager and key manager is responsible for loading and",
    "start": "721200",
    "end": "728560"
  },
  {
    "text": "decrypting in memory the new secure main image and i use the route secure because",
    "start": "728560",
    "end": "734399"
  },
  {
    "text": "it is encrypted okay so now we want to extract the key from",
    "start": "734399",
    "end": "740320"
  },
  {
    "text": "the key manager we are looking for the committee so the new",
    "start": "740320",
    "end": "745920"
  },
  {
    "text": "main new zealand image are encrypted with the same envelope encryption mechanism is used however instead of",
    "start": "745920",
    "end": "753519"
  },
  {
    "text": "using rsa for the asymmetric part some cryptography over elliptic curve is",
    "start": "753519",
    "end": "758959"
  },
  {
    "text": "used what happens is that when key manager starts very early in its boot",
    "start": "758959",
    "end": "764639"
  },
  {
    "text": "a private key is reconstructed this private key is combined with some",
    "start": "764639",
    "end": "770959"
  },
  {
    "text": "public part located in the header of the new encrypted username image and",
    "start": "770959",
    "end": "777279"
  },
  {
    "text": "basically what is used is a definement algorithm over the ap curve to derive a shared secret and this shared secret is",
    "start": "777279",
    "end": "784880"
  },
  {
    "text": "later used to derive the aes encryption key the symmetric encryption",
    "start": "784880",
    "end": "790480"
  },
  {
    "text": "used for zis in gcm mode so",
    "start": "790480",
    "end": "796000"
  },
  {
    "text": "the reverse engineering of key manager was already a great challenge especially because we had a new unknown factor new",
    "start": "796000",
    "end": "802480"
  },
  {
    "text": "x factor that was totally unknown to us at the beginning of this study which is a hardware crypto processor",
    "start": "802480",
    "end": "809440"
  },
  {
    "text": "regarding this crypto processor this hardware element we had absolutely no specification no developer documentation",
    "start": "809440",
    "end": "815600"
  },
  {
    "text": "or anything so we were really kind of blind at the beginning",
    "start": "815600",
    "end": "821120"
  },
  {
    "text": "quickly we realized that only three operations were used from this crypto processor the first one is a sha-384",
    "start": "821120",
    "end": "828880"
  },
  {
    "text": "primitive and we have an aes in counter mode and another ies in galway countermode so",
    "start": "828880",
    "end": "835920"
  },
  {
    "text": "authenticated the private key is reconstructed",
    "start": "835920",
    "end": "841519"
  },
  {
    "text": "regularly in the boot of kiev manager there are two main steps the first one is the derivation of a seed from",
    "start": "841519",
    "end": "847600"
  },
  {
    "text": "hardware values so on the top left of the schema schematic and on the top",
    "start": "847600",
    "end": "854079"
  },
  {
    "text": "right we have the key scheduling function that is fed by the seed that is the right first",
    "start": "854079",
    "end": "859920"
  },
  {
    "text": "so if we go back on the derivation of a seed there there are actually two inputs",
    "start": "859920",
    "end": "866000"
  },
  {
    "text": "value the first one that we name boot ash is actually we understand that",
    "start": "866000",
    "end": "872560"
  },
  {
    "text": "thanks to our knowledge of the system actually it is an artifact of the verification of the signature of",
    "start": "872560",
    "end": "879600"
  },
  {
    "text": "the first bootloader by the boot rom of located on the processor itself",
    "start": "879600",
    "end": "886079"
  },
  {
    "text": "so we have kind of a residual context that stays on the",
    "start": "886079",
    "end": "891440"
  },
  {
    "text": "output buffer of the cryptoprocessor and it is used as input value for the derivation of the initial seed",
    "start": "891440",
    "end": "899040"
  },
  {
    "text": "the second input that we named hardware key is actually a buffer made from uh again",
    "start": "899040",
    "end": "907199"
  },
  {
    "text": "hardware registers from the ilo 5 sock so you combine boot ash and advert",
    "start": "907199",
    "end": "914800"
  },
  {
    "text": "key using a derivation steps based on char 384 and you got the duration seed",
    "start": "914800",
    "end": "921360"
  },
  {
    "text": "this derivation seed is then proceeded to the key scheduling function",
    "start": "921360",
    "end": "927279"
  },
  {
    "text": "the key scheduling is kind of really complex so we will not enter into every",
    "start": "927279",
    "end": "932800"
  },
  {
    "text": "details here but you can find all the information in the paper that we published on the github of the project",
    "start": "932800",
    "end": "938800"
  },
  {
    "text": "as well today we will just speak about two key elements i would say the first one",
    "start": "938800",
    "end": "944399"
  },
  {
    "text": "is what we have called commands they are like wrapper over the crypto processor kind of derivation steps based again on",
    "start": "944399",
    "end": "951920"
  },
  {
    "text": "the charts 384 and this deviation step is parameterized by a key you have commands like key",
    "start": "951920",
    "end": "958800"
  },
  {
    "text": "schedule drive kx or drgb seed lb the second very important point is",
    "start": "958800",
    "end": "965680"
  },
  {
    "text": "do you generate a deterministic key because key manager use open ssl primitive like ec key generate key and",
    "start": "965680",
    "end": "972800"
  },
  {
    "text": "if you use that in your code on your machine it will generate for you a perfectly random",
    "start": "972800",
    "end": "979040"
  },
  {
    "text": "private key over the ap curve what kim manager does actually is that it replaces",
    "start": "979040",
    "end": "985440"
  },
  {
    "text": "the default prng used by openssl and it replaced it by a custom i would say prng",
    "start": "985440",
    "end": "992880"
  },
  {
    "text": "and this paren g is initialized or seeded with a deterministic seed so of course it will have a deterministic",
    "start": "992880",
    "end": "999120"
  },
  {
    "text": "output and that thus we will produce a deterministic key the deterministic seed is actually the",
    "start": "999120",
    "end": "1005279"
  },
  {
    "text": "output of the common derived kx so we have this complex key scheduling",
    "start": "1005279",
    "end": "1010320"
  },
  {
    "text": "function that will actually generate three private keys over the",
    "start": "1010320",
    "end": "1015759"
  },
  {
    "text": "elliptic curve however only the first one will be used by q manager",
    "start": "1015759",
    "end": "1021680"
  },
  {
    "text": "so we have a good understanding of the all the calibration steps and we",
    "start": "1021839",
    "end": "1027280"
  },
  {
    "text": "hopefully what we want to do is to perform an offline generation of this key",
    "start": "1027280",
    "end": "1032798"
  },
  {
    "text": "that is without the need of relying on the ido 5 hardware so we need a complete annotation in c to",
    "start": "1032799",
    "end": "1039600"
  },
  {
    "text": "be uh quite close to what is actually implemented uh in the original firmware based on our",
    "start": "1039600",
    "end": "1045760"
  },
  {
    "text": "static analysis we extracted again the hardware register's value using again",
    "start": "1045760",
    "end": "1051280"
  },
  {
    "text": "the 1d format string vulnerability and combining all of that it was a",
    "start": "1051280",
    "end": "1057120"
  },
  {
    "text": "complete failure we failed to decrypt the user a news user and image so we needed to have more information we",
    "start": "1057120",
    "end": "1063120"
  },
  {
    "text": "needed to escalate to analysis and possibly to interface with the crypto processor to understand and validate",
    "start": "1063120",
    "end": "1069280"
  },
  {
    "text": "step by step all the value stages of the key scheduling function and key direction",
    "start": "1069280",
    "end": "1075840"
  },
  {
    "text": "so we want to talk to the crypto processor because we need to interface directly with it",
    "start": "1076080",
    "end": "1083039"
  },
  {
    "text": "to do that you what we observe what we are reverse engineering is that there is an interface made of again mapped",
    "start": "1083039",
    "end": "1090640"
  },
  {
    "text": "hardware registers that are mapped inside the virtual memory of the task so we'll describe a bit the interface",
    "start": "1090640",
    "end": "1097120"
  },
  {
    "text": "with the crypto processor so at offset 0 we will have a register that is",
    "start": "1097120",
    "end": "1102799"
  },
  {
    "text": "that we have named control flags one can place specific flags to control the",
    "start": "1102799",
    "end": "1108400"
  },
  {
    "text": "various operations of the crypto processor for example if you want to start the computation of your digest to",
    "start": "1108400",
    "end": "1113760"
  },
  {
    "text": "add more data to end the computation or to reset the output buffer",
    "start": "1113760",
    "end": "1119440"
  },
  {
    "text": "at offset zero dot 10 sorry we have a register that we have",
    "start": "1119440",
    "end": "1127520"
  },
  {
    "text": "named offset it is actually automatically i mean in hardware incremented as soon as you write some",
    "start": "1127520",
    "end": "1134480"
  },
  {
    "text": "data inside the input buffer and it contains the size of the input data in bits",
    "start": "1134480",
    "end": "1140960"
  },
  {
    "text": "at offset 0x40 we have the output buffer and out of set",
    "start": "1140960",
    "end": "1147400"
  },
  {
    "text": "0x80 we have the input buffer so to interface with the credit",
    "start": "1147400",
    "end": "1153840"
  },
  {
    "text": "processor we only need to read and write the task virtual memory we can do that with the one day format string",
    "start": "1153840",
    "end": "1159039"
  },
  {
    "text": "vulnerability and we will use this primitive to interface with the crypto processor",
    "start": "1159039",
    "end": "1165840"
  },
  {
    "text": "we started doing so and quite quickly we discovered some unexpected bugs in the",
    "start": "1165840",
    "end": "1171120"
  },
  {
    "text": "use of the interface by schema by key manager the first one of these bugs",
    "start": "1171120",
    "end": "1176240"
  },
  {
    "text": "is related to the flag that we have named uh chas384 digest more data",
    "start": "1176240",
    "end": "1181919"
  },
  {
    "text": "its semantics is quite close to an update flag basically the expected",
    "start": "1181919",
    "end": "1187440"
  },
  {
    "text": "behavior is that when you position this flag it the internal state of the crypto processor",
    "start": "1187440",
    "end": "1194400"
  },
  {
    "text": "the internal state of the digest will be updated with the current content of the input buffer however what we observed",
    "start": "1194400",
    "end": "1202720"
  },
  {
    "text": "is that if the input buffer has not been fully filled then the data are discarded or ignored",
    "start": "1202720",
    "end": "1210240"
  },
  {
    "text": "so to give you an example we start an operation on the crypto on the yes the",
    "start": "1210240",
    "end": "1215679"
  },
  {
    "text": "credit processor so we write the boot hash buffer with input buffer we place the flag update",
    "start": "1215679",
    "end": "1223840"
  },
  {
    "text": "then we write a new buffer in the input buffer we write the hardware key buffer and we place the data end flags",
    "start": "1223840",
    "end": "1232320"
  },
  {
    "text": "what we would have expected is to uh that the final digest is the",
    "start": "1232320",
    "end": "1237360"
  },
  {
    "text": "concatenation the actual digest of the concatenation of boot ash with hardware key however what we observed is that",
    "start": "1237360",
    "end": "1245200"
  },
  {
    "text": "bootage buffer is actually discarded and the crypto processor will wrap simply wrap over the hardware key buffer",
    "start": "1245200",
    "end": "1252880"
  },
  {
    "text": "so we have a very different digest of course than what we would have expected",
    "start": "1252880",
    "end": "1259039"
  },
  {
    "text": "what it means in practice if you remember what we said regarding the derivation of the initial seed there are",
    "start": "1259039",
    "end": "1266480"
  },
  {
    "text": "two inputs boot ash and adwar key and in practice actually boot ash buffer is",
    "start": "1266480",
    "end": "1272320"
  },
  {
    "text": "discarded due to this bug in the interface with the cryptoprocessor",
    "start": "1272320",
    "end": "1278480"
  },
  {
    "text": "the second bug we observed is related to non-contiguous write in",
    "start": "1278480",
    "end": "1284000"
  },
  {
    "text": "the input buffer like we said again regarding the offset registers it is it is",
    "start": "1284000",
    "end": "1290400"
  },
  {
    "text": "automatically incremented in hardware with the number of bits that is written",
    "start": "1290400",
    "end": "1295520"
  },
  {
    "text": "in the input buffer however it is incremented without any consideration for the position of the write in the",
    "start": "1295520",
    "end": "1301360"
  },
  {
    "text": "input buffer that's really important and however again internally in hardware the offset",
    "start": "1301360",
    "end": "1307919"
  },
  {
    "text": "the value of the offset registers is used by the cryptoprocessor to read the data linearly or continuously",
    "start": "1307919",
    "end": "1315360"
  },
  {
    "text": "so that means that if you write a first buffer leaves a small gap then write a",
    "start": "1315360",
    "end": "1320720"
  },
  {
    "text": "new buffer then when you compute the",
    "start": "1320720",
    "end": "1326240"
  },
  {
    "text": "digest of these two these two buffers",
    "start": "1326240",
    "end": "1331440"
  },
  {
    "text": "you will have a result that is different that what could have been expected not all the data will be taken into",
    "start": "1331440",
    "end": "1338159"
  },
  {
    "text": "consideration in the digest so we",
    "start": "1338159",
    "end": "1343280"
  },
  {
    "text": "adapted our code to reflect these two bugs we discovered and it was actually a new total epic failure",
    "start": "1343280",
    "end": "1350080"
  },
  {
    "text": "because the key we computed was still invalid so now what we wanted to do was to find",
    "start": "1350080",
    "end": "1357280"
  },
  {
    "text": "some debug information to understand where we failed in our implementation",
    "start": "1357280",
    "end": "1362799"
  },
  {
    "text": "so while debugging the key manager task we saw that there were some debug messages present for example there's an",
    "start": "1362799",
    "end": "1370080"
  },
  {
    "text": "intermediary state in an early stage of the key derivation which is outputted on the standard output after being a base64",
    "start": "1370080",
    "end": "1378080"
  },
  {
    "text": "encoded and also the final computed public key is displayed also on the standard output",
    "start": "1378080",
    "end": "1385360"
  },
  {
    "text": "so we know that the standard output is in fact printed on the uart output of the server so we started probing some",
    "start": "1385360",
    "end": "1393120"
  },
  {
    "text": "pins on the server motherboard to find the url and we finally found it",
    "start": "1393120",
    "end": "1398159"
  },
  {
    "text": "so when we booted the server we can now see that these debug messages",
    "start": "1398159",
    "end": "1404400"
  },
  {
    "text": "so what we did was uh in our implementation we re-implemented the base64 encoding of this intermediary",
    "start": "1404400",
    "end": "1412159"
  },
  {
    "text": "state and we saw that the two values were totally different so it means that",
    "start": "1412159",
    "end": "1418880"
  },
  {
    "text": "we have a failure very early in the derivation process which is a good news",
    "start": "1418880",
    "end": "1425520"
  },
  {
    "text": "so here is where the the failure should be so there's the initial",
    "start": "1425520",
    "end": "1431279"
  },
  {
    "text": "derivation seed as well as an early step in the final key derivation",
    "start": "1431279",
    "end": "1438240"
  },
  {
    "text": "so now we had a new theory which was that the values of the hardware registers may",
    "start": "1438240",
    "end": "1444320"
  },
  {
    "text": "have changed between firmware versions 1.x and 2.x so we need better debugging capabilities",
    "start": "1444320",
    "end": "1451440"
  },
  {
    "text": "to be able to read these values on a 2.x firmware",
    "start": "1451440",
    "end": "1456640"
  },
  {
    "text": "so we wanted to use some hardware debugging so we we wanted to find a debug port on the motherboard and be",
    "start": "1456720",
    "end": "1463039"
  },
  {
    "text": "able to use it to read these hardware registers values when we looked at the",
    "start": "1463039",
    "end": "1469600"
  },
  {
    "text": "photographies of the hp micro server gen10 motherboard on hpe website we saw",
    "start": "1469600",
    "end": "1475520"
  },
  {
    "text": "there were there was a port labeled as ilo debug it's a miktor port which is well known in the arm",
    "start": "1475520",
    "end": "1481919"
  },
  {
    "text": "world and it should allow us to do some jtag debugging so we started soldering wires to be able",
    "start": "1481919",
    "end": "1488640"
  },
  {
    "text": "to interface with the with this port but finally we bought a correct adapter",
    "start": "1488640",
    "end": "1494799"
  },
  {
    "text": "in the end we were able to enumerate the jtag chain so we saw there were two processors on the chain but we had some",
    "start": "1494799",
    "end": "1502640"
  },
  {
    "text": "problem with the the jtag input the tdi pin and we didn't find the solution to",
    "start": "1502640",
    "end": "1507919"
  },
  {
    "text": "fix it so we gave up we are software guys so we wanted to find a software solution to be able to do the same",
    "start": "1507919",
    "end": "1516240"
  },
  {
    "text": "so what we did was uh looking for a new vulnerability in a firmware version 2.x",
    "start": "1516480",
    "end": "1522000"
  },
  {
    "text": "to be able to read the stock registers values so our target are 2.x firmwares we had a",
    "start": "1522000",
    "end": "1530159"
  },
  {
    "text": "look at the specific attack surface we already know which is the chief interface this is an interface to",
    "start": "1530159",
    "end": "1536559"
  },
  {
    "text": "to perform communication between the host operating system and the ilo system",
    "start": "1536559",
    "end": "1541600"
  },
  {
    "text": "so from there several tasks running on ilo are reachable from the host operating system",
    "start": "1541600",
    "end": "1547679"
  },
  {
    "text": "and one of them is the black box task and it's really interesting because this task is also present in the recovery",
    "start": "1547679",
    "end": "1554480"
  },
  {
    "text": "image which is unencrypted so we can open it in iodide and start studying it",
    "start": "1554480",
    "end": "1560000"
  },
  {
    "text": "so the black box task handles many comments and one of these commands commands 5 is a kind of debug menu in",
    "start": "1560000",
    "end": "1567840"
  },
  {
    "text": "expecting some commands in text mode just like if we were in a terminal and when it handles a command it will",
    "start": "1567840",
    "end": "1574960"
  },
  {
    "text": "output the the results on the uart for example there's a bbf dump command taking a file",
    "start": "1574960",
    "end": "1581520"
  },
  {
    "text": "as argument and it will exit the file on the uart when we started uh looking at the the",
    "start": "1581520",
    "end": "1589840"
  },
  {
    "text": "handler of this command it was like in the 19 so there were buffer overflows everywhere massive usage of dangerous",
    "start": "1589840",
    "end": "1596640"
  },
  {
    "text": "functions such as printf string copy without verifying the the destination",
    "start": "1596640",
    "end": "1602400"
  },
  {
    "text": "buffer size um as a reminder on ilo 5 there are no",
    "start": "1602400",
    "end": "1608960"
  },
  {
    "text": "modern mitigations so no nx no eslr no stack cookies so exploiting this kind of",
    "start": "1608960",
    "end": "1615279"
  },
  {
    "text": "vulnerability is kind of easy so we targeted one of these command handler which is the fvu command it will perform",
    "start": "1615279",
    "end": "1622799"
  },
  {
    "text": "an sprintf on a fixed style stack buffer without checking the size",
    "start": "1622799",
    "end": "1629440"
  },
  {
    "text": "so how did we exploit it we first wrote a small shell code a trampoline shell code in the data",
    "start": "1629919",
    "end": "1636640"
  },
  {
    "text": "section of the of the task using another command which is a chdr",
    "start": "1636640",
    "end": "1643039"
  },
  {
    "text": "and uh this shell code was simply grabbing the current stack pointer value and then",
    "start": "1643039",
    "end": "1649679"
  },
  {
    "text": "jumping back into the into the stack where our final shell code lies",
    "start": "1649679",
    "end": "1655440"
  },
  {
    "text": "so we could in fact put an arbitrary side shell code in the stack and jump to it",
    "start": "1655440",
    "end": "1661919"
  },
  {
    "text": "a little discretion here while exploiting this very narrow ability we also implemented the recovery of",
    "start": "1661919",
    "end": "1668080"
  },
  {
    "text": "usernames and cleartext password on ilo which will be useful in retest in red teams",
    "start": "1668080",
    "end": "1675120"
  },
  {
    "text": "so back to our business using the vulnerability we were able to read again the",
    "start": "1675120",
    "end": "1680880"
  },
  {
    "text": "hardware register values and all the values we weared were exactly the same as in older firmwares",
    "start": "1680880",
    "end": "1687039"
  },
  {
    "text": "so what we did next was uh directly ripping code from keymanager so we",
    "start": "1687039",
    "end": "1692080"
  },
  {
    "text": "splitted the the code in two blocks and we executed",
    "start": "1692080",
    "end": "1697279"
  },
  {
    "text": "it through the vulnerability and finally we dumped the uh cryptoprocessor output",
    "start": "1697279",
    "end": "1702399"
  },
  {
    "text": "buffer to compare the values with our implementation",
    "start": "1702399",
    "end": "1707440"
  },
  {
    "text": "and values were exactly the same so now we had a new theory which was",
    "start": "1707440",
    "end": "1714000"
  },
  {
    "text": "that um our execution context when exploiting the vulnerability was in fact different from the key manager context",
    "start": "1714000",
    "end": "1721440"
  },
  {
    "text": "so we now have to kind of instrument key manager to understand where we failed",
    "start": "1721440",
    "end": "1727760"
  },
  {
    "text": "to do so we in fact reused our secure boot bypass we we found earlier so the goal was to",
    "start": "1727760",
    "end": "1735279"
  },
  {
    "text": "create a modified vmwares and add some hooks to understand our mistakes",
    "start": "1735279",
    "end": "1740799"
  },
  {
    "text": "the security bypass in fact allows us to load a modified",
    "start": "1740799",
    "end": "1746080"
  },
  {
    "text": "userland image using an older vulnerable blue chain so",
    "start": "1746080",
    "end": "1751120"
  },
  {
    "text": "including the the bootloaders and an older kernel so the plan was to load a",
    "start": "1751120",
    "end": "1756320"
  },
  {
    "text": "modified key manager with an old vulnerable kernel so when we first",
    "start": "1756320",
    "end": "1761360"
  },
  {
    "text": "built this firmware we used an unmodified key manager and the the",
    "start": "1761360",
    "end": "1767520"
  },
  {
    "text": "ilo 5 booted and displayed the same key schedule validation as in a normal boot",
    "start": "1767520",
    "end": "1772720"
  },
  {
    "text": "which is very good and if we apply some minor modifications to the task for example modifying a",
    "start": "1772720",
    "end": "1777840"
  },
  {
    "text": "string it will still boot so we are now able to uh modify the task to understand where we failed",
    "start": "1777840",
    "end": "1785360"
  },
  {
    "text": "um how can we flash an arbitrary firmware nylo we have two solutions either with a",
    "start": "1785600",
    "end": "1791279"
  },
  {
    "text": "vulnerability in the in the firmware uh but it will need us",
    "start": "1791279",
    "end": "1796559"
  },
  {
    "text": "to reflash a valid firmware each time we wanted to flash a modified one either through hardware in fact we can directly",
    "start": "1796559",
    "end": "1802480"
  },
  {
    "text": "interface with the spi flash and write our firmware so that's what we did it was easier and faster for us",
    "start": "1802480",
    "end": "1810799"
  },
  {
    "text": "about the hook we in fact just put a simple printf in",
    "start": "1811760",
    "end": "1817200"
  },
  {
    "text": "the middle of the derivation derivation scheme uh so",
    "start": "1817200",
    "end": "1822960"
  },
  {
    "text": "how our oak was placed just after the derivations was computed and just before the first",
    "start": "1822960",
    "end": "1829120"
  },
  {
    "text": "stage of the key schedule uh the key scheduling algorithm",
    "start": "1829120",
    "end": "1834240"
  },
  {
    "text": "and we jumped the uh derivation sheet value encoded in by 64 on the uart so",
    "start": "1834240",
    "end": "1840320"
  },
  {
    "text": "when we booted the server we get this string on the uart so we were able to compare it to our",
    "start": "1840320",
    "end": "1846799"
  },
  {
    "text": "implementation and when we performed the comparison we saw that only four bytes were changing",
    "start": "1846799",
    "end": "1854000"
  },
  {
    "text": "which is very well because this value is supposed to be a sha 384 hash and when",
    "start": "1854000",
    "end": "1860720"
  },
  {
    "text": "only a few bytes change in a hash there's something really weird so we looked closer at the key manager",
    "start": "1860720",
    "end": "1868399"
  },
  {
    "text": "code and we saw that in fact when computing the final digest there were no use of a synchronization",
    "start": "1868399",
    "end": "1875519"
  },
  {
    "text": "mechanism between ilo and its crypto processor which means that the copy loop",
    "start": "1875519",
    "end": "1881039"
  },
  {
    "text": "starts before in fact before the crypto processor ends is hash computing so it",
    "start": "1881039",
    "end": "1886480"
  },
  {
    "text": "starts coping some values from an intermediary state",
    "start": "1886480",
    "end": "1891519"
  },
  {
    "text": "we could check this theory by using a shy implementation in python and by",
    "start": "1891519",
    "end": "1896720"
  },
  {
    "text": "adding a print of the intermediary state just before the final digest and we can",
    "start": "1896720",
    "end": "1901760"
  },
  {
    "text": "see that we the first four bytes of the intermediary state are the bytes we found in uh in the buffer with them",
    "start": "1901760",
    "end": "1910240"
  },
  {
    "text": "so we got our final bug and then we implemented it in our decryption tool and then it worked so now we are able to",
    "start": "1910480",
    "end": "1918399"
  },
  {
    "text": "decrypt the first envelope of the firmware but also the user land image and then we analyzed quickly this",
    "start": "1918399",
    "end": "1925519"
  },
  {
    "text": "useless image were four new tasks and only a few differences so we were like well that for this",
    "start": "1925519",
    "end": "1931840"
  },
  {
    "text": "but anyway the tool is now available on our github repository and the community could start using it to",
    "start": "1931840",
    "end": "1938640"
  },
  {
    "text": "check new new ilo versions yeah so we spent so much time understanding this last bug that we are",
    "start": "1938640",
    "end": "1945279"
  },
  {
    "text": "still quite happy and very happy to restore our balance to the force and more seriously we really believe",
    "start": "1945279",
    "end": "1951679"
  },
  {
    "text": "that we all rocks nikolai's work and the works of many users have helped to",
    "start": "1951679",
    "end": "1957600"
  },
  {
    "text": "increase the security level and awareness about il5 system so that's why the firmware analysis",
    "start": "1957600",
    "end": "1963840"
  },
  {
    "text": "capability is really important for the community regarding the firmware encryption itself",
    "start": "1963840",
    "end": "1969519"
  },
  {
    "text": "it has in our opinion an unclear added value for the end users because as we",
    "start": "1969519",
    "end": "1974640"
  },
  {
    "text": "showed here attackers are able to extract the keys exactly like we did",
    "start": "1974640",
    "end": "1981200"
  },
  {
    "text": "the implementation is particularly complex we find for something that is not",
    "start": "1981200",
    "end": "1987039"
  },
  {
    "text": "that should be much more simpler there is no use of a real secure element and",
    "start": "1987039",
    "end": "1992399"
  },
  {
    "text": "the buggy usage of the cryptoprocessor we can only make the hypothesis that the",
    "start": "1992399",
    "end": "1998399"
  },
  {
    "text": "exact same bugs have been implemented in the hpe firmware production pipeline",
    "start": "1998399",
    "end": "2005039"
  },
  {
    "text": "now if we speak more about the ilo5 system and in itself we find again the",
    "start": "2005039",
    "end": "2010640"
  },
  {
    "text": "same interesting weaknesses first of all the os primitives are two permissives exactly like the one we",
    "start": "2010640",
    "end": "2017840"
  },
  {
    "text": "abused for regarding the memory mapping the seeker boot is broken we reused or",
    "start": "2017840",
    "end": "2024240"
  },
  {
    "text": "exploit from 2018 to build a frackenstein firmware which was perfectly functional to gain",
    "start": "2024240",
    "end": "2030159"
  },
  {
    "text": "debug capabilities on the systems and also the complete lack of modern mitigation techniques",
    "start": "2030159",
    "end": "2037840"
  },
  {
    "text": "make it simple by expecting a single variability to perform a complete takeover of the ilo5 systems",
    "start": "2037840",
    "end": "2046600"
  },
  {
    "text": "we would like to remind you that ido 5 systems are really critical systems so please keep them up to date",
    "start": "2046720",
    "end": "2053599"
  },
  {
    "text": "make sure they are as not exposed too much isolate as much as",
    "start": "2053599",
    "end": "2059599"
  },
  {
    "text": "possible and monitor them regarding the new vulnerability that we",
    "start": "2059599",
    "end": "2064960"
  },
  {
    "text": "have talked about within this briefing there is an available fix by hpe which has been",
    "start": "2064960",
    "end": "2071679"
  },
  {
    "text": "released in march 2021 and you can have more information in the security",
    "start": "2071679",
    "end": "2076960"
  },
  {
    "text": "building that is rated as critical so before we close this talk we would",
    "start": "2076960",
    "end": "2082240"
  },
  {
    "text": "like to thank mark mancus and hold the hpe psrt for",
    "start": "2082240",
    "end": "2087280"
  },
  {
    "text": "their activity we would like also to thank our teams at synaptive and airbus for their very",
    "start": "2087280",
    "end": "2093440"
  },
  {
    "text": "valuable feedbacks during this research nikolayos as well for presenting his work and publishing his its tools",
    "start": "2093440",
    "end": "2101040"
  },
  {
    "text": "failing xavier for the help with the server initial move",
    "start": "2101040",
    "end": "2105838"
  },
  {
    "text": "so thank you very much for attending this briefing we'll be very happy to join you for the q a session",
    "start": "2106079",
    "end": "2112240"
  },
  {
    "text": "thank you for your attention",
    "start": "2112240",
    "end": "2115800"
  }
]