[
  {
    "text": "[Music]",
    "start": "1130",
    "end": "14080"
  },
  {
    "text": "hi everyone welcome i'm going to talk about ios security today the title is",
    "start": "14080",
    "end": "20160"
  },
  {
    "text": "everything has changed in ios 14 but jailbreak is ethanol",
    "start": "20160",
    "end": "25840"
  },
  {
    "text": "my name is sandorji a security researcher from art security chen chung",
    "start": "25840",
    "end": "31039"
  },
  {
    "text": "lab i mainly focus on mac os ios security i attended black hat asia",
    "start": "31039",
    "end": "37600"
  },
  {
    "text": "2021 as a speaker i'm glad i could attend the black hat again",
    "start": "37600",
    "end": "43280"
  },
  {
    "text": "on february 10th modern toner released the secular versa it is the first",
    "start": "43280",
    "end": "49120"
  },
  {
    "text": "workable ios 14 kernel exploit open a door to ios 14 jailbreak after that i",
    "start": "49120",
    "end": "56960"
  },
  {
    "text": "published a stable kernel thread primitive firstly based on the exploit today i will",
    "start": "56960",
    "end": "64640"
  },
  {
    "text": "complete a project dq preview break show how to run or authorize the code on ios",
    "start": "64640",
    "end": "71520"
  },
  {
    "text": "14. this talk is about my ios 14 learning journey",
    "start": "71520",
    "end": "77520"
  },
  {
    "text": "first let's compare the security between ios 14 and ios 13. in ios 13 there are",
    "start": "77520",
    "end": "85439"
  },
  {
    "text": "many vulnerabilities in its lifecycle for example ob timestamp in ios 13.3",
    "start": "85439",
    "end": "93920"
  },
  {
    "text": "taking on in ios 13.5 and ob wins in ios 13.7",
    "start": "93920",
    "end": "101280"
  },
  {
    "text": "so jailbreak is almost always available on ios 13",
    "start": "101280",
    "end": "106320"
  },
  {
    "text": "but things changed in ios 14 since the first warning of ios 14",
    "start": "106320",
    "end": "112880"
  },
  {
    "text": "we go to the first kernel exploit after more than five months this is really a",
    "start": "112880",
    "end": "119360"
  },
  {
    "text": "long period of time now ios 15 beta is testing maybe ios 14",
    "start": "119360",
    "end": "126840"
  },
  {
    "text": "will come to the end of its life cycle this is still there is still only one",
    "start": "126840",
    "end": "133840"
  },
  {
    "text": "public workforce chrono exploit so ios 14 is really a tough way",
    "start": "133840",
    "end": "140879"
  },
  {
    "text": "why is ios 14 so hard to be pruned well ios 14 introduced lots of new",
    "start": "140879",
    "end": "148480"
  },
  {
    "text": "mitigations such as the kernel heap hardening data pack user speeds pack",
    "start": "148480",
    "end": "154239"
  },
  {
    "text": "academy tlp harmony ipc key message harmony and etc",
    "start": "154239",
    "end": "160319"
  },
  {
    "text": "some works on the vulnerabilities did some works on the exploit stage make ios",
    "start": "160319",
    "end": "166879"
  },
  {
    "text": "more secure than before first i want to talk about the kernel",
    "start": "166879",
    "end": "172160"
  },
  {
    "text": "heap translation with the key key translation you can't overlap the free the object with a",
    "start": "172160",
    "end": "178720"
  },
  {
    "text": "different object avoid that have confusion that's a good way to stop uef",
    "start": "178720",
    "end": "185040"
  },
  {
    "text": "vulnerabilities it's not new but has been hardened massively in ios 14. in ios 14 key",
    "start": "185040",
    "end": "193440"
  },
  {
    "text": "analog heap is split into four subtypes now allocations made by kernel extension",
    "start": "193440",
    "end": "200879"
  },
  {
    "text": "are moved to key fib pxt kernel objects and the key ext objects",
    "start": "200879",
    "end": "208159"
  },
  {
    "text": "can't see each other there is a heap named data buffers",
    "start": "208159",
    "end": "213360"
  },
  {
    "text": "let's see the definition of it this set of zooms should contain pure bands of bytes with no pointers or of",
    "start": "213360",
    "end": "220879"
  },
  {
    "text": "size so uaf in this clip has few harmful side effects",
    "start": "220879",
    "end": "226400"
  },
  {
    "text": "that's not a serious problem and there is a special heap to store temporary",
    "start": "226400",
    "end": "232640"
  },
  {
    "text": "data when writing kernel exploit we often use",
    "start": "232640",
    "end": "238000"
  },
  {
    "text": "os data to build a fixed or uaf object but now os data and os",
    "start": "238000",
    "end": "245280"
  },
  {
    "text": "screen contains a model into data heap it is nearly impossible to build a fake",
    "start": "245280",
    "end": "252159"
  },
  {
    "text": "object with os data what's more ampl has moved more and more key objects into",
    "start": "252159",
    "end": "258400"
  },
  {
    "text": "delicate zooms now the heap in ios 14 is fine green",
    "start": "258400",
    "end": "264479"
  },
  {
    "text": "with few common errors which significantly reduces the living",
    "start": "264479",
    "end": "270080"
  },
  {
    "text": "space or uef vulnerabilities data pack",
    "start": "270080",
    "end": "275919"
  },
  {
    "text": "newly introduced in ios 14. you can mark a pointer using macro ptios signed pdr",
    "start": "275919",
    "end": "284960"
  },
  {
    "text": "then the compiler will add extra instructions automatically to",
    "start": "284960",
    "end": "290400"
  },
  {
    "text": "protect this pointer the disassembly code is shown below one full story",
    "start": "290400",
    "end": "296560"
  },
  {
    "text": "impact pointer and a landfill fetching the signing strategy is encrypting the",
    "start": "296560",
    "end": "302880"
  },
  {
    "text": "pointer with a unique discriminator plus its memory address",
    "start": "302880",
    "end": "308240"
  },
  {
    "text": "so if you count so you can't touch any base of the",
    "start": "308240",
    "end": "313360"
  },
  {
    "text": "packed pointer and since the memory address is also involved in the encryption",
    "start": "313360",
    "end": "319600"
  },
  {
    "text": "you can't use the packet pointer in other memory address different from code",
    "start": "319600",
    "end": "325280"
  },
  {
    "text": "pack data pack is used for data integrity ensure that the data is not",
    "start": "325280",
    "end": "331039"
  },
  {
    "text": "modified by others now most of the data pointers then apple",
    "start": "331039",
    "end": "336080"
  },
  {
    "text": "consider considered critical which are commonly used in exploit are protected",
    "start": "336080",
    "end": "342560"
  },
  {
    "text": "by pac such as ukraine ipc port",
    "start": "342560",
    "end": "348880"
  },
  {
    "text": "furthermore data pointer is not the only scenario where pack can be",
    "start": "349840",
    "end": "355600"
  },
  {
    "text": "applied sorry my bad complained about a webkit commit ago",
    "start": "355600",
    "end": "361440"
  },
  {
    "text": "i'm not familiar with the webkit exploit i guess field m offset of struct",
    "start": "361440",
    "end": "369039"
  },
  {
    "text": "assembler label is an important employed primitive",
    "start": "369039",
    "end": "374240"
  },
  {
    "text": "in this commit ample expander am offset to 64 bits so it can be signed by pack",
    "start": "374240",
    "end": "381840"
  },
  {
    "text": "using the extra 32 bits and what's more with the da cas",
    "start": "381840",
    "end": "388160"
  },
  {
    "text": "you can sign arbitrary blob kernel exports and api to do this",
    "start": "388160",
    "end": "394479"
  },
  {
    "text": "the thread state in kernel is also protected by ga case",
    "start": "394479",
    "end": "400080"
  },
  {
    "text": "in ios 14 you can find data pack in kernel here and there but it's not easy",
    "start": "400080",
    "end": "406000"
  },
  {
    "text": "to get rid of the in rs13 all the user speeds processes",
    "start": "406000",
    "end": "412319"
  },
  {
    "text": "share a sim ak so attackers can afford a key protected function pointers in other",
    "start": "412319",
    "end": "419520"
  },
  {
    "text": "process this is this is a serious flaw then",
    "start": "419520",
    "end": "425440"
  },
  {
    "text": "i was 14 ample decides to change this situation now iak becomes process dependent",
    "start": "425440",
    "end": "433759"
  },
  {
    "text": "different processes use different ii keys a name that is user speed pack",
    "start": "433759",
    "end": "439120"
  },
  {
    "text": "hardening this is detailed in kernel document pack dot md",
    "start": "439120",
    "end": "445520"
  },
  {
    "text": "this change is effective to resist cross process attack",
    "start": "445520",
    "end": "450720"
  },
  {
    "text": "but geopreg also need to control other process i.e am fid this mitigation",
    "start": "450720",
    "end": "459039"
  },
  {
    "text": "brings trouble fortunately with kernel rewrite it is possible to bypass it i will talk",
    "start": "459039",
    "end": "466240"
  },
  {
    "text": "about this later in the past hackers use the task for pid",
    "start": "466240",
    "end": "472960"
  },
  {
    "text": "0 trick to access the kernel task port it is the most convenient way to achieve",
    "start": "472960",
    "end": "479199"
  },
  {
    "text": "criminal rewrite almost every kernel exploit tries to build a tlp zero but that is not",
    "start": "479199",
    "end": "487759"
  },
  {
    "text": "that is not the case now apple has had another kernel task you can't resolve the kernel task now",
    "start": "487759",
    "end": "495360"
  },
  {
    "text": "and if you try to access the kernel map you will trigger a panic both pre-trial and e-12 plus devices are",
    "start": "495360",
    "end": "503520"
  },
  {
    "text": "seen we must find alternatives to trp 0 to achieve kernel rewrite",
    "start": "503520",
    "end": "511680"
  },
  {
    "text": "there i want to talk about a special kernel object ipc key message it is an",
    "start": "511680",
    "end": "518800"
  },
  {
    "text": "exploit friendly object you can frequently see it in heaps pre",
    "start": "518800",
    "end": "525040"
  },
  {
    "text": "but i must say key message is more powerful than that with key message you can directly",
    "start": "525040",
    "end": "532240"
  },
  {
    "text": "convert a toolbar clip overflow which happens in key analog large area",
    "start": "532240",
    "end": "538320"
  },
  {
    "text": "24 is export the key idea is modifying field ikm set",
    "start": "538320",
    "end": "544399"
  },
  {
    "text": "to free more memory and you can look itself with link pointer",
    "start": "544399",
    "end": "550320"
  },
  {
    "text": "but key message was hardened in ios 14.2 all key message objects went to zoom now",
    "start": "550320",
    "end": "558160"
  },
  {
    "text": "data path is separated from key message header and moved into key keep data",
    "start": "558160",
    "end": "563920"
  },
  {
    "text": "so now you can't overflow a key message now i think this is the apple's smart",
    "start": "563920",
    "end": "569839"
  },
  {
    "text": "idea without the essential exploiter primitives you cannot",
    "start": "569839",
    "end": "575600"
  },
  {
    "text": "exploit a bug easily this really matters to me i had an ios kernel back but the exploit",
    "start": "575600",
    "end": "584240"
  },
  {
    "text": "code relies on key message without a key message i'm not able to exploit it now",
    "start": "584240",
    "end": "591440"
  },
  {
    "text": "so it only works on ios 14.1 i can't find an alternative to key",
    "start": "591440",
    "end": "598720"
  },
  {
    "text": "message yet all right so it's very hard to pull ios",
    "start": "598720",
    "end": "604640"
  },
  {
    "text": "14 it is not impossible now let's talk about the first public",
    "start": "604640",
    "end": "610399"
  },
  {
    "text": "ios 14 chrono exploit cve 2021 1782",
    "start": "610399",
    "end": "616880"
  },
  {
    "text": "it is a risk condition bug in module fc water we can convert it back to a useful",
    "start": "616880",
    "end": "623760"
  },
  {
    "text": "uef it was fixed in rs 14.4 on january",
    "start": "623760",
    "end": "628959"
  },
  {
    "text": "26 2021 after two weeks snack tea published",
    "start": "628959",
    "end": "634640"
  },
  {
    "text": "the uh blog post detailing how this vulnerability works they also released a",
    "start": "634640",
    "end": "640720"
  },
  {
    "text": "workable poc to demonstrate the vulnerability on ios 14 by making the",
    "start": "640720",
    "end": "646480"
  },
  {
    "text": "kernel crash and then this in the same day odin puna published the exploit named",
    "start": "646480",
    "end": "654640"
  },
  {
    "text": "secuta versa for this vulnerability in the exploit code kernel read write",
    "start": "654640",
    "end": "661040"
  },
  {
    "text": "primitives are included that's amazing be aware that writing an ios 14 export",
    "start": "661040",
    "end": "668959"
  },
  {
    "text": "is not that easy due to the new mutations i really admire the techniques more than",
    "start": "668959",
    "end": "675279"
  },
  {
    "text": "pruners shown in their code today i will focus on how to execute our authorized",
    "start": "675279",
    "end": "681519"
  },
  {
    "text": "binary on iphone by utilizing modern toner's exploit",
    "start": "681519",
    "end": "686560"
  },
  {
    "text": "and how to solve the problems i met which was newly introduced",
    "start": "686560",
    "end": "691760"
  },
  {
    "text": "by ios 14. okay now let's see the kernel regret",
    "start": "691760",
    "end": "697440"
  },
  {
    "text": "primitives provided by secutar versa it converts the original original risk",
    "start": "697440",
    "end": "704480"
  },
  {
    "text": "condition bug to an uef of packing options there is a pointer in packing options",
    "start": "704480",
    "end": "711600"
  },
  {
    "text": "pointed to a pancreas info structure you can overwrite this pointer by freeing",
    "start": "711600",
    "end": "717600"
  },
  {
    "text": "and reallocating this object in user space then through get and set",
    "start": "717600",
    "end": "724160"
  },
  {
    "text": "circuit option you can read and write the packet info structure by the user",
    "start": "724160",
    "end": "729360"
  },
  {
    "text": "speeds control the pointer that's the arbitrary kernel redirect primitives",
    "start": "729360",
    "end": "735279"
  },
  {
    "text": "provided by secure towers we noticed that secure towers are you",
    "start": "735279",
    "end": "741519"
  },
  {
    "text": "utilize the circuit operation to lay out the kernel heap but in the past we usually use os data",
    "start": "741519",
    "end": "748639"
  },
  {
    "text": "or key message to operate the kernel heap so using salt it is a little weird",
    "start": "748639",
    "end": "755760"
  },
  {
    "text": "that is due to kernel heap resolution now they are in different hips",
    "start": "755760",
    "end": "761680"
  },
  {
    "text": "in this vulnerability we must look up suitable objects in keyhip default the",
    "start": "761680",
    "end": "768079"
  },
  {
    "text": "bad thing is the circuit option object is nearly the only solution",
    "start": "768079",
    "end": "773680"
  },
  {
    "text": "actually there is a limitation on the kernel read write every time we perform a kernel read or",
    "start": "773680",
    "end": "781519"
  },
  {
    "text": "write operation we need to free the old object then we allocate a new object",
    "start": "781519",
    "end": "788000"
  },
  {
    "text": "to modify the read write address but if we are not lucky there is a",
    "start": "788000",
    "end": "794160"
  },
  {
    "text": "chance that the memory call is occupied by others then we lost control of reader",
    "start": "794160",
    "end": "800880"
  },
  {
    "text": "life address kernel will panic so this way is not very stable",
    "start": "800880",
    "end": "808560"
  },
  {
    "text": "when i debug the code of a security versa and notice that that they write 20",
    "start": "809360",
    "end": "814959"
  },
  {
    "text": "primitive fields sometimes i don't know why then i checked the implementation of",
    "start": "814959",
    "end": "821360"
  },
  {
    "text": "rating it is based on set packet info the code is in ip6",
    "start": "821360",
    "end": "828320"
  },
  {
    "text": "output the data we write to kernel is actually a packet info structure the",
    "start": "828320",
    "end": "834959"
  },
  {
    "text": "first 16 bytes is an ip address the last four",
    "start": "834959",
    "end": "840160"
  },
  {
    "text": "bytes is a interface index but there is a check about the the",
    "start": "840160",
    "end": "846320"
  },
  {
    "text": "interface index it must be less than a rf indexed value",
    "start": "846320",
    "end": "853279"
  },
  {
    "text": "the value is the net interface count the system has i don't know what the exact",
    "start": "853279",
    "end": "860720"
  },
  {
    "text": "the exact value it is but it must be a small integer",
    "start": "860720",
    "end": "866399"
  },
  {
    "text": "likely one two all three so it's now clear that the 20 bytes we passed into",
    "start": "866399",
    "end": "874320"
  },
  {
    "text": "kernel must end with a small integer and i think 0 is the best value",
    "start": "874320",
    "end": "881120"
  },
  {
    "text": "then we know that red 20 is not an arbitrary right there is a limitation we",
    "start": "881120",
    "end": "887519"
  },
  {
    "text": "can only read 6 16 byte arbitrary data plus 4 by 0s of course we can still use",
    "start": "887519",
    "end": "895360"
  },
  {
    "text": "this red kernel data but it will smash the kernel object",
    "start": "895360",
    "end": "900480"
  },
  {
    "text": "sometimes leading to chrono panic",
    "start": "900480",
    "end": "905199"
  },
  {
    "text": "so there is limitations the right attention is still very very very useful",
    "start": "905680",
    "end": "912000"
  },
  {
    "text": "it gives us a very good starting point we must build a new",
    "start": "912000",
    "end": "918000"
  },
  {
    "text": "and stable kernel regret primitives using read 20 and red 20 we already have",
    "start": "918000",
    "end": "925920"
  },
  {
    "text": "before we had tlp0 it is the most perfect way to achieve kernel rewrite",
    "start": "925920",
    "end": "932720"
  },
  {
    "text": "but now due to the tlp-0 hardening it is nearly impossible to access kernel tasks",
    "start": "932720",
    "end": "939600"
  },
  {
    "text": "from user space we can to find an alternative to tlp 0.",
    "start": "939600",
    "end": "945360"
  },
  {
    "text": "we really need a currently right ability in post-export state but how",
    "start": "945360",
    "end": "951839"
  },
  {
    "text": "and the key idea is that we can find out our kernel objects that can be accessed",
    "start": "951839",
    "end": "958399"
  },
  {
    "text": "from user space easily and has specific interaction with the user speeds",
    "start": "958399",
    "end": "964800"
  },
  {
    "text": "like transferring data to and from kernel then we can use the right attendee to",
    "start": "964800",
    "end": "971040"
  },
  {
    "text": "overwrite the objects control the read write address transform it to a new kernel read writer",
    "start": "971040",
    "end": "978720"
  },
  {
    "text": "primitive but the question is which kernel object",
    "start": "978720",
    "end": "986000"
  },
  {
    "text": "is the suitable one well i have reader people exploiting io",
    "start": "986000",
    "end": "991680"
  },
  {
    "text": "surface 0 by chance the author is kenyan inspired by this paper it seems that the",
    "start": "991680",
    "end": "998720"
  },
  {
    "text": "key object io surface is a good candidate if you are familiar with ios",
    "start": "998720",
    "end": "1005199"
  },
  {
    "text": "kernel exploits you must be familiar with io service researchers often use io surface to do",
    "start": "1005199",
    "end": "1012639"
  },
  {
    "text": "kernel heap spree leakage kernel memory info or ford kernel objects",
    "start": "1012639",
    "end": "1018720"
  },
  {
    "text": "then reliance on the flexible gate set value external methods of io surface",
    "start": "1018720",
    "end": "1025678"
  },
  {
    "text": "in addition to this our surface has lots of other external methods as we expected",
    "start": "1025679",
    "end": "1033600"
  },
  {
    "text": "we can really build a new kernel redirect primitives on top of these",
    "start": "1033600",
    "end": "1038880"
  },
  {
    "text": "external methods before discussing that let's take a quick look at how io",
    "start": "1038880",
    "end": "1046000"
  },
  {
    "text": "service works in user space we use api's exported by",
    "start": "1046000",
    "end": "1052880"
  },
  {
    "text": "io surface diy life to interact with io surface and use surface id to specify which io",
    "start": "1052880",
    "end": "1061120"
  },
  {
    "text": "surface we want to operate but in kernel it is a bit complicated",
    "start": "1061120",
    "end": "1068160"
  },
  {
    "text": "this figure tries to show how the io surface looks like in kernel memory",
    "start": "1068160",
    "end": "1073440"
  },
  {
    "text": "the surface root user client use the surface id as an index to find",
    "start": "1073440",
    "end": "1080720"
  },
  {
    "text": "the correct io surface but kernel don't operate our surface directly it uses an io service client as",
    "start": "1080720",
    "end": "1089520"
  },
  {
    "text": "an agent every request from user sends to service",
    "start": "1089520",
    "end": "1094640"
  },
  {
    "text": "client first then will be redirected to our service object",
    "start": "1094640",
    "end": "1100240"
  },
  {
    "text": "actually these are not important i just want to explain that",
    "start": "1100240",
    "end": "1107039"
  },
  {
    "text": "if we can control any about structures in this team we can directly influence",
    "start": "1107039",
    "end": "1113600"
  },
  {
    "text": "the behavior of io surface operations",
    "start": "1113600",
    "end": "1118480"
  },
  {
    "text": "now let's see some special surface external methods the first one is the set indexed",
    "start": "1119039",
    "end": "1127120"
  },
  {
    "text": "timestamp this is the field code from ide pro",
    "start": "1127120",
    "end": "1133440"
  },
  {
    "text": "through this method we can write a timestamp to the address specified by a",
    "start": "1133440",
    "end": "1139280"
  },
  {
    "text": "field in the io surface object this field is is stored and offset of hex",
    "start": "1139280",
    "end": "1146919"
  },
  {
    "text": "360. so can control field 360 of io surface we",
    "start": "1146919",
    "end": "1154000"
  },
  {
    "text": "get a 8 8 byte light of course we can use the red 20",
    "start": "1154000",
    "end": "1160160"
  },
  {
    "text": "primitives to override this field to obtain a new kernel right primitive",
    "start": "1160160",
    "end": "1166080"
  },
  {
    "text": "and what's more in the question we do not touch any other class field so there",
    "start": "1166080",
    "end": "1172320"
  },
  {
    "text": "is no side effect with the extra 4 byte zeros right but actually i didn't try",
    "start": "1172320",
    "end": "1180160"
  },
  {
    "text": "this way i will talk about it later and there is another surface external",
    "start": "1180160",
    "end": "1187280"
  },
  {
    "text": "method get ycbcr matrix",
    "start": "1187280",
    "end": "1192400"
  },
  {
    "text": "we can use this method to read the field before our i o surface from the from",
    "start": "1192400",
    "end": "1199120"
  },
  {
    "text": "kernel this time if we can control surface pointer we get a 4 byte read and there",
    "start": "1199120",
    "end": "1206159"
  },
  {
    "text": "is no side effect too now with the two external methods",
    "start": "1206159",
    "end": "1211440"
  },
  {
    "text": "exported by our surface we obtain both new red and new read primitive",
    "start": "1211440",
    "end": "1219039"
  },
  {
    "text": "but we can't build these new primitives based on our",
    "start": "1219039",
    "end": "1224400"
  },
  {
    "text": "unstable relativity all the new ones will be unstable too",
    "start": "1224400",
    "end": "1229760"
  },
  {
    "text": "we must use another way to modify the class field or kernel memory",
    "start": "1229760",
    "end": "1236640"
  },
  {
    "text": "to modify to modify kernel memory i think the most convenient way is the shared memory",
    "start": "1237120",
    "end": "1244880"
  },
  {
    "text": "this time i choose pack so pipe is not a real shared memory it",
    "start": "1244880",
    "end": "1250400"
  },
  {
    "text": "works like a real shared memory when you write data in to pipe the data",
    "start": "1250400",
    "end": "1256960"
  },
  {
    "text": "will be cached into a block of kernel memory name the pipe buffer as if you",
    "start": "1256960",
    "end": "1263039"
  },
  {
    "text": "read something to kernel directly so if i can move io surface",
    "start": "1263039",
    "end": "1268960"
  },
  {
    "text": "related objects into pipe buffer i could modify them freely",
    "start": "1268960",
    "end": "1275200"
  },
  {
    "text": "actually it is easy to achieve this after after all we already have a",
    "start": "1275200",
    "end": "1281280"
  },
  {
    "text": "residential primitive just over red surface client re-pointer",
    "start": "1281280",
    "end": "1287520"
  },
  {
    "text": "in root user client force is pointing to memory in pipe buffer then you can fold surface objects",
    "start": "1287520",
    "end": "1295600"
  },
  {
    "text": "as you want and now you can read write arbitrary kernel memory using a thick surface",
    "start": "1295600",
    "end": "1302320"
  },
  {
    "text": "pointer and the figure field 360. besides pipe there is other batteries to",
    "start": "1302320",
    "end": "1310720"
  },
  {
    "text": "create a shared memory with the kernel but i'm lazy i've just simply reused the",
    "start": "1310720",
    "end": "1316640"
  },
  {
    "text": "code learning from brandon users watchers line",
    "start": "1316640",
    "end": "1321760"
  },
  {
    "text": "the implementation of new kernel rewrite primitive is simple",
    "start": "1321760",
    "end": "1327440"
  },
  {
    "text": "using read 20 to find out the memory address or pack buffer",
    "start": "1327440",
    "end": "1332720"
  },
  {
    "text": "then assign the address to service clients re using red 20 after that we",
    "start": "1332720",
    "end": "1339840"
  },
  {
    "text": "can specify read write address by a path right then call the gate and set external",
    "start": "1339840",
    "end": "1347280"
  },
  {
    "text": "methods of io surface to achieve arbitrary kernel result this is stable and they will never panic",
    "start": "1347280",
    "end": "1355039"
  },
  {
    "text": "the kernel now we have a good alternative to tfp 0",
    "start": "1355039",
    "end": "1360559"
  },
  {
    "text": "and we could share the primitive with other process with the daemon",
    "start": "1360559",
    "end": "1366960"
  },
  {
    "text": "since we already have the ability to do kernel rewrite it's time to do something useful",
    "start": "1366960",
    "end": "1373760"
  },
  {
    "text": "that is the jailbreak thing my goal is simple i want i just want to",
    "start": "1373760",
    "end": "1380400"
  },
  {
    "text": "execute arbitrary unauthorized binary it is somehow equivalent to take full",
    "start": "1380400",
    "end": "1386480"
  },
  {
    "text": "control of my iphone that's enough it is better to",
    "start": "1386480",
    "end": "1392559"
  },
  {
    "text": "stand on the shoulders of a giants to do something so i just pulled the code of free the",
    "start": "1392559",
    "end": "1398400"
  },
  {
    "text": "sandbox to secure versa next i will discuss the troubles i met",
    "start": "1398400",
    "end": "1404400"
  },
  {
    "text": "in the protein progress and how to solve them",
    "start": "1404400",
    "end": "1409519"
  },
  {
    "text": "to execute a binary we need the fork erc cisco combined nation",
    "start": "1409600",
    "end": "1416640"
  },
  {
    "text": "but it is disallowed by sandbox so the first thing is to",
    "start": "1416640",
    "end": "1422320"
  },
  {
    "text": "disable sandbox it can be done by nullifying the process sandbox slot in mac label but starting",
    "start": "1422320",
    "end": "1430799"
  },
  {
    "text": "from ios 14 there is a pack mark on the pointer as",
    "start": "1430799",
    "end": "1436000"
  },
  {
    "text": "we said earlier we can't touch any bit of a packed pack protected pointer so can we modify",
    "start": "1436000",
    "end": "1444000"
  },
  {
    "text": "the sandbox slot to now pointer the answer is yes actually",
    "start": "1444000",
    "end": "1450240"
  },
  {
    "text": "there is a flow in data pack let's see the disassembly code function",
    "start": "1450240",
    "end": "1455360"
  },
  {
    "text": "not clickable get there is a cbz instruction if it is an",
    "start": "1455360",
    "end": "1460559"
  },
  {
    "text": "out pointer the function just return now the packed pointer will",
    "start": "1460559",
    "end": "1466720"
  },
  {
    "text": "not be verified at all if the pointer is now for performance considerations now",
    "start": "1466720",
    "end": "1473200"
  },
  {
    "text": "pointers are handled especially in pack we usually use memory set 0 to",
    "start": "1473200",
    "end": "1479919"
  },
  {
    "text": "initialize objects and the impact to every now pointer will bring loss over overhead",
    "start": "1479919",
    "end": "1487600"
  },
  {
    "text": "so in most cases we can nullify a data pointer safely",
    "start": "1487600",
    "end": "1494080"
  },
  {
    "text": "now we are out of sandbox but the emi will stop us to execute unsigned code",
    "start": "1495520",
    "end": "1503039"
  },
  {
    "text": "we have two choices inject cd hash to each cluster cache or bypass amf id check",
    "start": "1503039",
    "end": "1512240"
  },
  {
    "text": "but injecting hashes into trust catch needs kernel code execution",
    "start": "1512240",
    "end": "1518799"
  },
  {
    "text": "it is somewhat difficult ams id is an user space demon it is easier to",
    "start": "1518799",
    "end": "1526480"
  },
  {
    "text": "take control our user space process then kernel code exclusion",
    "start": "1526480",
    "end": "1532559"
  },
  {
    "text": "so i will try to force amf id to be happy as the free sandbox starts",
    "start": "1532559",
    "end": "1541520"
  },
  {
    "text": "suppose we want to run signed but unauthorized the binary name that it out",
    "start": "1541520",
    "end": "1547919"
  },
  {
    "text": "a request will be sent to amf id emf id demon realize this is not a legal",
    "start": "1547919",
    "end": "1555279"
  },
  {
    "text": "program then we'll stop it running now that we have currently right we can",
    "start": "1555279",
    "end": "1562240"
  },
  {
    "text": "try to turn our our own process into a privileged process",
    "start": "1562240",
    "end": "1567840"
  },
  {
    "text": "get the task port of amf id and the set exec exception port for it",
    "start": "1567840",
    "end": "1574480"
  },
  {
    "text": "that is a debugger for emf id then we are able to control the behavior",
    "start": "1574480",
    "end": "1581279"
  },
  {
    "text": "of amf id after that we can intercept the request",
    "start": "1581279",
    "end": "1586559"
  },
  {
    "text": "and hijack a worried cd hash for it out force amf id to believe it out is a",
    "start": "1586559",
    "end": "1594720"
  },
  {
    "text": "legal program finally our goal running on authorized",
    "start": "1594720",
    "end": "1599840"
  },
  {
    "text": "binary is achieved to get the task port of amf id",
    "start": "1599840",
    "end": "1606640"
  },
  {
    "text": "we can use api task for pid but kernel states that",
    "start": "1606640",
    "end": "1612400"
  },
  {
    "text": "only process assigned with the entitlement tasker for pid allow can cross this api",
    "start": "1612400",
    "end": "1619840"
  },
  {
    "text": "increase the sandbox code the entitled self in the following way",
    "start": "1619840",
    "end": "1625440"
  },
  {
    "text": "find out a process which has the entitlement we need and then deal is",
    "start": "1625440",
    "end": "1631360"
  },
  {
    "text": "your credit and assign the credit to self-process then",
    "start": "1631360",
    "end": "1636640"
  },
  {
    "text": "our process has the same intelligence and we are able to call task for prd on",
    "start": "1636640",
    "end": "1642880"
  },
  {
    "text": "af on amf id now but in ios 14 there is a different",
    "start": "1642880",
    "end": "1650240"
  },
  {
    "text": "situation almost everything is protected by pack",
    "start": "1650240",
    "end": "1656799"
  },
  {
    "text": "we can't steal your cred from other process and we can't still see our label",
    "start": "1656799",
    "end": "1662880"
  },
  {
    "text": "or anything else i had no choice but to look at the low level data structure",
    "start": "1662880",
    "end": "1669679"
  },
  {
    "text": "finally i found that intelligence are stored in the in os dictionary i'm lucky",
    "start": "1669679",
    "end": "1676159"
  },
  {
    "text": "that the dictator increase is not packed so i had a chance to replace the key",
    "start": "1676159",
    "end": "1682159"
  },
  {
    "text": "value pairs in the dictionary and the essential intelligence to make",
    "start": "1682159",
    "end": "1687760"
  },
  {
    "text": "kernel believe that i'm a good process but this time i don't want steel or",
    "start": "1687760",
    "end": "1695120"
  },
  {
    "text": "borrow entitlements from others using set value interface we can attach",
    "start": "1695120",
    "end": "1701360"
  },
  {
    "text": "properties to an io surface they are stored in a dictionary",
    "start": "1701360",
    "end": "1706640"
  },
  {
    "text": "associated with the surface as we know processing elements are stored in a",
    "start": "1706640",
    "end": "1712880"
  },
  {
    "text": "dictionary too so we can put all the inherents we need into the our surface",
    "start": "1712880",
    "end": "1719760"
  },
  {
    "text": "values in advance that is we build an intelligence library for ourselves",
    "start": "1719760",
    "end": "1726080"
  },
  {
    "text": "when i need a new entitlement i just take it directly from here",
    "start": "1726080",
    "end": "1731760"
  },
  {
    "text": "i'm not sure if anyone has used this method before maybe this way is a small",
    "start": "1731760",
    "end": "1737679"
  },
  {
    "text": "innovation so i didn't actually defeat this pack in fact i just found a way to",
    "start": "1737679",
    "end": "1745360"
  },
  {
    "text": "avoid it moreover i'd like to mention one more thing our surface is really a trailer",
    "start": "1745360",
    "end": "1753440"
  },
  {
    "text": "it has already helped us to implement hips free fake object building kernel",
    "start": "1753440",
    "end": "1759760"
  },
  {
    "text": "read right and now it helps us again with the entitlement hack",
    "start": "1759760",
    "end": "1765679"
  },
  {
    "text": "io service is really a powerful helper for exploit development",
    "start": "1765679",
    "end": "1772240"
  },
  {
    "text": "ok we successfully go to the task port of amf id",
    "start": "1772880",
    "end": "1778399"
  },
  {
    "text": "next let's do the real amf id bypass and there are three weapons we can use",
    "start": "1778399",
    "end": "1786080"
  },
  {
    "text": "task set exception port we am red and the thread set stick",
    "start": "1786080",
    "end": "1791440"
  },
  {
    "text": "we can bypass amif id with the following steps note that mis validator signature and",
    "start": "1791440",
    "end": "1799279"
  },
  {
    "text": "copy info is the executable file validation procedure we",
    "start": "1799279",
    "end": "1805480"
  },
  {
    "text": "redirect it to involved address if a mfi request comes that's function",
    "start": "1805480",
    "end": "1813200"
  },
  {
    "text": "will through an exception we can't the exception hijack the will be simpler process",
    "start": "1813200",
    "end": "1820399"
  },
  {
    "text": "calculate the writer cd hash for the executable file put the result to amf id",
    "start": "1820399",
    "end": "1827360"
  },
  {
    "text": "memory to satisfy amfa check",
    "start": "1827360",
    "end": "1832480"
  },
  {
    "text": "the last step use the thread set state to set the pc register",
    "start": "1832480",
    "end": "1838080"
  },
  {
    "text": "on the original return address furthermore we are talking pack device",
    "start": "1838080",
    "end": "1844320"
  },
  {
    "text": "so we need to sign the address first finally resume amif id this am fid",
    "start": "1844320",
    "end": "1851520"
  },
  {
    "text": "bypass strategy works fine on ios 13 but fails on ios 14.",
    "start": "1851520",
    "end": "1858080"
  },
  {
    "text": "well this is the sad let's look into it",
    "start": "1858080",
    "end": "1863278"
  },
  {
    "text": "with the crash log we can confirm that amf id stops and wear the address",
    "start": "1863440",
    "end": "1870960"
  },
  {
    "text": "so the problem is here setting pc register doesn't work as",
    "start": "1870960",
    "end": "1876480"
  },
  {
    "text": "expected let's check the kernel code to see what",
    "start": "1876480",
    "end": "1881679"
  },
  {
    "text": "a thread set state does i found that thread state is signed in",
    "start": "1881679",
    "end": "1887279"
  },
  {
    "text": "user space but in kernel it is stored in raw format so thread sets data will use",
    "start": "1887279",
    "end": "1893840"
  },
  {
    "text": "target threads iak to decode the pc register is specified",
    "start": "1893840",
    "end": "1900159"
  },
  {
    "text": "from the code we know that gopid is the so-called pack iak",
    "start": "1900159",
    "end": "1906480"
  },
  {
    "text": "then i read the emf id's gop pid back to user space and compared it",
    "start": "1906480",
    "end": "1913120"
  },
  {
    "text": "with our own wpid they are different and remember that we said ios 14",
    "start": "1913120",
    "end": "1920559"
  },
  {
    "text": "introduces user speeds pack hardly one process cannot hold function",
    "start": "1920559",
    "end": "1926240"
  },
  {
    "text": "pointers in others process this is the principle of it",
    "start": "1926240",
    "end": "1931840"
  },
  {
    "text": "different process assigns a different gop pid",
    "start": "1931840",
    "end": "1937279"
  },
  {
    "text": "so sign an oauth a packed pointer with different iap",
    "start": "1937279",
    "end": "1942480"
  },
  {
    "text": "that's why thread said street field amf id got involved pc register to make it",
    "start": "1942480",
    "end": "1950320"
  },
  {
    "text": "works on ios 14 we must assign the pc register with emif ids iac",
    "start": "1950320",
    "end": "1957360"
  },
  {
    "text": "but how there is another function",
    "start": "1957360",
    "end": "1962640"
  },
  {
    "text": "thread gate state contrary to set speed it reads thread speed from kernel stack",
    "start": "1962640",
    "end": "1969440"
  },
  {
    "text": "before returning the state to user space thread get state or sign pc register",
    "start": "1969440",
    "end": "1975679"
  },
  {
    "text": "with target threads gop pid so there are two functions about thread",
    "start": "1975679",
    "end": "1982240"
  },
  {
    "text": "state one for earth one for sign they make up a functional loop of course",
    "start": "1982240",
    "end": "1989679"
  },
  {
    "text": "we can both use and sign pc register of our own thread but the amif id by pass",
    "start": "1989679",
    "end": "1997200"
  },
  {
    "text": "needs a return address correctly signed by amf ids iip",
    "start": "1997200",
    "end": "2002240"
  },
  {
    "text": "now that we found a graphics signing method if we can steal emf ids iac override our",
    "start": "2002240",
    "end": "2010559"
  },
  {
    "text": "threads iaek visit we may achieve this goal",
    "start": "2010559",
    "end": "2016559"
  },
  {
    "text": "i create a dummy thread and suspend it so i can manipulate freely",
    "start": "2017440",
    "end": "2024720"
  },
  {
    "text": "target pc is the address that we want emf id running to we strip it to a row",
    "start": "2024720",
    "end": "2033200"
  },
  {
    "text": "pointer sign it with iap and then set it to the dummy thread thread",
    "start": "2033200",
    "end": "2040000"
  },
  {
    "text": "this is our own thread so there is no problem with this operation next i",
    "start": "2040000",
    "end": "2047360"
  },
  {
    "text": "copy the dopp id from ams id thread to our thread now we call thread get state",
    "start": "2047360",
    "end": "2055118"
  },
  {
    "text": "the pc will be signed with the new jlp id finally we get a correctly signed pc",
    "start": "2055119",
    "end": "2062800"
  },
  {
    "text": "register and we can set this value to amf id this time",
    "start": "2062800",
    "end": "2068878"
  },
  {
    "text": "the amf id will return a successful validation result as we want the emf id",
    "start": "2068879",
    "end": "2076000"
  },
  {
    "text": "bypass is done when i was studying thread state i found",
    "start": "2076000",
    "end": "2082398"
  },
  {
    "text": "a microcore by accident thread convert thread state",
    "start": "2082399",
    "end": "2087679"
  },
  {
    "text": "is code as shown below if we specify the parameter direction to",
    "start": "2087679",
    "end": "2093040"
  },
  {
    "text": "from self it will help us convert our own thread state to target thread user",
    "start": "2093040",
    "end": "2099359"
  },
  {
    "text": "representation this is exactly what we want this is the second way that can be used",
    "start": "2099359",
    "end": "2107440"
  },
  {
    "text": "to bypass user space pack harmony and what's more in this way no kernel",
    "start": "2107440",
    "end": "2113280"
  },
  {
    "text": "read write required if you can get targets thread port",
    "start": "2113280",
    "end": "2119119"
  },
  {
    "text": "it's a it's a perfect bypass the code is simple just assign target pc",
    "start": "2119119",
    "end": "2126400"
  },
  {
    "text": "with our own iek then convert it to am fid's signed pc by the thread state",
    "start": "2126400",
    "end": "2134320"
  },
  {
    "text": "converting api about this api i think it is useless",
    "start": "2134320",
    "end": "2140240"
  },
  {
    "text": "except one scenario when you intend to debug a process that",
    "start": "2140240",
    "end": "2146079"
  },
  {
    "text": "doesn't belong to you but it is really helpful to bypass user speeds",
    "start": "2146079",
    "end": "2152000"
  },
  {
    "text": "pack handling i guess maybe ample will delete it someday for security",
    "start": "2152000",
    "end": "2159839"
  },
  {
    "text": "now we have two ways to sign a pointer with other process iak it's time to",
    "start": "2161599",
    "end": "2167599"
  },
  {
    "text": "complete the emf id bypass let's repair the last",
    "start": "2167599",
    "end": "2173359"
  },
  {
    "text": "step put the correctly signed the return address into amf id as we expected a",
    "start": "2173359",
    "end": "2182000"
  },
  {
    "text": "mfid bypass on ios 14 is working we are able to execute",
    "start": "2182000",
    "end": "2188560"
  },
  {
    "text": "on authorize the binary okay",
    "start": "2188560",
    "end": "2194160"
  },
  {
    "text": "let me summarize ulta and i have talked today with this image it gives an overview of how to execute",
    "start": "2194160",
    "end": "2202160"
  },
  {
    "text": "or authorize the code in ios 14 by exploiting a risk condition bar",
    "start": "2202160",
    "end": "2208560"
  },
  {
    "text": "the red part is the outstanding exploit written by modern poner the green part is my ios 14",
    "start": "2208560",
    "end": "2217119"
  },
  {
    "text": "learning journey maybe the stable kernel rewrite primitive built by ios by io surface",
    "start": "2217119",
    "end": "2225119"
  },
  {
    "text": "hack is the most helpful one you can find the full exploit code you",
    "start": "2225119",
    "end": "2231280"
  },
  {
    "text": "might be tough the link is given in the bottom actually the code is the better way to",
    "start": "2231280",
    "end": "2238400"
  },
  {
    "text": "express my to express my thought",
    "start": "2238400",
    "end": "2243920"
  },
  {
    "text": "last i think ios 14 is the most secular ios ever",
    "start": "2244000",
    "end": "2249440"
  },
  {
    "text": "everything has changed among the new mitigations key keep isolation and the data pack are",
    "start": "2249440",
    "end": "2256400"
  },
  {
    "text": "the outstanding lens one kills most vulnerabilities well",
    "start": "2256400",
    "end": "2261599"
  },
  {
    "text": "clear the most exploited primitives with high quality bugs like cve 2021",
    "start": "2261599",
    "end": "2269359"
  },
  {
    "text": "1782 we are still able to prune ios kernel",
    "start": "2269359",
    "end": "2274480"
  },
  {
    "text": "jailbreak is unstoppable but it is indeed harder and harder than before",
    "start": "2274480",
    "end": "2281119"
  },
  {
    "text": "i learned everything from the community security gives me the opportunity to",
    "start": "2281119",
    "end": "2287040"
  },
  {
    "text": "contribute to iowa's hack community so i make a tqu pre-jailbreak fully open",
    "start": "2287040",
    "end": "2293760"
  },
  {
    "text": "source now hope this will give some inspiration to researchers",
    "start": "2293760",
    "end": "2301280"
  },
  {
    "text": "okay thank you for watching that's all on my talk today i hope you enjoyed it",
    "start": "2301440",
    "end": "2308240"
  },
  {
    "text": "you can find the source code on my github and if you have questions you can",
    "start": "2308240",
    "end": "2313920"
  },
  {
    "text": "contact me by this email thank you",
    "start": "2313920",
    "end": "2319880"
  }
]