[
  {
    "text": "you are here for the last Talk of the day using undocumented CPU Behavior to",
    "start": "160",
    "end": "5440"
  },
  {
    "text": "see into kernel mode and break kslr in the process uh put on by Anders Foe and",
    "start": "5440",
    "end": "11799"
  },
  {
    "text": "Daniel Gru Andre Daniel take it away okay thank you um this talk is about",
    "start": "11799",
    "end": "18039"
  },
  {
    "text": "using undocumented CPU Behavior to see into kernel mode and break krr in the process um about a year ago I Was",
    "start": "18039",
    "end": "25599"
  },
  {
    "text": "preparing a talk for black hat 2015 about detecting rammer uh when Daniel",
    "start": "25599",
    "end": "30800"
  },
  {
    "text": "and his team came up with the way to do rammer and JavaScript um that marked the first time",
    "start": "30800",
    "end": "37840"
  },
  {
    "text": "that Daniels and my research collided uh it has collided a lot the last year and",
    "start": "37840",
    "end": "43800"
  },
  {
    "text": "finally we decided that it might be a good idea to cooperate instead of competing and what you're about to see",
    "start": "43800",
    "end": "50199"
  },
  {
    "text": "here is uh the first result of our cooperation and I hope you like",
    "start": "50199",
    "end": "55399"
  },
  {
    "text": "it so before we actually start with the presentation on just a couple of things to set straight this talk is about a",
    "start": "55399",
    "end": "62840"
  },
  {
    "text": "class of microarchitectural attacks it's um not about software buxs um it is",
    "start": "62840",
    "end": "69240"
  },
  {
    "text": "however about how CBU design can be used as an attack vctor and um with",
    "start": "69240",
    "end": "76560"
  },
  {
    "text": "microarchitectural attack we mean it's not about the instruction set architecture which is what Intel",
    "start": "76560",
    "end": "83079"
  },
  {
    "text": "promises to software developers that they'll keep it's about how the instruction set architecture is",
    "start": "83079",
    "end": "88960"
  },
  {
    "text": "implemented that is the level below that um we will be focusing on Intel x86 64",
    "start": "88960",
    "end": "96880"
  },
  {
    "text": "uh lots of the stuff that we'll be doing applies to other architectures as well uh",
    "start": "96880",
    "end": "103079"
  },
  {
    "text": "so um what we want you to take away from this talk is on a macro level that CPU",
    "start": "103079",
    "end": "108520"
  },
  {
    "text": "design is security relevant and on the micro level we'll want to make clear",
    "start": "108520",
    "end": "113640"
  },
  {
    "text": "that the prefetch instruction leaks important information and that we can use this",
    "start": "113640",
    "end": "118840"
  },
  {
    "text": "information to locate a driver in Co mode that is defeat KR SLR and we can",
    "start": "118840",
    "end": "124960"
  },
  {
    "text": "translate virtual addresses to physical addresses and we can use this for other",
    "start": "124960",
    "end": "130200"
  },
  {
    "text": "attacks so this is a short overview of the organization of this talk I will not read this slide out alloud so spare you",
    "start": "130200",
    "end": "138360"
  },
  {
    "text": "that um turn through the introduction um",
    "start": "138360",
    "end": "143480"
  },
  {
    "text": "we found something in an Intel manual that read something like this uh using the prefetch instruction is recommended",
    "start": "143480",
    "end": "150080"
  },
  {
    "text": "only if data does not fit in the cache use of software prefit should be limited to memory addresses that are managed or",
    "start": "150080",
    "end": "156480"
  },
  {
    "text": "owned within the application context prefetching the address that are not mapped to physical Pages can experience",
    "start": "156480",
    "end": "162680"
  },
  {
    "text": "non-deterministic performance penalty for example specifying a null pointer as",
    "start": "162680",
    "end": "168000"
  },
  {
    "text": "a as an address for prefetch can cause long delays um what somebody like Daniel",
    "start": "168000",
    "end": "174200"
  },
  {
    "text": "reads when he sees this is please only use the prefet as Intel intents orse",
    "start": "174200",
    "end": "180000"
  },
  {
    "text": "inel will be angry and there is no reason why anybody would measure the execution",
    "start": "180000",
    "end": "186120"
  },
  {
    "text": "time um so short who am I my name is Andis I'm a principal security",
    "start": "186120",
    "end": "192480"
  },
  {
    "text": "researcher for G data Advanced analytics I've been playing with malware since 992 and you can reach me on Twitter or by",
    "start": "192480",
    "end": "200319"
  },
  {
    "text": "email hello from my side uh my name is Daniel Cruz and I'm a PhD student from Gratz University of Technology where we",
    "start": "200319",
    "end": "207760"
  },
  {
    "text": "have also uh worked on this project um later on recently I joined Microsoft to",
    "start": "207760",
    "end": "213439"
  },
  {
    "text": "do an internship in Cambridge UK you can also reach me on Twitter or via",
    "start": "213439",
    "end": "219959"
  },
  {
    "text": "email uh yeah um so this was a joint work with uh",
    "start": "219959",
    "end": "227439"
  },
  {
    "text": "some other researchers from too Gratz Clementine Maurice morit lip and Stefan mangard who are unfortunately not here",
    "start": "227439",
    "end": "233599"
  },
  {
    "text": "uh but it was a uh group collaboration and team effort",
    "start": "233599",
    "end": "239959"
  },
  {
    "text": "okay let's start right away with some background on the memory subsystem so for the first part uh we",
    "start": "239959",
    "end": "248480"
  },
  {
    "text": "want to talk about CPU caches how CPU caches work um you have relatively fast",
    "start": "248480",
    "end": "254360"
  },
  {
    "text": "CPU nowadays in your computer but the uh DRM is still very slow uh because that's",
    "start": "254360",
    "end": "259880"
  },
  {
    "text": "how DRM works and there is some idea to to make the accesses to your memory",
    "start": "259880",
    "end": "266520"
  },
  {
    "text": "faster because you need a lot of memory but only need a small fraction of the memory uh in a high frequency uh the",
    "start": "266520",
    "end": "273440"
  },
  {
    "text": "idea is to buffer the frequently used memory in the CPU in some smaller but",
    "start": "273440",
    "end": "278960"
  },
  {
    "text": "faster memory locations every memory reference that any program in your system does goes",
    "start": "278960",
    "end": "285400"
  },
  {
    "text": "through the cache usually and it will be fast because it's buffered in the",
    "start": "285400",
    "end": "291400"
  },
  {
    "text": "cache the cach is entirely transparent to the operating system and program so you won't notice that the uh that the",
    "start": "291400",
    "end": "299240"
  },
  {
    "text": "address is actually cached uh except for one uh artifact and that is the excess",
    "start": "299240",
    "end": "306080"
  },
  {
    "text": "latency so if you measure the execution time of a memory uh operation then you",
    "start": "306080",
    "end": "312240"
  },
  {
    "text": "will see that the excess latency for a cach hit is much smaller than for a cash",
    "start": "312240",
    "end": "317600"
  },
  {
    "text": "Miss and here you see that for this particular CPU uh the cash hits were",
    "start": "317600",
    "end": "323120"
  },
  {
    "text": "around 70 Cycles whereas the cash misses were around 220 Cycles most of the time",
    "start": "323120",
    "end": "331639"
  },
  {
    "text": "if we look at the structure of caches in modern CPUs in detail uh today you have",
    "start": "332280",
    "end": "337720"
  },
  {
    "text": "CPUs with multiple cores and each of those cores has private caches the level",
    "start": "337720",
    "end": "342880"
  },
  {
    "text": "one and the level two caches and they all together have one big shared cache",
    "start": "342880",
    "end": "348120"
  },
  {
    "text": "the last level cache the level three cache which is up to several megabytes and the small caches the level one cache",
    "start": "348120",
    "end": "354960"
  },
  {
    "text": "for instance is it is only like 32 kilobytes of data cache and 32 kilobytes",
    "start": "354960",
    "end": "360240"
  },
  {
    "text": "of instruction cache and there is a reason for that and this is that you uh want to work with virtual addresses here",
    "start": "360240",
    "end": "367759"
  },
  {
    "text": "the level two cach is larger and also the last level cach is larger there you have to work with physical indexes to",
    "start": "367759",
    "end": "375599"
  },
  {
    "text": "find the right location in the cache um and the the right cache set to store the",
    "start": "375599",
    "end": "381440"
  },
  {
    "text": "data that you want to load from dram there is a fixed mapping from",
    "start": "381440",
    "end": "386560"
  },
  {
    "text": "physical addresses to locations in the cache and this c yeah and this mapping",
    "start": "386560",
    "end": "394080"
  },
  {
    "text": "this is fixed in the CPU uh so if you have one memory location it will always go to the same memory location in the",
    "start": "394080",
    "end": "402440"
  },
  {
    "text": "cache there are two operations basically to manipulate the uh cach utilization uh",
    "start": "402440",
    "end": "410479"
  },
  {
    "text": "to optimize the cach usage that is first the prefetch instruction uh it is sort",
    "start": "410479",
    "end": "415919"
  },
  {
    "text": "of a hint to the CPU where you can tell the CPU please load this into the cache I think I might need this in the near",
    "start": "415919",
    "end": "422720"
  },
  {
    "text": "future uh and there is the seal flush instruction which basically does the counterpart uh it tells the CPU I don't",
    "start": "422720",
    "end": "429319"
  },
  {
    "text": "need this part throw it out of the cache or rather uh for coherency reasons you",
    "start": "429319",
    "end": "434560"
  },
  {
    "text": "can also use the Cal flash instruction to to tell the CPU uh I'm not sure this value in the CPU is still up to date",
    "start": "434560",
    "end": "441960"
  },
  {
    "text": "please flush it to the memory and then reload it from the memory on the next",
    "start": "441960",
    "end": "447280"
  },
  {
    "text": "exess both instructions are based on on Virtual addresses so they need to perform somehow this translation from",
    "start": "447280",
    "end": "453879"
  },
  {
    "text": "virtual addresses to physical addresses because the last level cache is pH physically indexed you can remember that",
    "start": "453879",
    "end": "460120"
  },
  {
    "text": "for later because we might need that later on when we talk about prefet",
    "start": "460120",
    "end": "465479"
  },
  {
    "text": "instructions actually there are five prefetch instructions uh first we have the uh prefetch t0 to",
    "start": "465479",
    "end": "472879"
  },
  {
    "text": "T2 uh which give different sort of hints um where the data should be loaded and",
    "start": "472879",
    "end": "480919"
  },
  {
    "text": "as a as a rule for the sum you can uh you can say that the t2 instruction will",
    "start": "480919",
    "end": "488039"
  },
  {
    "text": "fetch it rather to the level three cache whereas the t0 instruction will rather fetch it to a cache that is closer to",
    "start": "488039",
    "end": "495560"
  },
  {
    "text": "the execution core the prefetch NTA instruction allows you to tell the CPU",
    "start": "495560",
    "end": "501240"
  },
  {
    "text": "okay I will probably only access this data once you can throw it away afterwards but please load it into the",
    "start": "501240",
    "end": "506319"
  },
  {
    "text": "cache right now and then there is a prefetched w instruction which tells which tells the CPU yeah I'm intending",
    "start": "506319",
    "end": "512839"
  },
  {
    "text": "to write to this variable maybe but uh I'm not yeah could you please load it",
    "start": "512839",
    "end": "519000"
  },
  {
    "text": "into the cache into my local cache and maybe invalidate it for the other caches so that I can really write to it without",
    "start": "519000",
    "end": "526480"
  },
  {
    "text": "any delay the actual behavior of the prefetch instruction varies widely",
    "start": "526480",
    "end": "532480"
  },
  {
    "text": "between the different CPU models so whether t0 fetches to L3 and L1 or L3",
    "start": "532480",
    "end": "537640"
  },
  {
    "text": "and L2 and L1 um so you cannot really rely on a specific behavior but we found",
    "start": "537640",
    "end": "545399"
  },
  {
    "text": "out that this is also not necessary because we are just interested in some Corner cases the preet instructions they are",
    "start": "545399",
    "end": "553120"
  },
  {
    "text": "somewhat usual uh not only that they have to translate virtual to physical addresses uh they are unusual",
    "start": "553120",
    "end": "560480"
  },
  {
    "text": "in in two ways the first I already said they are hints so the CPU can ignore",
    "start": "560480",
    "end": "566720"
  },
  {
    "text": "them but most of the time the CPU will not ignore them um the second unusual",
    "start": "566720",
    "end": "573040"
  },
  {
    "text": "property is that it is probably one of the one of the um few instructions in",
    "start": "573040",
    "end": "579440"
  },
  {
    "text": "the uh Intel manual where it says this instruction does not perform any",
    "start": "579440",
    "end": "585399"
  },
  {
    "text": "privilege checks and it does not cause any exceptions and if you read anything in",
    "start": "585399",
    "end": "590480"
  },
  {
    "text": "the int manual and it says uh it does not cause any exceptions then this sounds a bit uh",
    "start": "590480",
    "end": "596880"
  },
  {
    "text": "dangerous so why do we actually have this address translation with the viral",
    "start": "596880",
    "end": "602160"
  },
  {
    "text": "and physical addresses if we look back back 20 or 30 years or if we look at",
    "start": "602160",
    "end": "607360"
  },
  {
    "text": "small embedded platforms we actually don't have virtual addresses we only have physical addresses and you can only",
    "start": "607360",
    "end": "615399"
  },
  {
    "text": "run like one program one system on on on this chip and you don't have any",
    "start": "615399",
    "end": "621880"
  },
  {
    "text": "isolation between different um between different threads on this",
    "start": "621880",
    "end": "627640"
  },
  {
    "text": "CPU um with the um Intel 3 386 CPU uh virtual addresses",
    "start": "627640",
    "end": "634600"
  },
  {
    "text": "have been introduced and they allow to isolate uh different different processes",
    "start": "634600",
    "end": "641040"
  },
  {
    "text": "on the same CPU by providing different address spaces to them so there is a map",
    "start": "641040",
    "end": "647079"
  },
  {
    "text": "inside your hardware and you can configure this map and you can map from",
    "start": "647079",
    "end": "652800"
  },
  {
    "text": "virtual addresses like the pointers that you usually have in your programs to real physical addresses on the hardware",
    "start": "652800",
    "end": "661240"
  },
  {
    "text": "every application has its own virtual address space because it has its own map from virtual to physical",
    "start": "661720",
    "end": "669680"
  },
  {
    "text": "memory in this map you don't you not only have the translation from virtual memory to physical memory but you also",
    "start": "669680",
    "end": "676160"
  },
  {
    "text": "have uh the privilege settings for this memory region and the Privileges are",
    "start": "676160",
    "end": "682959"
  },
  {
    "text": "then checked when you access a me an memory address in this memory",
    "start": "682959",
    "end": "688079"
  },
  {
    "text": "range the privileges are then managed by the operating system kernel so you can do this dynamically and the operating",
    "start": "688079",
    "end": "694480"
  },
  {
    "text": "system can manage what you may and may not access for instance you should not be able to access the",
    "start": "694480",
    "end": "701120"
  },
  {
    "text": "kernel the address translation on x86 looks like this so we have a four stage",
    "start": "701120",
    "end": "707000"
  },
  {
    "text": "translation it looks more complicated than it actually is because it does the same on all of the four levels so you",
    "start": "707000",
    "end": "713760"
  },
  {
    "text": "start on the top left corner with a cr3 register which is a CPU register and it gives you the physical Base address of",
    "start": "713760",
    "end": "720240"
  },
  {
    "text": "your translation tables uh and it's in this case the PML 4 the page map level",
    "start": "720240",
    "end": "726560"
  },
  {
    "text": "four and this page map level four has 512 entries every of those tables here",
    "start": "726560",
    "end": "731639"
  },
  {
    "text": "has 512 entries and each entry is eight bytes in size to store a 64 bit pointer",
    "start": "731639",
    "end": "738480"
  },
  {
    "text": "basically and therefore each of those tables is 4 kilobytes in size which is",
    "start": "738480",
    "end": "743920"
  },
  {
    "text": "again pretty nice because you have 4 kilobyte pages on Intel CPUs and then it's easy to organize all the memory",
    "start": "743920",
    "end": "749839"
  },
  {
    "text": "with a bit map the virtual address so we have a 48-bit virtual address here and",
    "start": "749839",
    "end": "756680"
  },
  {
    "text": "so yeah we know we have 64 bit address space but right now we can only use 48",
    "start": "756680",
    "end": "762040"
  },
  {
    "text": "bits and it's divided into different parts so we have the first part is the uh page map level for index and this",
    "start": "762040",
    "end": "769199"
  },
  {
    "text": "index has nine bits and it chooses the right page map level for entry from from",
    "start": "769199",
    "end": "775000"
  },
  {
    "text": "this first uh table then exactly the same happens on the on the next level",
    "start": "775000",
    "end": "780079"
  },
  {
    "text": "the page directory pointer table each of those page directory pointer table entries organizes one gigabyte of your",
    "start": "780079",
    "end": "787440"
  },
  {
    "text": "virtual memory and here you have the option to directly map a 1 Gigabyte page to",
    "start": "787440",
    "end": "794000"
  },
  {
    "text": "physical memory or you can map a page directory and this page directory will",
    "start": "794000",
    "end": "799320"
  },
  {
    "text": "divide the 1 gbyte page into smaller blocks the page directory then again has",
    "start": "799320",
    "end": "805800"
  },
  {
    "text": "512 entries so you have two megabyte pages that you can map in the page page directory and on the last level the page",
    "start": "805800",
    "end": "811480"
  },
  {
    "text": "table uh you again have 512 entries and then it divides the 2 megabyte page into",
    "start": "811480",
    "end": "817199"
  },
  {
    "text": "4 kilobyte Pages now these tables are quite large",
    "start": "817199",
    "end": "823120"
  },
  {
    "text": "they are multiple kilobytes each each of them at least four kilobytes and you have multiple tables per layer so you",
    "start": "823120",
    "end": "829720"
  },
  {
    "text": "will probably have one PML 4 and multiple pdps and multiple page directories so this adds up and you have",
    "start": "829720",
    "end": "836959"
  },
  {
    "text": "several kilobytes of physical memory that is actually used to translate uh",
    "start": "836959",
    "end": "842480"
  },
  {
    "text": "virtual addresses to physical addresses so this is kind of weird to access physical memory you need to access",
    "start": "842480",
    "end": "849240"
  },
  {
    "text": "physical memory to translate your virtual addresses to physical addresses this is kind of weird and this would",
    "start": "849240",
    "end": "855279"
  },
  {
    "text": "also be very slow and therefore Intel had the idea to uh introduce caches for",
    "start": "855279",
    "end": "861160"
  },
  {
    "text": "this part as well so here we again have a cache hierarchy similar to the level one level two level three caches and it",
    "start": "861160",
    "end": "867079"
  },
  {
    "text": "starts with the instruction tlb and the D DLB on the top and then we go next to the page directory entry cache the page",
    "start": "867079",
    "end": "873480"
  },
  {
    "text": "directory pointer entry cache and then the PML 4 e cache the CPU starts the",
    "start": "873480",
    "end": "879639"
  },
  {
    "text": "lookup on the top so it first checks whether there is an entry in the tlb and if it is it can already abort and uh get",
    "start": "879639",
    "end": "887320"
  },
  {
    "text": "the data from the cache or from the DRM if there is no such entry it",
    "start": "887320",
    "end": "893560"
  },
  {
    "text": "probably has to go further down on the lookup hierarchy and if it doesn't find any entry in any cache then it has to",
    "start": "893560",
    "end": "900720"
  },
  {
    "text": "look up the page table structures in the system memory in the",
    "start": "900720",
    "end": "905560"
  },
  {
    "text": "dram so um before we can proceed with an attack we need to know about how modern operating system uses this paging system",
    "start": "907120",
    "end": "915120"
  },
  {
    "text": "and um the first thing we need to talk about is um that the kernel is mapped in",
    "start": "915120",
    "end": "921399"
  },
  {
    "text": "each and every process on the system uh this is by necessity um it turns out that user applications often use kernel",
    "start": "921399",
    "end": "928440"
  },
  {
    "text": "services like reading from a hard disk or stuff like that and for that it calls",
    "start": "928440",
    "end": "934000"
  },
  {
    "text": "into the kernel where a privilege escalation is being made and then",
    "start": "934000",
    "end": "940800"
  },
  {
    "text": "U and um and the stack is being changed so",
    "start": "940800",
    "end": "946519"
  },
  {
    "text": "this means that the kernel is present in every user mode application uh however it typically protects itself from access",
    "start": "946519",
    "end": "953240"
  },
  {
    "text": "using the page tables um uh for this talk we also need to talk about space uh layout",
    "start": "953240",
    "end": "961240"
  },
  {
    "text": "randomization um in this case it means that the kernel and the drivers are loaded at randoms offsets and virtual",
    "start": "961240",
    "end": "967360"
  },
  {
    "text": "memory and the idea behind this is that it mitigate code reuse attacks such as",
    "start": "967360",
    "end": "972759"
  },
  {
    "text": "return objective programming there are other code reuse attacks that are mitigated with this method as well um it",
    "start": "972759",
    "end": "979920"
  },
  {
    "text": "also mitigates attack based on read Primitives or right Primitives that is a classical exploits um and the idea here",
    "start": "979920",
    "end": "986639"
  },
  {
    "text": "is that if an attacker does not know where where in memory U the code or or",
    "start": "986639",
    "end": "992040"
  },
  {
    "text": "the data that he needs to use is then he is unable to to mount an attack uh what however can happen is",
    "start": "992040",
    "end": "1000199"
  },
  {
    "text": "that if a kernel or driver address is being leaked uh it defeats the",
    "start": "1000199",
    "end": "1006839"
  },
  {
    "text": "mitigation uh the final thing that we need to talk about is U the kernel direct physical map it's not present on",
    "start": "1006839",
    "end": "1013480"
  },
  {
    "text": "all operating system but it's on many operating system and the kernel physical map is",
    "start": "1013480",
    "end": "1019839"
  },
  {
    "text": "direct physical map is um means that the entire physical memory is mapped into",
    "start": "1019839",
    "end": "1026280"
  },
  {
    "text": "the kernel space and the reason is probably convenient because this allows the kernel to change any memory at any",
    "start": "1026280",
    "end": "1032918"
  },
  {
    "text": "time for any reason um and um this is",
    "start": "1032919",
    "end": "1037959"
  },
  {
    "text": "without changing the page tables or doing stuff like that so it's convenient and it speeds things up it is not on all",
    "start": "1037959",
    "end": "1044480"
  },
  {
    "text": "operating system it's available on OSX it's available on Linux it's available on BS",
    "start": "1044480",
    "end": "1049679"
  },
  {
    "text": "and quite interesting it's available on send pvm that means Amazon e to um it's",
    "start": "1049679",
    "end": "1055720"
  },
  {
    "text": "not available on Windows uh we should take note of this because uh one of our attacks actually uses this uh Kel direct",
    "start": "1055720",
    "end": "1062559"
  },
  {
    "text": "physical map um so that moves us on to actually talking about uh the side channel that",
    "start": "1062559",
    "end": "1069080"
  },
  {
    "text": "we're using for our attack the prefetch side Channel and before we go ahead we",
    "start": "1069080",
    "end": "1074799"
  },
  {
    "text": "just summarize what we had thus far uh first the kernel is mapped into every",
    "start": "1074799",
    "end": "1080720"
  },
  {
    "text": "process two the prefit instruction takes a virtual addresses input to manipulate",
    "start": "1080720",
    "end": "1085799"
  },
  {
    "text": "the L3 a physical addresses needed the prefet instruction must translate three the prefet instruction",
    "start": "1085799",
    "end": "1092320"
  },
  {
    "text": "does not trick privileges meaning any address can be prefetched and four translation is",
    "start": "1092320",
    "end": "1098240"
  },
  {
    "text": "cached and look up searches caches in a fixed order um this leads to the question",
    "start": "1098240",
    "end": "1105400"
  },
  {
    "text": "caches are supposed to speed things up can we figure out the",
    "start": "1105400",
    "end": "1111200"
  },
  {
    "text": "order where the lookup succeeds or fails um by a timing attack and we can",
    "start": "1111200",
    "end": "1118600"
  },
  {
    "text": "actually measure a difference and when we do that it looks like this and if you",
    "start": "1118600",
    "end": "1124200"
  },
  {
    "text": "remember the cach lookup hierarchy graph you will find that this is an almost",
    "start": "1124200",
    "end": "1129880"
  },
  {
    "text": "exactly match of what you would expect measuring latency on the prefet",
    "start": "1129880",
    "end": "1135240"
  },
  {
    "text": "instructions um that the fastest is if it's in the tlb and the slowest if it",
    "start": "1135240",
    "end": "1141000"
  },
  {
    "text": "has to go to physical memory uh it's worth noting here that that is exactly the Reversed order of the page table",
    "start": "1141000",
    "end": "1148000"
  },
  {
    "text": "look up itself and that has a purpose for Intel because most operating system",
    "start": "1148000",
    "end": "1153360"
  },
  {
    "text": "tends to use small Pages not much used for gigabyte pages in real world applications",
    "start": "1153360",
    "end": "1159159"
  },
  {
    "text": "um so the idea here is would this also work for inaccessible kernel memory and",
    "start": "1159159",
    "end": "1165159"
  },
  {
    "text": "you already know the answer because uh the prefetch instruction doesn't trick privileges so let's turn to what we can do with the",
    "start": "1165159",
    "end": "1171400"
  },
  {
    "text": "kernel with the pre prefetch instruction um before we actually do an attack we need to Define an attack",
    "start": "1171400",
    "end": "1177400"
  },
  {
    "text": "primitive and we call this our translation Oracle and it works by",
    "start": "1177400",
    "end": "1182919"
  },
  {
    "text": "timing the prefetch instruction on an arbitrary address and it will recover the translation level uh how this works",
    "start": "1182919",
    "end": "1190600"
  },
  {
    "text": "is we time the prefetch instruction the time that we get out of that we match to the diagram you saw in the last frame um",
    "start": "1190600",
    "end": "1199640"
  },
  {
    "text": "it's fairly simple you start at the y-axis you end up at the x-axis and you'll see where you you get",
    "start": "1199640",
    "end": "1206320"
  },
  {
    "text": "um we can use this to recover a map of the kernel and uh what do I mean by map",
    "start": "1206320",
    "end": "1212120"
  },
  {
    "text": "of the kernel most of you probably know the proc pit page map and Linux uh which is nowadays privileged to access because",
    "start": "1212120",
    "end": "1220440"
  },
  {
    "text": "it's useful for attacks um remember our attack is a CPU based",
    "start": "1220440",
    "end": "1227360"
  },
  {
    "text": "attack it's not about an operating system this means that we can recover this map for Windows as well we can recover it for other operating systems",
    "start": "1227360",
    "end": "1234559"
  },
  {
    "text": "it's just that we can recover it from basically most any Opera rating system from",
    "start": "1234559",
    "end": "1240360"
  },
  {
    "text": "unprivileged uh code execution because the prefet instruction is unprivileged",
    "start": "1240360",
    "end": "1247000"
  },
  {
    "text": "um so we start out with bread withd searched uh and that is we search the",
    "start": "1247000",
    "end": "1252400"
  },
  {
    "text": "memory for PML 4 entries and we do this by U searching in half terabyte steps",
    "start": "1252400",
    "end": "1260960"
  },
  {
    "text": "remember this is half a terabyte cach um and if we find one we",
    "start": "1260960",
    "end": "1266679"
  },
  {
    "text": "know we that we can when whenever we find one we know we can skip the next half gigabyte and we do this for each of",
    "start": "1266679",
    "end": "1273720"
  },
  {
    "text": "the four translation levels and we end up with a complete map of the",
    "start": "1273720",
    "end": "1278799"
  },
  {
    "text": "kernel and to complete this process takes anywhere from seconds to hours depending on how many pages are actually",
    "start": "1278799",
    "end": "1285159"
  },
  {
    "text": "mapped by the operating system and what kind of pages there are um typically what you'll have is um a lot of 4K Pages",
    "start": "1285159",
    "end": "1293279"
  },
  {
    "text": "um the amount of time you need increases with stuff like U shared memory if you memory map the same file a million times",
    "start": "1293279",
    "end": "1300200"
  },
  {
    "text": "you'll have a lot of page entries and it will take a long time uh however at this point we should probably note that an",
    "start": "1300200",
    "end": "1306679"
  },
  {
    "text": "attacker rarely needs a map of the entire kernel he is usually satisfied with the very small subset of the kernel",
    "start": "1306679",
    "end": "1313600"
  },
  {
    "text": "so typically we can he can is able to run this attack in in seconds or less",
    "start": "1313600",
    "end": "1319559"
  },
  {
    "text": "uh we will actually see this in one of our case studies later so the U that lead us to the next",
    "start": "1319559",
    "end": "1329440"
  },
  {
    "text": "attack primitive that we have and we call this the address translation Oracle the address translation Oracle is",
    "start": "1329440",
    "end": "1336440"
  },
  {
    "text": "there to U determine whether a virtual address p and another virtual address P",
    "start": "1336440",
    "end": "1342600"
  },
  {
    "text": "bar mapped to the same physical address um and the way this works is that we first flush P from the cache um",
    "start": "1342600",
    "end": "1351480"
  },
  {
    "text": "the seal flush instruction actually does cause access violation this means that this has to be a user mode address where",
    "start": "1351480",
    "end": "1357400"
  },
  {
    "text": "we have access um the second step is we use the",
    "start": "1357400",
    "end": "1362440"
  },
  {
    "text": "prefetch instruction to load P bar into the cache and",
    "start": "1362440",
    "end": "1368080"
  },
  {
    "text": "um we remember the prefet instruction doesn't Che privileges meaning that P",
    "start": "1368080",
    "end": "1373120"
  },
  {
    "text": "can be a cernal mode address and then we time the axis of",
    "start": "1373120",
    "end": "1378799"
  },
  {
    "text": "accessing p and if accessing p is fast we know that P maps to the same physical",
    "start": "1378799",
    "end": "1384840"
  },
  {
    "text": "memory as P bar um one should be aware here prefixed",
    "start": "1384840",
    "end": "1390640"
  },
  {
    "text": "instruction is a hint that means that the reverse is not true if it was slow it does not mean that they do not map to",
    "start": "1390640",
    "end": "1396960"
  },
  {
    "text": "the same physical memory as PR um so just be aware that this can",
    "start": "1396960",
    "end": "1405200"
  },
  {
    "text": "occur um yeah okay uh when we speak about",
    "start": "1405200",
    "end": "1413000"
  },
  {
    "text": "measuring the execution time of instructions we actually um have to know",
    "start": "1413000",
    "end": "1419720"
  },
  {
    "text": "how the Intel CPUs modern in Intel CPUs execute instructions and they don't",
    "start": "1419720",
    "end": "1425559"
  },
  {
    "text": "necessarily do that in order they reorder instructions to optimize the",
    "start": "1425559",
    "end": "1431600"
  },
  {
    "text": "execution flow and if we look at a simple example with like three different",
    "start": "1431600",
    "end": "1437039"
  },
  {
    "text": "instructions and we want to measure the middle instructions with uh rdts",
    "start": "1437039",
    "end": "1443039"
  },
  {
    "text": "CP then the CPU is actually allowed to reorder the instructions like this so",
    "start": "1443039",
    "end": "1449200"
  },
  {
    "text": "instruction two may be executed before the rdtsc and instruction 3 may also be",
    "start": "1449200",
    "end": "1455200"
  },
  {
    "text": "reordered to be executed in between or even before and this is really bad because uh",
    "start": "1455200",
    "end": "1462200"
  },
  {
    "text": "then we don't know what we actually measured we measured something but probably not what we wanted um for",
    "start": "1462200",
    "end": "1468360"
  },
  {
    "text": "fortunately the rdts CP instruction provides us with a different property so",
    "start": "1468360",
    "end": "1474480"
  },
  {
    "text": "if we uh look at reordering in the opposite direction in the forward Direction then we see that instruction",
    "start": "1474480",
    "end": "1480200"
  },
  {
    "text": "one may not be reordered so that it is between the two rcps and also instruction two uh may not be reordered",
    "start": "1480200",
    "end": "1487600"
  },
  {
    "text": "so that it's outside of the two rcps the same properties hold for uh",
    "start": "1487600",
    "end": "1493559"
  },
  {
    "text": "ense ense is used to serialize memory accesses and here the same properties",
    "start": "1493559",
    "end": "1499039"
  },
  {
    "text": "hold So the instructions may not be the memory referencing inst structures may not be reordered um in in the forward",
    "start": "1499039",
    "end": "1506600"
  },
  {
    "text": "Direction but they may be re uh reordered in the backward Direction so this is not",
    "start": "1506600",
    "end": "1512600"
  },
  {
    "text": "allowed um so we need some additional instruction that provides full",
    "start": "1512600",
    "end": "1518039"
  },
  {
    "text": "serialization of our instruction sequence and actually there is an instruction that allows us to do that uh",
    "start": "1518039",
    "end": "1524679"
  },
  {
    "text": "and that is CPU ID so we have to per to to run CPU ID before and after the",
    "start": "1524679",
    "end": "1530559"
  },
  {
    "text": "instruction that we want to measure uh with a high cycle",
    "start": "1530559",
    "end": "1535960"
  },
  {
    "text": "accuracy now CPU ID is a is an instruction with a huge overhead and we",
    "start": "1535960",
    "end": "1543080"
  },
  {
    "text": "observed uh noise while we we measured um different instructions when using CPU",
    "start": "1543080",
    "end": "1549600"
  },
  {
    "text": "ID so we had to figure a way to make the measurements really",
    "start": "1549600",
    "end": "1555000"
  },
  {
    "text": "reliable uh if we look at the prefet instruction the pre fet instruction is not ordered with respect to rdtsc so",
    "start": "1555000",
    "end": "1563000"
  },
  {
    "text": "this is allowed and this is also allowed so with when we want to measure prefetch rtcp is not help at all and the same",
    "start": "1563000",
    "end": "1571440"
  },
  {
    "text": "goes for infant so again uh it may be reordered in any direction and we cannot",
    "start": "1571440",
    "end": "1577840"
  },
  {
    "text": "just rely on rscp and ense so if we want to measure uh the execution time of a",
    "start": "1577840",
    "end": "1584240"
  },
  {
    "text": "prefetch instruction uh we actually have to come up with a sequence and we came",
    "start": "1584240",
    "end": "1589640"
  },
  {
    "text": "up with the following sequence we start with an m fence to serialize memory accesses then rdts then CPU ID then the",
    "start": "1589640",
    "end": "1597360"
  },
  {
    "text": "target instruction and then the same instructions in the in the opposite order and this allows us uh that the",
    "start": "1597360",
    "end": "1604640"
  },
  {
    "text": "prefetch instruction in the middle may actually be measured to a high cycle",
    "start": "1604640",
    "end": "1609720"
  },
  {
    "text": "accuracy the CPU ID instruction might introduce noise we have observed that uh",
    "start": "1609720",
    "end": "1615360"
  },
  {
    "text": "but the noise should cancel out over several measurements if we want to reduce the",
    "start": "1615360",
    "end": "1621799"
  },
  {
    "text": "noise from CPU ID instead and if we don't measure a prefetch instruction uh",
    "start": "1621799",
    "end": "1627200"
  },
  {
    "text": "then we can instead execute the following sequence so M fense then CPU ID and then rdt CP and this will provide",
    "start": "1627200",
    "end": "1634080"
  },
  {
    "text": "us with a better accuracy so we don't have to perform that many measurements",
    "start": "1634080",
    "end": "1639320"
  },
  {
    "text": "for this kind of measurement when we measure the",
    "start": "1639320",
    "end": "1644480"
  },
  {
    "text": "execution time of the prefetch instruction we use prefetch and a or prefetch T2 because they target the last",
    "start": "1644480",
    "end": "1652240"
  },
  {
    "text": "level cache uh mainly and for the memory accesses we just use a move instruction",
    "start": "1652240",
    "end": "1658799"
  },
  {
    "text": "um as as is used for most memory accesses yeah next we talk about the",
    "start": "1658799",
    "end": "1664799"
  },
  {
    "text": "feeding Windows 7K as alone so here's a case study and how we can actually mount",
    "start": "1664799",
    "end": "1670120"
  },
  {
    "text": "an attack with what we got so far and um first we need to notice that Windows 7",
    "start": "1670120",
    "end": "1676080"
  },
  {
    "text": "memory layout is um is pretty fixed we know that the hell and the kernel is",
    "start": "1676080",
    "end": "1681320"
  },
  {
    "text": "always located between the addresses where it says start and end and for kernel drivers is located in in another",
    "start": "1681320",
    "end": "1687200"
  },
  {
    "text": "region uh where they actually start is randomized but um they are in these",
    "start": "1687200",
    "end": "1692559"
  },
  {
    "text": "regions um this means that when we want to launch a a recovery attack we only",
    "start": "1692559",
    "end": "1698880"
  },
  {
    "text": "need to do a fraction of the kernel which means that we can actually Mount this in less than a",
    "start": "1698880",
    "end": "1705880"
  },
  {
    "text": "second and this is actually how we start to break KLR on on Windows 7 we map the",
    "start": "1705880",
    "end": "1711720"
  },
  {
    "text": "driver's address space and use translation recovery attack remember we haven't broken Windows 7 kslr until we",
    "start": "1711720",
    "end": "1719279"
  },
  {
    "text": "know where a driver is in in the memory because otherwise we would not know where there is something that an attaka",
    "start": "1719279",
    "end": "1726919"
  },
  {
    "text": "could use um the second step is we evict the page transation cashes and um there",
    "start": "1726919",
    "end": "1733600"
  },
  {
    "text": "are two different ways that we can do this we can use a sleep in uh",
    "start": "1733600",
    "end": "1738840"
  },
  {
    "text": "sleep op and windows which um causes the process current process to",
    "start": "1738840",
    "end": "1745440"
  },
  {
    "text": "be to be swapped out and another process swapped in and when we get swapped back",
    "start": "1745440",
    "end": "1750480"
  },
  {
    "text": "in by the Schuler uh typically we'll see that the translation ction has been",
    "start": "1750480",
    "end": "1755760"
  },
  {
    "text": "cleared and uh and we can use that another and faster way that we can do this is we can access a lot of memory in",
    "start": "1755760",
    "end": "1762600"
  },
  {
    "text": "a lodge otherwise you let buffer and since we're accessing a lot of memory it will be optimal for the CPU to have",
    "start": "1762600",
    "end": "1769720"
  },
  {
    "text": "these addresses in the translation CES and this means that um all the kernel",
    "start": "1769720",
    "end": "1775120"
  },
  {
    "text": "modules and drivers will uh be removed from these caches um the third step we need is we",
    "start": "1775120",
    "end": "1782240"
  },
  {
    "text": "need to perform a CIS call to the targeted driver what we're hoping to accomplish with that is that we hope the",
    "start": "1782240",
    "end": "1787799"
  },
  {
    "text": "address addresses that is used by this targeted driver will be placed in the translation CES and the past translation",
    "start": "1787799",
    "end": "1794960"
  },
  {
    "text": "CES and that we can measure it afterwards and that that is in fact step four uh in step four we take an address",
    "start": "1794960",
    "end": "1802760"
  },
  {
    "text": "from the list we found in in the first step from the page transation that is",
    "start": "1802760",
    "end": "1807799"
  },
  {
    "text": "where memory is actually mapped and we time the prefetch for that and we do that for all pages that",
    "start": "1807799",
    "end": "1814600"
  },
  {
    "text": "we found in the first step and the fastest average access time is then the",
    "start": "1814600",
    "end": "1820120"
  },
  {
    "text": "right address there's a bit of noise in here so we actually repeat these uhu",
    "start": "1820120",
    "end": "1825320"
  },
  {
    "text": "five steps a 100 times to get an average and um when we look at that graphically it",
    "start": "1825320",
    "end": "1832279"
  },
  {
    "text": "looks something like this and you'll notice here that the red bar is the",
    "start": "1832279",
    "end": "1837320"
  },
  {
    "text": "address that we were looking for in a driver and the very small blue dot below",
    "start": "1837320",
    "end": "1844039"
  },
  {
    "text": "signifies that this is the uh smallest average here um and in this way we can",
    "start": "1844039",
    "end": "1851600"
  },
  {
    "text": "locate a driver in in physical in virtual memory from unprivileged access",
    "start": "1851600",
    "end": "1856720"
  },
  {
    "text": "using just the pre instruction okay um then we will discuss",
    "start": "1856720",
    "end": "1863840"
  },
  {
    "text": "how we exploit direct physical maps and therefore we will just go one step back",
    "start": "1863840",
    "end": "1869240"
  },
  {
    "text": "first so why uh is the direct physical map a problem uh let's think of kernels",
    "start": "1869240",
    "end": "1875200"
  },
  {
    "text": "like 10 or 20 years ago uh assume that you have like a right four primitive and",
    "start": "1875200",
    "end": "1881440"
  },
  {
    "text": "you can overwrite an address in the kernel you could for instance overwrite some return address and then the uh",
    "start": "1881440",
    "end": "1889519"
  },
  {
    "text": "kernel would execute uh user code if you write a user code pointer there the your",
    "start": "1889519",
    "end": "1895960"
  },
  {
    "text": "still running in privil with privilege uh in with privilege mode in ring zero",
    "start": "1895960",
    "end": "1901639"
  },
  {
    "text": "so if you just overwrite the return address with the user space code address then you would actually run the user",
    "start": "1901639",
    "end": "1908559"
  },
  {
    "text": "code if this is for some reason not possible you could still try to overwrite the stack pointer and then",
    "start": "1908559",
    "end": "1914080"
  },
  {
    "text": "switch to a user space stack and then uh do some return oriented programming by",
    "start": "1914080",
    "end": "1920360"
  },
  {
    "text": "uh providing a nice prepared stack in the user space now this is not possible on Modern CPUs anymore because there are",
    "start": "1920360",
    "end": "1927200"
  },
  {
    "text": "countermeasures against that uh the first is called supervisor mode execution prevention so we cannot jump",
    "start": "1927200",
    "end": "1933559"
  },
  {
    "text": "to user space code anymore because the hardware prevents that the operating system uh configures that and then the",
    "start": "1933559",
    "end": "1940200"
  },
  {
    "text": "hardware prevents us from jumping there and the same goes for switching to a",
    "start": "1940200",
    "end": "1945919"
  },
  {
    "text": "user space deack so we cannot simply uh do that because supervisor mode access prevention prevents us from doing",
    "start": "1945919",
    "end": "1953240"
  },
  {
    "text": "that now in 2014 there has been an attack uh showing",
    "start": "1953240",
    "end": "1960519"
  },
  {
    "text": "that the identity mapping the direct physical map in the kernel can be",
    "start": "1960519",
    "end": "1966080"
  },
  {
    "text": "exploited to do the same uh to launch the same attack because every address",
    "start": "1966080",
    "end": "1971399"
  },
  {
    "text": "that is valid in our user space program will also be in some accessible uh",
    "start": "1971399",
    "end": "1977080"
  },
  {
    "text": "region in the the kernel memory in this direct physical map so instead of just jumping to the user space we just take",
    "start": "1977080",
    "end": "1983840"
  },
  {
    "text": "the physical address at the base off set of the direct physical map and jump there and this is known as return to",
    "start": "1983840",
    "end": "1991080"
  },
  {
    "text": "direct attacks and this was presented by camera at all at blackhe hat and husik in",
    "start": "1991080",
    "end": "1997440"
  },
  {
    "text": "2014 so what is the solution against those attacks so they uh suggested one",
    "start": "1997440",
    "end": "2003080"
  },
  {
    "text": "solution that involved um getting getting rid of parts of the direct physical map like the parts that are",
    "start": "2003080",
    "end": "2009120"
  },
  {
    "text": "mapped in the user space binary but actually Windows doesn't have a direct physical map so why don't we just get",
    "start": "2009120",
    "end": "2015039"
  },
  {
    "text": "rid of the direct phys physical map in OSX and Linux and uh other operating systems as well that might be a solution",
    "start": "2015039",
    "end": "2022320"
  },
  {
    "text": "right apparently not it's too complicated uh instead we decided we do",
    "start": "2022320",
    "end": "2028159"
  },
  {
    "text": "not leak uh physical addresses to the user so you cannot access the physical address map anymore and this is the",
    "start": "2028159",
    "end": "2034399"
  },
  {
    "text": "solution perfect problem solved so what we can do now is we can circumvent",
    "start": "2034399",
    "end": "2041840"
  },
  {
    "text": "this mitigation because it's not really a good mitigation uh and we can determine physical addresses or direct",
    "start": "2041840",
    "end": "2048679"
  },
  {
    "text": "physical map addresses using prefetch so we use our translation recovery attack",
    "start": "2048679",
    "end": "2054398"
  },
  {
    "text": "to find the direct physical map if we don't know where it is if it would if the base offset would be randomized",
    "start": "2054399",
    "end": "2060320"
  },
  {
    "text": "usually it is not so we can skip this step and just do the second step right away so we uh will search search for a",
    "start": "2060320",
    "end": "2069320"
  },
  {
    "text": "address in the direct physical map that we prefetch and then we access our user",
    "start": "2069320",
    "end": "2075919"
  },
  {
    "text": "space address and we will observe a cache hit and when we do that we will",
    "start": "2075919",
    "end": "2082118"
  },
  {
    "text": "actually find that this is a very straightforward attack um so it didn't take me much time to get this running uh",
    "start": "2082119",
    "end": "2090079"
  },
  {
    "text": "and I also talked to other people who reproduced this in a very short time so",
    "start": "2090079",
    "end": "2095878"
  },
  {
    "text": "you just iterate over the direct physical map and it just drops you the um direct physical map address that is",
    "start": "2095879",
    "end": "2103880"
  },
  {
    "text": "maps to the same physical location so this is great because this",
    "start": "2103880",
    "end": "2109240"
  },
  {
    "text": "immediately leaks our address that we can exploit in a red to De like attack and we don't need an additional",
    "start": "2109240",
    "end": "2114960"
  },
  {
    "text": "information leak we don't need the physical addresses but if we know the base offset of the direct physical map",
    "start": "2114960",
    "end": "2121040"
  },
  {
    "text": "then we also have the physical address and knowing the physical address we can use the later on for other texts",
    "start": "2121040",
    "end": "2127920"
  },
  {
    "text": "and as we already heard earlier we have direct physical maps in different operating systems so our attack works on",
    "start": "2127920",
    "end": "2133800"
  },
  {
    "text": "Linux on OSX it works on C pvm we tried that on Amazon ec2 uh that was fun so you get sort of",
    "start": "2133800",
    "end": "2142160"
  },
  {
    "text": "uh direct uh physical direct map uh addresses of the xen hypervisor because",
    "start": "2142160",
    "end": "2148079"
  },
  {
    "text": "uh the yeah the the xen hypervisor runs in ring zero and yeah then have fun with",
    "start": "2148079",
    "end": "2154119"
  },
  {
    "text": "doing something with the physical address on Amazon um our Tech does not work on Windows because it does they",
    "start": "2154119",
    "end": "2159839"
  },
  {
    "text": "don't have a direct physical map but it's still fun to play with the other operating",
    "start": "2159839",
    "end": "2165000"
  },
  {
    "text": "systems so let's talk about uh using the physical address for other attacks and",
    "start": "2165000",
    "end": "2170319"
  },
  {
    "text": "as you have heard earlier in this talk uh the cache the level three cache is",
    "start": "2170319",
    "end": "2176079"
  },
  {
    "text": "physically indexed so you need the physical address to actually compute where an a data stored in the last level",
    "start": "2176079",
    "end": "2184119"
  },
  {
    "text": "cache and if you have this information you can use this to build a powerful side channel so we have seen side",
    "start": "2184119",
    "end": "2190040"
  },
  {
    "text": "channels to infer user input like single key strokes some sometimes you can even",
    "start": "2190040",
    "end": "2195280"
  },
  {
    "text": "narrow it down to the to the letter that has been uh entered uh we have seen",
    "start": "2195280",
    "end": "2200359"
  },
  {
    "text": "crypto key recovery in like one encryption 97% of the of the key bits",
    "start": "2200359",
    "end": "2205720"
  },
  {
    "text": "recovered uh we have seen cross VM attacks cross core attacks even cross CPU attacks um this year we have seen",
    "start": "2205720",
    "end": "2214119"
  },
  {
    "text": "attacks on any architecture so most of most attacks were on in architectures but there is a usix paper by us at usix",
    "start": "2214119",
    "end": "2222200"
  },
  {
    "text": "uh this year and there we show that it works on Arm based mobile devices that's",
    "start": "2222200",
    "end": "2227640"
  },
  {
    "text": "also fun um but for these attacks it really helps if you know the physical",
    "start": "2227640",
    "end": "2233480"
  },
  {
    "text": "address because there is a mapping from physical addresses to the cache slices",
    "start": "2233480",
    "end": "2239760"
  },
  {
    "text": "the last level cache slices uh and this function has been reverse engineered so we can use the function if we have the",
    "start": "2239760",
    "end": "2245520"
  },
  {
    "text": "physical address but usually we we wouldn't have the physical address in the first place another attack that uh that can",
    "start": "2245520",
    "end": "2254079"
  },
  {
    "text": "benefit from knowing the physical address is row Hammer so if you know the physical addresses for a row Hammer",
    "start": "2254079",
    "end": "2259480"
  },
  {
    "text": "attack you can actually craft a much more efficient attack uh for those of",
    "start": "2259480",
    "end": "2265000"
  },
  {
    "text": "you who don't know row hammer it is basically a bug in Hardware uh where you",
    "start": "2265000",
    "end": "2270319"
  },
  {
    "text": "access memory locations in a high frequency and at a different random memory location that you probably cannot",
    "start": "2270319",
    "end": "2276599"
  },
  {
    "text": "access um a bit flips and you can exploit that it has been shown by Sion",
    "start": "2276599",
    "end": "2282280"
  },
  {
    "text": "and dulian who have presented this last year at blackhead uh you can gain root",
    "start": "2282280",
    "end": "2288040"
  },
  {
    "text": "privileges root privileges with that so rammer is pretty much like uh",
    "start": "2288040",
    "end": "2294440"
  },
  {
    "text": "slamming a door repeatedly to break into a neighbor apartment that is how",
    "start": "2294440",
    "end": "2299800"
  },
  {
    "text": "motherboard Vice described it when we presented rammer in JavaScript uh last",
    "start": "2299800",
    "end": "2305319"
  },
  {
    "text": "year um so it works pretty much like this so you activate one row and then",
    "start": "2305319",
    "end": "2310680"
  },
  {
    "text": "you activate another row and they are always copied to the row buffer and if you do that in a high frequency and",
    "start": "2310680",
    "end": "2316119"
  },
  {
    "text": "often enough you will see bit flips in the row between those two uh rows that you actually access now to actually do",
    "start": "2316119",
    "end": "2323520"
  },
  {
    "text": "this you need to know uh which memory locations which which physical addresses map to these two rows and therefore we",
    "start": "2323520",
    "end": "2331200"
  },
  {
    "text": "need to know how the dram is organized and if you look at a modern system you probably will have multiple channels",
    "start": "2331200",
    "end": "2336880"
  },
  {
    "text": "that are that are the modules that you have in your system and each of those modules will probably have multiple",
    "start": "2336880",
    "end": "2342640"
  },
  {
    "text": "sites that are the ranks of the uh of the dram module and then each chip is",
    "start": "2342640",
    "end": "2349720"
  },
  {
    "text": "further divided into Banks so you have up to eight Banks you have definitely",
    "start": "2349720",
    "end": "2355400"
  },
  {
    "text": "eight banks on DDR3 and you have up to 16 banks in uh DDR 4 and these banks are",
    "start": "2355400",
    "end": "2361920"
  },
  {
    "text": "further divided into the rows that you actually want to access so you need to know the mapping from phys physcal",
    "start": "2361920",
    "end": "2367640"
  },
  {
    "text": "addresses to channel to rank to bank and then you can access memory locations in",
    "start": "2367640",
    "end": "2372839"
  },
  {
    "text": "the same row so why does actually the bit flip uh",
    "start": "2372839",
    "end": "2378040"
  },
  {
    "text": "happen here um dram cells lose their charge over time they leak the charge",
    "start": "2378040",
    "end": "2384319"
  },
  {
    "text": "and if you let them leak the charge long enough they would lose the value that they stored so you need to refresh the",
    "start": "2384319",
    "end": "2391040"
  },
  {
    "text": "value that is stored in the in the cell uh very frequently and this is done by",
    "start": "2391040",
    "end": "2396680"
  },
  {
    "text": "just reading the value from the row and writing it back if you don't do this",
    "start": "2396680",
    "end": "2401839"
  },
  {
    "text": "fast enough then you will have um data errors you will have bit",
    "start": "2401839",
    "end": "2407119"
  },
  {
    "text": "flips now it has been found with the when when researching the uh rammer bug",
    "start": "2407119",
    "end": "2413480"
  },
  {
    "text": "it has been found that proximate excesses can uh increase the probability of a bit flip and this is the reason for",
    "start": "2413480",
    "end": "2420880"
  },
  {
    "text": "this is that the cells leak faster upon uh approximate excesses",
    "start": "2420880",
    "end": "2427960"
  },
  {
    "text": "we have reverse engineered the mappings from physical addresses to uh memory to",
    "start": "2427960",
    "end": "2433880"
  },
  {
    "text": "to the actual uh Channel Rank and bank and this is also a us next paper this",
    "start": "2433880",
    "end": "2439319"
  },
  {
    "text": "year and we need the physical addresses then to compute where we want to hammer",
    "start": "2439319",
    "end": "2446680"
  },
  {
    "text": "okay so just to summarize uh with a direct physical map we are able to defeat uh smap and smap",
    "start": "2446680",
    "end": "2456760"
  },
  {
    "text": "and we able to leak physical addresses and with these physical address we are able to perform other attacks",
    "start": "2456760",
    "end": "2462280"
  },
  {
    "text": "specifically cash attacks and rammer attacks",
    "start": "2462280",
    "end": "2468599"
  },
  {
    "text": "um this leads us to our final slide and what we got here is what we hope to",
    "start": "2468599",
    "end": "2475359"
  },
  {
    "text": "bring across here is that CPU design is security relevant uh in specific that prefet leak",
    "start": "2475359",
    "end": "2481760"
  },
  {
    "text": "significant information the information that we get here we can use to locate a driver in the kernel and thus break k",
    "start": "2481760",
    "end": "2487640"
  },
  {
    "text": "rlr um but that's not the only thing that we do we can break smap and smip",
    "start": "2487640",
    "end": "2493280"
  },
  {
    "text": "and we can get physical addresses to assist in other attacks um that was our",
    "start": "2493280",
    "end": "2500079"
  },
  {
    "text": "talk I think uh thank [Applause]",
    "start": "2500079",
    "end": "2512839"
  },
  {
    "text": "you I've got a question for you so if I understand correctly you need you need to be able to read your own processes",
    "start": "2512839",
    "end": "2519160"
  },
  {
    "text": "page tables in order to know what addresses are safe to search for the kernel mapping without causing a page",
    "start": "2519160",
    "end": "2525839"
  },
  {
    "text": "fault is that correct uh the prefetch instruction doesn't cause page faults",
    "start": "2525839",
    "end": "2530960"
  },
  {
    "text": "yeah but but you said earlier that um you can only search Pages uh I forget",
    "start": "2530960",
    "end": "2537200"
  },
  {
    "text": "which of your you can only search for for memory locations that are actually mapped yeah you the all pages that are",
    "start": "2537200",
    "end": "2543559"
  },
  {
    "text": "not mapped yet that would still require a page fa to occur uh you cannot you find them as not mapped so it's not",
    "start": "2543559",
    "end": "2551000"
  },
  {
    "text": "valid so do you need to know your own page table mapping before you can start searching for those one tbyte chunks or",
    "start": "2551000",
    "end": "2557880"
  },
  {
    "text": "no oh no no okay thank",
    "start": "2557880",
    "end": "2562599"
  },
  {
    "text": "you any more questions thank you",
    "start": "2564599",
    "end": "2570740"
  },
  {
    "text": "[Applause]",
    "start": "2570740",
    "end": "2577140"
  }
]