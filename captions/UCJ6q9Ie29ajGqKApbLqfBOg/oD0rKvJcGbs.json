[
  {
    "start": "0",
    "end": "50000"
  },
  {
    "text": "morning everyone um my name is Riga and it's my great pleasure to present thank",
    "start": "0",
    "end": "9990"
  },
  {
    "text": "you and it's my great pleasure to present our work on sending unguarded gates to",
    "start": "9990",
    "end": "16230"
  },
  {
    "text": "bypass the effigy with big data so even though I am the only one presenting",
    "start": "16230",
    "end": "22619"
  },
  {
    "text": "today this one is really a team work with my colleagues kasam Yong Jie Zhao",
    "start": "22619",
    "end": "29820"
  },
  {
    "text": "some in Seoul and Estonian Li we would like to share all the learnings with you",
    "start": "29820",
    "end": "36840"
  },
  {
    "text": "guys and also at the same time to collect feedbacks from the security",
    "start": "36840",
    "end": "42120"
  },
  {
    "text": "community we are based in United States but originally we all come from China",
    "start": "42120",
    "end": "50360"
  },
  {
    "start": "50000",
    "end": "96000"
  },
  {
    "text": "this is the agenda of my talk today so firstly I would like to quickly go over",
    "start": "50360",
    "end": "58399"
  },
  {
    "text": "safety and the implementation and well after that I will quickly go over some",
    "start": "58399",
    "end": "65760"
  },
  {
    "text": "previous safety by a research work after that I will talk about our research",
    "start": "65760",
    "end": "71549"
  },
  {
    "text": "focus over analysis approaches and some result that we obtained using our method",
    "start": "71549",
    "end": "79560"
  },
  {
    "text": "after that I will quickly talk about the fix for the issue from Microsoft and",
    "start": "79560",
    "end": "87780"
  },
  {
    "text": "some future work that will be carried out okay so first safety implementation",
    "start": "87780",
    "end": "94950"
  },
  {
    "text": "overview so as you may know that zfg is a mitigation technique that is used to",
    "start": "94950",
    "end": "104040"
  },
  {
    "start": "96000",
    "end": "200000"
  },
  {
    "text": "prevent control flow being redirected to you I intend to the locations by",
    "start": "104040",
    "end": "109979"
  },
  {
    "text": "validating the target address of any interactive branch before it takes place",
    "start": "109979",
    "end": "115369"
  },
  {
    "text": "so the implementation of CFG will require the support from both the",
    "start": "115369",
    "end": "121979"
  },
  {
    "text": "compiler and the operating system for example the compiler where are needed to",
    "start": "121979",
    "end": "128759"
  },
  {
    "text": "insert a self-check function call before in before each indirect call and before each",
    "start": "128759",
    "end": "136110"
  },
  {
    "text": "indirect jump the compiler will also need to generate the function table to",
    "start": "136110",
    "end": "142620"
  },
  {
    "text": "list all legal entry addresses and in addition to those to the compiler needs",
    "start": "142620",
    "end": "149400"
  },
  {
    "text": "to add a safety related entry in load configuration table those include god",
    "start": "149400",
    "end": "155520"
  },
  {
    "text": "save check function pointer god save checks type function table",
    "start": "155520",
    "end": "160560"
  },
  {
    "text": "god save function count under the God flag so meanwhile the operating system",
    "start": "160560",
    "end": "169080"
  },
  {
    "text": "of abort safety by point the safe check function pointer to our this function in",
    "start": "169080",
    "end": "176880"
  },
  {
    "text": "ntdll library it also generates CFG bitmap when the process is being created",
    "start": "176880",
    "end": "184560"
  },
  {
    "text": "and bitmap is basically based at all they say function table from the",
    "start": "184560",
    "end": "190500"
  },
  {
    "text": "compiler so in addition to that the operating system will also needs to",
    "start": "190500",
    "end": "195510"
  },
  {
    "text": "handle violations when the FG check fails so this picture more or less our",
    "start": "195510",
    "end": "203660"
  },
  {
    "text": "reiterate what I just said with a little bit more detail so for example are the",
    "start": "203660",
    "end": "212750"
  },
  {
    "text": "compiler insert god check I call function pointer before are each",
    "start": "212750",
    "end": "218910"
  },
  {
    "text": "indirect call or a picture or indirect jump the compiler need also I generate",
    "start": "218910",
    "end": "225930"
  },
  {
    "text": "save function table to list all the valid entry addresses meanwhile the",
    "start": "225930",
    "end": "232769"
  },
  {
    "start": "232000",
    "end": "268000"
  },
  {
    "text": "operating system does the bottom half of this picture it's a operating system",
    "start": "232769",
    "end": "238440"
  },
  {
    "text": "points the safe check function pointer to this function ldrp validate user call",
    "start": "238440",
    "end": "247049"
  },
  {
    "text": "target this functioning in ntdll library and the operating system generates the",
    "start": "247049",
    "end": "253380"
  },
  {
    "text": "safe g bitmap based on the safe function table from the compiler and if the",
    "start": "253380",
    "end": "259950"
  },
  {
    "text": "target address of the internet calls valid in the safe g bitmap it will",
    "start": "259950",
    "end": "265710"
  },
  {
    "text": "continue this injury call so our a on CFG basically plays a",
    "start": "265710",
    "end": "273250"
  },
  {
    "text": "row of officer to load officer who checks mister interest cost targeted",
    "start": "273250",
    "end": "278260"
  },
  {
    "text": "address from its database basically in the safe G bitmap if the target address",
    "start": "278260",
    "end": "284590"
  },
  {
    "text": "is varied the real officer would raise the barricade to let me stay in direct",
    "start": "284590",
    "end": "289870"
  },
  {
    "text": "call keep on going so that's a quick review of Safety implementation now I",
    "start": "289870",
    "end": "296889"
  },
  {
    "start": "291000",
    "end": "303000"
  },
  {
    "text": "would like to talk about some previous work on safety bypass so this one is a",
    "start": "296889",
    "end": "305350"
  },
  {
    "start": "303000",
    "end": "330000"
  },
  {
    "text": "incomplete we believe is incomplete list of some of the previous research work on",
    "start": "305350",
    "end": "311350"
  },
  {
    "text": "safety by past studies so for example the Hydra presented his work on bypass",
    "start": "311350",
    "end": "318520"
  },
  {
    "text": "CFG comprehensively in 2015 blackhat USA and while all these files are related to",
    "start": "318520",
    "end": "327880"
  },
  {
    "text": "JIT compilers and we also listed a incomplete list of attack surfaces and",
    "start": "327880",
    "end": "338289"
  },
  {
    "start": "330000",
    "end": "481000"
  },
  {
    "text": "most of these attack surfaces have already been mitigated for example non",
    "start": "338289",
    "end": "343450"
  },
  {
    "text": "CFG module if a non CFG module is loaded into the system this module would become",
    "start": "343450",
    "end": "350050"
  },
  {
    "text": "a weak support that can eventually leads to CFG bypass but we think this this",
    "start": "350050",
    "end": "356260"
  },
  {
    "text": "attack surface will eventually sunset with why the implementation of CFG",
    "start": "356260",
    "end": "362699"
  },
  {
    "text": "indirect jump this attack surface has already been mitigated by our safety the",
    "start": "362699",
    "end": "369760"
  },
  {
    "text": "same way add in direct course return address on stack this attack surface has",
    "start": "369760",
    "end": "376000"
  },
  {
    "text": "already been mitigated by newly introduced or F G return flow guard one",
    "start": "376000",
    "end": "382810"
  },
  {
    "text": "more attack surface the gold chat I call function pointer inserted by the compiler",
    "start": "382810",
    "end": "388510"
  },
  {
    "text": "before each indirect call indirect jump so this function pointer is supposed to",
    "start": "388510",
    "end": "394419"
  },
  {
    "text": "be riddling but under certain cases it can be made writable",
    "start": "394419",
    "end": "401290"
  },
  {
    "text": "this basically is you hi John's work and this issue has been reported affixed by",
    "start": "401290",
    "end": "407650"
  },
  {
    "text": "adding a wrapper to virtual protect so three more attack surfaces are listed",
    "start": "407650",
    "end": "413890"
  },
  {
    "text": "here step jump long jump called the jump buffer can be modified to bypass CFG and",
    "start": "413890",
    "end": "420960"
  },
  {
    "text": "this attack surface has been mitigated by long jump hardening in Windows 10 CFG",
    "start": "420960",
    "end": "427590"
  },
  {
    "text": "improvement GT decode I'm going to talk about this one a little bit more in",
    "start": "427590",
    "end": "433300"
  },
  {
    "text": "detail because most of the research work a previous research work are in this",
    "start": "433300",
    "end": "438370"
  },
  {
    "text": "area and finally very the gadget okay also free JIT compilers have been",
    "start": "438370",
    "end": "446950"
  },
  {
    "text": "reported to have some issues that can lead to CFG bypass and of them have",
    "start": "446950",
    "end": "452680"
  },
  {
    "text": "already been fixed the CFG bypass methods include using unprotected",
    "start": "452680",
    "end": "458740"
  },
  {
    "text": "integrate call or indirect jump from the GDD code using disk brake because",
    "start": "458740",
    "end": "464350"
  },
  {
    "text": "there's no target address check for indirect call jump into the GDD code area and lastly by overriding the",
    "start": "464350",
    "end": "472540"
  },
  {
    "text": "temporary GG the native code buffer I'll give you an example on each method",
    "start": "472540",
    "end": "479250"
  },
  {
    "text": "listed here so the first attack surface are using unprotected indirect called",
    "start": "479250",
    "end": "486790"
  },
  {
    "start": "481000",
    "end": "511000"
  },
  {
    "text": "jump from the GDD code I listed a three research studies on this method with",
    "start": "486790",
    "end": "493960"
  },
  {
    "text": "note that all these three are related to register based indirect cause or",
    "start": "493960",
    "end": "501010"
  },
  {
    "text": "indirect jumps so we have a call near X here we have a jump X here without CFG",
    "start": "501010",
    "end": "509580"
  },
  {
    "text": "protection the second one using jeeps Brahe because there's no target address",
    "start": "509580",
    "end": "516310"
  },
  {
    "text": "check for indirect call or indirect jump into the GTD code they are the it's all",
    "start": "516310",
    "end": "524530"
  },
  {
    "text": "listed like the at jerzees or listed valid in the CFG bitmap and the lastly",
    "start": "524530",
    "end": "532130"
  },
  {
    "start": "530000",
    "end": "549000"
  },
  {
    "text": "safety can also be bypassed by manipulating the GTD code in the",
    "start": "532130",
    "end": "537829"
  },
  {
    "text": "temporary code buffer which is writable before it gets copied to the executable",
    "start": "537829",
    "end": "543290"
  },
  {
    "text": "memory I list the one research work on this attack surface so lastly are valid",
    "start": "543290",
    "end": "552620"
  },
  {
    "start": "549000",
    "end": "623000"
  },
  {
    "text": "gadget CFG Odin prevents the control flow being hijacked to I expected",
    "start": "552620",
    "end": "559970"
  },
  {
    "text": "locations it does not stop that I intended use that I intended the use of",
    "start": "559970",
    "end": "565459"
  },
  {
    "text": "value the gadget at legal entry addresses our which CFG the availability",
    "start": "565459",
    "end": "572360"
  },
  {
    "text": "of those gadgets has been largely reduced making it very much more",
    "start": "572360",
    "end": "578149"
  },
  {
    "text": "difficult to exploit so those are the previous research work of safety bypass",
    "start": "578149",
    "end": "584750"
  },
  {
    "text": "now I'd like to jump into our research focus also being different from all the",
    "start": "584750",
    "end": "592310"
  },
  {
    "text": "previous research that has been done on CFG bypass we are trying to probe this",
    "start": "592310",
    "end": "599060"
  },
  {
    "text": "topic from a totally different angle so instead of trying to break the safety",
    "start": "599060",
    "end": "604130"
  },
  {
    "text": "check logic itself or I fried the implementation issues of safety in JIT",
    "start": "604130",
    "end": "611329"
  },
  {
    "text": "compilers we focused on another aspect that has not been widely extensively",
    "start": "611329",
    "end": "617899"
  },
  {
    "text": "studied before so we focused on memory based indirect cause we are actually",
    "start": "617899",
    "end": "624819"
  },
  {
    "text": "reported all those endings to nsrc and we really appreciate the recognition",
    "start": "624819",
    "end": "631279"
  },
  {
    "text": "from the bug bounty program as listed here so this table is not updated yet",
    "start": "631279",
    "end": "638630"
  },
  {
    "text": "because we reported two different issues to nsrc and both were recognized however",
    "start": "638630",
    "end": "646130"
  },
  {
    "text": "the only the first one is listed on the website okay so our our research focus",
    "start": "646130",
    "end": "653630"
  },
  {
    "start": "651000",
    "end": "748000"
  },
  {
    "text": "so we basically treat memory based indirect cost into two different groups",
    "start": "653630",
    "end": "660100"
  },
  {
    "text": "the first one is that the function pointer of the memory based",
    "start": "660100",
    "end": "666080"
  },
  {
    "text": "and call the function pointer is located at a vulnerable memory location so here",
    "start": "666080",
    "end": "672260"
  },
  {
    "text": "one robot means rightful so give you example by calling a function pointer",
    "start": "672260",
    "end": "677900"
  },
  {
    "text": "which is located in the data segment so",
    "start": "677900",
    "end": "682910"
  },
  {
    "text": "which is writable at the wrong time so in this case the compiler when CFG is",
    "start": "682910",
    "end": "688460"
  },
  {
    "text": "turned on the compiler will insert CFG check for the target address before",
    "start": "688460",
    "end": "694940"
  },
  {
    "text": "taking this memory based indirect call so alternatively the other one that the",
    "start": "694940",
    "end": "702050"
  },
  {
    "text": "other kind of indirect called memory based the indirect codes that the function pointer is located at the safe",
    "start": "702050",
    "end": "709100"
  },
  {
    "text": "memory location here safe means not writable so for example by calling a",
    "start": "709100",
    "end": "716000"
  },
  {
    "text": "function pointer from import address table which is located in the I data",
    "start": "716000",
    "end": "722350"
  },
  {
    "text": "segment which is read owning after being initialized at runtime because the",
    "start": "722350",
    "end": "728510"
  },
  {
    "text": "function the function pointer is riddling even though the save key is",
    "start": "728510",
    "end": "734150"
  },
  {
    "text": "turned on the compiler would not insert a safe check function before this memory",
    "start": "734150",
    "end": "741230"
  },
  {
    "text": "this memory based integral score takes place I'll give you example of each case here",
    "start": "741230",
    "end": "747380"
  },
  {
    "text": "in the first one the function pointer is located at vulnerable memory location so",
    "start": "747380",
    "end": "754730"
  },
  {
    "start": "748000",
    "end": "809000"
  },
  {
    "text": "as you can see here we have a memory based indirect call call my function",
    "start": "754730",
    "end": "761600"
  },
  {
    "text": "pointer and the function pointer is located in the data segment which is a",
    "start": "761600",
    "end": "768800"
  },
  {
    "text": "writable from either study the analysis so when CFG is turned on so basically it",
    "start": "768800",
    "end": "778840"
  },
  {
    "text": "firstly move the target address to Year",
    "start": "778840",
    "end": "784730"
  },
  {
    "text": "eggs and then movie eggs to the stack to the stack and then insert God check I",
    "start": "784730",
    "end": "791840"
  },
  {
    "text": "call function pointer before calling calling this one from the stack so it",
    "start": "791840",
    "end": "800239"
  },
  {
    "text": "changes the format has changed from a memory based in direct call to calling",
    "start": "800239",
    "end": "806539"
  },
  {
    "text": "from the stack so alternatively on the second one are the function pointer",
    "start": "806539",
    "end": "813889"
  },
  {
    "text": "which is located at a safe memory location for example we have a here we",
    "start": "813889",
    "end": "822559"
  },
  {
    "text": "have a memory based in direct call while the function pointer is located as at",
    "start": "822559",
    "end": "829999"
  },
  {
    "text": "the eye data segment and the I data segment is riddling from Ida and which",
    "start": "829999",
    "end": "838849"
  },
  {
    "text": "is confirmed from runtime analysis here the function pointer is read-only so in",
    "start": "838849",
    "end": "847429"
  },
  {
    "text": "this case even though CFG is turned on the compiler doesn't insert safe check",
    "start": "847429",
    "end": "853999"
  },
  {
    "text": "function before this memory based indirect call so basically a CFG like a",
    "start": "853999",
    "end": "863809"
  },
  {
    "text": "god protect each indirect call jump as",
    "start": "863809",
    "end": "869829"
  },
  {
    "text": "previous research has shown that the register based unprotected indirect call",
    "start": "869829",
    "end": "876589"
  },
  {
    "text": "or indirect jumps are able to bypass those are in difficult most of them are",
    "start": "876589",
    "end": "882379"
  },
  {
    "text": "in difficult are able to bypass CFG because there are there is a gate here",
    "start": "882379",
    "end": "887600"
  },
  {
    "text": "however for those memory based and protected indirect quorum cannot bypass",
    "start": "887600",
    "end": "895459"
  },
  {
    "text": "CFG because there is no gate here because the function pointer is not",
    "start": "895459",
    "end": "901369"
  },
  {
    "text": "writable so we started to think is this really the case under doing runtime the",
    "start": "901369",
    "end": "911179"
  },
  {
    "text": "data basically is our research focus trying to find a hiding gate basically",
    "start": "911179",
    "end": "918319"
  },
  {
    "text": "on our research focus is to find the day hiding gate which means we are trying to",
    "start": "918319",
    "end": "925459"
  },
  {
    "text": "find a memory based indirect course with writable function pointer at one time so that",
    "start": "925459",
    "end": "931730"
  },
  {
    "text": "function pointer is not protected by CFG so that is our research focus now let's",
    "start": "931730",
    "end": "938959"
  },
  {
    "start": "936000",
    "end": "941000"
  },
  {
    "text": "talk about our research approach so in order to find those memory-based",
    "start": "938959",
    "end": "943990"
  },
  {
    "start": "941000",
    "end": "1019000"
  },
  {
    "text": "integrated course with writable function pointer we utilized a pmu feature a PM",
    "start": "943990",
    "end": "952369"
  },
  {
    "text": "you based instrumentation to to collect the runtime context information that we",
    "start": "952369",
    "end": "958189"
  },
  {
    "text": "are interested in that can help us identify those memory based indirect",
    "start": "958189",
    "end": "964790"
  },
  {
    "text": "costs with writable function pointer we also use a sparkle based big data",
    "start": "964790",
    "end": "970579"
  },
  {
    "text": "analysis system to screen to analyze a large volume of data so this pmu feature",
    "start": "970579",
    "end": "979339"
  },
  {
    "text": "feature was firstly introduced in the Pentium processor with a set of model",
    "start": "979339",
    "end": "986629"
  },
  {
    "text": "specific performance monitoring counter registers so it allows the selection of",
    "start": "986629",
    "end": "993679"
  },
  {
    "text": "processor performance parameters to be monitored and measured this is a example",
    "start": "993679",
    "end": "999619"
  },
  {
    "text": "of ia32 performance even to select",
    "start": "999619",
    "end": "1004740"
  },
  {
    "text": "register this is the layout the event number and the umask value defines which",
    "start": "1004740",
    "end": "1013389"
  },
  {
    "text": "processor performance parameter is to be monitored and measured so and we",
    "start": "1013389",
    "end": "1020220"
  },
  {
    "text": "developed this framework to try to collect useful information that can help",
    "start": "1020220",
    "end": "1028990"
  },
  {
    "text": "look for those memory based indirect costs with writable function pointer so",
    "start": "1028990",
    "end": "1035409"
  },
  {
    "text": "by programming a set of model specific registers each indirect call in the",
    "start": "1035409",
    "end": "1043779"
  },
  {
    "text": "target code would trigger a PMI of almost monetary interrupts so its",
    "start": "1043779",
    "end": "1050370"
  },
  {
    "text": "indirect call triggers a interrupt and then we rejected over interrupt Handler",
    "start": "1050370",
    "end": "1058120"
  },
  {
    "text": "basically through two different ways to collect contact data contacts",
    "start": "1058120",
    "end": "1065900"
  },
  {
    "text": "information that we are interested in because we are the handler print out the",
    "start": "1065900",
    "end": "1071900"
  },
  {
    "text": "binary code that we are interested in in kernel mode directly we have to be very",
    "start": "1071900",
    "end": "1078020"
  },
  {
    "text": "careful to deal with a page fault problem to avoid any page fault problem",
    "start": "1078020",
    "end": "1083120"
  },
  {
    "text": "so that we just the handler is registered by two different ways the",
    "start": "1083120",
    "end": "1089270"
  },
  {
    "text": "first one is to hook the FES item in a DD table directly well the other one is",
    "start": "1089270",
    "end": "1096860"
  },
  {
    "text": "to use a Windows API which was mentioned in more details by CPS in last year's",
    "start": "1096860",
    "end": "1105470"
  },
  {
    "text": "black hat us a I'll give you an example we are on over our study was based on a",
    "start": "1105470",
    "end": "1115400"
  },
  {
    "start": "1111000",
    "end": "1159000"
  },
  {
    "text": "Sandy Bridge tab CPU so in our study we had to program the umask",
    "start": "1115400",
    "end": "1123550"
  },
  {
    "text": "value and the event number to be our a0",
    "start": "1123550",
    "end": "1128570"
  },
  {
    "text": "and eighty-eight respectively so that as you can see from here each taken",
    "start": "1128570",
    "end": "1135130"
  },
  {
    "text": "speculative and the retired indirect near call would trigger a interrupts and",
    "start": "1135130",
    "end": "1142520"
  },
  {
    "text": "then the total stream that we are interested in at each legal entry of",
    "start": "1142520",
    "end": "1147740"
  },
  {
    "text": "indirect call it's collected by the event handler for analysis so what kind",
    "start": "1147740",
    "end": "1155930"
  },
  {
    "text": "of data we collected for our study so there are three addresses are involved",
    "start": "1155930",
    "end": "1163820"
  },
  {
    "start": "1159000",
    "end": "1263000"
  },
  {
    "text": "in on each memory based indirect call so we have a from address where this memory",
    "start": "1163820",
    "end": "1171830"
  },
  {
    "text": "based indirect call takes place we have a function pointer and then we have a",
    "start": "1171830",
    "end": "1179000"
  },
  {
    "text": "target address where this function pointer points to so and so each address",
    "start": "1179000",
    "end": "1187930"
  },
  {
    "text": "has its own Pte page table entry so basically this 8 p",
    "start": "1187930",
    "end": "1195170"
  },
  {
    "text": "of information are collected upon each memory based indirect call so again we",
    "start": "1195170",
    "end": "1202280"
  },
  {
    "text": "collect from address so from where this memory based indirect call takes place",
    "start": "1202280",
    "end": "1208460"
  },
  {
    "text": "we then collect from code block so we collect eight bytes eight bytes of",
    "start": "1208460",
    "end": "1215300"
  },
  {
    "text": "information from the from address and then we collect the Pte of the from",
    "start": "1215300",
    "end": "1222560"
  },
  {
    "text": "address after that we collect the function pointer itself and the page",
    "start": "1222560",
    "end": "1229490"
  },
  {
    "text": "table entry information of the target of the target point function pointer and",
    "start": "1229490",
    "end": "1235240"
  },
  {
    "text": "lastly we collect the target address where the the to adjust basically the",
    "start": "1235240",
    "end": "1243230"
  },
  {
    "text": "target address will collect the eight bytes of information on the target",
    "start": "1243230",
    "end": "1250460"
  },
  {
    "text": "address and lastly we collect the page table entry of the target address so",
    "start": "1250460",
    "end": "1257660"
  },
  {
    "text": "give you eight pieces of information are collected on each memory based indirect",
    "start": "1257660",
    "end": "1262910"
  },
  {
    "text": "call so give you a real example of what we collected so again this is that data",
    "start": "1262910",
    "end": "1269240"
  },
  {
    "start": "1263000",
    "end": "1410000"
  },
  {
    "text": "format we'll collect we collected so eight pieces of the information from",
    "start": "1269240",
    "end": "1274880"
  },
  {
    "text": "address front code block eight bytes from address PDE function pointers",
    "start": "1274880",
    "end": "1281360"
  },
  {
    "text": "address function pointers PT e to address basically the target address",
    "start": "1281360",
    "end": "1287620"
  },
  {
    "text": "to address code block eight bytes of information and a to address is PT e so",
    "start": "1287620",
    "end": "1295550"
  },
  {
    "text": "this is the real data we collected so for example the first one from address",
    "start": "1295550",
    "end": "1301160"
  },
  {
    "text": "seven to a six b d for b BD for be at this address we have a memory based in",
    "start": "1301160",
    "end": "1310670"
  },
  {
    "text": "direct call called your a pointer here and then we collect eight bytes of",
    "start": "1310670",
    "end": "1318740"
  },
  {
    "text": "information from the from address so as you can see ff15 so this then followed",
    "start": "1318740",
    "end": "1325490"
  },
  {
    "text": "by a address so we collect this information as you can see f f-15e 4:01",
    "start": "1325490",
    "end": "1334350"
  },
  {
    "text": "there 187 - 87 - after that we collect the Pte from the from address okay so",
    "start": "1334350",
    "end": "1343990"
  },
  {
    "text": "and after that we collect the target point of address which is basically this",
    "start": "1343990",
    "end": "1350980"
  },
  {
    "text": "address is address followed by ff15 70 to 80 0 1 e 4 which is listed here and",
    "start": "1350980",
    "end": "1358929"
  },
  {
    "text": "then we collect the PT e of this address and finally we'll collect the target",
    "start": "1358929",
    "end": "1365770"
  },
  {
    "text": "address so if you DD this function pointer you get the real target address",
    "start": "1365770",
    "end": "1371460"
  },
  {
    "text": "7 5 0 4 3 CD 0 as listed here and the 8",
    "start": "1371460",
    "end": "1378940"
  },
  {
    "text": "bytes of information from the target address so as you can see 8 BSA's 5 5",
    "start": "1378940",
    "end": "1386350"
  },
  {
    "text": "and ABC so the target address a code",
    "start": "1386350",
    "end": "1391419"
  },
  {
    "text": "block almost always starts with HB v FF 5 5 so move EDI EDI gbpm movie btes D",
    "start": "1391419",
    "end": "1401500"
  },
  {
    "text": "and finally we collect the Pte of the to",
    "start": "1401500",
    "end": "1407230"
  },
  {
    "text": "address the PT of this address so as you can see that when we collect data on",
    "start": "1407230",
    "end": "1415809"
  },
  {
    "start": "1410000",
    "end": "1570000"
  },
  {
    "text": "this much of data on each indirect cost and their millions of indirect costs the",
    "start": "1415809",
    "end": "1421179"
  },
  {
    "text": "data file size goes up very fast and that's why we need a big data system to",
    "start": "1421179",
    "end": "1427090"
  },
  {
    "text": "help analyze the data this is the process processing pipeline data",
    "start": "1427090",
    "end": "1433570"
  },
  {
    "text": "pipeline in spark so we once we have that big chunk of data we loaded into",
    "start": "1433570",
    "end": "1440679"
  },
  {
    "text": "the system and pre-process it to remove all the duplicates cause there's so many",
    "start": "1440679",
    "end": "1446549"
  },
  {
    "text": "duplicate memory based indirect cause after that the code blocks will collected from the",
    "start": "1446549",
    "end": "1454659"
  },
  {
    "text": "from address and from the to address are disassembled by capstone",
    "start": "1454659",
    "end": "1461820"
  },
  {
    "text": "the purpose of this is to filter out all the register-based indirect costs because we are only interested in we're",
    "start": "1461820",
    "end": "1469380"
  },
  {
    "text": "only interested in memory based indirect cost after that we check if the memory is writable",
    "start": "1469380",
    "end": "1476820"
  },
  {
    "text": "through its Pte so this is the very key point the the most important part of our",
    "start": "1476820",
    "end": "1483320"
  },
  {
    "text": "study is to check if a memory is writable through its Pte and once we got",
    "start": "1483320",
    "end": "1491760"
  },
  {
    "text": "that we had to go back to the program to identify which to pinpoint which memory",
    "start": "1491760",
    "end": "1500280"
  },
  {
    "text": "based function in which library has a writable",
    "start": "1500280",
    "end": "1505670"
  },
  {
    "text": "function pointer on a memory based indirect call",
    "start": "1505670",
    "end": "1512029"
  },
  {
    "text": "yeah that our research focus basically to try to find any memory based indirect",
    "start": "1524179",
    "end": "1532950"
  },
  {
    "text": "call that has a rightful function pointer no because those are those",
    "start": "1532950",
    "end": "1547039"
  },
  {
    "text": "register based indirect cause we we don't want to look at yes so we only",
    "start": "1547039",
    "end": "1553409"
  },
  {
    "text": "look at the memory based indirect cause that's why we just fear it out yeah that's why we need to collect the code",
    "start": "1553409",
    "end": "1561690"
  },
  {
    "text": "block from the from address right okay so now so let's talk about some results",
    "start": "1561690",
    "end": "1569549"
  },
  {
    "text": "we obtained using this method okay also we are using the analysis method we just",
    "start": "1569549",
    "end": "1577559"
  },
  {
    "start": "1570000",
    "end": "1699000"
  },
  {
    "text": "mentioned we collected on edge and ie we collected about 70 milling of of",
    "start": "1577559",
    "end": "1586279"
  },
  {
    "text": "indirect calls and the data file size is about four point four gigabytes after",
    "start": "1586279",
    "end": "1592580"
  },
  {
    "text": "filtering out all those we just the base indirect calls we ended up and all the",
    "start": "1592580",
    "end": "1599429"
  },
  {
    "text": "duplicates fill out all the duplicates Wendy we ended up with a unique combination of from encourages about 20k",
    "start": "1599429",
    "end": "1607519"
  },
  {
    "text": "also on flash we collected about nine milling indirect calls and the data file",
    "start": "1607519",
    "end": "1615480"
  },
  {
    "text": "size is about 600 megabytes so after big data processing we ended up with about",
    "start": "1615480",
    "end": "1620909"
  },
  {
    "text": "700 indirect 700 calls so we found three",
    "start": "1620909",
    "end": "1628470"
  },
  {
    "text": "cases okay three cases out of if you add them up out of 100 milling indirect",
    "start": "1628470",
    "end": "1635580"
  },
  {
    "text": "calls so 3 out of 100 million calls that",
    "start": "1635580",
    "end": "1641269"
  },
  {
    "text": "those three cases of memory based indirect calls had writable function",
    "start": "1641269",
    "end": "1648809"
  },
  {
    "text": "pointers so they they were not protected by certain CFG as per policy",
    "start": "1648809",
    "end": "1655410"
  },
  {
    "text": "so two cases had the function pointer",
    "start": "1655410",
    "end": "1661670"
  },
  {
    "text": "which were located which are located within the data segment and those are in",
    "start": "1661670",
    "end": "1668670"
  },
  {
    "text": "Windows dot storage and IA pfl key our",
    "start": "1668670",
    "end": "1673740"
  },
  {
    "text": "library respectively attentively the last case R is very interesting because",
    "start": "1673740",
    "end": "1680270"
  },
  {
    "text": "this one had a red ball target function pointer which is located in the eye data",
    "start": "1680270",
    "end": "1688350"
  },
  {
    "text": "segment instead of in the data segment this way it's very interesting as I'm",
    "start": "1688350",
    "end": "1695100"
  },
  {
    "text": "going to explain each case one by one three cases in total so the first case",
    "start": "1695100",
    "end": "1701300"
  },
  {
    "start": "1699000",
    "end": "1741000"
  },
  {
    "text": "in Windows the storage library at here",
    "start": "1701300",
    "end": "1708720"
  },
  {
    "text": "we are able to friend we are able to find a memory based in direct call",
    "start": "1708720",
    "end": "1714780"
  },
  {
    "text": "called the or put the word pointer where the function pointer is located in the",
    "start": "1714780",
    "end": "1724110"
  },
  {
    "text": "data segment and this function pointer if you check the address attribute is",
    "start": "1724110",
    "end": "1729650"
  },
  {
    "text": "writable and that the safe G check was",
    "start": "1729650",
    "end": "1735780"
  },
  {
    "text": "not in place so this is our first finding the second one are very",
    "start": "1735780",
    "end": "1741870"
  },
  {
    "start": "1741000",
    "end": "1779000"
  },
  {
    "text": "similarly in IE APF lqr library at this",
    "start": "1741870",
    "end": "1747570"
  },
  {
    "text": "address there are exist a memory based in direct call calling the function pointer and",
    "start": "1747570",
    "end": "1756590"
  },
  {
    "text": "this function pointer which is also located in the data segment and if we",
    "start": "1756590",
    "end": "1764040"
  },
  {
    "text": "check the address attribute this one is also writable so two cases both had",
    "start": "1764040",
    "end": "1771120"
  },
  {
    "text": "writable function pointer in the",
    "start": "1771120",
    "end": "1776520"
  },
  {
    "text": "function pointers are located in the data segment the last one is very interesting",
    "start": "1776520",
    "end": "1782700"
  },
  {
    "start": "1779000",
    "end": "1797000"
  },
  {
    "text": "instead of having a function pointer located in the data segment is located",
    "start": "1782700",
    "end": "1788650"
  },
  {
    "text": "in the eye data segment and if you read this name of the dll you can read out is",
    "start": "1788650",
    "end": "1799420"
  },
  {
    "start": "1797000",
    "end": "1824000"
  },
  {
    "text": "like microsoft catch the flag so we did attach this flag so interesting if you",
    "start": "1799420",
    "end": "1809080"
  },
  {
    "text": "look at this address we are able to find a memory based indirect call that had a",
    "start": "1809080",
    "end": "1817440"
  },
  {
    "text": "function pointer writable as you can see from here so I said this case is of more",
    "start": "1817440",
    "end": "1827230"
  },
  {
    "start": "1824000",
    "end": "1844000"
  },
  {
    "text": "interest because the whole eye data segments the whole idea segment in this",
    "start": "1827230",
    "end": "1834340"
  },
  {
    "text": "library was writable as you can see from other static analysis so this is very",
    "start": "1834340",
    "end": "1842740"
  },
  {
    "text": "interesting because remember the gorgeous I call function pointer inserted by the compiler before each",
    "start": "1842740",
    "end": "1851370"
  },
  {
    "start": "1844000",
    "end": "1908000"
  },
  {
    "text": "before each indirect branch takes place this function pointer actually itself is",
    "start": "1851370",
    "end": "1858780"
  },
  {
    "text": "located in the eye data segment so which means that this function pointer itself",
    "start": "1858780",
    "end": "1865960"
  },
  {
    "text": "can be modified because because as you can see from here we have a safety check",
    "start": "1865960",
    "end": "1873250"
  },
  {
    "text": "function pointer before this indirect call and the function pointer of itself",
    "start": "1873250",
    "end": "1879370"
  },
  {
    "text": "is writable in this dll so actually the",
    "start": "1879370",
    "end": "1885670"
  },
  {
    "text": "previous work showed that people had to really spend the time and make an effort in order to make this function point of",
    "start": "1885670",
    "end": "1892990"
  },
  {
    "text": "rideable but in this VAR l every single safety",
    "start": "1892990",
    "end": "1898900"
  },
  {
    "text": "check function pointer what's right ball so we don't have to do anything it's already writable so we reported this",
    "start": "1898900",
    "end": "1906460"
  },
  {
    "text": "finding to Microsoft and after that we started to think this might not be the",
    "start": "1906460",
    "end": "1912250"
  },
  {
    "text": "only library that a writable I data segment within carried",
    "start": "1912250",
    "end": "1921340"
  },
  {
    "text": "out a more thorough screening using a static pee analysis using Python script",
    "start": "1921340",
    "end": "1927850"
  },
  {
    "text": "to screen for any writable I data SEC segments in all windows dll's so this is",
    "start": "1927850",
    "end": "1935320"
  },
  {
    "text": "just a snapshot of what the Python script prints out interestingly we found",
    "start": "1935320",
    "end": "1943169"
  },
  {
    "text": "with scan four thousand and ninety three windows dll files and the windows 10",
    "start": "1943169",
    "end": "1949240"
  },
  {
    "text": "32-bit system and we were able to find a for for more dll's",
    "start": "1949240",
    "end": "1957159"
  },
  {
    "text": "that all had the ideas segments writable",
    "start": "1957159",
    "end": "1962799"
  },
  {
    "text": "so it's using ddr aw dll as example as",
    "start": "1962799",
    "end": "1968980"
  },
  {
    "text": "you can see from here from either the whole eye data segment was writable so",
    "start": "1968980",
    "end": "1975220"
  },
  {
    "text": "that means all the CFG check function pointer can be can be modified on this",
    "start": "1975220",
    "end": "1983950"
  },
  {
    "text": "for libraries so we then ask and Windows 10 64 bit",
    "start": "1983950",
    "end": "1989649"
  },
  {
    "text": "system and we found the same result so basically we are reported all these",
    "start": "1989649",
    "end": "1996309"
  },
  {
    "text": "findings to Microsoft and those issues have not been fixed so now let's talk",
    "start": "1996309",
    "end": "2002909"
  },
  {
    "start": "1999000",
    "end": "2006000"
  },
  {
    "text": "about the fix for these issues so actually Microsoft fix these issues are",
    "start": "2002909",
    "end": "2009960"
  },
  {
    "start": "2006000",
    "end": "2046000"
  },
  {
    "text": "early this month so give you an example using MS City as a library at the",
    "start": "2009960",
    "end": "2017480"
  },
  {
    "text": "example before the fix as you can see that the I data segments are was",
    "start": "2017480",
    "end": "2024270"
  },
  {
    "text": "writable and after sex they are writable no more they are no longer writable this is also confirmed",
    "start": "2024270",
    "end": "2031919"
  },
  {
    "text": "doing wrong time analysis the function pointer is now read-only so basically",
    "start": "2031919",
    "end": "2040770"
  },
  {
    "text": "those are the our research work on this topic so I would like to",
    "start": "2040770",
    "end": "2047950"
  },
  {
    "start": "2046000",
    "end": "2080000"
  },
  {
    "text": "about some future work that will be carried out soon we believe that the PMU",
    "start": "2047950",
    "end": "2056460"
  },
  {
    "text": "instrumentation data collection plus big data analysis is a very powerful",
    "start": "2056460",
    "end": "2061540"
  },
  {
    "text": "framework and can be used for different bypass studies by selecting different",
    "start": "2061540",
    "end": "2067750"
  },
  {
    "text": "policies with the same data set we have collected so remember we collected these",
    "start": "2067750",
    "end": "2073510"
  },
  {
    "text": "8 pieces of information upon each indirect call so on our current work we",
    "start": "2073510",
    "end": "2082750"
  },
  {
    "start": "2080000",
    "end": "2105000"
  },
  {
    "text": "used data number 2 from code block and",
    "start": "2082750",
    "end": "2087760"
  },
  {
    "text": "data number 4 the talkative function pointer and data number 5 the PT of the",
    "start": "2087760",
    "end": "2094270"
  },
  {
    "text": "pocket function pointer to look for and protected a memory based indirect call",
    "start": "2094270",
    "end": "2100290"
  },
  {
    "text": "which had writable function pointer so alternatively we can use data number 7",
    "start": "2100290",
    "end": "2110740"
  },
  {
    "text": "to code block to look for or value the gadgets under CFG and in addition to",
    "start": "2110740",
    "end": "2119290"
  },
  {
    "text": "that we can use data number data item number 7 cube code block to look for",
    "start": "2119290",
    "end": "2128170"
  },
  {
    "text": "unguarded integrated jump in the two code block and lastly we can apply data",
    "start": "2128170",
    "end": "2137800"
  },
  {
    "text": "number 3 and a data number 8 the PT of the from address and PT of the to",
    "start": "2137800",
    "end": "2145210"
  },
  {
    "text": "address to look for cases with both the writable and executable a memory address",
    "start": "2145210",
    "end": "2153210"
  },
  {
    "text": "which could be also considered as CFG bypass okay so in summary CFG is a",
    "start": "2153210",
    "end": "2163630"
  },
  {
    "text": "powerful mitigation technique that effectively increases the difficulty and cost for memory corruption exploitation",
    "start": "2163630",
    "end": "2171240"
  },
  {
    "text": "being different from multiple previous studies reporting safety bypass",
    "start": "2171240",
    "end": "2176619"
  },
  {
    "text": "approaches our work focused on finding memory based indirect cost writeable target address pointers which",
    "start": "2176619",
    "end": "2184750"
  },
  {
    "text": "can be exploit for safety bypass p.m. you performance monitoring unit based",
    "start": "2184750",
    "end": "2192690"
  },
  {
    "text": "instrumentation and big data analysis are used for data collection and analysis as well as static P screening",
    "start": "2192690",
    "end": "2200020"
  },
  {
    "text": "we found multiple result and we report it to m/s or see and lastly P mu",
    "start": "2200020",
    "end": "2207010"
  },
  {
    "text": "instrumented data collection plus big data is a very powerful framework and",
    "start": "2207010",
    "end": "2212290"
  },
  {
    "text": "can be used for different bypass studies by selecting different policies with the",
    "start": "2212290",
    "end": "2217450"
  },
  {
    "text": "same data that we have collected so with that I would like to thank you all for",
    "start": "2217450",
    "end": "2222760"
  },
  {
    "start": "2220000",
    "end": "2247000"
  },
  {
    "text": "coming here and especially I would like to we would like to express our external",
    "start": "2222760",
    "end": "2227850"
  },
  {
    "text": "acknowledgement to - Lee and Rodrigo Bronco from Intel for their review of",
    "start": "2227850",
    "end": "2233500"
  },
  {
    "text": "our work and so this is a reference list in our presentation and thank you",
    "start": "2233500",
    "end": "2242810"
  },
  {
    "text": "[Applause]",
    "start": "2242810",
    "end": "2247679"
  }
]