[
  {
    "text": "this session is going to be on source code AUD so four these people work",
    "start": "760",
    "end": "7319"
  },
  {
    "text": "together on the uh ISS um they going to be sharing with you",
    "start": "7319",
    "end": "13360"
  },
  {
    "text": "some of the secrets of souring that perhaps aren't usually written in books and so forth um it's funny I came in",
    "start": "13360",
    "end": "21039"
  },
  {
    "text": "here and I said so were you guys on the panel and they said no and that's because they're not a panel all five of",
    "start": "21039",
    "end": "26160"
  },
  {
    "text": "these guys were actually doing a presentation for so uh uh they are marked out oh I'm going to",
    "start": "26160",
    "end": "34280"
  },
  {
    "text": "Massacre your names guys NAD harat Neil mea Chris Spencer and tar was here this",
    "start": "34280",
    "end": "42360"
  },
  {
    "text": "morning doing the uh R first doing the first presentation of",
    "start": "42360",
    "end": "49239"
  },
  {
    "text": "the morning all right guys are off okay",
    "start": "49239",
    "end": "54680"
  },
  {
    "text": "um hey okay um today we're going to be speaking as he said about uh very",
    "start": "54680",
    "end": "60199"
  },
  {
    "text": "vulnerable conditions that exist in modern software uh both applications and operating systems um and how to detect",
    "start": "60199",
    "end": "66960"
  },
  {
    "text": "such conditions uh we're going to be speaking about both Unix and win32 but pretty much a um uh heavy Accent on Unix",
    "start": "66960",
    "end": "75439"
  },
  {
    "text": "is win32 applications tend to be closed Source but we will be touching on it because um a lot of the concepts",
    "start": "75439",
    "end": "81640"
  },
  {
    "text": "actually apply even if you don't have the source code um we're going to be concentrating on popular apis in both",
    "start": "81640",
    "end": "88600"
  },
  {
    "text": "types of operating systems as well as a couple of dangerous era conditions that programs are prone to when using C++",
    "start": "88600",
    "end": "95360"
  },
  {
    "text": "which is the type of code we generally audit um we'll each be describing",
    "start": "95360",
    "end": "100960"
  },
  {
    "text": "vulnerabilities and showing demonstrations and source code from Real World applications to give people a",
    "start": "100960",
    "end": "106399"
  },
  {
    "text": "better idea about uh how these vulnerabilities actually actually appear in practice uh some of the examples we're",
    "start": "106399",
    "end": "113240"
  },
  {
    "text": "giving out um all of them have now been disclosed",
    "start": "113240",
    "end": "118520"
  },
  {
    "text": "uh uh but the latest one was actually disclosed today so it might not yet be widely known",
    "start": "118520",
    "end": "124479"
  },
  {
    "text": "here um a lot of papers so we decided to do this uh because a lot of papers have",
    "start": "124479",
    "end": "130920"
  },
  {
    "text": "been brought out on bug track and stuff that um basically describe in detail how to exploit buffer",
    "start": "130920",
    "end": "137599"
  },
  {
    "text": "overflows uh various different types uh stack based overflows and also um",
    "start": "137599",
    "end": "143360"
  },
  {
    "text": "techniques for um misusing maloc implementations to gain control of a process uh and",
    "start": "143360",
    "end": "150800"
  },
  {
    "text": "even like writing Shell Code for different architectures with tips on how to eliminate null bites and stuff and",
    "start": "150800",
    "end": "157879"
  },
  {
    "text": "these are all really valuable um but in order to exploit them uh you actually",
    "start": "157879",
    "end": "163040"
  },
  {
    "text": "have to be able to find the bugs in the first place uh which is why we chose this topic um rather than exploitation",
    "start": "163040",
    "end": "170040"
  },
  {
    "text": "techniques because in in the past bugs were pretty easy to find you just had to like GP for a string copy routine or",
    "start": "170040",
    "end": "176959"
  },
  {
    "text": "something and um it was not much of a science but now it's a lot more difficult to locate some more subtle",
    "start": "176959",
    "end": "183519"
  },
  {
    "text": "bugs and the auditor must often understand the logic and mechanics of the program that he or she is",
    "start": "183519",
    "end": "189519"
  },
  {
    "text": "analyzing uh please note that this speech isn't definitive um finering security vulnerabilities is really",
    "start": "189519",
    "end": "195480"
  },
  {
    "text": "limited to the auditor's imagination really um and so what we cover here is only a",
    "start": "195480",
    "end": "202560"
  },
  {
    "text": "subset of all possible vulnerabilities uh there's also some other types that we know about and stuff",
    "start": "202560",
    "end": "209799"
  },
  {
    "text": "but we can't fit it all into this speech um this is going to be uh we're going to",
    "start": "209799",
    "end": "217360"
  },
  {
    "text": "basically divide the speech into a couple of different uh sections um",
    "start": "217360",
    "end": "225640"
  },
  {
    "text": "so uh we're basically going to firstly present methodology of how you go about",
    "start": "225640",
    "end": "231360"
  },
  {
    "text": "attacking some a large codebase to find vulnerabilities and then we're going to talk about various classes of bugs and",
    "start": "231360",
    "end": "239280"
  },
  {
    "text": "as well as tools of the trade uh the main types of class of bugs we're going to talk about are dangerous",
    "start": "239280",
    "end": "245360"
  },
  {
    "text": "library and API functions uh these are pretty well known as we said before so we're not going to spend long on this uh",
    "start": "245360",
    "end": "252200"
  },
  {
    "text": "then we're going to also talk about unsafe use of Point arithmetic uh subtle trust relationships",
    "start": "252200",
    "end": "258799"
  },
  {
    "text": "and also integer manipulation issues which have been a lot more prant",
    "start": "258799",
    "end": "264800"
  },
  {
    "text": "recently um so we're going to go over to methodology now with",
    "start": "265520",
    "end": "271720"
  },
  {
    "text": "okay so in order to find bugs in large software programs um you need to have a",
    "start": "281000",
    "end": "288440"
  },
  {
    "text": "a planned method of going through them I mean you can you can't just randomly read them and hope to stumble upon a bug",
    "start": "288440",
    "end": "294680"
  },
  {
    "text": "and so we've tried to split it up into three different methodologies um the first one I'll talk about is is the top-",
    "start": "294680",
    "end": "300199"
  },
  {
    "text": "down methodology where you start at the the program entry point and you read through each and every relevant code",
    "start": "300199",
    "end": "306039"
  },
  {
    "text": "path and you try to understand um the larger scope of the program and",
    "start": "306039",
    "end": "311759"
  },
  {
    "text": "how every API interacts and you want to get a very deep understanding of the",
    "start": "311759",
    "end": "317120"
  },
  {
    "text": "internals of the program so that you can spot very subtle bugs um the thing about",
    "start": "317120",
    "end": "322400"
  },
  {
    "text": "this is that it can take a lot of time and um it may not be necessary to to go",
    "start": "322400",
    "end": "328400"
  },
  {
    "text": "into that depth for to find certain bugs um so another way to go about it would",
    "start": "328400",
    "end": "335440"
  },
  {
    "text": "be to try a a bottom up approach where you look for U dangerous um apis or D",
    "start": "335440",
    "end": "343160"
  },
  {
    "text": "what looks like really messy code and you trace backwards and see if there's a potential for vulnerability there so um",
    "start": "343160",
    "end": "350520"
  },
  {
    "text": "you'll spot more obvious bugs this way quite easily because obviously it'll",
    "start": "350520",
    "end": "355840"
  },
  {
    "text": "stick out that well he's doing an S printf here or he's uh well we'll go",
    "start": "355840",
    "end": "362639"
  },
  {
    "text": "into that more detail when we discuss the actual bugs but um you're going to miss a lot of subtle stuff and a lot of",
    "start": "362639",
    "end": "368880"
  },
  {
    "text": "stuff that um requires uh a deeper understanding of the know of the program",
    "start": "368880",
    "end": "375160"
  },
  {
    "text": "you're analyzing um so a hybrid approach sort of incorporates The Best of Both Worlds",
    "start": "375160",
    "end": "381160"
  },
  {
    "text": "where you might go and look for potentially dangerous places within the code such as anything that processes",
    "start": "381160",
    "end": "387759"
  },
  {
    "text": "user input anything that does parsing um anything where a programmer",
    "start": "387759",
    "end": "394039"
  },
  {
    "text": "might make a potentially fatal mistake um and then what you try to do is to",
    "start": "394039",
    "end": "399960"
  },
  {
    "text": "understand that part of the code in depth and Trace forward and uh determine whether or not a vulnerability",
    "start": "399960",
    "end": "406599"
  },
  {
    "text": "exists um it's a more focused approach I like this one better and it'll it'll",
    "start": "406599",
    "end": "412639"
  },
  {
    "text": "save a lot of time while you can still find some nice uh some very nice bugs using this um some other things that are",
    "start": "412639",
    "end": "419680"
  },
  {
    "text": "helpful is uh basically you want to be able to keep",
    "start": "419680",
    "end": "425120"
  },
  {
    "text": "track of all the necessary conditions to uh create a vulnerability so",
    "start": "425120",
    "end": "431240"
  },
  {
    "text": "um what I tend to do when I audit is to um create a list of requirements for",
    "start": "431240",
    "end": "436360"
  },
  {
    "text": "this vulner vulnerability to be triggered and then go ahead and Trace through the code and check them off",
    "start": "436360",
    "end": "442599"
  },
  {
    "text": "saying well yeah this variable can be this value at this point in the code so yes we do have an overflow here or",
    "start": "442599",
    "end": "448479"
  },
  {
    "text": "whatever and and that allows you to go ahead and verify that avability does",
    "start": "448479",
    "end": "454800"
  },
  {
    "text": "exist without actually going and trying to write the exploit um another thing that is quite helpful is to understand",
    "start": "454800",
    "end": "461639"
  },
  {
    "text": "the way the programmer is thinking when he's written this code um if you notice a tendency to um use or to do very",
    "start": "461639",
    "end": "470120"
  },
  {
    "text": "sloppy pointer arithmetic or to to um use unsafe functions in a lot",
    "start": "470120",
    "end": "476919"
  },
  {
    "text": "of places you might want to focus on that instead of focusing on on looking for something else like energer overflows within the code and so you",
    "start": "476919",
    "end": "483159"
  },
  {
    "text": "cannot kind of understand how the programmer is thinking when they're writing this and what you might want to look",
    "start": "483159",
    "end": "489960"
  },
  {
    "text": "for um in terms of tools you don't really need complex or Advanced tools to",
    "start": "490879",
    "end": "495919"
  },
  {
    "text": "audit source code it comes down to understanding and analyzing the source and and being able to",
    "start": "495919",
    "end": "501800"
  },
  {
    "text": "think uh of something that the programmer completely missed so there",
    "start": "501800",
    "end": "507280"
  },
  {
    "text": "are things however that will help you in this process process and make your life a lot easier um in terms of uh auditing you spend a",
    "start": "507280",
    "end": "515800"
  },
  {
    "text": "lot of time in a text editor and um staring at source code there so picking a good editor is pretty critical",
    "start": "515800",
    "end": "522800"
  },
  {
    "text": "something you're comfortable with um I like to use Vim it has some issues uh some features that actually help you",
    "start": "522800",
    "end": "529839"
  },
  {
    "text": "quite a bit when auditing syntax highlighting is okay I guess if you can't spot stuff like variable",
    "start": "529839",
    "end": "535200"
  },
  {
    "text": "definitions and maybe you shouldn't be auditing code but um it it makes it",
    "start": "535200",
    "end": "540399"
  },
  {
    "text": "easier to look at something I find useful is uh bracket matching if you're looking at a complex code branch and uh",
    "start": "540399",
    "end": "548480"
  },
  {
    "text": "you'll see maybe five or six brackets open up and you're trying to track down where one closes this can help you just",
    "start": "548480",
    "end": "554480"
  },
  {
    "text": "to understand the flow of the code um C tags is also very useful because you can navigate the the source code quite",
    "start": "554480",
    "end": "561360"
  },
  {
    "text": "easily from within the editor and jump to uh the definitions of functions or variables quite easily rather than",
    "start": "561360",
    "end": "568399"
  },
  {
    "text": "trying to your editor and going and trying to grap the entire Source tree finding out where this function is or",
    "start": "568399",
    "end": "573760"
  },
  {
    "text": "whatever um so Vim has all those features emac it has all those and",
    "start": "573760",
    "end": "579000"
  },
  {
    "text": "probably a million more it's pretty big I'm sure you've heard all the jokes about the acronyms for emac like I don't",
    "start": "579000",
    "end": "585640"
  },
  {
    "text": "know eight Megs and constantly swapping or all those stupid jokes right so um",
    "start": "585640",
    "end": "590760"
  },
  {
    "text": "and Pico has uh none of these features and it never will so don't use",
    "start": "590760",
    "end": "597360"
  },
  {
    "text": "that um Source browsers are pretty useful too um I think Source Navigator",
    "start": "597360",
    "end": "602680"
  },
  {
    "text": "runs on a variety of platforms I've seen it on Windows and I believe there's a compiles on Linux too so uh it's quite",
    "start": "602680",
    "end": "609800"
  },
  {
    "text": "useful you can actually sort of navigate through the source by uh",
    "start": "609800",
    "end": "616079"
  },
  {
    "text": "following where functions go and tracing from one function to another and so on so it's quite useful my personal",
    "start": "616079",
    "end": "622120"
  },
  {
    "text": "favorite is ccope and I use that a lot um you can use it to recursively search a very large sourcery I think I tried",
    "start": "622120",
    "end": "628519"
  },
  {
    "text": "something like uh a 300 megabyte Source tree the other day and it had no problems whatsoever so",
    "start": "628519",
    "end": "634399"
  },
  {
    "text": "it's quite robust you can locate the definition or the use of any c symbol within this large Source tree so if you",
    "start": "634399",
    "end": "641440"
  },
  {
    "text": "want to find where a variable is defined you can go ahead and look at that or you can find all instances in which this",
    "start": "641440",
    "end": "648440"
  },
  {
    "text": "variable is accessed used whatever so that's very useful um you can track all",
    "start": "648440",
    "end": "655120"
  },
  {
    "text": "locations where a function is called or all the functions called by any specific fun function so that's quite useful and",
    "start": "655120",
    "end": "662000"
  },
  {
    "text": "what it'll do is it'll give you a list of of all the uh the references found and then you can invoke your editor and",
    "start": "662000",
    "end": "668440"
  },
  {
    "text": "go ahead and look in Greater depth there I'm sure a lot of you use this and uh it's pretty good there's a there's some",
    "start": "668440",
    "end": "674720"
  },
  {
    "text": "plugins for different editors where you can invoke ccope from within the editor so that that'll make your life a little",
    "start": "674720",
    "end": "681560"
  },
  {
    "text": "easier um cbrowser is a graphical front end uh I think it's",
    "start": "681560",
    "end": "686720"
  },
  {
    "text": "tcltk for uh for ccope so if you like graphical user interfaces give that a",
    "start": "686720",
    "end": "693120"
  },
  {
    "text": "try and um there's some automated auditing tools out there I really don't",
    "start": "693120",
    "end": "698680"
  },
  {
    "text": "like them I think they they suck um if you try them out they'll find some",
    "start": "698680",
    "end": "704839"
  },
  {
    "text": "things but some of them are basically just grepping for S printf and string copy and whatever some of them go to",
    "start": "704839",
    "end": "710880"
  },
  {
    "text": "Greater depth you might want to try out uh splint has the ability to find some",
    "start": "710880",
    "end": "716160"
  },
  {
    "text": "complex bugs but it can't analyze the more complex um logic bugs and uh SQL is",
    "start": "716160",
    "end": "723839"
  },
  {
    "text": "I haven't actually been able to try that out but some people tell me it's pretty good and uh just one other thing that",
    "start": "723839",
    "end": "730680"
  },
  {
    "text": "might be useful uh a lot of vendors offer a CVS web interface to their",
    "start": "730680",
    "end": "735800"
  },
  {
    "text": "Source tree and so you can go there and check track recent changes in the latest releases and see when they patched this",
    "start": "735800",
    "end": "741440"
  },
  {
    "text": "or if they have um what subtle changes they're trying to slip by without doing an advisory on or whatever so sometimes",
    "start": "741440",
    "end": "748160"
  },
  {
    "text": "that's quite useful and I think that's it for tools and",
    "start": "748160",
    "end": "753639"
  },
  {
    "text": "methodology um most of the ones I talked about are free uh I think you have to pay for it4 but everything else I",
    "start": "757519",
    "end": "764199"
  },
  {
    "text": "mentioned are they're available free and most of them are open",
    "start": "764199",
    "end": "768399"
  },
  {
    "text": "source source I have heard that",
    "start": "772560",
    "end": "780680"
  },
  {
    "text": "okay um we're just going to move on now to dangerous lib C functions these have been covered a lot in the past but as we",
    "start": "780680",
    "end": "788040"
  },
  {
    "text": "said we're going to just have to go over them for completeness his sake uh we're just basically going to quickly mention",
    "start": "788040",
    "end": "793880"
  },
  {
    "text": "uh two classes of functions uh one is unbounded memory copies such as string",
    "start": "793880",
    "end": "800079"
  },
  {
    "text": "copy string cat um s print FV s print F all that kind of stuff um as you know if",
    "start": "800079",
    "end": "806000"
  },
  {
    "text": "you've got a uh Source buffer that's uh you copying Source data that's uh got",
    "start": "806000",
    "end": "812680"
  },
  {
    "text": "more data than can fit to the destination buffer then you can um influence this state of the program and",
    "start": "812680",
    "end": "818800"
  },
  {
    "text": "the execution flow and often get REM rout access or execute arbitary code uh",
    "start": "818800",
    "end": "825120"
  },
  {
    "text": "there's to combat these problems a while ago there was um bounded memory copy",
    "start": "825120",
    "end": "831480"
  },
  {
    "text": "copy functions that were introduced um these were meant to eliminate the",
    "start": "831480",
    "end": "837079"
  },
  {
    "text": "problems uh inherent with the prev previously me mentioned functions uh they usually take an extra parameter",
    "start": "837079",
    "end": "843040"
  },
  {
    "text": "denoting the maximum size of the destination buffer but it lately became apparent that some of these functions",
    "start": "843040",
    "end": "848079"
  },
  {
    "text": "were also quite misleading and could be used to caus buff for overflow conditions as well um we're mainly",
    "start": "848079",
    "end": "854399"
  },
  {
    "text": "talking about these kind of bug these kind of functions which have also been covered in reasonable depth in the past",
    "start": "854399",
    "end": "861800"
  },
  {
    "text": "um the first function we mention here is Stern copy uh which has the problem that",
    "start": "861800",
    "end": "867560"
  },
  {
    "text": "if the sour string length exceeds the maximum size of the destination buffer then the destination buffer would not",
    "start": "867560",
    "end": "872839"
  },
  {
    "text": "null terminate the string um which although doesn't seem like too much of an issue problems can arise when",
    "start": "872839",
    "end": "878279"
  },
  {
    "text": "programmers attempt to append a null which can result in a one bite overflow uh which has happened reasonably",
    "start": "878279",
    "end": "883959"
  },
  {
    "text": "frequently in the past uh copy the string into another buffer of the same size often resulting in a one bite",
    "start": "883959",
    "end": "890759"
  },
  {
    "text": "overflow or copying or concatenating the string into another buffer when another string buffer is in an adjacent memory",
    "start": "890759",
    "end": "897560"
  },
  {
    "text": "location uh thus forming a larger buffer um the second function Str strn",
    "start": "897560",
    "end": "904360"
  },
  {
    "text": "cat uh has similar problems but in many situations is is more dangerous because",
    "start": "904360",
    "end": "910000"
  },
  {
    "text": "it's misleading for three reasons um firstly uh the size argument for string",
    "start": "910000",
    "end": "917320"
  },
  {
    "text": "Str strncat doesn't account for the trailing null um oh well no firstly there's the",
    "start": "917320",
    "end": "924440"
  },
  {
    "text": "misleading size value in strn capap which is basically it looks like it should be the size of the buffer that",
    "start": "924440",
    "end": "931000"
  },
  {
    "text": "you give as an argument but it's actually the remaining length in the buffer um there's actually strl cat now",
    "start": "931000",
    "end": "936240"
  },
  {
    "text": "which um fixes this problem um secondly strncat doesn't account for the trailing",
    "start": "936240",
    "end": "942399"
  },
  {
    "text": "null bite when processing the size value so um you actually have to pass the size",
    "start": "942399",
    "end": "948040"
  },
  {
    "text": "value as the remaining length minus one to so that strn cat W append to n bite",
    "start": "948040",
    "end": "954079"
  },
  {
    "text": "pass the end of the buffer and there's thirdly potential um underflow problems",
    "start": "954079",
    "end": "959319"
  },
  {
    "text": "when addressing the trailing null issue uh basically what that means is um if",
    "start": "959319",
    "end": "965240"
  },
  {
    "text": "you've got a a buffer that you can make the string length of the buffer the same",
    "start": "965240",
    "end": "970680"
  },
  {
    "text": "as the size of the buffer you can often cause the size argument to underflow",
    "start": "970680",
    "end": "975920"
  },
  {
    "text": "because um because often the size is is",
    "start": "975920",
    "end": "982079"
  },
  {
    "text": "calculated dynamically and it'll usually be like size of buff minus Str Str L",
    "start": "982079",
    "end": "987560"
  },
  {
    "text": "buff minus one so so um if size of buff and Str L of buff is the same thing then",
    "start": "987560",
    "end": "993279"
  },
  {
    "text": "minus one will get past to strr incat as um as a size value which will be cast to",
    "start": "993279",
    "end": "999160"
  },
  {
    "text": "a huge positive value because it's a size T type and um finally there's misuse of",
    "start": "999160",
    "end": "1006360"
  },
  {
    "text": "return values in SN printf um basically that's just referring to the fact that",
    "start": "1006360",
    "end": "1011839"
  },
  {
    "text": "SN printf um and vsn prf actually returned the number of bytes that it would have written into a buffer rather",
    "start": "1011839",
    "end": "1017839"
  },
  {
    "text": "than what it did write um what it would have written if there was enough room and uh programmers often sometimes uh",
    "start": "1017839",
    "end": "1025079"
  },
  {
    "text": "make the assumption that it'll only return a maximum of the size of the buffer but we'll talk a bit more about",
    "start": "1025079",
    "end": "1030798"
  },
  {
    "text": "that later um so there's a few quick examples uh of the three strncat",
    "start": "1030799",
    "end": "1037640"
  },
  {
    "text": "problems the first one is the remaining length issue as I said um it seems",
    "start": "1037640",
    "end": "1043000"
  },
  {
    "text": "logical that you should give the size of the buffer for the third argument but um that's actually not the case so um",
    "start": "1043000",
    "end": "1050559"
  },
  {
    "text": "uh in the example up there uh this will actually overflow by the length of the first string that's copied into the",
    "start": "1050559",
    "end": "1058640"
  },
  {
    "text": "buffer um second is the off by one problem I mentioned as I said you've got to account for an extra bite because um",
    "start": "1058640",
    "end": "1066039"
  },
  {
    "text": "Str strn cap will always append a null and doesn't account for it with the size value so um in this example uh it looks",
    "start": "1066039",
    "end": "1073320"
  },
  {
    "text": "like they're accounting for the size but they're actually off by one and can cause a one bite overflow here and the",
    "start": "1073320",
    "end": "1080000"
  },
  {
    "text": "um underflow issue that I talked about is basically yeah if you can make size",
    "start": "1080000",
    "end": "1085440"
  },
  {
    "text": "of buff and strill and buff the the same value um which often happens if you've",
    "start": "1085440",
    "end": "1090720"
  },
  {
    "text": "got a strn copy immediately proceeding an strn cat or something like that when",
    "start": "1090720",
    "end": "1096400"
  },
  {
    "text": "there's no explicit null termination um so yeah we'll move on to point",
    "start": "1096400",
    "end": "1103799"
  },
  {
    "text": "arithmetic now than okay",
    "start": "1103799",
    "end": "1109300"
  },
  {
    "text": "[Music]",
    "start": "1109300",
    "end": "1112380"
  },
  {
    "text": "um point of arithmetic okay uh memory management is a pretty important issue",
    "start": "1116280",
    "end": "1121760"
  },
  {
    "text": "in C and um is accounted for a large number of uh programming errors which have led to remote compromise um",
    "start": "1121760",
    "end": "1129520"
  },
  {
    "text": "basically manipulating sections of memory AR uh arbitrarily Alters the state of logic of the program uh we",
    "start": "1129520",
    "end": "1137080"
  },
  {
    "text": "therefore need to address poter arithmetic and show the impact it has had on uh software Security in the past",
    "start": "1137080",
    "end": "1144480"
  },
  {
    "text": "in this section we will examine the following issues um looping constructs miscalculations and off by one",
    "start": "1144480",
    "end": "1151840"
  },
  {
    "text": "errors okay um first example we're going to look at um",
    "start": "1151840",
    "end": "1158240"
  },
  {
    "text": "ntpd um as you can see here the there's a",
    "start": "1158240",
    "end": "1164640"
  },
  {
    "text": "loop here fails to terminate the end of the buffer resulting in a buffer overflow um this is often caused by failing to",
    "start": "1164640",
    "end": "1173000"
  },
  {
    "text": "terminate loot when reaching the last available place in memory of the destination buffer and in the case of",
    "start": "1173000",
    "end": "1179080"
  },
  {
    "text": "strings terminating on a nobite instead um although this seems like an",
    "start": "1179080",
    "end": "1184400"
  },
  {
    "text": "obvious era during complex paing routines it can be quite hard to avoid um and you see just here you've",
    "start": "1184400",
    "end": "1191640"
  },
  {
    "text": "got the uh star TP Plus+ equals star CP Plus+ and that's only going to terminate",
    "start": "1191640",
    "end": "1198200"
  },
  {
    "text": "when it is a um a comma a dash",
    "start": "1198200",
    "end": "1204480"
  },
  {
    "text": " okay um looping constructs LPD um this is a",
    "start": "1204480",
    "end": "1212600"
  },
  {
    "text": "Char poter Point overflow this kind of mistake has been made a few times in the past um this bug is not immediately",
    "start": "1212600",
    "end": "1218880"
  },
  {
    "text": "obvious as the one shown previously however it can be seen that like the other bug the end of the ray can be",
    "start": "1218880",
    "end": "1225960"
  },
  {
    "text": "reached without the loop being terminated um this just a wall here",
    "start": "1225960",
    "end": "1235880"
  },
  {
    "text": "oops okay um you basically got an array of pointers which is filled with UMR",
    "start": "1250039",
    "end": "1257240"
  },
  {
    "text": "dupe and that's processed every time there's a op code of three and you",
    "start": "1257240",
    "end": "1262679"
  },
  {
    "text": "basically just have to overrun 64 elements in that",
    "start": "1262679",
    "end": "1268159"
  },
  {
    "text": "array we had to cut a lot of the code out of that example because it didn't fit on the slide but that's actually in",
    "start": "1269200",
    "end": "1274880"
  },
  {
    "text": "a a while loop reading user data so um it basically gets a user string and",
    "start": "1274880",
    "end": "1280480"
  },
  {
    "text": "decides what to do with it and there's a couple of different cases that we have to cut out but um basically you can send",
    "start": "1280480",
    "end": "1286200"
  },
  {
    "text": "as many names as you want and overflow a string array and that's what that DF",
    "start": "1286200",
    "end": "1291640"
  },
  {
    "text": "list line is all about that's what causes the problem um",
    "start": "1291640",
    "end": "1298120"
  },
  {
    "text": "miscalculations um sometimes when performing performing a point of arithmetic miscalculations",
    "start": "1298120",
    "end": "1304559"
  },
  {
    "text": "can be made as to how much space is left in the buffer uh this can allow for uh",
    "start": "1304559",
    "end": "1310080"
  },
  {
    "text": "malicious attackers to sometimes write outside the bounds of the destination buffer um and the bind 8 TC bug was an",
    "start": "1310080",
    "end": "1318039"
  },
  {
    "text": "example of last year okay uh off by one errors um in the",
    "start": "1318039",
    "end": "1324320"
  },
  {
    "text": "previous examples large buffer overflows were occurring due to failure to recognize the end sometimes though uh",
    "start": "1324320",
    "end": "1330880"
  },
  {
    "text": "when calculations are done a little more carefully termination can occur at the end of a buffer however um there are",
    "start": "1330880",
    "end": "1337279"
  },
  {
    "text": "quite often off by one errors which one by too many or one too many data elements written to a buffer um and this",
    "start": "1337279",
    "end": "1344320"
  },
  {
    "text": "is an old example from open BSD ftpd um",
    "start": "1344320",
    "end": "1349400"
  },
  {
    "text": "um the the pointer just points outside the bounds of the buffer after that for",
    "start": "1349400",
    "end": "1354799"
  },
  {
    "text": "Loop and a nobot is written [Music]",
    "start": "1354799",
    "end": "1360960"
  },
  {
    "text": "um exploitation of this bug depends on uh what variable you can overwrite or if you overwrite some Save State",
    "start": "1360960",
    "end": "1367240"
  },
  {
    "text": "information typically the low bite of the base pointer for Intel stack uh Intel stack based one B uh yeah",
    "start": "1367240",
    "end": "1376440"
  },
  {
    "text": "it also depends on the buffer size um if the buffer size is an odd number or often not a multiple of four",
    "start": "1376440",
    "end": "1383480"
  },
  {
    "text": "the buffer will be padded with extra bites for optimization reasons which renders the bug unexit this happens",
    "start": "1383480",
    "end": "1389559"
  },
  {
    "text": "sometimes when operating systems declare common variables with odd numbers like Max PA Ling as",
    "start": "1389559",
    "end": "1396200"
  },
  {
    "text": "255 or a buff declar as um buff Max Ling line plus",
    "start": "1396200",
    "end": "1403279"
  },
  {
    "text": "one um okay",
    "start": "1403279",
    "end": "1410440"
  },
  {
    "text": "a lot of Po arithmetic bugs can be quite subtle and difficult uh to spot",
    "start": "1410440",
    "end": "1415480"
  },
  {
    "text": "especially in programs that keep multiple pointers pointing to the same buffer attempting to keep save locations",
    "start": "1415480",
    "end": "1421200"
  },
  {
    "text": "in buffers and doing a lot of memory copy operations buff overflows that occur as a result of poter arithmetic",
    "start": "1421200",
    "end": "1427799"
  },
  {
    "text": "bugs most often occur in one of the following situations um got the off by one",
    "start": "1427799",
    "end": "1435039"
  },
  {
    "text": "miscalculation as previously discussed errors often often occur in looping constructs when one too many iterations",
    "start": "1435039",
    "end": "1442559"
  },
  {
    "text": "is performed or a bite is appended uh after a bounded Loop usually a null",
    "start": "1442559",
    "end": "1447799"
  },
  {
    "text": "bite um similarly uh poter variable can be incremented to a point one bite out",
    "start": "1447799",
    "end": "1454600"
  },
  {
    "text": "of the buffer which might be useful uh to not only write an extra bite into the buffer but also to",
    "start": "1454600",
    "end": "1460760"
  },
  {
    "text": "underflow the length variable here's an example um this looks okay like uh",
    "start": "1460760",
    "end": "1469640"
  },
  {
    "text": "terminating the string um after 123 bytes and you're just using a string and",
    "start": "1469640",
    "end": "1476080"
  },
  {
    "text": "copy to copy the user data in but the problem here is um pointer is",
    "start": "1476080",
    "end": "1481840"
  },
  {
    "text": "incremented um outside the bounds of the buffer and then when you have this length",
    "start": "1481840",
    "end": "1487039"
  },
  {
    "text": "calculation it's going to underflow and uh negative -1 is going to be passed as a size argument to the next string and",
    "start": "1487039",
    "end": "1495200"
  },
  {
    "text": "copy okay um um next one is excessive pointer",
    "start": "1496840",
    "end": "1502000"
  },
  {
    "text": "increment incrementing pointer um too far this is like the last scenario",
    "start": "1502000",
    "end": "1508039"
  },
  {
    "text": "except the pointer is incremented multiple part bites past the end of the buffer this may occur due to unexpected",
    "start": "1508039",
    "end": "1514159"
  },
  {
    "text": "return values from a function or misinterpretation of length remaining in a buffer um we look at this example for",
    "start": "1514159",
    "end": "1521679"
  },
  {
    "text": "SN printf functions um they return the number of btes that would have been written if enough buffer space was",
    "start": "1521679",
    "end": "1528039"
  },
  {
    "text": "provided bed in the destination buffer however programmers sometimes assumed that uh these functions only return the",
    "start": "1528039",
    "end": "1534120"
  },
  {
    "text": "maximum number of bites uh they have actually written resulting in bugs such as this",
    "start": "1534120",
    "end": "1542278"
  },
  {
    "text": "um yeah yeah",
    "start": "1544120",
    "end": "1548760"
  },
  {
    "text": "okay yeah the more modern behavior is to return the the amount of data it should have written if there was enough space",
    "start": "1549640",
    "end": "1555360"
  },
  {
    "text": "left in offer but old implementations return - one and uh you'll see that in a",
    "start": "1555360",
    "end": "1561000"
  },
  {
    "text": "lot of older codes still okay um the first SN print F looks",
    "start": "1561000",
    "end": "1567640"
  },
  {
    "text": "fairly safe um just writes data to the buffer but it increments the pointer way past the bounds of the actual buffer and",
    "start": "1567640",
    "end": "1575039"
  },
  {
    "text": "the next next Dan uh SM printf underflows with the length specifier due",
    "start": "1575039",
    "end": "1580760"
  },
  {
    "text": "to the calculation and uh yeah that's obviously a problem okay um next thing is Union",
    "start": "1580760",
    "end": "1591039"
  },
  {
    "text": "management okay I'll just very briefly go over this I'm sure most of you know this um a union is a uh a data structure",
    "start": "1600279",
    "end": "1606960"
  },
  {
    "text": "in which the uh the elements overlap in memory so here we have Union with an integer a short integer and a character",
    "start": "1606960",
    "end": "1613640"
  },
  {
    "text": "pointer and um the size of this this data structure is actually 4 bytes on a",
    "start": "1613640",
    "end": "1619039"
  },
  {
    "text": "32-bit architecture so um the uh the fact that these elements",
    "start": "1619039",
    "end": "1624840"
  },
  {
    "text": "overlap in memory can lead to some potential security vulnerabilities um basically the problem that can happen",
    "start": "1624840",
    "end": "1632640"
  },
  {
    "text": "here is that you m take one data member for another and um can lead to type",
    "start": "1632640",
    "end": "1638000"
  },
  {
    "text": "confusion um you might mistake an integer for a a",
    "start": "1638000",
    "end": "1643640"
  },
  {
    "text": "different integer which might be limited to a certain range of values or you might M take an integer for a pointer",
    "start": "1643640",
    "end": "1649640"
  },
  {
    "text": "and um that can have some interesting consequences I'm just going to show a an",
    "start": "1649640",
    "end": "1654799"
  },
  {
    "text": "example here of a potentially vulnerable application and uh very briefly go over",
    "start": "1654799",
    "end": "1660480"
  },
  {
    "text": "this so you can illustrate what's going on here we have",
    "start": "1660480",
    "end": "1665559"
  },
  {
    "text": "our our Union here within the data structure you can't see when it's highlighted but we have a uh an integer",
    "start": "1665559",
    "end": "1672840"
  },
  {
    "text": "within the union and a a character pointer I hope that's readable um",
    "start": "1672840",
    "end": "1679320"
  },
  {
    "text": "and uh we have a a a user an input routine here that reads data from the",
    "start": "1679320",
    "end": "1684880"
  },
  {
    "text": "user and it's aware that it's processing a data structure that contains a union so it um it properly processes the data",
    "start": "1684880",
    "end": "1692519"
  },
  {
    "text": "structure and it stores it could be an integer it could be a string um that's",
    "start": "1692519",
    "end": "1699360"
  },
  {
    "text": "done properly and uh we have our vulnerable function here which checks",
    "start": "1699360",
    "end": "1705159"
  },
  {
    "text": "the uh this the character pointer element and Compares One String to uh",
    "start": "1705159",
    "end": "1710440"
  },
  {
    "text": "what should be the correct string if it's not correct tries to free that string um and in our main",
    "start": "1710440",
    "end": "1717360"
  },
  {
    "text": "function um all it does is it reads the data and then passes it to our",
    "start": "1717360",
    "end": "1722640"
  },
  {
    "text": "vulnerable function without actually checking whether or not uh the the value",
    "start": "1722640",
    "end": "1728120"
  },
  {
    "text": "within the union is the is of the correct type so what you could do here is uh the user a malicious user could send",
    "start": "1728120",
    "end": "1735559"
  },
  {
    "text": "a data structure which contains an integer within that Union and it would be passed to the uh vulnerable function which thinks it's",
    "start": "1735559",
    "end": "1741679"
  },
  {
    "text": "the character pointer and then tries to free it and if you can arbitrarily specify the address which you're freeing",
    "start": "1741679",
    "end": "1748360"
  },
  {
    "text": "um it's very easy from there to obtain or to execute arbitrary code um I know",
    "start": "1748360",
    "end": "1754919"
  },
  {
    "text": "this looks like a bit of a a stupid mistake to make I mean obviously the the coder should just check which type is is",
    "start": "1754919",
    "end": "1761200"
  },
  {
    "text": "present within the union but I've actually seen this in code and people do make this mistake and um it happens in",
    "start": "1761200",
    "end": "1768440"
  },
  {
    "text": "code where the uh the remote user is allowed to transmit data structures directly or",
    "start": "1768440",
    "end": "1774640"
  },
  {
    "text": "specify quite uh specifically what the data structure contains um if you're",
    "start": "1774640",
    "end": "1780080"
  },
  {
    "text": "trying to think about where that might happen um the the thing that comes to mind immediately is uh RPC and the",
    "start": "1780080",
    "end": "1786919"
  },
  {
    "text": "external data representation xdr allows the remote user to transmit data structures directly pretty much and uh",
    "start": "1786919",
    "end": "1794880"
  },
  {
    "text": "it's well it's not easy to make this mistake but it does occur in that type of code",
    "start": "1794880",
    "end": "1800039"
  },
  {
    "text": "next is uh subtle trust",
    "start": "1811320",
    "end": "1814600"
  },
  {
    "text": "relationships well um can you guys hear me all right uh",
    "start": "1823279",
    "end": "1828799"
  },
  {
    "text": "take that as yes um well this is actually one of my",
    "start": "1828799",
    "end": "1835080"
  },
  {
    "text": "favorite classes of bugs so to speak for various reasons firstly being that uh",
    "start": "1835080",
    "end": "1841120"
  },
  {
    "text": "it's sort of like a little job guarantee for me because I know that this kind of bugs are never going to be found by a little monkey Farm in somew country so",
    "start": "1841120",
    "end": "1849919"
  },
  {
    "text": "uh well like the um my colleagues explained",
    "start": "1849919",
    "end": "1855760"
  },
  {
    "text": "before these kind of bugs actually can be",
    "start": "1855760",
    "end": "1860840"
  },
  {
    "text": "found more through the hybrid or the top down approach as opposed to the more",
    "start": "1860840",
    "end": "1867799"
  },
  {
    "text": "widespread bottom up approach because to discover this type of bugs you need a",
    "start": "1867799",
    "end": "1873360"
  },
  {
    "text": "sort of higher level analysis than what is possible through a typical",
    "start": "1873360",
    "end": "1879559"
  },
  {
    "text": "bottom up approach well um there are a couple of instances or a couple of subclasses of",
    "start": "1879559",
    "end": "1886799"
  },
  {
    "text": "instances where this type of bu bugs happen and um I'd like to like uh sort",
    "start": "1886799",
    "end": "1893360"
  },
  {
    "text": "of go deeper into them with some kind of real life examples later on but first I",
    "start": "1893360",
    "end": "1899279"
  },
  {
    "text": "would like present to you what these actual sub classes might be and um even",
    "start": "1899279",
    "end": "1904960"
  },
  {
    "text": "though they may sound fairly theoretical and",
    "start": "1904960",
    "end": "1910159"
  },
  {
    "text": "somewhat unrealistic these do really happen and these do happen in major software products",
    "start": "1910159",
    "end": "1915799"
  },
  {
    "text": "so it is something that we should not ignore when we are auditing software by any means the first thing is that in",
    "start": "1915799",
    "end": "1923960"
  },
  {
    "text": "complex software products a lot of internal components interconnect with each other and work together to provide",
    "start": "1923960",
    "end": "1931080"
  },
  {
    "text": "the actual application functionality and there's a lot of assumptions that are made about how these internal components",
    "start": "1931080",
    "end": "1939320"
  },
  {
    "text": "communicate with each other and interact with each other when it comes to the behavior and",
    "start": "1939320",
    "end": "1944880"
  },
  {
    "text": "uh this can be exploited in some situations by an external entity",
    "start": "1944880",
    "end": "1951159"
  },
  {
    "text": "to sort of mislead an internal component into believing that it's doing something",
    "start": "1951159",
    "end": "1956519"
  },
  {
    "text": "that it should be doing when it shouldn't be doing what it should be doing and um secondly server application",
    "start": "1956519",
    "end": "1963679"
  },
  {
    "text": "sometimes trust externally available information which is which might not",
    "start": "1963679",
    "end": "1968720"
  },
  {
    "text": "entirely be directly related to the functionality that the application is performing at the moment but it is",
    "start": "1968720",
    "end": "1974480"
  },
  {
    "text": "indirectly related in terms of whether it's going to be some client information or some third party token describing the",
    "start": "1974480",
    "end": "1981399"
  },
  {
    "text": "client's state or something like that and another big problem which you",
    "start": "1981399",
    "end": "1986639"
  },
  {
    "text": "usually see with a lot of proprietary software is that proprietary server",
    "start": "1986639",
    "end": "1991679"
  },
  {
    "text": "applications with undocumented protocols tend",
    "start": "1991679",
    "end": "1996440"
  },
  {
    "text": "to they I mean probably because of she arrogance I suppose but they tend to",
    "start": "1996799",
    "end": "2002799"
  },
  {
    "text": "think that their client application which is the intended client application is the one which is always going to",
    "start": "2002799",
    "end": "2008320"
  },
  {
    "text": "access the server services and uh not anything else but unfortunately there's",
    "start": "2008320",
    "end": "2013919"
  },
  {
    "text": "enough people with enough talent to reverse engineer the network protocols and write their own clients and historically there has been lot of bugs",
    "start": "2013919",
    "end": "2020159"
  },
  {
    "text": "of this type which has been discovered and uh my favorite is when people actually try to do fairly",
    "start": "2020159",
    "end": "2029159"
  },
  {
    "text": "safe programming without exactly knowing what they're doing a lot of applications try to",
    "start": "2029159",
    "end": "2037039"
  },
  {
    "text": "recover from errors or gracefully terminate and deallocate resources and",
    "start": "2037039",
    "end": "2044120"
  },
  {
    "text": "save debug information logging information and what not in case of an error but the fundamental problem is",
    "start": "2044120",
    "end": "2049720"
  },
  {
    "text": "that um when an error happens in an application your the state of your",
    "start": "2049720",
    "end": "2055480"
  },
  {
    "text": "process address space is somewhat questionable so some of these tasks you do after an error has occurred can",
    "start": "2055480",
    "end": "2064079"
  },
  {
    "text": "actually lead to successful compromises system like that and of course that's",
    "start": "2064079",
    "end": "2070158"
  },
  {
    "text": "exactly the opposite of what you want so um let's first look at internal",
    "start": "2070159",
    "end": "2076280"
  },
  {
    "text": "TR relationships well there are many operating systems which contain internal",
    "start": "2076280",
    "end": "2081638"
  },
  {
    "text": "undocumented apis and uh internal client side libraries that are provided by the",
    "start": "2081639",
    "end": "2086679"
  },
  {
    "text": "system mostly closed source which enable",
    "start": "2086679",
    "end": "2091720"
  },
  {
    "text": "client server subsystems to communicate and they make a lot of assumptions regarding this meth of communication I mean from a",
    "start": "2091720",
    "end": "2100440"
  },
  {
    "text": "simple assumption from what an API what a parameter to an API call",
    "start": "2100440",
    "end": "2107720"
  },
  {
    "text": "might be or to a blind assumption like oh yeah if somebody's going to call this API it's got to be trusted because if",
    "start": "2107720",
    "end": "2114240"
  },
  {
    "text": "our code that's that's the only guy who can call it sir if you guys are familiar with um one",
    "start": "2114240",
    "end": "2120320"
  },
  {
    "text": "of the more recent uh vulnerabilities discovered in",
    "start": "2120320",
    "end": "2126640"
  },
  {
    "text": "uh Windows n stream of operating systems where anybody could query handles for",
    "start": "2126640",
    "end": "2134520"
  },
  {
    "text": "for a process from the debug subsystem that's a typical example of this type",
    "start": "2134520",
    "end": "2140839"
  },
  {
    "text": "thing and uh this and again due to shared codebase and uh shared",
    "start": "2140839",
    "end": "2146720"
  },
  {
    "text": "development resources and the same programmers programming the client and the service of systems it's it's normal",
    "start": "2146720",
    "end": "2154040"
  },
  {
    "text": "that they have they come up with this implicit assumptions without even real realize there without even realizing",
    "start": "2154040",
    "end": "2160079"
  },
  {
    "text": "that they're actually assuming these things about the software that they're writing",
    "start": "2160079",
    "end": "2164880"
  },
  {
    "text": "so I really tend to like these kind of bugs because they are only apparent",
    "start": "2165640",
    "end": "2173000"
  },
  {
    "text": "through a very high level analysis which tries to understand the actual process and the internal functionality of the",
    "start": "2173000",
    "end": "2179440"
  },
  {
    "text": "software rather than just looking for vulnerable API calls or something like that so um even though this might sound",
    "start": "2179440",
    "end": "2185520"
  },
  {
    "text": "very theoretical there so many bugs which is in this category in major operating systems it's not even",
    "start": "2185520",
    "end": "2193319"
  },
  {
    "text": "funny and when it comes to trusting external information of servers tend",
    "start": "2193319",
    "end": "2200040"
  },
  {
    "text": "to get information about client from either third party sources or",
    "start": "2200040",
    "end": "2205280"
  },
  {
    "text": "information that the client can directly control at which at the same time has no",
    "start": "2205280",
    "end": "2210960"
  },
  {
    "text": "direct relationship to what the server might be performing at that particular point in time for example one of the",
    "start": "2210960",
    "end": "2216079"
  },
  {
    "text": "more recent Microsoft Exchange bu which was released about a week back there",
    "start": "2216079",
    "end": "2222880"
  },
  {
    "text": "um the the DNS resolution services in the SMTP",
    "start": "2222880",
    "end": "2228359"
  },
  {
    "text": "code expected any client DNS name to be",
    "start": "2228359",
    "end": "2234040"
  },
  {
    "text": "of within certain boundaries or have certain type of attributes to it and uh",
    "start": "2234040",
    "end": "2242839"
  },
  {
    "text": "obviously in real life 99% of the time a legitimate client would DNS name would",
    "start": "2242839",
    "end": "2248560"
  },
  {
    "text": "adhere to all these properties and will contain the same attributes but since it is controllable by the",
    "start": "2248560",
    "end": "2255440"
  },
  {
    "text": "client there's there is always a possibility that someone can malform or craft that information maliciously",
    "start": "2255440",
    "end": "2264160"
  },
  {
    "text": "to mislead the server into doing something that it doesn't want to do or like in this case completely compromise",
    "start": "2264160",
    "end": "2270599"
  },
  {
    "text": "the server this is again uh what I was",
    "start": "2270599",
    "end": "2277520"
  },
  {
    "text": "telling about earlier where proprietary protocols and and proprietor cents are",
    "start": "2277520",
    "end": "2284040"
  },
  {
    "text": "involved uh one example of this is actually the Oracle libraries and the",
    "start": "2284040",
    "end": "2289400"
  },
  {
    "text": "Oracle TNS listener protocol uh Oracle",
    "start": "2289400",
    "end": "2296640"
  },
  {
    "text": "has multiple versions of the libraries available on possibly every platform that they support their database",
    "start": "2296640",
    "end": "2302200"
  },
  {
    "text": "products on and they expected their database services to be accessed only by or rather only through",
    "start": "2302200",
    "end": "2310359"
  },
  {
    "text": "these of sort of client libraries and um most of the Integrity checking",
    "start": "2310359",
    "end": "2318040"
  },
  {
    "text": "and error checking and things like that was actually performed on client side rather than server side because",
    "start": "2318040",
    "end": "2324040"
  },
  {
    "text": "obviously they didn't expect someone else to come and access it directly and that led to some serious problems which",
    "start": "2324040",
    "end": "2331760"
  },
  {
    "text": "left their servers completely compromised the orle TNS listener denal service and the buff overflow",
    "start": "2331760",
    "end": "2337000"
  },
  {
    "text": "vulnerability which we discovered last year is a direct",
    "start": "2337000",
    "end": "2342119"
  },
  {
    "text": "example and uh yeah back to our safe programming",
    "start": "2342880",
    "end": "2349680"
  },
  {
    "text": "issue a lot of applications today which use objectoriented uh design principles and",
    "start": "2349720",
    "end": "2356280"
  },
  {
    "text": "object oriented programming tools tend to create lot of entities",
    "start": "2356280",
    "end": "2364520"
  },
  {
    "text": "within their code and it's very structured it's very nice and in a",
    "start": "2364520",
    "end": "2369800"
  },
  {
    "text": "perfect world if something goes wrong we should be able to clean up all our problems and deallocate all our objects",
    "start": "2369800",
    "end": "2375440"
  },
  {
    "text": "and gracefully terminate leaving a nice log to the administrators or nice debug",
    "start": "2375440",
    "end": "2380760"
  },
  {
    "text": "information file to be read by any technical support staff or whatever but",
    "start": "2380760",
    "end": "2387160"
  },
  {
    "text": "the problem is that when when an error happens in an application can we trust the contents of the address pace of that",
    "start": "2387160",
    "end": "2395160"
  },
  {
    "text": "process to be reasonably nonone malformed to the extent that",
    "start": "2395160",
    "end": "2403040"
  },
  {
    "text": "your post error processing functionality can take place without",
    "start": "2403040",
    "end": "2409200"
  },
  {
    "text": "actually either being unreliable or leading to arbitary cord execution",
    "start": "2409200",
    "end": "2414800"
  },
  {
    "text": "through the cleanup routines and in most cases people don't realize how bad this",
    "start": "2414800",
    "end": "2420280"
  },
  {
    "text": "is because for example if there was a if there was a heap overflow and there was",
    "start": "2420280",
    "end": "2425960"
  },
  {
    "text": "enough V tables allocated in the Heap for C++ objects and it'll be very very",
    "start": "2425960",
    "end": "2431079"
  },
  {
    "text": "easy to actually override a v table and just override a virtual distructor which will then be called",
    "start": "2431079",
    "end": "2437920"
  },
  {
    "text": "during your cleanup routine to just make sure that everything is nicely cleaned up and at that point you'll be owned and",
    "start": "2437920",
    "end": "2443400"
  },
  {
    "text": "it'll be too late so um I have seen some Innovative approaches unfortunately uh few and too",
    "start": "2443400",
    "end": "2450839"
  },
  {
    "text": "far between where where there has been instances of",
    "start": "2450839",
    "end": "2457640"
  },
  {
    "text": "a parent control application would use another application as just a work sort",
    "start": "2457640",
    "end": "2463680"
  },
  {
    "text": "of like a Workhorse application under its sandbox complete control where all",
    "start": "2463680",
    "end": "2469480"
  },
  {
    "text": "the error cleanup and everything was done by the parent program on the child's process by a very Innovative way",
    "start": "2469480",
    "end": "2475960"
  },
  {
    "text": "of injecting code into the child's process so I mean it's it it might be",
    "start": "2475960",
    "end": "2481400"
  },
  {
    "text": "Overkill but at the same time that's probably the only kind of um",
    "start": "2481400",
    "end": "2487400"
  },
  {
    "text": "approach which would give you 100% absolute security when it comes to things like this but at the same time",
    "start": "2487400",
    "end": "2494040"
  },
  {
    "text": "obviously I mean not all the software needs this level of security so it's entirely dependent on the intended use",
    "start": "2494040",
    "end": "2499319"
  },
  {
    "text": "of the software and how secure do you want it to be well I guess that's about",
    "start": "2499319",
    "end": "2506039"
  },
  {
    "text": "it so now we are moving on to integer manipulation",
    "start": "2506240",
    "end": "2511920"
  },
  {
    "text": "okay um all right yeah as Joey said now we're going to focus on several conditions regarding integers um",
    "start": "2520960",
    "end": "2528319"
  },
  {
    "text": "integers are interesting to us because they're often used to store data lengths or calculate remaining space of buffers",
    "start": "2528319",
    "end": "2534560"
  },
  {
    "text": "both fix both fixed length and D dynamically allocated ones uh therefore if we can manipulate these integers we",
    "start": "2534560",
    "end": "2541040"
  },
  {
    "text": "are sometimes able to misrepresent how much space is is allocated or available for the program to use and Trigger",
    "start": "2541040",
    "end": "2547319"
  },
  {
    "text": "buffer overflow condition um although the result of these types of attacks are memory corruption in some form of",
    "start": "2547319",
    "end": "2553559"
  },
  {
    "text": "another they are not your standard buffer overflow um the simple buffer overflow conditions that people talk",
    "start": "2553559",
    "end": "2560040"
  },
  {
    "text": "about usually occur due to failure to account for size at all whereas integer",
    "start": "2560040",
    "end": "2565400"
  },
  {
    "text": "manipulation is more of a logic flaw uh usually explo exposing some boundary condition that that the program has not",
    "start": "2565400",
    "end": "2571640"
  },
  {
    "text": "really accounted for uh we're going to really um just talk about three things here which is signed and unsigned",
    "start": "2571640",
    "end": "2577559"
  },
  {
    "text": "integers uh differen sized integers and um integer wrapping uh which is",
    "start": "2577559",
    "end": "2583359"
  },
  {
    "text": "overflowing and underflow integers uh that I touched a little bit before on with strr incat and so",
    "start": "2583359",
    "end": "2589839"
  },
  {
    "text": "forth um okay now firstly we're going to briefly talk about how integers are",
    "start": "2589839",
    "end": "2595880"
  },
  {
    "text": "stored in a program um very quickly uh they're usually 32bit um on on a on a",
    "start": "2595880",
    "end": "2604920"
  },
  {
    "text": "machine but it it depends on the machine um um we'll assume they're 32bit here",
    "start": "2604920",
    "end": "2610319"
  },
  {
    "text": "and they are also implied to be signed so it can be positive or negative unless the unsigned qualifier is explicitly",
    "start": "2610319",
    "end": "2616599"
  },
  {
    "text": "used um I don't know if you can see that table lay too well but it's just basically a list of the maximum minimum",
    "start": "2616599",
    "end": "2623640"
  },
  {
    "text": "values for um 16bit signed unsigned uh 32 and",
    "start": "2623640",
    "end": "2628800"
  },
  {
    "text": "64-bit uh values that integers can take um the limitations and peculiarities of",
    "start": "2628800",
    "end": "2635319"
  },
  {
    "text": "the integer data types can sometimes ruc results that were not expected from a calculation uh we'll show that these can",
    "start": "2635319",
    "end": "2641480"
  },
  {
    "text": "be used for remote exploitation in a number of scenarios [Music]",
    "start": "2641480",
    "end": "2646760"
  },
  {
    "text": "um so I guess we'll first talk about uh signed and unsigned integers um often",
    "start": "2646760",
    "end": "2653119"
  },
  {
    "text": "programmers use integers for sizes of data fields or space remaining in buffers as I said before um if an",
    "start": "2653119",
    "end": "2659200"
  },
  {
    "text": "unsigned qualifier is not explicitly used then the integer will be signed uh",
    "start": "2659200",
    "end": "2664440"
  },
  {
    "text": "this doesn't usually make sense to have a negative length value for something unless an error is indicated by returning negative one from",
    "start": "2664440",
    "end": "2671040"
  },
  {
    "text": "a function and we can often use this to our advantage um usually integers can be",
    "start": "2671040",
    "end": "2677800"
  },
  {
    "text": "entered in uh negative integers can be entered into a program incorrectly in in one of two ways um which is the first is",
    "start": "2677800",
    "end": "2685440"
  },
  {
    "text": "the protocol in question uses a length specifier controlled directly by the user which fails to check if the value",
    "start": "2685440",
    "end": "2691720"
  },
  {
    "text": "supplied is less than zero and the second is a calculation is made based on some user input put uh which can be",
    "start": "2691720",
    "end": "2698200"
  },
  {
    "text": "affected in such a way to make the result less than zero um when a negative value is given",
    "start": "2698200",
    "end": "2705000"
  },
  {
    "text": "to a bounded copying function uh they're often cast to positive values implicitly which is usually a huge number uh this",
    "start": "2705000",
    "end": "2712160"
  },
  {
    "text": "number is often so large in fact that exploitation of these bugs can be sometimes quite difficult but it depends",
    "start": "2712160",
    "end": "2717359"
  },
  {
    "text": "on the target program uh we'll sort of mention this a bit more a little bit later",
    "start": "2717359",
    "end": "2723839"
  },
  {
    "text": "um but basically uh we've got an example here of a sign bug",
    "start": "2723839",
    "end": "2731240"
  },
  {
    "text": "um you've probably seen these a little bit uh recently on bug track and that kind of thing",
    "start": "2731240",
    "end": "2737359"
  },
  {
    "text": "um they're useful as I said in the previous um slide for evading maximum",
    "start": "2737359",
    "end": "2743800"
  },
  {
    "text": "length checks and stuff like that um the best way I could think of was to show some example code which you've got there",
    "start": "2743800",
    "end": "2750880"
  },
  {
    "text": "uh basically um the program is getting an integer from the socket and um checking if it's greater than 250 six",
    "start": "2750880",
    "end": "2757920"
  },
  {
    "text": "and if it is it's exiting and if not it reads it into a buffer um the problem is",
    "start": "2757920",
    "end": "2764359"
  },
  {
    "text": "if if because the integer is not explicitly declared as unsigned we can pass a value like negative one and um a",
    "start": "2764359",
    "end": "2771400"
  },
  {
    "text": "signed comparison will occur and the program will think great this is like less than 256 we can do the do the read",
    "start": "2771400",
    "end": "2778559"
  },
  {
    "text": "from the socket and copy much more data into the buffer than in fact we want to",
    "start": "2778559",
    "end": "2784640"
  },
  {
    "text": "um so sign issues are often quite subtle",
    "start": "2784640",
    "end": "2789760"
  },
  {
    "text": "and holes of this nature have gone undetected for a pretty long time uh as can be seen from the example they're",
    "start": "2789760",
    "end": "2795520"
  },
  {
    "text": "very useful for evading Max maximum length checks and still being able to send more data than has been",
    "start": "2795520",
    "end": "2802400"
  },
  {
    "text": "allocated uh different sized integers are um as the name implies integers of",
    "start": "2802400",
    "end": "2808359"
  },
  {
    "text": "different sizes are sometimes used during calculations uh implications of this can include",
    "start": "2808359",
    "end": "2815119"
  },
  {
    "text": "values 32-bit values being assigned to 16bit um variables and they can become",
    "start": "2815119",
    "end": "2821359"
  },
  {
    "text": "truncated and also they can change sign uh for example a a 32-bit negative",
    "start": "2821359",
    "end": "2828520"
  },
  {
    "text": "number can become a 16bit positive number or a 16bit negative number can be",
    "start": "2828520",
    "end": "2833720"
  },
  {
    "text": "a is not sign extended when it's stored in a 32-bit uh variable um this might seem",
    "start": "2833720",
    "end": "2841880"
  },
  {
    "text": "really silly and you think like why would people ever do this but it actually occurs um in some uh in some",
    "start": "2841880",
    "end": "2849640"
  },
  {
    "text": "major applications especially in protocols that uh use 16bit data length Fields um and",
    "start": "2849640",
    "end": "2857800"
  },
  {
    "text": "uh and they're they're often quite subtle to spot because uh the 16bit",
    "start": "2857800",
    "end": "2864520"
  },
  {
    "text": "values are stored in like big structures and you got to look at a lot of the code to actually realize what's going on and",
    "start": "2864520",
    "end": "2871960"
  },
  {
    "text": "stuff like that so um",
    "start": "2871960",
    "end": "2876119"
  },
  {
    "text": "so we'll move on to uh integer wrapping um integer wrapping is basically a class",
    "start": "2877079",
    "end": "2882520"
  },
  {
    "text": "of bugs triggered by causing an integer to go over the maximum boundary or go under the minimum boundary",
    "start": "2882520",
    "end": "2889280"
  },
  {
    "text": "um basically the principle here is that um as we showed before integers occupy",
    "start": "2889280",
    "end": "2895160"
  },
  {
    "text": "finite space in memory which is usually 32 Bits And as such we can only",
    "start": "2895160",
    "end": "2900400"
  },
  {
    "text": "represent a subset of all possible integers um this set is actually quite large and adequate for most programs uh",
    "start": "2900400",
    "end": "2907280"
  },
  {
    "text": "but if the user is able to influence the that number directly then the program can sometimes produce unexpected results",
    "start": "2907280",
    "end": "2914119"
  },
  {
    "text": "leading to remote compromise um we'll consider a few hypothetical examples um",
    "start": "2914119",
    "end": "2920280"
  },
  {
    "text": "the first is an addition problem um as you can see here uh a length is received",
    "start": "2920280",
    "end": "2927720"
  },
  {
    "text": "from the network or whatever and um it's probably the program looks like",
    "start": "2927720",
    "end": "2933839"
  },
  {
    "text": "it's implying that it's about to send a string of that length across Network so the program allocates um the length you",
    "start": "2933839",
    "end": "2940440"
  },
  {
    "text": "give plus one for accounting presumably for null bite and then um M copies some",
    "start": "2940440",
    "end": "2946200"
  },
  {
    "text": "user data onto that string um if we give the length here as um like ox F FFF like",
    "start": "2946200",
    "end": "2953760"
  },
  {
    "text": "the largest value then the Plus One will um make it exceed the maximum value and wrap around back to zero so maloc in",
    "start": "2953760",
    "end": "2961000"
  },
  {
    "text": "this scenario will actually allocate zero bytes well depending on the Malo implementation it will allocate some",
    "start": "2961000",
    "end": "2968200"
  },
  {
    "text": "minimum value usually 8 or 16 but basically we can then send a lot more data than um or we can try and M Copy a",
    "start": "2968200",
    "end": "2974839"
  },
  {
    "text": "lot more data than is actually allocated uh we'll do a seconded",
    "start": "2974839",
    "end": "2980480"
  },
  {
    "text": "subtraction um this is integer underflows um this is another similar",
    "start": "2980480",
    "end": "2985799"
  },
  {
    "text": "example to the last one except the program is making assumptions on how much data it just read from the socket",
    "start": "2985799",
    "end": "2992040"
  },
  {
    "text": "which is basically that it read more than header size bites uh with subtraction you also saw in action the",
    "start": "2992040",
    "end": "2998680"
  },
  {
    "text": "um strncat and stuff like that where um lengths are dynamically",
    "start": "2998680",
    "end": "3004359"
  },
  {
    "text": "calculated and it it is the Assumption for example with yeah as I said with sdrn cat that size of buffin is greater",
    "start": "3004359",
    "end": "3012680"
  },
  {
    "text": "than ster and buff um so there's that example and",
    "start": "3012680",
    "end": "3019079"
  },
  {
    "text": "there's multiplication um multiplication error occurs when two",
    "start": "3019079",
    "end": "3025079"
  },
  {
    "text": "or more numbers multiply together a result larger than the highest possible integer these occur reasonably often in",
    "start": "3025079",
    "end": "3031079"
  },
  {
    "text": "programs often when allocating memory in which is an array of a data type whose size is greater than one uh here this",
    "start": "3031079",
    "end": "3038680"
  },
  {
    "text": "example if um num the variable num here is um greater than ox FFF divided by",
    "start": "3038680",
    "end": "3047079"
  },
  {
    "text": "size of the object type plus one then the integer will exceed its maximum limit and go back to zero allocating a",
    "start": "3047079",
    "end": "3053440"
  },
  {
    "text": "very small amount of memory and proceeding to copy in large amounts of data result resing in a buffer",
    "start": "3053440",
    "end": "3058680"
  },
  {
    "text": "overflow uh this is all pretty good but um it's there are some problems when it",
    "start": "3058680",
    "end": "3064200"
  },
  {
    "text": "actually comes to exploiting these that we need to briefly explore because um in a lot of our early work",
    "start": "3064200",
    "end": "3070880"
  },
  {
    "text": "when we were um finding bugs of this nature we found a whole heap of them but a lot of them turn out to be",
    "start": "3070880",
    "end": "3077280"
  },
  {
    "text": "unexploitable um when determining exploitability these bugs we run into problems often these bugs cause enormous",
    "start": "3077280",
    "end": "3084960"
  },
  {
    "text": "data copies that we real we really unable to exploit if we return to thinking about the first hypothetical",
    "start": "3084960",
    "end": "3090760"
  },
  {
    "text": "example you'll recall that an integer could be wrapped by adding one to it the addition example that is um so the M",
    "start": "3090760",
    "end": "3097960"
  },
  {
    "text": "Copy would then but the M Copy would then attempt to copy about four gabt of",
    "start": "3097960",
    "end": "3103200"
  },
  {
    "text": "data which is going to crouch the program once we hit the edge of the segment that our destination buffer resides in um a lot of integer wrapping",
    "start": "3103200",
    "end": "3111880"
  },
  {
    "text": "bugs contain problems just like this one also consider um",
    "start": "3111880",
    "end": "3117839"
  },
  {
    "text": "string up like I've got there um like theoretically a lot of string up type",
    "start": "3117839",
    "end": "3123559"
  },
  {
    "text": "routines basically do the same thing as the addition example where they maloc string length of some string plus",
    "start": "3123559",
    "end": "3130480"
  },
  {
    "text": "one and then copy all the data into it and theoretically if we could make sterin the maximum representable integer",
    "start": "3130480",
    "end": "3137240"
  },
  {
    "text": "then we could overflow it but practically we can't really do this because we can't Supply 4 GB um",
    "start": "3137240",
    "end": "3144599"
  },
  {
    "text": "string uh so we end up up having one of two problems often times which is either the program is attempting to copy very",
    "start": "3144599",
    "end": "3150640"
  },
  {
    "text": "large amounts of data or we need to supply such large amounts of data but it's just not",
    "start": "3150640",
    "end": "3156359"
  },
  {
    "text": "doable um so we've got some solutions uh",
    "start": "3156359",
    "end": "3161839"
  },
  {
    "text": "first is the program catching segmentation violations um sometimes the",
    "start": "3161839",
    "end": "3167160"
  },
  {
    "text": "program catches a sigsegv signal and tries to clean itself up often these",
    "start": "3167160",
    "end": "3172400"
  },
  {
    "text": "bugs can become exploitable if we corrupt variables or function pointers that are made use of when the seg fault",
    "start": "3172400",
    "end": "3177760"
  },
  {
    "text": "Handler is called this is pretty much just what Joey was talking about where um a fault occurs in an application and",
    "start": "3177760",
    "end": "3183760"
  },
  {
    "text": "it tries to clean itself up without and by doing that it's assuming that its Heap or whatever is",
    "start": "3183760",
    "end": "3190680"
  },
  {
    "text": "trustable um the second again um delivery of other",
    "start": "3190680",
    "end": "3196200"
  },
  {
    "text": "court signals sometimes um before a segmentation fold actually happens um we",
    "start": "3196200",
    "end": "3203040"
  },
  {
    "text": "can actually uh trigger other signals uh that might do something that might be",
    "start": "3203040",
    "end": "3208720"
  },
  {
    "text": "interesting to us the user may be able to corrupt some variables and then deliver a signal at the right time which makes use of these variables like maybe",
    "start": "3208720",
    "end": "3216359"
  },
  {
    "text": "calls free on them or something and um some signals you might be able to send a",
    "start": "3216359",
    "end": "3221880"
  },
  {
    "text": "sigge or Sig pipe in a in a network type situation um structured exception",
    "start": "3221880",
    "end": "3227920"
  },
  {
    "text": "handling uh which has been used a lot on Windows 32 type applications um in Wind 32 if the stack",
    "start": "3227920",
    "end": "3235520"
  },
  {
    "text": "gets entirely overwritten in large in large memory copies um an exception is generated and exception handling",
    "start": "3235520",
    "end": "3242760"
  },
  {
    "text": "routines are called to help clean up the process which are later located on the stack and so vulnerabilities of this",
    "start": "3242760",
    "end": "3248599"
  },
  {
    "text": "type on Windows 32 can be often exploited if large data copy is done to the stack um cleanup routines again",
    "start": "3248599",
    "end": "3256720"
  },
  {
    "text": "stuff that Joey was saying sometimes programs contain miscellaneous cleanup routines when the program crashes or",
    "start": "3256720",
    "end": "3263440"
  },
  {
    "text": "exit especially in the case of object oriented languages such to C++ which deallocate objects and call destructors",
    "start": "3263440",
    "end": "3269599"
  },
  {
    "text": "and that kind of thing um so we sometimes can use these",
    "start": "3269599",
    "end": "3275200"
  },
  {
    "text": "to our advantages for um integer wrapping problems but the best conditions for integer wrapping bugs do",
    "start": "3275200",
    "end": "3281920"
  },
  {
    "text": "not actually require any of these um they've got the properties that basically an integer Supply is directly",
    "start": "3281920",
    "end": "3289079"
  },
  {
    "text": "controlled by the user for memory allocation of something similar uh a loop resed for the data copy that can be",
    "start": "3289079",
    "end": "3294920"
  },
  {
    "text": "prematurely terminated and and premature termination of the loop does not call cause an immediate call to exit so that",
    "start": "3294920",
    "end": "3301760"
  },
  {
    "text": "we can exploit some cleanup routine um just a few notes about this",
    "start": "3301760",
    "end": "3307280"
  },
  {
    "text": "integer wrapping stuff uh when we were making this speech we thought that although integer wrapping of some types",
    "start": "3307280",
    "end": "3313160"
  },
  {
    "text": "has been noticed before the Potential Threat that these types of bug represent to the security of software has not",
    "start": "3313160",
    "end": "3318240"
  },
  {
    "text": "really been realized so we decided to show some real world examples and quickly show how large applications can",
    "start": "3318240",
    "end": "3324400"
  },
  {
    "text": "be vulnerable to problems like this uh before we show these examples though",
    "start": "3324400",
    "end": "3329680"
  },
  {
    "text": "we'd like to point out one or one or two more ideas we had about when researching this stuff um firstly when we talk about",
    "start": "3329680",
    "end": "3337160"
  },
  {
    "text": "in firstly we talk about it as integer wrapping but it really should be realized what impact this style of bug",
    "start": "3337160",
    "end": "3342359"
  },
  {
    "text": "has on pointer types as well which are really just integers uh pointer variables that are incremented by large",
    "start": "3342359",
    "end": "3348599"
  },
  {
    "text": "enough amounts could also be made to wrap around to another location in memory maybe behind the buffer to",
    "start": "3348599",
    "end": "3353839"
  },
  {
    "text": "another segment uh although this Al requires large values these values will",
    "start": "3353839",
    "end": "3359680"
  },
  {
    "text": "most likely be considerably smaller than what you need to wrap a standard integer because a pointer may already have a fairly large value like ox B FFF or",
    "start": "3359680",
    "end": "3367200"
  },
  {
    "text": "whatever for a stack pointer or something um Hal will be momentarily",
    "start": "3367200",
    "end": "3372799"
  },
  {
    "text": "demonstrating implications that this kind of stuff has on memory allocation routines um which are apparently",
    "start": "3372799",
    "end": "3380440"
  },
  {
    "text": "extremely buggy um furthermore we should mention that certain functions are susceptible",
    "start": "3380440",
    "end": "3386760"
  },
  {
    "text": "to being misused if not checked carefully uh so like when we were talking about dangerous Library",
    "start": "3386760",
    "end": "3392240"
  },
  {
    "text": "functions before we could add a few like consider the COC function for example which dynamically allocates an array um",
    "start": "3392240",
    "end": "3399480"
  },
  {
    "text": "a multiplication will be done between the two arguments done to it from memory allocation so bug stemming from",
    "start": "3399480",
    "end": "3405720"
  },
  {
    "text": "dangerous use of COK could arise very easily in the same fashion as the hypothetical multiplication example",
    "start": "3405720",
    "end": "3411799"
  },
  {
    "text": "given earlier um I would also like to note that um I didn't really check this out",
    "start": "3411799",
    "end": "3418079"
  },
  {
    "text": "but it appeared to me that the new operator in g++ seems to internally contain the same type of problem if you",
    "start": "3418079",
    "end": "3425480"
  },
  {
    "text": "um do like uh if you allocate an array using the new operator of some data type",
    "start": "3425480",
    "end": "3431280"
  },
  {
    "text": "whose size is greater than one and you and a user can control the um the amount",
    "start": "3431280",
    "end": "3436880"
  },
  {
    "text": "of amount of data elements allocated then you can usually cause g++",
    "start": "3436880",
    "end": "3442280"
  },
  {
    "text": "internally to allocate a very small amount of memory um",
    "start": "3442280",
    "end": "3447599"
  },
  {
    "text": "and and then um start constructing the objects um I'm not sure at this stage",
    "start": "3447599",
    "end": "3453599"
  },
  {
    "text": "whether this would create an exploitable situation it depends on the constructors",
    "start": "3453599",
    "end": "3458680"
  },
  {
    "text": "uh of whatever data type it was that was being allocated uh so we're going to go",
    "start": "3458680",
    "end": "3465000"
  },
  {
    "text": "through a couple of real world examples uh I already said that stuff um briefly",
    "start": "3465000",
    "end": "3470839"
  },
  {
    "text": "open SSH um this is the challenge response bug we",
    "start": "3470839",
    "end": "3476640"
  },
  {
    "text": "published earlier this year this example has been analyzed in bug track in detail now but it's perfect example of what",
    "start": "3476640",
    "end": "3482960"
  },
  {
    "text": "we're talking about uh if you look at the source code of the vulnerable part of SSH it's actually pretty much exactly",
    "start": "3482960",
    "end": "3489160"
  },
  {
    "text": "the same as the multiplication example I showed earlier",
    "start": "3489160",
    "end": "3494359"
  },
  {
    "text": "um basically uh you can trigger an integer multiplication overflow um which",
    "start": "3494359",
    "end": "3501760"
  },
  {
    "text": "causes an incorrect dat allocation on the Heap and we can right past the end of the allocat data with pointers return",
    "start": "3501760",
    "end": "3507480"
  },
  {
    "text": "from packet get string um which is a routine that gets strings from the network",
    "start": "3507480",
    "end": "3514039"
  },
  {
    "text": "uh basically um the conditions that I mentioned before are satisfied we're",
    "start": "3514039",
    "end": "3520599"
  },
  {
    "text": "directly able to control an ingor that is Multiplied past and pass to a memory allocation routine we enter a loop that",
    "start": "3520599",
    "end": "3527400"
  },
  {
    "text": "we can prematurely terminate and although this causes a call to exit uh some cleanup work is is done before exit",
    "start": "3527400",
    "end": "3534720"
  },
  {
    "text": "actually occurs and um it really stresses what Joey was saying earlier about um deallocation",
    "start": "3534720",
    "end": "3542480"
  },
  {
    "text": "routines and stuff actually causing vulnerabilities rather than um making",
    "start": "3542480",
    "end": "3548039"
  },
  {
    "text": "the process safely exit because uh if they didn't clean up in this situation",
    "start": "3548039",
    "end": "3553599"
  },
  {
    "text": "it wouldn't have been exploitable um but because they did it ended up being uh not only exploitable",
    "start": "3553599",
    "end": "3561319"
  },
  {
    "text": "but very trivial to exploit um so what happened was it turned out that um prematurely",
    "start": "3561319",
    "end": "3568440"
  },
  {
    "text": "terminating the loop we could firstly we could override a f fatal cleanup function pointer um with a PO of return from",
    "start": "3568440",
    "end": "3575799"
  },
  {
    "text": "packet get string and um basically in open SSH they had this uh fatal cleanup",
    "start": "3575799",
    "end": "3582240"
  },
  {
    "text": "structures which uh had a function pointer and a pointed to some data that it wanted to clean up and because we can",
    "start": "3582240",
    "end": "3587960"
  },
  {
    "text": "overwrite the function pointer um what happens is",
    "start": "3587960",
    "end": "3594880"
  },
  {
    "text": "uh um um when open SSH the integer overflow actually occurs because it allocates a a table of character",
    "start": "3594880",
    "end": "3602960"
  },
  {
    "text": "pointers um and as we're overwriting them um it runs",
    "start": "3602960",
    "end": "3608760"
  },
  {
    "text": "out of data in the packet so uh there's a premature termination of the loop which calls fatal which calls the",
    "start": "3608760",
    "end": "3614960"
  },
  {
    "text": "function pointer which we overwrite so um when open SSH is trying to clean up",
    "start": "3614960",
    "end": "3620240"
  },
  {
    "text": "its uh clean up its various things it actually jumps directly to the data that",
    "start": "3620240",
    "end": "3626760"
  },
  {
    "text": "we supplied in a string so um we can just put any executable code and um open",
    "start": "3626760",
    "end": "3632240"
  },
  {
    "text": "SSH while trying to clean up just jumps directly to it and spawns us a root shell so",
    "start": "3632240",
    "end": "3638960"
  },
  {
    "text": "um when noticing a bug like this uh it actually as we said before um with the",
    "start": "3638960",
    "end": "3646079"
  },
  {
    "text": "methodologies you have to follow whether everything is um whether we can actually get to that part of the code and it",
    "start": "3646079",
    "end": "3651799"
  },
  {
    "text": "turned out it was really easy to do because um the options were enabled in by default and so forth uh so um but it",
    "start": "3651799",
    "end": "3662680"
  },
  {
    "text": "does stress that you need to check out a program thoroughly because um even though the exploitable code was in every",
    "start": "3662680",
    "end": "3668880"
  },
  {
    "text": "single distribution for this particular type of bug um and enable by default uh",
    "start": "3668880",
    "end": "3674599"
  },
  {
    "text": "there was a function just before it that needed to return not null and if it didn't it wasn't exploitable and it only",
    "start": "3674599",
    "end": "3680440"
  },
  {
    "text": "returned not null if BSD Orth or sky was defined which is why it only affected BSD by default",
    "start": "3680440",
    "end": "3686640"
  },
  {
    "text": "fa um the um so we're going to talk about",
    "start": "3686640",
    "end": "3692200"
  },
  {
    "text": "uh Neil's example now which is the one that came out",
    "start": "3692200",
    "end": "3697039"
  },
  {
    "text": "today okay uh the example here is uh the xdr array um prototype which is used in",
    "start": "3706559",
    "end": "3714200"
  },
  {
    "text": "sunrpc and um this is this has all the perfect elements of a uh a",
    "start": "3714200",
    "end": "3719760"
  },
  {
    "text": "multiplication integer overflow um if you'll see we can directly specify the uh the size or the number of elements in",
    "start": "3719760",
    "end": "3726680"
  },
  {
    "text": "the array being transmitted and um a lot of uh RPC Services allow you to transmit",
    "start": "3726680",
    "end": "3734000"
  },
  {
    "text": "unlimited size arrays so the check for maximum size there is completely bypassed it then multiplies uh the uh",
    "start": "3734000",
    "end": "3742880"
  },
  {
    "text": "this the number of elements in the array by the size of each element and uh that's where we create an integer",
    "start": "3742880",
    "end": "3748599"
  },
  {
    "text": "overflow and then it goes ahead and allocates the extremely small amount of data and um further down you'll see that",
    "start": "3748599",
    "end": "3757200"
  },
  {
    "text": "it goes into a loop a for Loop where it uh tries to read the the number of",
    "start": "3757200",
    "end": "3762400"
  },
  {
    "text": "elements that we specified from the xdr stream and if it runs out of data within",
    "start": "3762400",
    "end": "3767760"
  },
  {
    "text": "that stream it just uh it'll just return a an error condition so um we don't run",
    "start": "3767760",
    "end": "3774520"
  },
  {
    "text": "we don't run into any problems with coping a huge amount of data there um and uh well just going back to some",
    "start": "3774520",
    "end": "3781440"
  },
  {
    "text": "of the stuff I talked about earlier uh if you if you had actually I don't know if you have if you had absolutely",
    "start": "3781440",
    "end": "3787200"
  },
  {
    "text": "nothing better to do if you had checked open BSD CV CVS uh yesterday or the day before this was actually patched in this",
    "start": "3787200",
    "end": "3793440"
  },
  {
    "text": "before the advisory went out so I don't know people track these things and they can spot these things a little early",
    "start": "3793440",
    "end": "3800359"
  },
  {
    "text": "um I don't think I have the exploit code actually maybe I do um yes I do uh I'll",
    "start": "3800359",
    "end": "3808760"
  },
  {
    "text": "just very briefly show you what's going on here the the key",
    "start": "3808760",
    "end": "3814720"
  },
  {
    "text": "part of this exploit is the number of elements that you pass to uh to this",
    "start": "3814720",
    "end": "3819920"
  },
  {
    "text": "routine and um you pass a value which is one quarter of the uh one quarter of the",
    "start": "3819920",
    "end": "3825359"
  },
  {
    "text": "maximum integer plus some some other data um so when it's multiplied it comes",
    "start": "3825359",
    "end": "3830480"
  },
  {
    "text": "out uh the the size of the elements are four so you multiply by four it comes out as a little bit over",
    "start": "3830480",
    "end": "3836559"
  },
  {
    "text": "the maximum integer value it's wrapped to a very small value and we allocate way less data than we",
    "start": "3836559",
    "end": "3842880"
  },
  {
    "text": "should uh I think uh halar is up next with buggy memory allocators",
    "start": "3845640",
    "end": "3852760"
  },
  {
    "text": "can everybody hear me no yeah okay so um let's see whether we",
    "start": "3878680",
    "end": "3885520"
  },
  {
    "text": "get to the screen okay um well round about last",
    "start": "3885520",
    "end": "3893680"
  },
  {
    "text": "year I was uh like last year this time I was speaking with uh Chris about auditing or gathering statistics on",
    "start": "3893680",
    "end": "3900440"
  },
  {
    "text": "which Library call would be the most frequently used one and then trying to find a bug in that Library call and um",
    "start": "3900440",
    "end": "3906520"
  },
  {
    "text": "well it turned out we didn't even have to gather statistics because it seems that Malo is among the most used Library calls in any",
    "start": "3906520",
    "end": "3912839"
  },
  {
    "text": "application and um Moc frequently handles user influence request sizes as we've seen now the problem with Malo is",
    "start": "3912839",
    "end": "3920520"
  },
  {
    "text": "that many many applications or many many large server software implements their own Malo",
    "start": "3920520",
    "end": "3927000"
  },
  {
    "text": "implements the own maloc in order to",
    "start": "3927000",
    "end": "3931599"
  },
  {
    "text": "um in order to okay in order to um what",
    "start": "3934240",
    "end": "3939279"
  },
  {
    "text": "is this probably okay I'll not",
    "start": "3939279",
    "end": "3945920"
  },
  {
    "text": "move anyhow um the the thing with with malok is or with these um many",
    "start": "3945920",
    "end": "3951680"
  },
  {
    "text": "applications Implement their own heat Management in order to speed up everything like their entire heat",
    "start": "3951680",
    "end": "3956720"
  },
  {
    "text": "management for example um it is recommended for optimization purposes if you have a large server software or whatever to generate well statistics on",
    "start": "3956720",
    "end": "3964839"
  },
  {
    "text": "the sizes of of normal memory allocation in your in your application and then optimize your heat management towards",
    "start": "3964839",
    "end": "3971880"
  },
  {
    "text": "like well dealing with those sizes that are most frequently requested and um",
    "start": "3971880",
    "end": "3977160"
  },
  {
    "text": "aside from this many other um applications Implement their own memory allocators and memory allocators have to",
    "start": "3977160",
    "end": "3983880"
  },
  {
    "text": "do arithmetics internally two kinds of arithmetics in fact they have to do arithmetics on pointers and on integers",
    "start": "3983880",
    "end": "3990079"
  },
  {
    "text": "integers being the request size and pointers being the pointers well they have inside their own Heap and um memory",
    "start": "3990079",
    "end": "3996799"
  },
  {
    "text": "allocators are really bad about 60% of them from my experience are broken in terms of Mello returning success for",
    "start": "3996799",
    "end": "4004039"
  },
  {
    "text": "stuff like negative one so you allocate 4 gigabytes and it returns success and in fact allocates like eight bytes uh",
    "start": "4004039",
    "end": "4011640"
  },
  {
    "text": "which is fairly bad so um well if if Malo breaks pretty much well",
    "start": "4011640",
    "end": "4017880"
  },
  {
    "text": "many other things break and a broken Malo can open many many doors um I stumbled across this originally the last",
    "start": "4017880",
    "end": "4023720"
  },
  {
    "text": "year when I was taking apart the bolany um Malo implementation because I wanted to exploit an overrun in the Heap and",
    "start": "4023720",
    "end": "4030839"
  },
  {
    "text": "well if you allocated minus one there it would allocate like eight bytes and succeed so um that's kind of how I",
    "start": "4030839",
    "end": "4037920"
  },
  {
    "text": "stumbled over this um what I would like to do here small b",
    "start": "4037920",
    "end": "4044359"
  },
  {
    "text": "i okay what I'd like to do here is a small",
    "start": "4044359",
    "end": "4050000"
  },
  {
    "text": "bug quiz um in terms of well I've got seven buggy memory allocators from",
    "start": "4050000",
    "end": "4055880"
  },
  {
    "text": "popular open source packages I've anonymized those so that nobody really knows um what application those are in",
    "start": "4055880",
    "end": "4063839"
  },
  {
    "text": "and the audience gets 120 seconds to spot the bug in the memory allocator and whoever does this first will get like he",
    "start": "4063839",
    "end": "4071559"
  },
  {
    "text": "will win the name of the package it is in okay",
    "start": "4071559",
    "end": "4077440"
  },
  {
    "text": "um well can you borrow me your watch um we have a special John McDonald",
    "start": "4079920",
    "end": "4085680"
  },
  {
    "text": "rule only one prize per person and um secondly the attendance of",
    "start": "4085680",
    "end": "4091480"
  },
  {
    "text": "attendees of my training class yesterday may not participate because they might have already seen something of this um",
    "start": "4091480",
    "end": "4097440"
  },
  {
    "text": "in order to win the prize you have to explain what is going wrong and which values will behave strangely and if",
    "start": "4097440",
    "end": "4104040"
  },
  {
    "text": "after 120 second there seconds there's no answer we will explain the bug but we will not tell anybody which package it",
    "start": "4104040",
    "end": "4109480"
  },
  {
    "text": "is in you all right yeah",
    "start": "4109480",
    "end": "4116400"
  },
  {
    "text": "what sorry those guys there can't participate well they can't participate they're in here but only one prize per",
    "start": "4116400",
    "end": "4122880"
  },
  {
    "text": "person so okay the first one is a really easy",
    "start": "4122880",
    "end": "4128158"
  },
  {
    "text": "one raise your hand raise your hand once you're ready",
    "start": "4131719",
    "end": "4137400"
  },
  {
    "text": "time here oh there's a hand",
    "start": "4138120",
    "end": "4144199"
  },
  {
    "text": "okay multiplication you pass in two un logs",
    "start": "4144199",
    "end": "4149480"
  },
  {
    "text": "that are big enough you overflow loop around and you'll end up with something",
    "start": "4149480",
    "end": "4156159"
  },
  {
    "text": "that's less than x m x size whatever that is and um instead you'll uh return",
    "start": "4156159",
    "end": "4166359"
  },
  {
    "text": "interesting number actually un all right well that was",
    "start": "4166359",
    "end": "4171640"
  },
  {
    "text": "correct the the trick here is that we have a multiplication in the check if size times number of items um if you",
    "start": "4171640",
    "end": "4178080"
  },
  {
    "text": "make that wrap around at 32 bits you'll have a fairly small number that will be smaller than Max C size and um then when",
    "start": "4178080",
    "end": "4185400"
  },
  {
    "text": "the well function returns it'll allocate a way smaller number and the application will think it has some huge array of",
    "start": "4185400",
    "end": "4192159"
  },
  {
    "text": "structures or whatever when it doesn't okay you've won name please come to us after the",
    "start": "4192159",
    "end": "4198800"
  },
  {
    "text": "speech wow all right next",
    "start": "4199080",
    "end": "4204560"
  },
  {
    "text": "one",
    "start": "4208320",
    "end": "4211320"
  },
  {
    "text": "this all right there's a hand on hand down",
    "start": "4223760",
    "end": "4228440"
  },
  {
    "text": "there",
    "start": "4231520",
    "end": "4234520"
  },
  {
    "text": "Max all right well that's it um if somebody gives or feeds a value",
    "start": "4240760",
    "end": "4246679"
  },
  {
    "text": "somewhere between um well Max in minus 8 and um max in into this function um",
    "start": "4246679",
    "end": "4254480"
  },
  {
    "text": "they'll allocate well minus one or whatever you passed into Plus 8 so if",
    "start": "4254480",
    "end": "4260000"
  },
  {
    "text": "you pass I don't know minus 8 in there they'll allocate zero and it'll succeed if you pass minus one in there they'll",
    "start": "4260000",
    "end": "4265960"
  },
  {
    "text": "allocate seven and it succeed get another name",
    "start": "4265960",
    "end": "4271080"
  },
  {
    "text": "gone okay next one should be fairly easy now",
    "start": "4271080",
    "end": "4280198"
  },
  {
    "text": "y this be another another simple addition one based off of the user Supply variable size yes this is yet",
    "start": "4295600",
    "end": "4302080"
  },
  {
    "text": "another simple addition based on the user value size okay yet another name gone three",
    "start": "4302080",
    "end": "4308600"
  },
  {
    "text": "out of three not bad this one is a little B Tri",
    "start": "4308600",
    "end": "4317639"
  },
  {
    "text": "here yes sir guess that the Align squ",
    "start": "4340080",
    "end": "4347159"
  },
  {
    "text": "sorry again ending with alignment minus one Whatever alignment",
    "start": "4347800",
    "end": "4354800"
  },
  {
    "text": "is well alignment would be a value like four",
    "start": "4354800",
    "end": "4361960"
  },
  {
    "text": "okay I think the time's over is it two more seconds two more",
    "start": "4365280",
    "end": "4370400"
  },
  {
    "text": "seconds okay oh yeah you can get an overow",
    "start": "4370400",
    "end": "4376639"
  },
  {
    "text": "because is an unsigned okay is very large yes then",
    "start": "4376639",
    "end": "4385280"
  },
  {
    "text": "add W aroundus um why would it turn into a",
    "start": "4385440",
    "end": "4392280"
  },
  {
    "text": "negative member because it's still being assigned like n well try to explain",
    "start": "4392280",
    "end": "4397679"
  },
  {
    "text": "again I'm not sure whether I understand what you're saying is yes",
    "start": "4397679",
    "end": "4403320"
  },
  {
    "text": "Max okay then when you add that it will wrap around the addition will give you a",
    "start": "4403320",
    "end": "4409800"
  },
  {
    "text": "two yes and then and three give you ative number um will it give you a",
    "start": "4409800",
    "end": "4418120"
  },
  {
    "text": "negative number I think it should give you a zero Sor",
    "start": "4418120",
    "end": "4425360"
  },
  {
    "text": "well um actually I think um well this is partly correct you'll still get the name",
    "start": "4425679",
    "end": "4432080"
  },
  {
    "text": "but um what's happening here is that um n is being rounded up to the next even",
    "start": "4432080",
    "end": "4437239"
  },
  {
    "text": "border like for example not even but to the next four bytes so you'll never get a negative value here but if you pass in",
    "start": "4437239",
    "end": "4444480"
  },
  {
    "text": "like minus one they round it up to zero so they round it and then a zero",
    "start": "4444480",
    "end": "4451239"
  },
  {
    "text": "siiz allocation will happen um well I think we'll give you the first half of the",
    "start": "4451239",
    "end": "4457679"
  },
  {
    "text": "name all right more fun",
    "start": "4459239",
    "end": "4465480"
  },
  {
    "text": "Jesus want TR6 this long time yeah",
    "start": "4467880",
    "end": "4473320"
  },
  {
    "text": "s",
    "start": "4512239",
    "end": "4515239"
  },
  {
    "text": "oh yeah right if size is very large then NP is",
    "start": "4530239",
    "end": "4536520"
  },
  {
    "text": "going to wrap um and cause some interesting side",
    "start": "4536520",
    "end": "4542960"
  },
  {
    "text": "effects that point um can you be a bit more detailed on that okay um basically if uh if size",
    "start": "4542960",
    "end": "4553639"
  },
  {
    "text": "is is very large then um then",
    "start": "4553639",
    "end": "4559679"
  },
  {
    "text": "NP is going to actually be less than",
    "start": "4559679",
    "end": "4565480"
  },
  {
    "text": "active first sale and so then um in in your if state",
    "start": "4565480",
    "end": "4574520"
  },
  {
    "text": "will succeed when it shouldn't and um the way we go from",
    "start": "4574520",
    "end": "4580480"
  },
  {
    "text": "there it's hard to say without knowing what a t",
    "start": "4580480",
    "end": "4586320"
  },
  {
    "text": "you look like okay yeah that's good um you will not get in this name or you can",
    "start": "4586320",
    "end": "4592040"
  },
  {
    "text": "choose between the two names because we only have one price per person but um nonetheless good work anyhow um what's",
    "start": "4592040",
    "end": "4599440"
  },
  {
    "text": "happening here is that we have not an integer which is wrapping around this time but a pointer um basically the the",
    "start": "4599440",
    "end": "4605639"
  },
  {
    "text": "end pointer end p is being calculated by adding active first Avail to size now",
    "start": "4605639",
    "end": "4611800"
  },
  {
    "text": "active first Avail is a pointer into the current Heap um I don't know what that is on Linux",
    "start": "4611800",
    "end": "4616840"
  },
  {
    "text": "somewhere at 40 something like 40 blah blah blah um so any allocation larger",
    "start": "4616840",
    "end": "4623719"
  },
  {
    "text": "than um 0 minus 40 will make this end point a wrap um so this will actually will",
    "start": "4623719",
    "end": "4632360"
  },
  {
    "text": "behave incorrectly for a very very large number of values going in there not just like minus 8 - 7 and so on but like for",
    "start": "4632360",
    "end": "4639840"
  },
  {
    "text": "um a few million different values this will not work properly so if you put a to large value in there NP will wrap NP",
    "start": "4639840",
    "end": "4647239"
  },
  {
    "text": "will be smaller than active NP and um it'll just return um the first Avail",
    "start": "4647239",
    "end": "4653920"
  },
  {
    "text": "pointer and um then corrupt the next first Avail pointer which the next",
    "start": "4653920",
    "end": "4659360"
  },
  {
    "text": "allocation will will get so um this is a fairly complex",
    "start": "4659360",
    "end": "4664960"
  },
  {
    "text": "bug do do we have really have six out of six so far okay well last one last one for",
    "start": "4664960",
    "end": "4673040"
  },
  {
    "text": "today and my personal favorite",
    "start": "4673040",
    "end": "4676840"
  },
  {
    "text": "thiss you got itbe the allocation problem but reest it",
    "start": "4702120",
    "end": "4710040"
  },
  {
    "text": "Z okay you sure about",
    "start": "4710040",
    "end": "4714520"
  },
  {
    "text": "that uh I'm not sure about that no because it divides by round size and round size will not be zero so um time",
    "start": "4716400",
    "end": "4724000"
  },
  {
    "text": "scking sorry okay well",
    "start": "4724000",
    "end": "4730280"
  },
  {
    "text": "much cl's upit oh sorry um is it like well the first thing doing",
    "start": "4761679",
    "end": "4769040"
  },
  {
    "text": "dividing by round but mtip so you can still um give a very big",
    "start": "4769040",
    "end": "4777199"
  },
  {
    "text": "number side you would still over on the first Avail right yeah but what will",
    "start": "4777199",
    "end": "4783639"
  },
  {
    "text": "happen afterwards okay so time's up um I'll",
    "start": "4783639",
    "end": "4791120"
  },
  {
    "text": "explain this for a second this is a bit trickier what happens here is the program rounds up the request size to",
    "start": "4791120",
    "end": "4796880"
  },
  {
    "text": "the next even boundary and then it'll check if request size is smaller zero so",
    "start": "4796880",
    "end": "4802199"
  },
  {
    "text": "if you pass in a negative value obviously this will screw up badly um well the the trick here more or",
    "start": "4802199",
    "end": "4810000"
  },
  {
    "text": "less is um let me think oh yeah um trick here is that you will well if you pass",
    "start": "4810000",
    "end": "4817239"
  },
  {
    "text": "in the largest positive value before it passes into the negative one it'll round",
    "start": "4817239",
    "end": "4823239"
  },
  {
    "text": "up and becom a negative number so size will be negative but request size is",
    "start": "4823239",
    "end": "4828679"
  },
  {
    "text": "being checked so request size is positive and size wraps around into the",
    "start": "4828679",
    "end": "4833840"
  },
  {
    "text": "Nega negative and then screws everything down there where um the new block is issued and that must have a negative",
    "start": "4833840",
    "end": "4840560"
  },
  {
    "text": "size so um there's a trickier one and um",
    "start": "4840560",
    "end": "4846280"
  },
  {
    "text": "it's one of my favorite bugs I'll frame it and put it on my wall um are there any questions",
    "start": "4846280",
    "end": "4852520"
  },
  {
    "text": "concerning this entire speech so so",
    "start": "4852520",
    "end": "4856800"
  },
  {
    "text": "far oh yes please you mentioned earlier that the automated auditing tools um",
    "start": "4858800",
    "end": "4865520"
  },
  {
    "text": "aren't very good at all do you see any hope of developing automated tools they",
    "start": "4865520",
    "end": "4870840"
  },
  {
    "text": "can catch typ of complicated vulnerability to talk about here uh no",
    "start": "4870840",
    "end": "4876159"
  },
  {
    "text": "the question was whether I see any hope of developing code that can automatically detect well really complex",
    "start": "4876159",
    "end": "4882560"
  },
  {
    "text": "bugs and um I really don't think that is going to be possible I think there is a",
    "start": "4882560",
    "end": "4888840"
  },
  {
    "text": "lot that you can do with like to find simple bugs and there's like a lot of",
    "start": "4888840",
    "end": "4895520"
  },
  {
    "text": "potential to buy like right good source code analyzers which are about a zillion times better than the the super grab we",
    "start": "4895520",
    "end": "4902760"
  },
  {
    "text": "have currently but for the really complex ones you'll still need a human to look at it and like find The Logical",
    "start": "4902760",
    "end": "4909120"
  },
  {
    "text": "flaw um for example the these things where clients are being trusted or um",
    "start": "4909120",
    "end": "4915000"
  },
  {
    "text": "other weird things happened that nishad was talking about earlier um you can't",
    "start": "4915000",
    "end": "4920199"
  },
  {
    "text": "detect those automatically I think problem is to not just like detecting the complex bugs but also determining",
    "start": "4920199",
    "end": "4926520"
  },
  {
    "text": "whether the code paths can in fact be reached did everyone hear that before no well the problem is not um not just um",
    "start": "4926520",
    "end": "4936080"
  },
  {
    "text": "detecting complex co uh bugs but also whether those conditions can actually be",
    "start": "4936080",
    "end": "4941280"
  },
  {
    "text": "triggered by a user or something like that so um even if they could detect some pretty uh complex uh type bugs it's",
    "start": "4941280",
    "end": "4950760"
  },
  {
    "text": "it becomes really difficult when you're trying to figure out whether a user can actually manipulate values in such a way",
    "start": "4950760",
    "end": "4956440"
  },
  {
    "text": "like setting flags and having certain characters and stuff like that um to actually get to the right place where",
    "start": "4956440",
    "end": "4962800"
  },
  {
    "text": "that code can be executed so that's so that's a big problem as well that only",
    "start": "4962800",
    "end": "4969040"
  },
  {
    "text": "affect don't oops uh right just fix the down Bo I",
    "start": "4969040",
    "end": "4977520"
  },
  {
    "text": "mean if if you've got a buggy code then just fix it don't worry about whether or not it can be reached it's too takes too",
    "start": "4977520",
    "end": "4983679"
  },
  {
    "text": "much time to figure out whether it can be reached you can fix it less time than it takes to figure out so just fix",
    "start": "4983679",
    "end": "4991120"
  },
  {
    "text": "it uh that's up to the software maintainers I",
    "start": "4991120",
    "end": "4997079"
  },
  {
    "text": "think yes with the trusted server uh",
    "start": "4997719",
    "end": "5002840"
  },
  {
    "text": "application expect to",
    "start": "5002840",
    "end": "5007320"
  },
  {
    "text": "see well if they don't use n two homes D short that's the question well the",
    "start": "5009719",
    "end": "5016320"
  },
  {
    "text": "question was if we have uh well if we have a client server environment whether we don't all also see um well indianist",
    "start": "5016320",
    "end": "5023840"
  },
  {
    "text": "problems probably stemming from the the fact that one of the two sides doesn't use net to host short or n to host long",
    "start": "5023840",
    "end": "5031199"
  },
  {
    "text": "um on the one hand I think those are definitely or could definitely be a source of bugs",
    "start": "5031199",
    "end": "5038239"
  },
  {
    "text": "then again um well code that has these kind of bugs wouldn't be functional in the first place so um I don't know how",
    "start": "5038239",
    "end": "5046320"
  },
  {
    "text": "many of these sneak through Q quality assurance but there's amazing stuff coming out of quality assurance so um",
    "start": "5046320",
    "end": "5053000"
  },
  {
    "text": "you never know any other",
    "start": "5053000",
    "end": "5058760"
  },
  {
    "text": "questions yes",
    "start": "5059440",
    "end": "5063440"
  },
  {
    "text": "um well the quiz will not be posted I think but the rest of the the thing",
    "start": "5065600",
    "end": "5071560"
  },
  {
    "text": "will any other questions yes",
    "start": "5071560",
    "end": "5077159"
  },
  {
    "text": "sir um if you want to yeah uh I might not be able to answer them",
    "start": "5080360",
    "end": "5085920"
  },
  {
    "text": "but all right oops",
    "start": "5085920",
    "end": "5092440"
  },
  {
    "text": "um well thanks for for being here and um thanks for everything",
    "start": "5092440",
    "end": "5101239"
  }
]