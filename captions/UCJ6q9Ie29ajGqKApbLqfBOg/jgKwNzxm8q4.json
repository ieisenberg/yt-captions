[
  {
    "text": "I am going to turn this over to Sylvio chz who will be delivering the next talk",
    "start": "199",
    "end": "6000"
  },
  {
    "text": "for you hello thank you uh for attending",
    "start": "6000",
    "end": "11920"
  },
  {
    "text": "this presentation um little story uh I arrived in a Vegas uh yesterday at about",
    "start": "11920",
    "end": "18119"
  },
  {
    "text": "10:00 a.m. 11:00 a.m. uh coming from Australia took about 20 24 hours uh in",
    "start": "18119",
    "end": "23400"
  },
  {
    "text": "flights and traveling time uh unfortunately my luggage didn't arrive with me uh so I had to buy a couple of",
    "start": "23400",
    "end": "29119"
  },
  {
    "text": "shirts last night from uh the Caesar Forum Shops and I'm still wearing my jeans and sneakers if you're wondering",
    "start": "29119",
    "end": "35320"
  },
  {
    "text": "uh from from the flight so excuse me for that but my luggage should arrive uh tonight hopefully so this talk is about",
    "start": "35320",
    "end": "41960"
  },
  {
    "text": "bug eli.com detecting bugs using decompilation and data flow analysis um a little bit about who I am",
    "start": "41960",
    "end": "49520"
  },
  {
    "text": "um and where this talk comes from I'm a PhD student at Deacon University uh my",
    "start": "49520",
    "end": "55000"
  },
  {
    "text": "thesis is currently under examination so hopefully um soon I'll I'll I'll",
    "start": "55000",
    "end": "60120"
  },
  {
    "text": "progress and be Award of that degree um I'm also a book author um the title of my thesis was software similarity and",
    "start": "60120",
    "end": "66880"
  },
  {
    "text": "classification and and I've written a book with the same title of that if you go to my website there's a free preprint",
    "start": "66880",
    "end": "73240"
  },
  {
    "text": "of that book available as well um and this talk covers some of that PhD research um I've also looked at other",
    "start": "73240",
    "end": "79799"
  },
  {
    "text": "things in the past such as malware detection um and there's a lot of overlap between this work as well the",
    "start": "79799",
    "end": "86079"
  },
  {
    "text": "same engine that I used to do malware analysis is used to do the static analysis and decompilation in this",
    "start": "86079",
    "end": "92240"
  },
  {
    "text": "work I'm also a bit of a hobbyist uh this is my Linux and Arduino powered um",
    "start": "92240",
    "end": "97560"
  },
  {
    "text": "home Gardening System the the irrigation system is controlled by um by my by my",
    "start": "97560",
    "end": "102840"
  },
  {
    "text": "Linux box that has a Chron job starting and stopping the irrigation so detecting bugs in binary",
    "start": "102840",
    "end": "110079"
  },
  {
    "text": "is useful uh we know that uh static analysis can have its uses and is",
    "start": "110079",
    "end": "116600"
  },
  {
    "text": "beneficial in in many respects but in in most cases you need access to the source code um but if you look at things like",
    "start": "116600",
    "end": "123479"
  },
  {
    "text": "penetration testing you often don't have that source code available so uh we need",
    "start": "123479",
    "end": "129319"
  },
  {
    "text": "an approach uh to do blackbox testing um so detecting bugs and binaries is useful",
    "start": "129319",
    "end": "134480"
  },
  {
    "text": "in that case uh external auditing and compliance is also another valid reason",
    "start": "134480",
    "end": "139599"
  },
  {
    "text": "for why we should have some Assurance on our software um and Assurance of software can't really be guaranteed um",
    "start": "139599",
    "end": "146040"
  },
  {
    "text": "once we've compiled and linked um a particular program uh we can do source",
    "start": "146040",
    "end": "151160"
  },
  {
    "text": "code analysis but that process of compiling linking um converts that",
    "start": "151160",
    "end": "156200"
  },
  {
    "text": "source code into a binary and to verify that that compilation linkage has performed successfully and not introduce",
    "start": "156200",
    "end": "162040"
  },
  {
    "text": "new errors we need to have an approach uh to detect bugs um in binaries um",
    "start": "162040",
    "end": "168120"
  },
  {
    "text": "finally if we have third party software we might be using um a library or a product from a vendor who doesn't",
    "start": "168120",
    "end": "174959"
  },
  {
    "text": "provide source code having some Assurance of the quality of that software that it doesn't have a really",
    "start": "174959",
    "end": "180159"
  },
  {
    "text": "big bugs in it that can be easily detected by an adversary is something of benefit as",
    "start": "180159",
    "end": "185920"
  },
  {
    "text": "well so the work that I'm doing today and that I'm presenting about today uh",
    "start": "185920",
    "end": "191159"
  },
  {
    "text": "has a number of I suppose Innovations and that's certainly how we describe it in the academic sense",
    "start": "191159",
    "end": "198040"
  },
  {
    "text": "um the the Innovation is really performing static analysis on binaries by using decompilation and then using",
    "start": "198040",
    "end": "204959"
  },
  {
    "text": "data flow analysis on those results um to find bugs uh the novelty is in",
    "start": "204959",
    "end": "210120"
  },
  {
    "text": "combining that decompilation with traditional static analysis techniques so we've got a whole range of of static",
    "start": "210120",
    "end": "215959"
  },
  {
    "text": "analysis techniques that apply to source code and if we introduce decompilation",
    "start": "215959",
    "end": "221040"
  },
  {
    "text": "uh we can we can use those those results that have been done before there are a number of methods um",
    "start": "221040",
    "end": "228159"
  },
  {
    "text": "to analyze programs uh formally uh we have you know the main approaches um",
    "start": "228159",
    "end": "233920"
  },
  {
    "text": "include theor improving so you might have things like defining the semantics of a program using mathematic",
    "start": "233920",
    "end": "240439"
  },
  {
    "text": "representations um and then proving properties based on those sematics uh",
    "start": "240439",
    "end": "245640"
  },
  {
    "text": "typical sematics used for verification include axiomatic semantics and there are also other semantics possible",
    "start": "245640",
    "end": "251480"
  },
  {
    "text": "denotational semantics operational sematics and so forth another approach",
    "start": "251480",
    "end": "257079"
  },
  {
    "text": "uh to formally proving the correctness or verifying programs uh is via abstract interpretation and Abstract",
    "start": "257079",
    "end": "263880"
  },
  {
    "text": "interpretation essentially uh abstracts the running of a program and reduces the",
    "start": "263880",
    "end": "269880"
  },
  {
    "text": "the complexity of looking at concrete execution and certainly according to RIS",
    "start": "269880",
    "end": "274919"
  },
  {
    "text": "theem you can't precisely prove specific properties uh of a program but using",
    "start": "274919",
    "end": "280479"
  },
  {
    "text": "abstract interpretation uh makes that possible through approximation a classic example that is used to describe um how",
    "start": "280479",
    "end": "287800"
  },
  {
    "text": "abstract interpretation um is using the abstract domain of signs um in this particular case you abstract uh the data",
    "start": "287800",
    "end": "296360"
  },
  {
    "text": "of particular variables by representing it using the of the variable so you might have positive negative and zero",
    "start": "296360",
    "end": "303160"
  },
  {
    "text": "and you can prove certain properties of the program such as particular variables are never zero always greater than zero",
    "start": "303160",
    "end": "309199"
  },
  {
    "text": "and so forth another approach uh to formally proving program correctness is model",
    "start": "309199",
    "end": "315240"
  },
  {
    "text": "checking and model checking essentially um represents the states of a program or",
    "start": "315240",
    "end": "321000"
  },
  {
    "text": "uh and you verify that your model of a program corresponds to its specification",
    "start": "321000",
    "end": "328880"
  },
  {
    "text": "so the outline of this talk that I'm going to give today covers a number of things I'll talk about",
    "start": "336280",
    "end": "342639"
  },
  {
    "text": "decompilation then I'll talk about data flow analysis I'll talk about um",
    "start": "342639",
    "end": "348520"
  },
  {
    "text": "optimizations on the Intermediate Language that I use to represent programs using that data flow analysis",
    "start": "348520",
    "end": "354800"
  },
  {
    "text": "and decompilation I'll talk about bug detection I'll talk about the system",
    "start": "354800",
    "end": "360919"
  },
  {
    "text": "that I've implemented bug wise and finally I'll talk about future work and conclude the",
    "start": "360919",
    "end": "367520"
  },
  {
    "text": "presentation but before I get into the actual uh analyses that I'm using I need to sort of cover some of the terminology",
    "start": "369759",
    "end": "376319"
  },
  {
    "text": "of program analysis um and in particular talking about the control flow of a",
    "start": "376319",
    "end": "381440"
  },
  {
    "text": "program for some of you you might already know this this isn't really new work it's just you know looking at some",
    "start": "381440",
    "end": "387680"
  },
  {
    "text": "of the terminology so a control flow graph represents control flow within a",
    "start": "387680",
    "end": "393639"
  },
  {
    "text": "procedure um and control flow describes the possible flow of execution within a program statically a control flow graph",
    "start": "393639",
    "end": "401000"
  },
  {
    "text": "is a directed graph um each node in the control flow graph represents a basic",
    "start": "401000",
    "end": "406639"
  },
  {
    "text": "block and a basic block represents a sequence of instructions without an intervening control flow uh transfer",
    "start": "406639",
    "end": "413880"
  },
  {
    "text": "instruction um an edge between those basic blocks represents that a branch or",
    "start": "413880",
    "end": "419639"
  },
  {
    "text": "control flow may be taken uh via that edge um control flow graphs are",
    "start": "419639",
    "end": "425199"
  },
  {
    "text": "typically used for intraprocedural analysis that is analysis within a",
    "start": "425199",
    "end": "430639"
  },
  {
    "text": "procedure um and there are a number of types of analyses uh that can be",
    "start": "430639",
    "end": "435720"
  },
  {
    "text": "performed intraprocedurally specifically flow sensitive analysis and flow insensitive analysis flow sensitive",
    "start": "435720",
    "end": "443000"
  },
  {
    "text": "analysis takes control flow into account uh so we're taking into account that",
    "start": "443000",
    "end": "448240"
  },
  {
    "text": "specific paths May may or may not be um exist in in that control flow graph um",
    "start": "448240",
    "end": "454080"
  },
  {
    "text": "examples of analyses that don't take control flow into account uh are things like pointer analysis uh we we can",
    "start": "454080",
    "end": "461560"
  },
  {
    "text": "specify a set of U logical formula to to represent",
    "start": "461560",
    "end": "468159"
  },
  {
    "text": "that in contrast to the control flow graph is a is a call graph a call graph",
    "start": "468159",
    "end": "474080"
  },
  {
    "text": "represents the control flow uh between procedures um again a call graph or a",
    "start": "474080",
    "end": "480319"
  },
  {
    "text": "pro function call graph is the directed graph each node in the graph represents a procedure and each Edge in that call",
    "start": "480319",
    "end": "487199"
  },
  {
    "text": "graph represents that the source of the edge uh that procedure may call the",
    "start": "487199",
    "end": "493080"
  },
  {
    "text": "destination uh of that edge so inter call graphs represent",
    "start": "493080",
    "end": "498599"
  },
  {
    "text": "interprocedural analysis uh and looks and they look at the uh the analysis between procedures",
    "start": "498599",
    "end": "505800"
  },
  {
    "text": "uh in inter proed interprocedural analysis you have context sensitive and context insensitive analyses a context",
    "start": "505800",
    "end": "513719"
  },
  {
    "text": "sensitive analysis takes into account uh the call uh the the call stack uh uh of",
    "start": "513719",
    "end": "521919"
  },
  {
    "text": "the of of each function um specifically uh at each particular function you can",
    "start": "521919",
    "end": "527120"
  },
  {
    "text": "have a certain uh set of uh call Stacks that may exist a context insensitive",
    "start": "527120",
    "end": "534120"
  },
  {
    "text": "analysis doesn't take that into account and it it's not as precise as a context sensitive analysis",
    "start": "534120",
    "end": "541360"
  },
  {
    "text": "so that's sort of the terminology that I'm going to discuss now on to the sort of the meat of the of the presentation",
    "start": "541360",
    "end": "548880"
  },
  {
    "text": "or at least the first part of it which is about decompilation so decompilation",
    "start": "548880",
    "end": "555279"
  },
  {
    "text": "essentially recover Source level information from a binary um I don't",
    "start": "555279",
    "end": "561000"
  },
  {
    "text": "actually use the textual source code representation of a binary to do uh my",
    "start": "561000",
    "end": "567240"
  },
  {
    "text": "bug detection um but I do use some high level information um that is obtained",
    "start": "567240",
    "end": "572839"
  },
  {
    "text": "through decompilation so the basic approach that this work takes that bug wise takes is to represent x86 Assembly",
    "start": "572839",
    "end": "579839"
  },
  {
    "text": "Language with an Intermediate Language an Intermediate Language makes the analyses easier and I'll talk about that",
    "start": "579839",
    "end": "586360"
  },
  {
    "text": "in in some later slides um I infer stack pointers um and from that I can",
    "start": "586360",
    "end": "593360"
  },
  {
    "text": "decompile uh local variables that are based on the stack and also procedure arguments which are based on on the sack",
    "start": "593360",
    "end": "600200"
  },
  {
    "text": "and that is effectively the part of decompilation that I'm using recovering local variables and procedure",
    "start": "600200",
    "end": "608560"
  },
  {
    "text": "arguments so the Intermediate Language that I use uh is called wire and it's a formal Intermediate Language uh for",
    "start": "608959",
    "end": "615519"
  },
  {
    "text": "binary analysis uh why do we have uh an Intermediate Language why don't we perform analyses directly on x86 uh well",
    "start": "615519",
    "end": "623600"
  },
  {
    "text": "x86 is complex and big uh as a cisk uh instruction set it has hundreds of",
    "start": "623600",
    "end": "630519"
  },
  {
    "text": "possible instructions with many addressing modes um it's useful to have",
    "start": "630519",
    "end": "635760"
  },
  {
    "text": "an Intermediate Language uh that is more concise that is more risk based um because you have to implement uh less",
    "start": "635760",
    "end": "642639"
  },
  {
    "text": "handlers for each instruction that you're working with uh so wire is a low-level risk style Assembly Language",
    "start": "642639",
    "end": "649720"
  },
  {
    "text": "very simple addressing modes it's register based uh the memory model um includes uh virtual memory of a 32-bit",
    "start": "649720",
    "end": "657639"
  },
  {
    "text": "address space uh and this is the result of translating x86 to this language uh",
    "start": "657639",
    "end": "664240"
  },
  {
    "text": "it's very similar to to halar flakes rail language um like rail I transform",
    "start": "664240",
    "end": "670399"
  },
  {
    "text": "one x86 instruction to one or more uh",
    "start": "670399",
    "end": "675639"
  },
  {
    "text": "instructions in The Wire language uh wire also has formally defined",
    "start": "675639",
    "end": "680720"
  },
  {
    "text": "operational semantics I talked a little bit earlier of some of the approaches of proving program correctness using formal",
    "start": "680720",
    "end": "688040"
  },
  {
    "text": "methods operational sematics describe effectively uh how a particular",
    "start": "688040",
    "end": "693440"
  },
  {
    "text": "instruction uh transforms the state of the machine uh one of the things that we can",
    "start": "693440",
    "end": "700440"
  },
  {
    "text": "do with the formally defined language and formally defined operational sematics is prove particular program",
    "start": "700440",
    "end": "706880"
  },
  {
    "text": "properties uh about about those things uh so on the left I've got uh uh some uh",
    "start": "706880",
    "end": "714760"
  },
  {
    "text": "some code uh and on the right I've got some code also equivalent to that but that has been OB",
    "start": "714760",
    "end": "722000"
  },
  {
    "text": "fiscated using dead code insertion so using operational sematics we can formally prove that the unobfuscated",
    "start": "722000",
    "end": "728720"
  },
  {
    "text": "sequence of instructions is equivalent to our obfuscated",
    "start": "728720",
    "end": "734800"
  },
  {
    "text": "version but you know the formal verification about proving equivalence between OB fiscated and non-op fiscated",
    "start": "736920",
    "end": "743560"
  },
  {
    "text": "um programs and instructions is not really the focus of this work this work is all about detecting bugs in binaries",
    "start": "743560",
    "end": "750600"
  },
  {
    "text": "um and to do that like I said you need to perform decompilation and recover local variables and arguments uh the",
    "start": "750600",
    "end": "758040"
  },
  {
    "text": "first part of that process is recovering uh stack pointer information within each",
    "start": "758040",
    "end": "764480"
  },
  {
    "text": "procedure uh this approach has been proposed earlier in the hex-rays decompiler and that's what hex-rays",
    "start": "764480",
    "end": "770839"
  },
  {
    "text": "users and idpro as well actually um uses to look at stack based variables uh the",
    "start": "770839",
    "end": "778760"
  },
  {
    "text": "basic presumption is that within a within a procedure at the start and end",
    "start": "778760",
    "end": "784360"
  },
  {
    "text": "of each basic block the stack pointer relative to the beginning of the procedure is constant it's not always",
    "start": "784360",
    "end": "790440"
  },
  {
    "text": "true but when you transform a high level language and compile it into assembly code this is pretty much the case in",
    "start": "790440",
    "end": "797920"
  },
  {
    "text": "most times so we do we determine what this stack pointer is relative to the",
    "start": "797920",
    "end": "803560"
  },
  {
    "text": "beginning of the the procedure um by representing it using linear",
    "start": "803560",
    "end": "809240"
  },
  {
    "text": "inequalities so we know for example that the stack pointer at the beginning of the procedure is zero the stack pointer",
    "start": "809240",
    "end": "816399"
  },
  {
    "text": "at the exit point of the procedure is zero and we also know that particular uh",
    "start": "816399",
    "end": "822079"
  },
  {
    "text": "types of instructions modify the stack um calls modify the sack pushes and Pops",
    "start": "822079",
    "end": "827320"
  },
  {
    "text": "modify the sack and we can represent these mathematically and we solve this using uh a standard offthe shelf uh",
    "start": "827320",
    "end": "834600"
  },
  {
    "text": "solve it for linear inequalities um specifically uses as Simplex algorithm to solve",
    "start": "834600",
    "end": "842360"
  },
  {
    "text": "this so once we've determined what the stack pointer is uh throughout each",
    "start": "842360",
    "end": "849680"
  },
  {
    "text": "procedure we can then go on to the next stage which is recovering local variables and procedure arguments so it",
    "start": "849680",
    "end": "857279"
  },
  {
    "text": "is based on that stack pointer inference um and the way that we use this is that when you reference a local variable or a",
    "start": "857279",
    "end": "864199"
  },
  {
    "text": "stack based variable you typically reference it relative to the stack pointer",
    "start": "864199",
    "end": "869240"
  },
  {
    "text": "the frame pointer and if we know what that stack pointer and frame pointer is at particular point in the program we",
    "start": "869240",
    "end": "875519"
  },
  {
    "text": "have these static offsets um into our stack space that represent local",
    "start": "875519",
    "end": "881279"
  },
  {
    "text": "variables and procedure arguments so on the left I've shown uh the Y",
    "start": "881279",
    "end": "886399"
  },
  {
    "text": "Intermediate Language representation of some code and on the right I've performed that local variable recovery",
    "start": "886399",
    "end": "893199"
  },
  {
    "text": "and it simplified it by quite a significant degree and in fact in fact that code on the left simplifies to a",
    "start": "893199",
    "end": "899560"
  },
  {
    "text": "free of a local variable and that's important because you know later on",
    "start": "899560",
    "end": "904880"
  },
  {
    "text": "we'll be looking at things like double frees and use after phrase and representing uh these stack based",
    "start": "904880",
    "end": "911160"
  },
  {
    "text": "variables using native registers and Native variables in the Intermediate Language makes this problem",
    "start": "911160",
    "end": "918279"
  },
  {
    "text": "solvable so again Pro procedure parameter and argument recovery is very similar uh to the local variable",
    "start": "918759",
    "end": "925320"
  },
  {
    "text": "recovery it's based on stack pointer inference again we know whether it's a local variable or an argument based on",
    "start": "925320",
    "end": "932000"
  },
  {
    "text": "its position relative to the stack pointer or the frame pointer um now there are different call conventions",
    "start": "932000",
    "end": "938040"
  },
  {
    "text": "that can be used and that stack poter inference takes into account that different call conventions can be used",
    "start": "938040",
    "end": "943279"
  },
  {
    "text": "such as call it cleans up or call E cleans up um but sometimes when we have",
    "start": "943279",
    "end": "948920"
  },
  {
    "text": "in particular call conventions a register might be used as an argument we can detect that a register is an",
    "start": "948920",
    "end": "954880"
  },
  {
    "text": "argument by looking at its liveness in that procedure um so a live variable is a variable that",
    "start": "954880",
    "end": "962279"
  },
  {
    "text": "will subsequently be read before it is redefined um so any register that is",
    "start": "962279",
    "end": "968680"
  },
  {
    "text": "going to be used at the beginning of a procedure before it's defined or redefined is a procedure argument it",
    "start": "968680",
    "end": "975319"
  },
  {
    "text": "could also indicate that it's an uninitialized variable um but in this case we'll we'll look at it as a",
    "start": "975319",
    "end": "981839"
  },
  {
    "text": "procedure argument okay so that's that's the",
    "start": "981839",
    "end": "986959"
  },
  {
    "text": "decompilation uh that this work uses users uh the next component of the system is data flow analysis so taking",
    "start": "986959",
    "end": "993759"
  },
  {
    "text": "that that Intermediate Language those recovered variables that are now native registers in that language and",
    "start": "993759",
    "end": "1000440"
  },
  {
    "text": "Performing data flow analysis to determine specific types of bugs and problems that can",
    "start": "1000440",
    "end": "1007880"
  },
  {
    "text": "exist so data flow analysis or DFA reasons about data U data flow analysis",
    "start": "1008680",
    "end": "1016000"
  },
  {
    "text": "uh should be conservative uh when we say when we say it's conservative means that",
    "start": "1016000",
    "end": "1022399"
  },
  {
    "text": "the data should be over approximated but never under approximated so you may have",
    "start": "1022399",
    "end": "1027400"
  },
  {
    "text": "false positives uh but you shouldn't have uh false negatives um data flow analysis is what",
    "start": "1027400",
    "end": "1035280"
  },
  {
    "text": "optimizing compilers use so data flow analysis is performed to determine",
    "start": "1035280",
    "end": "1040798"
  },
  {
    "text": "specific properties of the data within the program and when certain properties are true certain optimizations can be",
    "start": "1040799",
    "end": "1047798"
  },
  {
    "text": "applied the types of uh data flow analysis that a compiler uses include things like",
    "start": "1047799",
    "end": "1054360"
  },
  {
    "text": "reaching definitions upwards exposed uses live variables reaching copies and",
    "start": "1054360",
    "end": "1059880"
  },
  {
    "text": "so forth there's there's quite a large number of data flow analyses that are possible um and the work that that bug",
    "start": "1059880",
    "end": "1067520"
  },
  {
    "text": "wise uses the this the analysis that bug wise uses um use defa type data flow",
    "start": "1067520",
    "end": "1073720"
  },
  {
    "text": "problem so reaching definitions upwards Expos upwards exposed uses and Al variables I'll talk a little bit about",
    "start": "1073720",
    "end": "1079919"
  },
  {
    "text": "that uh shortly uh but that's the type of data flow analysis that I'm talking about uh when when I'm giving this",
    "start": "1079919",
    "end": "1088520"
  },
  {
    "text": "presentation so we we have this you know this General concept of we need to represent the the data in a program U",
    "start": "1088520",
    "end": "1095919"
  },
  {
    "text": "but how do we you know precisely model that problem uh what we can do is we can",
    "start": "1095919",
    "end": "1101760"
  },
  {
    "text": "represent data entering and leaving a basic block and that's that's what we're",
    "start": "1101760",
    "end": "1108039"
  },
  {
    "text": "looking at when we represent uh this data flow problem so we can set up a",
    "start": "1108039",
    "end": "1113200"
  },
  {
    "text": "number of equations that mathematically represent the flow of data uh within a procedure and we'll model what the what",
    "start": "1113200",
    "end": "1120400"
  },
  {
    "text": "each basic block has for data so we have data entering or leaving a basic block",
    "start": "1120400",
    "end": "1125919"
  },
  {
    "text": "and we have a transfer function that takes the data entering that basic block modifies it in some way according to the",
    "start": "1125919",
    "end": "1132240"
  },
  {
    "text": "instructions in the in the basic block um and that gives us the data leaving the basic block we also have to look at",
    "start": "1132240",
    "end": "1139400"
  },
  {
    "text": "a control flow because there are different paths in a program and depending on what path you're taking the",
    "start": "1139400",
    "end": "1146280"
  },
  {
    "text": "data can be modified accordingly so we have a concept of a join operator that combines the",
    "start": "1146280",
    "end": "1151799"
  },
  {
    "text": "predecessors of a basic block in a control flow graph or a flow graph in general depending on the types of",
    "start": "1151799",
    "end": "1157520"
  },
  {
    "text": "analysis that we're doing whether it's a forward analysis or a backward analysis you have the concept of joining the",
    "start": "1157520",
    "end": "1163440"
  },
  {
    "text": "predecessors of a basic block um or joining the successors of a basic block",
    "start": "1163440",
    "end": "1170720"
  },
  {
    "text": "so the first example that I'm going to give as a data flow problem uh is a",
    "start": "1171080",
    "end": "1176360"
  },
  {
    "text": "reaching definition now a reaching definition is a definition of a variable",
    "start": "1176360",
    "end": "1181559"
  },
  {
    "text": "that reaches a program Point without being redefined so if we look at our",
    "start": "1181559",
    "end": "1187120"
  },
  {
    "text": "control flow graph or our flow graph that I've shown the bottom node has print x what are the definitions that",
    "start": "1187120",
    "end": "1193880"
  },
  {
    "text": "reach that point so we have at the top um y = and xal 1 they both reach that",
    "start": "1193880",
    "end": "1202159"
  },
  {
    "text": "point but we have that xal 2 um can also",
    "start": "1202159",
    "end": "1207720"
  },
  {
    "text": "reach that point because there are two paths uh where X is modified uh which reach that final node",
    "start": "1207720",
    "end": "1215280"
  },
  {
    "text": "so we include all of those definitions uh in our reaching definition",
    "start": "1215280",
    "end": "1221080"
  },
  {
    "text": "analysis okay so that's that's a reaching definition and we've got sort of a a model of how we represent data",
    "start": "1223240",
    "end": "1229840"
  },
  {
    "text": "flow problems um but how do we you know what's a simpler way of representing data flow problems so the types of",
    "start": "1229840",
    "end": "1235799"
  },
  {
    "text": "analyses that we find useful and this is the type of framework that most compilers use um generally there's",
    "start": "1235799",
    "end": "1243159"
  },
  {
    "text": "forwards and backwards analysis depending on whether we start at the beginning of a procedure and work our",
    "start": "1243159",
    "end": "1248720"
  },
  {
    "text": "way to the end nodes or we start at the end noes and work our way back upwards so we have a forwards and backwards",
    "start": "1248720",
    "end": "1255000"
  },
  {
    "text": "analysis um we have initialization of our data entering a basic block out in",
    "start": "1255000",
    "end": "1261280"
  },
  {
    "text": "our data leaving the basic block out and we also have a concept of gen and kill sets for each basic block and we can use",
    "start": "1261280",
    "end": "1268000"
  },
  {
    "text": "those in our transfer function which describes how the data is modified by a",
    "start": "1268000",
    "end": "1273039"
  },
  {
    "text": "basic block uh so that's that's our definition of our transfer function and this is",
    "start": "1273039",
    "end": "1278559"
  },
  {
    "text": "very commonly used to solve problems like reaching definitions live variables uh and so forth our join operator that I",
    "start": "1278559",
    "end": "1286400"
  },
  {
    "text": "talked about earlier in that representation um in this particular framework uh can be either a union or an",
    "start": "1286400",
    "end": "1292640"
  },
  {
    "text": "intersection of sets so looking at our reaching",
    "start": "1292640",
    "end": "1298720"
  },
  {
    "text": "definitions problem you know we have you know we we know what the the basic you",
    "start": "1298720",
    "end": "1303840"
  },
  {
    "text": "know idea of a reaching definition it's a definition that can potentially reach a particular node or point in the",
    "start": "1303840",
    "end": "1310200"
  },
  {
    "text": "program and we can represent this using our framework that I just described in the last slide so we have our gen set",
    "start": "1310200",
    "end": "1316799"
  },
  {
    "text": "which is the definitions that appear in that basic block and reach the end of the basic block we have our kill set",
    "start": "1316799",
    "end": "1322760"
  },
  {
    "text": "which is all definitions that never reach the end of the basic block we can initialize um the data leaving the basic",
    "start": "1322760",
    "end": "1329080"
  },
  {
    "text": "block and we have a join operator based on Union and because it's a forward analysis we look at the union of the",
    "start": "1329080",
    "end": "1335120"
  },
  {
    "text": "predecessors of that basic block another type of data flow problem",
    "start": "1335120",
    "end": "1341880"
  },
  {
    "text": "which is really the opposite of reaching definitions is upward exposed uses and this tells us the uses of a definition",
    "start": "1341880",
    "end": "1348679"
  },
  {
    "text": "so at a particular program point we might want to know um when that data",
    "start": "1348679",
    "end": "1354120"
  },
  {
    "text": "will be used and we have our gen and kill sets defined accordingly um initialization again we have um our",
    "start": "1354120",
    "end": "1361600"
  },
  {
    "text": "Confluence operator or our join operator um is Union and because it's a backward analysis we look at the successors of",
    "start": "1361600",
    "end": "1368120"
  },
  {
    "text": "the basic block and not the predecessors there are many more data",
    "start": "1368120",
    "end": "1373760"
  },
  {
    "text": "flow problems probably the last one that of real note uh is live variables and a",
    "start": "1373760",
    "end": "1379480"
  },
  {
    "text": "variable is live if it will subsequently be read without being redefined and that's used in things like dead code",
    "start": "1379480",
    "end": "1385240"
  },
  {
    "text": "elimination we also have reach and copies which tell us the reach of a copy statement or an assignment of of a",
    "start": "1385240",
    "end": "1392120"
  },
  {
    "text": "particular variable but as I said there are more data flow problems out there there's available Expressions very busy",
    "start": "1392120",
    "end": "1398440"
  },
  {
    "text": "expressions and optimizing compilers use an entire range uh of data flow analyses",
    "start": "1398440",
    "end": "1403760"
  },
  {
    "text": "and problems to to perform their optimizations so we we represent our our",
    "start": "1403760",
    "end": "1410919"
  },
  {
    "text": "data flow problem using this framework of gen and kill sets but how do we actually solve you know this data flow",
    "start": "1410919",
    "end": "1417480"
  },
  {
    "text": "problem we can initialize it we have a you know way of joining control flow with predecessors and successors we have",
    "start": "1417480",
    "end": "1424039"
  },
  {
    "text": "transfer functions how do we come up with the final result of data entering and leaving each basic block well",
    "start": "1424039",
    "end": "1431159"
  },
  {
    "text": "there's an iterative solution um to this we initialize our our sets of data we apply",
    "start": "1431159",
    "end": "1439039"
  },
  {
    "text": "the transfer function we apply the join function and we iterate over all these nodes in our control flow graph and we",
    "start": "1439039",
    "end": "1445840"
  },
  {
    "text": "continue we just repeat that until our solution stabilizes that is until it reaches a fixed point and that's",
    "start": "1445840",
    "end": "1453159"
  },
  {
    "text": "effectively why they call these things monotone Frameworks and monotone analysis because our data um will always",
    "start": "1453159",
    "end": "1461200"
  },
  {
    "text": "increase or always decrease until it stabilizes and reaches a fixed point and we have to have certain properties in",
    "start": "1461200",
    "end": "1466679"
  },
  {
    "text": "our data flow representation to ensure that it is a monotone fra a monotone um",
    "start": "1466679",
    "end": "1472919"
  },
  {
    "text": "data flow problem um but effectively for all the data flow problems that that we're going to look at um we can all we",
    "start": "1472919",
    "end": "1479159"
  },
  {
    "text": "can guarantee that they do reach a fixed point so that's the iterative solution",
    "start": "1479159",
    "end": "1485200"
  },
  {
    "text": "to solving data flow problems there are other ways of of representing data flow problems though and solving data flow",
    "start": "1485200",
    "end": "1491520"
  },
  {
    "text": "problems probably the biggest uh different approach uh is by using logic",
    "start": "1491520",
    "end": "1498000"
  },
  {
    "text": "um data log is a very popular uh language and framework uh to solve these",
    "start": "1498000",
    "end": "1505279"
  },
  {
    "text": "types of logic problems and it's a syntactic subset of prologue so we represent our reaching definitions uh",
    "start": "1505279",
    "end": "1512240"
  },
  {
    "text": "problem as I've shown here uh using data log statements and logical formula uh we",
    "start": "1512240",
    "end": "1517840"
  },
  {
    "text": "can represent these and then we can solve these with a data log solver typically uh representing problems with",
    "start": "1517840",
    "end": "1524440"
  },
  {
    "text": "logic um is simpler than representing them with that that Jen and kill with",
    "start": "1524440",
    "end": "1529840"
  },
  {
    "text": "that monotone framework that I that I talked about",
    "start": "1529840",
    "end": "1534039"
  },
  {
    "text": "earlier so I've talked all about the intraprocedural way of of solving data",
    "start": "1534880",
    "end": "1540240"
  },
  {
    "text": "flow problems uh but you know it would be really useful if we could solve data flow problems inter procedurally as well",
    "start": "1540240",
    "end": "1547399"
  },
  {
    "text": "and we can do this using our framework um by joining our control flow graphs",
    "start": "1547399",
    "end": "1554480"
  },
  {
    "text": "for each procedure into what's known as an interprocedural control flow graph and this effectively takes each control",
    "start": "1554480",
    "end": "1560919"
  },
  {
    "text": "flow graph and joins them into one super graph we replace calls in each control",
    "start": "1560919",
    "end": "1567520"
  },
  {
    "text": "flow graph with a branch to the control flow graph that it's calling we replace",
    "start": "1567520",
    "end": "1573279"
  },
  {
    "text": "returns uh from functions with branches back to the call site and then once we",
    "start": "1573279",
    "end": "1578480"
  },
  {
    "text": "have this super graph we can apply our monotone analysis that I that I just",
    "start": "1578480",
    "end": "1584520"
  },
  {
    "text": "explained so that's that's the data flow analysis that's the theory part of of working with data flow",
    "start": "1584600",
    "end": "1591000"
  },
  {
    "text": "problems and using compiler style data flow analysis um as the basis for bug",
    "start": "1591000",
    "end": "1596440"
  },
  {
    "text": "detection the final sort of you know precursor to looking at bug detection uh",
    "start": "1596440",
    "end": "1602240"
  },
  {
    "text": "is looking at the optimizations that are performed on the why Intermediate Language um using the data flow problems",
    "start": "1602240",
    "end": "1609159"
  },
  {
    "text": "that I've just described so as I said the optimizations",
    "start": "1609159",
    "end": "1614799"
  },
  {
    "text": "are required to perform other types of analyses so the decomil the stack pointer inference requires optimization",
    "start": "1614799",
    "end": "1621120"
  },
  {
    "text": "on the Intermediate Language for the for the process to work correctly and also the bug detection requires the",
    "start": "1621120",
    "end": "1627159"
  },
  {
    "text": "optimization process the optimization reduces the size of the Intermediate Language code um and the optimizations",
    "start": "1627159",
    "end": "1634880"
  },
  {
    "text": "are based on data flow analysis so the optimizations that I'm using in bug wise",
    "start": "1634880",
    "end": "1640200"
  },
  {
    "text": "include constant folding and propagation copy propagation backwards copy propagation dead Co dead code",
    "start": "1640200",
    "end": "1646919"
  },
  {
    "text": "elimination and there are other typ of optimizations that are out there but these are the primary ones that I use in",
    "start": "1646919",
    "end": "1652919"
  },
  {
    "text": "bug wise so the first optimalization to look",
    "start": "1652919",
    "end": "1659080"
  },
  {
    "text": "at is constant folding and the motivation for this is to replace instructions such as x = 5 + 5 into x =",
    "start": "1659080",
    "end": "1667080"
  },
  {
    "text": "10 it's pretty intuitive that that 5 + 5 can be folded or combined into a single",
    "start": "1667080",
    "end": "1672480"
  },
  {
    "text": "constant and the way that we do this is for each oper for each arithmetic op operator if the reaching definition of",
    "start": "1672480",
    "end": "1679480"
  },
  {
    "text": "each operand is a single constant assignment then we can fold the constants in the",
    "start": "1679480",
    "end": "1685440"
  },
  {
    "text": "instruction constant propagation um has a motivation of reducing the number of",
    "start": "1685440",
    "end": "1691000"
  },
  {
    "text": "assignments in a program so on our left we have xal 34 and that",
    "start": "1691000",
    "end": "1696720"
  },
  {
    "text": "that value of x can be propagated into the next instruction giving us Ral 34 +",
    "start": "1696720",
    "end": "1703080"
  },
  {
    "text": "y so to solve this to perform this optimization if all the reaching def",
    "start": "1703080",
    "end": "1708120"
  },
  {
    "text": "definitions of a variable have the same assignment and it is constant the constant can be propagated to the",
    "start": "1708120",
    "end": "1715440"
  },
  {
    "text": "variable copy propagation uh reduces the number of copies in a program uh so on",
    "start": "1715440",
    "end": "1722480"
  },
  {
    "text": "our left we have yal X and that can be propagated uh into a later",
    "start": "1722480",
    "end": "1728480"
  },
  {
    "text": "instruction uh we can solve this uh in a couple of ways the probably the easiest",
    "start": "1728480",
    "end": "1734320"
  },
  {
    "text": "way to describe this is by looking at reaching copies a data flow problem that I mentioned briefly earlier uh a",
    "start": "1734320",
    "end": "1740960"
  },
  {
    "text": "reaching copy tells us the reach of a copy statement uh and at each use of X where x equals y if it's a reaching copy",
    "start": "1740960",
    "end": "1747840"
  },
  {
    "text": "replace x with Y and that's effectively how we use data flow um to perform these",
    "start": "1747840",
    "end": "1753279"
  },
  {
    "text": "types of optimizations we know specific properties of the data are true and we can look at them and we know when we can",
    "start": "1753279",
    "end": "1759480"
  },
  {
    "text": "apply these optimizations uh backwards copy propagation is is similar to copy",
    "start": "1759480",
    "end": "1765320"
  },
  {
    "text": "propagation in motivation is to reduce the number of copies um in bug wise both",
    "start": "1765320",
    "end": "1770760"
  },
  {
    "text": "forwards and backwards copy propagation are required for the for the system to work",
    "start": "1770760",
    "end": "1776480"
  },
  {
    "text": "effectively dead code elimination or dead store elimination is probably the optimization that most people have heard",
    "start": "1776480",
    "end": "1782960"
  },
  {
    "text": "of and the motivation of this is to reduce the number of instructions uh in a program um to perform dead code",
    "start": "1782960",
    "end": "1790480"
  },
  {
    "text": "elimination you need to know about the liveness of a variable um and remember that a variable is live if it will be",
    "start": "1790480",
    "end": "1796919"
  },
  {
    "text": "read or used used before it is redefined or defined absolutely so for any definition of a",
    "start": "1796919",
    "end": "1804000"
  },
  {
    "text": "variable if the variable is not live then eliminate the instruction so on our",
    "start": "1804000",
    "end": "1809519"
  },
  {
    "text": "left we have x = 34 and it's that xal 34 is never going to be read again because in the next instruction X is redefined",
    "start": "1809519",
    "end": "1816799"
  },
  {
    "text": "to be the value of 10 so we know that xal 34 x is not live so we can eliminate",
    "start": "1816799",
    "end": "1821840"
  },
  {
    "text": "that instruction so that's that's pretty much",
    "start": "1821840",
    "end": "1826880"
  },
  {
    "text": "all the all the necessary groundwork uh to perform bug",
    "start": "1826880",
    "end": "1832519"
  },
  {
    "text": "detection so the overview the process of detecting bugs in binaries we decompile",
    "start": "1832840",
    "end": "1838799"
  },
  {
    "text": "the program transforming local variables into native Intermediate Language variables or registers we use data flow",
    "start": "1838799",
    "end": "1845360"
  },
  {
    "text": "analysis to reason about those variables in our Intermediate Language when those variables are used and defined and then",
    "start": "1845360",
    "end": "1852519"
  },
  {
    "text": "we can detect particular types of bugs so the types of bugs that I'm detecting you know not really that impressive but",
    "start": "1852519",
    "end": "1859360"
  },
  {
    "text": "for this work they reasonably adequate so we're going to look at an old school bug here um buffer overflows caused by",
    "start": "1859360",
    "end": "1868840"
  },
  {
    "text": "um passing the results of get end to a string copy or or something equivalent",
    "start": "1868840",
    "end": "1874039"
  },
  {
    "text": "we're going to look at use after freeze and double Phee so this doesn't detect all possible cases of these bugs um but",
    "start": "1874039",
    "end": "1880600"
  },
  {
    "text": "it detects specific um cases with specific properties through",
    "start": "1880600",
    "end": "1887559"
  },
  {
    "text": "so the get end bug we're going to look at um is detecting unsafe applications of get end so classic example is a",
    "start": "1888120",
    "end": "1895960"
  },
  {
    "text": "string copy the results of get which gets an environment variable from Linux copies it directly to the buffer without",
    "start": "1895960",
    "end": "1903440"
  },
  {
    "text": "any bound checking um sometimes you can have uh bounds checking uh and have this",
    "start": "1903440",
    "end": "1910840"
  },
  {
    "text": "code present at the same time but in most cases if your pass get ends directly to a string it typically",
    "start": "1910840",
    "end": "1916159"
  },
  {
    "text": "indicates that it's bug uh so the way that we detect that this bug exists that",
    "start": "1916159",
    "end": "1922159"
  },
  {
    "text": "each time get n occurs in our program if the return value of that function is Li",
    "start": "1922159",
    "end": "1928960"
  },
  {
    "text": "that is uh the results of that buff that the results of that environment variable return from get end are going to be",
    "start": "1928960",
    "end": "1935600"
  },
  {
    "text": "used and that result is the reaching definition to the second argument of a",
    "start": "1935600",
    "end": "1940880"
  },
  {
    "text": "string copy or a strink and catenation then we make a warning a very simple approach using data flow analysis",
    "start": "1940880",
    "end": "1948760"
  },
  {
    "text": "that he's able to find bugs and this is a very old school bug so 2001",
    "start": "1948760",
    "end": "1955760"
  },
  {
    "text": "hello to detect use after free bugs uh for each time a free of a pointer occurs if",
    "start": "1956799",
    "end": "1965159"
  },
  {
    "text": "that pointer is live if that pointer will be used before it is redefined then",
    "start": "1965159",
    "end": "1970200"
  },
  {
    "text": "we warn on",
    "start": "1970200",
    "end": "1972880"
  },
  {
    "text": "that for a double frame for each time a free of a pointer",
    "start": "1975919",
    "end": "1981000"
  },
  {
    "text": "occurs if an upward exposed use of pointer that is where the variable is",
    "start": "1981000",
    "end": "1986679"
  },
  {
    "text": "used is free pointer then we Warn and by the way 2001 wants its bugs",
    "start": "1986679",
    "end": "1994919"
  },
  {
    "text": "back so that's that's the bug detection approach using data flow analysis that I'm using the next part of the talk uh",
    "start": "1994919",
    "end": "2001919"
  },
  {
    "text": "looks at the results obtained in the system implemented so this is based on some",
    "start": "2001919",
    "end": "2008840"
  },
  {
    "text": "previous work that I've that I've been working on for quite a while now a number of years um I did my Masters on a",
    "start": "2008840",
    "end": "2014960"
  },
  {
    "text": "malware detection system and also during my PhD I've worked on that as well um",
    "start": "2014960",
    "end": "2020880"
  },
  {
    "text": "it's quite a lot of code about 100,000 lines of code it's a framework for static analysis Spiner analysis and so",
    "start": "2020880",
    "end": "2026880"
  },
  {
    "text": "forth um and Bug wise this particular work uh is built as a set of loadable modules to that Mal wire system",
    "start": "2026880",
    "end": "2033639"
  },
  {
    "text": "everything in this talk um and more is implemented so there isn't any anything that I talked about that hasn't been",
    "start": "2033639",
    "end": "2039480"
  },
  {
    "text": "implemented in this system so for that get n uh bug that I",
    "start": "2039480",
    "end": "2046679"
  },
  {
    "text": "was talking about I scanned the entire Debian 7 unstable repository Debian 7 is stable now uh but when I performed uh",
    "start": "2046679",
    "end": "2055638"
  },
  {
    "text": "this work uh Debbie and S was still unstable um there were about 123,000",
    "start": "2055639",
    "end": "2061000"
  },
  {
    "text": "Earth binaries about 30 of 30,000 of them couldn't be scanned for various",
    "start": "2061000",
    "end": "2066398"
  },
  {
    "text": "reasons um uh primarily not supporting particular uh file formats and shared",
    "start": "2066399",
    "end": "2071520"
  },
  {
    "text": "libraries and whatnot uh the system reported 85 bugs across 47 packages uh",
    "start": "2071520",
    "end": "2078358"
  },
  {
    "text": "and those are those are the packages that have been reported as having um",
    "start": "2078359",
    "end": "2083480"
  },
  {
    "text": "buffer overflows as a result of unbounded uh get end copying um not all",
    "start": "2083480",
    "end": "2089800"
  },
  {
    "text": "of these are strictly bugs uh some of them have been have been false positives",
    "start": "2089800",
    "end": "2095599"
  },
  {
    "text": "uh when you have bounds checking um in conjunction uh with a reasonably",
    "start": "2095599",
    "end": "2101000"
  },
  {
    "text": "unsafe or you know not a very good use of of string copying get ends",
    "start": "2101000",
    "end": "2107760"
  },
  {
    "text": "together um some interesting",
    "start": "2107760",
    "end": "2112200"
  },
  {
    "text": "data um I'd say about 80% are true not all of them not all of them um",
    "start": "2113960",
    "end": "2122480"
  },
  {
    "text": "are are true true positives um and and I haven't orted all of these to Debian as",
    "start": "2122480",
    "end": "2129160"
  },
  {
    "text": "well still a work in",
    "start": "2129160",
    "end": "2132559"
  },
  {
    "text": "progress but generally I think you know even though that not all of them are are true positives uh I I think the use of",
    "start": "2135280",
    "end": "2144160"
  },
  {
    "text": "that code snippet is generally sort of ill advised I don't think it's a great idea uh you know to use that that type",
    "start": "2144160",
    "end": "2151520"
  },
  {
    "text": "of model of of of working with get EnV um some interesting data",
    "start": "2151520",
    "end": "2159240"
  },
  {
    "text": "um uh looking at the Earth binary sizes and how they how they exist in the",
    "start": "2159240",
    "end": "2164599"
  },
  {
    "text": "Debian repository it's pretty much linear growth with logar logarithmic scaling plus there are some",
    "start": "2164599",
    "end": "2172200"
  },
  {
    "text": "outliers now this is sort of interesting to know because when we look at the scalability of of scanning for binaries",
    "start": "2172200",
    "end": "2178760"
  },
  {
    "text": "um if we have linear uh scaling of our our binary analysis framework we can",
    "start": "2178760",
    "end": "2185160"
  },
  {
    "text": "make some estimations on on how much how well we can scale across the entire repository of software that we're",
    "start": "2185160",
    "end": "2191119"
  },
  {
    "text": "looking at um I looked at the get end bugs over time sorted by binary size now what",
    "start": "2191119",
    "end": "2198000"
  },
  {
    "text": "we're looking at here is wondering do we have more bugs um if",
    "start": "2198000",
    "end": "2204839"
  },
  {
    "text": "we have bigger binaries uh and you know if we if that is the case then we should expect a",
    "start": "2204839",
    "end": "2211000"
  },
  {
    "text": "nonlinear growth um over time looking at new packages um and in fact it's it's",
    "start": "2211000",
    "end": "2216800"
  },
  {
    "text": "sort of a cross between a linear growth um or a power growth it's it's there's a very slight difference between linear",
    "start": "2216800",
    "end": "2223200"
  },
  {
    "text": "and power growth so what what we can say um is that there's not a real significant increase uh in the number of",
    "start": "2223200",
    "end": "2230599"
  },
  {
    "text": "bugs as packages get bigger some statistics about those get",
    "start": "2230599",
    "end": "2237400"
  },
  {
    "text": "end bugs uh the probability of a",
    "start": "2237400",
    "end": "2241640"
  },
  {
    "text": "binary number of an absolute or number of per uh so looking at the presence of a you",
    "start": "2243920",
    "end": "2250960"
  },
  {
    "text": "know does any bug exist um given a larger binary size so uh the general",
    "start": "2250960",
    "end": "2258400"
  },
  {
    "text": "like thing that I'm looking at do we have more bugs um in software as it gets bigger but I think with get end",
    "start": "2258400",
    "end": "2264560"
  },
  {
    "text": "developers either make that bug or they don't make that bug so as the biner gets bigger you if they know that this bug",
    "start": "2264560",
    "end": "2269839"
  },
  {
    "text": "class exists then they're not likely you know they either they either do or they",
    "start": "2269839",
    "end": "2276160"
  },
  {
    "text": "don't so so the probability of one particular binary in Debian being vulnerable is quite low",
    "start": "2276240",
    "end": "2284400"
  },
  {
    "text": "0.0067 um the probability of a package being vulnerable is a bit higher because",
    "start": "2284400",
    "end": "2289440"
  },
  {
    "text": "each package consists of a number of binaries now the probability of a package having a second vulnerability",
    "start": "2289440",
    "end": "2296800"
  },
  {
    "text": "given that one binary in the package is vulnerable is quite high so we know that if a developer um implements uh",
    "start": "2296800",
    "end": "2305760"
  },
  {
    "text": "software uh with this particular type of bug they're more likely to write more software with the same bug it seems",
    "start": "2305760",
    "end": "2312800"
  },
  {
    "text": "pretty obvious but it's nice to to represent this with some some statistics as",
    "start": "2312800",
    "end": "2318480"
  },
  {
    "text": "well uh this is a double free uh found uh in a set group ID game program in",
    "start": "2318480",
    "end": "2324400"
  },
  {
    "text": "Debian 6 and it has been fixed um after I reported it but it shows that it is able to find um bugs in real software",
    "start": "2324400",
    "end": "2331640"
  },
  {
    "text": "and this was done when I was scanning uh all the set user ID and set group ID programs in deb6 at the time",
    "start": "2331640",
    "end": "2338960"
  },
  {
    "text": "so we can see that free full name um has a has a path to a double free um if a",
    "start": "2338960",
    "end": "2345560"
  },
  {
    "text": "file open fails which is quite unlikely in this case um which is why it hasn't really triggered any crashes in the",
    "start": "2345560",
    "end": "2352560"
  },
  {
    "text": "past uh bugal eyes.com is a web service uh and a website where you can submit",
    "start": "2352560",
    "end": "2359800"
  },
  {
    "text": "samples and Linux executables and get fairly close fairly fast uh scan times",
    "start": "2359800",
    "end": "2366319"
  },
  {
    "text": "uh and results shown in web browser so these are some of the types of reports that it generates uh on the top uh",
    "start": "2366319",
    "end": "2374079"
  },
  {
    "text": "diagram is a double free that's been detected and it tells you the EIP or the program counter of each particular uh",
    "start": "2374079",
    "end": "2380240"
  },
  {
    "text": "free that causes the problem on the bottom is a buffer overflow caused by that get end uh problem and these are",
    "start": "2380240",
    "end": "2388839"
  },
  {
    "text": "real binaries um um in Debian that that it's worked on um to support this web service um",
    "start": "2388839",
    "end": "2397440"
  },
  {
    "text": "I've built a some infrastructure using Amazon um the scanning of of each binary is",
    "start": "2397440",
    "end": "2404599"
  },
  {
    "text": "actually performed on a cluster of Amazon servers there's about three servers running at the moment um and",
    "start": "2404599",
    "end": "2412920"
  },
  {
    "text": "jobs are distributed to each scan server via a web load balancer there's also a lot of other supporting infrastructure",
    "start": "2412920",
    "end": "2419960"
  },
  {
    "text": "on Amazon such as DNS reporting logs and so forth uh this also shares uh uh work",
    "start": "2419960",
    "end": "2428000"
  },
  {
    "text": "with my other services including Simer which is a malware similarity service and clone wise which is a uh uh a",
    "start": "2428000",
    "end": "2435480"
  },
  {
    "text": "software uh tool to detect embedded copies of of well-used",
    "start": "2435480",
    "end": "2441640"
  },
  {
    "text": "libraries so that's pretty much pretty much all the all the things that I'm going to talk about today um I've",
    "start": "2441640",
    "end": "2449520"
  },
  {
    "text": "described how to decompile programs how to perform data flow analysis uh how to",
    "start": "2449520",
    "end": "2455000"
  },
  {
    "text": "use uh compiler Style optim ations on intermediate code to get simpler representations and how to represent uh",
    "start": "2455000",
    "end": "2462839"
  },
  {
    "text": "bug classes using data flow analysis and talk and finally talking about uh A",
    "start": "2462839",
    "end": "2468240"
  },
  {
    "text": "system that implements what I've talked about today and that has found bugs in binaries in the future I'd like to",
    "start": "2468240",
    "end": "2475480"
  },
  {
    "text": "improve the core of the engine a little bit I'd like to look more at interprocedural optimization um which will be able to",
    "start": "2475480",
    "end": "2483119"
  },
  {
    "text": "detect the larger number of bugs um when we have um used after free double frees",
    "start": "2483119",
    "end": "2488319"
  },
  {
    "text": "occurring um that require interprocedural analysis because they consume more than one one procedure I'd",
    "start": "2488319",
    "end": "2495040"
  },
  {
    "text": "also like to look at pointer analystics which would improve the Precision uh of the system and I'd like to improve the",
    "start": "2495040",
    "end": "2501040"
  },
  {
    "text": "decompiler the decompiler is okay but it's not it's not perfect at this point and there's still a a number of cases",
    "start": "2501040",
    "end": "2507920"
  },
  {
    "text": "where it doesn't perform as effective as it should um I'd like to improve the bug",
    "start": "2507920",
    "end": "2513079"
  },
  {
    "text": "detection uh components of the system looking at things like uninitialized variables unchecked return values and",
    "start": "2513079",
    "end": "2520119"
  },
  {
    "text": "I'd finally like to look at more evaluation performing more evaluations and get more results um I haven't",
    "start": "2520119",
    "end": "2526000"
  },
  {
    "text": "presented any you know really big bugs um but it's a it's it's a framework that can detect bugs and has found bugs in",
    "start": "2526000",
    "end": "2532720"
  },
  {
    "text": "sort of the low hanging fruit category of software and certainly as um as a",
    "start": "2532720",
    "end": "2537760"
  },
  {
    "text": "quality assurance tool it's met its goal of of finding bugs across an entire repository of",
    "start": "2537760",
    "end": "2544400"
  },
  {
    "text": "software so in conclusion i' you know traditional static analysis can find bugs um and decompilation um Bridges the",
    "start": "2544400",
    "end": "2552960"
  },
  {
    "text": "binary Gap um we can apply all those traditional static analysis techniques well not all of them but a large",
    "start": "2552960",
    "end": "2559000"
  },
  {
    "text": "proportion of them um by decompiling our software first um bug wise works on real",
    "start": "2559000",
    "end": "2564400"
  },
  {
    "text": "Linux binaries um and it's available to use it's free to use um you just have to go to my",
    "start": "2564400",
    "end": "2570160"
  },
  {
    "text": "website so thank you very much are there any questions would it",
    "start": "2570160",
    "end": "2577050"
  },
  {
    "text": "[Music] so the the system actually works pretty",
    "start": "2577050",
    "end": "2584440"
  },
  {
    "text": "effectively on on Windows it has a a p32 passer um the x86 is is is passed pretty",
    "start": "2584440",
    "end": "2591520"
  },
  {
    "text": "well I think the only reason I chose Linux in in this work is that I was more",
    "start": "2591520",
    "end": "2596839"
  },
  {
    "text": "familiar with the you know the simple types of bugs that I was looking at um certainly I think it can be applied to",
    "start": "2596839",
    "end": "2602400"
  },
  {
    "text": "to Windows and the back end does support it although you know publicly it's not",
    "start": "2602400",
    "end": "2607520"
  },
  {
    "text": "you you you have to submit elf binaries but certainly the the Intermediate Language and the the object F passing",
    "start": "2607520",
    "end": "2613559"
  },
  {
    "text": "the decompilation all works on Windows binaries as well but then again you have C++ which",
    "start": "2613559",
    "end": "2620240"
  },
  {
    "text": "increases the complexity as well [Music]",
    "start": "2620240",
    "end": "2631059"
  },
  {
    "text": "so the question was sorry for not repeating the questions earlier the question was um uh this system acts like",
    "start": "2631160",
    "end": "2637640"
  },
  {
    "text": "a bit of a black box how can I customize that system and put functions that I want to look at um it is true it is a",
    "start": "2637640",
    "end": "2644880"
  },
  {
    "text": "black box at the moment um and I'm not quite sure if I'm going to to open it up",
    "start": "2644880",
    "end": "2650040"
  },
  {
    "text": "more um certainly it's it's something that I may consider like uh making it",
    "start": "2650040",
    "end": "2655520"
  },
  {
    "text": "more customizable putting functions to look at representing data flow analysis and um specific you know ways of",
    "start": "2655520",
    "end": "2663280"
  },
  {
    "text": "customizing that but at this point in time I don't have plans for that so you know it's not great for for everyone but",
    "start": "2663280",
    "end": "2668720"
  },
  {
    "text": "as a free service I think it's quite reasonable",
    "start": "2668720",
    "end": "2674800"
  },
  {
    "text": "[Music] question so the question was why have I",
    "start": "2679670",
    "end": "2685359"
  },
  {
    "text": "used my own uh intermediate representation why haven't I used something like llvm um you know and use",
    "start": "2685359",
    "end": "2692200"
  },
  {
    "text": "something like clang or something to do static analysis I think I developed wire number of years ago um also there's rail",
    "start": "2692200",
    "end": "2699400"
  },
  {
    "text": "which is probably the most close the closest thing to it I developed wire a number of years ago um before there was",
    "start": "2699400",
    "end": "2705240"
  },
  {
    "text": "sort of a you know plethora of of IRS and ILS available to use one of the main",
    "start": "2705240",
    "end": "2711119"
  },
  {
    "text": "advantages that my Intermediate Language has and what I design it for was it's it's pretty fast to do the translation",
    "start": "2711119",
    "end": "2716480"
  },
  {
    "text": "so when I when I look at malware classification I can do pretty much close to realtime um uh analysis and and that is",
    "start": "2716480",
    "end": "2725760"
  },
  {
    "text": "you know that is based on having pretty fast translation so that you know that that is the you know the main advantage",
    "start": "2725760",
    "end": "2731960"
  },
  {
    "text": "of it um if I did it all again I probably would go to a more established intermediate representation and immed",
    "start": "2731960",
    "end": "2738400"
  },
  {
    "text": "Intermediate Language um certainly llvm is something that would you know open up",
    "start": "2738400",
    "end": "2743640"
  },
  {
    "text": "you know more possibilities um there are also other advantages of using my own intermedia representation some of the",
    "start": "2743640",
    "end": "2750000"
  },
  {
    "text": "decompilation primitiv are represented um in that Intermediate Language um",
    "start": "2750000",
    "end": "2755040"
  },
  {
    "text": "which makes the analysis a bit easier for the specific problems that I'm looking at but you know maybe a bridge",
    "start": "2755040",
    "end": "2760160"
  },
  {
    "text": "to that is by having um a transformation from my intermediate representation to",
    "start": "2760160",
    "end": "2765559"
  },
  {
    "text": "llvm and then using sort of existing uh code based on llvm around that does that",
    "start": "2765559",
    "end": "2771680"
  },
  {
    "text": "reasonbly answer your [Music]",
    "start": "2771680",
    "end": "2775969"
  },
  {
    "text": "question B and Bap and Vine weren't available Bap and Vine weren't available at the time time that I developed this",
    "start": "2782000",
    "end": "2788000"
  },
  {
    "text": "so I think [Music]",
    "start": "2788000",
    "end": "2792780"
  },
  {
    "text": "Vine Vine wide Vine I think was released maybe a couple years ago as part of the bit Blaze framework and Bap has been a",
    "start": "2794119",
    "end": "2801559"
  },
  {
    "text": "you know more recent release after that when when I developed the the original system I think bit Blaze was certainly",
    "start": "2801559",
    "end": "2807280"
  },
  {
    "text": "was entirely closed um and there was certainly no public um implementation of that system at the",
    "start": "2807280",
    "end": "2813880"
  },
  {
    "text": "time and Vine is you know effectively um as far as know an extension of Vex which is comes from the valren",
    "start": "2813880",
    "end": "2821280"
  },
  {
    "text": "IR um but Vex at at that time didn't really uh suit my needs um but it's you",
    "start": "2821280",
    "end": "2829200"
  },
  {
    "text": "know I you know in you know if I did it all again maybe B is is is the way to go now um but certainly at the time that I",
    "start": "2829200",
    "end": "2835880"
  },
  {
    "text": "developed the system bu wasn't public which is the pre predecessor to",
    "start": "2835880",
    "end": "2841440"
  },
  {
    "text": "back here how much did you how much did you have to tweak the decompiler for GCC",
    "start": "2841800",
    "end": "2848040"
  },
  {
    "text": "because you're looking at Linux binaries and how much would you have to or have you tweaked it for other compilers like",
    "start": "2848040",
    "end": "2854640"
  },
  {
    "text": "CL um I think that's a reasonable question I mean the analysis uh a fairly you know",
    "start": "2854640",
    "end": "2863559"
  },
  {
    "text": "robust the the decompiler is um is is fairly reasonable um I can't say I've",
    "start": "2863559",
    "end": "2870240"
  },
  {
    "text": "got an enormous amount of of firsthand commentary about that but certainly the analysis are defined so that that if you",
    "start": "2870240",
    "end": "2877400"
  },
  {
    "text": "use the common call convention then it should be able to to get um something out of it so you know and there's only",
    "start": "2877400",
    "end": "2883400"
  },
  {
    "text": "sort of you know a reasonable amount of you know finite sort of call convention that you use you know stack or call",
    "start": "2883400",
    "end": "2888760"
  },
  {
    "text": "cleans up caller cleans up register base and so forth so a combination of those should be able to be anal analyzed by",
    "start": "2888760",
    "end": "2895440"
  },
  {
    "text": "this system you know reasonably [Music]",
    "start": "2895440",
    "end": "2901400"
  },
  {
    "text": "effectively how come you use Clauses for data flow analyzes sorry say that again",
    "start": "2901400",
    "end": "2908640"
  },
  {
    "text": "um how come you use horn Clauses or or data log for data flow analyzers is it",
    "start": "2908640",
    "end": "2914480"
  },
  {
    "text": "more efficient or was it easier to formulate the query so so the data the data log uh data flow form that I",
    "start": "2914480",
    "end": "2921359"
  },
  {
    "text": "represented was basically um uh like a standard standard definition of a data",
    "start": "2921359",
    "end": "2926640"
  },
  {
    "text": "flow analysis I've I used um uh a few different types of data log solvers uh",
    "start": "2926640",
    "end": "2932599"
  },
  {
    "text": "to do it and and unfortunately like because um I had particular ways of",
    "start": "2932599",
    "end": "2937720"
  },
  {
    "text": "representing and I was I was limited to the type of data log solvers that I could use which sort of made it you know",
    "start": "2937720",
    "end": "2943400"
  },
  {
    "text": "not not the best thing um I didn't really follow the path of of looking at data log uh using it ex I originally had",
    "start": "2943400",
    "end": "2951400"
  },
  {
    "text": "the idea that I wanted to use data log exclusively CU I thought the data log solution was much better than you know",
    "start": "2951400",
    "end": "2956680"
  },
  {
    "text": "the sort of the you know this sort of complex you know data flow problem represented as bit vectors um but I",
    "start": "2956680",
    "end": "2962400"
  },
  {
    "text": "implemented I implemented that and I actually you know got worse times with my data log solver approach to data flow",
    "start": "2962400",
    "end": "2968960"
  },
  {
    "text": "analysis than I got with the bit Vector approach um so I sort of stopped looking at that I think if I did it you know if",
    "start": "2968960",
    "end": "2975559"
  },
  {
    "text": "I if I continue a bit more I think I'd like to look at the data log um approach",
    "start": "2975559",
    "end": "2980720"
  },
  {
    "text": "more because I think it's it's a really nice representation of data log problems and you know it seems that you know it",
    "start": "2980720",
    "end": "2987040"
  },
  {
    "text": "has you know has a lot of potential but in my implementation I wasn't able to get it fast enough and it was quite",
    "start": "2987040",
    "end": "2992760"
  },
  {
    "text": "significantly slow as well but I think you know probably the reason for that slowdown was that uh the transformation",
    "start": "2992760",
    "end": "2999839"
  },
  {
    "text": "from my my intermediate represent representation um to the data log um you",
    "start": "2999839",
    "end": "3005480"
  },
  {
    "text": "know representation is is where the slow down occurs as opposed to the data log solver",
    "start": "3005480",
    "end": "3010960"
  },
  {
    "text": "itself okay",
    "start": "3010960",
    "end": "3014200"
  },
  {
    "text": "thanks your engine against C++ programs because with all the interaction and",
    "start": "3017440",
    "end": "3023920"
  },
  {
    "text": "whatever whatever it gets much more complex like yes um the question yeah the question was have I looked at C++",
    "start": "3023920",
    "end": "3030720"
  },
  {
    "text": "programs with my engine um uh not much to be honest I wouldn't say that it",
    "start": "3030720",
    "end": "3036160"
  },
  {
    "text": "would uh be very good at C++ um so C is really the Target that",
    "start": "3036160",
    "end": "3041680"
  },
  {
    "text": "I'm looking at at the moment um you can certainly pass it bin you know C++ binaries but I wouldn't say that the",
    "start": "3041680",
    "end": "3047960"
  },
  {
    "text": "results will be great",
    "start": "3047960",
    "end": "3051680"
  },
  {
    "text": "apologies if you cover this and I just didn't catch it what are you doing when you hit a system call in terms of",
    "start": "3062920",
    "end": "3068240"
  },
  {
    "text": "modeling the stack pointer and whether data has been accessed or modified or not that's that's a very good question actually what am I doing with uh with",
    "start": "3068240",
    "end": "3075000"
  },
  {
    "text": "system calls uh in respect to to modifying the stack pointer um it's",
    "start": "3075000",
    "end": "3080680"
  },
  {
    "text": "currently what what would be happening right now is a bad approxim approximation of that system call um",
    "start": "3080680",
    "end": "3087079"
  },
  {
    "text": "um so yeah I you know I ideally you know",
    "start": "3087079",
    "end": "3092160"
  },
  {
    "text": "if if libc is being used or GBC um then you have a reasonable representation but if you start inter dispersing system",
    "start": "3092160",
    "end": "3098720"
  },
  {
    "text": "calls um then you'll probably get a bad approximation and you'll you you have false positives or false negatives",
    "start": "3098720",
    "end": "3107880"
  },
  {
    "text": "so so when you were running this on a server did you ever hit out of memory conditions when your graphs got too big",
    "start": "3120799",
    "end": "3127640"
  },
  {
    "text": "yeah that's that's probably like the one of the biggest problems with the uh with the system it does tend to use up a lot",
    "start": "3127640",
    "end": "3133160"
  },
  {
    "text": "of memory my my my representations that I'm using I I originally design it with it's probably better to have a little",
    "start": "3133160",
    "end": "3138680"
  },
  {
    "text": "more in the representation than a little less so there are there are limits to to to the to what you can scan um you know",
    "start": "3138680",
    "end": "3146280"
  },
  {
    "text": "as as the graphs get bigger it does get a bit more annoying and certainly representing the the data in in the",
    "start": "3146280",
    "end": "3152079"
  },
  {
    "text": "control flow graphs consumes quite a large amount of memory so there are limitations to to how much memory you can get at the upper end of the that",
    "start": "3152079",
    "end": "3159520"
  },
  {
    "text": "that graph where I showed Earth binary sizes there there were quite a few times that ran out of",
    "start": "3159520",
    "end": "3165720"
  },
  {
    "text": "memory uh it's a good question I think um uh there the question was uh am",
    "start": "3169440",
    "end": "3176559"
  },
  {
    "text": "running out of memory size of the binary or the number of functions in in the binar you know what's the relationship between size you know versus out of",
    "start": "3176559",
    "end": "3183559"
  },
  {
    "text": "memory I think as you get more procedures um and also as the graphs get bigger you start to to consume more",
    "start": "3183559",
    "end": "3190799"
  },
  {
    "text": "resources uh so if you have really big graphs big control flow graphs then then it does consume a bit more memory than",
    "start": "3190799",
    "end": "3196319"
  },
  {
    "text": "if you have a few smaller graphs um but yeah I think you know ultimately um you",
    "start": "3196319",
    "end": "3202720"
  },
  {
    "text": "know the only solution I've got at the moment is is is throwing more memory in in the server to do it so it's is not a",
    "start": "3202720",
    "end": "3208119"
  },
  {
    "text": "great solution but unfortunate it's in relation to my original concept of it's",
    "start": "3208119",
    "end": "3213280"
  },
  {
    "text": "probably better to represent more in the intermediate representation than",
    "start": "3213280",
    "end": "3218599"
  },
  {
    "text": "less thank you very much",
    "start": "3227559",
    "end": "3232040"
  },
  {
    "text": "[Applause]",
    "start": "3233760",
    "end": "3236219"
  }
]