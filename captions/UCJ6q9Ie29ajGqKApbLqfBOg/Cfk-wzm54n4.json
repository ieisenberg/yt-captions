[
  {
    "text": "uh today we're going to be presenting our talk Alice in kernerland Lessons",
    "start": "2340",
    "end": "7379"
  },
  {
    "text": "Learned From the evpf rabbit hole with my colleagues Simon and JJ my name is",
    "start": "7379",
    "end": "13440"
  },
  {
    "text": "Valentina I'm a vulnerability vulnerability researcher at IBM X-Force red and I'll let",
    "start": "13440",
    "end": "21119"
  },
  {
    "text": "uh thank you I'm Simon I'm A Cloud vulnerability researcher at Google I'm at Valentino in 2020 while we were",
    "start": "21119",
    "end": "27599"
  },
  {
    "text": "simultaneously doing research on evpf and that's how we met and hi my name is JJ I work as a",
    "start": "27599",
    "end": "35219"
  },
  {
    "text": "security research at Google as well when I transfer to my new team at Google doing screen research I was looking for",
    "start": "35219",
    "end": "40680"
  },
  {
    "text": "new products to do and I came across an article by Simon on evpf I started project on that and then later I found",
    "start": "40680",
    "end": "46200"
  },
  {
    "text": "out Simon was joining my team now here we are okay",
    "start": "46200",
    "end": "51960"
  },
  {
    "text": "um so we're going to begin with a short introduction to ebpf and what it is ebpf is a Linux kernel subsystem that",
    "start": "51960",
    "end": "59640"
  },
  {
    "text": "was built as a refactor of classic BPF which is Berkeley packet filtering",
    "start": "59640",
    "end": "65659"
  },
  {
    "text": "which was originally created to filter packets in the kernel now modern ebpf",
    "start": "65659",
    "end": "71280"
  },
  {
    "text": "serves as a technology that allows user mode applications to run code in the kernel without needing to load current a",
    "start": "71280",
    "end": "78299"
  },
  {
    "text": "kernel module evpf programs can be used to do all types of things such as tracing",
    "start": "78299",
    "end": "84780"
  },
  {
    "text": "instrumentation hooking system calls debugging capturing or filtering packets",
    "start": "84780",
    "end": "90119"
  },
  {
    "text": "of course and even in recent times we've seen it used to build root kits",
    "start": "90119",
    "end": "96240"
  },
  {
    "text": "um so what are the advantages of using ebpf for one developers don't need to",
    "start": "96240",
    "end": "101579"
  },
  {
    "text": "know how to develop kernel code which is a huge Advantage it's also easier than",
    "start": "101579",
    "end": "106799"
  },
  {
    "text": "compiling and maintaining a Custom Modified kernel ebpf programs are also easy to write you",
    "start": "106799",
    "end": "113640"
  },
  {
    "text": "can use a high level language such as python go rust or C and there's a lot of",
    "start": "113640",
    "end": "120060"
  },
  {
    "text": "performance advantages to using ebpf that's that's the main advantage to",
    "start": "120060",
    "end": "126420"
  },
  {
    "text": "running directly in the kernel it lends itself so that user mode applications can adopt an asynchronous programming",
    "start": "126420",
    "end": "132959"
  },
  {
    "text": "style which means fewer contact switches from user mode to Kernel mode which is",
    "start": "132959",
    "end": "138239"
  },
  {
    "text": "Advantage advantageous for Modern Hardware",
    "start": "138239",
    "end": "142459"
  },
  {
    "text": "as I stated before ebpf programs can be written in a high level language such as C python go rust and others then using a",
    "start": "143580",
    "end": "151800"
  },
  {
    "text": "tool chain for your preferred programming language the programs can are compiled into Ebbs byte code and",
    "start": "151800",
    "end": "158940"
  },
  {
    "text": "here we have pictured um some sample evpf instructions what they look like",
    "start": "158940",
    "end": "166159"
  },
  {
    "text": "um so how does it work here we have a diagram of the evpf ecosystem so let's",
    "start": "167160",
    "end": "176099"
  },
  {
    "text": "get into a brief overview first the user mode application loads the byte code",
    "start": "176099",
    "end": "181140"
  },
  {
    "text": "into the kernel via a syscall and the ebpf verifier will perform checks on the",
    "start": "181140",
    "end": "187800"
  },
  {
    "text": "byte code if the checks are passed the byte code is jit compiled into the need of",
    "start": "187800",
    "end": "193019"
  },
  {
    "text": "instruction set for the architecture or the instructions can be executed by The Interpreter while running just it just",
    "start": "193019",
    "end": "199560"
  },
  {
    "text": "depends on the Kernel configuration then the application attaches the loaded ebpf program into a hook hook point and",
    "start": "199560",
    "end": "208800"
  },
  {
    "text": "evpf utilizes event-based execution so the program will execute after it's",
    "start": "208800",
    "end": "214019"
  },
  {
    "text": "triggered by some event that occurs at the hook point then the application can interact with",
    "start": "214019",
    "end": "220500"
  },
  {
    "text": "the program via input and output with ebpf maps and helper functions",
    "start": "220500",
    "end": "227659"
  },
  {
    "text": "um whether unprivileged users can run ebpf programs depends on assist control",
    "start": "228180",
    "end": "233220"
  },
  {
    "text": "knob um which is called unprivileged vpf disabled unprivileged users are limited",
    "start": "233220",
    "end": "239040"
  },
  {
    "text": "to where programs can hook so the hook points that can be attached in particular unprivileged users are",
    "start": "239040",
    "end": "244860"
  },
  {
    "text": "allowed to hook to a socket that the user owns and in recent times there's been a",
    "start": "244860",
    "end": "251400"
  },
  {
    "text": "kconfig kernel configuration config BPF unprep default which sets the sys",
    "start": "251400",
    "end": "257820"
  },
  {
    "text": "control knob during runtime by default that restricts unprivileged users that",
    "start": "257820",
    "end": "263820"
  },
  {
    "text": "kernel kit config has been set by default in popular distributions like Ubuntu beginning around last year 2022.",
    "start": "263820",
    "end": "273000"
  },
  {
    "text": "and cap BPF is a Linux capability that can be granted to users or containers to",
    "start": "273000",
    "end": "278759"
  },
  {
    "text": "run ebpf programs there are also fewer restrictions on programs that can be",
    "start": "278759",
    "end": "284220"
  },
  {
    "text": "loaded for a user that has a cat BPF capabilities",
    "start": "284220",
    "end": "290060"
  },
  {
    "text": "um so a little bit of a new development that happened um recently unprivileged restrictions on",
    "start": "290400",
    "end": "296160"
  },
  {
    "text": "ebpf programs are currently being Revisited and discussed with the possibility that capabilities will be",
    "start": "296160",
    "end": "303300"
  },
  {
    "text": "further restructured so that more users without uh without capsis admin can run",
    "start": "303300",
    "end": "308460"
  },
  {
    "text": "evpf programs and also currently ebpf has no LSM uh Linux security model hooks",
    "start": "308460",
    "end": "316500"
  },
  {
    "text": "so it's not protected by mandatory access control implementations like SC Linux for now that may change in the",
    "start": "316500",
    "end": "324720"
  },
  {
    "text": "near future and therefore ebpf security auditing Still Remains relevant and",
    "start": "324720",
    "end": "330360"
  },
  {
    "text": "important um ebpf vulnerabilities pose a risk for",
    "start": "330360",
    "end": "336060"
  },
  {
    "text": "applications that are given cap BPF capabilities or running in containers with the capability even if unprivileged",
    "start": "336060",
    "end": "342840"
  },
  {
    "text": "ebpf is not allowed you may see this in actual environments for untrusted applications that process",
    "start": "342840",
    "end": "348960"
  },
  {
    "text": "heavy i o or networking activity some examples are Services firewalls security",
    "start": "348960",
    "end": "355919"
  },
  {
    "text": "or Telemetry applications and applications that run in containers that use ebpf",
    "start": "355919",
    "end": "363479"
  },
  {
    "text": "um so a quick note on the threat model and attack surfaces that we are focusing on for this talk",
    "start": "365340",
    "end": "372060"
  },
  {
    "text": "um mainly we're interested in vulnerabilities that allow uh privilege escalation meaning going from",
    "start": "372060",
    "end": "377699"
  },
  {
    "text": "unprivileged user to ebpf program to Kernel execution to root theoretically",
    "start": "377699",
    "end": "384000"
  },
  {
    "text": "there are some attack surfaces that could lead to remote code execution in ebpf for example like an mbpf programs",
    "start": "384000",
    "end": "392880"
  },
  {
    "text": "that do packet parsing operations or helper functions that assist with packet parsing but this is not our Focus we're",
    "start": "392880",
    "end": "400440"
  },
  {
    "text": "mainly focused on local privilege escalation for this talk",
    "start": "400440",
    "end": "406819"
  },
  {
    "text": "um so there are three places where ebpf vulnerabilities can reside it's either",
    "start": "407280",
    "end": "413280"
  },
  {
    "text": "in the verifier the jit compiler and the ebpf runtime kernel runtime when",
    "start": "413280",
    "end": "420660"
  },
  {
    "text": "building a fuzzer it's important to survey the types of vulnerabilities that can occur and how how to detect them in",
    "start": "420660",
    "end": "427380"
  },
  {
    "text": "order to automate a corpus generation in a way that makes sense and gains the best coverage for the Target",
    "start": "427380",
    "end": "434160"
  },
  {
    "text": "and on that note we're going to review types of bug classes that can occur in each of these components to give context",
    "start": "434160",
    "end": "439740"
  },
  {
    "text": "about what to keep in mind when building our fuzzer the first component that we'll discuss",
    "start": "439740",
    "end": "446520"
  },
  {
    "text": "is the ebpf verifier which is the component of evpf that ensures a program",
    "start": "446520",
    "end": "451580"
  },
  {
    "text": "is safe to safe to run in the kernel it's one of if not the most important",
    "start": "451580",
    "end": "457560"
  },
  {
    "text": "component for security because it bugs there or undefined Behavior there in",
    "start": "457560",
    "end": "463020"
  },
  {
    "text": "this component have a direct effect on weather an unsafe program is allowed to run",
    "start": "463020",
    "end": "468660"
  },
  {
    "text": "and what happens when it runs one of the things that the verifier does",
    "start": "468660",
    "end": "474240"
  },
  {
    "text": "to ensure safety is by keeping track of the expected values of scalar value scalar value registers that are used in",
    "start": "474240",
    "end": "482039"
  },
  {
    "text": "an ebpf program it imposes a restriction that only scalars can be added to pointers to",
    "start": "482039",
    "end": "488460"
  },
  {
    "text": "access memory of shared Maps the verifier has to ensure that these scalar registers fall within the",
    "start": "488460",
    "end": "496259"
  },
  {
    "text": "expected range and do not lead to out-of-bound memory accesses errors in how these ranges are",
    "start": "496259",
    "end": "502800"
  },
  {
    "text": "calculated result in the ability to manipulate the verifiers checks and allow kernel memory corruption",
    "start": "502800",
    "end": "511400"
  },
  {
    "text": "um here's an example of a code snippet in of an ebpf program that's written in go that is accessing and updating a",
    "start": "511620",
    "end": "518640"
  },
  {
    "text": "value inside the memory of an ebpf map and the verifier must ensure that one of",
    "start": "518640",
    "end": "523860"
  },
  {
    "text": "uh operations like this the one that we show above don't result in operating an out of bounds memory",
    "start": "523860",
    "end": "531620"
  },
  {
    "text": "an example of this kind of vulnerability Is cve 2020 27194 which was actually",
    "start": "532620",
    "end": "538800"
  },
  {
    "text": "discovered by the first iteration of the fuzzer that we're presenting on today it was caused by the miscalculation of",
    "start": "538800",
    "end": "545339"
  },
  {
    "text": "32-bit ranges which were derived by 64-bit registers this was actually a",
    "start": "545339",
    "end": "551399"
  },
  {
    "text": "problem that was seen before the discovery of this bug which prompted the ebpf devs to do individual tracking of",
    "start": "551399",
    "end": "558839"
  },
  {
    "text": "30-bit 32-bit ranges separate from the 64-bit ranges but unfortunately the",
    "start": "558839",
    "end": "564420"
  },
  {
    "text": "patch introduced another bug which was found by our fuzzer",
    "start": "564420",
    "end": "569820"
  },
  {
    "text": "another type of bug that can occur in the verifier is branching prediction bugs the verifier must analyze uh all",
    "start": "569820",
    "end": "577320"
  },
  {
    "text": "potential code Paths of the program being loaded and ensure that the",
    "start": "577320",
    "end": "583019"
  },
  {
    "text": "behavior at runtime Falls within expected safe constraints that the",
    "start": "583019",
    "end": "589200"
  },
  {
    "text": "verifier will impose it patches out instructions that I believe will never be reached or it also does not analyze",
    "start": "589200",
    "end": "597899"
  },
  {
    "text": "branches it believes to be in a scene State already or technically safe the",
    "start": "597899",
    "end": "603720"
  },
  {
    "text": "reason for this is performance as analysis on every single code path can grow exponentially",
    "start": "603720",
    "end": "609899"
  },
  {
    "text": "and bugs in the verifiers predict branching prediction mechanisms can lead to the ability to manipulate the program",
    "start": "609899",
    "end": "616440"
  },
  {
    "text": "state to one that's unexpected by the verifier",
    "start": "616440",
    "end": "621540"
  },
  {
    "text": "an example of this type of bug is cve 2023-2163 which was discovered by the",
    "start": "621540",
    "end": "628980"
  },
  {
    "text": "second iteration of the fusset that we're presenting today and we'll be discussed more in depth later",
    "start": "628980",
    "end": "636800"
  },
  {
    "text": "the last type of verifier vulnerability um uh types of bug classes that we're",
    "start": "636839",
    "end": "642779"
  },
  {
    "text": "going to discuss is just general logic bugs so logic bugs can occur when",
    "start": "642779",
    "end": "648620"
  },
  {
    "text": "traversing and verifying the program but they're not directly related to the",
    "start": "648620",
    "end": "653640"
  },
  {
    "text": "calculation of ranges an example of this bug a cve 2021 3490 this bug was caused",
    "start": "653640",
    "end": "661440"
  },
  {
    "text": "by the verifier failing to update the bounds of scalar registers after 32-bit",
    "start": "661440",
    "end": "667079"
  },
  {
    "text": "and or or xor operations however I want to emphasize that this was not an error",
    "start": "667079",
    "end": "673800"
  },
  {
    "text": "in the calculation of the ranges themselves and I think this is an",
    "start": "673800",
    "end": "679079"
  },
  {
    "text": "important factor to keep in mind as we move on to discussing fuzzing later and Ponder whether fuzzing scalar register",
    "start": "679079",
    "end": "685860"
  },
  {
    "text": "operations is worthwhile if we think that the range calculation operations",
    "start": "685860",
    "end": "691680"
  },
  {
    "text": "have already been exhausted and thoroughly audited",
    "start": "691680",
    "end": "696860"
  },
  {
    "text": "uh we'll click we'll quickly discuss where bugs may happen in the other two components I listed starting with the",
    "start": "696860",
    "end": "702720"
  },
  {
    "text": "jit compiler so the ebpf jit compiler compiles the ebpf byte code to assembly",
    "start": "702720",
    "end": "708300"
  },
  {
    "text": "of the Native architecture of the system um again one of the classes of bugs that",
    "start": "708300",
    "end": "715680"
  },
  {
    "text": "might occur here code generation bugs but this is a broad category um but the example",
    "start": "715680",
    "end": "722399"
  },
  {
    "text": "um in this one is caused by optimization of code generation that leads to branching miscalculations",
    "start": "722399",
    "end": "729420"
  },
  {
    "text": "um the cve listed here is a vulnerability with how Branch displacements were calculated for some architectures which could cause the ebpf",
    "start": "729420",
    "end": "736740"
  },
  {
    "text": "program to branch in an unexpected location in the program this of course can violate the assumptions about the",
    "start": "736740",
    "end": "743339"
  },
  {
    "text": "program State at the new Jump Target assumed by the verifier during static",
    "start": "743339",
    "end": "748380"
  },
  {
    "text": "analysis this will allow the possibility for an attacker using the new program state to get the program to do bad",
    "start": "748380",
    "end": "754980"
  },
  {
    "text": "things that the verifier initially believed was impossible during runtime this also highlights how architectural",
    "start": "754980",
    "end": "761459"
  },
  {
    "text": "differences can manifest in ebpf and a second type of a class that can",
    "start": "761459",
    "end": "768480"
  },
  {
    "text": "occur in the jit compiler also falls into the code generation umbrella but this one has to do with translation",
    "start": "768480",
    "end": "774000"
  },
  {
    "text": "so um the cve listed here is a bug in the way that classic ebpf programs are",
    "start": "774000",
    "end": "780420"
  },
  {
    "text": "translated and compiled in the jit compiler one thing that I didn't mention previously is that ebpf still has",
    "start": "780420",
    "end": "787980"
  },
  {
    "text": "support for classic BPF programs that use a slightly different instruction set",
    "start": "787980",
    "end": "793279"
  },
  {
    "text": "and the way that this is handled is by doing a translation from classic BPF to",
    "start": "793279",
    "end": "799079"
  },
  {
    "text": "Modern ebpf in the jit compiler and this highlights that Legacy cbpf program",
    "start": "799079",
    "end": "806100"
  },
  {
    "text": "support can also lead to issues and lastly I'm going to discuss",
    "start": "806100",
    "end": "811740"
  },
  {
    "text": "vulnerabilities in the ebpf runtime component ebpf has helper functions that",
    "start": "811740",
    "end": "817440"
  },
  {
    "text": "can interact with the ebpf program during runtime the code the code for this runs in the on Sandbox part of the",
    "start": "817440",
    "end": "824760"
  },
  {
    "text": "kernel which just means the normal part of the kernel code",
    "start": "824760",
    "end": "830779"
  },
  {
    "text": "and one of an example of a vulnerability here is cve",
    "start": "831540",
    "end": "837620"
  },
  {
    "text": "2021-38166 which is an integer overflow and out of bounds right in the hashmap",
    "start": "837620",
    "end": "842760"
  },
  {
    "text": "lookup function this vulnerability can be triggered if an application creates an ebpf map of a type hash map and calls",
    "start": "842760",
    "end": "851100"
  },
  {
    "text": "a helper function within the evpf program to retrieve a value stored in the map",
    "start": "851100",
    "end": "856680"
  },
  {
    "text": "a big portion of the ebpf runtime code attack surface is related to operating on shared maps and retrieving storing",
    "start": "856680",
    "end": "864420"
  },
  {
    "text": "their values so what now",
    "start": "864420",
    "end": "869639"
  },
  {
    "text": "um automated vulnerability Discovery with proper context of the target we began our automated vulnerability",
    "start": "869639",
    "end": "876240"
  },
  {
    "text": "Discovery process by targeting ebpf via buzzing after surveying our the attack",
    "start": "876240",
    "end": "881820"
  },
  {
    "text": "surface possible and potential for automated vulnerability Discovery the component we decided to Target is the",
    "start": "881820",
    "end": "888060"
  },
  {
    "text": "ebpf verifier I'll hand it off to Simon",
    "start": "888060",
    "end": "892940"
  },
  {
    "text": "thank you Valentina for the introduction to ebpf and the type of vulnerabilities that can occur and there were a lot of",
    "start": "894180",
    "end": "900060"
  },
  {
    "text": "details a lot of very subtle vulnerabilities so one of the reasons we decided to automate vulnerability",
    "start": "900060",
    "end": "906240"
  },
  {
    "text": "Discovery is at the time of making the slides the verifier.c file alone has over 17 000 Linus of code and the code",
    "start": "906240",
    "end": "913139"
  },
  {
    "text": "is very complex and complicated and it's difficult to read so automating vulnerability Discovery",
    "start": "913139",
    "end": "918779"
  },
  {
    "text": "just makes sense to just make it easier for ourselves and then uh the code is also very actively maintained there's",
    "start": "918779",
    "end": "924420"
  },
  {
    "text": "lots of changes so one of the vulnerabilities we discovered which was cve 2020 27 194 was introduced as a",
    "start": "924420",
    "end": "930839"
  },
  {
    "text": "patch for another security issue uh which contained I think hundreds even thousands of lines of code so ebpf is a",
    "start": "930839",
    "end": "937620"
  },
  {
    "text": "standard and if we can automate vulnerability Discovery we can likely Port it uh to more than one implementation or more than one",
    "start": "937620",
    "end": "944100"
  },
  {
    "text": "operating system or different versions of an operating system so the approach we took was fuzzing and",
    "start": "944100",
    "end": "952079"
  },
  {
    "text": "some of the advantages of fuzzing are it doesn't require a very deep technical understanding of the verifier code",
    "start": "952079",
    "end": "957240"
  },
  {
    "text": "itself so we just know what the verifier expects it expects evpf programs it can",
    "start": "957240",
    "end": "963180"
  },
  {
    "text": "verify our secure so we can just generate programs uh instead and and this is much easier than actually",
    "start": "963180",
    "end": "969300"
  },
  {
    "text": "reading the verifier code and finding some of these more subtle logic issues the ebpf instruction set is not very",
    "start": "969300",
    "end": "975779"
  },
  {
    "text": "large which means we can generate all up codes in a reasonable time frame when we",
    "start": "975779",
    "end": "981120"
  },
  {
    "text": "implement the fuzzer and the input generation and the EPA ebpf interface so the sys called to load programs to",
    "start": "981120",
    "end": "987000"
  },
  {
    "text": "verify them and then to actually execute them it doesn't change much meaning a fuzzer can be adapted relatively easy to",
    "start": "987000",
    "end": "992940"
  },
  {
    "text": "various implementations as well so at the time uh we considered some",
    "start": "992940",
    "end": "998759"
  },
  {
    "text": "existing Solutions this was in 2020 and there was an ebpf fuzzer for the Linux implementation uh however they were",
    "start": "998759",
    "end": "1005839"
  },
  {
    "text": "aiming at finding memory corruption issues in the verifier itself so they would try to load a program that would",
    "start": "1005839",
    "end": "1011540"
  },
  {
    "text": "cost for example an out of bounds read write and they did find issues however these are more classical if you will",
    "start": "1011540",
    "end": "1017779"
  },
  {
    "text": "memory corruption box we were more interested in logic bugs that occur after the verifier has verified a",
    "start": "1017779",
    "end": "1023959"
  },
  {
    "text": "program and made wrong assumptions about the program another alternative we consider was",
    "start": "1023959",
    "end": "1029000"
  },
  {
    "text": "ciscollar it's a coverage guide and then sophisticated kernel fuzzer however at the time I was more interested in",
    "start": "1029000",
    "end": "1035240"
  },
  {
    "text": "finding a singular issue and I decided that it would be easier instead of",
    "start": "1035240",
    "end": "1041058"
  },
  {
    "text": "hacking on the assist call or go source code to just write an evpf program from scratches it would take me around the",
    "start": "1041059",
    "end": "1047240"
  },
  {
    "text": "same time and the scholar is built to trigger and detect loud memory corruption issues so your kernel panics",
    "start": "1047240",
    "end": "1053660"
  },
  {
    "text": "your Azan ksen alerts if you will and we",
    "start": "1053660",
    "end": "1058700"
  },
  {
    "text": "were interested in these like very subtle to find logic bug issues so writing a fuzzer from scratch and",
    "start": "1058700",
    "end": "1065059"
  },
  {
    "text": "tailoring it for ebpf allowed us to reap some advantages for example we can optimize the fuzzing input generator to",
    "start": "1065059",
    "end": "1072559"
  },
  {
    "text": "generate valid ebpf programs and then we can modify it quite easily for experiments so for example Valentina",
    "start": "1072559",
    "end": "1078020"
  },
  {
    "text": "mentioned lots of different vulnerability classes so if we believe hey maybe there's something fishy about",
    "start": "1078020",
    "end": "1083780"
  },
  {
    "text": "this part of the code we can optimize and bias the fuzzer towards these areas of the code",
    "start": "1083780",
    "end": "1089480"
  },
  {
    "text": "and we can also choose an appropriate architecture for the fuzzer so usually for example syscollar you generate your",
    "start": "1089480",
    "end": "1095360"
  },
  {
    "text": "input you execute it and then you repeat this in a loop however with ebpf we need to verify programs and not all programs",
    "start": "1095360",
    "end": "1101600"
  },
  {
    "text": "we are going to generate are going to be valid which means we can have one component generating programs and then",
    "start": "1101600",
    "end": "1107840"
  },
  {
    "text": "the other can faster programs that are considered valid so this allows us to build a more optimized architecture and",
    "start": "1107840",
    "end": "1114919"
  },
  {
    "text": "we can also Implement a strategy for detecting box because this is quite subtle and I'll get into the details in",
    "start": "1114919",
    "end": "1120860"
  },
  {
    "text": "the next slides so the input generation on a very high level at naive fuzzer will just throw",
    "start": "1120860",
    "end": "1126260"
  },
  {
    "text": "random bytes at a program until it crashes so the issue with this approach is that in order for a program to crash",
    "start": "1126260",
    "end": "1132080"
  },
  {
    "text": "well or to trigger an issue and the verifier we needed to pass the verifier first so just throwing having a naive",
    "start": "1132080",
    "end": "1139460"
  },
  {
    "text": "bit flipping approach even if it's coverage guided just isn't optimized for performance in this case because if we",
    "start": "1139460",
    "end": "1145640"
  },
  {
    "text": "generate a long list a long array of opcodes they need to be correctly encoded they need to specify a valid",
    "start": "1145640",
    "end": "1151340"
  },
  {
    "text": "operation specify valid registers so source and destination or they or and",
    "start": "1151340",
    "end": "1157280"
  },
  {
    "text": "they need to specify immediates that are inside of the allowed ranges so that means if we generate eppf programs and",
    "start": "1157280",
    "end": "1165080"
  },
  {
    "text": "we have input generator that's optimized towards this we can just have a higher rate of programs that are considered",
    "start": "1165080",
    "end": "1170960"
  },
  {
    "text": "valid by the ebpf verifier so in the first version of the fuzzer we generated programs by prepending a",
    "start": "1170960",
    "end": "1177080"
  },
  {
    "text": "static program header that performed all necessary initialization so when you load an evpf program some registers will",
    "start": "1177080",
    "end": "1184100"
  },
  {
    "text": "point to for example the stack or the network packet that is being filtered and then we can set up an ebpf map that",
    "start": "1184100",
    "end": "1190940"
  },
  {
    "text": "will be used during the program execution so this part of the program always stayed the same and after we",
    "start": "1190940",
    "end": "1196880"
  },
  {
    "text": "generated a variable length of of an array of opcodes mostly allo operations",
    "start": "1196880",
    "end": "1202340"
  },
  {
    "text": "and then we just did random operations with random registers random immediates in a random order and then we would",
    "start": "1202340",
    "end": "1209960"
  },
  {
    "text": "append a static program footer that exited the program cleanly so we had this kind of skeleton approach where in",
    "start": "1209960",
    "end": "1215600"
  },
  {
    "text": "the middle there was just a whole bunch of random operations so this screenshot shows a loop which",
    "start": "1215600",
    "end": "1222080"
  },
  {
    "text": "generates a number of instruction and this variable is just Dynamic this can be just depends this is kind of a",
    "start": "1222080",
    "end": "1228260"
  },
  {
    "text": "tunable so you can say I want to have between 20 10 and 20 instructions in each generated program so the left",
    "start": "1228260",
    "end": "1234200"
  },
  {
    "text": "instructions you have the higher the probability is the program will be considered valid by the verifier just",
    "start": "1234200",
    "end": "1239720"
  },
  {
    "text": "because there's less places where something could go wrong but if you have more instructions then there's more complexity in the program so there is a",
    "start": "1239720",
    "end": "1246320"
  },
  {
    "text": "higher chance that something will go wrong so we can see we're generating in this screenshot uh in most cases with a",
    "start": "1246320",
    "end": "1252320"
  },
  {
    "text": "80 chance we generate an Aloo operation there are also other operations such as branching operations but this fuzzer was",
    "start": "1252320",
    "end": "1258620"
  },
  {
    "text": "naive compared to the second version and mostly just generated Aloo operations",
    "start": "1258620",
    "end": "1263840"
  },
  {
    "text": "and the next screenshot shows the generation of an aloe operation where we just choose a random opcode such as",
    "start": "1263840",
    "end": "1270260"
  },
  {
    "text": "addition or multiplication and then this continues on and on or we choose a random source and destination register",
    "start": "1270260",
    "end": "1276620"
  },
  {
    "text": "for the operation and that's how the programs came to be so now that we can generate ebpf",
    "start": "1276620",
    "end": "1282679"
  },
  {
    "text": "programs we have to consider error detection so as Valentina mentioned there is a lot of different vulnerability classes some of them very",
    "start": "1282679",
    "end": "1288799"
  },
  {
    "text": "subtle for example from the compilation of one program type to another some that can occur after the verification some",
    "start": "1288799",
    "end": "1295940"
  },
  {
    "text": "are just triggering a wrong assumption in the verifier where the verifier believes okay I have the correct range",
    "start": "1295940",
    "end": "1301640"
  },
  {
    "text": "but it's actually not the correct range and these issues are likely hard to detect with the usual standards such as",
    "start": "1301640",
    "end": "1308960"
  },
  {
    "text": "a kernel crash just because just because an issue was triggered inside of the jet code in the resulting code it doesn't",
    "start": "1308960",
    "end": "1315620"
  },
  {
    "text": "mean it will actually crash the kernel so in this version of the fuzzer what we",
    "start": "1315620",
    "end": "1320840"
  },
  {
    "text": "did is we relied on the fact that if you use pointer arithmetic so you modify a",
    "start": "1320840",
    "end": "1326360"
  },
  {
    "text": "pointer and then use it to access memory for example accessing a map if the program passes the verifier then the",
    "start": "1326360",
    "end": "1332900"
  },
  {
    "text": "verifier is 100 certain that this pointer right will be inside of the bounds of the memory that it's writing",
    "start": "1332900",
    "end": "1339380"
  },
  {
    "text": "to so we can test this assumption by writing a magic value to the ebpf map at",
    "start": "1339380",
    "end": "1345679"
  },
  {
    "text": "the end of the program execution and then after the program executes we can check if the magic value is inside of",
    "start": "1345679",
    "end": "1352340"
  },
  {
    "text": "the expected range of memory and if it's not that means the value was written out of bounds so this approach Works however",
    "start": "1352340",
    "end": "1359120"
  },
  {
    "text": "it's still not perfect and we have an improved version of the error detection coming up the problem with this is that",
    "start": "1359120",
    "end": "1365539"
  },
  {
    "text": "the the right could be in bounce but it could still be outside of the expected range of the verifier",
    "start": "1365539",
    "end": "1373580"
  },
  {
    "text": "so let's talk about performance and scaling um so at the time at least when I wrote",
    "start": "1373580",
    "end": "1378679"
  },
  {
    "text": "the first version of the fuzzer the ebpf verifier runs with a global lock uh meaning that the fuzzer won't scale well",
    "start": "1378679",
    "end": "1384799"
  },
  {
    "text": "uh no matter how many CPUs you throw at it it will always be bottlenecked by",
    "start": "1384799",
    "end": "1389840"
  },
  {
    "text": "this lock and this is bad news because we expect most of our time to be spent within the verifier so this first",
    "start": "1389840",
    "end": "1395720"
  },
  {
    "text": "version of the fuzzer generated less than one percent of valid programs which means almost all of the computation time",
    "start": "1395720",
    "end": "1402500"
  },
  {
    "text": "was spent in the verifier which basically runs on a single CPU so we",
    "start": "1402500",
    "end": "1407659"
  },
  {
    "text": "have some architectural um solutions for this so at the time I",
    "start": "1407659",
    "end": "1413179"
  },
  {
    "text": "decided to extract the verifier code from the Linux kernel and compile it in user space and this had several benefits",
    "start": "1413179",
    "end": "1419419"
  },
  {
    "text": "for scalability uh one was there were no contact switches so loading and verifying a program requires expensive",
    "start": "1419419",
    "end": "1426200"
  },
  {
    "text": "syscalls and we didn't have those and we could kind of remove the logic of the verifier lock and emulated have multiple",
    "start": "1426200",
    "end": "1432860"
  },
  {
    "text": "processes running at the same time and it's also a lot easier to debug potential issues just because you can",
    "start": "1432860",
    "end": "1439340"
  },
  {
    "text": "just attach GDB to a user Space Program you can compile it relatively quickly and add print statements and so on so",
    "start": "1439340",
    "end": "1446720"
  },
  {
    "text": "the downside is extracting kernel code and compiling it in user space with the disclaimer I didn't find a nice way of",
    "start": "1446720",
    "end": "1454039"
  },
  {
    "text": "automating this it's very time consuming and it's difficult to Port just because there's so many dependencies you pull",
    "start": "1454039",
    "end": "1459799"
  },
  {
    "text": "into the user space program and there's a lot of low level code you have to emulate like the kernel memory allocator",
    "start": "1459799",
    "end": "1465679"
  },
  {
    "text": "and a lot of just low level kernel apis that need to be either just no opt or",
    "start": "1465679",
    "end": "1471500"
  },
  {
    "text": "emulated in some way so unfortunately it was very difficult to adapt this approach to multiple versions",
    "start": "1471500",
    "end": "1477820"
  },
  {
    "text": "just because the commit frequency of the ebpf verifier is quite high so this makes this even more complicated",
    "start": "1477820",
    "end": "1484460"
  },
  {
    "text": "so this image also represents the architecture of the first version so we have the ebpf in user space which is",
    "start": "1484460",
    "end": "1491360"
  },
  {
    "text": "called by the generator and this emulates the kernel verifier and it checks the program for safety and resets",
    "start": "1491360",
    "end": "1497480"
  },
  {
    "text": "the emulation and if the program is considered unsafe we just generate a new program until the program is considered",
    "start": "1497480",
    "end": "1502940"
  },
  {
    "text": "safe and if the verifier believes this program is fine there's no security issues here we pass it on to the triager",
    "start": "1502940",
    "end": "1510020"
  },
  {
    "text": "which actually loads the program into kernel in a VM and then starts fuzzling it starts executing it with different",
    "start": "1510020",
    "end": "1516679"
  },
  {
    "text": "random inputs so it also tries to catch really out of Bounce box and reports them back to the",
    "start": "1516679",
    "end": "1522559"
  },
  {
    "text": "main component of the fuzzer so to summarize the first version of the fuzzer it was very scalable and fast to",
    "start": "1522559",
    "end": "1530419"
  },
  {
    "text": "the user space fuzzing approach however it wasn't hard to it was hard to adapt",
    "start": "1530419",
    "end": "1535520"
  },
  {
    "text": "this to new versions so I think uh summarizing I think using kernel code and user space to fuss a very specific",
    "start": "1535520",
    "end": "1542960"
  },
  {
    "text": "part of code can be very fast and speed up the process but it's very tedious in",
    "start": "1542960",
    "end": "1548299"
  },
  {
    "text": "hard work until there is a really nice approach to emulate this nicely",
    "start": "1548299",
    "end": "1553760"
  },
  {
    "text": "so another Pro was we had a first fuzzer that was just really optimized for ebpf",
    "start": "1553760",
    "end": "1559460"
  },
  {
    "text": "input generation so all the the programs we generated were correctly encoded however there was no intelligent",
    "start": "1559460",
    "end": "1566320"
  },
  {
    "text": "generation of programs so it was just a list of up codes which is why the valid",
    "start": "1566320",
    "end": "1573020"
  },
  {
    "text": "rate was less than one percent and another Pro was it was very eBay easy to debug issues and this fuzzer was",
    "start": "1573020",
    "end": "1580220"
  },
  {
    "text": "written in 2020 and it was written in C plus plus it was never released and then my colleague JJ will now tell you about",
    "start": "1580220",
    "end": "1587360"
  },
  {
    "text": "the second version of the fuzzer hello",
    "start": "1587360",
    "end": "1593600"
  },
  {
    "text": "it's a very funny thing that one of the first projects you take when joining a new team is based on a random article on",
    "start": "1593600",
    "end": "1600140"
  },
  {
    "text": "the internet WPF hosting and then you find out that the author of the article joins your team helps you build this new",
    "start": "1600140",
    "end": "1606500"
  },
  {
    "text": "project and then you end up in Black at Asia in Singapore uh so yes in our previous strategy the",
    "start": "1606500",
    "end": "1613580"
  },
  {
    "text": "biggest issue was that only a fraction of the programs are considered valid and",
    "start": "1613580",
    "end": "1618620"
  },
  {
    "text": "what if we create a filter that generates a high volume of syntactically valid programs and we're looking for",
    "start": "1618620",
    "end": "1625460"
  },
  {
    "text": "programs that are semantically around what does this mean well this means that the outcomes aren't quite well the jumps are often quite well means that we have",
    "start": "1625460",
    "end": "1632360"
  },
  {
    "text": "programs that look valid but what we're hunting actually for is programs that look valid but invalidate the security",
    "start": "1632360",
    "end": "1638960"
  },
  {
    "text": "rules that evpf verifier has so we came up with this uh it's a new",
    "start": "1638960",
    "end": "1645679"
  },
  {
    "text": "Foster well we started with a Foster and we end up with a fossil framework because we noticed that we had enough",
    "start": "1645679",
    "end": "1651559"
  },
  {
    "text": "code to basically generate any type of avf programs easily and we were like",
    "start": "1651559",
    "end": "1657080"
  },
  {
    "text": "okay what if instead of like just throw in one type of like program generation we create a way to generate multiple",
    "start": "1657080",
    "end": "1662960"
  },
  {
    "text": "types of programs and just like what if people are able to create their own ways of generating APF programs I'm",
    "start": "1662960",
    "end": "1668960"
  },
  {
    "text": "validating for issues in the verifier uh that's what we call like forcing",
    "start": "1668960",
    "end": "1674539"
  },
  {
    "text": "strategies and let's talk a little bit about what and why and this all builds up on what Valentina really mentioned",
    "start": "1674539",
    "end": "1680179"
  },
  {
    "text": "that when you're building a fossil it's very important for you to understand what type of issues you're looking for",
    "start": "1680179",
    "end": "1685460"
  },
  {
    "text": "and how you detect when those issues happen that's basically opposing strategy uh we we build up a couple of Hosting",
    "start": "1685460",
    "end": "1694400"
  },
  {
    "text": "strategies for example the parse verifier log strategy which we generate a bunch of random",
    "start": "1694400",
    "end": "1701240"
  },
  {
    "text": "audio operations then we parse the verifiers log to see what the Assumption of the verifier were at verified time",
    "start": "1701240",
    "end": "1708440"
  },
  {
    "text": "and here let's make an important a note that there are basically two points in",
    "start": "1708440",
    "end": "1713720"
  },
  {
    "text": "evpf one is the verified time when the verifier checks that all the Assumption",
    "start": "1713720",
    "end": "1718940"
  },
  {
    "text": "all the things that the program does are safe or adhere to the security rules and",
    "start": "1718940",
    "end": "1724100"
  },
  {
    "text": "then there is execution time when there are no more verifications well except for a few patching instructions",
    "start": "1724100",
    "end": "1730039"
  },
  {
    "text": "um so at verified time we get the log and we pass the very first assumptions at the runtime we get the values of the",
    "start": "1730039",
    "end": "1737360"
  },
  {
    "text": "registers and we compare those values with those assumptions if anything doesn't match like for example like",
    "start": "1737360",
    "end": "1742520"
  },
  {
    "text": "let's say the verify so like register zero had value one but turn out register hero had value two then we fly out flag",
    "start": "1742520",
    "end": "1749240"
  },
  {
    "text": "these as a problem then there is a pointer automatic",
    "start": "1749240",
    "end": "1754640"
  },
  {
    "text": "strategy which is based on what Simon just presented basically we generate a bunch of random operations on registers",
    "start": "1754640",
    "end": "1761059"
  },
  {
    "text": "uh this also includes some jump operations that we include later and then at the at the very end of the",
    "start": "1761059",
    "end": "1768320"
  },
  {
    "text": "program we grab one of those registers and we add it to a pointer to a map value and then we write to that to that",
    "start": "1768320",
    "end": "1774799"
  },
  {
    "text": "to that pointer at user space then we check if at",
    "start": "1774799",
    "end": "1780559"
  },
  {
    "text": "runtime again the value was actually written to the map if the value is not there then it means that very likely an",
    "start": "1780559",
    "end": "1787340"
  },
  {
    "text": "out of bounds right happen and this is the strategy that actually found the second CV that we representing",
    "start": "1787340",
    "end": "1794419"
  },
  {
    "text": "to do it today 2023 2163 I'm gonna talk a little bit more about that in other words let's just dive in a",
    "start": "1794419",
    "end": "1801679"
  },
  {
    "text": "little bit more in problem generation in a nutshell uh or phosphorus framework can generate",
    "start": "1801679",
    "end": "1807140"
  },
  {
    "text": "programs in a tree like structure and there is an interface that people can grab and then Implement their own",
    "start": "1807140",
    "end": "1812419"
  },
  {
    "text": "forcing strategies there are other features like we include",
    "start": "1812419",
    "end": "1818360"
  },
  {
    "text": "coverage we include that also like some statistics",
    "start": "1818360",
    "end": "1823898"
  },
  {
    "text": "and for some statistics it can generate around 35k vpf programs per minute for",
    "start": "1823940",
    "end": "1829760"
  },
  {
    "text": "example I've been running an instance of this filter since last week and I think right now we're around like 40 million programs generated",
    "start": "1829760",
    "end": "1835760"
  },
  {
    "text": "which is a pretty nice number uh and again like let me stay very clear that a",
    "start": "1835760",
    "end": "1841520"
  },
  {
    "text": "lot of those programs are going to be rejected by the verifier and that's okay because we are sure that the programs",
    "start": "1841520",
    "end": "1848059"
  },
  {
    "text": "are being generated because have been rejected because the verify things is an invalid pointer are in I think",
    "start": "1848059",
    "end": "1853520"
  },
  {
    "text": "and that's more interesting than a program being rejected because uh along with the encoding of an operation is",
    "start": "1853520",
    "end": "1859700"
  },
  {
    "text": "wrong and well 24 hours after we set to run",
    "start": "1859700",
    "end": "1865580"
  },
  {
    "text": "this thing for real we got our first strike 2023 2163 uh the tldr and things",
    "start": "1865580",
    "end": "1872419"
  },
  {
    "text": "volunteer for the r for the root cause analysis because it was very hard is that the verifier for optimization",
    "start": "1872419",
    "end": "1878840"
  },
  {
    "text": "purposes at any given point for branching can decide okay I'm not",
    "start": "1878840",
    "end": "1885020"
  },
  {
    "text": "going to follow this Branch because I have already proven that in the state that I am currently at if I follow this",
    "start": "1885020",
    "end": "1892039"
  },
  {
    "text": "Branch I'm going to exit the program safely there are other reasons why the verifier",
    "start": "1892039",
    "end": "1897260"
  },
  {
    "text": "cost branches but this is the one that matters here and turns out that we've",
    "start": "1897260",
    "end": "1902840"
  },
  {
    "text": "well the Foster found one of those cases where pruning average actually it leads",
    "start": "1902840",
    "end": "1908960"
  },
  {
    "text": "to an unsafe condition and actually at runtime it is this branch that gets",
    "start": "1908960",
    "end": "1914059"
  },
  {
    "text": "followed and well it results in kernel read write memory so also another important thing of this",
    "start": "1914059",
    "end": "1922460"
  },
  {
    "text": "work is that we are very very convinced that it will have been extremely hard to",
    "start": "1922460",
    "end": "1927679"
  },
  {
    "text": "find by manual auditing just because of how complex the verify code is and just how complex the pruning logic is",
    "start": "1927679",
    "end": "1935299"
  },
  {
    "text": "actually and let's be real like the very far is actually trying to do a very hard job like proving that the program is",
    "start": "1935299",
    "end": "1940460"
  },
  {
    "text": "safe proving the program reach a safe condition at the end it's a very hard problem to do so",
    "start": "1940460",
    "end": "1946399"
  },
  {
    "text": "we actually turn this into a local previous escalation plus container Escape that I'm going to show you right",
    "start": "1946399",
    "end": "1952580"
  },
  {
    "text": "now so we are outside container in a ciscover VM we have these folder that",
    "start": "1952580",
    "end": "1960260"
  },
  {
    "text": "belongs to user user there is M it's empty at first then we go to a container that runs with",
    "start": "1960260",
    "end": "1967340"
  },
  {
    "text": "cap BPF just bring the very inside container and",
    "start": "1967340",
    "end": "1972440"
  },
  {
    "text": "also proving that we are not able to read the user folder",
    "start": "1972440",
    "end": "1978760"
  },
  {
    "text": "so then we execute our exploit it's going to take a while so I can talk",
    "start": "1982159",
    "end": "1989419"
  },
  {
    "text": "to you a little bit more what's going on here here we see that we leaked some kernel memory addresses and now we're trying to",
    "start": "1989419",
    "end": "1995480"
  },
  {
    "text": "defeat aslr by finding they need PID and as string offset the second technique",
    "start": "1995480",
    "end": "2000519"
  },
  {
    "text": "you can go on the Internet to read more on how to how to bound the kernel using this",
    "start": "2000519",
    "end": "2005620"
  },
  {
    "text": "once we found it we look for the process that is running inside the container and",
    "start": "2005620",
    "end": "2011559"
  },
  {
    "text": "we cannot rely only on the prosely because namespaces so we look also very executable name",
    "start": "2011559",
    "end": "2017140"
  },
  {
    "text": "once we find it we patch the credentials and we patch the uh",
    "start": "2017140",
    "end": "2022559"
  },
  {
    "text": "We've watched some other pointers and then the file system pointer sorry and",
    "start": "2022559",
    "end": "2028000"
  },
  {
    "text": "then we actually can read outside container so here we can see that actually the folder was not available before it's not",
    "start": "2028000",
    "end": "2034600"
  },
  {
    "text": "it's available now we just write something to it for the",
    "start": "2034600",
    "end": "2039820"
  },
  {
    "text": "purpose of demonstrations",
    "start": "2039820",
    "end": "2042658"
  },
  {
    "text": "we go back to our next Shell dirt review show and we see that there's a file",
    "start": "2045700",
    "end": "2051580"
  },
  {
    "text": "there now so",
    "start": "2051580",
    "end": "2059099"
  },
  {
    "text": "all right so what now okay so the coding of first",
    "start": "2059260",
    "end": "2065440"
  },
  {
    "text": "thing framework name thank you thank you",
    "start": "2065440",
    "end": "2071339"
  },
  {
    "text": "uh cool the going of our first thing framework name buzzer has been made open source it's in github.com",
    "start": "2071379",
    "end": "2079020"
  },
  {
    "text": "there are still some features we want to implement like executing vpf programs in a distributed way across multiple VMS",
    "start": "2079060",
    "end": "2085599"
  },
  {
    "text": "across multiple versions of EPF I think there are some other operating systems also considering implementing APF this",
    "start": "2085599",
    "end": "2090700"
  },
  {
    "text": "is going to be very interesting we will be interested in better metrics collection more forcing strategies Etc",
    "start": "2090700",
    "end": "2096700"
  },
  {
    "text": "and we really just scratched the surface because to find this CV we literally only use arithmetic logic operations and",
    "start": "2096700",
    "end": "2102339"
  },
  {
    "text": "jumps and EVP has so many other features like helper functions there are even Loops so like really the future looks",
    "start": "2102339",
    "end": "2109720"
  },
  {
    "text": "interesting here and used to conclude with the sound bites that we were asked to add like",
    "start": "2109720",
    "end": "2115180"
  },
  {
    "text": "granting cap ppf for programs to run BPF or to be able to load BPF it Still",
    "start": "2115180",
    "end": "2120760"
  },
  {
    "text": "Remains a complicated complex attack surface and we should be careful when they saying to run this capability",
    "start": "2120760",
    "end": "2126460"
  },
  {
    "text": "when building a filter it's important to to think what type of vulnerabilities I am hunting for and how do I detect when",
    "start": "2126460",
    "end": "2134260"
  },
  {
    "text": "this vulnerabilities happen and there is a lot of value in the contribution between security",
    "start": "2134260",
    "end": "2139960"
  },
  {
    "text": "researchers like none of this will have happened just with a single researcher volunteer did an amazing job with the",
    "start": "2139960",
    "end": "2146619"
  },
  {
    "text": "real cost analysis like we would have never understood that book without her Simon of course did the first iteration",
    "start": "2146619",
    "end": "2152140"
  },
  {
    "text": "of the Foster which was the predecessor of the new professor and well now it's just a matter of like",
    "start": "2152140",
    "end": "2159520"
  },
  {
    "text": "Keep collaborating Together keep finding more books and just to conclude does anyone have",
    "start": "2159520",
    "end": "2165820"
  },
  {
    "text": "any questions",
    "start": "2165820",
    "end": "2168240"
  },
  {
    "text": "yes",
    "start": "2172720",
    "end": "2175320"
  },
  {
    "text": "yes the vulnerability happened by okay first we generated programs that had",
    "start": "2180579",
    "end": "2186880"
  },
  {
    "text": "arithmeticologic operations and jobs branching random all random operations",
    "start": "2186880",
    "end": "2192480"
  },
  {
    "text": "then after generating a certain number of operations around like 500 maybe we",
    "start": "2192480",
    "end": "2197680"
  },
  {
    "text": "created a program through there where we loaded EPF map pointer it points to somewhere in user space and",
    "start": "2197680",
    "end": "2204579"
  },
  {
    "text": "we wrote to it no okay first we did so we did an addition between a random register and this pointer",
    "start": "2204579",
    "end": "2210280"
  },
  {
    "text": "then we try to write to that pointer usually what happens is the verifier will be like you're insane like this is",
    "start": "2210280",
    "end": "2216220"
  },
  {
    "text": "not allowed uh but we found just an edge case where this was not analyzed so the verifier was not able to detect that",
    "start": "2216220",
    "end": "2222460"
  },
  {
    "text": "this was insecure I'm writing to it your centered right out of bounds because the pointer was modified so we didn't",
    "start": "2222460",
    "end": "2227560"
  },
  {
    "text": "observe from user space that right actually occur",
    "start": "2227560",
    "end": "2231599"
  },
  {
    "text": "any other questions in the slides too we can update it with the kernel commit",
    "start": "2233440",
    "end": "2238480"
  },
  {
    "text": "that fixes the vulnerability that has uh it's a pretty complex bug so it'll explain everything that went wrong it's",
    "start": "2238480",
    "end": "2245500"
  },
  {
    "text": "kind of hard to describe in like a minute or two yep actually like if you go to my",
    "start": "2245500",
    "end": "2251980"
  },
  {
    "text": "Twitter is probably the tweet that I have been there and like there's a link to the commit that fixes the the box so",
    "start": "2251980",
    "end": "2258160"
  },
  {
    "text": "if you want to go read how exactly it works it's it's a nice it's nice right up",
    "start": "2258160",
    "end": "2264359"
  },
  {
    "text": "or questions all right okay well thank you very much thank you",
    "start": "2270160",
    "end": "2276660"
  }
]