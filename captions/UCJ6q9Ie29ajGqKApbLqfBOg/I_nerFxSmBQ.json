[
  {
    "text": "welcome to how the internet dodged the bullet uh my name is Silas and I'm here with one of my co-authors Nicholas Fogle",
    "start": "2639",
    "end": "9040"
  },
  {
    "text": "and we're going to present our works on the key trap denial of service attacks against DNSC which is a class of",
    "start": "9040",
    "end": "14480"
  },
  {
    "text": "resource exhaustion attacks which cause DNL service first we'll get into one boat um",
    "start": "14480",
    "end": "21760"
  },
  {
    "text": "concerning DNS and DNSC a short refresher and first we'll ask our",
    "start": "21760",
    "end": "26880"
  },
  {
    "text": "question why is it always DNS and we all know it's always DNS we seen in the",
    "start": "26880",
    "end": "31920"
  },
  {
    "text": "keynote for instance that the 2021 Facebook outage uh happened and it also",
    "start": "31920",
    "end": "37120"
  },
  {
    "text": "was due to DNS and the reason for that is why it's always DNS is that DNS is",
    "start": "37120",
    "end": "42879"
  },
  {
    "text": "very mission critical protocol on the internet so virtually every transaction is preceded a DNS lookup in which a",
    "start": "42879",
    "end": "48960"
  },
  {
    "text": "domain name gets resolved to an IP address and therefore DNS is very important so let's have a look how DNS",
    "start": "48960",
    "end": "55920"
  },
  {
    "text": "resolution works we have our client the client sends a query to resolver asking for the address record he wants to",
    "start": "55920",
    "end": "62760"
  },
  {
    "text": "resolve the resolver will then assuming assuming nothing is in its cache forward",
    "start": "62760",
    "end": "68080"
  },
  {
    "text": "that query to the root servers the root name servers will then respond with a referral to the next closest name",
    "start": "68080",
    "end": "74240"
  },
  {
    "text": "servers in that case a second level domain server which will then be queried by the resolver for the very same",
    "start": "74240",
    "end": "80280"
  },
  {
    "text": "records and itself respond with a referral response until eventually the",
    "start": "80280",
    "end": "85360"
  },
  {
    "text": "resolver is delegated to the name server which is actually authoritative for the records the client asked for the server",
    "start": "85360",
    "end": "91520"
  },
  {
    "text": "will then deliver these records to the resolver and the resolver will forward them back to the client",
    "start": "91520",
    "end": "97600"
  },
  {
    "text": "dns is a very old protocol and um it has been created without much security in mind because when the internet was young",
    "start": "97600",
    "end": "104079"
  },
  {
    "text": "there wasn't much concerns about security and the very old attack and very critical critical attack against",
    "start": "104079",
    "end": "109600"
  },
  {
    "text": "DNS is seen as poisoning which is an attack on DNS record authenticity here",
    "start": "109600",
    "end": "114640"
  },
  {
    "text": "in this example the attacker injects poisonous values into the communication between the resolver and the authoritative name server which will",
    "start": "114640",
    "end": "121040"
  },
  {
    "text": "then lead to the client being developed poisonous values and being redirected to the attacker in",
    "start": "121040",
    "end": "128039"
  },
  {
    "text": "turn to prevent that DNSC has been standardized in the late 90s and DNS",
    "start": "128039",
    "end": "133280"
  },
  {
    "text": "uses signatures over the records the resolver validates these signatures and establishes trust in the signatures by",
    "start": "133280",
    "end": "139599"
  },
  {
    "text": "means of a public infrastructure which is aligned with the DNS hierarchy and this prevents the",
    "start": "139599",
    "end": "147200"
  },
  {
    "text": "attack dnsc is a little IPv6 story so shares some similarities in terms of",
    "start": "147400",
    "end": "152480"
  },
  {
    "text": "adoption uh adoption in domains is quite dragging on the top level domain side it",
    "start": "152480",
    "end": "157599"
  },
  {
    "text": "actually looks rather good so we have about 6% of them not being signed but on",
    "start": "157599",
    "end": "162720"
  },
  {
    "text": "the second level domain side it's much worse so there essentially the other way around only about 7% of them are",
    "start": "162720",
    "end": "169720"
  },
  {
    "text": "signed on the resolver side of things so validating DNS stack uh looks um quite a",
    "start": "169720",
    "end": "175840"
  },
  {
    "text": "bit better so if you take for instance the IPv4 address base and select all those IPv4 addresses which do DNS",
    "start": "175840",
    "end": "182640"
  },
  {
    "text": "resolution uh about a quarter of them also does DNS validation",
    "start": "182640",
    "end": "187920"
  },
  {
    "text": "and if you conduct uh studies using web clients for instance using at networks uh which is something we did um you see",
    "start": "187920",
    "end": "194720"
  },
  {
    "text": "that about a third of the web clients worldwide are protected by resolvers which do validate the",
    "start": "194720",
    "end": "201280"
  },
  {
    "text": "nest so but how does it work let's assume we are a resolver or using a um",
    "start": "201400",
    "end": "207280"
  },
  {
    "text": "terminal for that matter so doesn't make a bit difference we're taking the perspective of resolver now and um we're",
    "start": "207280",
    "end": "212959"
  },
  {
    "text": "asking what is the IP address of www.itf.org",
    "start": "212959",
    "end": "217799"
  },
  {
    "text": "our response looks something like this here we got our IPv4 addresses two of them these addresses are contained in",
    "start": "218480",
    "end": "224959"
  },
  {
    "text": "resource records and these resource records form a set a set is being defined as having the same name class",
    "start": "224959",
    "end": "231280"
  },
  {
    "text": "and type type is the IPv4 address records name is the one we queried and the class is a little anacronistic so um",
    "start": "231280",
    "end": "238480"
  },
  {
    "text": "it's always the internet essentially um you could define other scopes with it but it's virtually done",
    "start": "238480",
    "end": "245439"
  },
  {
    "text": "so we ask also for DNSC records so we get our signature records as well signatures record the signature records",
    "start": "245439",
    "end": "252080"
  },
  {
    "text": "carry the signature and are associated with the record set uh by means of the name the",
    "start": "252080",
    "end": "258400"
  },
  {
    "text": "class and a type covered field which is contained in the record",
    "start": "258400",
    "end": "263479"
  },
  {
    "text": "data so but how is the signature now validated to validate the signature we",
    "start": "263479",
    "end": "270720"
  },
  {
    "text": "also need a key obviously and what we are doing now is also what the resolver does we're querying for the DNS key set",
    "start": "270720",
    "end": "276000"
  },
  {
    "text": "in that domain we get back the DNS key set carrying public keys and the set is",
    "start": "276000",
    "end": "283120"
  },
  {
    "text": "itself signed and covered by signature record so now we have signatures and",
    "start": "283120",
    "end": "289840"
  },
  {
    "text": "keys but how are they associated again we have our two",
    "start": "289840",
    "end": "295120"
  },
  {
    "text": "responses here signatures and keys and we'll just forget about everything which is not important here",
    "start": "295120",
    "end": "302000"
  },
  {
    "text": "and now we have the signer name which is a field in the signature record and the signer name needs to equal the name of",
    "start": "302000",
    "end": "308560"
  },
  {
    "text": "the DNS key record which is the name of the domain we got our records from the algorithm number must match so",
    "start": "308560",
    "end": "316560"
  },
  {
    "text": "um DNSC uses multiple algorithms you can select between them and obviously you cannot evaluate an RSA signature with",
    "start": "316560",
    "end": "323600"
  },
  {
    "text": "ECDSA key and the signature record also has a key tag field which lists um 16 bit",
    "start": "323600",
    "end": "331080"
  },
  {
    "text": "number note that the dines record does not fe feature such a field so um the",
    "start": "331080",
    "end": "336160"
  },
  {
    "text": "key tag is then calculated as a 16- bit check sum over the record data and not conveyed in a",
    "start": "336160",
    "end": "343560"
  },
  {
    "text": "field so having calculated the key tag we now can use the triple of the owner name equals signer name and algorithm",
    "start": "343560",
    "end": "351919"
  },
  {
    "text": "number and key tag to associate a signature with a key speaking of keys um we measured and",
    "start": "351919",
    "end": "359600"
  },
  {
    "text": "found that DNS keys in top level domains for instance um are usually less than four and um 10 or two is the most common",
    "start": "359600",
    "end": "367680"
  },
  {
    "text": "case on the internet and it's essentially the same in all domains where that we measured so the least",
    "start": "367680",
    "end": "373520"
  },
  {
    "text": "domains online are using more than four keys the reason behind that is transport requirements to keep DNS efficient",
    "start": "373520",
    "end": "380240"
  },
  {
    "text": "what's also efficient here is the association of keys and signatures because there are only at max four keys",
    "start": "380240",
    "end": "386319"
  },
  {
    "text": "uh commonly and uh so this mechanism is very efficient under normal conditions",
    "start": "386319",
    "end": "392240"
  },
  {
    "text": "but we're not here to show you normal conditions we're here to show you an attack which is our key trap",
    "start": "392240",
    "end": "400440"
  },
  {
    "text": "attacks so let's check back and see how the association of signatures with keys works we now have a key tag which is",
    "start": "400440",
    "end": "407600"
  },
  {
    "text": "matching but what happens if key tags collide in the DNS key set so now we",
    "start": "407600",
    "end": "412800"
  },
  {
    "text": "have both the name the algorithm number and the key tag which is all the same for multiple DNS",
    "start": "412800",
    "end": "418759"
  },
  {
    "text": "keys and this can actually happen and uh therefore the protocol also",
    "start": "418759",
    "end": "425240"
  },
  {
    "text": "um included a mechanism to deal with that so first of all uh resolvers and implementations validators must not",
    "start": "425240",
    "end": "431759"
  },
  {
    "text": "assume that the key tech uniquely identifies a DNS key and if it's the case that this whole",
    "start": "431759",
    "end": "437199"
  },
  {
    "text": "triple uh tribal is not unique then the validator cannot uh really select between one but must by means of",
    "start": "437199",
    "end": "444160"
  },
  {
    "text": "specification try all of them until it runs out of keys to try or found a pair",
    "start": "444160",
    "end": "449360"
  },
  {
    "text": "of keys and signatures which validates so this requirement ensures robustness",
    "start": "449360",
    "end": "456319"
  },
  {
    "text": "which is very important in DNSC because if you have a misconfiguration on the domain side and something goes wrong in",
    "start": "456319",
    "end": "461919"
  },
  {
    "text": "that configuration then all subdomains are not reachable as well and this is also very old requirement so this is um",
    "start": "461919",
    "end": "468960"
  },
  {
    "text": "seen first in the 1999 specification already so it's very central for the",
    "start": "468960",
    "end": "474759"
  },
  {
    "text": "NSAC but it's a little strange right we have a linear time algorithm over resource intensive public key",
    "start": "474759",
    "end": "480960"
  },
  {
    "text": "cryptography operations and a resolver really must try all keys i mean this this must capital must this RC lingo for",
    "start": "480960",
    "end": "488000"
  },
  {
    "text": "either you do it or you don't abide by specification requirements sounds a little like a bad idea",
    "start": "488000",
    "end": "493960"
  },
  {
    "text": "right but there was more there was another requirement and",
    "start": "493960",
    "end": "500080"
  },
  {
    "text": "there is another requirement this is up to- date specification that resolver should try all signatures covering a",
    "start": "500080",
    "end": "505759"
  },
  {
    "text": "record set so in case there are multiple and one does not really validate it does not work because it has been created",
    "start": "505759",
    "end": "511759"
  },
  {
    "text": "with an outdated key or whatever um all the signatures need to be tried until the resolver runs out of signatures to",
    "start": "511759",
    "end": "518399"
  },
  {
    "text": "try or finds one which validates again this is meant to ensure",
    "start": "518399",
    "end": "523800"
  },
  {
    "text": "robustness in face of validation errors or attacks this requirement is from 2013 so it has",
    "start": "523800",
    "end": "530480"
  },
  {
    "text": "been introduced a little later in the end we now have not a linear time algorithm over cryptography",
    "start": "530480",
    "end": "537680"
  },
  {
    "text": "but um actually a quadratic one and if we have a look at the implementations we",
    "start": "537680",
    "end": "543200"
  },
  {
    "text": "also see that the validation routine of open source resolvers in this case it's unbound are actually doing this so here",
    "start": "543200",
    "end": "549440"
  },
  {
    "text": "in this case we have an outer signature loop where unbound tries all the signatures until it finds one which matches and an inner key loop where",
    "start": "549440",
    "end": "555680"
  },
  {
    "text": "unbound tries all the keys matching this trial until it finds a key which matches so the validation routine is",
    "start": "555680",
    "end": "563160"
  },
  {
    "text": "quadratic doesn't look good but that doesn't also doesn't really imply an attack already so there could be limited",
    "start": "563160",
    "end": "569200"
  },
  {
    "text": "buffers or other mitigations in place so if we want to attack unbound or any",
    "start": "569200",
    "end": "574720"
  },
  {
    "text": "other resolver for that regard we need to construct an attack to do this we first must find out",
    "start": "574720",
    "end": "582480"
  },
  {
    "text": "how much can all actually be and we if we have a look at the protocol we find there's not many restrictions in DNS we",
    "start": "582480",
    "end": "589440"
  },
  {
    "text": "have our DNS message header here on the right side uh which limits the records in a section to two to the^ 16 minus one",
    "start": "589440",
    "end": "597760"
  },
  {
    "text": "so 16 bit counter and um so DNS and uh",
    "start": "597760",
    "end": "603920"
  },
  {
    "text": "signature records must be conveyed in the same message and even in in the same",
    "start": "603920",
    "end": "609720"
  },
  {
    "text": "um section for that regard to work so record sets in DNS must not be split",
    "start": "609720",
    "end": "615040"
  },
  {
    "text": "across multiple sections or even multiple messages so in the end our bottleneck here is the",
    "start": "615040",
    "end": "621279"
  },
  {
    "text": "um length specifier from the transport layer which is uh 16 bits and that's the",
    "start": "621279",
    "end": "626880"
  },
  {
    "text": "same for all the transport protocols which have been um specified for",
    "start": "626880",
    "end": "633000"
  },
  {
    "text": "DNS so if we do the math size of a DNS message is about",
    "start": "633000",
    "end": "638920"
  },
  {
    "text": "64k one DNS key record algorithm 13 is 80 byt that leaves us space for 820",
    "start": "638920",
    "end": "646399"
  },
  {
    "text": "signature records um sorry keys per response speaking of signatures one",
    "start": "646399",
    "end": "652000"
  },
  {
    "text": "signature record is about 110 bytes again doing the math about 600 of them per response if we multiply that keys",
    "start": "652000",
    "end": "659760"
  },
  {
    "text": "times signatures we end up with 490,000 validations per single",
    "start": "659760",
    "end": "665600"
  },
  {
    "text": "response now let's assume uh one signature validation takes 1550",
    "start": "665880",
    "end": "671240"
  },
  {
    "text": "microsconds and again doing the math we end up with 74 74 seconds calculation",
    "start": "671240",
    "end": "676880"
  },
  {
    "text": "time for one set of signatures in a single response quite a",
    "start": "676880",
    "end": "684560"
  },
  {
    "text": "bit okay so now we know how many DNS keys and and signatures we can fit into",
    "start": "684920",
    "end": "690800"
  },
  {
    "text": "one response let's construct an attack first we need to have the DNS keys and for that matter a very large set of DNS",
    "start": "690800",
    "end": "697120"
  },
  {
    "text": "keys which all conform the same key tag and we're doing this in a pretty",
    "start": "697120",
    "end": "702240"
  },
  {
    "text": "straightforward fashion we just select one key tag and roll dices generate a lot of keys until we have enough of them to put into our responses which all",
    "start": "702240",
    "end": "709040"
  },
  {
    "text": "conform to the same key tag in the end our zone file looks",
    "start": "709040",
    "end": "714959"
  },
  {
    "text": "something like this here we have the subset of keys which is matching um so first it has different",
    "start": "714959",
    "end": "723120"
  },
  {
    "text": "public keys this is relevant because all the keys uh the signature records sorry the records in one set must not be the",
    "start": "723120",
    "end": "729920"
  },
  {
    "text": "same because it's a set and sets are dduplicated so we have different public keys all that we dice rolled before and",
    "start": "729920",
    "end": "738320"
  },
  {
    "text": "all the records conform to the same key tag and uh for resolvers to actually",
    "start": "738320",
    "end": "744800"
  },
  {
    "text": "accept that we also need another signature over the key set which is efficiently validated with a separate",
    "start": "744800",
    "end": "750560"
  },
  {
    "text": "DNS key which has a separate key tag and can be found efficiently efficiently",
    "start": "750560",
    "end": "757320"
  },
  {
    "text": "so now we want to have signatures and signatures need to cover something uh for that matter we have um IPv4 address",
    "start": "758800",
    "end": "765120"
  },
  {
    "text": "a single record put into our zone file and then we have a lot of signatures covering it this is the record just some random",
    "start": "765120",
    "end": "773440"
  },
  {
    "text": "IPv4 address and a whole lot of signatures all pointing to the same",
    "start": "773440",
    "end": "779920"
  },
  {
    "text": "owner name I number and key tag the signatures themselves um are",
    "start": "779920",
    "end": "787440"
  },
  {
    "text": "actually cryptography invalid which is important but mathematically um on on",
    "start": "787440",
    "end": "793040"
  },
  {
    "text": "the syntactic side syntactically they're valid so we we took a prototype record and just created a signature over it so",
    "start": "793040",
    "end": "799920"
  },
  {
    "text": "that the validation routine runs as long as possible before the validator notices okay this doesn't work",
    "start": "799920",
    "end": "805800"
  },
  {
    "text": "out and again to prevent dduplication we just um went and changed the timestamps",
    "start": "805800",
    "end": "811839"
  },
  {
    "text": "for validity to introduce variability in the set and all you can see here is",
    "start": "811839",
    "end": "817920"
  },
  {
    "text": "repeated all over the place in our zone file so there's not just one IPv4 address record but multiple of them so",
    "start": "817920",
    "end": "823279"
  },
  {
    "text": "that we can then go on and query multiple records okay we've set up our zone file",
    "start": "823279",
    "end": "829279"
  },
  {
    "text": "now we want to attract a victim resolver straightforward way to do this would be just quite directly but commonly on the",
    "start": "829279",
    "end": "835839"
  },
  {
    "text": "internet um resolvers there are quite a few which you could actually query directly but",
    "start": "835839",
    "end": "842480"
  },
  {
    "text": "often times there's a firewall blocking access to it our attacker knows ways around this",
    "start": "842480",
    "end": "848480"
  },
  {
    "text": "for instance the attacker could send an email to a victim domain um with a non-existent mailbox and if the mail",
    "start": "848480",
    "end": "855680"
  },
  {
    "text": "server is configured to deliver bounce messages the mail server will then go on and look up the sender domain which is",
    "start": "855680",
    "end": "861199"
  },
  {
    "text": "the attacker domain to deliver the response message saying hey I got an email to mailbox which I don't",
    "start": "861199",
    "end": "867480"
  },
  {
    "text": "know other ways would be for instance sending HTML email to victim network so that um the client opens the email and",
    "start": "867480",
    "end": "876240"
  },
  {
    "text": "includes say images for instance which can be shown or not or can be big or not",
    "start": "876240",
    "end": "881519"
  },
  {
    "text": "doesn't matter so all these inclusion of of external resources in the HTML will",
    "start": "881519",
    "end": "886560"
  },
  {
    "text": "then trigger a lot of DNS requests to the victim resolver which will then query the attacker",
    "start": "886560",
    "end": "893000"
  },
  {
    "text": "domain all this can also be scaled up because in the end DNS is a very open protocol so firewall doesn't really help",
    "start": "893000",
    "end": "899680"
  },
  {
    "text": "as we've seen DNS resolvers are not meant to be run in isolation and uh the attacker can also scale this up quite a",
    "start": "899680",
    "end": "906480"
  },
  {
    "text": "little because um as we've seen we only have static zone data to serve and it's not even much so it's much in terms of a",
    "start": "906480",
    "end": "912800"
  },
  {
    "text": "single DNS transaction but it's not much in terms of com DOS uh it's just 64k per",
    "start": "912800",
    "end": "919279"
  },
  {
    "text": "um signature response and uh to scale up the attack the attacker could use other",
    "start": "919279",
    "end": "924560"
  },
  {
    "text": "mechanisms for instance distributing online ads again with HTML including external resources or also internet",
    "start": "924560",
    "end": "931440"
  },
  {
    "text": "measurement networks could be abused in this example we see RI",
    "start": "931440",
    "end": "936720"
  },
  {
    "text": "atlas the tech procedure now is rather straightforward the attacker just sends multiple queries to the resolver the",
    "start": "937399",
    "end": "943680"
  },
  {
    "text": "resolver will then go on and fetch all the data from the attacker domain and run hot at CPU and sees responding",
    "start": "943680",
    "end": "950000"
  },
  {
    "text": "so this is flooding the victim resolver with malicious queries and we also brought you a demo",
    "start": "950000",
    "end": "956240"
  },
  {
    "text": "to show you how it",
    "start": "956240",
    "end": "959040"
  },
  {
    "text": "works so I assume you can see this uh we got on the right side here is our",
    "start": "961880",
    "end": "967279"
  },
  {
    "text": "resource monitor which shows our uh CPU utilization it's around um 10% right now",
    "start": "967279",
    "end": "973839"
  },
  {
    "text": "and below that there's um memory consumption but this is flatlining all the time this is not a memory based",
    "start": "973839",
    "end": "979000"
  },
  {
    "text": "attack and here on the left side on the lower left we have probing requests for benign domain which are running um two",
    "start": "979000",
    "end": "986639"
  },
  {
    "text": "of them per second we set a timeout of 500 milliseconds which isn't a lot but doesn't really matter it's just for",
    "start": "986639",
    "end": "992240"
  },
  {
    "text": "demonstration purposes usual timeouts are about 5 seconds and uh in this attack as I said doesn't really matter",
    "start": "992240",
    "end": "1000160"
  },
  {
    "text": "so now we're running our attack and we see this is just one query for the",
    "start": "1000160",
    "end": "1005519"
  },
  {
    "text": "attacker domain from our victim resolver which is a power s",
    "start": "1005519",
    "end": "1011440"
  },
  {
    "text": "recursor the attack has started we see instantaneously after 500 milliseconds",
    "start": "1012680",
    "end": "1019600"
  },
  {
    "text": "um our benign queries get timeouts and fail and our CPU is pinned at 100%",
    "start": "1019600",
    "end": "1027038"
  },
  {
    "text": "and this will go on for some seconds which I'm not showing you because it's can be minutes can be can be more",
    "start": "1027039",
    "end": "1033520"
  },
  {
    "text": "nicholas has a few words on that later um and uh this runs until the resolver",
    "start": "1033520",
    "end": "1038798"
  },
  {
    "text": "has validated all the signatures and found that none of the signatures with work with any of the",
    "start": "1038799",
    "end": "1044720"
  },
  {
    "text": "keys so I've showed you the key secret trap attack which is an instance of our key trap attacks we also have others um",
    "start": "1048679",
    "end": "1056240"
  },
  {
    "text": "there's sikjam which is just using the signature records for attack lo which is using only the colliding dq set with",
    "start": "1056240",
    "end": "1063440"
  },
  {
    "text": "individual signatures that's a little academic distinguish uh distinguishment but um we show by that that you could",
    "start": "1063440",
    "end": "1070480"
  },
  {
    "text": "exploit all the individual um requirements in the RFC's alone so of",
    "start": "1070480",
    "end": "1075919"
  },
  {
    "text": "course key trap is the combined attack which is the most powerful but all the individual aspects work as well and then",
    "start": "1075919",
    "end": "1082400"
  },
  {
    "text": "we've brought also brought hashtrap uh which is essentially key trap but not with signature records uh instead key",
    "start": "1082400",
    "end": "1089679"
  },
  {
    "text": "trap uses the s records um which are used to link between a parent and the child domain and uh these DS records",
    "start": "1089679",
    "end": "1096240"
  },
  {
    "text": "don't use public key crypto but only hashes so naturally they're not as effective and if you want to know more",
    "start": "1096240",
    "end": "1102400"
  },
  {
    "text": "you're pointed to our uh publication which we have linked on the last slide",
    "start": "1102400",
    "end": "1108320"
  },
  {
    "text": "speaking of effectiveness I would like to hand over to my co-author Nicholas",
    "start": "1108320",
    "end": "1113520"
  },
  {
    "text": "thank you stage is yours okay uh thank you IAS right so we have now seen how",
    "start": "1113520",
    "end": "1119120"
  },
  {
    "text": "the attack works how it exploits keys and signatures to cause a lot of load on the resolver but now let's take a short",
    "start": "1119120",
    "end": "1125679"
  },
  {
    "text": "step back and look at how we can maximize the impact of this attack and for this we have to look at the DNSC",
    "start": "1125679",
    "end": "1132080"
  },
  {
    "text": "algorithms so DNSC supports multiple different cryptographic algorithms and",
    "start": "1132080",
    "end": "1137919"
  },
  {
    "text": "since the size of the message is limited it turns out that size actually matters here and actually the smaller the better",
    "start": "1137919",
    "end": "1145200"
  },
  {
    "text": "right because the smaller the keys and the smaller the signatures the more we can fit into one message and the more",
    "start": "1145200",
    "end": "1150640"
  },
  {
    "text": "validations we can induce in the resolver but it turns out that this is not the whole story so when we tested",
    "start": "1150640",
    "end": "1157039"
  },
  {
    "text": "this in our lab we found that different algorithms produce different loads per key bit and elliptic curve are much",
    "start": "1157039",
    "end": "1164240"
  },
  {
    "text": "better suited because they are producing much more load on the resolver than RSA based algorithms and therefore we used",
    "start": "1164240",
    "end": "1170799"
  },
  {
    "text": "elliptic curve in all of our evaluations and with this now let's come to one of the most exciting parts in the",
    "start": "1170799",
    "end": "1177440"
  },
  {
    "text": "presentation which is the evaluations of the attack and for this we created a local isolated setup on our machine um",
    "start": "1177440",
    "end": "1185440"
  },
  {
    "text": "and we set up the unbound DNS sec resolver and we also set up a server running an attacking client and what the",
    "start": "1185440",
    "end": "1192559"
  },
  {
    "text": "attacker is doing it requests a domain from unbound to resolve and this domain is attacker controlled so Unbound now",
    "start": "1192559",
    "end": "1199919"
  },
  {
    "text": "has to go to the DNS server download all the zone data validate the data and then can reply to the client if this domain",
    "start": "1199919",
    "end": "1207120"
  },
  {
    "text": "could be resolved maybe the IP address or if maybe resolution failed and we also set up additional monitoring on",
    "start": "1207120",
    "end": "1213760"
  },
  {
    "text": "unbound to check how it reacts to our attacks and with this now let's come to",
    "start": "1213760",
    "end": "1218960"
  },
  {
    "text": "the first variant of our attack which is a smaller version that just exploits many signatures with one key and in this",
    "start": "1218960",
    "end": "1226080"
  },
  {
    "text": "setup we send 10 requests per second to Unbound all requesting unique domains to",
    "start": "1226080",
    "end": "1231600"
  },
  {
    "text": "ensure that the records are not cached and then Unbound will have to go to our DNS server and for each of these",
    "start": "1231600",
    "end": "1238240"
  },
  {
    "text": "requests download our zone data and in this first attack we constructed a zone",
    "start": "1238240",
    "end": "1243760"
  },
  {
    "text": "that has 340 signatures that all map to the same DNS key so they all have colliding key tags and what happens now",
    "start": "1243760",
    "end": "1250799"
  },
  {
    "text": "is that Unbound will have to validate through all these signatures before it can conclude that the request is invalid",
    "start": "1250799",
    "end": "1256640"
  },
  {
    "text": "and can't be resolved which means that if we have 10 requests per second then the resolver will have to do 3,400",
    "start": "1256640",
    "end": "1263440"
  },
  {
    "text": "validations before it can reply to the client per second and the impact of this we can see on the next slide so here I",
    "start": "1263440",
    "end": "1270640"
  },
  {
    "text": "have a plot of the monitoring of unbound and the plot on the xs x xaxis shows the",
    "start": "1270640",
    "end": "1276799"
  },
  {
    "text": "time of the measurement and on the y-axis we see CPU load and the loss packets and if you can look at the graph",
    "start": "1276799",
    "end": "1283600"
  },
  {
    "text": "here you can see that as soon as the attack starts CPU load immediately spikes to 100% which is also what we s",
    "start": "1283600",
    "end": "1289919"
  },
  {
    "text": "saw in the demo and since the fan is still running I assume it's still the attack is still running um so it",
    "start": "1289919",
    "end": "1295280"
  },
  {
    "text": "immediately spikes to 100% because unbound is so busy validating through all these signatures and at the same",
    "start": "1295280",
    "end": "1301120"
  },
  {
    "text": "time all benign traffic to the resolver is completely lost so we have 100% packet loss on the resolver and that's",
    "start": "1301120",
    "end": "1309039"
  },
  {
    "text": "already a huge problem right because we have a full denial of service attack which only requires 10 requests per",
    "start": "1309039",
    "end": "1315200"
  },
  {
    "text": "second which is totally viable like 10 requests per second will not land you usually in any rate limiting so this is",
    "start": "1315200",
    "end": "1322400"
  },
  {
    "text": "already a complete attack and this is the smaller variant right we didn't test the full attack yet um so since this is",
    "start": "1322400",
    "end": "1329760"
  },
  {
    "text": "blackhead we of course brought something worse which is the biggest attack that we have which we called key sick trap",
    "start": "1329760",
    "end": "1336799"
  },
  {
    "text": "and this attack now exploits many signatures and many keys and the setup is very similar to the previous setup um",
    "start": "1336799",
    "end": "1344159"
  },
  {
    "text": "with one important distinction instead of sending 10 requests per second we now just send one single request and that is",
    "start": "1344159",
    "end": "1350799"
  },
  {
    "text": "not per second it's just one request and then the same thing happens unbound will have to go to our DNS server to resolve",
    "start": "1350799",
    "end": "1357520"
  },
  {
    "text": "the single request and in the zone we now have again the 340 signatures but we",
    "start": "1357520",
    "end": "1363679"
  },
  {
    "text": "also have 582 keys and they all have colliding key tags so what will happen",
    "start": "1363679",
    "end": "1369520"
  },
  {
    "text": "now if unbound follows specification it will have to validate each of these signatures against each of these keys so",
    "start": "1369520",
    "end": "1376480"
  },
  {
    "text": "creating a cryotic amount of validations and if we do the math here we can see",
    "start": "1376480",
    "end": "1381520"
  },
  {
    "text": "that um Unbound will have to do over 220,000 validations just from this",
    "start": "1381520",
    "end": "1388080"
  },
  {
    "text": "single request so again over 200,000 validations just from a single attacker request and now let's see how the",
    "start": "1388080",
    "end": "1395120"
  },
  {
    "text": "resolver takes this as it turns out not so good so CPU load immediately again",
    "start": "1395120",
    "end": "1401280"
  },
  {
    "text": "spikes to 100% and also lost packets immediately spikes to 100% and this attack from a single request keeps",
    "start": "1401280",
    "end": "1407840"
  },
  {
    "text": "running for 18 entire minutes so just from one single attacker request which the request is about 100 bytes we can do",
    "start": "1407840",
    "end": "1415360"
  },
  {
    "text": "the resolver for 18 entire minutes and keep in mind this doesn't mean the resolver is doed just for the attacker",
    "start": "1415360",
    "end": "1422320"
  },
  {
    "text": "it is dosed for any other person any other client using the same resolver so you can imagine what happens if someone",
    "start": "1422320",
    "end": "1427919"
  },
  {
    "text": "used this on a Google resolver for example and when we did this measurement",
    "start": "1427919",
    "end": "1433200"
  },
  {
    "text": "we thought okay maybe maybe unbound is an outlier right maybe this is just very bad on unbound maybe it doesn't work on",
    "start": "1433200",
    "end": "1439440"
  },
  {
    "text": "the others so we set up the others and we tried and as it turns out every",
    "start": "1439440",
    "end": "1444960"
  },
  {
    "text": "single DNSC resolver that we tested is vulnerable to this and when you think about it it's actually not too",
    "start": "1444960",
    "end": "1451120"
  },
  {
    "text": "surprising because the vulnerability is in the standard it's within the RC's and so if the resolvers are doing what they",
    "start": "1451120",
    "end": "1457360"
  },
  {
    "text": "are supposed to do if they implement a standard if they follow the requirements they are vulnerable and actually we couldn't test",
    "start": "1457360",
    "end": "1464559"
  },
  {
    "text": "all of the resolvers because some of the resolvers are closed source um like the public resolvers like Cloudflare like",
    "start": "1464559",
    "end": "1470960"
  },
  {
    "text": "Google and we couldn't test them because we didn't really feel like running live attacks on production software used by",
    "start": "1470960",
    "end": "1477120"
  },
  {
    "text": "millions of people and we also like to not be in prison so uh we didn't test",
    "start": "1477120",
    "end": "1483039"
  },
  {
    "text": "this on live production but we talked to them and we asked them and they confirmed to us that they are vulnerable and now if you look at this uh table you",
    "start": "1483039",
    "end": "1490080"
  },
  {
    "text": "can see that we have two very notable outliers and the first one is bind which is also the most used DNS resolver and",
    "start": "1490080",
    "end": "1496960"
  },
  {
    "text": "when we tested this on bind initially we started the attack and it just kept on running like the attack it was still",
    "start": "1496960",
    "end": "1503919"
  },
  {
    "text": "validating still stalled until the work day was over so we had to stop it and then on the next day we started again",
    "start": "1503919",
    "end": "1509840"
  },
  {
    "text": "and then we let it run and it turned out that bind was stalled for 16 hours",
    "start": "1509840",
    "end": "1515520"
  },
  {
    "text": "um which is a big problem and when we checked um the reason for this is that they have quite an inefficient key",
    "start": "1515520",
    "end": "1521919"
  },
  {
    "text": "selection routine when you have colliding DNS keys and when you think about it you can't really blame them for",
    "start": "1521919",
    "end": "1528080"
  },
  {
    "text": "it because this is just something that won't happen in normal operation and so they just didn't optimize for it and",
    "start": "1528080",
    "end": "1535120"
  },
  {
    "text": "that's usually not a problem but in the attack it is and so they were very much affected by the attack then another",
    "start": "1535120",
    "end": "1541520"
  },
  {
    "text": "notable outlier is the not resolver which is stalled for a shorter duration i mean it's still 50 seconds it's still",
    "start": "1541520",
    "end": "1547679"
  },
  {
    "text": "a big attack um but it's much shorter than the rest and when we investigated this and we talked to the developers we",
    "start": "1547679",
    "end": "1554159"
  },
  {
    "text": "found that this is caused by a limited buffer for DNS keys so we just couldn't fit as many keys in our attack request",
    "start": "1554159",
    "end": "1561279"
  },
  {
    "text": "and talking to the developers it turned out that this was actually a bug this wasn't intentional um so they they just",
    "start": "1561279",
    "end": "1569360"
  },
  {
    "text": "did some mis miscalculations in the implementation so the buffer was too small and so not all the DNS keys could",
    "start": "1569360",
    "end": "1575760"
  },
  {
    "text": "fit in it um but when they fixed this bug the attack worked the same as in the others so I guess yeah they failed",
    "start": "1575760",
    "end": "1582360"
  },
  {
    "text": "successfully um so um now when we evaluated this we chose a",
    "start": "1582360",
    "end": "1589760"
  },
  {
    "text": "setup which was comparable so we set up all resolvers on a single thread and of course this is not really a totally",
    "start": "1589760",
    "end": "1596480"
  },
  {
    "text": "realistic deployment scenario because in most deployments you will have multiple threads right depending on the",
    "start": "1596480",
    "end": "1601919"
  },
  {
    "text": "deployment you might have between maybe four and 32 threads and so we also had to test how our attack works if we have",
    "start": "1601919",
    "end": "1608480"
  },
  {
    "text": "multi-threading enabled and for this we set up unbound again and this time with five validation threads enabled and then",
    "start": "1608480",
    "end": "1615039"
  },
  {
    "text": "we sent five key trap requests to the resolver and check what happened and it turns out that the scheduling between",
    "start": "1615039",
    "end": "1622640"
  },
  {
    "text": "requests and validation threads is not totally deterministic and they also don't consider the load of the thread",
    "start": "1622640",
    "end": "1628559"
  },
  {
    "text": "when scheduling which means that if you send five requests and have five threads usually you won't hit all of the threads",
    "start": "1628559",
    "end": "1634880"
  },
  {
    "text": "and you can see this here in the example that only four of the five threads were hit because it spikes to 80% but not to",
    "start": "1634880",
    "end": "1640960"
  },
  {
    "text": "100% so one validation thread is still open to reply to benign traffic and you",
    "start": "1640960",
    "end": "1646559"
  },
  {
    "text": "can also see that at the red arrow it goes down for three of the threads um and one threads keeps on valid one",
    "start": "1646559",
    "end": "1652640"
  },
  {
    "text": "thread keeps on validating because that's the thread that was hit by two of the requests whereas one wasn't hit at",
    "start": "1652640",
    "end": "1658240"
  },
  {
    "text": "all and now learning from this and learning from other experiments we did we construct can construct a final",
    "start": "1658240",
    "end": "1664720"
  },
  {
    "text": "attack which is a comprehensive and persistent denial of service and this attack only needs about like a few",
    "start": "1664720",
    "end": "1671679"
  },
  {
    "text": "packets per minute on any of the DNS resolvers we tested and achieves a complete comprehensive persistent DOS so",
    "start": "1671679",
    "end": "1678399"
  },
  {
    "text": "by just sending a few packets per minute you can disable the resolver for anyone using it permanently",
    "start": "1678399",
    "end": "1684960"
  },
  {
    "text": "okay now we have seen how detrimental this attack is um and acute cat and now",
    "start": "1684960",
    "end": "1691520"
  },
  {
    "text": "let's talk about the impact that this was would have if it would be exploited",
    "start": "1691520",
    "end": "1697440"
  },
  {
    "text": "in the wild like what would have happened if someone would have found this and exploited this before it was",
    "start": "1697440",
    "end": "1702520"
  },
  {
    "text": "patched and for this um to get a sense of uh how big the impact is we use a",
    "start": "1702520",
    "end": "1708399"
  },
  {
    "text": "measurement by epnic who just measure how many clients in the internet use a DNS resolver that is DNSC validating and",
    "start": "1708399",
    "end": "1716000"
  },
  {
    "text": "since we want to use DNSC for the attack we have to we must look at how many clients actually use DNS and depending",
    "start": "1716000",
    "end": "1722880"
  },
  {
    "text": "on which metric you use you come to between 33 and 42% of global internet",
    "start": "1722880",
    "end": "1728960"
  },
  {
    "text": "clients using a DNS resolver that validates DNS sec and since all resolvers that we tested which was all",
    "start": "1728960",
    "end": "1735440"
  },
  {
    "text": "that we could find um were vulnerable we assume that basically all of these um",
    "start": "1735440",
    "end": "1740640"
  },
  {
    "text": "clients would be vulnerable to our attack and so therefore This means that if someone would have exploited this on",
    "start": "1740640",
    "end": "1746399"
  },
  {
    "text": "a wider scale they could have potentially disabled DNS services for over one-third of global internet users",
    "start": "1746399",
    "end": "1754000"
  },
  {
    "text": "and if you disable DNS for onethird of global internet users you also disable",
    "start": "1754000",
    "end": "1759120"
  },
  {
    "text": "most internet services for them right if you think about web browsing or if you think about email instant messaging all",
    "start": "1759120",
    "end": "1765120"
  },
  {
    "text": "of them use DNS and if DNS is not available then they can't be they can't use",
    "start": "1765120",
    "end": "1770760"
  },
  {
    "text": "it okay and also one interesting thing to note here is that the more protected",
    "start": "1770760",
    "end": "1775919"
  },
  {
    "text": "a country is so the greener it is on this map for example we're from Germany and Germany has quite a big deployment of DNSC um the more vulnerable it is to",
    "start": "1775919",
    "end": "1784000"
  },
  {
    "text": "these attacks right because you need DNS to carry out the attacks and so the more protected the country is the more",
    "start": "1784000",
    "end": "1789520"
  },
  {
    "text": "vulnerable it is in this case um but at this point we also want to say that we think the NSA is good and I think more",
    "start": "1789520",
    "end": "1795440"
  },
  {
    "text": "people should deploy it so you shouldn't use this as a indication that you shouldn't deploy DNS sec just uh as a",
    "start": "1795440",
    "end": "1802200"
  },
  {
    "text": "disclaimer okay now if we see this huge impact that this attack could have of course we couldn't follow our normal",
    "start": "1802200",
    "end": "1809039"
  },
  {
    "text": "disclosure procedure we couldn't just send out an email describing the attack maybe sending a proof of concept and",
    "start": "1809039",
    "end": "1815039"
  },
  {
    "text": "then very much hoping for a high high CVSS score this wouldn't cut it this time because we just couldn't risk this",
    "start": "1815039",
    "end": "1820880"
  },
  {
    "text": "leaking to someone and then someone exploiting this and so we decided to use a multi-stage process for the disclosure",
    "start": "1820880",
    "end": "1828159"
  },
  {
    "text": "we initially disclosed to a few key experts from the community um who then",
    "start": "1828159",
    "end": "1833440"
  },
  {
    "text": "assemble assembled basically a task force of the most important and trustworthy stakeholders from the",
    "start": "1833440",
    "end": "1839440"
  },
  {
    "text": "community which were mostly the operators and the developers of DNS software and then we worked with them to",
    "start": "1839440",
    "end": "1846559"
  },
  {
    "text": "develop patches against these attacks and this took a couple of months and it was an iterative process so they would",
    "start": "1846559",
    "end": "1853200"
  },
  {
    "text": "develop a patch then send it to us if they thought it might work and then we would test the patch see if it works and",
    "start": "1853200",
    "end": "1860480"
  },
  {
    "text": "see if we can somehow circumvent it which happened a few times so we took a few iterations until finally we had",
    "start": "1860480",
    "end": "1866399"
  },
  {
    "text": "patches which completely mitigated the attack and consisted of multiple counter measures and to illustrate this process",
    "start": "1866399",
    "end": "1873120"
  },
  {
    "text": "I brought two examples and the first example is a patch that was quite early in the process and the idea of this",
    "start": "1873120",
    "end": "1879760"
  },
  {
    "text": "patch is to limit the amount of validations that the resolver is do is willing to do per request which is a",
    "start": "1879760",
    "end": "1886000"
  },
  {
    "text": "very good idea the problem was that the DNSC resolvers of today are quite complex so it's not as straightforward",
    "start": "1886000",
    "end": "1892159"
  },
  {
    "text": "as you might think where to put this in the code and it turned out that in this patch it wasn't put at the right",
    "start": "1892159",
    "end": "1897760"
  },
  {
    "text": "location and so the resolver was still there was still a lot of load on the resolver if the attack was running so",
    "start": "1897760",
    "end": "1903279"
  },
  {
    "text": "this wasn't sufficient um if we now look at a much later patch um this patch",
    "start": "1903279",
    "end": "1908880"
  },
  {
    "text": "implements the same counter measure um limiting the amount of signature validations that the resolver is willing",
    "start": "1908880",
    "end": "1914399"
  },
  {
    "text": "to do and they implemented correctly the problem is that we didn't only have this attack we also had variants of the",
    "start": "1914399",
    "end": "1920799"
  },
  {
    "text": "attack and we also had a variant that didn't use signature validations but instead used um hash computations which",
    "start": "1920799",
    "end": "1928320"
  },
  {
    "text": "can also have collisions so we can also cause a lot of load with the hashes it's not as much load as the signatures",
    "start": "1928320",
    "end": "1933600"
  },
  {
    "text": "because hashes are more efficient but still a lot of load and with this hash trap attack that we called it we were",
    "start": "1933600",
    "end": "1940080"
  },
  {
    "text": "still able to do this resolver even though it was patched but then in the end um this was",
    "start": "1940080",
    "end": "1946480"
  },
  {
    "text": "also patched and then in the end we finally had resolver patches which totally worked which totally mitigated",
    "start": "1946480",
    "end": "1952640"
  },
  {
    "text": "the attacks and with this let's come to our conclusion and lessons learned now the",
    "start": "1952640",
    "end": "1959600"
  },
  {
    "text": "first conclusion is that the key trap text that we showed allow for a comprehensive DOS on any DNS sec",
    "start": "1959600",
    "end": "1965360"
  },
  {
    "text": "resolver that we tested so we assumed the majority of DNS sec resolvers because we tested all we could find and",
    "start": "1965360",
    "end": "1972080"
  },
  {
    "text": "this vulnerability is not an implementation problem it's not the fault of the implementations because",
    "start": "1972080",
    "end": "1977840"
  },
  {
    "text": "it's in the standard it's in the RFC and the RFC I mean people writing RCS are",
    "start": "1977840",
    "end": "1983679"
  },
  {
    "text": "not stupid right they know what they're doing and they put in these requirements to ensure availability i mean I already",
    "start": "1983679",
    "end": "1990720"
  },
  {
    "text": "hinted at this um they put this in because they wanted resolvers to try everything they can to resolve a domain",
    "start": "1990720",
    "end": "1997360"
  },
  {
    "text": "and for example if you have colliding keys the resolver should just try all of them to ensure it finds the one that",
    "start": "1997360",
    "end": "2002399"
  },
  {
    "text": "works and can um resolve the domain but all of these requirements put on the resolvers in the fi in the end led to so",
    "start": "2002399",
    "end": "2009679"
  },
  {
    "text": "much load on the resolvers that it in the end compromised availability so it basically hurt itself in its confusion",
    "start": "2009679",
    "end": "2016399"
  },
  {
    "text": "um and the final the final um conclusion and takeaway that we have is that when",
    "start": "2016399",
    "end": "2021440"
  },
  {
    "text": "writing specification when writing RC's the impact on resource consumption must",
    "start": "2021440",
    "end": "2026720"
  },
  {
    "text": "be considered and that is not only in specific requirements which is also important but also in the combination of",
    "start": "2026720",
    "end": "2032960"
  },
  {
    "text": "requirements so always thinking about how could one requirement in combination with others lead to a lot of load for",
    "start": "2032960",
    "end": "2039039"
  },
  {
    "text": "example on resolvers on or on other software for that matter and what we",
    "start": "2039039",
    "end": "2044559"
  },
  {
    "text": "also found in this example is that generic warnings are not sufficient so",
    "start": "2044559",
    "end": "2049679"
  },
  {
    "text": "the DNS standard also had a generic warning saying \"Yeah you shouldn't put too much load um when resolving a",
    "start": "2049679",
    "end": "2055919"
  },
  {
    "text": "domain.\" But clearly this is not sufficient because if you have requirements especially must requirements people will implement them",
    "start": "2055919",
    "end": "2063040"
  },
  {
    "text": "they are supposed to do and so just having this generic warning you can't expect developers to with each code line",
    "start": "2063040",
    "end": "2068878"
  },
  {
    "text": "they write think about how this generic warning could apply right and that's it now we're at the end of our presentation",
    "start": "2068879",
    "end": "2075520"
  },
  {
    "text": "if you have questions then feel free to ask here or if you want to have more technical insights on this we also wrote",
    "start": "2075520",
    "end": "2081200"
  },
  {
    "text": "a paper which has a huge QR code here so it was published at CCS so if you want",
    "start": "2081200",
    "end": "2086240"
  },
  {
    "text": "to read it then feel free to uh scan the QR code thank you",
    "start": "2086240",
    "end": "2093078"
  },
  {
    "text": "thank you so much for Thank you so much for the fascinating presentation i'm curious a little bit to hear more about",
    "start": "2104640",
    "end": "2110720"
  },
  {
    "text": "the bug or the feature with the not resolver that uh generated that um the",
    "start": "2110720",
    "end": "2117119"
  },
  {
    "text": "results that you've shown i'm also curious to hear about the obvious potential to use this for amplified DOS",
    "start": "2117119",
    "end": "2123119"
  },
  {
    "text": "attacks so this could uh you only mentioned this in passing with regards to using ad serving networks and",
    "start": "2123119",
    "end": "2129200"
  },
  {
    "text": "measurement networks if you could elaborate a little bit about that thank you kindly thank you okay should I start",
    "start": "2129200",
    "end": "2134880"
  },
  {
    "text": "with another thing yes please okay so um if I have it in mind correctly it was basically a decompression problem so",
    "start": "2134880",
    "end": "2140880"
  },
  {
    "text": "they implemented a big enough buffer which was 65 kilobytes which is correct",
    "start": "2140880",
    "end": "2146480"
  },
  {
    "text": "but the problem is that the message was is compressed so it decompresses a little bit and then it goes over the",
    "start": "2146480",
    "end": "2151599"
  },
  {
    "text": "buffer basically and that was the problem and was there a successful resolve yes yeah so they resolved this",
    "start": "2151599",
    "end": "2158000"
  },
  {
    "text": "yeah they basically issued a patch then and the second question you can answer maybe second question regarding uh",
    "start": "2158000",
    "end": "2164160"
  },
  {
    "text": "service okay so um question is what exactly is",
    "start": "2164160",
    "end": "2169280"
  },
  {
    "text": "the target of the DOS attack in this case so we have an attack on DNS resolvers and um in that regard we don't",
    "start": "2169280",
    "end": "2175520"
  },
  {
    "text": "do traffic flooding or something like this this is just in the simplest case 64k transmission twice two of them um so",
    "start": "2175520",
    "end": "2183839"
  },
  {
    "text": "we have an attack on DNS resolvers and you could also flood them with requests to keep them busy and by that degrade",
    "start": "2183839",
    "end": "2189280"
  },
  {
    "text": "the service and in that regard these uh cryptography extensions DNSC uh serve as",
    "start": "2189280",
    "end": "2196079"
  },
  {
    "text": "an amplifier for this attack on the resolver itself because it ramps up CPU resource consumption keeps threats busy",
    "start": "2196079",
    "end": "2201839"
  },
  {
    "text": "and stuff like that um but with regards to like reflection attacks on some links or something overloading them um this is",
    "start": "2201839",
    "end": "2209119"
  },
  {
    "text": "a different scope so a different story we attacking dash resolvers themselves by means of overloading the CPU that's",
    "start": "2209119",
    "end": "2215720"
  },
  {
    "text": "understood you had one where you mentioned the potential to use this with ad delivery networks oh yeah that was um",
    "start": "2215720",
    "end": "2222880"
  },
  {
    "text": "for so to reiterate on that um the slide we we put up with at networks and um",
    "start": "2222880",
    "end": "2229200"
  },
  {
    "text": "measurement networks uh was meant to show that uh the attacker can scale up the attack not just attacking a single",
    "start": "2229200",
    "end": "2235280"
  },
  {
    "text": "resolver by targeting a single one but actually just uh indifferently just hit out and um spray the internet with a lot",
    "start": "2235280",
    "end": "2242640"
  },
  {
    "text": "of these requests to then cause a large scale attack on many resolvers online and by that eventually degrade or",
    "start": "2242640",
    "end": "2248880"
  },
  {
    "text": "completely deny service to um all their clients",
    "start": "2248880",
    "end": "2254000"
  },
  {
    "text": "hey uh great work thank you um it seems like almost all the DNS sec validation",
    "start": "2254000",
    "end": "2259760"
  },
  {
    "text": "type problems are on recursives are you aware of any work on non-recursive DNS",
    "start": "2259760",
    "end": "2266800"
  },
  {
    "text": "sec validation problems or DOSs attacks oh actually um recursive resolvers is",
    "start": "2266800",
    "end": "2271839"
  },
  {
    "text": "just one aspect of our research which we have in our paper more uh we investigated validation libraries um",
    "start": "2271839",
    "end": "2277839"
  },
  {
    "text": "zone checkers for instance which some uh domain operators or some um yeah",
    "start": "2277839",
    "end": "2283680"
  },
  {
    "text": "deployments actually run on zone files so um we had one provider which we had a",
    "start": "2283680",
    "end": "2289359"
  },
  {
    "text": "short look at which actually allows their customers to upload arbitrary records and then um provided they they",
    "start": "2289359",
    "end": "2296240"
  },
  {
    "text": "also check the DNS sec of the zone then you could deny service essentially their interfaces for uploading records but if",
    "start": "2296240",
    "end": "2302240"
  },
  {
    "text": "but if I'm running just an authoritative server doing DNS sec validation I'm",
    "start": "2302240",
    "end": "2307839"
  },
  {
    "text": "pretty safe so DNS sec validation is usually thing of validators downstream not the the",
    "start": "2307839",
    "end": "2314160"
  },
  {
    "text": "authoritative cell so if you're running just the authoritative server and you're not checking for the validation and",
    "start": "2314160",
    "end": "2319839"
  },
  {
    "text": "they're query all they're getting static records there's no real computation occurring at the authoritative server",
    "start": "2319839",
    "end": "2325280"
  },
  {
    "text": "yes so um the the malicious records are queried from the attacker name server so um no benign or innocuous um name",
    "start": "2325280",
    "end": "2332320"
  },
  {
    "text": "servers involved here okay thanks",
    "start": "2332320",
    "end": "2336920"
  },
  {
    "text": "okay okay if no more questions then thank you and thank you very much off to the next speaker",
    "start": "2338320",
    "end": "2346359"
  }
]