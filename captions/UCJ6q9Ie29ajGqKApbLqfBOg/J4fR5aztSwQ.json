[
  {
    "start": "0",
    "end": "71000"
  },
  {
    "text": "good morning my name is nick harper and i will be presenting on the security aspects",
    "start": "2560",
    "end": "7680"
  },
  {
    "text": "of http 3 and quick i've been working on implementing quick at google for the",
    "start": "7680",
    "end": "13360"
  },
  {
    "text": "past few years and i also participate in standardizing the protocol at the ietf",
    "start": "13360",
    "end": "19840"
  },
  {
    "text": "quik is a new general purpose transport protocol it is always encrypted and provides",
    "start": "19840",
    "end": "24880"
  },
  {
    "text": "multiple streams of application data in the same connection with packet loss on one stream not",
    "start": "24880",
    "end": "30080"
  },
  {
    "text": "affecting other streams http 3 is an application protocol built",
    "start": "30080",
    "end": "36160"
  },
  {
    "text": "on quick that provides http semantics its feature set is practically identical to that of http",
    "start": "36160",
    "end": "43200"
  },
  {
    "text": "2. the purpose of quick and http 3 is to improve performance compared to http 2.",
    "start": "43200",
    "end": "51840"
  },
  {
    "text": "over the course of this talk i will show how the protocol stack for http 3 differs from http 2 and examine in",
    "start": "51840",
    "end": "59440"
  },
  {
    "text": "detail many of the features that are moved into the quick protocol i will also explore security related",
    "start": "59440",
    "end": "66080"
  },
  {
    "text": "mechanisms used in quick throughout the lifetime of a quick connection",
    "start": "66080",
    "end": "72560"
  },
  {
    "start": "71000",
    "end": "145000"
  },
  {
    "text": "let's start by looking at how the http 2 protocol stack differs from http 3.",
    "start": "72560",
    "end": "79520"
  },
  {
    "text": "at the bottom of both protocol stacks we have ip which transmits messages between two",
    "start": "79520",
    "end": "84880"
  },
  {
    "text": "addresses on the internet the next layer up in the http 2 protocol",
    "start": "84880",
    "end": "90799"
  },
  {
    "text": "stack is tcp tcp provides an in-order reliable byte stream and allows the",
    "start": "90799",
    "end": "96720"
  },
  {
    "text": "operating system to dispatch incoming connections to different processes based on port numbers",
    "start": "96720",
    "end": "103920"
  },
  {
    "text": "tls runs on top of an in-order reliable byte stream such as the one provided by tcp and it",
    "start": "104159",
    "end": "109920"
  },
  {
    "text": "provides that same abstraction to the level above it but tls adds confidentiality and",
    "start": "109920",
    "end": "115520"
  },
  {
    "text": "integrity to its messages http 2 sits on top of this whole stack",
    "start": "115520",
    "end": "122560"
  },
  {
    "text": "and it provides a way to multiplex streams on a single connection in http 3 all of the functionality that",
    "start": "122560",
    "end": "130479"
  },
  {
    "text": "i just described is moved into the quick protocol",
    "start": "130479",
    "end": "135120"
  },
  {
    "text": "let's start by examining the transport handshake in quick and how that compares to a tcp",
    "start": "136560",
    "end": "143120"
  },
  {
    "text": "handshake in this packet trace we have a client on",
    "start": "143120",
    "end": "149440"
  },
  {
    "start": "145000",
    "end": "328000"
  },
  {
    "text": "the left which initiates a quick connection and a server on the right",
    "start": "149440",
    "end": "156959"
  },
  {
    "text": "in a tcp three-way handshake when the client receives a synack from the server",
    "start": "156959",
    "end": "162080"
  },
  {
    "text": "it can verify that it had to be in response to its sin likewise when the server receives the",
    "start": "162080",
    "end": "168319"
  },
  {
    "text": "first act from the client it can verify that it was in response to the",
    "start": "168319",
    "end": "175040"
  },
  {
    "text": "likewise when the server receives the first act from the client it can verify that it was in response to the server's synack and since the",
    "start": "177440",
    "end": "184319"
  },
  {
    "text": "synack was sent to the source ip address in the syn packet the client is able to send and receive",
    "start": "184319",
    "end": "189360"
  },
  {
    "text": "packets at that address in the quick handshake we have similar",
    "start": "189360",
    "end": "194480"
  },
  {
    "text": "confirmation that the client is able to send and receive packets at its source ip address",
    "start": "194480",
    "end": "201760"
  },
  {
    "text": "the client can verify that the server's tls handshake messages are in response to the client's tls",
    "start": "201760",
    "end": "206799"
  },
  {
    "text": "client hello and the server can verify that the client's cls finished message is in",
    "start": "206799",
    "end": "212239"
  },
  {
    "text": "response to the same tls connection just like how the tcp synap message was",
    "start": "212239",
    "end": "217680"
  },
  {
    "text": "sent to the client's source ip address in quick the server's tls handshake messages were sent to the client's ip",
    "start": "217680",
    "end": "223840"
  },
  {
    "text": "address and getting the tls finished message proves that the client controls that ip address",
    "start": "223840",
    "end": "230959"
  },
  {
    "text": "in tcp the server's synack message is sent without knowing if the sender of the sim controls the source ip address",
    "start": "232560",
    "end": "239120"
  },
  {
    "text": "from the syn packet if the client spoofs the source ip address of its in packet it can get the",
    "start": "239120",
    "end": "244720"
  },
  {
    "text": "server to send a syn ack to another endpoint before the client's ip address is",
    "start": "244720",
    "end": "250959"
  },
  {
    "text": "validated a hypothetical protocol running on top of ip might allow a client to send a small",
    "start": "250959",
    "end": "256320"
  },
  {
    "text": "packet with a spoofed source ip address to a server that would result in a large packet",
    "start": "256320",
    "end": "261440"
  },
  {
    "text": "being sent by the server to the victim in an attempt to dos the victim",
    "start": "261440",
    "end": "266720"
  },
  {
    "text": "this attack is only useful if the server's packet is noticeably larger than the client's packet since otherwise the client could send",
    "start": "266720",
    "end": "273280"
  },
  {
    "text": "traffic directly to the victim in tcp this attack isn't a concern because the syn and synack packets",
    "start": "273280",
    "end": "280160"
  },
  {
    "text": "are both small and roughly the same size in quick both the client's initial",
    "start": "280160",
    "end": "286560"
  },
  {
    "text": "packet and the server's first flight of packets are much larger than a tcp syn or synap",
    "start": "286560",
    "end": "291600"
  },
  {
    "text": "packet to avoid this amplification attack quick imposes a limit on how much data",
    "start": "291600",
    "end": "297360"
  },
  {
    "text": "the server can send before the client's address has been validated",
    "start": "297360",
    "end": "302639"
  },
  {
    "text": "the server is limited to sending three times the amount of data that was in the client's packet the",
    "start": "302639",
    "end": "308639"
  },
  {
    "text": "client can expand its initial packet by adding padding to allow the server to have a larger",
    "start": "308639",
    "end": "314080"
  },
  {
    "text": "response however if the server needs to send more data in the handshake than fits under",
    "start": "314080",
    "end": "320000"
  },
  {
    "text": "the amplification attack limit the server can explicitly request address validation",
    "start": "320000",
    "end": "325680"
  },
  {
    "text": "at the cost of one round trip the server does this by sending a retry",
    "start": "325680",
    "end": "331600"
  },
  {
    "start": "328000",
    "end": "423000"
  },
  {
    "text": "packet which contains only an address validation token the client puts this token in the header",
    "start": "331600",
    "end": "338000"
  },
  {
    "text": "of its next initial packet and echoing it back to the server proves",
    "start": "338000",
    "end": "343039"
  },
  {
    "text": "the client controls its source ip address at this point since the address has been",
    "start": "343039",
    "end": "348639"
  },
  {
    "text": "validated there are no limits to the size of the server's tls handshake messages",
    "start": "348639",
    "end": "354720"
  },
  {
    "text": "this retry token can also be used to mitigate kwik's equivalent of a tcp syn flood upon receipt of a tls",
    "start": "356000",
    "end": "363280"
  },
  {
    "text": "client hello the server has to maintain state for the quick connection if an attacker floods the server with",
    "start": "363280",
    "end": "369280"
  },
  {
    "text": "client initial packets the server has to store state for each of these connections",
    "start": "369280",
    "end": "374880"
  },
  {
    "text": "at the cost of one round trip the server can defer the cost of creating this",
    "start": "374880",
    "end": "380080"
  },
  {
    "text": "state until after address validation it does this by sending a retry packet to the client",
    "start": "380080",
    "end": "386960"
  },
  {
    "text": "deferring the cost of creating state is done by encrypting all of the state the client's connection id its source ip",
    "start": "387440",
    "end": "394160"
  },
  {
    "text": "address and port and any other state the server might need in the retry token that way no state apart from the",
    "start": "394160",
    "end": "400000"
  },
  {
    "text": "encryption key for the retry token is needed on the server",
    "start": "400000",
    "end": "408720"
  },
  {
    "text": "in the tcp handshake sorry in the transport handshake in addition to confirming that the",
    "start": "408720",
    "end": "415680"
  },
  {
    "text": "client controls its source ip address additional transport connection",
    "start": "415680",
    "end": "421440"
  },
  {
    "text": "properties are established this includes flow control limits and other properties",
    "start": "421440",
    "end": "429759"
  },
  {
    "start": "423000",
    "end": "471000"
  },
  {
    "text": "in tcp these are advertised in the tcp header in quick these limits and other",
    "start": "429759",
    "end": "435280"
  },
  {
    "text": "connection properties are advertised in the transport parameters tls extension",
    "start": "435280",
    "end": "441360"
  },
  {
    "text": "unlike tcp where a network intermediary can alter the tcp header the transport parameters are",
    "start": "441360",
    "end": "447440"
  },
  {
    "text": "authenticated by the tls handshake and encrypted in the server-to-client direction",
    "start": "447440",
    "end": "453280"
  },
  {
    "text": "in either direction an attacker cannot tamper with the contents of the transport parameters without causing the tls handshake and",
    "start": "453280",
    "end": "459919"
  },
  {
    "text": "thus the quick connection to fail",
    "start": "459919",
    "end": "465840"
  },
  {
    "text": "now let's look in a little more detail how these packets appear on the wire quick packets",
    "start": "466160",
    "end": "473440"
  },
  {
    "start": "471000",
    "end": "530000"
  },
  {
    "text": "regardless of what version of quick have either a long header or a short header long header packets are used during",
    "start": "473440",
    "end": "480080"
  },
  {
    "text": "connection establishment and the short header packets are used once the handshake is complete",
    "start": "480080",
    "end": "486000"
  },
  {
    "text": "the first bit in the packet header indicates whether the header form which header form is in use a 1",
    "start": "486000",
    "end": "493120"
  },
  {
    "text": "indicates a long header and a 0 indicates a short header long headers include the connection ids",
    "start": "493120",
    "end": "499440"
  },
  {
    "text": "of both the sender and the receiver while short headers only include the receiver's connection id",
    "start": "499440",
    "end": "506639"
  },
  {
    "text": "for the rest of this talk i will be focusing on quick version one the packet formats for those versions",
    "start": "506639",
    "end": "512479"
  },
  {
    "text": "have a little more details than described on this slide this slide shows what is in",
    "start": "512479",
    "end": "517599"
  },
  {
    "text": "a quick packet header for any version of quick i've mentioned on this slide and in",
    "start": "517599",
    "end": "524320"
  },
  {
    "text": "previous slides quick connection ids so let's look at how those work in a little more detail",
    "start": "524320",
    "end": "531360"
  },
  {
    "start": "530000",
    "end": "691000"
  },
  {
    "text": "quick uses connection ids to identify a connection instead of using the five tuple of ip protocol source and destination ip",
    "start": "531519",
    "end": "539040"
  },
  {
    "text": "addresses and udp sort and destin source and destination ports",
    "start": "539040",
    "end": "544480"
  },
  {
    "text": "connection ids are variable length ranging from 0 to 20 bytes each endpoint chooses its own",
    "start": "544480",
    "end": "551279"
  },
  {
    "text": "connection ids and advertises those to its peer an endpoint can have multiple connection",
    "start": "551279",
    "end": "556399"
  },
  {
    "text": "ids for a single connection multiple connection ids are provided for a single",
    "start": "556399",
    "end": "561600"
  },
  {
    "text": "connection so that each network path used for a connection can use a different connection id",
    "start": "561600",
    "end": "577839"
  },
  {
    "text": "an endpoint needs to be able to route a packet based on its connection id to the correct quick connection and the",
    "start": "578959",
    "end": "585680"
  },
  {
    "text": "connection id should appear random to an external observer load balancers can use connection ids to",
    "start": "585680",
    "end": "592240"
  },
  {
    "text": "route packets to specific servers assuming that there is cooperation and coordination between the server fleet",
    "start": "592240",
    "end": "598000"
  },
  {
    "text": "and the load balancer sitting in front of that fleet cooperation is required because servers",
    "start": "598000",
    "end": "604160"
  },
  {
    "text": "issue connection ids and load balancers need to process enough of that connection id to route it back to the server",
    "start": "604160",
    "end": "610720"
  },
  {
    "text": "there is a draft in progress that describes multiple ways that load balancers and servers can cooperate",
    "start": "610720",
    "end": "616560"
  },
  {
    "text": "the suggested way at a high level is that the servers and the load balancer share a",
    "start": "616560",
    "end": "621920"
  },
  {
    "text": "key and encrypt a connection id the plain text of that would contain",
    "start": "621920",
    "end": "627279"
  },
  {
    "text": "a server id and a section for to identify that connection on the server and then the encrypted connection",
    "start": "627279",
    "end": "634399"
  },
  {
    "text": "id is put on the wire if connection ids do not appear random",
    "start": "634399",
    "end": "640399"
  },
  {
    "text": "to an external observer there are two possible attacks the first attack is the privacy leakage",
    "start": "640399",
    "end": "646720"
  },
  {
    "text": "if an observer can tell whether two connection ids belong to the same connection",
    "start": "646720",
    "end": "651760"
  },
  {
    "text": "it can look at traffic flows on different five tuples and correlate connections uh as being",
    "start": "651760",
    "end": "658000"
  },
  {
    "text": "the same connection the second attack involves load balancers",
    "start": "658000",
    "end": "663519"
  },
  {
    "text": "if an attacker can generate many connection ids that the load balancer will map to the same server the attacker can",
    "start": "663519",
    "end": "670480"
  },
  {
    "text": "bypass the load balancer to mount a denial of service attack on the specific server behind the load balancer",
    "start": "670480",
    "end": "678560"
  },
  {
    "text": "now that we've looked at the transport handshake and connection ids let's look at how the crypto transport",
    "start": "681360",
    "end": "686800"
  },
  {
    "text": "let's look at how the crypto handshake works in quick",
    "start": "686800",
    "end": "691279"
  },
  {
    "start": "691000",
    "end": "852000"
  },
  {
    "text": "so to start off the crypto handshake in quick is the tls 1.3 handshake",
    "start": "694560",
    "end": "703839"
  },
  {
    "text": "when run over tcp tls provides a record layer which handles multiplexing handshake and application data on the",
    "start": "704560",
    "end": "710639"
  },
  {
    "text": "same connection this record layer also handles encrypting the data sent on the connection",
    "start": "710639",
    "end": "716880"
  },
  {
    "text": "tls assumes that it is run on an inorder reliable byte stream in quick the tls record layer isn't used",
    "start": "716880",
    "end": "723519"
  },
  {
    "text": "instead quick has its own record layer to handle encrypting packets",
    "start": "723519",
    "end": "728800"
  },
  {
    "text": "the tls handshake still depends on its handshake messages being delivered in order and reliably",
    "start": "728800",
    "end": "735600"
  },
  {
    "text": "the use of tls 1.3 in quick its handshake relies on quick transport",
    "start": "735920",
    "end": "741920"
  },
  {
    "text": "features handling reordering and re-transmission of packets containing the crypto handshake",
    "start": "741920",
    "end": "748160"
  },
  {
    "text": "so on this slide we see that the tls handshake messages are in quick crypto frames and if a packet gets",
    "start": "748160",
    "end": "755360"
  },
  {
    "text": "lost quick will retransmit that crypto frame in a future packet",
    "start": "755360",
    "end": "760560"
  },
  {
    "text": "the crypto handshake in addition to establishing crypto parameters for the connection and keys to use uh also carries the",
    "start": "760560",
    "end": "768399"
  },
  {
    "text": "transport parameters for the connection as i mentioned earlier",
    "start": "768399",
    "end": "773600"
  },
  {
    "text": "the crypto handshake also contains the alpn for the connection the application",
    "start": "773600",
    "end": "779600"
  },
  {
    "text": "layer protocol negotiation tag so this would be for example http 3.",
    "start": "779600",
    "end": "787839"
  },
  {
    "text": "so tls provides keys too quick to use for record layer encryption but quick handles that record layer",
    "start": "790000",
    "end": "796000"
  },
  {
    "text": "encryption itself the encryption key is used for a quick packet are determined by the type of",
    "start": "796000",
    "end": "801440"
  },
  {
    "text": "packet handshake packets in quick use handshake keys from tls zero rtt quick packets use zero rtt keys",
    "start": "801440",
    "end": "809279"
  },
  {
    "text": "from tls and short header packets in quick use application data keys from tls",
    "start": "809279",
    "end": "815360"
  },
  {
    "text": "the application data keys used to protect short header packets provide forward secrecy",
    "start": "815360",
    "end": "822480"
  },
  {
    "text": "the tls 1.3 key schedule drives traffic secrets for each encryption level",
    "start": "823600",
    "end": "828800"
  },
  {
    "text": "which maps to a quick packet type a single traffic secret at each encryption level is used to",
    "start": "828800",
    "end": "834959"
  },
  {
    "text": "derive multiple secrets including encryption keys and ivs for both sending and receiving",
    "start": "834959",
    "end": "840880"
  },
  {
    "text": "by each endpoint let's look in a little more detail how",
    "start": "840880",
    "end": "847920"
  },
  {
    "text": "quick record protection or record layer encryption works for quick v1",
    "start": "847920",
    "end": "857839"
  },
  {
    "text": "in quick every packet is encrypted using an aed mode of encryption and",
    "start": "862720",
    "end": "870079"
  },
  {
    "text": "every packet in quick has a packet header which contains a packet number and a payload",
    "start": "870079",
    "end": "875839"
  },
  {
    "text": "let's look at how these elements of a quick packet map to the inputs of the aad encryption",
    "start": "875839",
    "end": "882839"
  },
  {
    "text": "function the aead encryption function takes four inputs",
    "start": "882839",
    "end": "888560"
  },
  {
    "text": "k the key n a nonce p the plain text and a associated data",
    "start": "888560",
    "end": "897199"
  },
  {
    "text": "and outputs a ciphertext c when encrypting a packet at some",
    "start": "897199",
    "end": "903120"
  },
  {
    "text": "encryption level we have a key and an iv that are derived for that encryption level",
    "start": "903120",
    "end": "908959"
  },
  {
    "text": "we use that key as the key k for the aad operation the nonce is derived from the iv and the",
    "start": "908959",
    "end": "917040"
  },
  {
    "text": "packet number for the packet being encrypted the plain text is the payload of the",
    "start": "917040",
    "end": "922160"
  },
  {
    "text": "packet and the associated data is the packet header the ciphertext output c is then",
    "start": "922160",
    "end": "929600"
  },
  {
    "text": "transmitted on the wire in place of the plaintext p this provides confidentiality and",
    "start": "929600",
    "end": "936240"
  },
  {
    "text": "integrity for the packet payload it also provides integrity for the entire packet since the",
    "start": "936240",
    "end": "942320"
  },
  {
    "text": "header is used as the associated data because of this integrity guarantee",
    "start": "942320",
    "end": "948079"
  },
  {
    "text": "quick packets cannot have their headers modified by network intermediaries unlike tcp packets where headers are",
    "start": "948079",
    "end": "953680"
  },
  {
    "text": "often processed and modified by intermediaries in the example on this slide we see the",
    "start": "953680",
    "end": "960480"
  },
  {
    "text": "start of a packet on the first line the first byte colored in red is",
    "start": "960480",
    "end": "966079"
  },
  {
    "text": "identifies whether the packet is a long or short header and a few of the bits in there are used for additional purposes next",
    "start": "966079",
    "end": "973040"
  },
  {
    "text": "this packet header has a connection id highlighted in yellow the length of the connection id",
    "start": "973040",
    "end": "978560"
  },
  {
    "text": "is known by the receiver ahead of time finally the packet header contains a",
    "start": "978560",
    "end": "984959"
  },
  {
    "text": "packet number in this case the packet number is one byte long some of the lower bits",
    "start": "984959",
    "end": "990720"
  },
  {
    "text": "in the first byte of the packet header indicate the length of the packet number and then",
    "start": "990720",
    "end": "997360"
  },
  {
    "text": "finally we have the plain text for the packet the second line shows how the plain text",
    "start": "997360",
    "end": "1004959"
  },
  {
    "text": "of the packet payload is replaced by the ciphertext that was output from the aad function",
    "start": "1004959",
    "end": "1011839"
  },
  {
    "text": "after this encryption has been done there is an additional step done to encrypt the packet number in the",
    "start": "1012240",
    "end": "1019199"
  },
  {
    "text": "header and some of the bits in the first byte of the packet header",
    "start": "1019199",
    "end": "1026798"
  },
  {
    "text": "during the key derivations step where we got the key and iv to use there is a third secret that was derived",
    "start": "1026959",
    "end": "1032720"
  },
  {
    "text": "which is the header protection key this header protection key is used to",
    "start": "1032720",
    "end": "1038319"
  },
  {
    "text": "perform a single encryption operation it takes as input 16 bytes that are",
    "start": "1038319",
    "end": "1043360"
  },
  {
    "text": "sampled from the encrypted ciphertext of the packet and outputs a mask this mask is shown on the third line of",
    "start": "1043360",
    "end": "1049919"
  },
  {
    "text": "this example and the mask is xored with certain bits of the packet header",
    "start": "1049919",
    "end": "1055200"
  },
  {
    "text": "to result in the encrypted packet header we can see in this example",
    "start": "1055200",
    "end": "1060400"
  },
  {
    "text": "that the last five bits of the first byte are of the mask are xored with the",
    "start": "1060400",
    "end": "1067760"
  },
  {
    "text": "first byte of the packet header this obscures the length of the packet number in the header",
    "start": "1067760",
    "end": "1075600"
  },
  {
    "text": "and then the rest of the mask is used to x4 with the packet number to encrypt the",
    "start": "1075600",
    "end": "1081679"
  },
  {
    "text": "packet number the final line on this slide shows what",
    "start": "1081679",
    "end": "1087919"
  },
  {
    "text": "the packet that actually gets sent on the wire looks like after the encryption and header",
    "start": "1087919",
    "end": "1093520"
  },
  {
    "text": "protection are applied to decrypt a quick packet these",
    "start": "1093520",
    "end": "1100080"
  },
  {
    "text": "operations are applied in reverse first the header protection mask is",
    "start": "1100080",
    "end": "1105520"
  },
  {
    "text": "computed and then xord with the same bit pattern to decrypt the header then",
    "start": "1105520",
    "end": "1113120"
  },
  {
    "text": "once the packet number is decrypted well the receiver can know the knots to use",
    "start": "1113120",
    "end": "1120160"
  },
  {
    "text": "and can run the aead open function to get the plain text or the aad decrypt",
    "start": "1120160",
    "end": "1128080"
  },
  {
    "text": "operation could fail if an endpoint receives a packet that",
    "start": "1128080",
    "end": "1133280"
  },
  {
    "text": "fails to decrypt the packet is discarded this prevents an attacker from being able to inject packets into a quick",
    "start": "1133280",
    "end": "1139600"
  },
  {
    "text": "connection when short header packets are used the",
    "start": "1139600",
    "end": "1145120"
  },
  {
    "text": "only parts of the packet header that are in the clear are the three bits at the beginning of",
    "start": "1145120",
    "end": "1150320"
  },
  {
    "text": "the packet and the connection id everything else is encrypted",
    "start": "1150320",
    "end": "1155600"
  },
  {
    "text": "this example has a short packet header so the three bits in the first byte of the packet header",
    "start": "1155600",
    "end": "1161760"
  },
  {
    "text": "are in the clear the connection id is in the clear but everything else in the packet is encrypted",
    "start": "1161760",
    "end": "1169120"
  },
  {
    "text": "when using quix record layer encryption there are a few considerations regarding multiple encryption levels",
    "start": "1171679",
    "end": "1178480"
  },
  {
    "text": "the first is that initial packets are protected with obfuscation keys these are derived from the connection id",
    "start": "1178480",
    "end": "1185840"
  },
  {
    "text": "and the quick version which means that anyone can derive",
    "start": "1185840",
    "end": "1190880"
  },
  {
    "text": "these keys once initial encryption keys aren't needed these keys should be discarded to",
    "start": "1190880",
    "end": "1197520"
  },
  {
    "text": "prevent an attacker from injecting packets at the encryption initial at the initial encryption level",
    "start": "1197520",
    "end": "1204799"
  },
  {
    "text": "also each type of frame in quick can only be sent and received at certain encryption levels",
    "start": "1205679",
    "end": "1211600"
  },
  {
    "text": "for example most frames that are sent in zero rtt packets can't be sent in handshake packets in particular if a",
    "start": "1211600",
    "end": "1218240"
  },
  {
    "text": "client mistakenly sends a stream frame and a handshake packet there could be a loss of confidentiality",
    "start": "1218240",
    "end": "1224240"
  },
  {
    "text": "if the client is not able to authenticate the server so endpoints should make sure that they",
    "start": "1224240",
    "end": "1230240"
  },
  {
    "text": "only send frames at the correct encryption levels in addition to ensuring that frames are",
    "start": "1230240",
    "end": "1236159"
  },
  {
    "text": "written at the correct encryption levels implementations should also check that incoming frames it reads were sent at",
    "start": "1236159",
    "end": "1241760"
  },
  {
    "text": "the correct encryption levels for example a server should not accept an initial packet that contains a stream",
    "start": "1241760",
    "end": "1248159"
  },
  {
    "text": "frame",
    "start": "1248159",
    "end": "1250480"
  },
  {
    "text": "now that we understand how the transport and crypto handshakes work in quick and how quick encrypts",
    "start": "1253840",
    "end": "1259120"
  },
  {
    "text": "data let's take a look at some of the other details of the quick transport",
    "start": "1259120",
    "end": "1277840"
  },
  {
    "text": "the payload of a quick packet is made up of a series of frames a quick frame starts with an indicator",
    "start": "1279039",
    "end": "1284880"
  },
  {
    "text": "of what type of frame it is but otherwise frames are not self-describing we've already seen examples of two types",
    "start": "1284880",
    "end": "1291520"
  },
  {
    "text": "of frames on previous slides crypto frames and ack frames and i've also mentioned",
    "start": "1291520",
    "end": "1297039"
  },
  {
    "text": "stream frames so application data in quick is carried",
    "start": "1297039",
    "end": "1304080"
  },
  {
    "text": "in stream frames a stream is lightweight abstraction for a reliable in-order byte stream",
    "start": "1304080",
    "end": "1310159"
  },
  {
    "text": "and it is identified by a stream id which is a 62-bit integer that is unique across all streams on",
    "start": "1310159",
    "end": "1316320"
  },
  {
    "text": "that particular connection one of the responsibilities of a",
    "start": "1316320",
    "end": "1322080"
  },
  {
    "text": "transport protocol like quick is managing flow control kwik has an overall flow control limit for a",
    "start": "1322080",
    "end": "1328559"
  },
  {
    "text": "connection it also has flow control per stream and flow control for the number of streams",
    "start": "1328559",
    "end": "1333760"
  },
  {
    "text": "that can be open at a time these limits are initially set in transport parameters",
    "start": "1333760",
    "end": "1339039"
  },
  {
    "text": "during the connection they are updated via max data max stream data and max streams frames unlike tcp",
    "start": "1339039",
    "end": "1346960"
  },
  {
    "text": "where flow control is in the clear in the tcp header these frames are all part of the packet payload and thus they are encrypted",
    "start": "1346960",
    "end": "1353679"
  },
  {
    "text": "and not visible on the network receipt of quick packets is acknowledged",
    "start": "1353679",
    "end": "1360240"
  },
  {
    "text": "in ack frames which again is information protected in the packet payload instead of in clear text like in tcp",
    "start": "1360240",
    "end": "1368320"
  },
  {
    "text": "when data is lost and re-transmitted in quick it is re-transmitted in new packets",
    "start": "1368559",
    "end": "1373600"
  },
  {
    "text": "unlike tcp packet numbers or sequence numbers are not reused",
    "start": "1373600",
    "end": "1379760"
  },
  {
    "text": "when a quick connection starts using a new network path the new network path must be validated before use",
    "start": "1380000",
    "end": "1386080"
  },
  {
    "text": "an endpoint does this by sending a path challenge frame and then waiting for a path response",
    "start": "1386080",
    "end": "1391200"
  },
  {
    "text": "frame i'll now talk about some implementation",
    "start": "1391200",
    "end": "1397360"
  },
  {
    "start": "1394000",
    "end": "1524000"
  },
  {
    "text": "considerations that could have security impacts the first one regards flow control if an",
    "start": "1397360",
    "end": "1403600"
  },
  {
    "text": "endpoint advertises flow control limits but never enforces them from the peer then the peer could flood the endpoint",
    "start": "1403600",
    "end": "1410000"
  },
  {
    "text": "with data leading to resource exhaustion if an endpoint does not do path",
    "start": "1410000",
    "end": "1416240"
  },
  {
    "text": "validation before using a new path then its peer could cause that endpoint to flood a victim",
    "start": "1416240",
    "end": "1422080"
  },
  {
    "text": "with traffic for http 2 there is a cve cve 2019-9517",
    "start": "1422080",
    "end": "1431279"
  },
  {
    "text": "which was a bug in implementations and deployments where a malicious endpoint could",
    "start": "1431279",
    "end": "1436480"
  },
  {
    "text": "advertise a large flow control window at the http 2 layer but at the tcp layer it would close the",
    "start": "1436480",
    "end": "1442400"
  },
  {
    "text": "flow control window this would result in the victim thinking at the http 2 layer they can send a",
    "start": "1442400",
    "end": "1447919"
  },
  {
    "text": "large amount of data but at the tcp layer it can't and then a large amount of data would be buffered",
    "start": "1447919",
    "end": "1453520"
  },
  {
    "text": "in the http 2 layer in http 3 both the per stream and per connection",
    "start": "1453520",
    "end": "1459840"
  },
  {
    "text": "flow control happens in the same context in the quick layer so a quick implementation can simply apply",
    "start": "1459840",
    "end": "1467520"
  },
  {
    "text": "the minimum of the two flow control limits for the per connection flow control limit and the per stream flow control limit and thus avoid",
    "start": "1467520",
    "end": "1474240"
  },
  {
    "text": "the extra data buffering where it thinks it can send more data than it actually can",
    "start": "1474240",
    "end": "1480080"
  },
  {
    "text": "when this cve was reported there were multiple other cves reported affecting http 2.",
    "start": "1481840",
    "end": "1487120"
  },
  {
    "text": "the key takeaway from all of these cves is that an endpoint's peer shouldn't be able to cause the endpoint",
    "start": "1487120",
    "end": "1493039"
  },
  {
    "text": "to use unbounded memory many of the mitigations for those other issues apply to quick",
    "start": "1493039",
    "end": "1498720"
  },
  {
    "text": "as well",
    "start": "1498720",
    "end": "1501840"
  },
  {
    "text": "so far when examining how a quick connection gets established we've looked at fresh connections now",
    "start": "1504799",
    "end": "1510400"
  },
  {
    "text": "let's look at how quick handles resuming connections including one of quick's biggest",
    "start": "1510400",
    "end": "1515520"
  },
  {
    "text": "features which is how it allows a client to establish a connection with zero round trip time",
    "start": "1515520",
    "end": "1521600"
  },
  {
    "text": "or zero rtt",
    "start": "1521600",
    "end": "1524799"
  },
  {
    "start": "1524000",
    "end": "1639000"
  },
  {
    "text": "on a fresh connection a quick server has the option of waiting an additional round trip to validate the client's source ip",
    "start": "1527600",
    "end": "1534400"
  },
  {
    "text": "address before continuing the handshake it does this by sending an address validation token in a retry packet",
    "start": "1534400",
    "end": "1542000"
  },
  {
    "text": "a server can also send an address validation token to a client in a new token frame this token can be",
    "start": "1542000",
    "end": "1547919"
  },
  {
    "text": "used by the client on a future connection to prove that it controls its source ip address",
    "start": "1547919",
    "end": "1554159"
  },
  {
    "text": "you can think of this as being very similar to a tcp fast open cookie which allows zero rtt a tcp connection",
    "start": "1554159",
    "end": "1561440"
  },
  {
    "text": "establishment when a server generates address",
    "start": "1561440",
    "end": "1566559"
  },
  {
    "text": "validation tokens whether they are in a new token frame or in a retry packet the server must",
    "start": "1566559",
    "end": "1571840"
  },
  {
    "text": "ensure that an attacker cannot forge these tokens if an attacker can forge an address",
    "start": "1571840",
    "end": "1577919"
  },
  {
    "text": "validation token the server is vulnerable to participating in an amplification attack",
    "start": "1577919",
    "end": "1584559"
  },
  {
    "text": "an endpoint could receive an unbounded number of new token frames from its pier it should limit how many",
    "start": "1584559",
    "end": "1590240"
  },
  {
    "text": "tokens it stores and if it receives more tokens than it has room for it should discard old ones",
    "start": "1590240",
    "end": "1596400"
  },
  {
    "text": "to avoid storing an unbounded number of tokens",
    "start": "1596400",
    "end": "1600799"
  },
  {
    "text": "the other aspect of being able to establish a zero rtt quick connection involves the tls handshake",
    "start": "1602960",
    "end": "1609279"
  },
  {
    "text": "tls 1.3 has a zero rtt resumption feature which quick also uses this works by having the",
    "start": "1609279",
    "end": "1615520"
  },
  {
    "text": "server send a new session ticket to the client after the tls handshake completes and the client uses that new",
    "start": "1615520",
    "end": "1621600"
  },
  {
    "text": "session ticket to perform zero rtt resumption on a future connection",
    "start": "1621600",
    "end": "1627200"
  },
  {
    "text": "effectively the way this works is that both parties remember a shared secret from one connection and use that secret to derive keys that",
    "start": "1627200",
    "end": "1634320"
  },
  {
    "text": "the client can use to send zero rtt data on a new connection",
    "start": "1634320",
    "end": "1639679"
  },
  {
    "start": "1639000",
    "end": "1993000"
  },
  {
    "text": "let's look at the start of a zero rtt handshake this diagram shows what the packet flow",
    "start": "1639840",
    "end": "1646880"
  },
  {
    "text": "for a zero rtt connection looks like the client includes a retry token t in",
    "start": "1646880",
    "end": "1651919"
  },
  {
    "text": "its initial packet for the server to use for address validation the client receives this token on a",
    "start": "1651919",
    "end": "1657279"
  },
  {
    "text": "previous connection and is assuming that it has the same source ip address from that previous connection",
    "start": "1657279",
    "end": "1663520"
  },
  {
    "text": "if the server notices that the client is on a different source ip address the server can discard that token and either",
    "start": "1663520",
    "end": "1670159"
  },
  {
    "text": "perform address validation or assume that the address is not validated and handled this like it would in a 1rtt connection with",
    "start": "1670159",
    "end": "1677520"
  },
  {
    "text": "amplification attack limits in this initial packet the client sends",
    "start": "1677520",
    "end": "1682880"
  },
  {
    "text": "a tls client hello to resume a tls connection it includes the early data tls extension",
    "start": "1682880",
    "end": "1688640"
  },
  {
    "text": "which indicates that the client will be sending zero rtt data the client",
    "start": "1688640",
    "end": "1695440"
  },
  {
    "text": "can then send zero rtt quick packets containing stream frames with application data and these packets are encrypted using",
    "start": "1695440",
    "end": "1701760"
  },
  {
    "text": "the zero rtt keys derived from tls these keys are known only",
    "start": "1701760",
    "end": "1707039"
  },
  {
    "text": "to the client and the server there are two caveats to be aware of",
    "start": "1707039",
    "end": "1712799"
  },
  {
    "text": "when using zero rtt data the first is that data sent under zero rtt keys",
    "start": "1712799",
    "end": "1718399"
  },
  {
    "text": "is not forward secret the endpoints must wait until the handshake",
    "start": "1718399",
    "end": "1723440"
  },
  {
    "text": "is complete to be able to send data with forward secrecy",
    "start": "1723440",
    "end": "1728960"
  },
  {
    "text": "a separate issue is that zero rtt data can be replayed by an attacker as if it were the beginning of a new",
    "start": "1729039",
    "end": "1736840"
  },
  {
    "text": "connection example a zero rtt packet from a client might contain an",
    "start": "1736840",
    "end": "1744240"
  },
  {
    "text": "http request an attacker can observe these initial packets and then send them to the server",
    "start": "1744240",
    "end": "1749760"
  },
  {
    "text": "a second time the server at this point has no way of knowing did those packets come from a live client",
    "start": "1749760",
    "end": "1755279"
  },
  {
    "text": "or did those come from an attacker who has replayed them whatever processing that the server does",
    "start": "1755279",
    "end": "1762000"
  },
  {
    "text": "with the data in the zero rtt packet it needs to be aware that it might receive it multiple times for",
    "start": "1762000",
    "end": "1769200"
  },
  {
    "text": "example in http it is recommended that only safe http methods like get head or options are used in",
    "start": "1769200",
    "end": "1776159"
  },
  {
    "text": "zero rtd data ultimately it is up to the protocol and the server to decide what data in zero",
    "start": "1776159",
    "end": "1783600"
  },
  {
    "text": "rtt is acceptable and what data it will wait until the handshake is confirmed to process the caveats here that i've",
    "start": "1783600",
    "end": "1792559"
  },
  {
    "text": "described for using zero rtt data in quick are the same ones for using zero rtt data in tls 1.3",
    "start": "1792559",
    "end": "1799760"
  },
  {
    "text": "over tcp",
    "start": "1799760",
    "end": "1809840"
  },
  {
    "text": "so we have now looked at how quick connections get established how they can be resumed and do some of",
    "start": "1814000",
    "end": "1819679"
  },
  {
    "text": "what happens when a quick connection is running now let's talk about how a connection is terminated",
    "start": "1819679",
    "end": "1825679"
  },
  {
    "text": "and how an attacker might use those mechanisms to close a connection it does not control",
    "start": "1825679",
    "end": "1837840"
  },
  {
    "text": "the easiest way to close a quick connection is by sending a connection close frame to terminate",
    "start": "1838640",
    "end": "1844320"
  },
  {
    "text": "the connection immediately remember that since quick frames are part of the protected payload an",
    "start": "1844320",
    "end": "1850080"
  },
  {
    "text": "on-path attacker can't inject a connection close on a connection when the handshake has been confirmed",
    "start": "1850080",
    "end": "1856159"
  },
  {
    "text": "an attacker can only inject connection closed frames if the endpoint is still receiving initial",
    "start": "1856159",
    "end": "1861440"
  },
  {
    "text": "packets a connection can also be closed by idle timeout",
    "start": "1861440",
    "end": "1866720"
  },
  {
    "text": "if an endpoint receives no new packets after a determined amount of time it silently closes the connection and",
    "start": "1866720",
    "end": "1872480"
  },
  {
    "text": "discards its connection state an onpath network attacker could drop",
    "start": "1872480",
    "end": "1877919"
  },
  {
    "text": "all packets for a connection there is nothing the transport protocol can do to mitigate this type of connection close",
    "start": "1877919",
    "end": "1884000"
  },
  {
    "text": "besides moving the connection to a different path",
    "start": "1884000",
    "end": "1888799"
  },
  {
    "text": "the last way a connection can be closed is via stateless reset if an endpoint loses connection state",
    "start": "1889600",
    "end": "1896159"
  },
  {
    "text": "for example because the endpoint just restarted it may still be receiving packets for a connection to previously established",
    "start": "1896159",
    "end": "1902960"
  },
  {
    "text": "since the endpoint no longer has the encryption keys for that connection it wants some way to signal to its peer",
    "start": "1902960",
    "end": "1908559"
  },
  {
    "text": "that the connection is closed this is to save time waiting for the connection to timeout",
    "start": "1908559",
    "end": "1914320"
  },
  {
    "text": "and to save bandwidth and processing while the pier is flooding this endpoint with packets",
    "start": "1914320",
    "end": "1921840"
  },
  {
    "text": "the endpoint can signal this connection close with a stateless reset packet earlier in the connection when the",
    "start": "1925279",
    "end": "1932080"
  },
  {
    "text": "endpoint provided its peer with its connection id the endpoint also provided a stateless reset token",
    "start": "1932080",
    "end": "1938320"
  },
  {
    "text": "if the peer sees that stateless reset token in the future it knows that the endpoint is closing",
    "start": "1938320",
    "end": "1943760"
  },
  {
    "text": "the connection an endpoint constructs the stateless reset token by using some global",
    "start": "1943760",
    "end": "1950159"
  },
  {
    "text": "not per connection state so that it can deterministically derive the token from the connection id of the",
    "start": "1950159",
    "end": "1955919"
  },
  {
    "text": "incoming packet for example this can be done by using a secret key on the server that persists through this",
    "start": "1955919",
    "end": "1962640"
  },
  {
    "text": "restart and then computing an hmac or an hkdf of the connection id of the incoming",
    "start": "1962640",
    "end": "1968080"
  },
  {
    "text": "packet it is important that whatever mechanism is used here",
    "start": "1968080",
    "end": "1973120"
  },
  {
    "text": "keeps this key secret because if an attacker gets a hold of that secret it can",
    "start": "1973120",
    "end": "1979120"
  },
  {
    "text": "compute stateless reset tokens for any connection and inject those and close connections it's not a part of",
    "start": "1979120",
    "end": "1986480"
  },
  {
    "text": "this concludes our exploration of the http 3 protocol stack and its security features",
    "start": "1987440",
    "end": "1994080"
  },
  {
    "start": "1993000",
    "end": "2036000"
  },
  {
    "text": "in summary the http 3 protocol stack has the same security features and properties as the http 2 protocol stack",
    "start": "1994159",
    "end": "2002799"
  },
  {
    "text": "most of the functionality has been moved into the quick protocol http 3's use of quick provides improved",
    "start": "2002799",
    "end": "2009840"
  },
  {
    "text": "performance compared to http 2. kwik's use of encryption and authentication prevents the network from",
    "start": "2009840",
    "end": "2016000"
  },
  {
    "text": "modifying transport connection properties this encryption and authentication also",
    "start": "2016000",
    "end": "2021440"
  },
  {
    "text": "improves privacy compared to tcp by making the connection id the only unencrypted part of the packet",
    "start": "2021440",
    "end": "2027279"
  },
  {
    "text": "this also benefits future protocol development thank you for watching my talk and i",
    "start": "2027279",
    "end": "2032960"
  },
  {
    "text": "will take any questions now",
    "start": "2032960",
    "end": "2038720"
  }
]