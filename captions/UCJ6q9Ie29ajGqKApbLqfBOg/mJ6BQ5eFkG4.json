[
  {
    "text": "[Applause] hello everyone thank you for coming um",
    "start": "780",
    "end": "6000"
  },
  {
    "text": "so I'm going to uh talk about Jason web tokens and new ways to attack them uh my",
    "start": "6000",
    "end": "11840"
  },
  {
    "text": "name is stter fors I work as a security specialist for Secura uh a subsidiary of",
    "start": "11840",
    "end": "17320"
  },
  {
    "text": "Bureau fitas in the Netherlands um I work as a pentester um",
    "start": "17320",
    "end": "24160"
  },
  {
    "text": "do consultancy work and a lot of vulnerability research as well uh mostly specializing when it comes to",
    "start": "24160",
    "end": "30199"
  },
  {
    "text": "vulnerability research in uh cryptography topics and PR practical attacks uh against cryptographic",
    "start": "30199",
    "end": "37800"
  },
  {
    "text": "implementations um I've been on blackhe hats uh before talking about the uh zero logon",
    "start": "37800",
    "end": "43320"
  },
  {
    "text": "vulnerability uh which is um what really got me into uh vulnerability research",
    "start": "43320",
    "end": "49160"
  },
  {
    "text": "because of the high impact uh that one had and now I'm going to talk about um",
    "start": "49160",
    "end": "55160"
  },
  {
    "text": "my research uh on Json web token implementations so first I'm going to give give a bit of a general uh",
    "start": "55160",
    "end": "61239"
  },
  {
    "text": "backgrounds on uh jwt's and what kind of problem they're trying to solve and some",
    "start": "61239",
    "end": "66439"
  },
  {
    "text": "of the earlier uh vulnerabilities uh I will then introduce my three new attacks and end with some",
    "start": "66439",
    "end": "72280"
  },
  {
    "text": "general conclusions and takeaways So backgrounds um you're probably familiar",
    "start": "72280",
    "end": "78799"
  },
  {
    "text": "with the concept of a session identifier you want to um use a web application you",
    "start": "78799",
    "end": "84360"
  },
  {
    "text": "authenticate and after you've given your credentials the uh application needs to remember who you are they are not going",
    "start": "84360",
    "end": "90600"
  },
  {
    "text": "to ask you for your password every single time uh so you're assigned a um a random token uh just a random uh string",
    "start": "90600",
    "end": "98240"
  },
  {
    "text": "that's stored in your browser and every subsequent uh request as long as your session remains valid um the application",
    "start": "98240",
    "end": "105119"
  },
  {
    "text": "looks at the token uses it as a key to do a database lookup uh to get your identity information your authorization",
    "start": "105119",
    "end": "112439"
  },
  {
    "text": "information to be able to decide if you're authorized to make this request or",
    "start": "112439",
    "end": "117600"
  },
  {
    "text": "not um this uh a similar system is also used uh for single sign on when you have",
    "start": "117600",
    "end": "125360"
  },
  {
    "text": "an ident uh when authentication is outsourced to an identity provider um",
    "start": "125360",
    "end": "130879"
  },
  {
    "text": "that verifies your credentials and then gives you access to multiple applications running on different",
    "start": "130879",
    "end": "135959"
  },
  {
    "text": "servers um the identity provider can assign you a token as well and then this token through the browser through",
    "start": "135959",
    "end": "142480"
  },
  {
    "text": "redirects is passed on to these other applications the back end of an application uh consults the uh uh",
    "start": "142480",
    "end": "148760"
  },
  {
    "text": "database of the identity provider to get back uh information about your identity",
    "start": "148760",
    "end": "154120"
  },
  {
    "text": "uh likewise uh when this is not just used to uh provide information about um",
    "start": "154120",
    "end": "160360"
  },
  {
    "text": "who has authenticated but also uh on the type of action you want to perform so if you want to make an online payment for",
    "start": "160360",
    "end": "166319"
  },
  {
    "text": "example a similar mechanism can be used to transfer information about this payment so the uh web shop um gives you",
    "start": "166319",
    "end": "175000"
  },
  {
    "text": "a a token of you want to uh make a certain transaction um that token is",
    "start": "175000",
    "end": "180879"
  },
  {
    "text": "then submitted through the browser to a banking websites and the bank can then look up what kind of transaction you're",
    "start": "180879",
    "end": "186680"
  },
  {
    "text": "trying to make and so on and the traditional approach with tokens and",
    "start": "186680",
    "end": "191959"
  },
  {
    "text": "databases um is still commonly used but there's also an uh increasingly popular",
    "start": "191959",
    "end": "198840"
  },
  {
    "text": "alternative and that's to do away with a central database storing your identity uh claim information and instead storing",
    "start": "198840",
    "end": "206200"
  },
  {
    "text": "all of this on the client s uh and then every time um you interact with a new server uh you",
    "start": "206200",
    "end": "213120"
  },
  {
    "text": "just uh forward all this identity information to this server uh of course",
    "start": "213120",
    "end": "219200"
  },
  {
    "text": "you don't want people to actually temper with these claims about their identity and their authorizations uh so you use",
    "start": "219200",
    "end": "225519"
  },
  {
    "text": "cryptography to uh make it temper proof so uh at any time you would make some",
    "start": "225519",
    "end": "231799"
  },
  {
    "text": "kind of uh change uh it will be detected on the server s and this um the the",
    "start": "231799",
    "end": "239040"
  },
  {
    "text": "server only only knows a cryptographic key that is needed to be able to issue these kinds of cryptographically",
    "start": "239040",
    "end": "245159"
  },
  {
    "text": "protected claims uh preventing end users from uh for example elevating privileges",
    "start": "245159",
    "end": "251480"
  },
  {
    "text": "uh or bypassing authentication measures by just coming up with their own tokens and pretending like they're an",
    "start": "251480",
    "end": "256759"
  },
  {
    "text": "administrator or that they have access to something where they should not have access so when you compare the two",
    "start": "256759",
    "end": "264240"
  },
  {
    "text": "approaches um the cryptographic approach has very clear performance and scalability benefit",
    "start": "264240",
    "end": "270520"
  },
  {
    "text": "uh you do not need to make a centralized database lookup for every single request uh you just need to do some uh uh",
    "start": "270520",
    "end": "276680"
  },
  {
    "text": "cryptographic validation which you can easily do locally uh it's very easy to just spread the right Keys around on",
    "start": "276680",
    "end": "282160"
  },
  {
    "text": "every one that needs to do some validation um and you can immediately determine um uh the identity claims that",
    "start": "282160",
    "end": "289720"
  },
  {
    "text": "you need to uh make your authorization decisions and especially when you're uh",
    "start": "289720",
    "end": "295120"
  },
  {
    "text": "have a application operating at a higher scale uh with many uh load balanced over",
    "start": "295120",
    "end": "300680"
  },
  {
    "text": "many different Serv servers this is a big Advantage but there are also downsides",
    "start": "300680",
    "end": "306639"
  },
  {
    "text": "uh whenever all the ident the identity claims are stored in a central database it's very easy to change them you make a",
    "start": "306639",
    "end": "312440"
  },
  {
    "text": "change to them and the changes are applied immediately however if you give out a cryptographic token um you've",
    "start": "312440",
    "end": "319520"
  },
  {
    "text": "given it out you can no longer make any changes uh because now the user is storing it and they can just maintain",
    "start": "319520",
    "end": "325880"
  },
  {
    "text": "this token and even if technically something about their authorization changes let's say they are given a different role they may still have an",
    "start": "325880",
    "end": "332240"
  },
  {
    "text": "old copy of an old token uh providing them with your original role and that's generally addressed by putting an",
    "start": "332240",
    "end": "337400"
  },
  {
    "text": "expiration date at the token and whenever that expires you need to get a new token likewise uh whenever you click a",
    "start": "337400",
    "end": "343759"
  },
  {
    "text": "logout button somewhere with a stateful uh tokens this is very easy you just remove the entry from the database while",
    "start": "343759",
    "end": "350440"
  },
  {
    "text": "once you give somebody a cryptographic token you can no longer easily invalidated um so basically you no",
    "start": "350440",
    "end": "358080"
  },
  {
    "text": "longer have a server side log outs which uh of course you can still when somebody clicks a sign out button uh erase the",
    "start": "358080",
    "end": "365280"
  },
  {
    "text": "token on the client s but that will become more difficult when people are using multiple devices so I log in somewhere with my phone and then uh on",
    "start": "365280",
    "end": "372160"
  },
  {
    "text": "my desktop system I lost my phone so I want to log out my session from the phone that's not really possible with",
    "start": "372160",
    "end": "377919"
  },
  {
    "text": "cryptographic tokens additionally uh whenever dealing with from a security perspective",
    "start": "377919",
    "end": "384960"
  },
  {
    "text": "whenever uh giving somebody a stateful token uh this is just this is a secret value and if it leaks out well somebody",
    "start": "384960",
    "end": "392080"
  },
  {
    "text": "can compromise their session uh but this is only a temporary secret valid for the time of the session and it only belongs",
    "start": "392080",
    "end": "398120"
  },
  {
    "text": "to one single user and one single session uh while with cryptographic token you've got a key that you need to",
    "start": "398120",
    "end": "404960"
  },
  {
    "text": "keep secret and if this key ever leaks out then an attacker that uh obtains",
    "start": "404960",
    "end": "410240"
  },
  {
    "text": "this private key can spoof tokens for anyone so they can compromise any single user while if you ever leak out a token",
    "start": "410240",
    "end": "418120"
  },
  {
    "text": "uh the attacker can only uh compromise that specific to uh user that the token belongs",
    "start": "418120",
    "end": "425440"
  },
  {
    "text": "to and finally um stateful tokens are just a lot simpler to implement you just",
    "start": "425440",
    "end": "431039"
  },
  {
    "text": "need a uh cryptographically secure random number generator well that's provided by any operating system or any",
    "start": "431039",
    "end": "436560"
  },
  {
    "text": "standard Library um you just ask it to generate the right amount of BU 16 or something",
    "start": "436560",
    "end": "442440"
  },
  {
    "text": "and you're good uh while then dealing with encrypted tokens it involves more complex uh cryptography and you may",
    "start": "442440",
    "end": "450000"
  },
  {
    "text": "argue that well you only need some cryptographic temper protection how hard can it",
    "start": "450000",
    "end": "455240"
  },
  {
    "text": "be but in practice there have been quite some cases where it turns out this was",
    "start": "455240",
    "end": "461639"
  },
  {
    "text": "uh a bit harder than you would think it this and I'll get into that later um now there are some uh hybrid approaches you",
    "start": "461639",
    "end": "468479"
  },
  {
    "text": "can also take to kind of uh have a compromise between the upsides and downsides of stateful tokens and",
    "start": "468479",
    "end": "474479"
  },
  {
    "text": "cryptographic tokens and this is also very commonly seen with jwt's where you",
    "start": "474479",
    "end": "479680"
  },
  {
    "text": "have a so-called exess token that is uses cryptography and a refresh token",
    "start": "479680",
    "end": "485280"
  },
  {
    "text": "that's a database uh key and this allows you to make this exis token valid for a",
    "start": "485280",
    "end": "491319"
  },
  {
    "text": "short amount of time maybe five maybe 15 minutes and at any time it expires you then use the persistent token to look up",
    "start": "491319",
    "end": "497919"
  },
  {
    "text": "the most upto-date information from the database that means that by far most of your requests are going to be very fast",
    "start": "497919",
    "end": "504280"
  },
  {
    "text": "to validate but every five minutes per session you're going to need to do one single database lookup so you still have",
    "start": "504280",
    "end": "509800"
  },
  {
    "text": "excellent performance um and whenever you want to do any revocation or claims change you",
    "start": "509800",
    "end": "515760"
  },
  {
    "text": "can do that in the database and you just have a a short period the maximal",
    "start": "515760",
    "end": "521080"
  },
  {
    "text": "validity time of a token that you'll have to wait to make sure that the change is take effect so if I click the",
    "start": "521080",
    "end": "527080"
  },
  {
    "text": "sign out button and then wait uh after five minutes you can be sure well any excess token belonging to this user has",
    "start": "527080",
    "end": "533440"
  },
  {
    "text": "been expired by now so now somebody really is fully signed out however the security issue still",
    "start": "533440",
    "end": "539200"
  },
  {
    "text": "still persist because if you leak out a key I can still SPO excess tokens and even if this excess token is not if I",
    "start": "539200",
    "end": "545000"
  },
  {
    "text": "can't come up with a valid refresh token an exess token is all I need to be able to spoof identities so you still need to",
    "start": "545000",
    "end": "551440"
  },
  {
    "text": "keep a key secret and you still need to use secure",
    "start": "551440",
    "end": "556640"
  },
  {
    "text": "cryptography and this has failed quite some times in the past so um the seml",
    "start": "556640",
    "end": "562680"
  },
  {
    "text": "protocol is still uh uh one of the popular um identity Federation protocols",
    "start": "562680",
    "end": "568800"
  },
  {
    "text": "uh it's based on XML signatures and these are notoriously",
    "start": "568800",
    "end": "574399"
  },
  {
    "text": "difficult to implement correctly there's a lot of uh pitfalls uh where you make some subtle changes to an XML uh tree",
    "start": "574399",
    "end": "582440"
  },
  {
    "text": "and then this the signature validator thinks it looks like one thing but the application thinks it looks like something else and you can uh completely",
    "start": "582440",
    "end": "589600"
  },
  {
    "text": "spoof your claim information and impersonate other users um there are also proprietary",
    "start": "589600",
    "end": "595519"
  },
  {
    "text": "cryptographic mechanisms usually quite a bit older um that also have shown to",
    "start": "595519",
    "end": "600959"
  },
  {
    "text": "have fall uh flaws uh Oracle access manager for example uh used to use a",
    "start": "600959",
    "end": "606839"
  },
  {
    "text": "proprietary mechanism based on unauthenticated as CBC encryption and if you're familiar with cryptography you",
    "start": "606839",
    "end": "613240"
  },
  {
    "text": "know that's not a very good idea if uh at all um because this may uh maintain",
    "start": "613240",
    "end": "620040"
  },
  {
    "text": "the confidentiality of your tokens it's vulnerable to all sorts of attacks whenever you're in a chosen Cipher text",
    "start": "620040",
    "end": "625959"
  },
  {
    "text": "scenario where somebody can make changes to the cipher text which is definitely the case when you're handing off these tokens to users um I also did some",
    "start": "625959",
    "end": "633079"
  },
  {
    "text": "research myself last year on another proprietary mechanism called ltpa tokens",
    "start": "633079",
    "end": "638120"
  },
  {
    "text": "used by IBM websphere um and these used a uh um custom cryptographic scheme uh",
    "start": "638120",
    "end": "645160"
  },
  {
    "text": "based on the combination of RSA signatures and AES encryption in a bit of an odd um uh OD structure where they",
    "start": "645160",
    "end": "653279"
  },
  {
    "text": "use the key as an initialization factor and this was actually vulnerable to an Adaptive chosen cyer taex attack that",
    "start": "653279",
    "end": "659240"
  },
  {
    "text": "eventually allowed you to completely spoof tokens as well luckily right now we have a JWT",
    "start": "659240",
    "end": "667600"
  },
  {
    "text": "probably the most popular uh cryptographic token format and while I'm going to criticize",
    "start": "667600",
    "end": "674600"
  },
  {
    "text": "JWT design in this talk I do have to say that it's a massive improvement over",
    "start": "674600",
    "end": "680040"
  },
  {
    "text": "previous standards um it the lowlevel C cryptographic Primitives that are used",
    "start": "680040",
    "end": "687040"
  },
  {
    "text": "are generally uh good um most importantly it uses proper ident",
    "start": "687040",
    "end": "692880"
  },
  {
    "text": "uh Integrity protection it doesn't just use encryption without authentication um and besides that",
    "start": "692880",
    "end": "698760"
  },
  {
    "text": "another big advantage that also appeals probably to a lot of users and developers is that they're easy to read",
    "start": "698760",
    "end": "703920"
  },
  {
    "text": "and debug you just have uh well three Bas 64 blocks separated by periods you",
    "start": "703920",
    "end": "709880"
  },
  {
    "text": "can just throw any part of it in a b 64 decoder and you can see what's inside uh",
    "start": "709880",
    "end": "715160"
  },
  {
    "text": "and what's inside is a pretty straightforward Json based uh um formats",
    "start": "715160",
    "end": "720519"
  },
  {
    "text": "to uh transfer identity claims that is um relatively straightforward and easy",
    "start": "720519",
    "end": "726639"
  },
  {
    "text": "to understand um because of this Simplicity probably um JWT is really C",
    "start": "726639",
    "end": "732519"
  },
  {
    "text": "called on and there are many many many implementations to choose from uh for some even of the most obscure",
    "start": "732519",
    "end": "738560"
  },
  {
    "text": "programming languages you're probably going to have a bunch of JWT libraries that implements at least parts of the",
    "start": "738560",
    "end": "744360"
  },
  {
    "text": "specification it's also the uh token that used for open ID connects which is a popular identity imigration protocol",
    "start": "744360",
    "end": "751560"
  },
  {
    "text": "so in practice um I do quite a lot of application pen tests and probably seven",
    "start": "751560",
    "end": "757959"
  },
  {
    "text": "out of 10 time there's going to be some JWT in that application somewhere they're everywhere they're incredibly",
    "start": "757959",
    "end": "763399"
  },
  {
    "text": "prevalent and therefore also a very interesting research subject so in the past there have been",
    "start": "763399",
    "end": "769399"
  },
  {
    "text": "some uh security problems with jwt's uh a very well-known one is the",
    "start": "769399",
    "end": "775040"
  },
  {
    "text": "fact that one of the signature algorithms supported by it was called none which basically means there's no signature whatsoever so uh anyone can",
    "start": "775040",
    "end": "782720"
  },
  {
    "text": "just spoof this stoken and when you change the algorithm uh fields that you",
    "start": "782720",
    "end": "788240"
  },
  {
    "text": "can see here the ALK fields in the header of a token if you replace that with none and you remove the signature",
    "start": "788240",
    "end": "794240"
  },
  {
    "text": "the token would be accepted and you can just arbitrarily spoof claims and then there are some implementations that triy",
    "start": "794240",
    "end": "799880"
  },
  {
    "text": "to fix this by put uh blocking the specific nonv value but then you could uh capitalize one of the letters and you",
    "start": "799880",
    "end": "806040"
  },
  {
    "text": "would bypass that filter um another attack uh allowed you that was also based on changing the",
    "start": "806040",
    "end": "812639"
  },
  {
    "text": "algorithm in the token uh allowed you to uh make back and think that an RSA",
    "start": "812639",
    "end": "819079"
  },
  {
    "text": "public key is actually an hmax secret key and well public Keys it's in the name they're public uh and then um you",
    "start": "819079",
    "end": "826440"
  },
  {
    "text": "can use that as a secret key you can start forging tokens um another attack that's maybe a",
    "start": "826440",
    "end": "832839"
  },
  {
    "text": "little less welln is uh a so-called key injection attack where you can sort of",
    "start": "832839",
    "end": "838120"
  },
  {
    "text": "create it's a bit similar to a self- signed certificates because JWT actually uh for some reason allows you to put the",
    "start": "838120",
    "end": "845040"
  },
  {
    "text": "key that's used to verify the token in the token header so you can just come up with your own key put it in the header",
    "start": "845040",
    "end": "850720"
  },
  {
    "text": "and use your own key to then sign the token and some implementations would actually uh use that key in the header",
    "start": "850720",
    "end": "857600"
  },
  {
    "text": "over the key that was actually configured and you have a complete spoofing attack uh there were also some",
    "start": "857600",
    "end": "863320"
  },
  {
    "text": "more traditional crypto bux um uh based on some of the Primitives that are being",
    "start": "863320",
    "end": "869560"
  },
  {
    "text": "used uh although in practice if you're going to break a JWT uh application it's",
    "start": "869560",
    "end": "877000"
  },
  {
    "text": "most likely because a simple password was used as the key which allows an offline Brute Force attack where you",
    "start": "877000",
    "end": "882920"
  },
  {
    "text": "just try put it in hashcat uh you try out a lot of common words from a dictionary until one of them works and",
    "start": "882920",
    "end": "889279"
  },
  {
    "text": "you can decrypt the token in practice this is probably still the most common attack you can mount against a JWT with",
    "start": "889279",
    "end": "895360"
  },
  {
    "text": "the highest chance of success uh because it's very common that live uh JWT libraries allow you to just put a single",
    "start": "895360",
    "end": "902199"
  },
  {
    "text": "pa word in the uh uh in the key field there's a lot of code samples online",
    "start": "902199",
    "end": "907480"
  },
  {
    "text": "that when you copy paste them will result in you using like the word secret or something like that as your JWT key",
    "start": "907480",
    "end": "914519"
  },
  {
    "text": "and um yeah if there's one way to attack Jes and my attacks not going to change anything about that it's probably this",
    "start": "914519",
    "end": "920839"
  },
  {
    "text": "approach this is probably the biggest problem in practice so I um I personally think that",
    "start": "920839",
    "end": "929360"
  },
  {
    "text": "these issues are not just implementation issues um but that there are some underlying issues with the specification",
    "start": "929360",
    "end": "936440"
  },
  {
    "text": "while if implemented correctly these issues should not exist and there's",
    "start": "936440",
    "end": "941519"
  },
  {
    "text": "enough uh ambiguity in the specifications they get leave a lot of responsibility to the implementers so",
    "start": "941519",
    "end": "947120"
  },
  {
    "text": "you can you can always argue that it's the responsibility of the implementers to prevent these attacks but I do think there is some uh design flaws that lead",
    "start": "947120",
    "end": "955040"
  },
  {
    "text": "to these kinds of issues uh probably the most important one uh that I'm definitely going to get back to is the",
    "start": "955040",
    "end": "961399"
  },
  {
    "text": "fact that you have this Al header so you have a a piece of uh information in the",
    "start": "961399",
    "end": "966560"
  },
  {
    "text": "token itself that tells the back end what kind of cryptographic algorithm to use to do validation and that's strange",
    "start": "966560",
    "end": "974120"
  },
  {
    "text": "because the token is something that's under the control of an attacker that's something that you cannot trust and you",
    "start": "974120",
    "end": "979920"
  },
  {
    "text": "don't attacker to decide what kind of cryptography you're going to use that opens up a whole kind of worm of potential cross protocol attacks ideally",
    "start": "979920",
    "end": "987000"
  },
  {
    "text": "you want to either configure a specific um algorithm on the back ends or you",
    "start": "987000",
    "end": "992079"
  },
  {
    "text": "want to store the algorithm along with your cryptographic key uh which is not on the under the attacker's control you",
    "start": "992079",
    "end": "997560"
  },
  {
    "text": "don't want to put that in a token and the JWT standards actually allow you to do both of these things you can put an",
    "start": "997560",
    "end": "1003120"
  },
  {
    "text": "algorithm in the key you can uh uh Force an algorithm in uh your",
    "start": "1003120",
    "end": "1008800"
  },
  {
    "text": "configuration but the default is to put it in the token and when you don't do these two things it's pretty common that",
    "start": "1008800",
    "end": "1015040"
  },
  {
    "text": "the token header is just going to be crusted result in a lot of attack surface and",
    "start": "1015040",
    "end": "1021040"
  },
  {
    "text": "problems uh besides that there's a very long list of algorithms to choose from so instead of just picking a few or one",
    "start": "1021040",
    "end": "1029678"
  },
  {
    "text": "good cryptographic mechanism uh that's chosen by cryptographers that is uh fit",
    "start": "1029679",
    "end": "1035120"
  },
  {
    "text": "for purpose for the use case your uh a lot is basically Left To the End user they have to make a choice from dozens",
    "start": "1035120",
    "end": "1041438"
  },
  {
    "text": "of options and most uh end users are probably not going to be cryptographic experts so it's easy for them to make m",
    "start": "1041439",
    "end": "1048640"
  },
  {
    "text": "uh mistakes and make the wrong choice depending on their situation um which isn't helped by the",
    "start": "1048640",
    "end": "1054600"
  },
  {
    "text": "fact that there actually are bad choices so a lot of the algorithms are basically equivalent in security properties um but",
    "start": "1054600",
    "end": "1062600"
  },
  {
    "text": "for some reason the standard did still include RSA with pkcs uh version 1.5",
    "start": "1062600",
    "end": "1068480"
  },
  {
    "text": "padding which is kind of broken since 1998 uh and really should not be used in",
    "start": "1068480",
    "end": "1075480"
  },
  {
    "text": "new applications anymore and of course there's this whole non algorithm that you probably never would want to",
    "start": "1075480",
    "end": "1080880"
  },
  {
    "text": "use also while some algorithms well if like for example if you use hmac",
    "start": "1080880",
    "end": "1087280"
  },
  {
    "text": "256 or hmac 512 really does not matter at all in practice their security",
    "start": "1087280",
    "end": "1092960"
  },
  {
    "text": "properties are basically uh interchangeable uh however some other algorithms have completely different",
    "start": "1092960",
    "end": "1098559"
  },
  {
    "text": "properties so a um science JWT can either use a symmetric cryptography",
    "start": "1098559",
    "end": "1105159"
  },
  {
    "text": "where you have a shared secret or asymmetric cryptography where you have a public key for verification and a",
    "start": "1105159",
    "end": "1110240"
  },
  {
    "text": "private key for signing and which you're using depends completely on the algorithm Fields the token looks",
    "start": "1110240",
    "end": "1115559"
  },
  {
    "text": "completely the same but you swap the algorithm and it has completely different security properties which can be quite confusing if you're not a",
    "start": "1115559",
    "end": "1121159"
  },
  {
    "text": "cryptographer yourself or you're not experienced with applying cryptography and finally the standards",
    "start": "1121159",
    "end": "1128280"
  },
  {
    "text": "have a lot of features they're trying to address a lot of use cases at the same time um there's a compression feature in",
    "start": "1128280",
    "end": "1135640"
  },
  {
    "text": "Json web tokens there's a feature to put an 509 certificate in your header to",
    "start": "1135640",
    "end": "1140880"
  },
  {
    "text": "determine a public key uh there's a feature to put a URL in your header to fetch a public key from an external",
    "start": "1140880",
    "end": "1147640"
  },
  {
    "text": "source and then use that to validate your token and you can probably imagine there's going to be a lot of potential",
    "start": "1147640",
    "end": "1153080"
  },
  {
    "text": "problems with that luckily that one is basically not implemented by anyone but it's on paper it's it's one of the",
    "start": "1153080",
    "end": "1158640"
  },
  {
    "text": "features that you could Implement um and that leads it to be kind of a bit over",
    "start": "1158640",
    "end": "1164000"
  },
  {
    "text": "engineered um and uh makes it quite tricky to decide for implementers what",
    "start": "1164000",
    "end": "1169039"
  },
  {
    "text": "features to use and what not to use and if you want to be as Full Features as possible you're going to add a lot of",
    "start": "1169039",
    "end": "1174360"
  },
  {
    "text": "attack service by implementing all these uh features that maybe only have very specific obscure use cases and don't",
    "start": "1174360",
    "end": "1181000"
  },
  {
    "text": "really match the general use case of Json web tokens so before I continue uh there's",
    "start": "1181000",
    "end": "1187559"
  },
  {
    "text": "some uh uh terminology that is convenient to use uh luckily it's pretty",
    "start": "1187559",
    "end": "1192919"
  },
  {
    "text": "consistent so uh well Json web tokens jwt's um",
    "start": "1192919",
    "end": "1198799"
  },
  {
    "text": "basically that defines the claim the Json based claims format that uses other standards called",
    "start": "1198799",
    "end": "1206520"
  },
  {
    "text": "the Josie standards J JavaScript object signing encryption for the cryptographic part but you can actually use Josie",
    "start": "1206520",
    "end": "1213240"
  },
  {
    "text": "encryption standards for completely different purposes so there are other protocols that also use these but don't use",
    "start": "1213240",
    "end": "1219120"
  },
  {
    "text": "jwt's um within those standards we have jws which is a type of object for",
    "start": "1219120",
    "end": "1224360"
  },
  {
    "text": "cryptographic authentication and we have jwe which is used for cryption so uh",
    "start": "1224360",
    "end": "1229520"
  },
  {
    "text": "whenever confidentiality is also an issue then uh there is the JW RFC which",
    "start": "1229520",
    "end": "1235520"
  },
  {
    "text": "just lists the cryptographic algorithms used by both standards um and uh defines how to",
    "start": "1235520",
    "end": "1242200"
  },
  {
    "text": "implement them and how to call them and finally there's jwk which is a format for storing cryptographic keys to use",
    "start": "1242200",
    "end": "1248640"
  },
  {
    "text": "with these standards so now let's finally get onto the attacks and the first one I call",
    "start": "1248640",
    "end": "1256159"
  },
  {
    "text": "sign encrypt confusion so there is um basically three different",
    "start": "1256159",
    "end": "1262280"
  },
  {
    "text": "flavors of Json web tokens that uh each user different uh josi standard or",
    "start": "1262280",
    "end": "1268280"
  },
  {
    "text": "combinations of them so by far the most common one is to put your Json web token your claims in a jws format so in this",
    "start": "1268280",
    "end": "1276080"
  },
  {
    "text": "case um you have integrity protection that's the main property you want but the user can read their own claims they",
    "start": "1276080",
    "end": "1282200"
  },
  {
    "text": "you can look in your uh look at your browser cookie or something and you can see what kind of claims are being stored",
    "start": "1282200",
    "end": "1287240"
  },
  {
    "text": "in there uh which is uh in many use cases is completely fine uh but if you",
    "start": "1287240",
    "end": "1293000"
  },
  {
    "text": "don't actually want your end users to look at their claims you also have the encrypted JWT format here you use the",
    "start": "1293000",
    "end": "1299600"
  },
  {
    "text": "jwe standard and um the payload of the encrypted message are is the same Json",
    "start": "1299600",
    "end": "1307240"
  },
  {
    "text": "object with the claims in them then finally there's also the uh you have the possibility of combining both standards",
    "start": "1307240",
    "end": "1314039"
  },
  {
    "text": "and put a jws object into a jwe object so you uh um you both have an encryption",
    "start": "1314039",
    "end": "1321159"
  },
  {
    "text": "layer and you have an uh signing layer an authenticity layer uh Within These uh",
    "start": "1321159",
    "end": "1327159"
  },
  {
    "text": "different typ of um formats you have different algorithms as I mentioned",
    "start": "1327159",
    "end": "1332400"
  },
  {
    "text": "before and these algorithms can either be symmetric or asymmetric so you either have a shared secret or you have a",
    "start": "1332400",
    "end": "1339360"
  },
  {
    "text": "public key cryptography with a public key and a private key um for uh J um for",
    "start": "1339360",
    "end": "1346880"
  },
  {
    "text": "science JWT in the jws format which if one you use both symmetric",
    "start": "1346880",
    "end": "1352559"
  },
  {
    "text": "authentication or asymmetric authentication is going to satisfy your core requirement it's going to prevent",
    "start": "1352559",
    "end": "1359080"
  },
  {
    "text": "end users from tempering with it um when you look at JW however if you use a",
    "start": "1359080",
    "end": "1365720"
  },
  {
    "text": "secret key that's actually completely fine because in jwe when you have a symmetric key um it offers both",
    "start": "1365720",
    "end": "1372360"
  },
  {
    "text": "confidentiality protection and integrity protection so it's suitable for jwt's",
    "start": "1372360",
    "end": "1378679"
  },
  {
    "text": "however there's Al also asymmetric jwes and when you use those you're",
    "start": "1378679",
    "end": "1384480"
  },
  {
    "text": "actually encrypting with a public key and then um you need a private key a",
    "start": "1384480",
    "end": "1389679"
  },
  {
    "text": "secret to decrypt it so the validator is going to need a secret but the one issuing the tokens Can you use a public",
    "start": "1389679",
    "end": "1396320"
  },
  {
    "text": "key and well it's public so basically anyone can do the encryption and they",
    "start": "1396320",
    "end": "1402600"
  },
  {
    "text": "can just take some claims they can encrypt it with a public key which is public and they have created a valid",
    "start": "1402600",
    "end": "1409400"
  },
  {
    "text": "token or at least it's not supposed you're probably not supposed to use this",
    "start": "1409400",
    "end": "1414600"
  },
  {
    "text": "but nowhere in the um JWT RFC is it stated that this is forbidden it just",
    "start": "1414600",
    "end": "1420679"
  },
  {
    "text": "says you can put your JWT in a jws or in a JW object but it doesn't say that",
    "start": "1420679",
    "end": "1425840"
  },
  {
    "text": "certain algorithms are not are suitable or not suitable for this context but in practice you really never want to use",
    "start": "1425840",
    "end": "1433440"
  },
  {
    "text": "this so you could you can argue well the end users should be responsible for this",
    "start": "1433440",
    "end": "1439200"
  },
  {
    "text": "they should never pick an asymmetric algorithm if they want to use encrypted jwt's but that's not that",
    "start": "1439200",
    "end": "1445120"
  },
  {
    "text": "straightforward if they don't have prior cryptographic experience if you go to the RFC you have a nice list of",
    "start": "1445120",
    "end": "1450600"
  },
  {
    "text": "encryption algorithms um some of them are suitable for using jwt's because",
    "start": "1450600",
    "end": "1456159"
  },
  {
    "text": "they're symmetric other ones are asymmetric and completely unsuitable but the RFC is not going to tell you that",
    "start": "1456159",
    "end": "1462279"
  },
  {
    "text": "explicitly and if you're um if you have the mindset you just want to use a",
    "start": "1462279",
    "end": "1467919"
  },
  {
    "text": "secure algorithm and you look up well you have some very secure algorithms here that just not fit for this",
    "start": "1467919",
    "end": "1473360"
  },
  {
    "text": "particular use case and you may think if you're experienced with cryptography well who's going to accidentally pick",
    "start": "1473360",
    "end": "1479679"
  },
  {
    "text": "public re encryption instead of signing this is actually pretty common in practice I see a lot of uh among",
    "start": "1479679",
    "end": "1485480"
  },
  {
    "text": "developers I often see a lot of confusion uh between different types of cryptographic Primitives people are just",
    "start": "1485480",
    "end": "1491200"
  },
  {
    "text": "looking for a secure Cipher uh and they know that oh RSA is secure therefore I can use RSA but then they actually",
    "start": "1491200",
    "end": "1497720"
  },
  {
    "text": "accidentally Ed the wrong type of RSA for a different use case and they have a",
    "start": "1497720",
    "end": "1502840"
  },
  {
    "text": "vulnerability but that's not really the attack that's a potential misconfiguration um so what if we just",
    "start": "1502840",
    "end": "1509960"
  },
  {
    "text": "forgo encrypted jwt's and we just use plain old science jwt's we don't have to",
    "start": "1509960",
    "end": "1516039"
  },
  {
    "text": "worry about any of this right well right here you see a uh few Snippets of codes",
    "start": "1516039",
    "end": "1523000"
  },
  {
    "text": "using the uh popular out lip uh python Library uh you have a piece uh of code",
    "start": "1523000",
    "end": "1529120"
  },
  {
    "text": "that issues jwt's and that validates them um and it uses pretty standard",
    "start": "1529120",
    "end": "1534559"
  },
  {
    "text": "functions from the library it's pretty similar to the code samples you get um so you have an RSA key you have a signer",
    "start": "1534559",
    "end": "1542039"
  },
  {
    "text": "that uh gives out RSA signed tokens completely fine and then you have a validator that loads in the same RSA key",
    "start": "1542039",
    "end": "1548279"
  },
  {
    "text": "and just use and then uses the standard validation function with that key on the token that comes in not much can go",
    "start": "1548279",
    "end": "1554640"
  },
  {
    "text": "wrong here right well the problem here is that the key file is not only usable for signing",
    "start": "1554640",
    "end": "1563039"
  },
  {
    "text": "and validation uh because it's an RSA key uh and RSA can also be used for",
    "start": "1563039",
    "end": "1568240"
  },
  {
    "text": "encryption and decryption um this same file when loaded in this Library can also be used for",
    "start": "1568240",
    "end": "1574760"
  },
  {
    "text": "these purposes so how does the validator know whether to use uh signing or",
    "start": "1574760",
    "end": "1582760"
  },
  {
    "text": "encryption uh well you can either configure it manually um but if you use the default it actually look at this ALK",
    "start": "1582760",
    "end": "1588960"
  },
  {
    "text": "header in the token and this Al header in the token is going to tell you what kind of algorithm to use so if you",
    "start": "1588960",
    "end": "1595799"
  },
  {
    "text": "submit an encrypted token instead of a signed token the validator will look at it oh it's an encrypted JWT what",
    "start": "1595799",
    "end": "1602000"
  },
  {
    "text": "algorithm RSA I have an RSA key seems legit I have a private key here I'm going to decrypt it I'm going to accept",
    "start": "1602000",
    "end": "1608440"
  },
  {
    "text": "it and then we have a problem that leads us to the sign encrypt confusion attack",
    "start": "1608440",
    "end": "1615240"
  },
  {
    "text": "so this really doesn't work in uh in all use cases with sign J WTS but what the",
    "start": "1615240",
    "end": "1620440"
  },
  {
    "text": "right combination of preconditions is present which was the case for the code samples you saw well it no longer is",
    "start": "1620440",
    "end": "1625799"
  },
  {
    "text": "because OD lip has been patched but before the patch uh these conditions were present so when you have a library",
    "start": "1625799",
    "end": "1631720"
  },
  {
    "text": "that supports encrypted jws uh when the regular application users signs jws when the private key",
    "start": "1631720",
    "end": "1639440"
  },
  {
    "text": "used for uh uh giving out the tokens is also accessible by the validation",
    "start": "1639440",
    "end": "1644679"
  },
  {
    "text": "function uh which is possible with some libraries and certain use cases and",
    "start": "1644679",
    "end": "1649880"
  },
  {
    "text": "there's no type enforcement then you could carry out this Attack One practical consideration",
    "start": "1649880",
    "end": "1656679"
  },
  {
    "text": "is though that even though a public key is supposed to be public in practice you don't always know the public key when you get a token it doesn't contain this",
    "start": "1656679",
    "end": "1663320"
  },
  {
    "text": "public key uh when you're dealing with open ID connect you can usually look up this uh public key with a standard",
    "start": "1663320",
    "end": "1669039"
  },
  {
    "text": "endpoint but if this is not actually revealed um there's another way to get to the public key and that's to compute",
    "start": "1669039",
    "end": "1675200"
  },
  {
    "text": "it if um the uh if certain RSA algorithms are used these",
    "start": "1675200",
    "end": "1681120"
  },
  {
    "text": "are actually the most common one for science jwt's you can actually compute the public Key by if you have two",
    "start": "1681120",
    "end": "1687320"
  },
  {
    "text": "different tokens I wrote a tool for that takes about a minute to compute on a laptop uh and given two of these tokens",
    "start": "1687320",
    "end": "1693880"
  },
  {
    "text": "it will give you the public key this is not a vulnerability in RSA because RSA is not designed to hide your public key",
    "start": "1693880",
    "end": "1699519"
  },
  {
    "text": "because once again supposed to be public but this is in practice very useful when carrying out this attack and you can",
    "start": "1699519",
    "end": "1705039"
  },
  {
    "text": "also use this when you want to uh try to exploit the older uh hm RSA confusion",
    "start": "1705039",
    "end": "1711480"
  },
  {
    "text": "attack uh and personally to do this in practice you can just use any uh J JWT",
    "start": "1711480",
    "end": "1716679"
  },
  {
    "text": "tool that allows you to create encrypt the tokens I personally like to use the JWT editor uh plugin for burp during",
    "start": "1716679",
    "end": "1724279"
  },
  {
    "text": "application assignments because it makes it very easy to swap the algorithm around and resign or reencrypt a JWT",
    "start": "1724279",
    "end": "1730120"
  },
  {
    "text": "with a different algorithm so yeah that was attack number one number two the polyglots JWT",
    "start": "1730120",
    "end": "1739120"
  },
  {
    "text": "so a common pattern that you can see in applications is that they pass off a JWT",
    "start": "1739120",
    "end": "1745640"
  },
  {
    "text": "string to a validation library that does all the crypto stuff and tells you if the signature is correct or not and then",
    "start": "1745640",
    "end": "1752919"
  },
  {
    "text": "it PES off the same token after validation to a library that's actually going to look in the claims at the",
    "start": "1752919",
    "end": "1758080"
  },
  {
    "text": "claims inside it but it will not do any cryptography because it assumes the validation library has taken care of",
    "start": "1758080",
    "end": "1764399"
  },
  {
    "text": "that and whenever there's an incon consistency between these two libraries",
    "start": "1764399",
    "end": "1769600"
  },
  {
    "text": "on how they par jws there might be an opportunity that you can create a JWT that looks different to library a and",
    "start": "1769600",
    "end": "1776000"
  },
  {
    "text": "different to library B so Library a you supply a completely valid token but then",
    "start": "1776000",
    "end": "1781559"
  },
  {
    "text": "you make it look like a different spoof tokens to library B and if this is possible this is a pretty dangerous",
    "start": "1781559",
    "end": "1787880"
  },
  {
    "text": "patter um uh I was um actively looking for vulnerabilities like this at first I",
    "start": "1787880",
    "end": "1794320"
  },
  {
    "text": "was thinking maybe exploit Json ambiguity like for example having two Fields with the same names there's some",
    "start": "1794320",
    "end": "1800720"
  },
  {
    "text": "nice research from Bishop Fox uh on many different Json applications that you can exploit like this I didn't actually find",
    "start": "1800720",
    "end": "1807080"
  },
  {
    "text": "any bucks like that in JWT libraries but I did find something else because um jws",
    "start": "1807080",
    "end": "1813360"
  },
  {
    "text": "objects uh can actually be represented in different ways uh you have the compact format that's used for J WTS but",
    "start": "1813360",
    "end": "1819279"
  },
  {
    "text": "you also have an alternative Json based format and some JWT libraries uh support",
    "start": "1819279",
    "end": "1825159"
  },
  {
    "text": "this as well and this uh led to something interesting",
    "start": "1825159",
    "end": "1831279"
  },
  {
    "text": "in a specific uh Library called python JWT that assumed that the first compact",
    "start": "1831279",
    "end": "1838000"
  },
  {
    "text": "format was used but then this Library passes off the uh the token to a second",
    "start": "1838000",
    "end": "1843399"
  },
  {
    "text": "Library JW crypto which supports both formats so JW crypto looks at the token",
    "start": "1843399",
    "end": "1848760"
  },
  {
    "text": "and thinks well does this look like Jason if so I'm going to treat it as the Json format if not I'm going to treat it",
    "start": "1848760",
    "end": "1854559"
  },
  {
    "text": "as the compact formats well pton JWT just assumes it's compact it splits it at the periods it does some custom",
    "start": "1854559",
    "end": "1861159"
  },
  {
    "text": "validations of its own passes it off to the other Library if the other Library doesn't throw an exception it will",
    "start": "1861159",
    "end": "1866440"
  },
  {
    "text": "continue with the token it has already pared so let's try to attack this let's",
    "start": "1866440",
    "end": "1872679"
  },
  {
    "text": "say we get a legitimate token we log in with a lowly privilege user header a payloads b uh signature C and we're",
    "start": "1872679",
    "end": "1880519"
  },
  {
    "text": "going to transform it like this so we're basically going to change it in a different Json format but we're going to",
    "start": "1880519",
    "end": "1886320"
  },
  {
    "text": "add an extra Fe where the key is the header value and the uh value is a malicious payload that",
    "start": "1886320",
    "end": "1893440"
  },
  {
    "text": "we come up with ourselves when this is loaded into the JW crypto Library it will just see",
    "start": "1893440",
    "end": "1900919"
  },
  {
    "text": "adjacent object with an extra Fields it just ignores this extra field it only will uh read the keys that it knows",
    "start": "1900919",
    "end": "1907799"
  },
  {
    "text": "about protected payload and signature if there's an extra field this does not cut any issues gets completely ignored and",
    "start": "1907799",
    "end": "1914279"
  },
  {
    "text": "when this has the legitimate signature this check Library will pass the check however python JWT will uh split",
    "start": "1914279",
    "end": "1923320"
  },
  {
    "text": "this will not know that this is Json it will just split this thing on periods throw away the what's supposed to be the",
    "start": "1923320",
    "end": "1929120"
  },
  {
    "text": "signature part and then use a Bas 64 decoder that happens to just discard any character that's not in the Bas 64",
    "start": "1929120",
    "end": "1936039"
  },
  {
    "text": "alphabet so in the end this library has uh gets this x",
    "start": "1936039",
    "end": "1942360"
  },
  {
    "text": "payload and this x payload can contain any arbitrary claims you can come up",
    "start": "1942360",
    "end": "1947679"
  },
  {
    "text": "with so this allows you if you have one legitimate token to turn it in any other token that you want so you can have an",
    "start": "1947679",
    "end": "1953720"
  },
  {
    "text": "uh a token that's part belongs to an administrator and it's valid forever for",
    "start": "1953720",
    "end": "1959440"
  },
  {
    "text": "example so finally attack number three the billion hashes attack this is about some other JW e",
    "start": "1959440",
    "end": "1967639"
  },
  {
    "text": "algorithms so I mentioned before that there's both symmetric and asymmetric algorithms but there's also sort of a",
    "start": "1967639",
    "end": "1974919"
  },
  {
    "text": "variant of symmetric algorithms based on password based encryption so these are schemes where you don't really use a",
    "start": "1974919",
    "end": "1980720"
  },
  {
    "text": "random string as a key but you use a password and then the password is uh uh put to a together with the Sals into a",
    "start": "1980720",
    "end": "1988240"
  },
  {
    "text": "key der password based key derivation function and the result of that is a cryptographic key that's used for the",
    "start": "1988240",
    "end": "1993440"
  },
  {
    "text": "actual cryptography and well it's understandable that these things exist",
    "start": "1993440",
    "end": "1999919"
  },
  {
    "text": "if you're a standard designer and you want to have feature completeness password based encryption is pretty",
    "start": "1999919",
    "end": "2005159"
  },
  {
    "text": "useful there's a lot of use cases for it so um the standard just added this to the algorithm list to have more options",
    "start": "2005159",
    "end": "2012480"
  },
  {
    "text": "but then the library implementor looks at this list of algorithms and thinks well I want to support the whole",
    "start": "2012480",
    "end": "2017880"
  },
  {
    "text": "standard so my end users will have uh have more versatility more options so I'm going to implement these algorithms",
    "start": "2017880",
    "end": "2024200"
  },
  {
    "text": "as well and I also want to have a clean interface so I'm not going to bother the end user with too many details the end",
    "start": "2024200",
    "end": "2031440"
  },
  {
    "text": "user can just pick an algorithm and I'm going to use the exact same API regardless if it's a symmetric Crypt",
    "start": "2031440",
    "end": "2037159"
  },
  {
    "text": "asymmetric crypto or password based crypto then finally the user just used",
    "start": "2037159",
    "end": "2042320"
  },
  {
    "text": "when they get a token in their application you just use the default settings because they assume well it's a",
    "start": "2042320",
    "end": "2047480"
  },
  {
    "text": "default it's a security Library it's supposed to be secure um but this actually means that the library will use",
    "start": "2047480",
    "end": "2054599"
  },
  {
    "text": "the ALG header to determine what kind of crypto to use and if the ALG header then says I'm using password based crypto the",
    "start": "2054599",
    "end": "2061520"
  },
  {
    "text": "library is going to use password based crypto so at first I thought well maybe I can turn this into a protocol attack",
    "start": "2061520",
    "end": "2067839"
  },
  {
    "text": "to spoof tokens didn't really find any practical way to do that but they did notice something else and that's a",
    "start": "2067839",
    "end": "2074960"
  },
  {
    "text": "particular parameter for the password based encryption which is an iteration count in because in password based",
    "start": "2074960",
    "end": "2081240"
  },
  {
    "text": "encryption you want to defend against dictionary attacks people repeatedly trying out passwords to see which one is",
    "start": "2081240",
    "end": "2087358"
  },
  {
    "text": "correct and one way to mitigate this is to intentionally make the password based key derivation function expensive and",
    "start": "2087359",
    "end": "2094679"
  },
  {
    "text": "the way that's done here is by just iterating a hash function many times and this is a parameter so you can tweak how",
    "start": "2094679",
    "end": "2101079"
  },
  {
    "text": "long it takes to compute your function uh normally you would make kind of a trade-off like that it's slow that it's",
    "start": "2101079",
    "end": "2107240"
  },
  {
    "text": "not too slow for normal use but it will be too slow for an attacker to do an effective Brute Force attack and we can",
    "start": "2107240",
    "end": "2114000"
  },
  {
    "text": "take advantage of that here by just setting this value to the maximum allowed value by the library uh for the",
    "start": "2114000",
    "end": "2119960"
  },
  {
    "text": "libraries I investigated is always was 2 to the^ of 31 minus one and so basically uh",
    "start": "2119960",
    "end": "2127560"
  },
  {
    "text": "uh two billion iterations and when I pass off this token to a library that accepts this uh",
    "start": "2127560",
    "end": "2134520"
  },
  {
    "text": "and I just the payload and signature just pick random arbitrary bites don't care about that it will do this very",
    "start": "2134520",
    "end": "2140880"
  },
  {
    "text": "very long computation it will uh compute billions of Hesh cycles and then finally",
    "start": "2140880",
    "end": "2146480"
  },
  {
    "text": "it comes to some uh key and the key will be incorrect your token will be invalid but it can only determine whether your",
    "start": "2146480",
    "end": "2152440"
  },
  {
    "text": "token is invalid after doing this heavy computation so you can imagine if I sent a bunch of these tokens to a backends it",
    "start": "2152440",
    "end": "2160240"
  },
  {
    "text": "may will probably take the backend down pretty quickly so you have a very efficient denial of surface attacks that",
    "start": "2160240",
    "end": "2165760"
  },
  {
    "text": "is also completely unauthenticated because you don't need a f token to start with so yeah those were the uh three new",
    "start": "2165760",
    "end": "2173200"
  },
  {
    "text": "attack categories and all of them you could argue are not really standard",
    "start": "2173200",
    "end": "2178800"
  },
  {
    "text": "vulnerabilities or protocol flaws they are um implementation",
    "start": "2178800",
    "end": "2184040"
  },
  {
    "text": "flaws um and by uh to be fair most implementations are not actually",
    "start": "2184040",
    "end": "2189800"
  },
  {
    "text": "vulnerable to these because they don't Implement certain features or they have other controls that uh guard against",
    "start": "2189800",
    "end": "2195520"
  },
  {
    "text": "these types of attacks uh however I did find six libraries that were vulnerable",
    "start": "2195520",
    "end": "2201280"
  },
  {
    "text": "to at least one of these issues um and um they uh reported those have all been",
    "start": "2201280",
    "end": "2208160"
  },
  {
    "text": "patched this was actually a pretty pleasant experience because unlike what I'm used with like support uh like",
    "start": "2208160",
    "end": "2215040"
  },
  {
    "text": "reporting box to an organization like Microsoft uh these small open- Source development teams all responded very",
    "start": "2215040",
    "end": "2221640"
  },
  {
    "text": "quickly they didn't try to downplay the issues they took it very seriously uh one of the library",
    "start": "2221640",
    "end": "2228280"
  },
  {
    "text": "maintainers uh came up with a complete P proposed patch in two hours after my submission um in yeah if if you want to",
    "start": "2228280",
    "end": "2236720"
  },
  {
    "text": "have a good time doing vulnerability disclosure go look at small open source security libraries it uh or especially",
    "start": "2236720",
    "end": "2243400"
  },
  {
    "text": "JWT libraries it was actually very positive a very positive experience um",
    "start": "2243400",
    "end": "2249200"
  },
  {
    "text": "so yeah this um uh and in these libraries that I investigated uh patches were applied that make all of these",
    "start": "2249200",
    "end": "2254880"
  },
  {
    "text": "three attacks completely impossible in practice however I could not look at every single JWT",
    "start": "2254880",
    "end": "2261160"
  },
  {
    "text": "implementation and the underlying issues that make this possible I do think there are some standards issues some of the",
    "start": "2261160",
    "end": "2267599"
  },
  {
    "text": "flaws I mentioned before are part of the uh root ca for these issues and it's not",
    "start": "2267599",
    "end": "2273560"
  },
  {
    "text": "unlikely that there will be other libraries out there that have similar problems uh I try to focus mostly on the popular",
    "start": "2273560",
    "end": "2279640"
  },
  {
    "text": "libraries that seem to have one of these issues but there can definitely more that I",
    "start": "2279640",
    "end": "2285040"
  },
  {
    "text": "missed so finally uh yeah my my takeaways from this research um first of all I would like to",
    "start": "2285040",
    "end": "2292160"
  },
  {
    "text": "emphasize that jts have advantages over traditional old-fashioned booring uh",
    "start": "2292160",
    "end": "2298599"
  },
  {
    "text": "random tokens but they do introduce new complexity and risk so if you don't need",
    "start": "2298599",
    "end": "2303760"
  },
  {
    "text": "cryptographic tokens simplest and most secure option is to simply don't use them just use a traditional sessions",
    "start": "2303760",
    "end": "2310880"
  },
  {
    "text": "database if you don't require the uh high levels of scalability uh that",
    "start": "2310880",
    "end": "2316839"
  },
  {
    "text": "cryptographic tokens enable just go for uh oldfashioned stateful tokens um also",
    "start": "2316839",
    "end": "2324760"
  },
  {
    "text": "um after the AL Nan attacks and the algorithm confusion attacks from a few years ago there are still other issues",
    "start": "2324760",
    "end": "2331520"
  },
  {
    "text": "with uh algorithm selection and I still think that puting and the algorithm in",
    "start": "2331520",
    "end": "2337119"
  },
  {
    "text": "the along with the cipher text in the untrusted token is a major design flaw and that opens up a huge attack surface",
    "start": "2337119",
    "end": "2344319"
  },
  {
    "text": "and that enabled two out of the three attacks that I talked about here um I also noticed that the libraries that",
    "start": "2344319",
    "end": "2351240"
  },
  {
    "text": "were most vulnerable were the libraries uh that uh try to implement as many features as possible try to be very",
    "start": "2351240",
    "end": "2357200"
  },
  {
    "text": "feature Rich there's definitely good reasons why you would want that but uh when you want to focus on security it",
    "start": "2357200",
    "end": "2363359"
  },
  {
    "text": "may be better to just try to implement a narrow subset of features uh so for any end users I would",
    "start": "2363359",
    "end": "2370400"
  },
  {
    "text": "recommend um to make sure that you avoid the F the second issue with the algorithm selection by enforcing a",
    "start": "2370400",
    "end": "2376720"
  },
  {
    "text": "specific algorithm and to maybe also consider going for an alternative like stateful tokens or another cryptographic",
    "start": "2376720",
    "end": "2383280"
  },
  {
    "text": "token that has a more tight design tries to not solve as many problems as well so",
    "start": "2383280",
    "end": "2388720"
  },
  {
    "text": "yeah my time is up here um thank you all very much for uh [Applause]",
    "start": "2388720",
    "end": "2395400"
  },
  {
    "text": "attending so unfortunately I don't think there will be time for questions uh but I will",
    "start": "2395400",
    "end": "2402359"
  },
  {
    "text": "be available at I think 3:00 there's some meet and greet event plans uh and",
    "start": "2402359",
    "end": "2408000"
  },
  {
    "text": "of course you can also just uh uh approach me right now or during lunch if you have uh anything you would like to",
    "start": "2408000",
    "end": "2413760"
  },
  {
    "text": "ask thank you all",
    "start": "2413760",
    "end": "2419520"
  }
]