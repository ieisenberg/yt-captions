[
  {
    "text": "hello everyone I'm Max I work in the Microsoft offensive research and security engineering team and I'm going",
    "start": "4680",
    "end": "11519"
  },
  {
    "text": "to talk about the security review we did of TDX which is a new confidential Computing technology from Intel uh so",
    "start": "11519",
    "end": "18160"
  },
  {
    "text": "it's a review we did a year ago in partnership with Intel and so I'm going to talk about what TDX is how it works",
    "start": "18160",
    "end": "24199"
  },
  {
    "text": "how we approached it from a security point of view and then going to present two vulnerabilities we discovered in it",
    "start": "24199",
    "end": "29599"
  },
  {
    "text": "before concluding with a few takeaways so in a uh standard",
    "start": "29599",
    "end": "35200"
  },
  {
    "text": "utilization architecture you have a hypervisor that runs guests uh the hypervisor is typically owned by a cloud",
    "start": "35200",
    "end": "40760"
  },
  {
    "text": "provider and the guests are typically Cloud customers in this architecture there is by definition no",
    "start": "40760",
    "end": "47280"
  },
  {
    "text": "confidentiality guarantee is provided to the guest uh because the hypervisor has access to the guest memory and to the",
    "start": "47280",
    "end": "53160"
  },
  {
    "text": "guest registers and so it can see all of the guest data that's of course a",
    "start": "53160",
    "end": "58680"
  },
  {
    "text": "problem if uh cloud provider gets compromised because if an attacker takes control of the hypervisor then it's easy",
    "start": "58680",
    "end": "65040"
  },
  {
    "text": "for them to exfiltrate all of the customer data so in order to fix that problem there needs to be a change in",
    "start": "65040",
    "end": "71200"
  },
  {
    "text": "architecture there needs to be a new architecture and on Intel that architecture is called TDX the TDX",
    "start": "71200",
    "end": "76960"
  },
  {
    "text": "stands for trust the main extensions and the idea is that the hypervisor does not",
    "start": "76960",
    "end": "82119"
  },
  {
    "text": "longer run the guest directly instead it talks to a new piece of fmil called the TDX module and it's the TDX module that",
    "start": "82119",
    "end": "89680"
  },
  {
    "text": "runs runs the guest in an isolated way um so the TDX module in green here is",
    "start": "89680",
    "end": "95240"
  },
  {
    "text": "the core component of the TDX architecture and it acts as a bit of a gatekeeper to ensure that the guest",
    "start": "95240",
    "end": "101399"
  },
  {
    "text": "memory is encrypted and that the guest registers are not exposed to the hypervisor and so in this new",
    "start": "101399",
    "end": "106920"
  },
  {
    "text": "architecture if the cloud provider gets compromised then it's not possible to steal the customer data because it's",
    "start": "106920",
    "end": "112399"
  },
  {
    "text": "protected by TDX the TDX provides confidentiality and",
    "start": "112399",
    "end": "117600"
  },
  {
    "text": "integrity guarantees uh it will available in future generation CPUs by",
    "start": "117600",
    "end": "122680"
  },
  {
    "text": "Intel uh so it's about to become available in the market but it isn't yet completely um and at Microsoft we are",
    "start": "122680",
    "end": "129759"
  },
  {
    "text": "very interested in strengthening the security promises that we make to our customers in our asure cloud and so",
    "start": "129759",
    "end": "135879"
  },
  {
    "text": "we're very interested in the TDX architecture and that's why we performed a Security review of TDX to learn more",
    "start": "135879",
    "end": "142760"
  },
  {
    "text": "about how it works and see whether the security Promises of TDX truly hold so let's dig into the technical",
    "start": "142760",
    "end": "150519"
  },
  {
    "text": "details of how the TDX module works so the TDX module is first of all a purely software component uh it doesn't run on",
    "start": "150519",
    "end": "157519"
  },
  {
    "text": "a separate chip on a specific Hardware it runs on the main CPU in the system um",
    "start": "157519",
    "end": "162879"
  },
  {
    "text": "it is actually open source so you can download it source code from the Intel website it is programmed in C compiled",
    "start": "162879",
    "end": "169560"
  },
  {
    "text": "by clang and results in an elf binary it uses a standard 64 instruction set so no",
    "start": "169560",
    "end": "176040"
  },
  {
    "text": "magic instructions or anything like that and it runs in ring0 64bit page mode which is similar to a traditional",
    "start": "176040",
    "end": "183400"
  },
  {
    "text": "kernel at initialization time the TDX modle is loaded in a range of protected physical memory called the seam range",
    "start": "183400",
    "end": "190480"
  },
  {
    "text": "and by protected I mean that the hypervisor does not have access to it only the TDX module can write into the",
    "start": "190480",
    "end": "196040"
  },
  {
    "text": "seam range um once TDX has initialized the TDX module executes only when it is",
    "start": "196040",
    "end": "202799"
  },
  {
    "text": "explicitly invoked and to do so there are two new instructions introduced in the CPU Sim call and simr uh so it's a",
    "start": "202799",
    "end": "209959"
  },
  {
    "text": "red couple that allows to jump in and out of the TDX module so the hypervisor can execute the Sim call instruction",
    "start": "209959",
    "end": "216640"
  },
  {
    "text": "that will cause the CPU to jump into the TDX module and then when the TDX module executes Sim R the CPU jumps back to the",
    "start": "216640",
    "end": "223959"
  },
  {
    "text": "hypervisor in terms of privileges the TDX module uh runs in a privilege mode",
    "start": "223959",
    "end": "230319"
  },
  {
    "text": "that is similar to the normal mode it just has access to the Sim range in addition uh so if you represent as a",
    "start": "230319",
    "end": "236879"
  },
  {
    "text": "timeline you first have the hypervisor running in mode in standard mode when it executes the Simon instruction the CPU",
    "start": "236879",
    "end": "243760"
  },
  {
    "text": "jumps into the TDX module and switches to the TDX mode and here the Sim range",
    "start": "243760",
    "end": "249159"
  },
  {
    "text": "becomes accessible so the protected range in physical memory becomes accessible and when the TDX mod execut",
    "start": "249159",
    "end": "254720"
  },
  {
    "text": "Sim red the CPU JS back to the hypervisor switches back to host mode and here the Sim range becomes not",
    "start": "254720",
    "end": "260479"
  },
  {
    "text": "accessible anymore the Sim call instruction that allows to jump into the TDX module is",
    "start": "260479",
    "end": "266800"
  },
  {
    "text": "actually used to implement an interface that resembles cisal on traditional",
    "start": "266800",
    "end": "271919"
  },
  {
    "text": "kernels so before executing the simal instruction the hypervisor can set a specific value value in Array X to",
    "start": "271919",
    "end": "279000"
  },
  {
    "text": "select a command then it populates the rest of the registers with some parameters when it executes Sim C the",
    "start": "279000",
    "end": "285320"
  },
  {
    "text": "CPU jumps into the TDX module and here the TDX module dispatches the command selected in Array X using the parameters",
    "start": "285320",
    "end": "292639"
  },
  {
    "text": "supplied in the rest of the registers um so it's pretty much similar to way to the cisal",
    "start": "292639",
    "end": "300199"
  },
  {
    "text": "interface on normal kernels it's just called Sim here but it's the same principle there are around 80 commands",
    "start": "300199",
    "end": "306880"
  },
  {
    "text": "implemented in the TDX module so at cisal if you want most of which have to do with guas management so there's a",
    "start": "306880",
    "end": "313000"
  },
  {
    "text": "command to create a guess there's a command to assign memory to a guest for example and so on and eventually there's",
    "start": "313000",
    "end": "318720"
  },
  {
    "text": "a command to run the guest that last command run the guest is uh where the",
    "start": "318720",
    "end": "324800"
  },
  {
    "text": "guest runs for real on the CPU so if we represent as a timeline you first have the hypervisor executing in hor mode it",
    "start": "324800",
    "end": "331039"
  },
  {
    "text": "executes the same instruction to invoke the command run the guest in the TDX module so the CPU jumps into the TDX",
    "start": "331039",
    "end": "337240"
  },
  {
    "text": "module the TDX mod dispatches the command and then performs a VM launch and that's where the CPU jumps into the",
    "start": "337240",
    "end": "343800"
  },
  {
    "text": "guest and starts running the guest for real so the guest executes at some point the VM exit ures so the CPU jumps back",
    "start": "343800",
    "end": "351360"
  },
  {
    "text": "to the TDX module and then the TDX module in turn executes Sim R so the CPU",
    "start": "351360",
    "end": "356520"
  },
  {
    "text": "jumps back to the hypervisor uh that's the full workflow of how guests are run in the new TDX",
    "start": "356520",
    "end": "364600"
  },
  {
    "text": "architecture so now that we have presented the basics of the TDX module there are two questions that arise when",
    "start": "364600",
    "end": "370759"
  },
  {
    "text": "we look at it from a security point of view the first is where do we actually look for vulnerabilities in this new",
    "start": "370759",
    "end": "375880"
  },
  {
    "text": "architecture so there are two natural um attack surfaces that I highlighted in",
    "start": "375880",
    "end": "381599"
  },
  {
    "text": "red here uh the the hypervisor to TDX module and the guest to TDX module uh",
    "start": "381599",
    "end": "387440"
  },
  {
    "text": "these are two security boundaries that the guess that the TDX mod has to protect and in this talk I'm going to",
    "start": "387440",
    "end": "394479"
  },
  {
    "text": "talk about only the hypervisor to TDX one and the attack scenario is the one that I mentioned earlier which is that",
    "start": "394479",
    "end": "400360"
  },
  {
    "text": "if the hypervisor gets compromised then does TDX truly protect the customer data",
    "start": "400360",
    "end": "406120"
  },
  {
    "text": "here so that the that's the attack scenario we're going to keep in mind here then the second question that that",
    "start": "406120",
    "end": "412000"
  },
  {
    "text": "arises when we look at TDX from a security point of view is how do we actually execute the TDX modle if we",
    "start": "412000",
    "end": "417879"
  },
  {
    "text": "want to exercise it or to it typically uh so to to execute a TX module you have",
    "start": "417879",
    "end": "423360"
  },
  {
    "text": "to have a new physical machine that has the latest Intel generation CPUs that",
    "start": "423360",
    "end": "428560"
  },
  {
    "text": "supports TDX right now that means a future machine because they're not available in the market yet once you",
    "start": "428560",
    "end": "434879"
  },
  {
    "text": "have that set up you have to have um a setup where you execute the Sim call instruction to try to invoke commands in",
    "start": "434879",
    "end": "440960"
  },
  {
    "text": "the TDX module to try to fuzz it for example the problem is that uh in that",
    "start": "440960",
    "end": "447120"
  },
  {
    "text": "environment you can't attach debugger to the TDX module so you can't debug it you don't have access to the register States",
    "start": "447120",
    "end": "453520"
  },
  {
    "text": "and to the memory uh and so your life is very difficult if you try to execute the",
    "start": "453520",
    "end": "458560"
  },
  {
    "text": "TDX module for real with that in mind we started developing at Microsoft a quick tool",
    "start": "458560",
    "end": "465080"
  },
  {
    "text": "that we called Cornelius that allows that was initially just a toy uh but it turned it into a full emulation",
    "start": "465080",
    "end": "471840"
  },
  {
    "text": "framework uh that allows to run the TDX module so the firmware as a VM without",
    "start": "471840",
    "end": "477639"
  },
  {
    "text": "having TDX Hardware um in that environment we have full",
    "start": "477639",
    "end": "483440"
  },
  {
    "text": "introspection capabilities of course because we control the VM in which the firmware runs so we have access to the",
    "start": "483440",
    "end": "490199"
  },
  {
    "text": "memory and to the registers um and we even went the extra mile of developing support for sanitizers on the TDX module",
    "start": "490199",
    "end": "498400"
  },
  {
    "text": "specifically we support asan uban and sanov uh assisted by our Cornelius",
    "start": "498400",
    "end": "505280"
  },
  {
    "text": "emulator so with Cornelius uh we basically went from having a very difficult life with physical machines to",
    "start": "505280",
    "end": "511360"
  },
  {
    "text": "having a very easy life now uh because we're now able to run the TDX module in",
    "start": "511360",
    "end": "516959"
  },
  {
    "text": "a VM uh without having TDX hardware and with full inspection capabilities and",
    "start": "516959",
    "end": "522440"
  },
  {
    "text": "sanitizers so it's a perfect environment to do security research I had a quick demo to Showcase",
    "start": "522440",
    "end": "528480"
  },
  {
    "text": "how it works not much to see it's just a demonstrator that we wrote that executes",
    "start": "528480",
    "end": "533760"
  },
  {
    "text": "that executes several commands in the TDX module and they all execute successfully that's all if we zoom in at",
    "start": "533760",
    "end": "539519"
  },
  {
    "text": "the end I said that we support sanitizers and specifically we support sandov the coverage sanitizer so if you",
    "start": "539519",
    "end": "545760"
  },
  {
    "text": "zoom in at the end uh kelus dumped the coverage count and in this case there were four CPUs on which the TDX module",
    "start": "545760",
    "end": "553360"
  },
  {
    "text": "run in the VM and we executed most commands on CPU number zero and so that's why it has a higher coverage",
    "start": "553360",
    "end": "559680"
  },
  {
    "text": "count which makes sense uh so anyway it's just to demonstrate that it works I'll come back to Cornelius in an",
    "start": "559680",
    "end": "567040"
  },
  {
    "text": "instant so now that we know which a tax phas to look for and now that we have our execution environment to First the",
    "start": "567040",
    "end": "573880"
  },
  {
    "text": "TDX module um we started looking for vulnerabilities uh in the TDX module and we realized early on that we're not",
    "start": "573880",
    "end": "580440"
  },
  {
    "text": "going to find easy vulnerabilities uh because there are overall good programming guidelines in the source",
    "start": "580440",
    "end": "586680"
  },
  {
    "text": "code so Intel performs extensive testing and they also use thetic analysis which",
    "start": "586680",
    "end": "591800"
  },
  {
    "text": "catches the vast majority of the bugs at the source code level then at the binary level uh the TDX modal also has good",
    "start": "591800",
    "end": "598680"
  },
  {
    "text": "mitigations so it has ROP to prevent uh it has Shadow stack sorry to prevent aop",
    "start": "598680",
    "end": "604839"
  },
  {
    "text": "it has IBT to prevent cop it has aslr uh proper information is on the pages the",
    "start": "604839",
    "end": "610800"
  },
  {
    "text": "stack cookies of course and so on so overall it's a good uh code quality for",
    "start": "610800",
    "end": "617640"
  },
  {
    "text": "a firmware much better than usual and so we realize that we're going to have to think harder than just looking for off",
    "start": "617640",
    "end": "624040"
  },
  {
    "text": "by ones in the source code so instead we started looking at more architectural",
    "start": "624040",
    "end": "629120"
  },
  {
    "text": "and um logical types of bugs and specifically at the context switching logic that takes place in the TDX",
    "start": "629120",
    "end": "636639"
  },
  {
    "text": "architecture so during the Sim calls and Sim RS to jump in and out of the TDX module the CPU has to perform a Contex",
    "start": "636639",
    "end": "644000"
  },
  {
    "text": "switch it means that it has to copy the values that are contained in the CPU resistors into memory so it saves them",
    "start": "644000",
    "end": "650120"
  },
  {
    "text": "to Memory and then it installs new values from memory into the CPU so if we",
    "start": "650120",
    "end": "655279"
  },
  {
    "text": "represent here and say that there's an Intel CPU with six registers um during the Sim call what happens is that the",
    "start": "655279",
    "end": "662920"
  },
  {
    "text": "values initially of the registers are the hypervisor values the CPU saves them to Memory and then it installs the",
    "start": "662920",
    "end": "669839"
  },
  {
    "text": "values of the TDX module into the CPU so that the CPU can then start executing with a safe set of initial registers so",
    "start": "669839",
    "end": "677480"
  },
  {
    "text": "that's how the CPU goes from having hypervisor values before the Sim C to having TDX module values after the S",
    "start": "677480",
    "end": "684519"
  },
  {
    "text": "call in uh the registers now the CPU does not actually Contex switch all of the registers uh",
    "start": "684519",
    "end": "691880"
  },
  {
    "text": "some of them need to be Contex switched manually by the TDX module itself in",
    "start": "691880",
    "end": "697360"
  },
  {
    "text": "software and that naturally naturally raises the question of does it do so correctly so we made a quick experiment",
    "start": "697360",
    "end": "704839"
  },
  {
    "text": "uh we know we knew that the xmm registers are switched neither by the CPU nor by the TDX module um and the",
    "start": "704839",
    "end": "712959"
  },
  {
    "text": "reason for that is that the TDX module doesn't use the XM register so it doesn't bother context switching them so",
    "start": "712959",
    "end": "718639"
  },
  {
    "text": "it means that the values persist when the hypervisor sets its own values in the Xmen registers they're not context",
    "start": "718639",
    "end": "724600"
  },
  {
    "text": "switched so after the Sim call the values are still there and the TDX modle executes with still the hypervisor",
    "start": "724600",
    "end": "730079"
  },
  {
    "text": "values loaded in the CPU and that's because the TDX modle doesn't use them so with that",
    "start": "730079",
    "end": "736480"
  },
  {
    "text": "observation we thought that well since uh the TDX module doesn't use xmm then",
    "start": "736480",
    "end": "742880"
  },
  {
    "text": "we can disable xmm in Cornelius right there shouldn't be a problem since the TDX module doesn't use this regist",
    "start": "742880",
    "end": "750120"
  },
  {
    "text": "so we made the change in Cornelius and we rerun the demonstrator that I showed you earlier and as soon as we run it we",
    "start": "750120",
    "end": "756120"
  },
  {
    "text": "see that in fact the TDX module crashes in the VM and the reason for that is",
    "start": "756120",
    "end": "761880"
  },
  {
    "text": "that the TDX module does actually use the xmm registers but forgets to Contex",
    "start": "761880",
    "end": "767360"
  },
  {
    "text": "switch them during the Sim calls and the simrs and that's a bug that could be a",
    "start": "767360",
    "end": "772880"
  },
  {
    "text": "vulnerability so if we show the full workflow what happens is that during the Sim course the values in the CPU persist",
    "start": "772880",
    "end": "780079"
  },
  {
    "text": "so they're not Contex switched and the TDX modle executes with the values still loaded at some point the TDX modle is",
    "start": "780079",
    "end": "786079"
  },
  {
    "text": "going to overwrite xmm Z for example with a new value that it has and then when it executes simr the value persists",
    "start": "786079",
    "end": "793279"
  },
  {
    "text": "again because there is no context switch and so the value goes back to the hypervisor so there are two impacts in",
    "start": "793279",
    "end": "799959"
  },
  {
    "text": "this bug the first impact is that whatever value the hypervisor initially had in xmm Z before the Sim actually",
    "start": "799959",
    "end": "807600"
  },
  {
    "text": "gets corrupted by the TDX module after the Sim call so if the hypervisor had",
    "start": "807600",
    "end": "812680"
  },
  {
    "text": "typically stored a pointer in that register and then tries to deference that pointer then there could be Memory",
    "start": "812680",
    "end": "817920"
  },
  {
    "text": "corruption in the hypervisor uh so that's the first impact State corruption",
    "start": "817920",
    "end": "823440"
  },
  {
    "text": "possible State corruption in the hypervisor and then the second impact which is more interesting for us is that",
    "start": "823440",
    "end": "828959"
  },
  {
    "text": "whatever value the the TDX module wrote in xmm0 actually persisted during the simr",
    "start": "828959",
    "end": "835240"
  },
  {
    "text": "and actually therefore leaked to the hypervisor and so if the T X module had actually stored a guest secret in the",
    "start": "835240",
    "end": "842000"
  },
  {
    "text": "xmm zero register then that secret leaks back to the hypervisor during the simr",
    "start": "842000",
    "end": "847680"
  },
  {
    "text": "and so that's the second impact possible information disclosure um so two impacts",
    "start": "847680",
    "end": "853440"
  },
  {
    "text": "for that bug we realized after more investigation that the second impact was",
    "start": "853440",
    "end": "858600"
  },
  {
    "text": "not happening in practice because in practice the TDX module um does not",
    "start": "858600",
    "end": "864000"
  },
  {
    "text": "store guest secrets in the xmm registers so even though the xmm registers lck back to the hyperv",
    "start": "864000",
    "end": "869800"
  },
  {
    "text": "they don't contain secrets that are worth like bothering with so Intel fixed",
    "start": "869800",
    "end": "874959"
  },
  {
    "text": "the bug as a functional bug and not as a security bug because it was not an information disclosure technically which",
    "start": "874959",
    "end": "880600"
  },
  {
    "text": "makes sense um but it's a bug we found in only 20 seconds uh 10 seconds to get",
    "start": "880600",
    "end": "886519"
  },
  {
    "text": "the idea of disabling xmm and then 10 seconds to rerun Cornelius without xmm",
    "start": "886519",
    "end": "892000"
  },
  {
    "text": "and see that the TDX module crashes so 20 seconds to find a bug that could have been potentially critical if the second",
    "start": "892000",
    "end": "898320"
  },
  {
    "text": "impact had materialized so that's a pretty much that's a very good return on investment",
    "start": "898320",
    "end": "904440"
  },
  {
    "text": "and so we started digging deeper into the context switching logic in the hope of finding more bugs um so we did find",
    "start": "904440",
    "end": "912040"
  },
  {
    "text": "increasingly more interesting bugs which were on the verge of being security issues but not quite um until we arrived",
    "start": "912040",
    "end": "918880"
  },
  {
    "text": "at a first critical vulnerability uh which was in the context switching of the processor Trace",
    "start": "918880",
    "end": "925399"
  },
  {
    "text": "registers so processor Trace is a tracing feature implemented in the CPU and the principle is that the CPU",
    "start": "925399",
    "end": "932360"
  },
  {
    "text": "records the execution of your software and creates a login memory that summarizes what your software did uh the",
    "start": "932360",
    "end": "939959"
  },
  {
    "text": "TDX modual supports processor Trace uh in guests so that the guests can run can",
    "start": "939959",
    "end": "946120"
  },
  {
    "text": "enable processor trace on themselves when they run in the TDX architecture processor Trace is",
    "start": "946120",
    "end": "952839"
  },
  {
    "text": "controlled by several registers uh two of which are important here the first is",
    "start": "952839",
    "end": "958120"
  },
  {
    "text": "the control register that has a trace enable bit and that's the main toggle to enable or disable processor Trace that's",
    "start": "958120",
    "end": "965240"
  },
  {
    "text": "the trace enable bit then the second register is the output base register uh it contains the physical address at",
    "start": "965240",
    "end": "972319"
  },
  {
    "text": "which the CPU is going to write the log in memory so typically if you want to enable processor Trace you first set the",
    "start": "972319",
    "end": "979279"
  },
  {
    "text": "address of a physical page in output base then you set Trace enable to one and from then on the CPU starts logging",
    "start": "979279",
    "end": "985440"
  },
  {
    "text": "the execution of your software and creates a log in memory at the address that you designated in the output base",
    "start": "985440",
    "end": "993279"
  },
  {
    "text": "register so if we look at the context switching uh that takes place for these two processor Trace registers there's",
    "start": "993279",
    "end": "999839"
  },
  {
    "text": "actually two context switches the first is during the Sim calls the CPU just the",
    "start": "999839",
    "end": "1005560"
  },
  {
    "text": "CPU doesn't perform a full context switch it just forces the value of Trace enable to zero uh it means it basically",
    "start": "1005560",
    "end": "1012880"
  },
  {
    "text": "Force disables processor Trace during the simle then when the TDX module per from",
    "start": "1012880",
    "end": "1019120"
  },
  {
    "text": "the VM launch into a guest this time a full context which takes place to install the values of the guest into the",
    "start": "1019120",
    "end": "1025600"
  },
  {
    "text": "CPU so that the guest can run with the values it wants so the hypervisor has its own values on the left uh the guest",
    "start": "1025600",
    "end": "1032520"
  },
  {
    "text": "has its own values on the right and the TDX module in the middle is in an intermediary state where Pro Trace is",
    "start": "1032520",
    "end": "1039600"
  },
  {
    "text": "just forc disabled now if you focus on the second context switch on the right side the VM",
    "start": "1039600",
    "end": "1044839"
  },
  {
    "text": "launch one um that's as I said the full context switch so the guest values are",
    "start": "1044839",
    "end": "1050880"
  },
  {
    "text": "in memory they are copied into the CPU and then the CPU is ready to start running the guest so if we represent U",
    "start": "1050880",
    "end": "1057840"
  },
  {
    "text": "so that's a context which do that is made not by the CPU but by the TDX",
    "start": "1057840",
    "end": "1062880"
  },
  {
    "text": "module itself in software so if we represent as a timeline you first have the guest executing the sorry the TDX",
    "start": "1062880",
    "end": "1069679"
  },
  {
    "text": "module executing uh so it's processing the command run theist uh as part of",
    "start": "1069679",
    "end": "1075760"
  },
  {
    "text": "processing that command it performs the contact switch here to install the two registers from memory into the CPU so it",
    "start": "1075760",
    "end": "1082120"
  },
  {
    "text": "copies them into the CPU and then at some point later it performs the VM launch which is where the guess starts",
    "start": "1082120",
    "end": "1087480"
  },
  {
    "text": "running uh now what's noticeable here is that there is actually a Time window",
    "start": "1087480",
    "end": "1092919"
  },
  {
    "text": "between the Contex switch and the VM launch uh when the contact switch is finished the TDX modle is actually still",
    "start": "1092919",
    "end": "1098360"
  },
  {
    "text": "executing the CPU hasn't yet jumped into the guest so that could create a theoretical",
    "start": "1098360",
    "end": "1105200"
  },
  {
    "text": "problem uh because what if the trace enabl bits on the right side in the in",
    "start": "1105200",
    "end": "1110400"
  },
  {
    "text": "memory State um is set to one if the tracing aable bit is set to one in",
    "start": "1110400",
    "end": "1115880"
  },
  {
    "text": "memory then when it gets copied into the CPU it's also set to one in the CPU and that means that processor Trace gets",
    "start": "1115880",
    "end": "1121760"
  },
  {
    "text": "enabled while the TDX modu still executes after the Contex switch and before the VM launch uh so that could be",
    "start": "1121760",
    "end": "1128760"
  },
  {
    "text": "a theoretical problem where process Trace could be enabled in the TDX module itself now in practice it's not supposed",
    "start": "1128760",
    "end": "1135159"
  },
  {
    "text": "to be the case uh because due to a complex set of interactions it there is",
    "start": "1135159",
    "end": "1141720"
  },
  {
    "text": "basically the guarantee that the inmemory state the inmemory value of the trace enable bit is always zero and so",
    "start": "1141720",
    "end": "1149000"
  },
  {
    "text": "when it when the context which occures the value zero gets copied into the CPU and therefore it's still zero in the CPU",
    "start": "1149000",
    "end": "1154559"
  },
  {
    "text": "and therefore processor Trace does not get enabled after the Contex switch",
    "start": "1154559",
    "end": "1159679"
  },
  {
    "text": "immediately so that's U an assumption that is correct to make and that we",
    "start": "1159679",
    "end": "1164720"
  },
  {
    "text": "verified and that holds overall except in one specific case uh which is on",
    "start": "1164720",
    "end": "1171480"
  },
  {
    "text": "debuggable guests so debuggable guests are a specific type of guest uh and it's",
    "start": "1171480",
    "end": "1176679"
  },
  {
    "text": "a type of guest for which the inmemory state on the right side is actually",
    "start": "1176679",
    "end": "1181799"
  },
  {
    "text": "accessible to the hypervisor and the hypervisor can write whatever values it wants into the inmemory state on the",
    "start": "1181799",
    "end": "1188240"
  },
  {
    "text": "right side that means that the assumption that the inmemory value of the Trac or bit uh the assumption that",
    "start": "1188240",
    "end": "1194840"
  },
  {
    "text": "this value is zero is actually wrong because the hypervisor could have it to one on a debuggable guest and if that",
    "start": "1194840",
    "end": "1202080"
  },
  {
    "text": "happens it means that the hypervisor can therefore enable processor traits in the TDX module because the value one then",
    "start": "1202080",
    "end": "1208400"
  },
  {
    "text": "gets copied into the CPU and from that on TDX processor Trace gets enabled in the TDX module so if we summarize as a",
    "start": "1208400",
    "end": "1216520"
  },
  {
    "text": "timeline you first have the TDX modu that executes performs the Contex switch to copy the pror trace registers from",
    "start": "1216520",
    "end": "1223640"
  },
  {
    "text": "memory into the CPU but here it could have been a guest",
    "start": "1223640",
    "end": "1229400"
  },
  {
    "text": "on which the hypervisor set Trace enabl to one and so it means that as soon as the Contex switch is finished proc the",
    "start": "1229400",
    "end": "1235440"
  },
  {
    "text": "trace gets enabled right away and therefore the the TDX module keeps executing what we've processor Trace",
    "start": "1235440",
    "end": "1241760"
  },
  {
    "text": "enabled before it jumps into the guest so there's a window here A Time window",
    "start": "1241760",
    "end": "1247559"
  },
  {
    "text": "during which the TDX module executes re procal trace and that's a window of of opportunity for us the",
    "start": "1247559",
    "end": "1254559"
  },
  {
    "text": "attackers so if we assemble the different pieces together I said that the the on debuggable guest uh the",
    "start": "1254559",
    "end": "1260919"
  },
  {
    "text": "hypervisor has access to the in memory state so it can control uh the output base register and the trace enable",
    "start": "1260919",
    "end": "1267240"
  },
  {
    "text": "register uh that means it can control the output base actually and therefore the hypervisor can decide where in",
    "start": "1267240",
    "end": "1273880"
  },
  {
    "text": "memory the log gets written to the log that the CPU is going to create so",
    "start": "1273880",
    "end": "1279000"
  },
  {
    "text": "that's number one number two there are actually additional processor Trace registers uh that exist that I didn't",
    "start": "1279000",
    "end": "1286720"
  },
  {
    "text": "mention uh but they allow to control what kind of data the CPU is going to write into the log uh and given that the",
    "start": "1286720",
    "end": "1294600"
  },
  {
    "text": "hypervisor has access to the inmemory state it can control the value of these registers and therefore it can control",
    "start": "1294600",
    "end": "1301200"
  },
  {
    "text": "what data the CPU is going to write into the log the log which is created at the",
    "start": "1301200",
    "end": "1306640"
  },
  {
    "text": "output base that the at the output Base address that the hypervisor also controls so that's number two and then",
    "start": "1306640",
    "end": "1313960"
  },
  {
    "text": "number three I said earlier that the TDX module executes in TDX mode and in that mode the seam range is actually",
    "start": "1313960",
    "end": "1320520"
  },
  {
    "text": "accessible the protected range in physical memory so that's number three if we assemble the different pieces",
    "start": "1320520",
    "end": "1326960"
  },
  {
    "text": "together we can see that in fact the hypervisor can set the output base register to point into the seam range",
    "start": "1326960",
    "end": "1334520"
  },
  {
    "text": "and by then enabling processor Trace into the TDX mod it can cause the CPU to",
    "start": "1334520",
    "end": "1339679"
  },
  {
    "text": "override the TDX memory with the procer trace log uh the log like the contents",
    "start": "1339679",
    "end": "1346159"
  },
  {
    "text": "of which are also controlled by the hypervisor so it means that the hypervisor",
    "start": "1346159",
    "end": "1351559"
  },
  {
    "text": "effectively has a right whatw primitive into the TDX memory and therefore it can",
    "start": "1351559",
    "end": "1357240"
  },
  {
    "text": "achieve full privilege escalation because it can overwrite the instruction by of the TDX module and inject its own",
    "start": "1357240",
    "end": "1364840"
  },
  {
    "text": "Shell Code and its own back door now what about aslr I mentioned earlier that the PDX module has good",
    "start": "1364840",
    "end": "1371520"
  },
  {
    "text": "mitigation and among other things it has aslr well in this case it doesn't really apply because aslr is only applied on",
    "start": "1371520",
    "end": "1378960"
  },
  {
    "text": "the virtual memory not the physical memory and here with our primitive we are actually overwriting the physical",
    "start": "1378960",
    "end": "1385720"
  },
  {
    "text": "memory which is not subject to eslr and is not randomized uh in other words the",
    "start": "1385720",
    "end": "1391600"
  },
  {
    "text": "hypervisor knows exactly where the TDX module is in memory and knows exactly where to override it where to overwrite",
    "start": "1391600",
    "end": "1398480"
  },
  {
    "text": "its instruction bites because there is no aslr so aslr is essentially useless in this",
    "start": "1398480",
    "end": "1405159"
  },
  {
    "text": "vulnerability so if we summarize the attack scenario if you have a cloud system that's running with TDX you have",
    "start": "1405159",
    "end": "1411039"
  },
  {
    "text": "a Target customer here that you would like to attack so an attacker takes like",
    "start": "1411039",
    "end": "1416919"
  },
  {
    "text": "compromises uh the cloud provider takes control of the hypervisor first step create a debuggable guest so that's just",
    "start": "1416919",
    "end": "1423760"
  },
  {
    "text": "going to be a dummy guest that is just debuggable for the purpose of exploiting the vulnerability then next step uh",
    "start": "1423760",
    "end": "1431039"
  },
  {
    "text": "exploit the vulnerability to escalate privileges into the TDX module via the debuggable guest by enabling processor",
    "start": "1431039",
    "end": "1437840"
  },
  {
    "text": "trace and overwriting the memory of the TDX module and then number three once uh",
    "start": "1437840",
    "end": "1443679"
  },
  {
    "text": "the the attacker controls the TDX module then it's trivial to exfiltrate the customer",
    "start": "1443679",
    "end": "1449320"
  },
  {
    "text": "data and so with this vulnerability we achieve a full defeat of the confidentiality promises made by",
    "start": "1449320",
    "end": "1457600"
  },
  {
    "text": "TDX so Intel assigned the following cve to the vulnerability uh they it's a vulnerability that affected all the",
    "start": "1457600",
    "end": "1464360"
  },
  {
    "text": "versions of the TDX module and Intel fixed the latest version so that's the first",
    "start": "1464360",
    "end": "1470480"
  },
  {
    "text": "vulnerability I wanted to present and it shows how we can defeat the confidentiality guarantees uh in the new",
    "start": "1470480",
    "end": "1476679"
  },
  {
    "text": "PDX architecture that is supposed to provide these guarantees there is then a second vulnerability which we found still in",
    "start": "1476679",
    "end": "1483600"
  },
  {
    "text": "the context switching logic but not this time not in the TDX module but in the CPU itself uh so I've been talking about the",
    "start": "1483600",
    "end": "1490679"
  },
  {
    "text": "simal instruction and how it's used to to implement an interface to jump into",
    "start": "1490679",
    "end": "1495799"
  },
  {
    "text": "the TDX module and invoke commands and so on uh now if we forget about the TDX module completely and focus only on the",
    "start": "1495799",
    "end": "1503120"
  },
  {
    "text": "very simple instruction itself if we look at the SoDo code",
    "start": "1503120",
    "end": "1508159"
  },
  {
    "text": "provided in the Intel specification there's something that is striking there's two things that are striking at the beginning the first thing is that",
    "start": "1508159",
    "end": "1515360"
  },
  {
    "text": "the Sim instruction is actually unconditionally recognized by the CPU uh it means that there is no toggle to",
    "start": "1515360",
    "end": "1521600"
  },
  {
    "text": "enable or disable it it's just that if the CPU supports TDX then it's going to unconditionally recognize the",
    "start": "1521600",
    "end": "1527799"
  },
  {
    "text": "instruction and anybody can execute it in the system uh that's weird because",
    "start": "1527799",
    "end": "1532919"
  },
  {
    "text": "normally um when a new CPU feature is introduced there's supposed to be a toggle to explicitly enable it before",
    "start": "1532919",
    "end": "1539039"
  },
  {
    "text": "using it it's not supposed to be enabled by default unconditionally so that's unusual but not a security problem at a",
    "start": "1539039",
    "end": "1546799"
  },
  {
    "text": "first site the the second thing that is striking in obodo code is that the Sim",
    "start": "1546799",
    "end": "1552600"
  },
  {
    "text": "call instruction has a VM exit reason Associated to it uh and so if we forget",
    "start": "1552600",
    "end": "1559320"
  },
  {
    "text": "about the whole TDX architecture and come back to the previous model where the hypervisor directly runs the guest",
    "start": "1559320",
    "end": "1565840"
  },
  {
    "text": "uh in that model um if the guest executes a privilege instruction uh the CPU performs a VM exit so it jumps back",
    "start": "1565840",
    "end": "1572919"
  },
  {
    "text": "to the hypervisor and it tells the hypervisor hey the guest dried to execute that instruction please emulate",
    "start": "1572919",
    "end": "1579760"
  },
  {
    "text": "it so Sim call has a VM exit reason Associated to it and that means that if",
    "start": "1579760",
    "end": "1585760"
  },
  {
    "text": "the guest executes the Sim call instruction then the CPU Trigg a VM exit jumps to the hypervisor and tells the",
    "start": "1585760",
    "end": "1591720"
  },
  {
    "text": "hypervisor hey um the guest just execute the Sim call instruction please emulate",
    "start": "1591720",
    "end": "1597159"
  },
  {
    "text": "it that's also weird and unusual because normally there should be a toggle here",
    "start": "1597159",
    "end": "1602760"
  },
  {
    "text": "to enable the VM exit also uh the VM exit is not supposed to be unconditionally uh raised uh by the",
    "start": "1602760",
    "end": "1611240"
  },
  {
    "text": "hardware by the CPU so that's weird again but still not a security problem at a first sight now if we now if we",
    "start": "1611240",
    "end": "1620200"
  },
  {
    "text": "think more about TDX I said that it's a new feature right so it's going to be available in future CPUs so but the",
    "start": "1620200",
    "end": "1627399"
  },
  {
    "text": "current hypervisors that exist on the market currently like hyperv and Linux KVM they don't know about TDX and they",
    "start": "1627399",
    "end": "1634279"
  },
  {
    "text": "don't know about the Sim call instruction either so what what would happen if the uh if a guest executes the",
    "start": "1634279",
    "end": "1642279"
  },
  {
    "text": "Sim call instruction but the hypervisor does not actually know about TDX and doesn't know about the Sim instruction and therefore doesn't recognize",
    "start": "1642279",
    "end": "1648880"
  },
  {
    "text": "the Sim VM exit well what happens in that case is that the hypervisor kills the guest because it doesn't know how",
    "start": "1648880",
    "end": "1656320"
  },
  {
    "text": "because if it doesn't know how to emulate the operation uh the default behavior is just to kill the",
    "start": "1656320",
    "end": "1661480"
  },
  {
    "text": "guest so that's interesting but still not a security problem at this point because it's only a self-denial of",
    "start": "1661480",
    "end": "1668960"
  },
  {
    "text": "service if the guest executes the Simon instruction and the hypervisor doesn't recognize it then the hypervisor kills",
    "start": "1668960",
    "end": "1675080"
  },
  {
    "text": "the guest so it's just a self-denial of service from the point of view so still not a security problem now things get",
    "start": "1675080",
    "end": "1682880"
  },
  {
    "text": "spicy when we think about nested utilization uh in an Ned scenario you have a hypervisor that runs a guest that",
    "start": "1682880",
    "end": "1690039"
  },
  {
    "text": "is itself another hypervisor that runs another guest inside of it in that",
    "start": "1690039",
    "end": "1695760"
  },
  {
    "text": "scenario if the nested guest down here executes the Sim call instruction the",
    "start": "1695760",
    "end": "1701640"
  },
  {
    "text": "CPU raises a VM exit to the outer hypervisor the one at the top um and if",
    "start": "1701640",
    "end": "1707840"
  },
  {
    "text": "the outer hypervisor doesn't recognize the Sim called Vian exit then it kills the whole guest which means it kills",
    "start": "1707840",
    "end": "1713840"
  },
  {
    "text": "both the guest hypervisor and all of the Ned guest underneath it so that's more",
    "start": "1713840",
    "end": "1720200"
  },
  {
    "text": "interesting uh we do at Microsoft in Asia just like other Cloud providers we",
    "start": "1720200",
    "end": "1725880"
  },
  {
    "text": "do use nested virtualization in certain scenarios such as containers so if you book a container on Asia you're going to",
    "start": "1725880",
    "end": "1732640"
  },
  {
    "text": "have access to a nested guest here guest number four for example uh and the rest of the guests nearby are going to be",
    "start": "1732640",
    "end": "1739640"
  },
  {
    "text": "other customers in the system uh so you can maybe sense now where the problem is for us with the SIM call instruction",
    "start": "1739640",
    "end": "1746840"
  },
  {
    "text": "it's that if a malicious customer guest number six for example executes the same",
    "start": "1746840",
    "end": "1752240"
  },
  {
    "text": "call instruction that generates a VM exit to the outer hypervisor but if the hypervisor doesn't recognize the S call",
    "start": "1752240",
    "end": "1758760"
  },
  {
    "text": "instruction then the hypervisor kills the whole guest which means it also kills all the other guests of the other",
    "start": "1758760",
    "end": "1764960"
  },
  {
    "text": "customers in the system so essentially by because of the fact that",
    "start": "1764960",
    "end": "1772360"
  },
  {
    "text": "the sinal instruction is unconditionally recognized we can have the case where a malicious customer guest number six here",
    "start": "1772360",
    "end": "1779440"
  },
  {
    "text": "can do a denial of service on a whole bunch of other customers in the cloud by just executing the Sim call",
    "start": "1779440",
    "end": "1786919"
  },
  {
    "text": "instruction what's more there's actually a second bug if you look at the rest of the pseudo code of the simol instruction",
    "start": "1786919",
    "end": "1794799"
  },
  {
    "text": "uh there is a PRI priority inversion so the simol instruction is supposed to be executable only from kernel mode not",
    "start": "1794799",
    "end": "1800760"
  },
  {
    "text": "from user mode the problem is that in that SoDo code there is a priority inversion the privilege check is takes",
    "start": "1800760",
    "end": "1808880"
  },
  {
    "text": "place after the VM exit so the VM exit occurs before and so if the guest",
    "start": "1808880",
    "end": "1814320"
  },
  {
    "text": "execute Sim call in user mode then the VM exit o the VM exit occurs and the",
    "start": "1814320",
    "end": "1820360"
  },
  {
    "text": "privilege check in practice never takes place and so it means that in the",
    "start": "1820360",
    "end": "1825760"
  },
  {
    "text": "previous vulnerability uh when the malicious customers executed the Sim call it doesn't even have to be in",
    "start": "1825760",
    "end": "1830960"
  },
  {
    "text": "kernel mode to execute the Sim call instruction it can directly execute it from user mode and that's going to work",
    "start": "1830960",
    "end": "1836559"
  },
  {
    "text": "that's going to raise the VM exit that is going to lead the hypervisor to kills the to kill the whole guests um so that",
    "start": "1836559",
    "end": "1843120"
  },
  {
    "text": "makes that that second mistake in the specification makes the first vulnerability even easier to",
    "start": "1843120",
    "end": "1850360"
  },
  {
    "text": "exploit so in terms of affected systems uh we're talking about the case where",
    "start": "1850360",
    "end": "1856440"
  },
  {
    "text": "the hypervisor doesn't know about TDX doesn't recognize the Sim call VM exits",
    "start": "1856440",
    "end": "1861760"
  },
  {
    "text": "uh so that's a case that would typically be a future setup where you have an old",
    "start": "1861760",
    "end": "1867200"
  },
  {
    "text": "hypervisor running on New Intel TDX hardware and it's the combination of old hypervisor new hardware that creates the",
    "start": "1867200",
    "end": "1874360"
  },
  {
    "text": "denial of service condition here uh because of the fact that the new hardware raises a VM exit that the old",
    "start": "1874360",
    "end": "1880159"
  },
  {
    "text": "software doesn't recognize that's a setup that actually exists a lot in the cloud for various reasons having an old",
    "start": "1880159",
    "end": "1887559"
  },
  {
    "text": "hyperv on new hardware specifically when we migrate existing systems existing",
    "start": "1887559",
    "end": "1893320"
  },
  {
    "text": "software on new hardware uh we can end up in the situation with old hypervisor and new hardware that would have led to",
    "start": "1893320",
    "end": "1900760"
  },
  {
    "text": "a denial of service here so Intel D service vulnerability so Intel assigned",
    "start": "1900760",
    "end": "1906519"
  },
  {
    "text": "the following CV to the vulnerability and they issued a micr code update to fix half of the problem so the micr code",
    "start": "1906519",
    "end": "1912919"
  },
  {
    "text": "update fixes the priority inversion to make sure that the privilege check takes place before the VM exit uh but they",
    "start": "1912919",
    "end": "1920440"
  },
  {
    "text": "didn't fix the bigger issue which is that the S instruction is just",
    "start": "1920440",
    "end": "1925559"
  },
  {
    "text": "unconditionally recognized by the hardware and the VM exit can unconditionally occur too so they're not",
    "start": "1925559",
    "end": "1931039"
  },
  {
    "text": "going to fix it in hardware and instead uh you have to apply a software fix so",
    "start": "1931039",
    "end": "1937039"
  },
  {
    "text": "basically the hypervisors have to be updated to just recognize the Sim C VM exit and not not kill the guests in such",
    "start": "1937039",
    "end": "1944200"
  },
  {
    "text": "case so that's a change we actually made preemptively at Microsoft soft in hyperv a year ago uh we made a change in hyperv",
    "start": "1944200",
    "end": "1952000"
  },
  {
    "text": "for it to just recognize the SLE VM exit and not kill the guests uh and we pushed",
    "start": "1952000",
    "end": "1957320"
  },
  {
    "text": "the change uh via Windows update like six months ago so if you've been running Windows uh you already have the fix uh",
    "start": "1957320",
    "end": "1965480"
  },
  {
    "text": "to prevent the denial of service but now the other hypervisors will also have to",
    "start": "1965480",
    "end": "1970679"
  },
  {
    "text": "be updated so Linux KVM for example uh also has to be updated to recognize the Sim C VM exit and not kill the guest all",
    "start": "1970679",
    "end": "1977840"
  },
  {
    "text": "otherwise we're going to get um the N service conditions so that's all for the two",
    "start": "1977840",
    "end": "1985000"
  },
  {
    "text": "vulnerabilities uh I wanted to present and that's how the whole TDX",
    "start": "1985000",
    "end": "1990360"
  },
  {
    "text": "architecture works and the security guarantees that it has we have now published a white paper uh that is a",
    "start": "1990360",
    "end": "1996840"
  },
  {
    "text": "partnership between Microsoft and Intel and it summarizes our security research or findings or",
    "start": "1996840",
    "end": "2003080"
  },
  {
    "text": "methodology uh we had overall 21 findings uh six of which were confir vulnerabilities so I talked about two",
    "start": "2003080",
    "end": "2009480"
  },
  {
    "text": "here but there's four more my colleagues at blue hat Israel at",
    "start": "2009480",
    "end": "2015399"
  },
  {
    "text": "Microsoft Israel uh made a talk at blue hat a few months ago to present two other vulnerabilities uh and so here's",
    "start": "2015399",
    "end": "2022399"
  },
  {
    "text": "the YouTube link and Intel has also now published a blog post that summarizes the partnership between Microsoft and",
    "start": "2022399",
    "end": "2028799"
  },
  {
    "text": "Intel on the PDX technology and on the security of continential Computing in the",
    "start": "2028799",
    "end": "2033880"
  },
  {
    "text": "future the Cornelius uh framework that we developed to that allows to run the TDX module as a",
    "start": "2033880",
    "end": "2040120"
  },
  {
    "text": "VM is also open for now so we published it on the Microsoft GitHub um if you're",
    "start": "2040120",
    "end": "2045519"
  },
  {
    "text": "interested feel free to have a look if you have any feedback or want to contribute also as I said it's a great",
    "start": "2045519",
    "end": "2051480"
  },
  {
    "text": "tool it makes it very easy to do security evaluation of the TDX module because you don't even need to have TDX",
    "start": "2051480",
    "end": "2056878"
  },
  {
    "text": "Hardware you can directly run it as a VM with sanitizers with full inpection",
    "start": "2056879",
    "end": "2062040"
  },
  {
    "text": "capabilities so very easy to do security research overall the TDX module and the",
    "start": "2062040",
    "end": "2067839"
  },
  {
    "text": "whole TDX architecture actually uh is a very interesting Target to look at uh as I said the TDX modle is open source so",
    "start": "2067839",
    "end": "2075040"
  },
  {
    "text": "uh it's easy to review it for security vulnerabilities uh it was written with security in mind",
    "start": "2075040",
    "end": "2080839"
  },
  {
    "text": "and finding bugs in it is hard at the source code level and then at the binary level it also has good mitigations as I",
    "start": "2080839",
    "end": "2087158"
  },
  {
    "text": "said so the combination of all of that makes it a very good intellectual exercise if you are a security",
    "start": "2087159",
    "end": "2093079"
  },
  {
    "text": "researcher and want to have a look at a new Target fin Intel has a bug program",
    "start": "2093079",
    "end": "2099720"
  },
  {
    "text": "that does cover the TDX module and so it means that you can typically write your",
    "start": "2099720",
    "end": "2104800"
  },
  {
    "text": "own fer based on Cornelius that we have now open sourced you can find bugs with it report them sell them and get money",
    "start": "2104800",
    "end": "2112040"
  },
  {
    "text": "out of it uh so TDX is also a good business opportunity for us security researchers in addition to being a good",
    "start": "2112040",
    "end": "2119240"
  },
  {
    "text": "intellectual exercise that's all thanks [Applause]",
    "start": "2119240",
    "end": "2127839"
  },
  {
    "text": "night",
    "start": "2127839",
    "end": "2130839"
  }
]