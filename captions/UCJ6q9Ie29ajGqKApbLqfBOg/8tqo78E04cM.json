[
  {
    "start": "0",
    "end": "111000"
  },
  {
    "text": "hello everyone my name is Matteo Utrecht and today I will be talking about my latest project called the box pol",
    "start": "30",
    "end": "6330"
  },
  {
    "text": "reloaded which is using x86 emulation and stained tracking to disclose to",
    "start": "6330",
    "end": "11370"
  },
  {
    "text": "discover this closure of initialized memory in operating system kernels so the agenda for today is first off to",
    "start": "11370",
    "end": "18990"
  },
  {
    "text": "briefly start discussing the communication between user and kernel mode in operating systems and what are",
    "start": "18990",
    "end": "24990"
  },
  {
    "text": "the common pitfalls that are related to them and then introduce the box pawn reloaded project the principles behind",
    "start": "24990",
    "end": "32308"
  },
  {
    "text": "it how it works in general and how it uses the full system emulation to",
    "start": "32309",
    "end": "37320"
  },
  {
    "text": "discover any kind of bugs then I will talk about the system specific",
    "start": "37320",
    "end": "42360"
  },
  {
    "text": "approaches which are specific to both Windows and Linux which are the two operating systems that I analyzed I will",
    "start": "42360",
    "end": "49020"
  },
  {
    "text": "talk about the results in in those operating systems and then wrap up with some ideas for future work on how this",
    "start": "49020",
    "end": "55590"
  },
  {
    "text": "project can be extended and improved and how we can deal with this type of issues in the future a few words about myself I",
    "start": "55590",
    "end": "64500"
  },
  {
    "text": "am a low-level security researcher interest obviously in all sorts of vulnerability research and software",
    "start": "64500",
    "end": "70260"
  },
  {
    "text": "exploitation I work at freedom 0 at Google in my spare time I place in CDF's",
    "start": "70260",
    "end": "75750"
  },
  {
    "text": "as part of the dragon sector team and I have a blog and Twitter where I post some of my research as well so yeah",
    "start": "75750",
    "end": "82530"
  },
  {
    "text": "let's start with with some basics very quickly about user and kernel communication so as you all know user",
    "start": "82530",
    "end": "89220"
  },
  {
    "text": "applications run independently of other programs and independently of the kernel and whenever they actually want to do",
    "start": "89220",
    "end": "96450"
  },
  {
    "text": "something in the operating system they call into the kernel to request the operation that they want to do and when",
    "start": "96450",
    "end": "102840"
  },
  {
    "text": "they do it the ring free memory which is a shared memory between the user and kernel mode is used as the exchange data",
    "start": "102840",
    "end": "109500"
  },
  {
    "text": "exchange channel so this is how it looks on a simple graph so we have the user",
    "start": "109500",
    "end": "115259"
  },
  {
    "start": "111000",
    "end": "111000"
  },
  {
    "text": "mode program which wants to perform some operations so it writes input data to the shirt user mode memory then in it",
    "start": "115259",
    "end": "122610"
  },
  {
    "text": "invokes the system called which transfers execution to the system kernel which then reads the input data performs",
    "start": "122610",
    "end": "129209"
  },
  {
    "text": "some logic writes output beta back and returns to user space then the use program reads the output data back and",
    "start": "129209",
    "end": "135660"
  },
  {
    "text": "operates on it so in this presentation we're mostly interested in these two stages of the system kernel first",
    "start": "135660",
    "end": "142050"
  },
  {
    "text": "reading input data and then writing output data and especially in the in the second part so let's imagine in a",
    "start": "142050",
    "end": "149460"
  },
  {
    "text": "perfect world where the kernel doesn't have any bugs so we would like in this",
    "start": "149460",
    "end": "155160"
  },
  {
    "text": "perfect word for the kernel to only read every memory unit once within the scope",
    "start": "155160",
    "end": "161190"
  },
  {
    "text": "of a system call and then write to it also at most once after it is done with",
    "start": "161190",
    "end": "166680"
  },
  {
    "text": "all of the system call logic do it in a secure manner and only write the data that is intended for user mode so that",
    "start": "166680",
    "end": "173370"
  },
  {
    "text": "is the state of the perfect world that we could imagine but of course we have free LT instead so these assumptions",
    "start": "173370",
    "end": "181050"
  },
  {
    "text": "that I mentioned can be broken in in a number of ways so for example we can break the assumption that every memory",
    "start": "181050",
    "end": "187290"
  },
  {
    "text": "unit is read from at most once it may happen that memory is actually read most",
    "start": "187290",
    "end": "193350"
  },
  {
    "text": "and more than once this was the subject of the original box boom research that we performed four years ago we've been",
    "start": "193350",
    "end": "199470"
  },
  {
    "text": "very cold wind and the possible violation is that we have two or more fetches from user mode memory which may",
    "start": "199470",
    "end": "206310"
  },
  {
    "text": "allow some race conditions to break code assumptions which can lead to buffer overflows right what with work",
    "start": "206310",
    "end": "213239"
  },
  {
    "text": "conditions arbitrary it's all kind of badness so these this original research",
    "start": "213239",
    "end": "218340"
  },
  {
    "text": "resulted in discovering more than 40 vulnerabilities in Windows and yeah so",
    "start": "218340",
    "end": "225709"
  },
  {
    "text": "we wrote quite a few papers on this subject on both trying to find these kind of double fetters and also exploit",
    "start": "225709",
    "end": "232650"
  },
  {
    "text": "them this research was also presented here at blackhat we can also break the",
    "start": "232650",
    "end": "239370"
  },
  {
    "text": "other assumptions in a number of ways so for example we can have like unprotected accesses to user mode pointers in the",
    "start": "239370",
    "end": "245610"
  },
  {
    "text": "kernel we can have multiple writes to a single memory area which can also indicate that something fishy's going on",
    "start": "245610",
    "end": "251910"
  },
  {
    "text": "in the kernel we can have reading from the user mode address after already having written to it which is also kind",
    "start": "251910",
    "end": "258510"
  },
  {
    "text": "of fishy because why would a kernel do it and there are some other behaviors",
    "start": "258510",
    "end": "263910"
  },
  {
    "text": "which can raise an eyebrow for example accessing ring memory within very deeply nested skull",
    "start": "263910",
    "end": "269500"
  },
  {
    "text": "stacks or with the first enabled exception hands are very high optical stack these are also some some weird",
    "start": "269500",
    "end": "275830"
  },
  {
    "text": "behaviors that could happen but the subject of this talk is actually this part about only writing data that is",
    "start": "275830",
    "end": "282250"
  },
  {
    "text": "intended to be used by user mode so that's what we will focus on so writing",
    "start": "282250",
    "end": "287590"
  },
  {
    "start": "286000",
    "end": "286000"
  },
  {
    "text": "data to use during 3 happens in general in 4 different cases so we have system",
    "start": "287590",
    "end": "293770"
  },
  {
    "text": "calls which exist in all operating systems that were interested in we have IO CDLs which are also a special case of",
    "start": "293770",
    "end": "300100"
  },
  {
    "text": "sis calls but they have often dedicated output mechanisms so we can consider them differently a little bit we have",
    "start": "300100",
    "end": "306850"
  },
  {
    "text": "user mode callbacks which are a mechanism which is specific to Windows and win 32k graphical subsystem and we",
    "start": "306850",
    "end": "314410"
  },
  {
    "text": "finally have exception handling where the kernel has to build an exception frame on the user mode stack so then it",
    "start": "314410",
    "end": "321370"
  },
  {
    "text": "also writes to the user mode memory so let's let's go back a little bit and",
    "start": "321370",
    "end": "326890"
  },
  {
    "start": "323000",
    "end": "323000"
  },
  {
    "text": "think about where when writing initialized memory or some kind of unintended memory to user mode can",
    "start": "326890",
    "end": "333670"
  },
  {
    "text": "happen so we have this easy problem on the example of a fake Windows system call implementation here of writing an",
    "start": "333670",
    "end": "341050"
  },
  {
    "text": "initialized value of a primitive type variable so here we have a system call which calculates the multiplication of 2",
    "start": "341050",
    "end": "348670"
  },
  {
    "text": "of a value and of course as we can see the local output value is not initialized if input value is equal to 0",
    "start": "348670",
    "end": "355570"
  },
  {
    "text": "so then we are leaking for or yeah basically for 4 bytes of initialized kernel stack memory back to user mode so",
    "start": "355570",
    "end": "362980"
  },
  {
    "text": "this of course can happen and will happen but this is not not as bad as it",
    "start": "362980",
    "end": "368440"
  },
  {
    "text": "seems because first of all it's it's not a very trivial bug to make for developers compilers will often warn",
    "start": "368440",
    "end": "374920"
  },
  {
    "text": "about instances of such issues it doesn't leak too much information because it's just a single variable and",
    "start": "374920",
    "end": "380620"
  },
  {
    "text": "it very well may be detected during development as well because it may be a functional part so this is not not so",
    "start": "380620",
    "end": "386770"
  },
  {
    "text": "bad but we have many many other definitely harder problems so first of all we have structures and unions which",
    "start": "386770",
    "end": "393070"
  },
  {
    "text": "are used in C and C++ so here in this example we have a structure who has which has three fields which are being",
    "start": "393070",
    "end": "399250"
  },
  {
    "text": "used to output some user mode so the two of them - two of",
    "start": "399250",
    "end": "404860"
  },
  {
    "text": "the fields in this structure and are initialized because they are used by the system call but the third one is",
    "start": "404860",
    "end": "409990"
  },
  {
    "text": "reserved so it's not honest it's not initialized by default kind of by design but still it's allocated in the kernel",
    "start": "409990",
    "end": "417790"
  },
  {
    "text": "stack and it still output back to user mode so it's leaking some some data within that fuel furthermore we have",
    "start": "417790",
    "end": "425980"
  },
  {
    "text": "unions which can have fields and you know types of fields that have different",
    "start": "425980",
    "end": "431560"
  },
  {
    "text": "sizes so here you can see that we have one D word and one Q word and only the D",
    "start": "431560",
    "end": "436600"
  },
  {
    "text": "word is initialized here which leaves the other four bytes unutilized and they are also leaked back to user mode in the",
    "start": "436600",
    "end": "443020"
  },
  {
    "text": "in the annualized state and furthermore we have structures which have padding",
    "start": "443020",
    "end": "449860"
  },
  {
    "text": "holes inside so we have a D word followed by a Q word but since the key word has to be 8 byte aligned the compiler inserts a pairing",
    "start": "449860",
    "end": "457150"
  },
  {
    "text": "whole of 4 bytes which in this code are also not initialized properly and output to user mode so we have as I said",
    "start": "457150",
    "end": "466360"
  },
  {
    "text": "different problems related to the structures and unions first of all they are usually copied in memory entirely",
    "start": "466360",
    "end": "472000"
  },
  {
    "text": "using functions such as mem copy and size is calculated by the sizeof operator they have often many fields so",
    "start": "472000",
    "end": "480490"
  },
  {
    "text": "it's either easy to forget about about setting some of them or they may be and not set by design we have padding halls",
    "start": "480490",
    "end": "488440"
  },
  {
    "text": "we have as I said different sizes and unions and worst of all compilers don't",
    "start": "488440",
    "end": "493840"
  },
  {
    "text": "really have too much inside into structures especially when they are dynamically allocated from the heap or pools and also because of the fact that",
    "start": "493840",
    "end": "501280"
  },
  {
    "text": "they are often copied using functions such as mem copy then we have another problem related to fixed size erase so",
    "start": "501280",
    "end": "508660"
  },
  {
    "text": "here we have an example of a system call which returns the path to the system on",
    "start": "508660",
    "end": "514960"
  },
  {
    "text": "file system and as you can see we have this huge array which is allocated from",
    "start": "514960",
    "end": "520000"
  },
  {
    "text": "the stack but it's only partially initialized with with the relevant string that we want to return but the",
    "start": "520000",
    "end": "525910"
  },
  {
    "text": "kernel still returns the whole array with more than 200 initialized bytes",
    "start": "525910",
    "end": "531690"
  },
  {
    "text": "inside and we have a lot of instances of such long fixed size buffers in a window in",
    "start": "531690",
    "end": "538460"
  },
  {
    "text": "the Windows kernel which are used in the exchange of data between user and kernel mode they used for paths in the file",
    "start": "538460",
    "end": "544760"
  },
  {
    "text": "system for names identifiers etc and most most often even though these",
    "start": "544760",
    "end": "550850"
  },
  {
    "text": "buffers are fixed in size the length of the content inside is variable and usually most of the storage used by the",
    "start": "550850",
    "end": "558500"
  },
  {
    "text": "array is actually not not used at all so and the other problem is that these",
    "start": "558500",
    "end": "563630"
  },
  {
    "text": "these arrays are often part of structures which are which makes it even harder to only copy the relevant part of",
    "start": "563630",
    "end": "570050"
  },
  {
    "text": "the string to user mode so and also the bad thing about this is that since the",
    "start": "570050",
    "end": "575420"
  },
  {
    "text": "yes array can be very huge they can also leak a lot of data from the kernel to the user space at once and",
    "start": "575420",
    "end": "582010"
  },
  {
    "text": "then we have yet another problem which is kind of specific to Windows but not",
    "start": "582010",
    "end": "587120"
  },
  {
    "text": "not not only so even though we have this system call which only returns 12 bytes",
    "start": "587120",
    "end": "593870"
  },
  {
    "text": "in total in three magic D words it allows the user mode color to specify",
    "start": "593870",
    "end": "599660"
  },
  {
    "text": "the length of the output buffer and it allocates a number of bytes that is requested by the user a mode color and",
    "start": "599660",
    "end": "607130"
  },
  {
    "text": "even though it only writes a limited number of bytes into the buffer it copies this use this kernel mode buffer",
    "start": "607130",
    "end": "613430"
  },
  {
    "text": "in a hole back to user mode so we also end up with a lot of uninitialized data",
    "start": "613430",
    "end": "618620"
  },
  {
    "text": "here this is also very common in Windows as I said and the interesting thing",
    "start": "618620",
    "end": "624620"
  },
  {
    "text": "about this is that it this this kind of bug may actually enable disclosure from both the stack and the heap in the same",
    "start": "624620",
    "end": "630860"
  },
  {
    "text": "affected code because of the fact that Windows uses an optimization so for small request sizes it uses stack",
    "start": "630860",
    "end": "637130"
  },
  {
    "text": "buffers and for a larger one it uses heap allocations in many cases and it",
    "start": "637130",
    "end": "642830"
  },
  {
    "text": "often leads to large leaks of control number of bytes and the worst thing is",
    "start": "642830",
    "end": "648770"
  },
  {
    "text": "that in this particular case it could be possible for the user to actually be",
    "start": "648770",
    "end": "654170"
  },
  {
    "text": "able to specify that the size of the allocation that is being leaked so it may enable the attacker to try to",
    "start": "654170",
    "end": "661010"
  },
  {
    "text": "collide with interesting objects in kernel mode memory in order to leak something interesting",
    "start": "661010",
    "end": "667010"
  },
  {
    "start": "666000",
    "end": "666000"
  },
  {
    "text": "so apart from all of this we have some more factors which contribute to this whole problem so first of all neither",
    "start": "667010",
    "end": "674360"
  },
  {
    "text": "windows nor Linux actually pre initialized allocations on the stack or heap by default of course there are a",
    "start": "674360",
    "end": "681649"
  },
  {
    "text": "lot of exceptions mostly in Linux such as the case a lock function the GFP zero",
    "start": "681649",
    "end": "687320"
  },
  {
    "text": "flag etc but in general allocations are not initialized by default a recent",
    "start": "687320",
    "end": "693889"
  },
  {
    "text": "change in Windows from a few months ago is that some some allocations used for",
    "start": "693889",
    "end": "700730"
  },
  {
    "text": "ioctl IO buffers are initialized now but that is that is something that was not",
    "start": "700730",
    "end": "705949"
  },
  {
    "text": "true two months ago but the general rule still stands and as you can see here in",
    "start": "705949",
    "end": "711260"
  },
  {
    "text": "the screenshot even the official documentation of the X allocate pool with tagged windows function warns about",
    "start": "711260",
    "end": "717649"
  },
  {
    "text": "the fact that allocations returned by this function contain initialized memory",
    "start": "717649",
    "end": "722839"
  },
  {
    "text": "and if the code wants to return it to user mode it has to memset it first",
    "start": "722839",
    "end": "728110"
  },
  {
    "text": "another factor is that there are no visible visible consequences of this kind of behavior so even though C and",
    "start": "728110",
    "end": "735410"
  },
  {
    "text": "C++ don't really make it easy for the code to copy data securely between",
    "start": "735410",
    "end": "740870"
  },
  {
    "text": "security domains there isn't any punishment if you fail to do it correctly so you know even if the kernel",
    "start": "740870",
    "end": "747800"
  },
  {
    "text": "discloses if you initialize bytes in one syscall or another nothing will really",
    "start": "747800",
    "end": "753260"
  },
  {
    "text": "crash in most cases and so no one will discover this bug and so as a result if",
    "start": "753260",
    "end": "759740"
  },
  {
    "text": "a kernel developer is not aware of this bug class and they are not trying to actively prevent it they will probably",
    "start": "759740",
    "end": "765890"
  },
  {
    "text": "never kind of find out because the code crashes or something doesn't work so",
    "start": "765890",
    "end": "771170"
  },
  {
    "text": "it's a very silent type of bug yet another factor is the fact that it might",
    "start": "771170",
    "end": "777500"
  },
  {
    "text": "be not very easy to discover that any leaks from kernel mode are actually taking place because some of them could",
    "start": "777500",
    "end": "783920"
  },
  {
    "text": "be hidden behind the user mode system api so even though data is actually leaked from the system kernel back to",
    "start": "783920",
    "end": "790399"
  },
  {
    "text": "user mode in general that the original color of the system api might not see",
    "start": "790399",
    "end": "796910"
  },
  {
    "text": "this data at all so yeah when it comes to the severity and",
    "start": "796910",
    "end": "801920"
  },
  {
    "start": "799000",
    "end": "799000"
  },
  {
    "text": "considerations of this of these bugs you can say that they are not very severe",
    "start": "801920",
    "end": "807949"
  },
  {
    "text": "because it's just local info leaks there is no memory corruption taking place now remote exploitation involved by nature",
    "start": "807949",
    "end": "814459"
  },
  {
    "text": "and and and etc but the actual severity depends on what we managed to leak out",
    "start": "814459",
    "end": "820790"
  },
  {
    "text": "of the kernel this can be addresses that we can use for further exploitation of other vulnerabilities or it can be some",
    "start": "820790",
    "end": "827630"
  },
  {
    "text": "sensitive data that we can use more directly to elevate our privileges in the system but on the positive side from",
    "start": "827630",
    "end": "834920"
  },
  {
    "text": "the attacker perspective these bugs are mostly silent and transparent so we can try to exploit them basically",
    "start": "834920",
    "end": "841610"
  },
  {
    "text": "indefinitely and very silently without ever worrying about the system going down or someone actually discovering",
    "start": "841610",
    "end": "847850"
  },
  {
    "text": "that something something fishy is going on hmm so as I said these bugs are",
    "start": "847850",
    "end": "853130"
  },
  {
    "text": "mostly useful in practice as a single link in a full exploit chains for local",
    "start": "853130",
    "end": "858560"
  },
  {
    "text": "privilege escalation especially given how much effort is actually being put into protecting kernel address space",
    "start": "858560",
    "end": "864440"
  },
  {
    "text": "information in Windows and one real-life example of this would be an exploit",
    "start": "864440",
    "end": "870680"
  },
  {
    "text": "found in the hacking team dump two years ago so in order to exploit another",
    "start": "870680",
    "end": "875720"
  },
  {
    "text": "vulnerability they used a pool memory disclosure which leaked the base address of the winter dedicated sis driver and",
    "start": "875720",
    "end": "883660"
  },
  {
    "text": "so yeah it was used in practice and at the same time a few weeks before all of",
    "start": "883660",
    "end": "890029"
  },
  {
    "text": "this came to light a project zero researcher mod state also discovered",
    "start": "890029",
    "end": "895279"
  },
  {
    "text": "this independently and reported it so yeah when it comes to the benefits of of",
    "start": "895279",
    "end": "901699"
  },
  {
    "start": "897000",
    "end": "897000"
  },
  {
    "text": "this kind of disclosures you have to consider them separately when it comes to whether they are stack or heap",
    "start": "901699",
    "end": "907010"
  },
  {
    "text": "disclosures so when it comes to stack these are consistent and immediately",
    "start": "907010",
    "end": "912980"
  },
  {
    "text": "useful values because you know these are the desert this is the type of data that",
    "start": "912980",
    "end": "918529"
  },
  {
    "text": "is being stored on the stack so we have things like addresses of the kernel",
    "start": "918529",
    "end": "924019"
  },
  {
    "text": "stack because of the stack pointers we have heap addresses we have addresses of",
    "start": "924019",
    "end": "929540"
  },
  {
    "text": "executable images because of return addresses we can leak values of stock cookies which can be",
    "start": "929540",
    "end": "936019"
  },
  {
    "text": "then used to exploit a stack buffer overflow we have some Cisco specific data that is used by services called",
    "start": "936019",
    "end": "943220"
  },
  {
    "text": "directly before the leaking Cisco and also interesting thing is that we can",
    "start": "943220",
    "end": "949209"
  },
  {
    "text": "sometimes leak data of interrupt handlers if they happen to trigger in the same context as the exploiting",
    "start": "949209",
    "end": "955970"
  },
  {
    "text": "threat but that's only on Windows 7 on the other hand when it comes to heap",
    "start": "955970",
    "end": "961699"
  },
  {
    "start": "959000",
    "end": "959000"
  },
  {
    "text": "disclosure we have kind of less obvious memory because it's it's not always just",
    "start": "961699",
    "end": "967720"
  },
  {
    "text": "pointers to the stack into executable images but we have more potential to collide with something that is more",
    "start": "967720",
    "end": "974449"
  },
  {
    "text": "sensitive so of course we have addresses again of the heap and potentially of executable images but we can collide",
    "start": "974449",
    "end": "980149"
  },
  {
    "text": "with virtually allocations of any active kernel modules related to the disk",
    "start": "980149",
    "end": "985850"
  },
  {
    "text": "networking video etc yeah interestingly",
    "start": "985850",
    "end": "991779"
  },
  {
    "start": "989000",
    "end": "989000"
  },
  {
    "text": "there hasn't been too much work with within that space on Windows so",
    "start": "991779",
    "end": "998170"
  },
  {
    "text": "according to my best knowledge people have started to take interest in this",
    "start": "998170",
    "end": "1003190"
  },
  {
    "text": "kind of issues something like two years ago so we have this this one issue in",
    "start": "1003190",
    "end": "1008380"
  },
  {
    "text": "project zero tracker discovered by Mott state then we have a presentation of given by wandering glitch last year",
    "start": "1008380",
    "end": "1016060"
  },
  {
    "text": "about several unutilized memory disclosure bugs fixed in 2015 and we",
    "start": "1016060",
    "end": "1021699"
  },
  {
    "text": "have two more we have a presentation from this year from can sequester which doesn't really concern this",
    "start": "1021699",
    "end": "1028120"
  },
  {
    "text": "subject but mentions that there are some leaks in win32 k user remote callbacks and also we have this work from just",
    "start": "1028120",
    "end": "1035500"
  },
  {
    "text": "last month from two researchers which also collided with my research and and",
    "start": "1035500",
    "end": "1041319"
  },
  {
    "text": "tried to find some sum of info League parks in the Windows kernel automatically on the other hand the",
    "start": "1041319",
    "end": "1048910"
  },
  {
    "text": "problem seems to be much better well known on Linux so already seven years ago Dan Rosenberg",
    "start": "1048910",
    "end": "1056220"
  },
  {
    "text": "apparently went on a rampage and killed several dozen I think more than 20 info",
    "start": "1056220",
    "end": "1061990"
  },
  {
    "text": "leaks in various subsystems he presented some of this work in",
    "start": "1061990",
    "end": "1067190"
  },
  {
    "text": "patien given by him and yon aburrida in 2011 and then there are also a lot of",
    "start": "1067190",
    "end": "1073730"
  },
  {
    "text": "other comets provided by different security researchers which who",
    "start": "1073730",
    "end": "1080120"
  },
  {
    "text": "discovered this kind of bugs throughout the history so this problem seems to be much better",
    "start": "1080120",
    "end": "1085160"
  },
  {
    "text": "well known and well well understood in Linux than it is on Windows probably because of the fact that Linux is open",
    "start": "1085160",
    "end": "1091190"
  },
  {
    "text": "source so you can more easily find this kind of stuff there so let's look into",
    "start": "1091190",
    "end": "1096380"
  },
  {
    "text": "the design of the of the tool now we'll start with a quick description of box",
    "start": "1096380",
    "end": "1103070"
  },
  {
    "text": "because box spawn reloaded is is based on the Box emulator it's a full emulator",
    "start": "1103070",
    "end": "1108410"
  },
  {
    "text": "developed by Intel it has a full implementation of the CPU it has support",
    "start": "1108410",
    "end": "1115850"
  },
  {
    "text": "for all of the latest features of the CPU all of the extensions such as SSE a Fe X and stuff like that it also has all",
    "start": "1115850",
    "end": "1123830"
  },
  {
    "text": "basic peripherals so you can just run a full operating system on this single",
    "start": "1123830",
    "end": "1129020"
  },
  {
    "text": "emulator without any problems and a good thing is that it also provides an extension instrumentation API so we can",
    "start": "1129020",
    "end": "1136010"
  },
  {
    "text": "we can in addition to just running the system we can look into how it works and",
    "start": "1136010",
    "end": "1141980"
  },
  {
    "text": "we can change its behavior in any way we want in terms of performance of this",
    "start": "1141980",
    "end": "1147380"
  },
  {
    "start": "1145000",
    "end": "1145000"
  },
  {
    "text": "emulator since it's a full system is full software emulator the performance",
    "start": "1147380",
    "end": "1152990"
  },
  {
    "text": "is not very good so here we have you can see that I at this at the point of",
    "start": "1152990",
    "end": "1158030"
  },
  {
    "text": "taking the screenshot it was executing for to me about 40 million instructions per second so that's not too much",
    "start": "1158030",
    "end": "1164570"
  },
  {
    "text": "the longer story is that if we have a non instrumented guest it can run up to",
    "start": "1164570",
    "end": "1170030"
  },
  {
    "start": "1165000",
    "end": "1165000"
  },
  {
    "text": "100 IPS which is sufficient to boot a system in kind of reasonable time which",
    "start": "1170030",
    "end": "1175310"
  },
  {
    "text": "is under five minutes and when we do it the environment is fairly responsive we",
    "start": "1175310",
    "end": "1180890"
  },
  {
    "text": "can you know like use the system move the mouse open some applications",
    "start": "1180890",
    "end": "1187280"
  },
  {
    "text": "and stuff like that when we add some instrumentation on top of that we have some overhead depending on what",
    "start": "1187280",
    "end": "1193160"
  },
  {
    "text": "instrumentation we write in my case in in case of box phone reloaded that",
    "start": "1193160",
    "end": "1198230"
  },
  {
    "text": "performance drop was to around 30 to 40 million IPS which was still kind of",
    "start": "1198230",
    "end": "1205519"
  },
  {
    "text": "acceptable for research purposes so I can still interact with the system and get some visible results but when",
    "start": "1205519",
    "end": "1213320"
  },
  {
    "text": "interacting with box we actually had to put a lot of effort into making sure that the logic that we're implementing",
    "start": "1213320",
    "end": "1218450"
  },
  {
    "text": "in the instrumentation is is as simple and as fast as possible so about the",
    "start": "1218450",
    "end": "1226580"
  },
  {
    "start": "1223000",
    "end": "1223000"
  },
  {
    "text": "instrumentation support in box technically it works through macros",
    "start": "1226580",
    "end": "1232909"
  },
  {
    "text": "defined in C++ starting with the BX instru prefix and then we have a lot of",
    "start": "1232909",
    "end": "1240049"
  },
  {
    "text": "callbacks to actually choose from so we can we can execute our own code on",
    "start": "1240049",
    "end": "1246039"
  },
  {
    "text": "initialization of the virtual machine shuts down before and after executing an",
    "start": "1246039",
    "end": "1251119"
  },
  {
    "text": "instruction on linear and physical memory access on exceptions interrupts",
    "start": "1251119",
    "end": "1256639"
  },
  {
    "text": "and stuff like that so we can control and everything that is going on in the system and this enables us to develop",
    "start": "1256639",
    "end": "1262909"
  },
  {
    "text": "virtually any logic that we want to do so we can count statistics on what instructions are executing and how often",
    "start": "1262909",
    "end": "1269720"
  },
  {
    "text": "we can trace instructions or trace memory accesses add metadata and stuff",
    "start": "1269720",
    "end": "1275659"
  },
  {
    "text": "like that so here you can see a full list of the instrumentation callbacks that box",
    "start": "1275659",
    "end": "1281149"
  },
  {
    "start": "1276000",
    "end": "1276000"
  },
  {
    "text": "provides and the ones that are underlined are the ones that that I used",
    "start": "1281149",
    "end": "1286190"
  },
  {
    "text": "in box one reloaded so it's not not too many of them basically the most important ones are just the ones",
    "start": "1286190",
    "end": "1292399"
  },
  {
    "text": "triggering before and after execution of an instruction and the one triggering on accessing linear memory and the",
    "start": "1292399",
    "end": "1300470"
  },
  {
    "start": "1299000",
    "end": "1299000"
  },
  {
    "text": "CoreLogic of box bone is that we want to change track the entire kernel address",
    "start": "1300470",
    "end": "1305600"
  },
  {
    "text": "space and in order to do it we need to first be able to send change on new",
    "start": "1305600",
    "end": "1310970"
  },
  {
    "text": "allocations that are being performed in kernel mode both from the stack and the heap then we want to be able to remove",
    "start": "1310970",
    "end": "1317149"
  },
  {
    "text": "taint when memory is freed of course we want to propagate taint in memory and then most importantly we want to detect",
    "start": "1317149",
    "end": "1324590"
  },
  {
    "text": "when some initialized memory is copied from the kernel space to the user space",
    "start": "1324590",
    "end": "1329740"
  },
  {
    "start": "1329000",
    "end": "1329000"
  },
  {
    "text": "apart from that core functionality it's also good that we are able to reproduce the bugs and",
    "start": "1329740",
    "end": "1337010"
  },
  {
    "text": "analyse them somehow so in order to do that we want to also keep track of all the loaded cast kernel modules so we",
    "start": "1337010",
    "end": "1344120"
  },
  {
    "text": "know which driver is triggering the bug we will also want to read full stack",
    "start": "1344120",
    "end": "1350360"
  },
  {
    "text": "traces to be able to duplicate the bugs not to run into the same vulnerability",
    "start": "1350360",
    "end": "1355669"
  },
  {
    "text": "all over and over again of course it's good to also symbolize the call stacks to have pretty reports that we can",
    "start": "1355669",
    "end": "1362179"
  },
  {
    "text": "analyze and finally we want to break into kernel debugger attached to the guests when an error actually happens so",
    "start": "1362179",
    "end": "1369169"
  },
  {
    "text": "that we can interactively try to see what's going on in the system here you",
    "start": "1369169",
    "end": "1375380"
  },
  {
    "start": "1374000",
    "end": "1374000"
  },
  {
    "text": "can see a representation of the shadow memory so we have the guest the West memory divided into user a lot and",
    "start": "1375380",
    "end": "1381320"
  },
  {
    "text": "kernel and for every kernel and byte or rather we have a mapping of the a full",
    "start": "1381320",
    "end": "1390440"
  },
  {
    "text": "mapping of the shadow memory corresponding to the kernel land and then every memory unit is described by a",
    "start": "1390440",
    "end": "1395659"
  },
  {
    "text": "few variables of course we have detained bit but also we have information about",
    "start": "1395659",
    "end": "1401620"
  },
  {
    "text": "what is the base address of the allocation that despite belongs to we",
    "start": "1401620",
    "end": "1407450"
  },
  {
    "text": "have the information about where despite was allocated in the kernel and stuff",
    "start": "1407450",
    "end": "1412639"
  },
  {
    "text": "like that so this this shadow memory size is linear in relation to the size",
    "start": "1412639",
    "end": "1419299"
  },
  {
    "text": "of the guest kernel address space currently we only support 32-bit guests but that shouldn't be really too hard to",
    "start": "1419299",
    "end": "1427250"
  },
  {
    "text": "to modify and some of the information is stored at one by two on orality and some at eight byte granularity so right now",
    "start": "1427250",
    "end": "1435110"
  },
  {
    "text": "with my implementation the size of the shadow memory is three times the size of the kernel address space so we have six",
    "start": "1435110",
    "end": "1441139"
  },
  {
    "text": "gigabytes of memory for for a windows guest and three gigabytes of memory for linux guest so it can easily run on any",
    "start": "1441139",
    "end": "1449330"
  },
  {
    "text": "any host machine that has a reasonable amount of RAM memory and apart from just",
    "start": "1449330",
    "end": "1455090"
  },
  {
    "text": "painting the memory that we that is being allocated in our shadow memory what I wanted to do is also part the",
    "start": "1455090",
    "end": "1462620"
  },
  {
    "text": "guest memory with some special marker bytes so we have a",
    "start": "1462620",
    "end": "1468080"
  },
  {
    "text": "with the a a bite for hip allocations and BB bite for stack areas this is used",
    "start": "1468080",
    "end": "1474110"
  },
  {
    "text": "mostly first of all in order to eliminate all false positives because now we have the guarantee that if shadow",
    "start": "1474110",
    "end": "1480680"
  },
  {
    "text": "memory indicates that there is a bug we can also refer to the actual guest memory and see if these original marker",
    "start": "1480680",
    "end": "1487220"
  },
  {
    "text": "bites are still these values of a a or BB and it can also trigger some use of",
    "start": "1487220",
    "end": "1495200"
  },
  {
    "text": "an energized memory bugs that are not just info leaks but also other bugs so",
    "start": "1495200",
    "end": "1502390"
  },
  {
    "start": "1500000",
    "end": "1500000"
  },
  {
    "text": "about setting paint on stack this is this is actually very easy because all",
    "start": "1502390",
    "end": "1507710"
  },
  {
    "text": "allocations performed on stack are performed using the same assembly pattern so it's close cross-platform",
    "start": "1507710",
    "end": "1514870"
  },
  {
    "text": "what I do in my instrumentation is I just detect these three instruction of adding subtracting and ending against",
    "start": "1514870",
    "end": "1521840"
  },
  {
    "text": "the ESP register and then after the execution of this instruction if ESP",
    "start": "1521840",
    "end": "1526880"
  },
  {
    "text": "decrease that I just sent the taint on the whole new memory region that also allocated this way of course you can",
    "start": "1526880",
    "end": "1533240"
  },
  {
    "text": "imagine cases where this would crash the operating system if it didn't perform properly but unfortunately both windows",
    "start": "1533240",
    "end": "1541250"
  },
  {
    "text": "and linux do so this behavior doesn't crash anything and it all works out on",
    "start": "1541250",
    "end": "1546710"
  },
  {
    "start": "1545000",
    "end": "1545000"
  },
  {
    "text": "the other hand setting taint on heap and full allocations is completely different we cannot do it universally in any way",
    "start": "1546710",
    "end": "1553370"
  },
  {
    "text": "we actually have to know how the system allocates memory where the allocators are located in the kernel address space",
    "start": "1553370",
    "end": "1560330"
  },
  {
    "text": "and how do how they work so right now we can just say that after we detect an",
    "start": "1560330",
    "end": "1566510"
  },
  {
    "text": "allocation and we know the address and the size of the allocation we've just tainted and I will talk about how we do",
    "start": "1566510",
    "end": "1572360"
  },
  {
    "text": "it specifically in later in the presentation then we want to remove taint on hip free which is also very",
    "start": "1572360",
    "end": "1579380"
  },
  {
    "text": "reliant on how the heap implementation works on the specific system but",
    "start": "1579380",
    "end": "1584660"
  },
  {
    "text": "basically when we break on a free function Prolog we look up the allocation size of the memory that",
    "start": "1584660",
    "end": "1590560"
  },
  {
    "text": "corresponds to the address and we just clear all of the taint and metadata that corresponds to the whole memory region",
    "start": "1590560",
    "end": "1597140"
  },
  {
    "text": "another idea would be to escape this this clearing of the taint and is that retains this this memory in order",
    "start": "1597140",
    "end": "1605029"
  },
  {
    "text": "to detect use after free and leaks of freed memory but that's an implement implementational detail and the hardest",
    "start": "1605029",
    "end": "1612950"
  },
  {
    "start": "1611000",
    "end": "1611000"
  },
  {
    "text": "part of all of this is the taint propagation because we can easily detect allocations but detecting data transfers",
    "start": "1612950",
    "end": "1621200"
  },
  {
    "text": "and handling them correctly is definitely the hardest part so in case of my project I only propagate time for",
    "start": "1621200",
    "end": "1628909"
  },
  {
    "text": "the red mob as Dee and her red mob as be instructions which correspond to the mem copy kind of construct it's used both in",
    "start": "1628909",
    "end": "1637429"
  },
  {
    "text": "the mem copy implementation of various C clients and it's also used as an inline",
    "start": "1637429",
    "end": "1643190"
  },
  {
    "text": "version of the mem copy function and the good thing about handling this specific",
    "start": "1643190",
    "end": "1648740"
  },
  {
    "text": "instruction is that we know the source and destination addresses at the same time so we know how many bytes are",
    "start": "1648740",
    "end": "1655399"
  },
  {
    "text": "copied from which address location to to which one so we can analyze this very",
    "start": "1655399",
    "end": "1661159"
  },
  {
    "text": "easily and you know of course this is only a best-effort approach it's not",
    "start": "1661159",
    "end": "1666679"
  },
  {
    "text": "perfect we don't handle all of the data transfers but you know it still gives us",
    "start": "1666679",
    "end": "1673580"
  },
  {
    "text": "a lot of information and we still mostly care about copying large memory blobs",
    "start": "1673580",
    "end": "1679730"
  },
  {
    "text": "and not single variables so this this lets us to spend as little time on this",
    "start": "1679730",
    "end": "1685879"
  },
  {
    "text": "with as much benefit as we can get and it also has a quite a small CPU overhead",
    "start": "1685879",
    "end": "1694299"
  },
  {
    "text": "so if a memory access is not a result of this instruction that we specifically",
    "start": "1694299",
    "end": "1699799"
  },
  {
    "text": "analyzed then we perform the following steps if this instruction that we encounter is writing to some memory",
    "start": "1699799",
    "end": "1705889"
  },
  {
    "text": "we'll just clear the taint on that memory area and if the instruction is reading from the from the memory we",
    "start": "1705889",
    "end": "1711529"
  },
  {
    "text": "check the taint information and if the shadow memory indicates that this is",
    "start": "1711529",
    "end": "1716840"
  },
  {
    "text": "actually an annualized read we verify whether this is the case or not with the marker bytes that I mentioned before in",
    "start": "1716840",
    "end": "1723590"
  },
  {
    "text": "case there is a mismatch for whatever reason we just cleared the taint again but if the marker bytes are still there",
    "start": "1723590",
    "end": "1730759"
  },
  {
    "text": "in the guest memory we we report the bug and also the real detection of the user",
    "start": "1730759",
    "end": "1739850"
  },
  {
    "start": "1734000",
    "end": "1734000"
  },
  {
    "text": "mode or kernel mode information leak triggers on the read mode as be",
    "start": "1739850",
    "end": "1744950"
  },
  {
    "text": "instruction where the ESI is in kernel mode and idea is in user mode which",
    "start": "1744950",
    "end": "1750769"
  },
  {
    "text": "which is a very clear indicator that initialized memory is actually copied from kernel to user mode so once we have",
    "start": "1750769",
    "end": "1758389"
  },
  {
    "text": "all of this information and this picture of how this product should look like we",
    "start": "1758389",
    "end": "1763850"
  },
  {
    "text": "can try to run it on some real systems starting with Windows what we have to do",
    "start": "1763850",
    "end": "1770179"
  },
  {
    "start": "1768000",
    "end": "1768000"
  },
  {
    "text": "first is we have to implement the painting of pool allocations in Windows",
    "start": "1770179",
    "end": "1776450"
  },
  {
    "text": "we have a lot of functions which allocate memory from the pool all of them start with X allocate pool but",
    "start": "1776450",
    "end": "1783350"
  },
  {
    "text": "there are different variants but fortunately for us all of these functions eventually call into one",
    "start": "1783350",
    "end": "1788960"
  },
  {
    "text": "called X allocate pool with tag and it's very convenient because it uses the STD call",
    "start": "1788960",
    "end": "1795379"
  },
  {
    "text": "calling convention which means that we have the arguments on the stack and the return value in EAX and this means that",
    "start": "1795379",
    "end": "1802789"
  },
  {
    "text": "when the read instruction is executed in this function we have all of the information about both the allocation",
    "start": "1802789",
    "end": "1809210"
  },
  {
    "text": "request and allocation result at the same time so this is this is very convenient for us this is how it looks",
    "start": "1809210",
    "end": "1815419"
  },
  {
    "text": "on a graph so we have we have different colors of all of the allocation functions eventually they all call into",
    "start": "1815419",
    "end": "1822080"
  },
  {
    "text": "X allocate pool with tag and then we break on this single read instruction and read all of the relevant information",
    "start": "1822080",
    "end": "1827960"
  },
  {
    "text": "from ax and from memory under ESP so we read",
    "start": "1827960",
    "end": "1833419"
  },
  {
    "text": "where the allocation is being made from from the return address and the requested size and the allocation tag",
    "start": "1833419",
    "end": "1840259"
  },
  {
    "text": "for some debugging information and then we also break on the X free pool with",
    "start": "1840259",
    "end": "1846620"
  },
  {
    "text": "tag function this time in the prologue of the function and we just read the address of the regem that is being freed",
    "start": "1846620",
    "end": "1853700"
  },
  {
    "text": "in order to clear the taint unfortunately there are some corner cases which we also have to take into",
    "start": "1853700",
    "end": "1860720"
  },
  {
    "text": "account in order to find all of the bugs so for example in Windows we have some optimized specialized alligators such",
    "start": "1860720",
    "end": "1867169"
  },
  {
    "text": "though such as the one used by winter okay so there is this alligator which first of all tries to return a cached",
    "start": "1867169",
    "end": "1873950"
  },
  {
    "text": "memory region that is pre allocated and after only it is busy the actual Windows",
    "start": "1873950",
    "end": "1880280"
  },
  {
    "text": "kernel a locator is used so and it's called from from quite a few locations so we",
    "start": "1880280",
    "end": "1886429"
  },
  {
    "text": "have to take care of that but what we can do is we can just simply patch this function to always use the system a",
    "start": "1886429",
    "end": "1892039"
  },
  {
    "text": "locator instead and we are good to go when it comes to propagating taint and",
    "start": "1892039",
    "end": "1897559"
  },
  {
    "start": "1894000",
    "end": "1894000"
  },
  {
    "text": "detecting bugs in Windows we are quite lucky because the the mem copy function that is used by the",
    "start": "1897559",
    "end": "1904070"
  },
  {
    "text": "Windows kernel actually uses the red morph as B and wrap morph as d function instructions sometimes they have some",
    "start": "1904070",
    "end": "1913870"
  },
  {
    "text": "optimizations that we have to care about so for example in Windows if the copy size is less than 32 bytes",
    "start": "1913870",
    "end": "1921350"
  },
  {
    "text": "then morph instructions are used instead of red morph as beep or red Mofaz d but",
    "start": "1921350",
    "end": "1926960"
  },
  {
    "text": "we also can just modify that in assembly so in general as a result tracking most",
    "start": "1926960",
    "end": "1934130"
  },
  {
    "text": "transfers of data blobs in Windows works out of the box with the approach that I",
    "start": "1934130",
    "end": "1939230"
  },
  {
    "start": "1939000",
    "end": "1939000"
  },
  {
    "text": "mentioned before I'm not sure oh you can actually see that quite well so I created a small visualization of the",
    "start": "1939230",
    "end": "1946309"
  },
  {
    "text": "whole address space in Windows 7 so here you can see the whole 2 gigabyte kernel address space over time this is an image",
    "start": "1946309",
    "end": "1956000"
  },
  {
    "text": "which is of dimensions 1024 by 512 each pixel is a single memory page and so",
    "start": "1956000",
    "end": "1963770"
  },
  {
    "text": "these pages that are that have some stack memory taint are marked in green",
    "start": "1963770",
    "end": "1969679"
  },
  {
    "text": "and the pool ones are marked in red so now we can see that what the patterns",
    "start": "1969679",
    "end": "1975740"
  },
  {
    "text": "are in Windows when it boots up and when you start some of the some of the applications in Windows so that's 40",
    "start": "1975740",
    "end": "1982070"
  },
  {
    "text": "minutes of runtime a new snapshot was being taken every 20 seconds here so I I",
    "start": "1982070",
    "end": "1988610"
  },
  {
    "text": "found I find that quite interesting myself and here you can see the similar",
    "start": "1988610",
    "end": "1993740"
  },
  {
    "text": "image on Windows 10 over 120 minutes with a snapshot taking every 60 seconds",
    "start": "1993740",
    "end": "2000850"
  },
  {
    "text": "because the boots time was much longer on the box emulator so you can see that much",
    "start": "2000850",
    "end": "2006700"
  },
  {
    "text": "more memories consumed by the operating system and the patterns in which memory is allocated also is also quite",
    "start": "2006700",
    "end": "2012880"
  },
  {
    "text": "different when it comes to other technical details such as keeping track of processes and threads it's very",
    "start": "2012880",
    "end": "2020049"
  },
  {
    "text": "simple it's the same as in the original box born from four years ago it's just",
    "start": "2020049",
    "end": "2025090"
  },
  {
    "text": "about traversing a simple traversing a single a linked list of of modules in",
    "start": "2025090",
    "end": "2031900"
  },
  {
    "text": "the kernel address space and the same goes for keeping track of keeping track of loaded kernel modules you also just",
    "start": "2031900",
    "end": "2038679"
  },
  {
    "start": "2033000",
    "end": "2033000"
  },
  {
    "text": "have to go through a list of descriptors and note the values there so here we",
    "start": "2038679",
    "end": "2045460"
  },
  {
    "text": "have an example of Bach's bone that that was generated in an actual runtime so",
    "start": "2045460",
    "end": "2050530"
  },
  {
    "text": "you can see all of the information that we have about the bag that happened we have the address of the memory that is",
    "start": "2050530",
    "end": "2056260"
  },
  {
    "text": "being read we have information about the process in this case it's Explorer dot X",
    "start": "2056260",
    "end": "2062020"
  },
  {
    "text": "ax we have the faulting instruction which as I mentioned before can only be read more of SD in this case and we have",
    "start": "2062020",
    "end": "2069878"
  },
  {
    "text": "information about where the memory region was allocated in this case it was",
    "start": "2069879",
    "end": "2075040"
  },
  {
    "text": "just a generic function inside of win32 K and the stack trace of where this",
    "start": "2075040",
    "end": "2080710"
  },
  {
    "text": "happened so this is all very good and it looks very nice but it was a very simple",
    "start": "2080710",
    "end": "2088210"
  },
  {
    "text": "example and there are much more complex examples where we have a bug but it's",
    "start": "2088210",
    "end": "2094000"
  },
  {
    "text": "it's not just to stack frames it's actually like 30 stack frames because the back happens inside of a ioctl",
    "start": "2094000",
    "end": "2100780"
  },
  {
    "text": "handler someone very deep inside of the kernel so it's not very convenient in",
    "start": "2100780",
    "end": "2106300"
  },
  {
    "text": "that case to try to analyze the bug based just on the single box spawn report so as I mentioned before what I",
    "start": "2106300",
    "end": "2111790"
  },
  {
    "text": "wanted to do is to be able to attach windbg or wind back to the emulated guest kernel and this is not a very big",
    "start": "2111790",
    "end": "2119560"
  },
  {
    "text": "problem because box actually supports redirecting comm ports to Windows pipes so we can just enable kernel debugging",
    "start": "2119560",
    "end": "2125830"
  },
  {
    "text": "in the guest system and then attach a wind wind back to it from outside of",
    "start": "2125830",
    "end": "2131170"
  },
  {
    "text": "course this is very very slow if you try to attach wind back takes maybe five minutes for it to fully",
    "start": "2131170",
    "end": "2137500"
  },
  {
    "text": "on initially and provide with the interactive shell but it's still workable for our purposes and of course",
    "start": "2137500",
    "end": "2145870"
  },
  {
    "text": "this is not sufficient because even though we have this kernel debugger attached we don't know when when the",
    "start": "2145870",
    "end": "2153340"
  },
  {
    "text": "bugs are happening so what we also want to do is that we want to break on the specific moment when a bug happens and",
    "start": "2153340",
    "end": "2160180"
  },
  {
    "text": "this is achieved by injecting an entry instruction in the emulator exactly at",
    "start": "2160180",
    "end": "2167230"
  },
  {
    "text": "the moment when the bug is detected so this this lets us break into the debugger and see exactly what is going",
    "start": "2167230",
    "end": "2174460"
  },
  {
    "text": "on and what memory is being copied to user mode and why so for me at least it",
    "start": "2174460",
    "end": "2180340"
  },
  {
    "text": "seems it feels quite magical that it will all works but it does so here I",
    "start": "2180340",
    "end": "2185950"
  },
  {
    "text": "have a screenshot of wind wind bag attached to the box guest here yeah when",
    "start": "2185950",
    "end": "2193420"
  },
  {
    "start": "2192000",
    "end": "2192000"
  },
  {
    "text": "it comes to the testing that I performed in order to get some reasonable cold coverage first of all I run the",
    "start": "2193420",
    "end": "2199780"
  },
  {
    "text": "instrumentation against Windows 7 and Windows 10 in order to get above the old",
    "start": "2199780",
    "end": "2204880"
  },
  {
    "text": "code that could have been removed in Windows 10 and also the new code that was added in that system and within that",
    "start": "2204880",
    "end": "2211720"
  },
  {
    "text": "guests what I did is that I of course booted up the system started a few default applications such as Internet",
    "start": "2211720",
    "end": "2217540"
  },
  {
    "text": "Explorer WordPad stuff like that I generally did some network traffic and I also run so-called react OS unit tests",
    "start": "2217540",
    "end": "2225250"
  },
  {
    "text": "which is a bunch of applications which are used by react OS to test whether the behavior of the system is the same as",
    "start": "2225250",
    "end": "2231580"
  },
  {
    "text": "Windows so it actually helps us provide or get a lot of code coverage in the",
    "start": "2231580",
    "end": "2237700"
  },
  {
    "text": "kernel that we wouldn't be able to do otherwise we already used this these tests four years ago but they were",
    "start": "2237700",
    "end": "2244750"
  },
  {
    "text": "largely improved since then so they were very helpful for us but of course even",
    "start": "2244750",
    "end": "2249760"
  },
  {
    "text": "though we did all of those things it's still not the perfect amount of code coverage that we can get so it's still a",
    "start": "2249760",
    "end": "2257170"
  },
  {
    "text": "major roadblock in every effective usage of full system instrumentation because",
    "start": "2257170",
    "end": "2262780"
  },
  {
    "text": "we can find only as many bugs are actually triggered on the system so let's look into the results",
    "start": "2262780",
    "end": "2270690"
  },
  {
    "text": "this is this is the results on a single slide so it's a it's a couple of screenshots from Microsoft Billiton from",
    "start": "2271010",
    "end": "2278000"
  },
  {
    "text": "the last four months the summary is that we found so far 30 vulnerabilities 13 of",
    "start": "2278000",
    "end": "2285050"
  },
  {
    "text": "them were in from the pools and 17 from the stack so it's quite evenly divided",
    "start": "2285050",
    "end": "2291340"
  },
  {
    "text": "and we can see here the pool ones were triggered in a number of kernel drivers",
    "start": "2291340",
    "end": "2297680"
  },
  {
    "text": "so we have both the core NTS OS kernel we have win32 k we have a bunch of you",
    "start": "2297680",
    "end": "2304100"
  },
  {
    "text": "know like partition manager drivers volume manager driver stuff like that",
    "start": "2304100",
    "end": "2310090"
  },
  {
    "text": "and root causes of those bugs are also very diverse so we have bugs caused by",
    "start": "2310090",
    "end": "2316100"
  },
  {
    "text": "structure alignment unicode string alignment padding halls and you know a",
    "start": "2316100",
    "end": "2321620"
  },
  {
    "text": "lot of different things and also the the amount of bytes that were leaked is also quite diverse so it ranges from just a",
    "start": "2321620",
    "end": "2328970"
  },
  {
    "text": "single byte to over 6 kilobytes of information at a single request and then",
    "start": "2328970",
    "end": "2334730"
  },
  {
    "text": "we have the stock disclosures as well from a number of functions they are also diverse for some of them I wasn't really",
    "start": "2334730",
    "end": "2341360"
  },
  {
    "text": "able to figure out what the reason for for the leak was but yeah it's still",
    "start": "2341360",
    "end": "2346490"
  },
  {
    "text": "quite a lot of them so it's it's an important problem once we detected these",
    "start": "2346490",
    "end": "2352100"
  },
  {
    "text": "bugs we want to reproduce them of course and this is another important problem that we have to look into so in order to",
    "start": "2352100",
    "end": "2359240"
  },
  {
    "text": "reproduce the pool info leaks what I did is that I used regular vm in order to make sure that this bug is not specific",
    "start": "2359240",
    "end": "2366110"
  },
  {
    "text": "to box but also a normal environment what I did is that I just found out",
    "start": "2366110",
    "end": "2371210"
  },
  {
    "text": "which drivers making the allocation that is being leaked to user mode and I already had this information from the",
    "start": "2371210",
    "end": "2378380"
  },
  {
    "text": "metadata I enabled special pools for that model reboot the system and then started the POC twice and then I could",
    "start": "2378380",
    "end": "2385940"
  },
  {
    "text": "observe a repeated marker bite at the offsets where the data was leaked so this is how it looked like for the",
    "start": "2385940",
    "end": "2392480"
  },
  {
    "text": "volume disks extents vulnerability when I run it the first time you can see 39",
    "start": "2392480",
    "end": "2398090"
  },
  {
    "text": "marker byte but then when I run it again it's another byte so you can easily see where the leak is actually taking place",
    "start": "2398090",
    "end": "2404330"
  },
  {
    "text": "here when it comes to stacking fully reproduction that is much more difficult",
    "start": "2404330",
    "end": "2409550"
  },
  {
    "start": "2405000",
    "end": "2405000"
  },
  {
    "text": "because there is no official or documented way of padding stack allocations with marker bytes but on the",
    "start": "2409550",
    "end": "2415880"
  },
  {
    "text": "other hand we still want to reproduce these packs reliably and be able to show where the bytes are being leaked because",
    "start": "2415880",
    "end": "2422840"
  },
  {
    "text": "otherwise you know first of all it's easier for Microsoft to find add to to",
    "start": "2422840",
    "end": "2428180"
  },
  {
    "text": "to fix those bugs and also it's easier for us to make sure that the back is real and also reproduce outside of the",
    "start": "2428180",
    "end": "2434840"
  },
  {
    "text": "test environment what we can do in this case is that we can use stack spraying this is a technique that allows us to",
    "start": "2434840",
    "end": "2443720"
  },
  {
    "start": "2436000",
    "end": "2436000"
  },
  {
    "text": "spray the kernel stack with some controlled memory and it works thanks to",
    "start": "2443720",
    "end": "2449600"
  },
  {
    "text": "the fact that Windows uses optimization of using local buffers for small requests and some of the system calls",
    "start": "2449600",
    "end": "2456680"
  },
  {
    "text": "actually have very large buffers for storing optimized local data so we have",
    "start": "2456680",
    "end": "2462440"
  },
  {
    "text": "this system call called anti map user physical pages which allows us to put 4",
    "start": "2462440",
    "end": "2467600"
  },
  {
    "text": "or 8 kilobytes of controlled data on the stack so it's very convenient so this is",
    "start": "2467600",
    "end": "2473270"
  },
  {
    "text": "illustrated here first of all what we do is that we just spray the current start with some easily recognizable patterns",
    "start": "2473270",
    "end": "2479120"
  },
  {
    "text": "such as the for 1 byte and then we trigger the vulnerability and we see where this marker byte happens to to be",
    "start": "2479120",
    "end": "2486710"
  },
  {
    "text": "in our output buffer so this is another example of running the anti GDI get",
    "start": "2486710",
    "end": "2492590"
  },
  {
    "text": "realization info POC here which leaks 8 bytes from the kernel stack and a quick",
    "start": "2492590",
    "end": "2498890"
  },
  {
    "start": "2497000",
    "end": "2497000"
  },
  {
    "text": "digression is that if memory marking can be used for bug demonstration it can also be used for discovery that's what I",
    "start": "2498890",
    "end": "2504500"
  },
  {
    "text": "at least thought and the basic idea would be to first of all enable special pools for all of the kernel modules and",
    "start": "2504500",
    "end": "2511670"
  },
  {
    "text": "then invoke invite invoke test tested system called twice pre spraying the",
    "start": "2511670",
    "end": "2517880"
  },
  {
    "text": "kernel stack with a different bite each time and then we can compare the output of the system call and see if if it",
    "start": "2517880",
    "end": "2523880"
  },
  {
    "text": "differs in a reliable way and the perfect candidate to to test in",
    "start": "2523880",
    "end": "2529490"
  },
  {
    "start": "2526000",
    "end": "2526000"
  },
  {
    "text": "this way is that function is the family of anti query information system calls",
    "start": "2529490",
    "end": "2534920"
  },
  {
    "text": "which have a very calm structures so we have a handle to the",
    "start": "2534920",
    "end": "2540020"
  },
  {
    "text": "object that we want to query we have some information class which is just a simple integer and we have a pointer and",
    "start": "2540020",
    "end": "2546320"
  },
  {
    "text": "size of the output buffer so we can create the object that we want to query",
    "start": "2546320",
    "end": "2551780"
  },
  {
    "text": "and then we can just brute force pretty much both the information class and the expected buffer size and our about ten",
    "start": "2551780",
    "end": "2559400"
  },
  {
    "text": "such functions which we can test this way so this looked quite promising and",
    "start": "2559400",
    "end": "2564950"
  },
  {
    "text": "indeed it turned out that this was a fruitful idea and I was able to find about five bucks this way as well so it",
    "start": "2564950",
    "end": "2571640"
  },
  {
    "text": "was it was quite easy so in summary the problem seems to have remained mostly",
    "start": "2571640",
    "end": "2577190"
  },
  {
    "start": "2573000",
    "end": "2573000"
  },
  {
    "text": "unrecognized until now probably because of the factor that factors that I mentioned before that it's quite",
    "start": "2577190",
    "end": "2583970"
  },
  {
    "text": "invisible and not obvious to find these bugs but on the other hand it's a fundamental issue which is trivial to",
    "start": "2583970",
    "end": "2590060"
  },
  {
    "text": "overlook but very difficult to get right in the code so I think it's also a tip",
    "start": "2590060",
    "end": "2597890"
  },
  {
    "text": "of the iceberg so even though I found thirty bucks so far there are hundreds of men copy calls to user remote in the",
    "start": "2597890",
    "end": "2604340"
  },
  {
    "text": "Windows kernel and every one of them is a potential disclosure so so there are",
    "start": "2604340",
    "end": "2609380"
  },
  {
    "text": "still probably a lot of such bugs lurking in the codebase of Windows and this is especially true in the cases",
    "start": "2609380",
    "end": "2615260"
  },
  {
    "text": "where the size is user controlled but the amount of lab relevant data is fixed or otherwise limited there are some",
    "start": "2615260",
    "end": "2622910"
  },
  {
    "text": "mitigations ideas that Microsoft could probably implement in some way in order to to try to mitigate those bugs first",
    "start": "2622910",
    "end": "2630800"
  },
  {
    "text": "of all of course they could just memset all stack and pool allocations we learned there made or requested which",
    "start": "2630800",
    "end": "2637400"
  },
  {
    "text": "would make the bug go away without doing any bug fixing at all but of course that is probably incurring too much of an",
    "start": "2637400",
    "end": "2643400"
  },
  {
    "text": "overhead so it's not realistic and especially given the fact that most kernel allocations probably don't at end",
    "start": "2643400",
    "end": "2650210"
  },
  {
    "text": "up copied to user mode anyway but it turns out that Microsoft implemented a",
    "start": "2650210",
    "end": "2656090"
  },
  {
    "text": "part of this idea by mem setting the buffered i/o output buffer in the ioctl",
    "start": "2656090",
    "end": "2662980"
  },
  {
    "text": "implementation just just a few weeks ago so they are definitely looking into into this there are some other",
    "start": "2662980",
    "end": "2669870"
  },
  {
    "text": "creation ideas that are more realistic such as for example Creek clearing the kernel stack between system calls they",
    "start": "2669870",
    "end": "2677490"
  },
  {
    "text": "could also add a new a locator function which just clears the returned memory regions before returning them and they",
    "start": "2677490",
    "end": "2684960"
  },
  {
    "text": "could also just detect which allocations end up being copied to user mode and then only clear those either",
    "start": "2684960",
    "end": "2691410"
  },
  {
    "text": "automatically or just by adding Maps it calls manually and in general since when",
    "start": "2691410",
    "end": "2697380"
  },
  {
    "text": "the Microsoft has the wins of source code they could bring this idea to a whole new level by writing better",
    "start": "2697380",
    "end": "2705030"
  },
  {
    "text": "instrumentation which has more information about data transfers and stuff like that they also have probably",
    "start": "2705030",
    "end": "2711420"
  },
  {
    "text": "mode code coverage that I am able to achieve by just running a few simple tests and starting a few applications",
    "start": "2711420",
    "end": "2717270"
  },
  {
    "text": "which also means more bugs found and static analysis is also easier to use to",
    "start": "2717270",
    "end": "2724170"
  },
  {
    "text": "guide this dynamic approaches so when it comes to closing remarks for Windows of",
    "start": "2724170",
    "end": "2730470"
  },
  {
    "start": "2726000",
    "end": "2726000"
  },
  {
    "text": "course this box phone approach could be also used to detect regular use of an initialized memory but the results in",
    "start": "2730470",
    "end": "2736710"
  },
  {
    "text": "case of Windows are much harder to try out because we don't have access to the source code so we cannot easily analyze",
    "start": "2736710",
    "end": "2742770"
  },
  {
    "text": "if this use of an initialized memory is an actual buck or not and another point",
    "start": "2742770",
    "end": "2749280"
  },
  {
    "text": "that I wanted to make is that the the subject of leaking specific sensitive data from pool disclosures is still an",
    "start": "2749280",
    "end": "2757140"
  },
  {
    "text": "interesting subject that hasn't been explored too much now I also wanted to talk about running Bach's bone against",
    "start": "2757140",
    "end": "2763650"
  },
  {
    "text": "Linux but I guess I don't have too much time anymore so I will just quickly say that the",
    "start": "2763650",
    "end": "2770760"
  },
  {
    "start": "2767000",
    "end": "2767000"
  },
  {
    "text": "tainting of heap allocations is much more difficult on Linux because the allocators themselves are plenty it's",
    "start": "2770760",
    "end": "2777840"
  },
  {
    "text": "not just a single function but we have a couple of families that are schema log V ma log K memcache a log and stuff like",
    "start": "2777840",
    "end": "2784200"
  },
  {
    "text": "that all of them work in different ways so we have a lot of these functions for",
    "start": "2784200",
    "end": "2789960"
  },
  {
    "text": "came along a lot of these functions in vemma log we have to hook into most of",
    "start": "2789960",
    "end": "2795000"
  },
  {
    "text": "them in order to be able to catch all of the allocations in my case it was seven",
    "start": "2795000",
    "end": "2800070"
  },
  {
    "text": "of them we also have problems such as the fact we have a different calling conventions",
    "start": "2800070",
    "end": "2805950"
  },
  {
    "text": "with arguments passed through registers and not the stack so instead of just",
    "start": "2805950",
    "end": "2811980"
  },
  {
    "text": "hooking into a single read instruction we actually have to hook into the both the prologue of the app function in",
    "start": "2811980",
    "end": "2817890"
  },
  {
    "text": "order to save information about the allocation request and then we have to hook into the return instruction in",
    "start": "2817890",
    "end": "2824160"
  },
  {
    "text": "order to be able to read the address that it was being allocated and then we can set the taint then we have this",
    "start": "2824160",
    "end": "2831000"
  },
  {
    "text": "troublesome family of K memcache functions which create a cache of",
    "start": "2831000",
    "end": "2836460"
  },
  {
    "text": "allocations which are initialized and tainted at the time where the object is",
    "start": "2836460",
    "end": "2842640"
  },
  {
    "text": "initialized but not at the time when it is requested so we have to implement some additional logic to account for",
    "start": "2842640",
    "end": "2849630"
  },
  {
    "text": "that other than that we have a few flags that we have to set in the config in order to make the mem copy function be",
    "start": "2849630",
    "end": "2857490"
  },
  {
    "text": "compiled into a set of rep move move SB instructions we have this visualization",
    "start": "2857490",
    "end": "2867000"
  },
  {
    "start": "2863000",
    "end": "2863000"
  },
  {
    "text": "of Ubuntu memory layout which I'm gonna skip right now we have a few other config options that we also have to set",
    "start": "2867000",
    "end": "2873810"
  },
  {
    "text": "in order to enable debugging symbols use the right kernel user address mode split",
    "start": "2873810",
    "end": "2879390"
  },
  {
    "text": "and disable some of the mechanisms that we don't want to use in the emulation",
    "start": "2879390",
    "end": "2886040"
  },
  {
    "text": "then we also have to set another config option to make sure that copy to user which is used to copy memory back from",
    "start": "2886040",
    "end": "2893460"
  },
  {
    "text": "kernel mode to user mode is also compiled into read mob SP and read more SD instructions unfortunately there is",
    "start": "2893460",
    "end": "2901770"
  },
  {
    "text": "one problematic function that we have to also care about which is put user which is a macro used to copy simple types",
    "start": "2901770",
    "end": "2910290"
  },
  {
    "text": "back to user mode but we can take care of that by just using a hack of using",
    "start": "2910290",
    "end": "2917910"
  },
  {
    "text": "these prefetch instructions in order to enable and disable strict mode in box",
    "start": "2917910",
    "end": "2923940"
  },
  {
    "text": "which means that we just sanitize all of the reads from memory that happened",
    "start": "2923940",
    "end": "2929849"
  },
  {
    "text": "between those two instructions you are welcome to ask me about the details of",
    "start": "2929849",
    "end": "2935280"
  },
  {
    "text": "that after presentation but that's how it looks in assembly so we have the preface one and",
    "start": "2935280",
    "end": "2941250"
  },
  {
    "text": "preffered two instructions and be in between these instructions we just sanitize all of the memory reads so yeah",
    "start": "2941250",
    "end": "2948810"
  },
  {
    "text": "we have we have a very similar log from box pawn report right now so it's all",
    "start": "2948810",
    "end": "2954090"
  },
  {
    "text": "the same information about the instruction the stack trace where the back happened and stuff like that we",
    "start": "2954090",
    "end": "2959730"
  },
  {
    "start": "2959000",
    "end": "2959000"
  },
  {
    "text": "also have a kernel debugger attached as well so we can we can debug these bugs",
    "start": "2959730",
    "end": "2964800"
  },
  {
    "text": "that happen at runtime we perform some very simple testing as well by running a",
    "start": "2964800",
    "end": "2971730"
  },
  {
    "text": "few system professors such as Trinity pools I know this also a few unit tests",
    "start": "2971730",
    "end": "2979170"
  },
  {
    "text": "such as the Linux test project and a couple of other things unfortunately we are but we weren't able to use this",
    "start": "2979170",
    "end": "2985860"
  },
  {
    "text": "color because it's currently only supporting 64-bit architectures and we",
    "start": "2985860",
    "end": "2991290"
  },
  {
    "text": "were working with 32-bit when it comes to the results they are much less",
    "start": "2991290",
    "end": "2996810"
  },
  {
    "text": "impressive than on Windows so it was just a single bug which was very minor because it was in the ioctl of a device",
    "start": "2996810",
    "end": "3005060"
  },
  {
    "text": "that was only accessible to route I'd still discovered it around April 20th",
    "start": "3005060",
    "end": "3010760"
  },
  {
    "text": "and I was I was still able to I was still going to report it a few days later but when I started looking around",
    "start": "3010760",
    "end": "3017360"
  },
  {
    "text": "seeing if anybody has reported it already I discovered that seven days after yeah after I discovered it someone from",
    "start": "3017360",
    "end": "3024440"
  },
  {
    "text": "Google already have have fixed it so too bad but since that didn't work out so",
    "start": "3024440",
    "end": "3031220"
  },
  {
    "text": "well for me to detect does direct kernel to user info leaks I decided that I",
    "start": "3031220",
    "end": "3037310"
  },
  {
    "text": "could enable that global strict mode and detect all uses of unutilized memory and analyze all of them because I had access",
    "start": "3037310",
    "end": "3043880"
  },
  {
    "text": "to the source code in this case so I could just look into the in-depth root cause of every such instance so I did",
    "start": "3043880",
    "end": "3051170"
  },
  {
    "text": "that and this was more lucky for me so I was able to find a few bugs one of them",
    "start": "3051170",
    "end": "3057920"
  },
  {
    "start": "3052000",
    "end": "3052000"
  },
  {
    "text": "actually led to the discovery of an actual kernel info leak in the LLC piece",
    "start": "3057920",
    "end": "3063500"
  },
  {
    "text": "or connect in NFC sockets the other ones are much lesser",
    "start": "3063500",
    "end": "3069740"
  },
  {
    "text": "they were still uses of uninitialized memory but not directly leading to information disclosure thankfully all of",
    "start": "3069740",
    "end": "3076490"
  },
  {
    "text": "them have been fixed now and as you can see some of them have also been found by",
    "start": "3076490",
    "end": "3081800"
  },
  {
    "text": "external researchers as well so it turns",
    "start": "3081800",
    "end": "3087800"
  },
  {
    "text": "out that when it comes to analyze reads from kernel mode my project was not the",
    "start": "3087800",
    "end": "3094130"
  },
  {
    "text": "only one in Linux so there is a project called kernel memory sanitizer which is being worked on right now",
    "start": "3094130",
    "end": "3100760"
  },
  {
    "text": "it's called km Sun it's developed by Alexander Potter Penco and it has",
    "start": "3100760",
    "end": "3106310"
  },
  {
    "text": "collided on a few on a few of my findings and the important thing is that",
    "start": "3106310",
    "end": "3111530"
  },
  {
    "text": "it's actually working in a different way it's adding instrumentation at compile time it's very similar to projects such",
    "start": "3111530",
    "end": "3119420"
  },
  {
    "text": "as address ionizer memory sanitizer for user mode and this is the the correct",
    "start": "3119420",
    "end": "3124490"
  },
  {
    "text": "way to do it in Linux but I still wanted to also test my approach on that operating system so the conclusions in",
    "start": "3124490",
    "end": "3132020"
  },
  {
    "start": "3129000",
    "end": "3129000"
  },
  {
    "text": "terms of Linux is that here we have we have a community which has been on top of the problem for the last few years we",
    "start": "3132020",
    "end": "3139310"
  },
  {
    "text": "don't have so many info leaks here and even if we find something it turns out that these bugs seem to be quite",
    "start": "3139310",
    "end": "3146210"
  },
  {
    "text": "short-lived from my experience at least yeah there is a little bit of future",
    "start": "3146210",
    "end": "3151880"
  },
  {
    "start": "3149000",
    "end": "3149000"
  },
  {
    "text": "work to be done here we can run further iteration on Windows we can try to look into improving code coverage which is",
    "start": "3151880",
    "end": "3158000"
  },
  {
    "text": "always something that needs to be done I can also think about improving taste",
    "start": "3158000",
    "end": "3163160"
  },
  {
    "text": "propagation beyond just rap of SB and implementing support for 64-bit guests",
    "start": "3163160",
    "end": "3169400"
  },
  {
    "text": "which also should be able to identify a few more new bugs there are some other",
    "start": "3169400",
    "end": "3176090"
  },
  {
    "text": "more crazy approaches such as taint less approaches of not having any taint but",
    "start": "3176090",
    "end": "3182119"
  },
  {
    "text": "only looking into writes into user remote memory and seeing if there are any marker bytes that are being leaked",
    "start": "3182119",
    "end": "3187130"
  },
  {
    "text": "there this addresses the problem of non-ideal tyne propagation but it has",
    "start": "3187130",
    "end": "3192530"
  },
  {
    "text": "other problems as well yeah we can also we can also think about detecting leaks",
    "start": "3192530",
    "end": "3199550"
  },
  {
    "text": "not just into user remote memory but into other sinks that outgoing network traffic file system",
    "start": "3199550",
    "end": "3205280"
  },
  {
    "text": "metadata and stuff like that so there is a lot of work to do still but I think",
    "start": "3205280",
    "end": "3210530"
  },
  {
    "text": "the results so far are still quite impressive and are motivating to look",
    "start": "3210530",
    "end": "3216890"
  },
  {
    "text": "into info leaks more in the future so thank you for listening and I'm happy to answer questions [Applause]",
    "start": "3216890",
    "end": "3222580"
  },
  {
    "text": "[Music] [Applause] [Music] [Applause]",
    "start": "3222580",
    "end": "3230780"
  }
]