[
  {
    "start": "0",
    "end": "220000"
  },
  {
    "text": "[Music]",
    "start": "90",
    "end": "26960"
  },
  {
    "text": "you ready do all right um this talk uh today is on um buffer",
    "start": "28640",
    "end": "36559"
  },
  {
    "text": "overflow protection uh their implementations and their weaknesses um I'm Peter Silverman uh during the summer",
    "start": "36559",
    "end": "43000"
  },
  {
    "text": "I work for eye defense and security researcher and during the fall I try to go to class and um",
    "start": "43000",
    "end": "50680"
  },
  {
    "text": "Johnson do you have I'm rich Johnson i'mi",
    "start": "50719",
    "end": "57920"
  },
  {
    "text": "yours isn't working yeah can we get some assistance with mic just",
    "start": "62359",
    "end": "69280"
  },
  {
    "text": "talk hold",
    "start": "69280",
    "end": "72400"
  },
  {
    "text": "on yeah it's just it it's been the bad luck",
    "start": "74840",
    "end": "84078"
  },
  {
    "text": "a little bit of volume is that better all right I think that's",
    "start": "98119",
    "end": "103799"
  },
  {
    "text": "good okay so I'm Richard Johnson I'm a senior security engineer with high defense Labs uh generally just work on",
    "start": "105479",
    "end": "113880"
  },
  {
    "text": "vulnerability research and uh software analysis and here to go ahead and",
    "start": "113880",
    "end": "119439"
  },
  {
    "text": "introduce all right um The Who great love mics um",
    "start": "119439",
    "end": "125680"
  },
  {
    "text": "The Talk today is going to cover um what buffer over overflow protection is um",
    "start": "125680",
    "end": "130800"
  },
  {
    "text": "how it works uh basically it's going to you know it's the software that prevents uh overflows execution of code and could",
    "start": "130800",
    "end": "138160"
  },
  {
    "text": "potentially prot protect you against oday um for those of us who are experienced in the Linux realm though of",
    "start": "138160",
    "end": "143720"
  },
  {
    "text": "pxs and um other things the new aspect of this is going to be uh two products that we uh did research on that attempt",
    "start": "143720",
    "end": "151000"
  },
  {
    "text": "to implement packs like protection um and so we'll show you those and we'll do some",
    "start": "151000",
    "end": "157480"
  },
  {
    "text": "demos all right um we're going to talk about uh compiler enforce protection uh",
    "start": "157879",
    "end": "163319"
  },
  {
    "text": "first and we're going to cover um stack guard stack shield and pro police and these are um all Linux based compiler",
    "start": "163319",
    "end": "170040"
  },
  {
    "text": "protections um they range from Canary like protection to uh rearranging the layout of the stack um we're going to",
    "start": "170040",
    "end": "176360"
  },
  {
    "text": "also talk about Microsoft's uh net protection which we've um know there's done been prior research so we're going",
    "start": "176360",
    "end": "182120"
  },
  {
    "text": "to go over that briefly we're going to then cover uh the colel enforc protection uh packs stack Defender one",
    "start": "182120",
    "end": "187959"
  },
  {
    "text": "one and two uh which are the windows uh based and then uh overflow guard uh and",
    "start": "187959",
    "end": "193480"
  },
  {
    "text": "finally we'll introduce you to the attack Vector test platform which will allow the user and developers to test",
    "start": "193480",
    "end": "200080"
  },
  {
    "text": "how um well their protection um how well their software protects against overflows um you'll notice if you're",
    "start": "200080",
    "end": "206799"
  },
  {
    "text": "following Along online or in the book that there have been some modific the slides and stuff and uh therefore um",
    "start": "206799",
    "end": "213280"
  },
  {
    "text": "we ask that you uh look up here and then look down because you might not see the slide that's in",
    "start": "213280",
    "end": "218920"
  },
  {
    "start": "220000",
    "end": "693000"
  },
  {
    "text": "there so compiler enforce protection essentially takes the the approach that they're going to modify compiler in",
    "start": "220040",
    "end": "227040"
  },
  {
    "text": "process so that you can make direct modifications to the binary that gets generated by that compiler uh general",
    "start": "227040",
    "end": "235360"
  },
  {
    "text": "concepts is that they want to uh protect the Control Data stored on the stack essentially overflows want to redirect",
    "start": "235360",
    "end": "241920"
  },
  {
    "text": "the program execution by overflowing a a return address or a function pointer",
    "start": "241920",
    "end": "247159"
  },
  {
    "text": "that's stored somewhere in memory what they try to do is uh either reorder the stack variables so that if a you know a",
    "start": "247159",
    "end": "254400"
  },
  {
    "text": "character array overflows a pointer won't be after it it'll immediately overflow the canary and therefore you",
    "start": "254400",
    "end": "261000"
  },
  {
    "text": "know that uh it's there's been a breach in the Integrity of the program flow and",
    "start": "261000",
    "end": "266199"
  },
  {
    "text": "stack canaries take form in in four different ways there's a a random Canary which is exactly what it's it's a it's a",
    "start": "266199",
    "end": "273560"
  },
  {
    "text": "randomized long 4 byte value that gets compared during the uh function prologue",
    "start": "273560",
    "end": "280240"
  },
  {
    "text": "and EP or gets generated during the prologue gets compared during the epilog to make sure that the the modification",
    "start": "280240",
    "end": "285919"
  },
  {
    "text": "to the stack hasn't occurred uh during the process of that function there's also the XO caner which essentially is",
    "start": "285919",
    "end": "293680"
  },
  {
    "text": "the same thing only the exor it with the original return address so that the generated value",
    "start": "293680",
    "end": "300199"
  },
  {
    "text": "is uh comparable and you can't just assume that the random value there there isn't much more protection provided",
    "start": "300199",
    "end": "305960"
  },
  {
    "text": "these are just different methods a null Canary is based upon the concept that strings are generally terminated by nles",
    "start": "305960",
    "end": "312680"
  },
  {
    "text": "and if you have NES in your shell code and you try to overflow a function which is a string based function then uh you",
    "start": "312680",
    "end": "319520"
  },
  {
    "text": "know you're not going to be able to insert that null very easily Terminator canaries take that step a little bit",
    "start": "319520",
    "end": "324759"
  },
  {
    "text": "further and uh they use a combination of uh you know return",
    "start": "324759",
    "end": "330160"
  },
  {
    "text": "uh like the actual return character CR LF and uh NES as well to take care of",
    "start": "330160",
    "end": "336560"
  },
  {
    "text": "functions like fits and and uh actual data functions that don't necessarily",
    "start": "336560",
    "end": "342039"
  },
  {
    "text": "terminate on nules the advantages of using a compiler enforced approach uh essentially is that",
    "start": "342039",
    "end": "349039"
  },
  {
    "text": "there's no systemwide performance impact uh later on we'll talk about the kernel-based sometimes you have a",
    "start": "349039",
    "end": "355280"
  },
  {
    "text": "performance impact due to the fact that uh x86 processors don't natively support a non-executable paging mechanism",
    "start": "355280",
    "end": "362560"
  },
  {
    "text": "therefore uh they have to emulate that in software so there's no system wide performance impact you can you know",
    "start": "362560",
    "end": "368680"
  },
  {
    "text": "specifically choose which software will be protected and you know if if there will be a performance impact it will be",
    "start": "368680",
    "end": "374639"
  },
  {
    "text": "isolated to that binary itself not only that but since the compiler is what's",
    "start": "374639",
    "end": "380000"
  },
  {
    "text": "generating the binary from source code there's you know it has intimate knowledge in the layout and the structure it's able to modify values and",
    "start": "380000",
    "end": "386800"
  },
  {
    "text": "and relocate things um in the order that the gets generated therefore you know in",
    "start": "386800",
    "end": "392560"
  },
  {
    "text": "that approach you're able to specifically work out where vulnerabilities may occur and uh try to prevent those vectors from changing",
    "start": "392560",
    "end": "399440"
  },
  {
    "text": "control the data disadvantage of this is of course that you have to apply this to every binary you have to recompile your",
    "start": "399440",
    "end": "405280"
  },
  {
    "text": "libraries you have to compile the source code that you want to protect that's going to be a problem if you don't have the source code and uh therefore I mean",
    "start": "405280",
    "end": "413199"
  },
  {
    "text": "that's that's one of the major disadvantages of a compiler approach also since uh like I said the",
    "start": "413199",
    "end": "418919"
  },
  {
    "text": "intimate knowledge of the binary structure allows you to change the the the final generation of the executable",
    "start": "418919",
    "end": "424919"
  },
  {
    "text": "but you have to account for every attack vector and in the case of you know next",
    "start": "424919",
    "end": "430199"
  },
  {
    "text": "time we come out with a new attack Vector like format strings in the past or you know methods for overriding data",
    "start": "430199",
    "end": "437039"
  },
  {
    "text": "they're going to have to you know modify their approach to protect your software",
    "start": "437039",
    "end": "442280"
  },
  {
    "text": "differently stack guard was basically uh it was created by AMX and uh Chrisman",
    "start": "442280",
    "end": "448599"
  },
  {
    "text": "Cowen and a pioneer the the theory of stat canaries and uh essentially the stat Canary is generated",
    "start": "448599",
    "end": "455440"
  },
  {
    "text": "during the function prologue which is the little stub of code that gets executed before every function and uh",
    "start": "455440",
    "end": "461520"
  },
  {
    "text": "the validation steps occur at the function epilog which is essentially the little St that gets executed every time",
    "start": "461520",
    "end": "467240"
  },
  {
    "text": "you return from a function um originally the canary was just put adjacent to the return address",
    "start": "467240",
    "end": "472759"
  },
  {
    "text": "so it was put right before the return address and a buffer overflow you know your data goes beyond the buffer that",
    "start": "472759",
    "end": "478840"
  },
  {
    "text": "was originally allocated and eventually hits the Control Data that's on the stack so they put the canary right",
    "start": "478840",
    "end": "484759"
  },
  {
    "text": "before that Control Data check in that blog if it's been overwritten or modified then they know that there's",
    "start": "484759",
    "end": "489840"
  },
  {
    "text": "been a breach in Integrity latest versions you know as as the theory has been progressed you know",
    "start": "489840",
    "end": "496280"
  },
  {
    "text": "the newer versions protect the return address the frame pointer you know sometimes they even protect the function",
    "start": "496280",
    "end": "502280"
  },
  {
    "text": "pointers that are stored on the stack to validate that they're um pointing to the text section and are non-executable",
    "start": "502280",
    "end": "508240"
  },
  {
    "text": "pages and uh also just in the latest version of Stack guard uh the canary location",
    "start": "508240",
    "end": "514800"
  },
  {
    "text": "has been modified so that depending on the architecture that you're running your program on the the canary location",
    "start": "514800",
    "end": "520599"
  },
  {
    "text": "is put in an optimal place so that it doesn't affect or so it's more difficult to actually reach and modify essentially",
    "start": "520599",
    "end": "527800"
  },
  {
    "text": "if you're able to override the canary when they compare the canary to the save value then you know I mean you can do it",
    "start": "527800",
    "end": "533920"
  },
  {
    "text": "either way uh so they they they change the location of it so that it's more difficult to overwrite",
    "start": "533920",
    "end": "540800"
  },
  {
    "text": "after stack guard was around and we had the development of Stack Shield which currently isn't really supported but",
    "start": "540800",
    "end": "546800"
  },
  {
    "text": "it's interesting nonetheless um their approach was the concept of a global",
    "start": "546800",
    "end": "551839"
  },
  {
    "text": "return stack and a return range check essentially all it is is that they copy",
    "start": "551839",
    "end": "557040"
  },
  {
    "text": "the return address to a safe location and they're able to in in the case of",
    "start": "557040",
    "end": "562880"
  },
  {
    "text": "the return stack they just copy it back from that known location overwrite wherever the return address would have",
    "start": "562880",
    "end": "568760"
  },
  {
    "text": "been with they already known save data and are able to keep Integrity that way",
    "start": "568760",
    "end": "574200"
  },
  {
    "text": "with the return range check you get the uh added benefit of being able to know that there's been an overwrite because",
    "start": "574200",
    "end": "580279"
  },
  {
    "text": "it compares the uh the saved address with the uh the actual value that's in",
    "start": "580279",
    "end": "586120"
  },
  {
    "text": "the stack so with the global return stack you're not going to be able to know that occurred because essentially",
    "start": "586120",
    "end": "592880"
  },
  {
    "text": "they don't care what that value is they just copy it out and put it back and the return range check they're able to do the comparison and catch you know in the",
    "start": "592880",
    "end": "600399"
  },
  {
    "text": "act of overflow also one other thing is they do check for function pointers make sure",
    "start": "600399",
    "end": "605959"
  },
  {
    "text": "they're they're pointing into the text section of the binary which which is an added benefit latest developments uh and in",
    "start": "605959",
    "end": "614040"
  },
  {
    "text": "the software in the compiler world of prop police and um although stack guard",
    "start": "614040",
    "end": "619240"
  },
  {
    "text": "claimed that they were going to be integrated into GCC compiler already it hasn't really occurred but prop police",
    "start": "619240",
    "end": "624360"
  },
  {
    "text": "is starting to get integrated in a number of distributions such as Gen 2 and uh a couple of others and in our",
    "start": "624360",
    "end": "631399"
  },
  {
    "text": "test results you will see that they definitely have provided the most complete uh compiler based protection it",
    "start": "631399",
    "end": "638440"
  },
  {
    "text": "implements the safe stack model which re rearranges the actual values in the stack so that overriding pointers after",
    "start": "638440",
    "end": "646160"
  },
  {
    "text": "a buffer is theoretically not possible generally in uh in your usual",
    "start": "646160",
    "end": "652480"
  },
  {
    "text": "stack layout you've got your arrays and local variables and then you know your return addresses directly afterwards and",
    "start": "652480",
    "end": "659320"
  },
  {
    "text": "in the case of a uh you know vulnerable code segment like this one if you were to overflow the car buff uh buffer then",
    "start": "659320",
    "end": "667800"
  },
  {
    "text": "the next thing that you would hit was a the function pointer well what they do is they rearrange it so that the",
    "start": "667800",
    "end": "674079"
  },
  {
    "text": "function pointers are located previous to that buffer so that you would immediately overflow the the saved",
    "start": "674079",
    "end": "679639"
  },
  {
    "text": "Canary value and they also uh save the function pointer in a return or in a local variable or",
    "start": "679639",
    "end": "685920"
  },
  {
    "text": "register which essentially makes it much more difficult to overwrite and I'll turn it back over to Peter so",
    "start": "685920",
    "end": "691560"
  },
  {
    "text": "we can cover the Microsoft side all right um like pre I said previously uh this this has been talked about in depth",
    "start": "691560",
    "end": "697760"
  },
  {
    "start": "693000",
    "end": "835000"
  },
  {
    "text": "so we're just going to touch on it and then U move on to the more interesting stuff um Microsoft wanted a way",
    "start": "697760",
    "end": "703279"
  },
  {
    "text": "initially to um try to secure their products out of the box so that their um slow PCH time would not be affected um",
    "start": "703279",
    "end": "710320"
  },
  {
    "text": "how so this resulted in them adding a buffer overpro protection into the net compiler um the net compiler is",
    "start": "710320",
    "end": "717440"
  },
  {
    "text": "basically um a rein aration of chrisen Cohen's uh stack guard which we just talked about however there are some",
    "start": "717440",
    "end": "723079"
  },
  {
    "text": "subtle differences um they call um the random value pushed on the stack a cookie instead of a canary and they also",
    "start": "723079",
    "end": "729839"
  },
  {
    "text": "store um what would be referred to as the canary death Handler in writable memory um so we'll see how that plays",
    "start": "729839",
    "end": "737240"
  },
  {
    "text": "out um the net compiler works like this um it adds a cookie in front of the save",
    "start": "737240",
    "end": "742680"
  },
  {
    "text": "DVP and uh return address so if the buffer is to overflow it will overflow the cookie and on the check um the check",
    "start": "742680",
    "end": "749000"
  },
  {
    "text": "will fail and the program will exit um what happens is the check occurs um the",
    "start": "749000",
    "end": "754160"
  },
  {
    "text": "cookie is checked against the stored the stored cookie in the data section if they're not um the same it checks to see",
    "start": "754160",
    "end": "760160"
  },
  {
    "text": "if there's secur a security Handler defined if there is and the security Handler stored in the data section um it",
    "start": "760160",
    "end": "766680"
  },
  {
    "text": "will call the security Handler otherwise it will call the unhandled exception filter Microsoft also with this release",
    "start": "766680",
    "end": "772240"
  },
  {
    "text": "made um modifications to their exception Handler um the exception hand some of these modifications were uh the",
    "start": "772240",
    "end": "777800"
  },
  {
    "text": "exception Handler can't point to the stack so you can't overwrite the exception Handler and point it to your code um also the um exception handlers",
    "start": "777800",
    "end": "786160"
  },
  {
    "text": "are stored in uh the load directory config section of the executable so if it's not a registered exception Handler",
    "start": "786160",
    "end": "791519"
  },
  {
    "text": "it will not execute um the bypass basically there are a couple ways to",
    "start": "791519",
    "end": "796600"
  },
  {
    "text": "bypass um the exception Handler one is that if you can get your um code onto the Heap you can point the exception",
    "start": "796600",
    "end": "802199"
  },
  {
    "text": "Handler to the Heap and it will still execute also if you can um appoint your",
    "start": "802199",
    "end": "807360"
  },
  {
    "text": "exception Handler to a registered exception Handler and then abuse that exception Handler you're able to get your code",
    "start": "807360",
    "end": "812760"
  },
  {
    "text": "executed and finally um if you have a pointer overwrite which is um specific",
    "start": "812760",
    "end": "818040"
  },
  {
    "text": "to different scenarios you can overwrite the saved cookie which will make the uh cookie check um pass and then you can",
    "start": "818040",
    "end": "824360"
  },
  {
    "text": "return into your code or overwrite the security Handler if it's defined and uh execute your code that way and those are",
    "start": "824360",
    "end": "829959"
  },
  {
    "text": "just a couple ways that like I said it's documented and uh you can read up on",
    "start": "829959",
    "end": "835240"
  },
  {
    "text": "it so those are the different compiler choices compiler protections that are currently available",
    "start": "835240",
    "end": "841519"
  },
  {
    "text": "those those take the the approach of modifying the B directly and the kernel Forest method essentially a patch is",
    "start": "841519",
    "end": "848079"
  },
  {
    "text": "done in the kernel to add protection features such as a non-executable stack or um address layout randomization that",
    "start": "848079",
    "end": "855480"
  },
  {
    "text": "essentially try to eliminate the effectiveness of an exploit if uh if you have non-executable Pages then obviously",
    "start": "855480",
    "end": "861720"
  },
  {
    "text": "if you put your data onto the stack and you try to execute it or in the Heap uh you know it's not going to execute",
    "start": "861720",
    "end": "867920"
  },
  {
    "text": "you'll you'll throw a page fault they're able to catch it or in the case of you know old school exploits that still rely",
    "start": "867920",
    "end": "874040"
  },
  {
    "text": "on uh hard-coded addresses you know that the address randomization is going to take care of that so the comp the",
    "start": "874040",
    "end": "881480"
  },
  {
    "text": "essentially it's it's accomplished through applying access controls to mmu so I mean that's that would be the",
    "start": "881480",
    "end": "886600"
  },
  {
    "text": "non-executable pages uh modifications to your um M protect uh or your um your",
    "start": "886600",
    "end": "893759"
  },
  {
    "text": "other functions that allocate new memory during the process of your execution and essentially they they limit the the use",
    "start": "893759",
    "end": "901560"
  },
  {
    "text": "of those functions so that you can't change the permissions of a page at a later date if it's already been written to and of course the randomization of",
    "start": "901560",
    "end": "908360"
  },
  {
    "text": "the process memory like I said uh essentially the goal of Kernel enforced protection according to Pax is to uh",
    "start": "908360",
    "end": "916440"
  },
  {
    "text": "prevent or contain the introduction of AR the introduction execution of arbitrary code generally the the",
    "start": "916440",
    "end": "923560"
  },
  {
    "text": "introduction of arbitrary code into a program is is not easy to stop because we have vulnerable functions out there",
    "start": "923560",
    "end": "928720"
  },
  {
    "text": "that allow you to write beyond the bounds of your buffers but uh you know I mean if you put that data there and you",
    "start": "928720",
    "end": "933800"
  },
  {
    "text": "can't execute it then essentially it's no big deal you're just going to crash the program also execution of existing",
    "start": "933800",
    "end": "940319"
  },
  {
    "text": "code out of program ORD so if you were able to do for example a return to lib C attack where the code's already in the",
    "start": "940319",
    "end": "947440"
  },
  {
    "text": "in the program itself you just redirect the program to execute that code out of the original order it was intended or",
    "start": "947440",
    "end": "954040"
  },
  {
    "text": "execution of existing code uh in the original program order but with arbitrary data for example if you were",
    "start": "954040",
    "end": "959800"
  },
  {
    "text": "to do a memory copy to a pointer that you were able to control you can then write arbitrary values to anywhere in in",
    "start": "959800",
    "end": "966680"
  },
  {
    "text": "your memory space so they they try to contain those three different methods of of modifying the program flow the",
    "start": "966680",
    "end": "972800"
  },
  {
    "text": "advantages of this is of course that you don't have to have source code since it's done on a kernel level it's",
    "start": "972800",
    "end": "978279"
  },
  {
    "text": "systemwide it instantly takes effect in every program that you execute and uh you know it's it's a blanket",
    "start": "978279",
    "end": "985480"
  },
  {
    "text": "application and not only that but kernel has control over the mmu unlike the binary itself so you're able to you know",
    "start": "985480",
    "end": "992560"
  },
  {
    "text": "apply those access controls to the different functionality or the different functions uh that you know allocate new",
    "start": "992560",
    "end": "998160"
  },
  {
    "text": "pages or try try to change permissions which are all controlled in the kernel itself of course the disadvantages of",
    "start": "998160",
    "end": "1004079"
  },
  {
    "text": "this is that it it's architecture and platform dependent unlike a patch to GCC which will apply across the board since",
    "start": "1004079",
    "end": "1010360"
  },
  {
    "text": "it's just modifying the prologue and epilog functions um in this case you're going to have to do a lot more work as",
    "start": "1010360",
    "end": "1016880"
  },
  {
    "text": "far as making it work on a spark architecture as opposed to x86 or you know power PC whatever it may be and",
    "start": "1016880",
    "end": "1023720"
  },
  {
    "text": "also you you'll have a noticeable performance impact dependent on the way that they Implement their page",
    "start": "1023720",
    "end": "1029959"
  },
  {
    "text": "protection uh for example with PS um up until the most recent version with the Linux 2.6 kernel uh the page exec was",
    "start": "1029959",
    "end": "1039280"
  },
  {
    "text": "much slower than the segmentation logic and I mean it just comes down to the amount of uh emulation that they have to",
    "start": "1039280",
    "end": "1044959"
  },
  {
    "text": "do in software and the kernel to provide that protection layer",
    "start": "1044959",
    "end": "1050840"
  },
  {
    "start": "1051000",
    "end": "1131000"
  },
  {
    "text": "so non-executable protection is the most commonly used access control I mean obviously like I said again uh if if",
    "start": "1051200",
    "end": "1059080"
  },
  {
    "text": "you're not able to execute that arbitrary code and it the impact is pretty much negated um a non-executable",
    "start": "1059080",
    "end": "1066200"
  },
  {
    "text": "stack is it's on a system they they refer to it as enforcing proper memory",
    "start": "1066200",
    "end": "1071360"
  },
  {
    "text": "semantics you know it's basically a buzz word that says we need to separate the readable and writable pages so you're",
    "start": "1071360",
    "end": "1078000"
  },
  {
    "text": "able to write to that page uh then you know you shouldn't be able to execute it later by default on x86 architecture if",
    "start": "1078000",
    "end": "1084880"
  },
  {
    "text": "a page is readable it's also executable so essentially you know that could be read separate the writable from",
    "start": "1084880",
    "end": "1090520"
  },
  {
    "text": "executable Pages as well um all executable memory including the stack Heap and Anonymous mappings must be",
    "start": "1090520",
    "end": "1097000"
  },
  {
    "text": "non-executable and that just makes sense that's where your your data is going to be stored and obviously if that's your",
    "start": "1097000",
    "end": "1102480"
  },
  {
    "text": "data sections you shouldn't be executing from them you should just be modifying the values that are going to be ex that",
    "start": "1102480",
    "end": "1108200"
  },
  {
    "text": "are going to be plugged into the actual code execution in the text section anyway and uh finally just deny the",
    "start": "1108200",
    "end": "1113559"
  },
  {
    "text": "conversion of executable memory to non-executable memory and vice versa so you know obviously if you have a page",
    "start": "1113559",
    "end": "1120400"
  },
  {
    "text": "that's been marked non-executable so it's meant for data storage you can't later do a return to Li C type thing",
    "start": "1120400",
    "end": "1126039"
  },
  {
    "text": "that would unprotect that that data so you could execute it later aslr or address space layout",
    "start": "1126039",
    "end": "1134159"
  },
  {
    "start": "1131000",
    "end": "1256000"
  },
  {
    "text": "randomization uh defeats you know the the the techniques that rely on",
    "start": "1134159",
    "end": "1139320"
  },
  {
    "text": "static values or offsets into memory that uh would generally be a pre-known",
    "start": "1139320",
    "end": "1145080"
  },
  {
    "text": "value so by modifying the layout of the binary obviously that's going to shift the locations of all you know the",
    "start": "1145080",
    "end": "1152200"
  },
  {
    "text": "predetermined addresses so uh that will effectively reduce the impact of of an",
    "start": "1152200",
    "end": "1158520"
  },
  {
    "text": "exploit because it's not going to get to the right values um also it just gives you the",
    "start": "1158520",
    "end": "1163840"
  },
  {
    "text": "advantage of uh you know it Maps the the binary mapping and the loader it is will",
    "start": "1163840",
    "end": "1168919"
  },
  {
    "text": "load at a different location than the standard uh addresses that are predefined in the kernel as well and uh",
    "start": "1168919",
    "end": "1175159"
  },
  {
    "text": "further Library linking and uh you know kernel space execution is also",
    "start": "1175159",
    "end": "1181559"
  },
  {
    "text": "randomized so we're going to take a look at pxs PX is pretty much the definitive",
    "start": "1181559",
    "end": "1186760"
  },
  {
    "text": "kernel patch uh as far as implementing buffer over full protection just about every uh effective kernel patch has been",
    "start": "1186760",
    "end": "1194640"
  },
  {
    "text": "based on you know the work that pax's project has done uh and some of them even include packs as a subset of the",
    "start": "1194640",
    "end": "1201159"
  },
  {
    "text": "features such as gr security um and as we said it offers the",
    "start": "1201159",
    "end": "1207039"
  },
  {
    "text": "prevention through those two methods the mmu access controls and the address space randomization they refer to their",
    "start": "1207039",
    "end": "1213080"
  },
  {
    "text": "non-executable stack protection as no exec um it obviously aims to prevent",
    "start": "1213080",
    "end": "1218159"
  },
  {
    "text": "execution arbitrary code the uh the three features which ultimately are the access controls are the executable",
    "start": "1218159",
    "end": "1225200"
  },
  {
    "text": "semantics are applied to memory Pages meaning that you know the separation of of executable and writable Pages uh the",
    "start": "1225200",
    "end": "1231240"
  },
  {
    "text": "stack he Anonymous memory mappings in any section not marked as executable such as the text section are marked non-",
    "start": "1231240",
    "end": "1238200"
  },
  {
    "text": "executable by default you'll notice if you look at your memory mappings today that some pages for some reason are just",
    "start": "1238200",
    "end": "1244080"
  },
  {
    "text": "marked executable even though they're also writable they they fixed that and then also the ACLS are applied to map",
    "start": "1244080",
    "end": "1249840"
  },
  {
    "text": "and M protect so that will later prevent the conversion of non-executable pages to",
    "start": "1249840",
    "end": "1255240"
  },
  {
    "text": "executable um they Implement their uh page protection non executable",
    "start": "1255240",
    "end": "1260400"
  },
  {
    "start": "1256000",
    "end": "1370000"
  },
  {
    "text": "protection in two different ways one's segmentation based the segmentation logic of X6 processors and then the",
    "start": "1260400",
    "end": "1266720"
  },
  {
    "text": "other one's the page the paging logic um essentially pages are allocated and they",
    "start": "1266720",
    "end": "1275279"
  },
  {
    "text": "pointers to them are stored in a pte or pte page table entries and in those entries are uh permission bits that",
    "start": "1275279",
    "end": "1283120"
  },
  {
    "text": "essentially Define you know what type of page this is is it a kernel page is it a userland page um um and in the case of a",
    "start": "1283120",
    "end": "1291919"
  },
  {
    "text": "memory that's been swapped out it'll be marked as non-present so that the colonel knows how to handle that when it's referred to from the program so if",
    "start": "1291919",
    "end": "1298559"
  },
  {
    "text": "a page is marked nonpresent or another bit is referred to a super supervisor level access uh a page fault occurs and",
    "start": "1298559",
    "end": "1306400"
  },
  {
    "text": "then the colonel you know figures out what what it needs to do from there if uh in the case of the page exec logic",
    "start": "1306400",
    "end": "1312960"
  },
  {
    "text": "what they try to do is Mark the pages as nonpresent or supervisor level access to throw the page fault when it gets",
    "start": "1312960",
    "end": "1318559"
  },
  {
    "text": "referred to and it's able to compare if the page fault occurred at the same EIP",
    "start": "1318559",
    "end": "1324720"
  },
  {
    "text": "or process count of the program then that then you know that the page fault occurred on an instruction fetch because",
    "start": "1324720",
    "end": "1331159"
  },
  {
    "text": "it's trying to execute code from that location that the page fault actually occurred at if it's a data access you'll",
    "start": "1331159",
    "end": "1336799"
  },
  {
    "text": "still get a page fault but the EIP will be different from the actual page fault location like if you get a if you",
    "start": "1336799",
    "end": "1342640"
  },
  {
    "text": "reference a null if you have like a null poter D reference for example you're going to get a page fault that says you",
    "start": "1342640",
    "end": "1348039"
  },
  {
    "text": "know page default location was nules it all nuls you know if you get an air well",
    "start": "1348039",
    "end": "1353240"
  },
  {
    "text": "in that case then you know that the program execution obviously you didn't just execute an instruction from you",
    "start": "1353240",
    "end": "1358440"
  },
  {
    "text": "know zero in memory you're obviously going to be executing from some location so by doing that they're able to",
    "start": "1358440",
    "end": "1364480"
  },
  {
    "text": "determine if that was you know an instruction fetch or a data Fetch and uh act",
    "start": "1364480",
    "end": "1370000"
  },
  {
    "start": "1370000",
    "end": "1586000"
  },
  {
    "text": "appropriately segmentation logic is uh something that we usually don't really",
    "start": "1370000",
    "end": "1375120"
  },
  {
    "text": "uh we're not very aware of on a day-to-day basis because uh modern kernels pretty much uh make it",
    "start": "1375120",
    "end": "1381799"
  },
  {
    "text": "transparent in the conversion of logical addresses to physical addresses um",
    "start": "1381799",
    "end": "1387279"
  },
  {
    "text": "essentially the uh tlb trans uh translation look aide buffer is what",
    "start": "1387279",
    "end": "1393400"
  },
  {
    "text": "determines uh if the data access is going to be in a code segment or a data",
    "start": "1393400",
    "end": "1398760"
  },
  {
    "text": "segment and code segment would be the executable segments obviously and the data segments would be the ones that store your data um usually the entire uh",
    "start": "1398760",
    "end": "1408080"
  },
  {
    "text": "memory space is mapped on both the the dtlb as well as the the code segments so",
    "start": "1408080",
    "end": "1413679"
  },
  {
    "text": "regardless of where you put your memory the kernel just handles it the translation and it doesn't separate you know data data values have to always be",
    "start": "1413679",
    "end": "1421200"
  },
  {
    "text": "below this memory address space or code values always have to be above this this this segment but in the logic",
    "start": "1421200",
    "end": "1428760"
  },
  {
    "text": "essentially it knows that if you tried to execute from the data segment then obviously your your page fault will",
    "start": "1428760",
    "end": "1435320"
  },
  {
    "text": "occur and it can handle it from there as well the uh the M protect feature of pxs uh",
    "start": "1435320",
    "end": "1443400"
  },
  {
    "text": "prevents the introduction of new code uh executable code actually into a given",
    "start": "1443400",
    "end": "1448520"
  },
  {
    "text": "task address space so uh the objective is to you know prevent the creation of",
    "start": "1448520",
    "end": "1454000"
  },
  {
    "text": "executable Anonymous mappings so I mean if you bring in a file and you mmap that in you you shouldn't be able to execute",
    "start": "1454000",
    "end": "1460559"
  },
  {
    "text": "the data that's in that file or you know creation of executable and writable file mappings um executable read only mapping",
    "start": "1460559",
    "end": "1468640"
  },
  {
    "text": "writable except for performance uh they have to do relocations on dynamically",
    "start": "1468640",
    "end": "1473919"
  },
  {
    "text": "compiled elf binary so that you know they can't",
    "start": "1473919",
    "end": "1478960"
  },
  {
    "text": "really they can't really apply the same access controls on that level because you know you're going to have to be able to relocate that to a different area in",
    "start": "1478960",
    "end": "1485320"
  },
  {
    "text": "memory and then also of course the conversion of non-executable to executable mapping um every memory mapping has",
    "start": "1485320",
    "end": "1492559"
  },
  {
    "text": "permission attributes in the kernel and the VM Flags field and essentially those",
    "start": "1492559",
    "end": "1498399"
  },
  {
    "text": "that there's a number of different permission bits but the ones that we're mostly concerned with are the writable executable readable um and in our case",
    "start": "1498399",
    "end": "1505840"
  },
  {
    "text": "like I said readable and executable pages are the exact same thing since there isn't native support for that",
    "start": "1505840",
    "end": "1511840"
  },
  {
    "text": "non-executable bit um essentially once you eliminate all the different combinations of May write write May",
    "start": "1511840",
    "end": "1518720"
  },
  {
    "text": "execute execute bits uh they have to narrow it down to these four which I mean it's pretty obvious it makes sense",
    "start": "1518720",
    "end": "1524919"
  },
  {
    "text": "that it's okay to have May right and WR on the same page but but you can't have may execute and write you know I mean",
    "start": "1524919",
    "end": "1531200"
  },
  {
    "text": "that would mean that you could convert that page to executable later after you've written to it the aslr component uh consists of",
    "start": "1531200",
    "end": "1539880"
  },
  {
    "text": "four different subcomponents the that are listed here the user stack kernel",
    "start": "1539880",
    "end": "1545039"
  },
  {
    "text": "stack memory mappings and executable loading the uh user stack is randomized",
    "start": "1545039",
    "end": "1551320"
  },
  {
    "text": "upon each exact call uh it has to allocate the number of pages and then",
    "start": "1551320",
    "end": "1557640"
  },
  {
    "text": "Maps those pag to the processes virtual space usually you can see that the stack is mapped at",
    "start": "1557640",
    "end": "1563840"
  },
  {
    "text": "BFF well what they can do now that it's in the kernel they can modify that default location every time a binary is",
    "start": "1563840",
    "end": "1569960"
  },
  {
    "text": "executed and you know it will shift uh you can look at the pack stocks but there's variable bit shifts um you know",
    "start": "1569960",
    "end": "1578159"
  },
  {
    "text": "to introduce different levels of entropy at at different points in the memory mappings",
    "start": "1578159",
    "end": "1585600"
  },
  {
    "text": "themselves kernel stack memor randomization essentially uh works on",
    "start": "1585840",
    "end": "1591480"
  },
  {
    "start": "1586000",
    "end": "1637000"
  },
  {
    "text": "the theory that or on the actual concept that every time a system call is executed and the context which occurs",
    "start": "1591480",
    "end": "1599240"
  },
  {
    "text": "your um execution in the kernel space will start at the same memory location",
    "start": "1599240",
    "end": "1605000"
  },
  {
    "text": "uh because you can't just leave value you can't leave values laying around in the kernel that are going to be there later so essentially every time you do",
    "start": "1605000",
    "end": "1611919"
  },
  {
    "text": "that context switch before you return the uh the memory is cleaned up and your pointer is going to be at the same location so therefore there able to",
    "start": "1611919",
    "end": "1618600"
  },
  {
    "text": "randomize that every single time you do the contact switch and uh and shift accordingly I mean this this prevents",
    "start": "1618600",
    "end": "1626000"
  },
  {
    "text": "you know kernel-based exploits that would normally be able to you know try to resolve a current address of where",
    "start": "1626000",
    "end": "1631840"
  },
  {
    "text": "that pointer is and then work from there so uh so it's it's pretty effective the",
    "start": "1631840",
    "end": "1637279"
  },
  {
    "start": "1637000",
    "end": "1725000"
  },
  {
    "text": "map protection uh essentially is able to modify the location of your HEAP as well",
    "start": "1637279",
    "end": "1644399"
  },
  {
    "text": "uh it just does this by adding some additional functionality in the do map and adding a a random Delta value uh to",
    "start": "1644399",
    "end": "1651679"
  },
  {
    "text": "the Base address before searching for free memory whenever you try to mmap something essentially all it does is it",
    "start": "1651679",
    "end": "1656960"
  },
  {
    "text": "looks for the next chunk of unallocated memory that's of appropriate size for",
    "start": "1656960",
    "end": "1662159"
  },
  {
    "text": "the memory space that you're asking for and finally the uh executable",
    "start": "1662159",
    "end": "1668039"
  },
  {
    "text": "portion of this is uh is kind of interesting because obviously if you're running a binary that wasn't compiled to",
    "start": "1668039",
    "end": "1674039"
  },
  {
    "text": "be position independent you're going to have some direct references to to pointers in in the memory itself like",
    "start": "1674039",
    "end": "1680919"
  },
  {
    "text": "function pointers and whatnot well what it does here is it Maps it as usual but",
    "start": "1680919",
    "end": "1686480"
  },
  {
    "text": "then it also Maps another copy of it using the the M map logic that I just discussed and then it marks the pages of",
    "start": "1686480",
    "end": "1692640"
  },
  {
    "text": "the originally mapped executable as non-executable what will occur then is that whenever one of those hard-coded",
    "start": "1692640",
    "end": "1698600"
  },
  {
    "text": "values is referred to page fault Handler will see that this is referring to the original mapped binary and uh do",
    "start": "1698600",
    "end": "1707080"
  },
  {
    "text": "something that they call uh VMA mirroring and uh you can look at the docs there too it's it's a little",
    "start": "1707080",
    "end": "1713399"
  },
  {
    "text": "little tricky but essentially what it does is it resolves the fact that they were trying to execute non-executable copy resolves where the currently",
    "start": "1713399",
    "end": "1720480"
  },
  {
    "text": "allocated uh copy of the binary is and just redirects it back into that and back to Windows all right",
    "start": "1720480",
    "end": "1727720"
  },
  {
    "text": "Windows okay so um we know that uh Windows is an open source so it's not",
    "start": "1727720",
    "end": "1732840"
  },
  {
    "text": "that all that easy to modify the kernel so uh there are a couple products out there we reviewed two that um attempt to",
    "start": "1732840",
    "end": "1739240"
  },
  {
    "text": "implement uh attempt to prevent uh sh code execution I should say um stack",
    "start": "1739240",
    "end": "1744480"
  },
  {
    "text": "Defender 1.10 I should is uh does not Implement no execution stack so if you",
    "start": "1744480",
    "end": "1750200"
  },
  {
    "text": "overflow a buffer you can still execute your shell code um instead stack Defender does what a lot of um host",
    "start": "1750200",
    "end": "1756559"
  },
  {
    "text": "intrusion prevention systems are doing and it uh hooks uh apis and applies uh ACLS to them and we'll describe what",
    "start": "1756559",
    "end": "1762480"
  },
  {
    "text": "kind of uh what kind of um ACLS they apply stack Defender installs um many",
    "start": "1762480",
    "end": "1768360"
  },
  {
    "text": "files but we're going to talk about um the the following files on your screen uh the kernel ngfr msvc ngfr and NTD",
    "start": "1768360",
    "end": "1776720"
  },
  {
    "text": "ngfr will refer to quite frequently moving on um stack defender.",
    "start": "1776720",
    "end": "1782679"
  },
  {
    "text": "um SC is uh hooks the ZW create file and ZW open file and to detect uh colel 32 msv",
    "start": "1782679",
    "end": "1790760"
  },
  {
    "text": "search and ntdll if it detects these files it will re it will chop off the last six characters and redirect them",
    "start": "1790760",
    "end": "1797120"
  },
  {
    "text": "into the ng. R files you just saw um before we can talk about the ngfr files",
    "start": "1797120",
    "end": "1802880"
  },
  {
    "text": "we're going to go over um how the hook Works um a system call uh works like follow works as follows um eax will",
    "start": "1802880",
    "end": "1810720"
  },
  {
    "start": "1805000",
    "end": "1826000"
  },
  {
    "text": "contain the function ID so uh 64 is going to be moved into eax um edx is",
    "start": "1810720",
    "end": "1815760"
  },
  {
    "text": "going to get a pointer to the user land parameters on the stack then the uh interrupt 2E is uh executed this is um",
    "start": "1815760",
    "end": "1822039"
  },
  {
    "text": "for system call however there's also System enter in uh fast call um the the",
    "start": "1822039",
    "end": "1827679"
  },
  {
    "text": "inter table which we'll describe in the uh next section uh acts the Gateway between user mode and kernel mode uh",
    "start": "1827679",
    "end": "1834039"
  },
  {
    "text": "interaction um when you call toe that dispatches the Ki system service which will um look up the uh kernel service",
    "start": "1834039",
    "end": "1841279"
  },
  {
    "text": "descriptor table which um checks the service table Member Service table base",
    "start": "1841279",
    "end": "1846360"
  },
  {
    "text": "and uh indexes that by the function ID so that's basically in layman terms it's basically saying it's getting the um",
    "start": "1846360",
    "end": "1852440"
  },
  {
    "text": "it's indexing uh the descriptor table to get the uh actual function pointer that uh we need to execute and uh this is",
    "start": "1852440",
    "end": "1859240"
  },
  {
    "text": "done a lot and that's how uh user land API is going to interact with",
    "start": "1859240",
    "end": "1864480"
  },
  {
    "text": "kernel um to hook the uh system call basically we set it up so that we don't receive interrupts we retrieve a pointer",
    "start": "1864480",
    "end": "1871360"
  },
  {
    "start": "1865000",
    "end": "1903000"
  },
  {
    "text": "to a ZW create file and then a pointer to a k service descriptor table um we",
    "start": "1871360",
    "end": "1877080"
  },
  {
    "text": "then uh get what K service descriptor table we dreference K service descriptor table and we also get the uh function ID",
    "start": "1877080",
    "end": "1883039"
  },
  {
    "text": "by adding one to the function pointer uh we grab what the what function uh address address uh is pointed to at that",
    "start": "1883039",
    "end": "1889320"
  },
  {
    "text": "ID we uh store it in the old function repeat the process except this time we overwrite that function uh address with",
    "start": "1889320",
    "end": "1895559"
  },
  {
    "text": "the function we want to we want to receive our Hooks and that's essentially how you they're going to hook how the",
    "start": "1895559",
    "end": "1900639"
  },
  {
    "text": "hook Works in a stack Defender um the ngfr files are used by a",
    "start": "1900639",
    "end": "1906960"
  },
  {
    "text": "stack defer to uh add Randomness to a system dlls it's a it's it's not aslr",
    "start": "1906960",
    "end": "1912679"
  },
  {
    "text": "it's an attempt at it it's a Windows attempt basically what happens is the three files are copied colel 32 ndl and",
    "start": "1912679",
    "end": "1919559"
  },
  {
    "text": "msvt into their respective ngfr files um those files are then rebased and put on",
    "start": "1919559",
    "end": "1925639"
  },
  {
    "text": "the system so when the redirection occurs in the uh ZW open and ZW create file um there'll be files to",
    "start": "1925639",
    "end": "1933240"
  },
  {
    "start": "1933000",
    "end": "1988000"
  },
  {
    "text": "call um before we can understand how uh they're going to modify the kernel ngfr",
    "start": "1933240",
    "end": "1938600"
  },
  {
    "text": "first need to understand the export address table the export address table is a structure in the um executable and",
    "start": "1938600",
    "end": "1945080"
  },
  {
    "text": "basically um it's used to uh store what function uh that that usually DL exports",
    "start": "1945080",
    "end": "1950519"
  },
  {
    "text": "to other processes to use um and so we have to understand how get proc address works so basically if you want to get",
    "start": "1950519",
    "end": "1956799"
  },
  {
    "text": "the procedure address of uh let's say connect um you have to obtain the uh export address table in uh wock 32 then",
    "start": "1956799",
    "end": "1965480"
  },
  {
    "text": "you uh walk the address of names and address of name ordinal simultaneously so if you find connect and address of",
    "start": "1965480",
    "end": "1971039"
  },
  {
    "text": "name ordinal you retrieve what address I mean sorry if you find connect in our address of names you retrieve where uh",
    "start": "1971039",
    "end": "1978200"
  },
  {
    "text": "address of name ordinals points and you index address of functions to actually get the entry point to connect and what",
    "start": "1978200",
    "end": "1984480"
  },
  {
    "text": "we'll see how they're going to overwrite this to point to their own code kernel ngfr um is the only ngfr",
    "start": "1984480",
    "end": "1993000"
  },
  {
    "start": "1988000",
    "end": "2036000"
  },
  {
    "text": "file modified the other files are just rebased and uh left alone um what happens is stack Defender is going to",
    "start": "1993000",
    "end": "1998360"
  },
  {
    "text": "modify the relocation sections characteristics to allow them to uh write and execute code in the relocation",
    "start": "1998360",
    "end": "2004760"
  },
  {
    "text": "section um what happens is they're going to copy functions stubs so they hook create process a they're going to copy a",
    "start": "2004760",
    "end": "2010880"
  },
  {
    "text": "stub to the relocation section um which takes the same parameters as create process a except it does different",
    "start": "2010880",
    "end": "2016639"
  },
  {
    "text": "things um next they're going to overwrite the expert address table um function entry point in uh in the kernel",
    "start": "2016639",
    "end": "2025240"
  },
  {
    "text": "ngfr to point to the relocation section so when you uh get get proc on uh kernel",
    "start": "2025240",
    "end": "2030760"
  },
  {
    "text": "ngfr uh you're actually going to receive the relocation section not the actual text",
    "start": "2030760",
    "end": "2036360"
  },
  {
    "text": "section um these are the following functions that uh stacked Fender is going to hook um as you can see it's a wide array and their view is that com",
    "start": "2036360",
    "end": "2044000"
  },
  {
    "text": "most shell codes going to call one of these apis and it's going to allow them to detect the Shell Code execution and",
    "start": "2044000",
    "end": "2049679"
  },
  {
    "text": "as we've seen previously uh this theory is flawed um the Overflow detection",
    "start": "2049679",
    "end": "2055118"
  },
  {
    "start": "2053000",
    "end": "2176000"
  },
  {
    "text": "algorithm is uh somewhat similar to other products we've seen uh the",
    "start": "2055119",
    "end": "2060240"
  },
  {
    "text": "relocation section the function stubs are going to load proxy dl. dll uh I'm",
    "start": "2060240",
    "end": "2065599"
  },
  {
    "text": "just going to call it proxy dll because it's that extra dll throws me off proxy dll uh exports stack Defender and uh",
    "start": "2065599",
    "end": "2073118"
  },
  {
    "text": "stack Defender uh takes in four arguments the first argument is a a static stack address so it's going to",
    "start": "2073119",
    "end": "2079320"
  },
  {
    "text": "always be ESP plus OC um argument two is where the function was called from it's",
    "start": "2079320",
    "end": "2084638"
  },
  {
    "text": "the old EIP uh argument three is an integer that does not play a vital role in the detection of the Overflow and",
    "start": "2084639",
    "end": "2090878"
  },
  {
    "text": "argument four is the stack address of a specific parameter within that API so for create create process a they're",
    "start": "2090879",
    "end": "2096240"
  },
  {
    "text": "going to push argument forward be the process name it's created creating proxy DL um overflow detection",
    "start": "2096240",
    "end": "2103200"
  },
  {
    "text": "goes as follows um they have a routine uh an internal routine it's basically an",
    "start": "2103200",
    "end": "2108320"
  },
  {
    "text": "alert API routine and what this means is if your shell code is going to load library with wock 32 then get Pro get",
    "start": "2108320",
    "end": "2115480"
  },
  {
    "text": "proc address on a connect and bind then create process uh with uh command exe",
    "start": "2115480",
    "end": "2121720"
  },
  {
    "text": "it's going to it hooks those functions so it's going to compare string values to certain parameters and if this occurs",
    "start": "2121720",
    "end": "2127079"
  },
  {
    "text": "Within X number of milliseconds um it will mark it as an overflow we didn't see them pick this this routine did not",
    "start": "2127079",
    "end": "2134320"
  },
  {
    "text": "pick up uh any of our overflows in the attempts uh the other routines did um the next routine is uh they're going to",
    "start": "2134320",
    "end": "2141119"
  },
  {
    "text": "call virtual query on argument one in argument two um and if the uh member",
    "start": "2141119",
    "end": "2146839"
  },
  {
    "text": "basic information uh the memory basic information's member allocation base are",
    "start": "2146839",
    "end": "2151920"
  },
  {
    "text": "equal it means that the uh call was made from the stack and therefore they're going to mark it as an overflow",
    "start": "2151920",
    "end": "2158359"
  },
  {
    "text": "next um they have a feature called enforce writable memory regions basically this means uh they're going to",
    "start": "2158359",
    "end": "2164400"
  },
  {
    "text": "try to detect Heap overflows this is done um by calling is bad right pointer on argument two if it's writable memory",
    "start": "2164400",
    "end": "2171200"
  },
  {
    "text": "region it's going to return zero and therefore they're going to Market as an overflow and exit the program all right uh defeating stack",
    "start": "2171200",
    "end": "2178200"
  },
  {
    "start": "2176000",
    "end": "2208000"
  },
  {
    "text": "Defender uh it's pretty trivial to defeat stack Defender um since they don't prevent Shell Code execution you",
    "start": "2178200",
    "end": "2183839"
  },
  {
    "text": "could essentially um write custom shell code to uh put put the uh copy itself onto the Heap and mark the Heap as read",
    "start": "2183839",
    "end": "2190400"
  },
  {
    "text": "only and then jump to the Heap and execute the actual sh code portion you can also um bypass their",
    "start": "2190400",
    "end": "2197079"
  },
  {
    "text": "hooks by calling higher level functions so we have a diagram here uh create process a eventually calls ZW create",
    "start": "2197079",
    "end": "2203280"
  },
  {
    "text": "process call ZW create process instead of create process a and uh they won't pick it",
    "start": "2203280",
    "end": "2208440"
  },
  {
    "start": "2208000",
    "end": "2259000"
  },
  {
    "text": "up um stack Defender 2.0 we it was it was initially re released and uh we did",
    "start": "2208440",
    "end": "2214800"
  },
  {
    "text": "not have time to do a full analysis so I'm just going to give you a brief overview and then we're going to do a demo on stack Defender 1.10 and 2.0 um",
    "start": "2214800",
    "end": "2222400"
  },
  {
    "text": "stack Defender 2.0 was heavily influenced by PS uh this means they moved away from the API ACLS and more",
    "start": "2222400",
    "end": "2228200"
  },
  {
    "text": "towards the no execution uh Heap and stack and stuff our initial analysis shows that they hook ZW allocate and ZW",
    "start": "2228200",
    "end": "2235160"
  },
  {
    "text": "protect basically to um enforce the proper memory semantics needed uh as described in PAX and as previously",
    "start": "2235160",
    "end": "2241359"
  },
  {
    "text": "mentioned they also hook uh interrupt OE which is the page fault Handler and interrupt uh 2E which is as we saw the U",
    "start": "2241359",
    "end": "2248400"
  },
  {
    "text": "System enter and that's just a basic overview it's not in depth uh we didn't have time",
    "start": "2248400",
    "end": "2254520"
  },
  {
    "text": "but let's uh let's do a demo here hopefully um the demo gods are with us",
    "start": "2254520",
    "end": "2259640"
  },
  {
    "start": "2259000",
    "end": "2286000"
  },
  {
    "text": "on this but no promises all right there's a vulnerability this this image",
    "start": "2259640",
    "end": "2265079"
  },
  {
    "text": "is running stack Defender 1.10 there's a vulnerability in stack Defender 1.10 because they hook ZW create file and ZW",
    "start": "2265079",
    "end": "2271560"
  },
  {
    "text": "open file they uh receive the object attributes parameter they uh dreference this without checking to make sure it's",
    "start": "2271560",
    "end": "2277200"
  },
  {
    "text": "valid because this happens in kernel it's a local Doss it'll reboot the computer um",
    "start": "2277200",
    "end": "2282880"
  },
  {
    "text": "we've uh yeah so let's just see this real quick and there you go it's done",
    "start": "2282880",
    "end": "2288599"
  },
  {
    "start": "2286000",
    "end": "2411000"
  },
  {
    "text": "it's a you don't need privileges um and it just reboots the computer with no warning uh the next vulnerability uh was",
    "start": "2288599",
    "end": "2296520"
  },
  {
    "text": "actually found when uh we first we I can't um pause the",
    "start": "2296520",
    "end": "2302680"
  },
  {
    "text": "machine the virtual machine because this the stat Venter 2.0 hooks ZW allocate",
    "start": "2302680",
    "end": "2308440"
  },
  {
    "text": "and a lot of people think that the performance would be better than um setting Pages a supervisor it's horrible",
    "start": "2308440",
    "end": "2313720"
  },
  {
    "text": "at least in VMware and we were unable um if you pause it it doesn't start up again so we have to reboot from scratch",
    "start": "2313720",
    "end": "2320880"
  },
  {
    "text": "which is why I might take a minute but we found the the stack Defender 2.0 vulnerability exists in uh ZW protect",
    "start": "2320880",
    "end": "2326920"
  },
  {
    "text": "virtual memory they um dreference The Base address without checking it uh it was",
    "start": "2326920",
    "end": "2332440"
  },
  {
    "text": "actually found in a remote uh attempt on a we were working on a returning to libc for RPC C dcom and the screen went blue",
    "start": "2332440",
    "end": "2339680"
  },
  {
    "text": "and that wasn't supposed to happen it was supposed to execute Shell Code so we you know made some decisions and realized what happened so now we you can",
    "start": "2339680",
    "end": "2346240"
  },
  {
    "text": "do it locally on a fully patched system which is what we'll demo here basically um we're going to call ZW protect",
    "start": "2346240",
    "end": "2353119"
  },
  {
    "text": "virtual memory with an invalid Base address of like 1 2 3 4 5 6 78 and uh",
    "start": "2353119",
    "end": "2358800"
  },
  {
    "text": "it's setting up right now and you'll see that the uh screen will go blue as previously mentioned um and you'll also",
    "start": "2358800",
    "end": "2364760"
  },
  {
    "text": "get to see the performance impact probably that hooking the ZW allocate functions um has all right",
    "start": "2364760",
    "end": "2373560"
  },
  {
    "text": "so stack Defender 2.0 starting up we're going to call uh protect three which is",
    "start": "2373560",
    "end": "2378880"
  },
  {
    "text": "the virtual protect and goodbye so this also like",
    "start": "2378880",
    "end": "2384160"
  },
  {
    "text": "you saw it's the same thing and it's basically just another one uh stack Fender was notified of this uh problem",
    "start": "2384160",
    "end": "2390880"
  },
  {
    "text": "and uh they released a patch we think without notifying us so it's on their",
    "start": "2390880",
    "end": "2396079"
  },
  {
    "text": "website they've got a new version whether or not it fixed the problem we don't know that we didn't find out until I left for Vegas and I checked their",
    "start": "2396079",
    "end": "2401640"
  },
  {
    "text": "website and saw a new version um so it might be patched I'm moving",
    "start": "2401640",
    "end": "2408000"
  },
  {
    "text": "on all right oh well I was supposed to show this slide before I did that all right",
    "start": "2408000",
    "end": "2414160"
  },
  {
    "start": "2411000",
    "end": "2451000"
  },
  {
    "text": "well you've seen the vulnerabilities in stack Fender and I've described them so we're going to skip this one uh data security software overflow guard 1.4 um",
    "start": "2414160",
    "end": "2421680"
  },
  {
    "text": "this is pro possibly the first uh third party application to implement proper uh",
    "start": "2421680",
    "end": "2427000"
  },
  {
    "text": "page protection like packs and we're going to describe how this happens um overflow guard's going to hook um during",
    "start": "2427000",
    "end": "2433839"
  },
  {
    "text": "setup the interrupt descriptor table entries at OE and o1 OE is the page fault Handler uh as we previously",
    "start": "2433839",
    "end": "2439480"
  },
  {
    "text": "mentioned uh it has to be modified to uh support all these faults it's going to receed and o1 is a debug",
    "start": "2439480",
    "end": "2445359"
  },
  {
    "text": "exception overflow guard installs files but we're only going to talk about overflow guard. size s sorry um what is",
    "start": "2445359",
    "end": "2452560"
  },
  {
    "start": "2451000",
    "end": "2481000"
  },
  {
    "text": "the interrupted scriptor table uh the IDT uh provides an array of function pointers that act as handlers for user",
    "start": "2452560",
    "end": "2458880"
  },
  {
    "text": "land exceptions and events an exception would be a page fault a read to an invalid memory address an event would be",
    "start": "2458880",
    "end": "2465960"
  },
  {
    "text": "a breakpoint so that's the differences um the colonel is going to receive this interrupt request and dispatch the correct Handler the dispatch is done by",
    "start": "2465960",
    "end": "2472839"
  },
  {
    "text": "uh taking the interrupt uh number and indexing the IDT um we'll describe how",
    "start": "2472839",
    "end": "2477880"
  },
  {
    "text": "this happens the uh index is a little more complicated than it sounds um first we have to overwrite the",
    "start": "2477880",
    "end": "2483680"
  },
  {
    "text": "IDT um to do this we uh call the S ID instructions store interrupt descriptor",
    "start": "2483680",
    "end": "2489280"
  },
  {
    "text": "table base into a given register um then you add the Base address to the interrupt ID and multiply that by eight",
    "start": "2489280",
    "end": "2495119"
  },
  {
    "text": "and you're going to get the uh address of your exception Handler however the exception Handler is two Longs it's not",
    "start": "2495119",
    "end": "2501119"
  },
  {
    "text": "uh just one address so you have to overwrite the upper half of the first long with the upper half of the address you want to uh be in the new be the new",
    "start": "2501119",
    "end": "2508200"
  },
  {
    "text": "Handler and the lower half of the uh second long with the address you want to be the new Handler uh with your lower",
    "start": "2508200",
    "end": "2513800"
  },
  {
    "text": "half of the address so um when it's called it's actually put together the two offsets are put together to form the",
    "start": "2513800",
    "end": "2519079"
  },
  {
    "text": "actual address so that's just a little interesting tipit there and moving on",
    "start": "2519079",
    "end": "2525280"
  },
  {
    "start": "2524000",
    "end": "2731000"
  },
  {
    "text": "all right overflow guard has a very interesting U mechanism unlike um packs and setting everything to supervisor",
    "start": "2525280",
    "end": "2531599"
  },
  {
    "text": "what occurs is Overflow guard will take the last module loaded which is uh could be like you know ad vapy 32 or whatever",
    "start": "2531599",
    "end": "2539599"
  },
  {
    "text": "uh and takes the first and last modules loaded it walks up from the first the it",
    "start": "2539599",
    "end": "2545079"
  },
  {
    "text": "walks up from the last module loaded sets all the memory up in that process address range to read only it walks down",
    "start": "2545079",
    "end": "2552240"
  },
  {
    "text": "and does the same thing and until it until it reaches a invalid memory address it's going to do that so it's",
    "start": "2552240",
    "end": "2557520"
  },
  {
    "text": "going to cover all your memory mappings your PEB teb all that's going to be readon and the reason they mark it as",
    "start": "2557520",
    "end": "2563800"
  },
  {
    "text": "readon is because if you mark the PEB as supervisor there are a lot of times that the PEB is read from and you can't read",
    "start": "2563800",
    "end": "2570040"
  },
  {
    "text": "from in supervisor so you're going to have a performance uh it's going to be a more performance impact so instead",
    "start": "2570040",
    "end": "2575359"
  },
  {
    "text": "they're going to mark it as read only however as you guys know uh when you write to the stack and it's read only you're going to page fa so what happens",
    "start": "2575359",
    "end": "2582359"
  },
  {
    "text": "well overflow guard is going to compare the old EIP which is pushed on the stack during the interrupt process to the",
    "start": "2582359",
    "end": "2588599"
  },
  {
    "text": "physical uh fault address so it's going to convert the old EIP to physical address as well if these are equal the",
    "start": "2588599",
    "end": "2595200"
  },
  {
    "text": "it was an execution attempt and it will mark it accordingly an exit however um if it's not it performs a uh data it",
    "start": "2595200",
    "end": "2602119"
  },
  {
    "text": "performs the uh data read process and we'll explain that basically what will happen is Overflow is going to find the",
    "start": "2602119",
    "end": "2607680"
  },
  {
    "text": "memory address it's then going to mark it as writable user and dirty so it's taking off the supervisor and read only",
    "start": "2607680",
    "end": "2614480"
  },
  {
    "text": "if it was read only it's going to perform a dummy read this dummy read is going to load the address into the dtlb",
    "start": "2614480",
    "end": "2620680"
  },
  {
    "text": "the data translation lookaside buffer we talked briefly about the T tlb which is",
    "start": "2620680",
    "end": "2625760"
  },
  {
    "text": "the translation lookaside buffer that usually stores a instruction fetches on addresses and stuff dtlb uh is data so",
    "start": "2625760",
    "end": "2631960"
  },
  {
    "text": "it's a cache so that you don't have to perform an expensive memory walk every time you um access data um it's going to",
    "start": "2631960",
    "end": "2637880"
  },
  {
    "text": "load this it's going to load this new U memory uh address with the new permissions into the uh dtlb it's going",
    "start": "2637880",
    "end": "2644000"
  },
  {
    "text": "to then reset those memory permissions uh not in the dtlb but in the actual memory uh to supervisor so that it's non",
    "start": "2644000",
    "end": "2650640"
  },
  {
    "text": "executable again um the program will then have access to that memory it'll be able to read or write to it the next",
    "start": "2650640",
    "end": "2655800"
  },
  {
    "text": "time that memory is accessed because it was dirty it's marked as invalid the dtlb is cleared and the process is",
    "start": "2655800",
    "end": "2661079"
  },
  {
    "text": "repeated so that's how um it's going to Pro protect you and uh we'll talk about",
    "start": "2661079",
    "end": "2667280"
  },
  {
    "text": "um protection it offers all right um overflow guard and other products have not come up with an effective way to um",
    "start": "2667280",
    "end": "2674000"
  },
  {
    "text": "get rid of returning to lip C exploits and uh one was demonstrated demonstrated by The Insider in uh I think it was",
    "start": "2674000",
    "end": "2680000"
  },
  {
    "text": "November of 2003 that actually bypassed uh stack Defender and overflow guard and it does it it does uh it still does and",
    "start": "2680000",
    "end": "2687079"
  },
  {
    "text": "um so that's one way to bypass overflow guard however your average uh attempts",
    "start": "2687079",
    "end": "2692200"
  },
  {
    "text": "on overflows are not going to work also be because of how overflow guard receiv",
    "start": "2692200",
    "end": "2697680"
  },
  {
    "text": "receives the modules uh it walks because of the first and last and how it has to look at the processes it does not",
    "start": "2697680",
    "end": "2703319"
  },
  {
    "text": "protect thirdparty applications as of our testing time um and this is a common theme a lot of third- party applications",
    "start": "2703319",
    "end": "2709720"
  },
  {
    "text": "are not protected so um your IE your office your aim your trillion are not",
    "start": "2709720",
    "end": "2715200"
  },
  {
    "text": "protected so it offers a really good security for the your services but you're really not getting what you need",
    "start": "2715200",
    "end": "2721280"
  },
  {
    "text": "for your third party applications which we haven't seen yet um and I'm going to handed off for",
    "start": "2721280",
    "end": "2727520"
  },
  {
    "text": "to Rich to describe the attack Vector test platform so we have all this Theory out",
    "start": "2727520",
    "end": "2734079"
  },
  {
    "start": "2731000",
    "end": "2747000"
  },
  {
    "text": "here you know the the concepts that the people are trying to apply but it's difficult to get a good grasp of you",
    "start": "2734079",
    "end": "2739599"
  },
  {
    "text": "know how effective these different protection layers are the attack Vector test platform it's it's a program that",
    "start": "2739599",
    "end": "2745839"
  },
  {
    "text": "emulates the act of overflowing by by calling functions which simulate the",
    "start": "2745839",
    "end": "2750960"
  },
  {
    "text": "attack vectors that are normally taken for example if you were to overwrite the return address that's your direct you",
    "start": "2750960",
    "end": "2756319"
  },
  {
    "text": "know one of the stack Overflow that's one of the test cases another one uh would be like you know a function",
    "start": "2756319",
    "end": "2762400"
  },
  {
    "text": "pointer overwrite or a long jump pointer things like that so John wilander uh did",
    "start": "2762400",
    "end": "2769079"
  },
  {
    "text": "some research uh on similar topics uh I don't you know what year was that few",
    "start": "2769079",
    "end": "2774119"
  },
  {
    "text": "years back O2 I think yeah O2 and uh had a had a basic structure that we took a",
    "start": "2774119",
    "end": "2780520"
  },
  {
    "text": "little bit further Peter ported it to Windows uh we added some more tests and essentially what this does is it gives",
    "start": "2780520",
    "end": "2786480"
  },
  {
    "text": "us an objective you know a view here's on on the left column you can see all the different uh methods that we added",
    "start": "2786480",
    "end": "2792960"
  },
  {
    "text": "to it that would uh be test cases for your attack vectors and on the Unix side",
    "start": "2792960",
    "end": "2798760"
  },
  {
    "text": "here's how it all played out pa obviously is is by far providing the most secure uh buffer overflow",
    "start": "2798760",
    "end": "2805160"
  },
  {
    "text": "prevention mechanism um across the board it was able to defeat any sort of you know rudimentary uh attempts what we",
    "start": "2805160",
    "end": "2813040"
  },
  {
    "text": "don't have in here is a return to Li C attack uh but at a later date you guys will be able to get our code off the",
    "start": "2813040",
    "end": "2819520"
  },
  {
    "text": "website and um we've added additional test so they just didn't make it into the presentation um for the compiler",
    "start": "2819520",
    "end": "2825960"
  },
  {
    "text": "side you can also see uh it's very interesting that uh you know stack guard was the first and uh it provided",
    "start": "2825960",
    "end": "2833440"
  },
  {
    "text": "protection against four different test cases the green means that it successfully uh protected against this",
    "start": "2833440",
    "end": "2838640"
  },
  {
    "text": "attack Vector red of course means that it didn't um so you know it was able to protect your return address overflows",
    "start": "2838640",
    "end": "2845359"
  },
  {
    "text": "your old base pointer overflow those are just generic stack overflows",
    "start": "2845359",
    "end": "2850559"
  },
  {
    "text": "the stack Shield took it one step further it was able to provide some additional protection uh to pointers um",
    "start": "2850559",
    "end": "2857480"
  },
  {
    "text": "on the stack as well and then propol by far is providing the best protection uh",
    "start": "2857480",
    "end": "2863839"
  },
  {
    "text": "from a compiler standpoint as you can see here as well and uh essentially you know the Unix portion of of our talk was",
    "start": "2863839",
    "end": "2870640"
  },
  {
    "text": "to to set up you know the developments and the influence that it's taking effect on the Windows world because I I",
    "start": "2870640",
    "end": "2876880"
  },
  {
    "text": "mean it seems to be the the major interest in in our commercial uh you",
    "start": "2876880",
    "end": "2882160"
  },
  {
    "text": "know sector but as you can see here I mean it's just as important to know on the Linux side that uh what Solutions",
    "start": "2882160",
    "end": "2888040"
  },
  {
    "text": "you can be using to protect your systems as well and I'll let Peter explain the windows all right I know this look like",
    "start": "2888040",
    "end": "2894440"
  },
  {
    "start": "2892000",
    "end": "2898000"
  },
  {
    "text": "a twisted rainbow or something um our original theory was that we'd have",
    "start": "2894440",
    "end": "2899480"
  },
  {
    "text": "differing results so we'd be able to show you something like what you saw with the Linux graph however as you see",
    "start": "2899480",
    "end": "2905640"
  },
  {
    "text": "with all that black that was not the case um black signifies that we did not have that test implemented for Windows",
    "start": "2905640",
    "end": "2912040"
  },
  {
    "text": "however if you go to the website we'll have up a new attack Vector with much more implemented it was a time",
    "start": "2912040",
    "end": "2917520"
  },
  {
    "text": "constraint thing we've also added a asky return into lipy exploit for our Windows those are uh very painful to write as",
    "start": "2917520",
    "end": "2924520"
  },
  {
    "text": "I'll tell you uh it's a return to lipy uh and it'll test uh Windows uh return",
    "start": "2924520",
    "end": "2930000"
  },
  {
    "text": "to lipy protection um so as you see visual uh studio.net protected against",
    "start": "2930000",
    "end": "2935640"
  },
  {
    "text": "everything however we didn't have Heap overflows to implement at the time so that was it didn't do anything for us um",
    "start": "2935640",
    "end": "2943079"
  },
  {
    "text": "overflow guard didn't project anything as we said it does not protect thirdparty applications and this is an example we actually tried to it said it",
    "start": "2943079",
    "end": "2950760"
  },
  {
    "text": "claims it protects thirdparty system services so what I did was I uh there's a tool like serve any um offered in the",
    "start": "2950760",
    "end": "2958160"
  },
  {
    "text": "resource kit I added the test bed and gave it a parameter to try to execute it still didn't work well uh we had mixed",
    "start": "2958160",
    "end": "2964599"
  },
  {
    "text": "varying results it it has to do with low time of how how fast overflow guards watching the system service process so",
    "start": "2964599",
    "end": "2971720"
  },
  {
    "text": "um that's what we believe at least um stack Defender 1.10 did just as well and",
    "start": "2971720",
    "end": "2977359"
  },
  {
    "text": "the reason that is is because we used common Shell Code um that was released by Matt Miller we just cut and pasted that because we didn't feel it was right",
    "start": "2977359",
    "end": "2983200"
  },
  {
    "text": "to um write Shell Code that would you know cheat it we thought that we were trying to gain control of the flow of",
    "start": "2983200",
    "end": "2988640"
  },
  {
    "text": "the program and that's what we did instead so if we had custom shell code as we said we could have bypassed it",
    "start": "2988640",
    "end": "2995079"
  },
  {
    "text": "easily stack Defender 2.0 they say they protect against third party um programs",
    "start": "2995079",
    "end": "3001319"
  },
  {
    "start": "2998000",
    "end": "3029000"
  },
  {
    "text": "I talked with them was unable to replicate this but it's still possible in this new version they fixed a bug",
    "start": "3001319",
    "end": "3006400"
  },
  {
    "text": "that was preventing that so as you can see they also perform very poorly and um like I said before uh there many more uh",
    "start": "3006400",
    "end": "3013400"
  },
  {
    "text": "test scenarios and there's also um the return in lipy for Windows that's uh pretty cool all right um the",
    "start": "3013400",
    "end": "3020200"
  },
  {
    "text": "conclusion well the test results uh are showing the various coverage that uh each protection is able to offer",
    "start": "3020200",
    "end": "3027160"
  },
  {
    "text": "and um you can see that from the graph uh and the windows protection as we can see from the graph is not advanced yet",
    "start": "3027160",
    "end": "3034040"
  },
  {
    "start": "3029000",
    "end": "3078000"
  },
  {
    "text": "um all these programs had to you know disassemble a kernel disassemble internal structures to get this kind of knowledge so it's going to take a little",
    "start": "3034040",
    "end": "3040119"
  },
  {
    "text": "longer um there are a few compiler options for Windows unlike uh Linux and",
    "start": "3040119",
    "end": "3045160"
  },
  {
    "text": "that's um and that's probably one of the problems uh also uh we haven't been able",
    "start": "3045160",
    "end": "3050599"
  },
  {
    "text": "to implement successful protection of third- party applications and there are probably unfor un look unseen uh",
    "start": "3050599",
    "end": "3057839"
  },
  {
    "text": "problems that uh pop up when you try to do this um however as we've shown you um",
    "start": "3057839",
    "end": "3063839"
  },
  {
    "text": "a combination of both compiler and uh kernel based protection is probably the best method and will offer you a",
    "start": "3063839",
    "end": "3070359"
  },
  {
    "text": "reasonable amount of security um we'd like to thank Matt Miller um for technical uh insight and",
    "start": "3070359",
    "end": "3077240"
  },
  {
    "text": "lord yup for conceptual contributions we also like to thank ey defense Labs Dr J",
    "start": "3077240",
    "end": "3082319"
  },
  {
    "start": "3078000",
    "end": "3101000"
  },
  {
    "text": "ah whatever uh yeah we just like to thank people read the slide if want to see who we think and thanks for coming",
    "start": "3082319",
    "end": "3088240"
  },
  {
    "text": "too yeah thanks for coming uh",
    "start": "3088240",
    "end": "3091559"
  },
  {
    "text": "questions uh the question was uh XP Service Pack 2 buffer overflow protection uh that's interesting because",
    "start": "3097079",
    "end": "3102680"
  },
  {
    "start": "3101000",
    "end": "3599000"
  },
  {
    "text": "I actually uh started talking to some Microsoft guys so I'll give you the gist of what I know from them basically",
    "start": "3102680",
    "end": "3108760"
  },
  {
    "text": "they're call they're waiting for Hardware support so if your processor supports NX and Intel does not have any",
    "start": "3108760",
    "end": "3115319"
  },
  {
    "text": "out right now only am does so that will be the service pack to well that's what",
    "start": "3115319",
    "end": "3120880"
  },
  {
    "text": "your protection will be um I haven't been able to test it I'd love to get it going so that I could see you know how",
    "start": "3120880",
    "end": "3126160"
  },
  {
    "text": "it performs against everything um and like I said you need that",
    "start": "3126160",
    "end": "3132640"
  },
  {
    "text": "processor yeah and it is as he said uh he said that the amds are 64bit which is also the",
    "start": "3133040",
    "end": "3139760"
  },
  {
    "text": "case I'm sorry okay they're saying that the new",
    "start": "3140640",
    "end": "3146920"
  },
  {
    "text": "Intel processor will have the Intel bit but as we showed you you do not need necessar you do not necessarily need",
    "start": "3146920",
    "end": "3152400"
  },
  {
    "text": "Hardware support to implement something on Windows that offers a reasonable amount of security",
    "start": "3152400",
    "end": "3158960"
  },
  {
    "text": "basically said that uh for those of you who couldn't hear that uh 64 bits what supported and it's AMD only that's the",
    "start": "3182799",
    "end": "3188440"
  },
  {
    "text": "gist of that any other",
    "start": "3188440",
    "end": "3191359"
  },
  {
    "text": "questions well I'll I'll address that um since what we were essentially testing were the attack vectors uh it it's",
    "start": "3199480",
    "end": "3206520"
  },
  {
    "text": "pretty inconsequential what architecture you're running it on um you know it's it's the same Theory it's when you get",
    "start": "3206520",
    "end": "3212200"
  },
  {
    "text": "down to the Shell Code level or the you know the implementation of their maps and you know different things like that",
    "start": "3212200",
    "end": "3218200"
  },
  {
    "text": "their Malo and whatnot that those those will be architecture specific but um the nice thing about this is that we took",
    "start": "3218200",
    "end": "3224319"
  },
  {
    "text": "the approach that uh just by testing the attack vectors which essentially is what redirects your program flow in the long",
    "start": "3224319",
    "end": "3230200"
  },
  {
    "text": "run uh you know it's it applies at a at a higher level so it doesn't really it's not affected and the forgot to say the",
    "start": "3230200",
    "end": "3237040"
  },
  {
    "text": "attack Vector is open source so vendors and users can modify scenarios and add it and you know sit on my website hey it",
    "start": "3237040",
    "end": "3242760"
  },
  {
    "text": "protects this hey it doesn't protect this you know it's basically a it'll offer the only other thing is that there",
    "start": "3242760",
    "end": "3248040"
  },
  {
    "text": "are architectures of course that have native uh you know page protections so uh you know in those cases of course",
    "start": "3248040",
    "end": "3254799"
  },
  {
    "text": "it's going to be faster and things like that but essentially as far as the the TAC Vector platform it's the the test",
    "start": "3254799",
    "end": "3260680"
  },
  {
    "text": "results wouldn't be different",
    "start": "3260680",
    "end": "3264359"
  },
  {
    "text": "uh no I mean they they really shouldn't because essentially the the methods of applying the protections are you know",
    "start": "3270920",
    "end": "3276599"
  },
  {
    "text": "completely independent the only thing that would be of concern is possibly a performance hit you know I mean you're",
    "start": "3276599",
    "end": "3281760"
  },
  {
    "text": "going to have a little bit of extra code added to the binary and a little bit of extra code added during the kernel",
    "start": "3281760",
    "end": "3286880"
  },
  {
    "text": "processing so uh no",
    "start": "3286880",
    "end": "3293319"
  },
  {
    "text": "no well I mean it's pretty apparent when you run a kernel protection that uh does",
    "start": "3294680",
    "end": "3300640"
  },
  {
    "text": "have a performance impact you're executing more code there's more instructions being executed",
    "start": "3300640",
    "end": "3307480"
  },
  {
    "text": "right I'm sorry can you feel",
    "start": "3309799",
    "end": "3316480"
  },
  {
    "text": "of I mean that's that would be dependent upon their implementation I mean I I",
    "start": "3316920",
    "end": "3322680"
  },
  {
    "text": "don't have any data on that we we haven't we didn't test that thank you guys very much",
    "start": "3322680",
    "end": "3329559"
  },
  {
    "text": "oh uh it's gonna be on black hat and we'll also have it on ey defense um so",
    "start": "3329559",
    "end": "3335760"
  },
  {
    "text": "thank [Applause]",
    "start": "3335760",
    "end": "3343078"
  },
  {
    "text": "you",
    "start": "3355240",
    "end": "3358240"
  },
  {
    "text": "e",
    "start": "3385240",
    "end": "3388240"
  },
  {
    "text": "e",
    "start": "3415240",
    "end": "3418240"
  },
  {
    "text": "e",
    "start": "3445160",
    "end": "3448160"
  },
  {
    "text": "e",
    "start": "3475119",
    "end": "3478119"
  },
  {
    "text": "e",
    "start": "3505119",
    "end": "3508119"
  },
  {
    "text": "e",
    "start": "3535039",
    "end": "3538039"
  },
  {
    "text": "e",
    "start": "3565039",
    "end": "3568039"
  },
  {
    "text": "e",
    "start": "3595039",
    "end": "3598039"
  },
  {
    "text": "e",
    "start": "3624960",
    "end": "3627960"
  },
  {
    "text": "e",
    "start": "3654920",
    "end": "3657920"
  },
  {
    "text": "e for",
    "start": "3684920",
    "end": "3688920"
  }
]