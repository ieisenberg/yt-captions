[
  {
    "text": "welcome this is uh abusing salid mitigation understanding weaknesses within internet explorers isolated Heap",
    "start": "280",
    "end": "5759"
  },
  {
    "text": "and memory protection so this talk originates around a set of research we did in mid 2014 and completed in around",
    "start": "5759",
    "end": "12759"
  },
  {
    "text": "February uh 2015 and it really is a in-depth look at the new mitigations",
    "start": "12759",
    "end": "18320"
  },
  {
    "text": "that are being introduced into internet explore specifically we're talking about the isolated Heap and memory protection",
    "start": "18320",
    "end": "24840"
  },
  {
    "text": "mitigations um we'll be covering not only how these mitigations work but we'll also be covering",
    "start": "24840",
    "end": "30560"
  },
  {
    "text": "uh how to attack these mitigations we'll also be talking about how you can use one of these mitigations to break",
    "start": "30560",
    "end": "36680"
  },
  {
    "text": "another mitigation in this case me using memory protection as a way to bypass aslr we'll also cover all of the",
    "start": "36680",
    "end": "43879"
  },
  {
    "text": "defenses that we suggested to Microsoft in fact This research won",
    "start": "43879",
    "end": "49280"
  },
  {
    "text": "$125,000 from Microsoft's mitigation bypass and blue hat bonus for defense Bounty program which we in turn donated",
    "start": "49280",
    "end": "56559"
  },
  {
    "text": "to stem uh Charities that support stem education and is also nominated for this year's Pony award for uh most Innovative",
    "start": "56559",
    "end": "64158"
  },
  {
    "text": "research and so we got a lot to cover so we're going to go start diving in just a quick overview of who we are uh up here",
    "start": "64159",
    "end": "71320"
  },
  {
    "text": "on the stage and several people out here in the front are actually members of the zero day Initiative Program uh celebrating its 10th year as the world's",
    "start": "71320",
    "end": "78200"
  },
  {
    "text": "largest vendor agnostic bug Bounty program we focus on vulnerability research uh and and Remediation along",
    "start": "78200",
    "end": "84880"
  },
  {
    "text": "with Advanced exploitation techniques uh working to procure those uh from researchers around the world and working",
    "start": "84880",
    "end": "90680"
  },
  {
    "text": "with the vendors to get them fixed um I got to work my name is Brian",
    "start": "90680",
    "end": "95720"
  },
  {
    "text": "goren I actually run the zero day Initiative Program uh and I work again with researchers around the world trying",
    "start": "95720",
    "end": "101479"
  },
  {
    "text": "to get bugs fixed and purchasing research off of off of individuals out there in the world um I also organized",
    "start": "101479",
    "end": "107280"
  },
  {
    "text": "the ever popular Ponda own hacking competition and I got to work with Simon and Abdul here uh on This research",
    "start": "107280",
    "end": "113119"
  },
  {
    "text": "project and I'll have them introduce themselves real quick I'm Abdul I'm a security",
    "start": "113119",
    "end": "119399"
  },
  {
    "text": "researcher uh working for the zero day Initiative Program been working for zdi for the past two years um I do calls",
    "start": "119399",
    "end": "126680"
  },
  {
    "text": "analysis and Bug Discovery",
    "start": "126680",
    "end": "131039"
  },
  {
    "text": "Simon hi I'm Simon zuker Bron on Twitter I'm hex kitchen I've been working with",
    "start": "132200",
    "end": "138160"
  },
  {
    "text": "zdi for a little over a year and I've done a lot of work with Internet",
    "start": "138160",
    "end": "143480"
  },
  {
    "text": "Explorer all right so it should come as no surprise to people in this room that use after free vulnerabil were uh were",
    "start": "143680",
    "end": "151200"
  },
  {
    "text": "very very popular with exploiters out there and you can see on the slide uh the list of uh use after free",
    "start": "151200",
    "end": "157080"
  },
  {
    "text": "vulnerabilities that were under active exploitation in the years of 2013 and 2014 and really something had to be done",
    "start": "157080",
    "end": "163840"
  },
  {
    "text": "about this they pretty much was every month every other month a new use after free vulnerability would come show up in",
    "start": "163840",
    "end": "169000"
  },
  {
    "text": "the wild being used in a targeted attack against corporations or being used against governments and so really like",
    "start": "169000",
    "end": "175959"
  },
  {
    "text": "we said something had to be done and Microsoft decided to do something about it uh in in the middle of",
    "start": "175959",
    "end": "181400"
  },
  {
    "text": "2014 and they introduced a couple new mitigations in there to make exploitation harder and this really had",
    "start": "181400",
    "end": "187799"
  },
  {
    "text": "the result of Shifting the attack surf shifting attackers away from Internet Explorer and now that and as most of you",
    "start": "187799",
    "end": "194120"
  },
  {
    "text": "know they're focusing on flash bone abilities uh to to break into",
    "start": "194120",
    "end": "199360"
  },
  {
    "text": "corporations so what exactly did they introduce in the middle of 2014 that that made exploitation harder well first",
    "start": "199360",
    "end": "206239"
  },
  {
    "text": "was the isolated Heap which was introduced in June followed by memory protection in July and these mitigations",
    "start": "206239",
    "end": "212280"
  },
  {
    "text": "were intended to make use after free exploitation harder and we'll talk about how all of these work and the attacks",
    "start": "212280",
    "end": "218080"
  },
  {
    "text": "that we identified that that work against these mitigations here here in a second but when they were introduced",
    "start": "218080",
    "end": "223879"
  },
  {
    "text": "really the side effect for us in the zero day Initiative Program was it actually made Internet Explorer fun to",
    "start": "223879",
    "end": "229319"
  },
  {
    "text": "research again right we had been spending a lot of time doing root cause analysis on use after free vulnerabilities and other",
    "start": "229319",
    "end": "234920"
  },
  {
    "text": "vulnerabilities that existed in that product and it pretty much every time one came in it almost guaranteed was",
    "start": "234920",
    "end": "240760"
  },
  {
    "text": "going to work and result in direct code execution um so it really made it fun",
    "start": "240760",
    "end": "246640"
  },
  {
    "text": "again which was kind of nice here on this slide you can kind of see the vulnerability uh trends that we had in",
    "start": "246640",
    "end": "252680"
  },
  {
    "text": "our program uh the submission Trends over the over the last several years and you can see increasingly more and more",
    "start": "252680",
    "end": "258199"
  },
  {
    "text": "Internet Explorer vulnerabilities coming into our program and then all of a sudden in 2014 we had a a significant",
    "start": "258199",
    "end": "264560"
  },
  {
    "text": "Spike with with a Max of 44 vulnerabilities in Internet Explorer in one month and now that's a lot lot of",
    "start": "264560",
    "end": "269919"
  },
  {
    "text": "work to actually go vet all of those vulnerabilities and make sure that they're valid but yeah it really kind of",
    "start": "269919",
    "end": "275000"
  },
  {
    "text": "stayed up there for several months you know 40 40 plus zero days in Internet Explorer coming into our program and so",
    "start": "275000",
    "end": "281759"
  },
  {
    "text": "you know when when Microsoft introduced the um the mitigations that we're going to talk about it really for myself as",
    "start": "281759",
    "end": "288039"
  },
  {
    "text": "the one who runs the budget for the program I kind of thank Microsoft for saving me a bunch of money um and so you",
    "start": "288039",
    "end": "294120"
  },
  {
    "text": "can see the the drop in submissions that happened uh in the middle of 2014 we're averaging round 25 new zero days in I IE",
    "start": "294120",
    "end": "302639"
  },
  {
    "text": "every month now and so what we're going to go through is start looking at the isolated",
    "start": "302639",
    "end": "308320"
  },
  {
    "text": "Heap and Abdul will'll go over how it works and the attacks that you can use against",
    "start": "308320",
    "end": "314240"
  },
  {
    "text": "it all right so isolated Heap was introduced in June 2014 we noticed back",
    "start": "316360",
    "end": "322919"
  },
  {
    "text": "then that there's a separate he Heap region created with a heap create API and the the main purpose for this um",
    "start": "322919",
    "end": "329759"
  },
  {
    "text": "region was to uh provide some kind of isolation between Dom allocations and other types of allocations um so so",
    "start": "329759",
    "end": "336600"
  },
  {
    "text": "basically This was um a game changer for the use after fee exploitation um because the classical ways of overriding",
    "start": "336600",
    "end": "343120"
  },
  {
    "text": "the feed objects with um strings and and other types of allegations still reside",
    "start": "343120",
    "end": "348160"
  },
  {
    "text": "on inside the process Heap rather than the isolated so it provided some kind of isolation which which which was pretty",
    "start": "348160",
    "end": "355880"
  },
  {
    "text": "cool um so just like any other mitigation um is isolated Heap contain",
    "start": "355880",
    "end": "361080"
  },
  {
    "text": "contains some weaknesses um so basically it has a type confusion issue uh solely because it it doesn't keep track of the",
    "start": "361080",
    "end": "368080"
  },
  {
    "text": "objects being allocated the type of objects being allocated and the sizes so an attacker can can basically just",
    "start": "368080",
    "end": "373599"
  },
  {
    "text": "override an isolated object with another um isolated object of whatever type he chooses um he can he can just allocate",
    "start": "373599",
    "end": "381400"
  },
  {
    "text": "anything um of different sizes any object of different sizes um attacking",
    "start": "381400",
    "end": "386840"
  },
  {
    "text": "isolated Heap and exploitation of isolated Heap is highly depend on on the bug itself um specifically on the",
    "start": "386840",
    "end": "393120"
  },
  {
    "text": "offsets that are being referenced um from the feed",
    "start": "393120",
    "end": "398240"
  },
  {
    "text": "object so um the first attack technique that I'll be covering is the aligned allocations attack technique um so so",
    "start": "399120",
    "end": "406759"
  },
  {
    "text": "basically it's simply is just allocating an object right at the same exact",
    "start": "406759",
    "end": "412840"
  },
  {
    "text": "address of um of the feed object um so this attack technique is is is very",
    "start": "412840",
    "end": "418479"
  },
  {
    "text": "useful when you have a us after free condition where the bug is the referencing High offset um so the only",
    "start": "418479",
    "end": "425759"
  },
  {
    "text": "challenge here just to choose something uh to replace the feed object with but something that contains specific values",
    "start": "425759",
    "end": "432120"
  },
  {
    "text": "at high offsets that the attacker can control directly or indirectly via spray or anything like that um in order to",
    "start": "432120",
    "end": "438960"
  },
  {
    "text": "have a successful aligned attack um allocation technique um one an attacker",
    "start": "438960",
    "end": "444879"
  },
  {
    "text": "can should should avoid the low fragmentation Heap uh so the the reason reason for that is that we're probably",
    "start": "444879",
    "end": "451199"
  },
  {
    "text": "going to be allocating objects of different sizes so we we don't we don't want to want to end up allocating on a",
    "start": "451199",
    "end": "456840"
  },
  {
    "text": "different bucket um so the simplest way to achieve this is basically step one is to uh to",
    "start": "456840",
    "end": "463639"
  },
  {
    "text": "trigger the freeing condition then we probably have to massage the Heap in a way um to trigger",
    "start": "463639",
    "end": "469919"
  },
  {
    "text": "multiple heaps multiple freeze sorry then uh we have to coales all",
    "start": "469919",
    "end": "476199"
  },
  {
    "text": "these free chunks together in one uh chunk and later on we have to spray uh objects",
    "start": "476199",
    "end": "482639"
  },
  {
    "text": "inside that specific free chunk free chunk that we generated and finally we have to trigger",
    "start": "482639",
    "end": "488840"
  },
  {
    "text": "their use um using the type confused",
    "start": "488840",
    "end": "493680"
  },
  {
    "text": "object so uh in this graph I have the the c table row object and up front we",
    "start": "493960",
    "end": "499440"
  },
  {
    "text": "have the C text node both are isolated in this specific example we uh we're freeing the c table row and we're",
    "start": "499440",
    "end": "506400"
  },
  {
    "text": "overwriting it with SE on text node which is smaller in size uh basically in this specific example we",
    "start": "506400",
    "end": "512159"
  },
  {
    "text": "like we chose the seom text node because at a specific offset it contains a value that we can uh potentially control or",
    "start": "512159",
    "end": "518640"
  },
  {
    "text": "partially control so in this uh wind debug dump um",
    "start": "518640",
    "end": "526160"
  },
  {
    "text": "it's just like there's a before and after shot basically before you guys can see the c table row U object and after",
    "start": "526160",
    "end": "532959"
  },
  {
    "text": "you guys can see that it has been overwritten by ccom text node highlighted in yellow is the offset that",
    "start": "532959",
    "end": "538320"
  },
  {
    "text": "we're targeting uh it's offset 30 and basically the cdom text note contains",
    "start": "538320",
    "end": "544000"
  },
  {
    "text": "the value 4000000 at that specific offset and uh that's that that specific",
    "start": "544000",
    "end": "549920"
  },
  {
    "text": "value can be sprayed and the attacker can have some partial control via spray or anything like",
    "start": "549920",
    "end": "556640"
  },
  {
    "text": "that so this is a crash time if um if everything everything was successful",
    "start": "557120",
    "end": "562360"
  },
  {
    "text": "we're going to have um we're going to have the bugy referencing that specific value and then the attacker can spray",
    "start": "562360",
    "end": "568519"
  },
  {
    "text": "that value and go from there and control the flow so um the next attack technique",
    "start": "568519",
    "end": "576519"
  },
  {
    "text": "that I'll be discussing is the misaligned allocations attack technique basically the aligned allocations attack",
    "start": "576519",
    "end": "582320"
  },
  {
    "text": "technique works really well when we have a high offset uh but if if we have a bug that the references a low offset that",
    "start": "582320",
    "end": "588720"
  },
  {
    "text": "that can be kind of problematic from an attacker's perspective uh specifically because it's really hard to find an",
    "start": "588720",
    "end": "595519"
  },
  {
    "text": "object with a low um offset that we can um that that has values that we can",
    "start": "595519",
    "end": "601560"
  },
  {
    "text": "control at at its low offsets um so in order to have to or to solve this problem um we have we have to probably",
    "start": "601560",
    "end": "609240"
  },
  {
    "text": "allocate something in a misaligned way basically if the original object is aligned at at address X then we probably",
    "start": "609240",
    "end": "615600"
  },
  {
    "text": "have to start our allocations at xus n uh in order to have some object misaligned against the original one so",
    "start": "615600",
    "end": "623399"
  },
  {
    "text": "the simple steps are um we we have to trigger uh multiple uh we have to coales",
    "start": "623399",
    "end": "628920"
  },
  {
    "text": "multiple um free chunks together in order to produce a a big",
    "start": "628920",
    "end": "634000"
  },
  {
    "text": "one next we have to spray this big free chunk uh with random objects and later on we have to to",
    "start": "634000",
    "end": "641040"
  },
  {
    "text": "trigger their use in order to D reference a specific value from the misaligned object that we sprayed",
    "start": "641040",
    "end": "648320"
  },
  {
    "text": "with so again this is my fancy diagram um it's again that we we're targeting",
    "start": "648680",
    "end": "653800"
  },
  {
    "text": "the c table row object and as you guys can see up front like we have big a big",
    "start": "653800",
    "end": "659880"
  },
  {
    "text": "chunk and we spray the C button objects inside it um basically we have one C",
    "start": "659880",
    "end": "665279"
  },
  {
    "text": "button object that's kind of misaligned against the original one and then we're going to have a der reference from that",
    "start": "665279",
    "end": "670680"
  },
  {
    "text": "c misalign c button [Applause] object so in order to have um a",
    "start": "670680",
    "end": "677399"
  },
  {
    "text": "successful attack misaligned allegations attack we have to stabilize the Heap in a way to produce the same free chunk the",
    "start": "677399",
    "end": "683760"
  },
  {
    "text": "same one over and over with the same size basically this is the code that we've used in this specific uh um",
    "start": "683760",
    "end": "690000"
  },
  {
    "text": "example it's not a generic way of doing it but um this specific code was was good enough to to produce the same exact",
    "start": "690000",
    "end": "697360"
  },
  {
    "text": "feet chunk again and again which is of size [Applause]",
    "start": "697360",
    "end": "703249"
  },
  {
    "text": "110 so uh this is the wind debug uh dump that shows um that EDI uh points the",
    "start": "703399",
    "end": "709760"
  },
  {
    "text": "middle of a free chunk the free chunk is always of 110 um hags of",
    "start": "709760",
    "end": "715720"
  },
  {
    "text": "[Applause] size so asum assuming we were able to stabilize the Heap in a way to produce",
    "start": "715720",
    "end": "721720"
  },
  {
    "text": "the same free chunk over and over then we have to spray this big free chunk with random objects basically we chose",
    "start": "721720",
    "end": "728959"
  },
  {
    "text": "uh the button we were we were targeting this to override it with a with a button object we sprayed the track uh objects",
    "start": "728959",
    "end": "735560"
  },
  {
    "text": "just to um to uh to clear up just to to cover some holes and then this worked",
    "start": "735560",
    "end": "741279"
  },
  {
    "text": "well basically this can be done in multiple ways um some some some guys actually did it with a text area uh you",
    "start": "741279",
    "end": "747880"
  },
  {
    "text": "can do it with an anchor depends whatever you guys want but the button one works in this",
    "start": "747880",
    "end": "753490"
  },
  {
    "text": "[Applause] example all right so this is a crash time um at crash time we had we had DDI",
    "start": "753490",
    "end": "761639"
  },
  {
    "text": "plus1 C pointing to an offset from the misaligned C button basically this uh",
    "start": "761639",
    "end": "766920"
  },
  {
    "text": "this offset contains the value 12 c004 and that value can be sprayed by an",
    "start": "766920",
    "end": "772240"
  },
  {
    "text": "attacker and then uh he can control the flow from there so uh to recap all this um",
    "start": "772240",
    "end": "780639"
  },
  {
    "text": "isolated heat does a good job isolating Dom allocations against other type of allocations it's not perfect it's still",
    "start": "780639",
    "end": "787240"
  },
  {
    "text": "contains some weaknesses like type confusion issues um attacking or exploiting isolated he depends on",
    "start": "787240",
    "end": "792839"
  },
  {
    "text": "several factors like the nature of the bug offsets and low fermentation Heap so",
    "start": "792839",
    "end": "798600"
  },
  {
    "text": "now I'm going to turn it to Brian so he can discuss the memory protection",
    "start": "798600",
    "end": "803680"
  },
  {
    "text": "stuff all right so we'll go over memory protection and to go over memory",
    "start": "803959",
    "end": "809560"
  },
  {
    "text": "protection we really have to look back to around July of 2014 when they first released memory protection and inside of",
    "start": "809560",
    "end": "815199"
  },
  {
    "text": "the zero day Initiative Program we had purchased a bunch of use after free vulnerabilities uh that in on one day",
    "start": "815199",
    "end": "821639"
  },
  {
    "text": "they worked resulting in direct arbitrary code execution and then the next day when the patch was applied they",
    "start": "821639",
    "end": "826839"
  },
  {
    "text": "all turned to null pointer D references right so this was kind of concerning to us we were interested in how this how",
    "start": "826839",
    "end": "831920"
  },
  {
    "text": "this worked um and so we started taking a deeper look and we noticed that that Microsoft had implemented memory",
    "start": "831920",
    "end": "836959"
  },
  {
    "text": "protection so what exactly is memory protection well memory protection is a delayed freeing mechanism that prevents",
    "start": "836959",
    "end": "843880"
  },
  {
    "text": "blocks from being deallocated while they're being referenced on the stack it keeps these blocks in a unusable but",
    "start": "843880",
    "end": "850880"
  },
  {
    "text": "allocated condition and adds them to a weight list and every so often a Reclamation process will occur which",
    "start": "850880",
    "end": "857160"
  },
  {
    "text": "will Traverse the weight list and see if the blocks have reference if there's references still to the blocks and then",
    "start": "857160",
    "end": "863199"
  },
  {
    "text": "if there are no references it will free that block at the heat manager level so how did Microsoft implement this well",
    "start": "863199",
    "end": "868560"
  },
  {
    "text": "they implement Ed a new function called protected free which is called instead of Heap",
    "start": "868560",
    "end": "874480"
  },
  {
    "text": "free so kind of understand how this works what you see on the slide is a flowchart of the steps that are taken by",
    "start": "874480",
    "end": "881279"
  },
  {
    "text": "protected free and it's actually pretty simple the first thing it decides to do is whether it's going to do a",
    "start": "881279",
    "end": "887320"
  },
  {
    "text": "Reclamation sweep or not and then after that it adds that block to the weight list it will perform a Reclamation sweep",
    "start": "887320",
    "end": "894120"
  },
  {
    "text": "if the weight list contains more than 100,000 bytes worth of new blocks on the weight list since the last Reclamation",
    "start": "894120",
    "end": "900600"
  },
  {
    "text": "sweep another key point about protected free is to understand is when protected free is called on an object it's",
    "start": "900600",
    "end": "907199"
  },
  {
    "text": "guaranteed that that object will not be reclaimed in that in that running of protected free but it will be added to",
    "start": "907199",
    "end": "912800"
  },
  {
    "text": "the weight list and so these two things the decision on whether to do a Reclamation sweep and the fact that the",
    "start": "912800",
    "end": "918560"
  },
  {
    "text": "the block is added to the weight list at the end of protected free we can be used to generate an",
    "start": "918560",
    "end": "925440"
  },
  {
    "text": "attack so how does the Reclamation process work well it reverses every entry on the wait list to determine if",
    "start": "925440",
    "end": "931920"
  },
  {
    "text": "it's still being referenced so here we have an entry referring to a heap a block on the Heap and the first thing it",
    "start": "931920",
    "end": "938880"
  },
  {
    "text": "does is check to see if there's a reference on the stack to this block then it checks the process",
    "start": "938880",
    "end": "945839"
  },
  {
    "text": "registers to see if there's a reference to this block in the registers if there is a reference the",
    "start": "945839",
    "end": "952000"
  },
  {
    "text": "block will be weight listed and continue to be weight listed after protected free is complete but if there are no",
    "start": "952000",
    "end": "957880"
  },
  {
    "text": "references it will free the block at the heat manager level so for use after free vulnerabilities where there is a",
    "start": "957880",
    "end": "963759"
  },
  {
    "text": "reference on the stack or in the processor registers memory protection is highly effective against those used after",
    "start": "963759",
    "end": "970639"
  },
  {
    "text": "freeze but there are cases where uh where references do not exist to the objects and so what kind of challenges",
    "start": "970720",
    "end": "977440"
  },
  {
    "text": "does memory protection present to the attacker well first there's a deallocation delay due to the Reclamation process that occurs then",
    "start": "977440",
    "end": "985160"
  },
  {
    "text": "there's non-determinism in that Reclamation process due to what we call stack junk and stack junk to us is is",
    "start": "985160",
    "end": "992120"
  },
  {
    "text": "basically non-p pointers or stale pointers that are left over on the stack in buffers that have not been clear to",
    "start": "992120",
    "end": "997440"
  },
  {
    "text": "their former contents so as the Reclamation process occurs it will it will think that these are Pointers into",
    "start": "997440",
    "end": "1002959"
  },
  {
    "text": "the block and as a result they will not free those blocks there's also complexity in determining the deallocation time due to",
    "start": "1002959",
    "end": "1009959"
  },
  {
    "text": "the large number of blocks that could be on the weight list and there's also complexity in the heat manager Behavior",
    "start": "1009959",
    "end": "1015160"
  },
  {
    "text": "due to the reordering of the weight list that occurs making it harder predict harder to predict the order in which the",
    "start": "1015160",
    "end": "1020480"
  },
  {
    "text": "deallocations are going to occur so what kind of attack techniques",
    "start": "1020480",
    "end": "1025880"
  },
  {
    "text": "can we come up with to defeat all of those challenges for the cases of use after freeze where the references don't",
    "start": "1025880",
    "end": "1031038"
  },
  {
    "text": "exist well first you can use uh generic memory pressuring techniques like this one you see on the screen that will make",
    "start": "1031039",
    "end": "1038160"
  },
  {
    "text": "sure that there are over 100,000 bytes of new blocks on the weight list uh so",
    "start": "1038160",
    "end": "1043959"
  },
  {
    "text": "that the Reclamation sweep can be performed the next time protected free occurs but it doesn't really solve all the challenges es so we're going to take",
    "start": "1043959",
    "end": "1050559"
  },
  {
    "text": "a more surgical approach uh at at trying to make sure that a a use after free",
    "start": "1050559",
    "end": "1056080"
  },
  {
    "text": "that we want to use is deallocated when we want it to be deallocated and overcome all of the challenges that exist due to memory protection so the",
    "start": "1056080",
    "end": "1063679"
  },
  {
    "text": "first thing that we're going to do is we're going to prep the weight list to ensure that the next time the Reclamation process occurs um it will",
    "start": "1063679",
    "end": "1070799"
  },
  {
    "text": "occur when protected free uh run so what we're going to do is we're going to find a way to allocate a 100,000 byte block",
    "start": "1070799",
    "end": "1079280"
  },
  {
    "text": "and then we're going to free that block using protected free and as we know protected free will only will add the",
    "start": "1079280",
    "end": "1084919"
  },
  {
    "text": "block to the weight list after it's done we result in a in the weight list here",
    "start": "1084919",
    "end": "1090400"
  },
  {
    "text": "having block a on it so at this time the next time protected free is called the Reclamation process will",
    "start": "1090400",
    "end": "1096760"
  },
  {
    "text": "occur so now we're going to prep the weight list and try to bring it to a known size so that we know exactly when",
    "start": "1096760",
    "end": "1103039"
  },
  {
    "text": "deallocations are going to occur so we're going to force a Reclamation sweep and bring that weight list into that approximate size so first we're going to",
    "start": "1103039",
    "end": "1109720"
  },
  {
    "text": "allocate a block of an arbitrary size we'll call it B then we're going to call",
    "start": "1109720",
    "end": "1114919"
  },
  {
    "text": "protected free on that object and because we've we're at the point where the Reclamation process will the the",
    "start": "1114919",
    "end": "1122120"
  },
  {
    "text": "code will trigger the Reclamation process it will free block a and free any other blocks that don't have references on there and after that it",
    "start": "1122120",
    "end": "1128200"
  },
  {
    "text": "will add Block B to the weight list so at this time we have a weight list in an approximate size and an approximate",
    "start": "1128200",
    "end": "1134360"
  },
  {
    "text": "known State clearing everything out next we're going to launch our",
    "start": "1134360",
    "end": "1139520"
  },
  {
    "text": "attack against and in this case we're going to call it Block C which is the block that we want to use in the use after free",
    "start": "1139520",
    "end": "1145360"
  },
  {
    "text": "attack first we're going to add block Block C to the weight list by calling protected free on it so at this point",
    "start": "1145360",
    "end": "1151960"
  },
  {
    "text": "Block C is on the weight list then we're going to allocate a block of 100,000 bytes we'll call this block D and we're",
    "start": "1151960",
    "end": "1158320"
  },
  {
    "text": "going to call protected free on that block which will add the block to the weight list then we're going to force",
    "start": "1158320",
    "end": "1164480"
  },
  {
    "text": "Reclamation of Block C and D by allocating another block and calling protected free on it and at this point",
    "start": "1164480",
    "end": "1171320"
  },
  {
    "text": "we we've hit the Reclamation threshold which will free Block C and block D and and now we can move on and use the",
    "start": "1171320",
    "end": "1178520"
  },
  {
    "text": "isolated Heap attack techniques to go to try to uh reclaim the appropriate offsets that we need to continue on uh",
    "start": "1178520",
    "end": "1185400"
  },
  {
    "text": "exploiting this use after free vulnerability so what do we need well we need a way of arbitrarily allocating and",
    "start": "1185400",
    "end": "1192679"
  },
  {
    "text": "deallocating using protected free an arbitrary Siz block so we can't use CIS",
    "start": "1192679",
    "end": "1198880"
  },
  {
    "text": "string or CIS free string based strings because they don't call protected free when they're destroyed in this case we",
    "start": "1198880",
    "end": "1204320"
  },
  {
    "text": "need to use seaster and seaster will call protected free and the way we get to seaster is we call get Elements by",
    "start": "1204320",
    "end": "1210600"
  },
  {
    "text": "class name get Elements by class name has a side effect of of both allocating a block and deallocating a block in the",
    "start": "1210600",
    "end": "1216799"
  },
  {
    "text": "same code in the same method so it gives us an excellent opportunity to do some real surgical stuff with the with the",
    "start": "1216799",
    "end": "1222840"
  },
  {
    "text": "weight list and deallocating uh blocks on the Heap and so the code that we have",
    "start": "1222840",
    "end": "1228080"
  },
  {
    "text": "here kind of shows how we would use this get Elements by class name first we need to do a little priming procedure uh",
    "start": "1228080",
    "end": "1234320"
  },
  {
    "text": "which you see on the first two lines which we explain in detail on the paper and then after that every time we call get Elements by class name it will",
    "start": "1234320",
    "end": "1240559"
  },
  {
    "text": "allocate a seaster and then call protected free on that on that arbitrarily sized object so we can",
    "start": "1240559",
    "end": "1246240"
  },
  {
    "text": "manipulate the weight list and Heap um what we're going to show you here is a demo video of a use after free",
    "start": "1246240",
    "end": "1251799"
  },
  {
    "text": "vulnerability um that we that we had that uh we use the techniques that we",
    "start": "1251799",
    "end": "1256880"
  },
  {
    "text": "just talked about with memory protection along with the isolated Heap uh uh techniques to gain control of the EIP",
    "start": "1256880",
    "end": "1262880"
  },
  {
    "text": "register and clearing up all the challenges that exist existed from memory protection so you see",
    "start": "1262880",
    "end": "1270559"
  },
  {
    "text": "here at this point we we own the EIP",
    "start": "1270559",
    "end": "1275278"
  },
  {
    "text": "register you can kind of see right there 41 41 41 41 uh in the in in the in the",
    "start": "1275679",
    "end": "1281799"
  },
  {
    "text": "good register so now we're going to turn it over to Simon and he's going to go over",
    "start": "1281799",
    "end": "1287039"
  },
  {
    "text": "how we used memory protection to break",
    "start": "1287039",
    "end": "1290519"
  },
  {
    "text": "aslr in this section we're going to talk about how we were able to abuse memory protection to get a bypass of",
    "start": "1296120",
    "end": "1304120"
  },
  {
    "text": "aslr after I got comfortable with making Precision modifications to the memory protection State um I went back and",
    "start": "1304120",
    "end": "1311200"
  },
  {
    "text": "started thinking some more about something I'd read uh um in a blog from foret back in July of 2014",
    "start": "1311200",
    "end": "1319919"
  },
  {
    "text": "it's a paraphrase from that post um back in 2013 um Dion showed how conservative",
    "start": "1319919",
    "end": "1327279"
  },
  {
    "text": "garbage collectors uh used by Script engines um can be attacked to leak",
    "start": "1327279",
    "end": "1334240"
  },
  {
    "text": "information about Heap",
    "start": "1334240",
    "end": "1337400"
  },
  {
    "text": "addresses um does memory protection provide a new attack surface for a similar attack um that's an interesting",
    "start": "1343400",
    "end": "1351000"
  },
  {
    "text": "idea in a sense memory protection acts like a conservative garbage collector freeing allocated memory only if no",
    "start": "1351000",
    "end": "1359400"
  },
  {
    "text": "references are found on the stack U that means that it might be susceptible to an attack similar to the garbage collection",
    "start": "1359400",
    "end": "1365760"
  },
  {
    "text": "attack done by Dion the key idea here is that when memory protection examines values on the",
    "start": "1365760",
    "end": "1372320"
  },
  {
    "text": "stack it doesn't understand anything about the semantics of those values it treats each dword as if it is",
    "start": "1372320",
    "end": "1378480"
  },
  {
    "text": "potentially a pointer so if we like we can plant a chosen integer value on the",
    "start": "1378480",
    "end": "1384360"
  },
  {
    "text": "stack and memory protection will interpret it as a pointer memory protection will then exhibit different",
    "start": "1384360",
    "end": "1390360"
  },
  {
    "text": "Behavior depending on whether or not the integer we chose corresponds to an",
    "start": "1390360",
    "end": "1395600"
  },
  {
    "text": "address of weight listed memory uh so uh here we see a block on",
    "start": "1395600",
    "end": "1401600"
  },
  {
    "text": "the weight list uh let's say we plant an integer value on the stack and then trigger memory protections Reclamation",
    "start": "1401600",
    "end": "1409360"
  },
  {
    "text": "routine if the integer we planted corresponds to an address anywhere within the block then memory protection",
    "start": "1409360",
    "end": "1416400"
  },
  {
    "text": "will respond in One Way by uh keeping the block on the weight list but if the",
    "start": "1416400",
    "end": "1422320"
  },
  {
    "text": "integer we planted is not within the weight listed blocks address range then memory protection will behave in a",
    "start": "1422320",
    "end": "1428440"
  },
  {
    "text": "different way and deallocate the block so it's starting to sound like we may",
    "start": "1428440",
    "end": "1434240"
  },
  {
    "text": "have a way to reveal information about the layout of the address space we can repeatedly guess an address plant it as",
    "start": "1434240",
    "end": "1442640"
  },
  {
    "text": "an integer on the stack and get memory protection to behave in a way that reveals whether or not we have correctly",
    "start": "1442640",
    "end": "1449960"
  },
  {
    "text": "guessed the address of a certain allocated Block in memory in other words we have an",
    "start": "1449960",
    "end": "1455840"
  },
  {
    "text": "article or do we because at this point there is still a very big",
    "start": "1455840",
    "end": "1461840"
  },
  {
    "text": "problem let's look at the programmatic contract exposed by memory protection",
    "start": "1461840",
    "end": "1469158"
  },
  {
    "text": "hm aside from that dll notification which is not something that gets called",
    "start": "1469640",
    "end": "1474679"
  },
  {
    "text": "during normal program operation memory protection does not return even a single",
    "start": "1474679",
    "end": "1480000"
  },
  {
    "text": "piece of data from any of its methods that's a problem we can influence memory",
    "start": "1480000",
    "end": "1486039"
  },
  {
    "text": "protection based on um whether we've guessed the correct address or not but to have an oracle we need to have the",
    "start": "1486039",
    "end": "1492679"
  },
  {
    "text": "ability to read some kind of a response back and memory protections API gives us",
    "start": "1492679",
    "end": "1497760"
  },
  {
    "text": "absolutely nothing what this means is that we need a side channel so when I was thinking about",
    "start": "1497760",
    "end": "1505399"
  },
  {
    "text": "this the first thing that came to mind was that maybe we could use a timing attack but then something else came",
    "start": "1505399",
    "end": "1510960"
  },
  {
    "text": "along it was in the summer of 2014 and uh some cases starting started coming into uh the zero day initiative that",
    "start": "1510960",
    "end": "1517720"
  },
  {
    "text": "were kind of unusual we were seeing proof of concept code that would expose bad code paths in",
    "start": "1517720",
    "end": "1524840"
  },
  {
    "text": "IE by subjecting the browser to memory pressure um the code would do some lengthy Loop",
    "start": "1524840",
    "end": "1532120"
  },
  {
    "text": "performing repeated Dom manipulations and also consuming memory at some point",
    "start": "1532120",
    "end": "1537520"
  },
  {
    "text": "when virtual address space was nearly exhausted and memory allocations were starting to fail a code path would be",
    "start": "1537520",
    "end": "1544039"
  },
  {
    "text": "triggered that was vulnerable it was striking how a reasonably reliable trigger could be constructed in this way",
    "start": "1544039",
    "end": "1550840"
  },
  {
    "text": "even though the browser was under such a high level of stress I started thinking about the idea of operating the BR",
    "start": "1550840",
    "end": "1558320"
  },
  {
    "text": "Bowser in a regime of high memory pressure it's relatively unexplored",
    "start": "1558320",
    "end": "1565279"
  },
  {
    "text": "territory what kinds of things can we make happen it struck me as interesting something else I noticed was",
    "start": "1565279",
    "end": "1572039"
  },
  {
    "text": "that when um script Rec request an operation that requires a heap allocation and the allocation fails due",
    "start": "1572039",
    "end": "1579960"
  },
  {
    "text": "to a lack of available memory the script receives an out of memory",
    "start": "1579960",
    "end": "1586240"
  },
  {
    "text": "exception here we have a way for attacker's script to detect whether an",
    "start": "1586240",
    "end": "1591760"
  },
  {
    "text": "allocation was a success or a failure all it needs to do is check for the exception and here's the crucial",
    "start": "1591760",
    "end": "1599039"
  },
  {
    "text": "Insight script can detect whether an allocation succeeds or fails and whether",
    "start": "1599039",
    "end": "1605440"
  },
  {
    "text": "it succeeds or fails is a function of the existing state of the",
    "start": "1605440",
    "end": "1611399"
  },
  {
    "text": "Heap in other words JavaScript out of memory exceptions are a side channel",
    "start": "1611399",
    "end": "1617520"
  },
  {
    "text": "that reveals information about the state of the Heap and that's exactly the side channel that we need in order to get",
    "start": "1617520",
    "end": "1623679"
  },
  {
    "text": "information back for memory protection here's the highlevel view of",
    "start": "1623679",
    "end": "1630279"
  },
  {
    "text": "how we're going to consult the memory protection Oracle don't be concerned about the",
    "start": "1630279",
    "end": "1636679"
  },
  {
    "text": "exact details I'm going to fill those in just a little bit later for now let's just appreciate the high LEL structure",
    "start": "1636679",
    "end": "1642799"
  },
  {
    "text": "of what we're going to do say we have a block of memory on the memory protection weight list",
    "start": "1642799",
    "end": "1648760"
  },
  {
    "text": "and we want to consult the article um to determine whether a certain address X is",
    "start": "1648760",
    "end": "1654039"
  },
  {
    "text": "an address that falls within that block um we plant X on the stack as an integer",
    "start": "1654039",
    "end": "1660000"
  },
  {
    "text": "and then we do something that triggers memory protections Reclamation routine in response memory protection modifies",
    "start": "1660000",
    "end": "1666919"
  },
  {
    "text": "the Heap in a way that's dependent on whether X points within the targeted block how do we find out how memory",
    "start": "1666919",
    "end": "1673600"
  },
  {
    "text": "protection has responded we attempt a new Heap allocation that is designed to",
    "start": "1673600",
    "end": "1679919"
  },
  {
    "text": "succeed or fail depending upon what memory protection has done to the Heap",
    "start": "1679919",
    "end": "1686240"
  },
  {
    "text": "then by checking for the presence or absence of an out of memory exception we can make a deduction about how memory",
    "start": "1686240",
    "end": "1692960"
  },
  {
    "text": "protection has behaved and this reveals the in the answer to whether x Falls",
    "start": "1692960",
    "end": "1698360"
  },
  {
    "text": "within the targeted block of memory here's the whole chain of deductions we make the presence or",
    "start": "1698360",
    "end": "1705080"
  },
  {
    "text": "absence of an out of memory exception tells us something about the state of the Heap the state of the Heap tells us",
    "start": "1705080",
    "end": "1712000"
  },
  {
    "text": "something about how memory protection has behaved and how memory protection has behaved um tells us whether x Falls",
    "start": "1712000",
    "end": "1719159"
  },
  {
    "text": "within the targeted block that's the high level view clearly to actualize all this it's going to take",
    "start": "1719159",
    "end": "1725919"
  },
  {
    "text": "some pretty careful setup but here's the thing going back to something i' mentioned earlier once you start thinking about",
    "start": "1725919",
    "end": "1733240"
  },
  {
    "text": "what you can do in a regime of high memory pressure some really interesting",
    "start": "1733240",
    "end": "1739039"
  },
  {
    "text": "possibilities open up um before going any further though I'd like to refine what we mean by high memory pressure",
    "start": "1739039",
    "end": "1746600"
  },
  {
    "text": "it's more subtle than just piling on lots of pressure until there's no free memory left first of all it's not really",
    "start": "1746600",
    "end": "1754640"
  },
  {
    "text": "availability of availability of memory we're talking about it's availability of address space in a 32-bit process the",
    "start": "1754640",
    "end": "1763000"
  },
  {
    "text": "limiting factor that causes allocation failures is not memory exhaustion it's address space",
    "start": "1763000",
    "end": "1769279"
  },
  {
    "text": "exhaustion the next thing to note it's possible for allocations to fail even if",
    "start": "1769279",
    "end": "1774440"
  },
  {
    "text": "there's plenty of address space left it all just depends on how large of an allocation you're asking for also you",
    "start": "1774440",
    "end": "1781440"
  },
  {
    "text": "know it's not the aggregate amount of remaining address Bas that matters it's whether a large enough contiguous free",
    "start": "1781440",
    "end": "1788640"
  },
  {
    "text": "region can be found so let's refine our ideas follows operating the browser in a",
    "start": "1788640",
    "end": "1796080"
  },
  {
    "text": "regime of limited event availability of large contiguous regions of free address",
    "start": "1796080",
    "end": "1803279"
  },
  {
    "text": "space so let's play with this a little bit see what we can do let's say we spray the Heap with one megabyte",
    "start": "1803279",
    "end": "1810240"
  },
  {
    "text": "allocations until address space is all consumed and then we free one of those",
    "start": "1810240",
    "end": "1816240"
  },
  {
    "text": "one megabyte blocks what's left is a 1 Megabyte hole and that hole is the one",
    "start": "1816240",
    "end": "1823399"
  },
  {
    "text": "and only contiguous region of one megabytes of free addresses uh we can",
    "start": "1823399",
    "end": "1828519"
  },
  {
    "text": "actually leave lots of smaller holes also and it doesn't change the fact that we have exactly one hole that's one",
    "start": "1828519",
    "end": "1834120"
  },
  {
    "text": "megabyte big if we now go back and make another one megabyte allocation um we",
    "start": "1834120",
    "end": "1839880"
  },
  {
    "text": "know that will be placed right in that hole because that's the only place it can fit we can actually keep doing this",
    "start": "1839880",
    "end": "1846360"
  },
  {
    "text": "over and over allocating one megabyte block and freeing it allocating a one megabyte block and freeing it every time",
    "start": "1846360",
    "end": "1852399"
  },
  {
    "text": "the one megabyte block will be allocated in exactly the same place now what would happen if one time",
    "start": "1852399",
    "end": "1859760"
  },
  {
    "text": "we tried to make that allocation but it failed what would that tell us what could make that happen well one thing",
    "start": "1859760",
    "end": "1867000"
  },
  {
    "text": "that could make that happen is if some other allocation came along and occupied the hole but um let's say we can rule",
    "start": "1867000",
    "end": "1874360"
  },
  {
    "text": "out that possibility because we know there are no other large allocations going on then we might be able to",
    "start": "1874360",
    "end": "1880760"
  },
  {
    "text": "conclude that what happened was the last time around the one megabyte block never",
    "start": "1880760",
    "end": "1886639"
  },
  {
    "text": "really got freed because memory protection was holding on to it in other",
    "start": "1886639",
    "end": "1892159"
  },
  {
    "text": "words we have a way of telling whether memory protection still has the block weight listed by trying to make a new 1",
    "start": "1892159",
    "end": "1899679"
  },
  {
    "text": "Megabyte allocation and checking to see if an out of memory exception is thrown all right now we have all the",
    "start": "1899679",
    "end": "1907559"
  },
  {
    "text": "main pieces we need in order to make an attack possible first we prepare memory",
    "start": "1907559",
    "end": "1913200"
  },
  {
    "text": "so there's just one large contiguous free region let's say one megabyte in",
    "start": "1913200",
    "end": "1918960"
  },
  {
    "text": "size but it could be any size we like we're going to call that the hole or the region we're going to use memory",
    "start": "1918960",
    "end": "1925519"
  },
  {
    "text": "protection as an article to determine where that hole is in",
    "start": "1925519",
    "end": "1930559"
  },
  {
    "text": "memory we guess an address X and we want to consult the article to determine if x",
    "start": "1930559",
    "end": "1937200"
  },
  {
    "text": "Falls within the hole we make a 1 Megabyte allocation so now the hole is",
    "start": "1937200",
    "end": "1943240"
  },
  {
    "text": "occupied and then we free the allocation we made meaning that it gets passed to protected free protected free puts the",
    "start": "1943240",
    "end": "1950519"
  },
  {
    "text": "allocation on the weight list as far as the heat manager concerned the memory is still",
    "start": "1950519",
    "end": "1957000"
  },
  {
    "text": "allocated now we plant X as an integer on the stack and while X is there on the",
    "start": "1957000",
    "end": "1962320"
  },
  {
    "text": "stack we do something that triggers memory Reclamation what happens next depends on",
    "start": "1962320",
    "end": "1968559"
  },
  {
    "text": "whether x Falls within the 1 Megabyte address region or not if x Falls within",
    "start": "1968559",
    "end": "1974399"
  },
  {
    "text": "the address region then when memory protection performs reclamation it will keep this allocation on the",
    "start": "1974399",
    "end": "1980159"
  },
  {
    "text": "weight list and it won't free it at the heat manager level otherwise if x doesn't fall within the region then",
    "start": "1980159",
    "end": "1987000"
  },
  {
    "text": "memory protection will remove this allocation from the weight list and invoke Heap free so it'll be completely",
    "start": "1987000",
    "end": "1994760"
  },
  {
    "text": "free uh this shows the two possible States we can end up in if x Falls",
    "start": "1994760",
    "end": "2000240"
  },
  {
    "text": "within the region the hole stays occupied but if x does not fall within the region then the hole gets opened up",
    "start": "2000240",
    "end": "2007039"
  },
  {
    "text": "again last step to tell which of these two states we just ended up in all we need",
    "start": "2007039",
    "end": "2013000"
  },
  {
    "text": "to do is to try another 1 Megabyte allocation if it succeeds we know that",
    "start": "2013000",
    "end": "2018679"
  },
  {
    "text": "the hole got opened and this means that X wasn't within the region but if we get an out of memory exception that then we",
    "start": "2018679",
    "end": "2025440"
  },
  {
    "text": "know that the whole stay occupied which tells us that x Falls within the region now we have an answer from the Oracle",
    "start": "2025440",
    "end": "2032840"
  },
  {
    "text": "and by repeating this process with different values of X we can use the Oracle to find out",
    "start": "2032840",
    "end": "2038480"
  },
  {
    "text": "exactly where that 1 megab hole is in memory so I'm going to go back to this",
    "start": "2038480",
    "end": "2044799"
  },
  {
    "text": "idea just one more time when we operate the browser in a regime of limited",
    "start": "2044799",
    "end": "2050398"
  },
  {
    "text": "availability of large contiguous regions of free address space the new",
    "start": "2050399",
    "end": "2055480"
  },
  {
    "text": "possibilities that arise can be quite interesting it leads us to what we can do next so far what we have is a way to",
    "start": "2055480",
    "end": "2063280"
  },
  {
    "text": "prepare the address space so that there is just one large hole of available address addes of a size are choosing and",
    "start": "2063280",
    "end": "2069919"
  },
  {
    "text": "then to use the memory protection Oracle to determine the exact addresses of that",
    "start": "2069919",
    "end": "2075158"
  },
  {
    "text": "hole how can we make good use of this ability what can an attacker gain from",
    "start": "2075159",
    "end": "2080599"
  },
  {
    "text": "knowing the address of a hole in the address space we can load a module into",
    "start": "2080599",
    "end": "2087679"
  },
  {
    "text": "it we can start by creating a hole that's exactly the right size for",
    "start": "2087679",
    "end": "2093079"
  },
  {
    "text": "loading a particular module then using the memory protection Oracle we leak the",
    "start": "2093079",
    "end": "2099400"
  },
  {
    "text": "address of the hole finally we cause the loading of the module it gets loaded exactly at the",
    "start": "2099400",
    "end": "2106280"
  },
  {
    "text": "beginning of the hole because that's exact that's the only available place in the address space where that module is",
    "start": "2106280",
    "end": "2112920"
  },
  {
    "text": "going to fit so it's actually an aslr bypass and",
    "start": "2112920",
    "end": "2119200"
  },
  {
    "text": "it runs quite efficient efficiently and reliably we're going to show a demo video here what it looks like",
    "start": "2119200",
    "end": "2127920"
  },
  {
    "text": "okay running the page and it's got an address",
    "start": "2139720",
    "end": "2146720"
  },
  {
    "text": "already open up wind debug check that address",
    "start": "2146720",
    "end": "2152359"
  },
  {
    "text": "[Applause]",
    "start": "2164600",
    "end": "2167750"
  },
  {
    "text": "um in this aslr bypass we've relied on exhaustion of the 32bit address space",
    "start": "2172119",
    "end": "2178839"
  },
  {
    "text": "there's been a great deal of confusion about how this affects 64-bit systems on this slide we're just going to dispel",
    "start": "2178839",
    "end": "2185400"
  },
  {
    "text": "some myths um the truth is this issue affects every default desktop of IE",
    "start": "2185400",
    "end": "2191599"
  },
  {
    "text": "that's out there except for Metro I'm not sure about ie 10 um this is because",
    "start": "2191599",
    "end": "2196920"
  },
  {
    "text": "under default settings uh uh Windows 10 I should say not IE 10",
    "start": "2196920",
    "end": "2202680"
  },
  {
    "text": "I'm not sure about Windows 10 um this is because under default",
    "start": "2202680",
    "end": "2207880"
  },
  {
    "text": "settings classic desktop IE uh uses a 32-bit renderer process even if the",
    "start": "2207880",
    "end": "2214440"
  },
  {
    "text": "broker process is 64-bit so even if you You' got a 64-bit processor and 64-bit",
    "start": "2214440",
    "end": "2221280"
  },
  {
    "text": "windows and you're running 64-bit IE with default settings this aslr bypass",
    "start": "2221280",
    "end": "2226560"
  },
  {
    "text": "still works um so this has been a lot of fun um what started out looking like it was",
    "start": "2226560",
    "end": "2232560"
  },
  {
    "text": "something that was non- exploitable turned out in the end to be a reliable aslr bypass the key Insight that made it",
    "start": "2232560",
    "end": "2238319"
  },
  {
    "text": "possible is that JavaScript out of memory exceptions are a side channel that reveals critical information about",
    "start": "2238319",
    "end": "2243920"
  },
  {
    "text": "the state of the Heap I don't think this has been recognized before and there are interesting possibilities that open up",
    "start": "2243920",
    "end": "2249280"
  },
  {
    "text": "when you operate the browser under memory pressure we've made several",
    "start": "2249280",
    "end": "2254480"
  },
  {
    "text": "recommendations to Microsoft for ways they can improve isolated Heap and memory protection to harden them against",
    "start": "2254480",
    "end": "2260400"
  },
  {
    "text": "the attacks we've discovered um in regard to memory protection we make the recommendation to remove memory",
    "start": "2260400",
    "end": "2267520"
  },
  {
    "text": "protection from array and buffer allocations this means that memory protection would apply only to scaler",
    "start": "2267520",
    "end": "2274240"
  },
  {
    "text": "allocations our rationale is that one almost never finds an exploitable uaf",
    "start": "2274240",
    "end": "2279560"
  },
  {
    "text": "condition in Internet Explorer where the freed object is an array or a buffer so",
    "start": "2279560",
    "end": "2284880"
  },
  {
    "text": "the the benefit of applying memory protection to these types is doubtful on the other hand we've demonstrated how it",
    "start": "2284880",
    "end": "2290960"
  },
  {
    "text": "can be a of very significant benefit to an attacker we therefore feel that memory protection will be a stronger",
    "start": "2290960",
    "end": "2297960"
  },
  {
    "text": "defense if applied to scaler allocations only our next suggestion pertains to",
    "start": "2297960",
    "end": "2304079"
  },
  {
    "text": "strengthening aslr I'm taking a look at how we got aslr to fail what you can notice is that",
    "start": "2304079",
    "end": "2310480"
  },
  {
    "text": "the attacker was able to violate one of asr's assumptions by preparing the",
    "start": "2310480",
    "end": "2315680"
  },
  {
    "text": "address space in a particular way uh here's the particular assumption that aslr makes that when it chooses a load",
    "start": "2315680",
    "end": "2322480"
  },
  {
    "text": "address for a module from among the set of possible load addresses that this",
    "start": "2322480",
    "end": "2327880"
  },
  {
    "text": "random choice will exhibit a significant amount of entropy but an attacker can break this assumption by radically",
    "start": "2327880",
    "end": "2335359"
  },
  {
    "text": "narrowing the set of possible load addresses before the module loads our recommendation is to enhance aslr by",
    "start": "2335359",
    "end": "2342480"
  },
  {
    "text": "adding an additional check before loading a module this check is to ensure that there really do exist a",
    "start": "2342480",
    "end": "2349440"
  },
  {
    "text": "multiplicity of addresses at which the requested module could load before actually performing the random selection",
    "start": "2349440",
    "end": "2356560"
  },
  {
    "text": "of a load address if the number of possible load addresses is below is below a certain threshold the module",
    "start": "2356560",
    "end": "2362720"
  },
  {
    "text": "load should fail since loading the module under this circumstance could significant ly weaken the security of",
    "start": "2362720",
    "end": "2368960"
  },
  {
    "text": "the process this next recommendation is in regard to out of memory exceptions we've",
    "start": "2368960",
    "end": "2375839"
  },
  {
    "text": "shown that JavaScript out of memory exceptions are a side channel that reveals information about the state of",
    "start": "2375839",
    "end": "2381880"
  },
  {
    "text": "the Heap although this leaked bit of information might seem insignificant at",
    "start": "2381880",
    "end": "2387119"
  },
  {
    "text": "first we have shown that how how it can actually be leveraged to great effect it should also be mentioned that out of",
    "start": "2387119",
    "end": "2393119"
  },
  {
    "text": "memory exceptions are very useful in to the attacker in setting up conditions of memory pressure that are needed for our",
    "start": "2393119",
    "end": "2400440"
  },
  {
    "text": "aslr bypass attack as well as triggering various other vulnerabilities that are",
    "start": "2400440",
    "end": "2405760"
  },
  {
    "text": "dependent on memory pressure we therefore recommend considering eliminating out of memory exceptions in",
    "start": "2405760",
    "end": "2412400"
  },
  {
    "text": "script when an allocation fails due to memory or address space exhaustion",
    "start": "2412400",
    "end": "2418640"
  },
  {
    "text": "instead of passing an exception up to script code where it can be handled the condition should be considered as fatal",
    "start": "2418640",
    "end": "2425040"
  },
  {
    "text": "to the process or at least fatal to script execution within the process this",
    "start": "2425040",
    "end": "2430640"
  },
  {
    "text": "seems unlikely to have a significant negative impact upon legitimate web",
    "start": "2430640",
    "end": "2437200"
  },
  {
    "text": "pages finally we recommend taking ISO Heap to the next logical step by creating additional separate heaps",
    "start": "2437200",
    "end": "2445000"
  },
  {
    "text": "ideally one could have a separate Heap for each scaler type this would bring two great benefits first a uaf condition",
    "start": "2445000",
    "end": "2452839"
  },
  {
    "text": "could never lead to type confusion since every type is confined to its own Heap",
    "start": "2452839",
    "end": "2458040"
  },
  {
    "text": "secondly since each Heap consists entirely of objects of homogeneous size misalignments will not arise actually",
    "start": "2458040",
    "end": "2465680"
  },
  {
    "text": "this last point is made tricker by a storage of C++ arrays C++ array storage",
    "start": "2465680",
    "end": "2471760"
  },
  {
    "text": "has a metadata footprint that differs from the storage of individual scalers so it's possible to use C++ arrays to",
    "start": "2471760",
    "end": "2478319"
  },
  {
    "text": "introduce misalignment however as we've mentioned exploitable uafs in arrays and",
    "start": "2478319",
    "end": "2485440"
  },
  {
    "text": "buffer allocations are extreme extremely rare so we recommend just leaving all array and buffer allocations on the",
    "start": "2485440",
    "end": "2491920"
  },
  {
    "text": "default Heap instead and if we do that it should become impossible for an attacker to produce misalignments on the",
    "start": "2491920",
    "end": "2499000"
  },
  {
    "text": "isolated heaps actually there's another completely separate reason why it's best",
    "start": "2499000",
    "end": "2504200"
  },
  {
    "text": "to leave arrays and buffers on the main process Heap and I'd like to digress a",
    "start": "2504200",
    "end": "2509359"
  },
  {
    "text": "moment to explain why uh there's something that doesn't get much attention when ISO Heap is discussed and",
    "start": "2509359",
    "end": "2515400"
  },
  {
    "text": "that's what um could be called an ous reuse attack what's that well consider",
    "start": "2515400",
    "end": "2521680"
  },
  {
    "text": "how ISO Heap is supposed to ensure that when a Dom object is freed then attacker won't be able to uh allocate some other",
    "start": "2521680",
    "end": "2528440"
  },
  {
    "text": "non-dom type object in its place such as a string is so he tries to ensure this",
    "start": "2528440",
    "end": "2534520"
  },
  {
    "text": "by making sure that Dom allocations and string allocations don't happen on the same Heap but here's the thing the",
    "start": "2534520",
    "end": "2542079"
  },
  {
    "text": "attacker doesn't care about heaps the attacker only cares about addresses",
    "start": "2542079",
    "end": "2547680"
  },
  {
    "text": "is it possible for the address of a freed Dom object to later on be the",
    "start": "2547680",
    "end": "2552920"
  },
  {
    "text": "address of a string allocation this would become possible if the iso Heap which is the Heap on which",
    "start": "2552920",
    "end": "2560040"
  },
  {
    "text": "Dom objects are stored sometimes relinquishes control a virtual address pie that no longer needs this would",
    "start": "2560040",
    "end": "2567000"
  },
  {
    "text": "create the opportunity for those same addresses to later become part of a different Heap such as the process Heap",
    "start": "2567000",
    "end": "2572520"
  },
  {
    "text": "then a string could be allocated there is this attack actually",
    "start": "2572520",
    "end": "2578359"
  },
  {
    "text": "possible currently this attack is not possible and here's why the way the",
    "start": "2578359",
    "end": "2583680"
  },
  {
    "text": "windows heat manager Works small allocations reside within regions of virtual memory called Heap segments and",
    "start": "2583680",
    "end": "2590440"
  },
  {
    "text": "once a particular Heap reserves a segment it never relinquishes control of those virtual addresses for as long as",
    "start": "2590440",
    "end": "2596800"
  },
  {
    "text": "that Heap lives it will never allow those addresses to become part of any other Heap and today the iso Heap is",
    "start": "2596800",
    "end": "2602880"
  },
  {
    "text": "used only for small scalar allocations but if instead IE tried to protect large",
    "start": "2602880",
    "end": "2609040"
  },
  {
    "text": "buffer allocations by placing them on ISO Heap then isolation wouldn't be guaranteed for large allocations the",
    "start": "2609040",
    "end": "2616280"
  },
  {
    "text": "Heap manager doesn't use Heap segments when the Heap manager freed the buffer it would relinquish control over the",
    "start": "2616280",
    "end": "2622720"
  },
  {
    "text": "actual virtual addresses involved and later on those virtual addresses could be become part of a different Heap",
    "start": "2622720",
    "end": "2628599"
  },
  {
    "text": "breaking the isolation what this means for us is that it's pointless to try to protect buffers in arrays by placing",
    "start": "2628599",
    "end": "2635079"
  },
  {
    "text": "them on an isolated Heap that isolation could easily be broken by an address reuse attack bottom line is the best way",
    "start": "2635079",
    "end": "2642440"
  },
  {
    "text": "is to keep array and buffer allocations on the default Heap and have a separate",
    "start": "2642440",
    "end": "2647520"
  },
  {
    "text": "isolated Heap for every type of scaler allocation then those isolated heaps will be completely immune to type",
    "start": "2647520",
    "end": "2654040"
  },
  {
    "text": "confusion and misalignment issues so having a separate Heap for every scaler type is highly beneficial",
    "start": "2654040",
    "end": "2660839"
  },
  {
    "text": "but the drawback is that it may be too wasteful of address space in a 32-bit process where address space is a scar",
    "start": "2660839",
    "end": "2667359"
  },
  {
    "text": "resource we're faced with a trade-off between security and address Bas usage",
    "start": "2667359",
    "end": "2673000"
  },
  {
    "text": "what can we do to make the best of this trade-off we're only going to be able to create a limited number of heaps and in",
    "start": "2673000",
    "end": "2678240"
  },
  {
    "text": "whatever way we make assignments of types to heaps an attacker who has discovered a uaf on a given Heap will",
    "start": "2678240",
    "end": "2683599"
  },
  {
    "text": "try to construct an exploit via type confusion and or misalignment by making use of the various types we have",
    "start": "2683599",
    "end": "2689640"
  },
  {
    "text": "assigned to that same Heap unless we randomize the assignments between types",
    "start": "2689640",
    "end": "2695760"
  },
  {
    "text": "and heaps we can break the monoculture of heat partitioning and instead choose a random partitioning at process startup",
    "start": "2695760",
    "end": "2702720"
  },
  {
    "text": "time uh at process startup time this denies to the attacker the ability to write a reliable exploit that relies on",
    "start": "2702720",
    "end": "2710720"
  },
  {
    "text": "knowledge of which types are collocated on a heap um this optimizes the defender",
    "start": "2710720",
    "end": "2716240"
  },
  {
    "text": "Advantage when we make the tradeoff between security and the number of heaps we're willing to",
    "start": "2716240",
    "end": "2723200"
  },
  {
    "text": "create all right so in conclusion wanted to also show uh the exploit that we had generated for the um bypass program was",
    "start": "2724920",
    "end": "2732839"
  },
  {
    "text": "one of the requirements but what we're going to you're going to see is all of the attack techniques put into one exploit the first thing you're going to",
    "start": "2732839",
    "end": "2738040"
  },
  {
    "text": "see is we're going to launch Internet Explorer and we're going to use the aslr bypass to to Break um are using memory",
    "start": "2738040",
    "end": "2744359"
  },
  {
    "text": "protection to break aslr so you just at that point we're just checking to make sure it was the most current",
    "start": "2744359",
    "end": "2749760"
  },
  {
    "text": "browser which it was and you'll see it break aslr",
    "start": "2749760",
    "end": "2755599"
  },
  {
    "text": "right right there and then it will pass that on the the leaked address out off to the exploit where it will then use uh",
    "start": "2755599",
    "end": "2762559"
  },
  {
    "text": "the the memory protection uh techniques along with the isolated Heap techniques to gain code execution on the latest",
    "start": "2762559",
    "end": "2768839"
  },
  {
    "text": "version of Internet Explorer um so when we submitted this paper to Microsoft and all of the",
    "start": "2768839",
    "end": "2774960"
  },
  {
    "text": "details and all the recommendations um they they awarded it $125,000 and then they uh sat on it for several months and",
    "start": "2774960",
    "end": "2782319"
  },
  {
    "text": "decided not to implement any of the recommendations uh that we had talked about",
    "start": "2782319",
    "end": "2788839"
  },
  {
    "text": "so uh we released all the code uh so it's if you want to go play with the uh aslr uh break and the isolated Heap",
    "start": "2789640",
    "end": "2797079"
  },
  {
    "text": "attack techniques and the m and the memory protection techniques all of the code is out on GitHub um it works on",
    "start": "2797079",
    "end": "2802480"
  },
  {
    "text": "every default version of iie desktop version as Simon stated um and I hope you enjoyed the presentation uh we have",
    "start": "2802480",
    "end": "2809720"
  },
  {
    "text": "uh for anybody who wants to come up and ask a question we have a u challenge coin up here it is it is a 10 it's dual",
    "start": "2809720",
    "end": "2816599"
  },
  {
    "text": "use technology it's a challenge coin and it's also a bottle opener so get it before the wasar takes it away uh thank",
    "start": "2816599",
    "end": "2823920"
  },
  {
    "text": "you have a have a nice day [Applause]",
    "start": "2823920",
    "end": "2832538"
  }
]