[
  {
    "start": "0",
    "end": "173000"
  },
  {
    "text": "this is the lower layers track and you are here for Windows 8 Heap intervals",
    "start": "160",
    "end": "5879"
  },
  {
    "text": "with uh Chris valek and tar J",
    "start": "5879",
    "end": "10760"
  },
  {
    "text": "man all right uh uh you know as the flyer red this is Windows 8 Heap",
    "start": "12200",
    "end": "20359"
  },
  {
    "text": "intervals I am uh I'm Chris valc I'm a senior security research scientist at CI",
    "start": "20600",
    "end": "27560"
  },
  {
    "text": "and this is tar mant he's a vulnerability researcher at asthma security um we we do a lot of Heap",
    "start": "27560",
    "end": "34840"
  },
  {
    "text": "research if you haven't noticed so what are we going to cover today um we're going to try to look at",
    "start": "34840",
    "end": "41960"
  },
  {
    "text": "data structures and algorithms um in the Windows 8 release preview that being said this may change when uh what",
    "start": "41960",
    "end": "48520"
  },
  {
    "text": "October 26th whenever the actual uh product is Dro but uh I think it should give you a pretty solid overview of of",
    "start": "48520",
    "end": "54920"
  },
  {
    "text": "what's going to happen um after we go over some uh data structures and algorithms we're going to talk about all",
    "start": "54920",
    "end": "60640"
  },
  {
    "text": "the security mechanisms put in place and there are definitely plenty of them um and finally I I hope that we can go over",
    "start": "60640",
    "end": "67159"
  },
  {
    "text": "some um exploitation techniques that that tar and I have uh came up with that are applicable to Windows 8 uh while not",
    "start": "67159",
    "end": "74520"
  },
  {
    "text": "as plentiful as in years past uh they still do kind of exist um so if you",
    "start": "74520",
    "end": "82000"
  },
  {
    "text": "haven't already read the two papers that tar and and I wrote before uh you might",
    "start": "82000",
    "end": "87159"
  },
  {
    "text": "want to read those as prerequisite material before you kind of get get into the Windows 8 paper that uh that we",
    "start": "87159",
    "end": "92320"
  },
  {
    "text": "released with his presentation also there's a bunch of other people who do a bunch of good Heap work obviously you",
    "start": "92320",
    "end": "98000"
  },
  {
    "text": "know check that stuff out um why do you even want to learn about this U you know",
    "start": "98000",
    "end": "103520"
  },
  {
    "text": "it's 2012 why why is Heap stuff even important anymore um you know if you're going to do anything with uh heat-based",
    "start": "103520",
    "end": "111000"
  },
  {
    "text": "memory corruption vulnerabilities uh you can't really just play guesswork and hope to win um you need to understand",
    "start": "111000",
    "end": "116880"
  },
  {
    "text": "the underlying operating system and application uh and how they actually manage their memory and what you can do",
    "start": "116880",
    "end": "123360"
  },
  {
    "text": "to leverage certain pieces to achieve your goals and and gain more exploitation Primitives um that being",
    "start": "123360",
    "end": "130720"
  },
  {
    "text": "said if if you have Heap exploits that work in Windows 7 uh most likely they",
    "start": "130720",
    "end": "135760"
  },
  {
    "text": "are not going to work in Windows 8 I'm sorry to burst everyone's bubble uh you know feel free to leave now if you don't",
    "start": "135760",
    "end": "141599"
  },
  {
    "text": "care to learn uh why that happened but uh that being said let's let's try to move on here and and see what actually",
    "start": "141599",
    "end": "147959"
  },
  {
    "text": "uh we're going to cover uh uh first I'm going to talk about the user land backend Heap uh this is probably the",
    "start": "147959",
    "end": "153480"
  },
  {
    "text": "most familiar to people it's the dou link list structure that um that",
    "start": "153480",
    "end": "159120"
  },
  {
    "text": "everyone's kind of used to uh since seeing it you know a long time ago um we're also going to cover some",
    "start": "159120",
    "end": "165560"
  },
  {
    "text": "mitigations in the back end um it it it is strikingly similar to Windows 7 but",
    "start": "165560",
    "end": "171080"
  },
  {
    "text": "not exactly the same um so I know this is probably hard for some of you to see",
    "start": "171080",
    "end": "176239"
  },
  {
    "start": "173000",
    "end": "173000"
  },
  {
    "text": "but in Windows 7 I created a diagram that is very similar to what I'm showing showing you right now um before though",
    "start": "176239",
    "end": "182800"
  },
  {
    "text": "there was this backlink um in the in the list hints and that backlink kind of",
    "start": "182800",
    "end": "188040"
  },
  {
    "text": "serves the Dual Purpose it contained a counter to uh to lazily activate the low",
    "start": "188040",
    "end": "194280"
  },
  {
    "text": "fragmentation heat for certain sizes and occasionally it would contain the address of a heat bucket data structure",
    "start": "194280",
    "end": "200480"
  },
  {
    "text": "um which would then be passed to the front end allocator and used for allocation this is now changed um they",
    "start": "200480",
    "end": "207159"
  },
  {
    "text": "no longer use this back blink there's actually been another data structure added to the to the base uh to the heat",
    "start": "207159",
    "end": "213360"
  },
  {
    "text": "base um structure that is specifically used for counting and and indic into the",
    "start": "213360",
    "end": "219959"
  },
  {
    "text": "uh indices into the the heat buckets um it's called the the front end Heap usage data uh data structure and also as an",
    "start": "219959",
    "end": "227200"
  },
  {
    "text": "optimization instead of checking this backlink they now have a bit map where they can say hey at this index within",
    "start": "227200",
    "end": "232879"
  },
  {
    "text": "the bit map uh is it is it a one if it is we're using the low fragmentation heat for this given size those are some",
    "start": "232879",
    "end": "239319"
  },
  {
    "text": "things that changed um while not drastic changes there there changes nonetheless um on to the onto the kind",
    "start": "239319",
    "end": "246439"
  },
  {
    "text": "of exploitation mitigations and like I said there's a lot of these uh the first one I'm going to talk about is uh back",
    "start": "246439",
    "end": "253439"
  },
  {
    "text": "in 2008 uh Ben Hawks if you're counting name drops that's going to be one it may happen several times um Ben Hawks came",
    "start": "253439",
    "end": "260359"
  },
  {
    "text": "up with uh a technique where if you could free uh a heap handle um and then",
    "start": "260359",
    "end": "266000"
  },
  {
    "text": "subsequently allocate uh that memory you could overwrite the the Heap handle with",
    "start": "266000",
    "end": "271080"
  },
  {
    "text": "uh data that would permit the attacker to get uh code execution uh upon",
    "start": "271080",
    "end": "276880"
  },
  {
    "text": "allocation um this was actually uh prevented in the Windows 8 backend manager by uh by checking the the chunk",
    "start": "276880",
    "end": "284840"
  },
  {
    "text": "that you're freeing when you free it if it's the same Heap that's freeing it um it's going to report failure therefore",
    "start": "284840",
    "end": "291560"
  },
  {
    "text": "if you're trying to free a heap handle uh as the chunk to be freed uh it's not going to work um you know there may be a",
    "start": "291560",
    "end": "298639"
  },
  {
    "text": "corner case where you could potentially get a heap to free a different Heap handle but uh I would just say that's",
    "start": "298639",
    "end": "304039"
  },
  {
    "text": "probably not going to happen um the more complex uh of these uh is uh is uh what",
    "start": "304039",
    "end": "311479"
  },
  {
    "start": "306000",
    "end": "306000"
  },
  {
    "text": "they did with virtual allocated memory um before there was a possibility that",
    "start": "311479",
    "end": "317759"
  },
  {
    "text": "you could have predictable virtually allocated memory that is uh you could have one big chunk on top of another big",
    "start": "317759",
    "end": "325000"
  },
  {
    "text": "chunk and if you had an overflow you you kind of had a very good idea of what what would be where um this this has",
    "start": "325000",
    "end": "332400"
  },
  {
    "text": "changed in Windows 8 and changed quite drastically um again the code is kind of small but what they do now is if the",
    "start": "332400",
    "end": "339560"
  },
  {
    "text": "size that you're requesting should be serviced by the virtual memory allocator um it's actually going to create a a a",
    "start": "339560",
    "end": "345919"
  },
  {
    "text": "random offset and um and it's also going to add uh some extra size to to um to",
    "start": "345919",
    "end": "352240"
  },
  {
    "text": "the actual amount of memory that's needed and what this achieves is two things um the offset for this uh virtual",
    "start": "352240",
    "end": "360919"
  },
  {
    "text": "header is not going to be predict predictable you won't know exactly where it's going to be in this overall chunk",
    "start": "360919",
    "end": "367280"
  },
  {
    "text": "and also since they uh reserve the memory uh and uh and then only commit a",
    "start": "367280",
    "end": "372479"
  },
  {
    "text": "different amount uh each of these virtual chunks these large pieces of memory are going to have reserved memory",
    "start": "372479",
    "end": "378080"
  },
  {
    "text": "above it in hopes that if there is a sequential overflow it hits this reserved memory and an access violation",
    "start": "378080",
    "end": "383400"
  },
  {
    "text": "occurs uh therefore rendering your your overflow uh useless so that didn't seem too bad",
    "start": "383400",
    "end": "390639"
  },
  {
    "text": "right there weren't too many changes uh it worked you know fairly well there's just some exploitation mitigations um",
    "start": "390639",
    "end": "397280"
  },
  {
    "text": "now we're going to talk about the user land front front end or the low fragmentation heat um there was a lot of",
    "start": "397280",
    "end": "403440"
  },
  {
    "text": "changes to algorithms and data structures in the front end um RTP low",
    "start": "403440",
    "end": "408759"
  },
  {
    "text": "frag Heap Alec from Context uh is the main allocation function for the low fragmentation Heap and when binding it",
    "start": "408759",
    "end": "415840"
  },
  {
    "text": "with the um the preview versions and Windows 7 they didn't actually come up as match matched functions so that's how",
    "start": "415840",
    "end": "423039"
  },
  {
    "text": "much the functionality and data structure access changed in those things um that made it very not fun to start",
    "start": "423039",
    "end": "430879"
  },
  {
    "text": "analyzing um the we we talked about uh the",
    "start": "431440",
    "end": "436560"
  },
  {
    "text": "mitigations in in the back end and and now we'll talk about them in the front end as well um we we first saw how the",
    "start": "436560",
    "end": "442080"
  },
  {
    "text": "the front end uh activation her istics are triggered right no longer is that that backlink used for everything uh",
    "start": "442080",
    "end": "449160"
  },
  {
    "text": "there's dedicated data structures in a bit map to do it um we're going to go over in a bit of detail how front-end",
    "start": "449160",
    "end": "456520"
  },
  {
    "text": "allocation actually occurs now uh there's no more free entry offset if you're familiar with the free entry offset overwrite technique it's been",
    "start": "456520",
    "end": "463560"
  },
  {
    "text": "removed uh also allocations are less deterministic uh than they have been",
    "start": "463560",
    "end": "468639"
  },
  {
    "text": "before um we'll go over that stuff and then continue with the mitigations uh listed below is fast fail and there's",
    "start": "468639",
    "end": "474599"
  },
  {
    "text": "some guard Pages um and more anti- exploitation technology uh but before we",
    "start": "474599",
    "end": "481479"
  },
  {
    "text": "do that um let's revisit Windows 7 real quickly the Windows 7 low fragmentation",
    "start": "481479",
    "end": "487120"
  },
  {
    "text": "Heap used this Heap user D user data header uh which preceded a thing that I",
    "start": "487120",
    "end": "492280"
  },
  {
    "text": "refer to as the user blocks basically a user block container contained chunks of memory um and each chunk the first two",
    "start": "492280",
    "end": "499080"
  },
  {
    "text": "bytes was uh uh kind of uh it was the free entry offset which pointed to uh",
    "start": "499080",
    "end": "504560"
  },
  {
    "text": "another free Chunk in this overall container um the allocator blindly Trust",
    "start": "504560",
    "end": "509720"
  },
  {
    "text": "this value and used it in its calculations so here's how allocations",
    "start": "509720",
    "end": "515240"
  },
  {
    "text": "would go in Windows 7 say you had this virgin user block container where no chunks were uh busy um and you made an",
    "start": "515240",
    "end": "522360"
  },
  {
    "text": "allocation you see that the free entry offset is updated with the value that was there and the depth is decremented",
    "start": "522360",
    "end": "529440"
  },
  {
    "text": "you make another allocation it comes from the slot next to it uh the free offset is updated uh and and so on so",
    "start": "529440",
    "end": "536320"
  },
  {
    "text": "you see that it basically trusts this value and use it to provide free chunks to the calling",
    "start": "536320",
    "end": "543040"
  },
  {
    "text": "function Windows 8s changed quite drastically in this fashion um you can see the Heap user data header has many",
    "start": "543040",
    "end": "549720"
  },
  {
    "text": "more members um uh one of them that caught my eye as soon as I saw it was guard page present which uh is",
    "start": "549720",
    "end": "556320"
  },
  {
    "text": "foretelling about what you'll see here shortly um other neat things to notice is there's a uh first allocation offset",
    "start": "556320",
    "end": "564160"
  },
  {
    "text": "and this is basically was implied before because it was always after the Heap user data header but now it's a a set",
    "start": "564160",
    "end": "570320"
  },
  {
    "text": "value and also there's a member called The Block stride that basically just says how big are chunks that I that I'm",
    "start": "570320",
    "end": "576600"
  },
  {
    "text": "managing uh how big are they um you'll see that there's no more free entry",
    "start": "576600",
    "end": "581839"
  },
  {
    "text": "offset in in the user block chunks anymore it's just not used instead they use this bit map and each index in the",
    "start": "581839",
    "end": "589120"
  },
  {
    "text": "bit map represents an offset into the user blocks container and there's a",
    "start": "589120",
    "end": "594519"
  },
  {
    "text": "one:1 ratio of how many chunks there are on the user block to this bit map here",
    "start": "594519",
    "end": "600040"
  },
  {
    "start": "599000",
    "end": "599000"
  },
  {
    "text": "um I talked about Randomness and non-determinism before um how exactly they do that it it wouldn't be",
    "start": "600040",
    "end": "606079"
  },
  {
    "text": "manageable to generate a random number every time you make an allocation the overhead would be too great right uh so",
    "start": "606079",
    "end": "612120"
  },
  {
    "text": "instead they created this array and actually populated this Ray with uh unsigned 8-bit integers and these",
    "start": "612120",
    "end": "619120"
  },
  {
    "text": "unsigned 8bit integers are used uh as offsets into this bit map which will",
    "start": "619120",
    "end": "624760"
  },
  {
    "text": "then uh be used to service a request and get a chunk from the lfh so if you're",
    "start": "624760",
    "end": "629800"
  },
  {
    "text": "wondering how that occurred it's not a random uh random integer every time an allocation is made it's actually pre",
    "start": "629800",
    "end": "636360"
  },
  {
    "text": "pre-populated and updated occasionally as well so just like the Windows 7",
    "start": "636360",
    "end": "642279"
  },
  {
    "start": "639000",
    "end": "639000"
  },
  {
    "text": "allocation let's assume that we control all the allocations and uh this is a virgin user block with no busy chunks um",
    "start": "642279",
    "end": "650200"
  },
  {
    "text": "the first allocation won't actually be from that first slot anymore it's going to be at a random value so we'll say the",
    "start": "650200",
    "end": "656959"
  },
  {
    "text": "the bit map uh was chosen and it looked at offset 5 and it said yes there that's a free chunk there you can give give the",
    "start": "656959",
    "end": "664320"
  },
  {
    "text": "offset 5 back um we're not actually going to get offset six is the next one if we make a subsequent allocation it's",
    "start": "664320",
    "end": "670600"
  },
  {
    "text": "going to be another uh offset within this bit map uh you may be asking what happens when the the bit map actually",
    "start": "670600",
    "end": "677880"
  },
  {
    "text": "misses and it and it actually selects a busy chunk um it will actually then start sequentially looking for free",
    "start": "677880",
    "end": "684399"
  },
  {
    "text": "chunks so if you guess offset five uh and you want to you know and it's busy",
    "start": "684399",
    "end": "689600"
  },
  {
    "text": "it's going to go look at offset 6 7 8 Etc um looking for chunks that are free",
    "start": "689600",
    "end": "695800"
  },
  {
    "text": "so this kind of hinders the process of knowing exactly where your chunk is going to be in relation to data that you",
    "start": "695800",
    "end": "701519"
  },
  {
    "text": "want to overwrite um it also could uh really mess up kind of use after free bugs as well you can't just uh Alec free",
    "start": "701519",
    "end": "708440"
  },
  {
    "text": "Alec again you're not guaranteed to get the same uh memory at the same address back so like I said Windows 7 uh kind of",
    "start": "708440",
    "end": "716519"
  },
  {
    "start": "713000",
    "end": "713000"
  },
  {
    "text": "sequential if if I may uh allocations there's a free an Offset you can overwrite um pretty pretty",
    "start": "716519",
    "end": "722680"
  },
  {
    "text": "straightforward uh Windows 8 you have this randomized non-deterministic way of allocating memory uh there's no free",
    "start": "722680",
    "end": "728880"
  },
  {
    "text": "andry offset so chalk another one up for exploitation techniques dying in Windows",
    "start": "728880",
    "end": "734000"
  },
  {
    "start": "734000",
    "end": "734000"
  },
  {
    "text": "8 but let's talk more about what they did as well uh there's a thing called Fast fail and I think the first person",
    "start": "734000",
    "end": "740160"
  },
  {
    "text": "really to publicly mention this was Alex enescu uh on his blog uh it's basically",
    "start": "740160",
    "end": "746360"
  },
  {
    "text": "uh a way an interrupt to uh terminate the process uh immediately and they're",
    "start": "746360",
    "end": "752839"
  },
  {
    "text": "actually used when checking uh linked lists to ensure that they're not corrupted uh there's times where if uh",
    "start": "752839",
    "end": "760360"
  },
  {
    "text": "the terminate on corruption flag isn't passed to Heap set information uh the API uh it will log a report but it may",
    "start": "760360",
    "end": "767440"
  },
  {
    "text": "not terminate the application um as a developer of Windows code you may not want to rely on people doing things",
    "start": "767440",
    "end": "773760"
  },
  {
    "text": "properly you may want to just terminate uh proc the process right there and this is exactly what it does um you'll see",
    "start": "773760",
    "end": "780440"
  },
  {
    "text": "here that if the W link list is considered corrupting uh instead of calling a logging function and seeing if",
    "start": "780440",
    "end": "786320"
  },
  {
    "text": "the right flags are set it calls in 29 and the the process will we stop um you",
    "start": "786320",
    "end": "791720"
  },
  {
    "text": "should go look at this function in Windows 7 um guard guard Pages as we talked",
    "start": "791720",
    "end": "798560"
  },
  {
    "start": "796000",
    "end": "796000"
  },
  {
    "text": "about before with uh with the guard page present flag uh I think this might affect sequential heat-based buffer",
    "start": "798560",
    "end": "805320"
  },
  {
    "text": "overflows uh the most uh maybe maybe in comparison with the with the random",
    "start": "805320",
    "end": "810360"
  },
  {
    "text": "allocations um the Heap user data header now uh instead of just allocating uh a",
    "start": "810360",
    "end": "815639"
  },
  {
    "text": "big chunk of memory and chunking it out and potentially storing other uh user block containers uh adjacent in memory",
    "start": "815639",
    "end": "822560"
  },
  {
    "text": "we'll tend to look at things first um it will actually say hey uh have how many chunks of this",
    "start": "822560",
    "end": "830560"
  },
  {
    "text": "certain size do we have uh if it's above a24 next time you this time around when",
    "start": "830560",
    "end": "836040"
  },
  {
    "text": "we're creating a new user block container uh add a page to it make that a guard page afterwards um also if the",
    "start": "836040",
    "end": "842560"
  },
  {
    "text": "size is really big that you're asking for which could be used in a spray it also will so say set the guard page",
    "start": "842560",
    "end": "848360"
  },
  {
    "text": "appropriately um like I said before you would had this function that would allocate memory chunk it out and that'd",
    "start": "848360",
    "end": "854560"
  },
  {
    "text": "be done um now uh when RTP allocate user block used to just allocate the memory",
    "start": "854560",
    "end": "860199"
  },
  {
    "text": "and be done it actually calls RTP allocate user block from Heap um and you",
    "start": "860199",
    "end": "866199"
  },
  {
    "text": "can see in this code right here uh it allocates the memory and if it says the guard page should be set it's going to",
    "start": "866199",
    "end": "873399"
  },
  {
    "text": "add a add a page size and then reallocate the memory and then set the uh set that uh page at the end to page",
    "start": "873399",
    "end": "880160"
  },
  {
    "text": "now access effectively what this does if you try to read or write to those addresses that are set as page no access",
    "start": "880160",
    "end": "888040"
  },
  {
    "text": "um access violation you don't win uh and again this could greatly affect uh Heap",
    "start": "888040",
    "end": "894000"
  },
  {
    "text": "spraying um you know sequential overflows things like that it uh it definitely will will uh you know make",
    "start": "894000",
    "end": "900759"
  },
  {
    "text": "things much harder and here's just a brief example of uh theoretically what could happen with these guard Pages",
    "start": "900759",
    "end": "907600"
  },
  {
    "text": "before you would have user blocks uh for for the heat bucket six and 8 and six all kind of together contiguous in",
    "start": "907600",
    "end": "914600"
  },
  {
    "text": "memory um now they're going to actually be separated by these guard pages so uh an overflow uh from one uh user block",
    "start": "914600",
    "end": "921959"
  },
  {
    "text": "container into another will cause an access violation if theistic is",
    "start": "921959",
    "end": "927360"
  },
  {
    "text": "triggered um again uh they they really paid attention to Ben Hawk's uh research",
    "start": "927360",
    "end": "933800"
  },
  {
    "text": "from 2008 um he also came up with a way to sorry um over uh with with an",
    "start": "933800",
    "end": "942000"
  },
  {
    "text": "overflow overwrite some information in a heap's trunk header uh the way uh if",
    "start": "942000",
    "end": "947800"
  },
  {
    "text": "there were certain flag set the header would actually be relocated to a new position and if you could trick it into",
    "start": "947800",
    "end": "953279"
  },
  {
    "text": "relocating to a position within the uh low fragmentation Heap you could",
    "start": "953279",
    "end": "958680"
  },
  {
    "text": "actually free memory uh that wasn't supposed to be free and was busy and created a use after free condition um",
    "start": "958680",
    "end": "965759"
  },
  {
    "text": "now when they do the initial uh header relocation you see here that if it's set",
    "start": "965759",
    "end": "971079"
  },
  {
    "text": "to a certain value it's going to subtract from its current position to get a new header but now if it's in the",
    "start": "971079",
    "end": "977160"
  },
  {
    "text": "low fragmentation Heap um it's actually going to call RTP validate lfh block and",
    "start": "977160",
    "end": "982399"
  },
  {
    "text": "that's going to guarantee hey if this is the type of Chunk that gets relocated is it really that type or is this attempted",
    "start": "982399",
    "end": "990120"
  },
  {
    "text": "exploitation if it is attempted exploitation then it's going to log failure and return",
    "start": "990120",
    "end": "996759"
  },
  {
    "text": "zero exploitation death number four I think we're on death toll number four um",
    "start": "997160",
    "end": "1003360"
  },
  {
    "text": "the last thing uh the last kind of uh exploitation mitigation I want to talk about uh was something I kind of",
    "start": "1003360",
    "end": "1009880"
  },
  {
    "text": "speculated about um originally in Windows 7 the uh rlp low frag Heat ball",
    "start": "1009880",
    "end": "1016319"
  },
  {
    "text": "from Context was wrapped in a TR catch all basically if anything happened bad uh exception would be caught it would",
    "start": "1016319",
    "end": "1022519"
  },
  {
    "text": "return zero if zero was returned from that function the backend would service the request no questions asked um I kind",
    "start": "1022519",
    "end": "1029520"
  },
  {
    "text": "of theorized that if you could do an overflow multiple times and attempt to say overwrite certain addresses or",
    "start": "1029520",
    "end": "1035798"
  },
  {
    "text": "access certain pieces of memory that you were uh trying to guess uh you could you could win because uh if the memory",
    "start": "1035799",
    "end": "1044000"
  },
  {
    "text": "address didn't exist um it would exception would be thrown it would be caught zero return you get a piece of",
    "start": "1044000",
    "end": "1049400"
  },
  {
    "text": "memory uh if it did exist you you overrode it and you won so um that was pretty easy fix they just removed the",
    "start": "1049400",
    "end": "1055640"
  },
  {
    "text": "tri catch all and that's not there anymore all right little summary for everyone little rundown um you can see",
    "start": "1055640",
    "end": "1062160"
  },
  {
    "text": "Windows Vista and Windows 7 have a lot of red X's that is because they don't do things like uh have Heap handle",
    "start": "1062160",
    "end": "1069000"
  },
  {
    "text": "protection and N non-determinism uh baked in uh to virtually allocated",
    "start": "1069000",
    "end": "1074280"
  },
  {
    "text": "chunks and chunks in the low fragmentation heat they're using dedicated bit maps and counters instead",
    "start": "1074280",
    "end": "1079760"
  },
  {
    "text": "of kind of just plugging them into uh data structures that already exist uh they've added ways for programmers to",
    "start": "1079760",
    "end": "1086400"
  },
  {
    "text": "immediately terminate a process upon link list corruption um you know and and added things like guard pages and",
    "start": "1086400",
    "end": "1092840"
  },
  {
    "text": "avoiding uh arbitrary freeze and lastly even things that weren't uh you know",
    "start": "1092840",
    "end": "1098960"
  },
  {
    "text": "real in my mind I just theorized that you could use this Tri catch thing uh you know a couple years ago uh and it",
    "start": "1098960",
    "end": "1105360"
  },
  {
    "text": "was removed as well so this shows that Microsoft really took the time and and effort to go through and and look at",
    "start": "1105360",
    "end": "1110960"
  },
  {
    "text": "what has been published and uh kind of react in a good way by fixing it instead of yelling at me and tar um that being",
    "start": "1110960",
    "end": "1119840"
  },
  {
    "text": "said I can't not talk about exploitation at all right so I'm going to go over a",
    "start": "1119840",
    "end": "1125159"
  },
  {
    "text": "little uh exploitation Tech um I don't think any of it's too Earth shattering uh I'd like to say I have one and a",
    "start": "1125159",
    "end": "1132120"
  },
  {
    "start": "1127000",
    "end": "1127000"
  },
  {
    "text": "third exploitation techniques in this and this consists of the third um I I I",
    "start": "1132120",
    "end": "1138240"
  },
  {
    "text": "named it map flipping 20 um so what happens if uh chunks are",
    "start": "1138240",
    "end": "1145760"
  },
  {
    "text": "in the low fragmentation Heap um when they're freed they need to update that bit map right because it keeps track of",
    "start": "1145760",
    "end": "1151880"
  },
  {
    "text": "uh busy and free chunks well since we don't have the we're not relying on the data structure in free enry offset how",
    "start": "1151880",
    "end": "1157760"
  },
  {
    "text": "does it do that it actually stores the offset within the the index into the bit",
    "start": "1157760",
    "end": "1163039"
  },
  {
    "text": "map in the chunk header in the previous size field and um what you could do do",
    "start": "1163039",
    "end": "1169440"
  },
  {
    "text": "is overwrite this previous size field with a value that is greater than the size of the bit map it will gladly zero",
    "start": "1169440",
    "end": "1176400"
  },
  {
    "text": "out a bit at that index within the bit map since the bit map is off the base of",
    "start": "1176400",
    "end": "1181600"
  },
  {
    "text": "the Heap user data header you can potentially affect say C++ objects other heat metadata uh and so on that being",
    "start": "1181600",
    "end": "1189440"
  },
  {
    "text": "said this thing's pretty moot for a lot of reasons and I'll list a few um to",
    "start": "1189440",
    "end": "1194559"
  },
  {
    "text": "free a chunk you're going to need to get the user blocks uh which is derived from the Heap Subs segment the Heap Subs",
    "start": "1194559",
    "end": "1201320"
  },
  {
    "text": "segment is dered by exor uh exor encoding or xor uncoding depending on how you look at it uh values uh which",
    "start": "1201320",
    "end": "1208960"
  },
  {
    "text": "include that encoded chunk header introduced in Windows Vista and Windows 7 for all chunks so if you have a",
    "start": "1208960",
    "end": "1214799"
  },
  {
    "text": "sequential overflow and you munge that uh this definitely isn't going to work for you um if you had an off by few or",
    "start": "1214799",
    "end": "1221240"
  },
  {
    "text": "an overflow that started after the encoded header because the previous size is at offset four um this may able to do",
    "start": "1221240",
    "end": "1229120"
  },
  {
    "text": "something it may be an exploitation primitive but I don't really have very high confidence level in this ever being",
    "start": "1229120",
    "end": "1236520"
  },
  {
    "text": "useful and this is just an example of what I said before let's say you have a bit map of the size of four you override",
    "start": "1237600",
    "end": "1243480"
  },
  {
    "text": "a chunk uh to have a previous size of 20 um you know when you free it uh at bit",
    "start": "1243480",
    "end": "1249840"
  },
  {
    "text": "20 from that uh bit map it's going to zero out a zero out a bit uh you could potentially do something you know",
    "start": "1249840",
    "end": "1256600"
  },
  {
    "text": "inappropriate um on to the next one uh the the exploitation technique that I think can",
    "start": "1256600",
    "end": "1263360"
  },
  {
    "start": "1258000",
    "end": "1258000"
  },
  {
    "text": "be viable um we talked before about how that Heap user data header structure uh",
    "start": "1263360",
    "end": "1268640"
  },
  {
    "text": "contained uh a first allocation offset uh where to start the you know the the allocations and uh block stride which is",
    "start": "1268640",
    "end": "1275679"
  },
  {
    "text": "a a two by integer that uh told you how big the chunks are right well if you",
    "start": "1275679",
    "end": "1282360"
  },
  {
    "text": "could align two uh user block structures adjacent in memory and have a chunk that",
    "start": "1282360",
    "end": "1288159"
  },
  {
    "text": "over flows from one into the other you could actually come up with a scenario",
    "start": "1288159",
    "end": "1293480"
  },
  {
    "text": "that looks much like this you have two blocks aligned and you overflow from one chunk into another uh Heap use a data",
    "start": "1293480",
    "end": "1301559"
  },
  {
    "text": "header structure and you can overwrite the first allocation offset and the block stride what effectively this does",
    "start": "1301559",
    "end": "1309080"
  },
  {
    "text": "for you is the chunk to be returned says hey uh once you get the index within uh",
    "start": "1309080",
    "end": "1315039"
  },
  {
    "text": "that bit map uh take the address of the user block multiply that index from the bit map with the block stride and add",
    "start": "1315039",
    "end": "1321360"
  },
  {
    "text": "the first allocation offset uh this has very similar effects to the free entry offset overwrite technique right because",
    "start": "1321360",
    "end": "1328039"
  },
  {
    "text": "you're going to be able to return a chunk that is outside the bounds of this container um that's going to be bad",
    "start": "1328039",
    "end": "1335080"
  },
  {
    "text": "times I mean generally that's what I did when uh we wrote the is FP bug is we got",
    "start": "1335080",
    "end": "1341600"
  },
  {
    "text": "some stuff in memory somewhere and then overr a value and kind of prayed that that stuff would be there um and",
    "start": "1341600",
    "end": "1347960"
  },
  {
    "text": "occasionally it was so you could use this to the same effect again there's some issues um",
    "start": "1347960",
    "end": "1354600"
  },
  {
    "text": "guard Pages uh if you if guard pages are enabled this sequential overflow deal will fail because you're going to have",
    "start": "1354600",
    "end": "1360799"
  },
  {
    "text": "an access violation um you have to position an over flowable chunk before a",
    "start": "1360799",
    "end": "1366120"
  },
  {
    "text": "heap user user data header structure that's much more difficult than placing it uh before a free chunk which was the",
    "start": "1366120",
    "end": "1373559"
  },
  {
    "text": "prerequisite for the free entry offset technique um tainting that bit map",
    "start": "1373559",
    "end": "1378760"
  },
  {
    "text": "that's used to determine where free chunks are uh could also uh end in Access violations if overwritten with",
    "start": "1378760",
    "end": "1385440"
  },
  {
    "text": "inappropriate values uh lastly I think the the chunk being returned from this",
    "start": "1385440",
    "end": "1390679"
  },
  {
    "text": "uh from this calculation actually has to be free as well it can't be busy so",
    "start": "1390679",
    "end": "1395799"
  },
  {
    "text": "there are quite a few uh prerequisites to get this working but the nice thing",
    "start": "1395799",
    "end": "1401120"
  },
  {
    "text": "is once you overwrite it once you can make allocations uh a bunch of time from that user block container and it's",
    "start": "1401120",
    "end": "1407039"
  },
  {
    "text": "always going to be tainted so I think this is actually",
    "start": "1407039",
    "end": "1412240"
  },
  {
    "text": "viable question Mr kushman have you gotten it to work I've have gotten it to",
    "start": "1412240",
    "end": "1417679"
  },
  {
    "text": "work on a program I wrote by myself do you have anything you want me",
    "start": "1417679",
    "end": "1424400"
  },
  {
    "text": "to look at all right with that being said it's T's time to talk about the konel pool",
    "start": "1424400",
    "end": "1432200"
  },
  {
    "text": "allocator okay so uh we've heard about the mitigation that were introduced in Windows 88 the Windows 8 Heap so we're",
    "start": "1434880",
    "end": "1442039"
  },
  {
    "text": "now going to look at the kernel pool um just to introduce the kernel pool briefly uh it's more of a deterministic",
    "start": "1442039",
    "end": "1449320"
  },
  {
    "text": "allocator so you allocate from the beginning of a page and then subsequent uh uh chunks are allocated by them up uh",
    "start": "1449320",
    "end": "1456919"
  },
  {
    "text": "it uses traditionally doubly link freelists uh these are ordered by block size it's very focused on efficiency uhu",
    "start": "1456919",
    "end": "1464600"
  },
  {
    "text": "meaning that the uses Locus high list tries to use CPU C etc etc and the",
    "start": "1464600",
    "end": "1470279"
  },
  {
    "text": "kernel pool if you're not familiar with it is used by pretty much all third party drivers and uh system components",
    "start": "1470279",
    "end": "1477240"
  },
  {
    "text": "uh the kernel itself for Dynam dynamically allocating memory so there's uh basically two pool",
    "start": "1477240",
    "end": "1484399"
  },
  {
    "start": "1481000",
    "end": "1481000"
  },
  {
    "text": "types uh there's the non-page pool which is guaranteed to be present at all times",
    "start": "1484399",
    "end": "1490640"
  },
  {
    "text": "Um this can be accessed by any code regardless of the per um regardless of",
    "start": "1490640",
    "end": "1495880"
  },
  {
    "text": "the RQ level uh it's you also have the page pool which can be page out for instance a disk and this can only be",
    "start": "1495880",
    "end": "1503240"
  },
  {
    "text": "accessed U below DPC and dispatch level um so there's basically these two basic",
    "start": "1503240",
    "end": "1509039"
  },
  {
    "text": "pool types uh and each of the pool that is defined is managed by why do we uh",
    "start": "1509039",
    "end": "1514480"
  },
  {
    "text": "refer to as a pool descriptor and this descriptor is really the base structure that manages uh the lists of free pool",
    "start": "1514480",
    "end": "1521799"
  },
  {
    "text": "chunks uh the dou link lists uh these lists are ordered by block size uh so on",
    "start": "1521799",
    "end": "1527760"
  },
  {
    "text": "XA to six uh the block size is 8 bytes while in 64-bit a block size is uh 16",
    "start": "1527760",
    "end": "1534039"
  },
  {
    "text": "bit bytes uh they're used for allocation up to 480 bytes on 32bit and",
    "start": "1534039",
    "end": "1542520"
  },
  {
    "text": "4,964 bytes on 64-bit I believe uh the pool descriptor also keeps track of all",
    "start": "1542520",
    "end": "1549320"
  },
  {
    "text": "the allocations and frees and pages and use so it has like General statistics on on the pool",
    "start": "1549320",
    "end": "1556159"
  },
  {
    "start": "1556000",
    "end": "1556000"
  },
  {
    "text": "use uh when you allocate a CH each of those each of the chunks have a",
    "start": "1556159",
    "end": "1561440"
  },
  {
    "text": "pooled header associated with it so that header includes information such as the",
    "start": "1561440",
    "end": "1566640"
  },
  {
    "text": "size of Chunk uh the pool type uh the associated pool descriptor and a process",
    "start": "1566640",
    "end": "1572440"
  },
  {
    "text": "pointer and this is really what the allocator uses to do the merging and the allocation and freeing of the um of the",
    "start": "1572440",
    "end": "1580440"
  },
  {
    "text": "pool chunks themselves uh so the pool header has really been the target of",
    "start": "1580440",
    "end": "1585799"
  },
  {
    "text": "previous attacks on Windows uh previous version Windows such as Windows 7 uh so",
    "start": "1585799",
    "end": "1590919"
  },
  {
    "text": "you have the definition of this structure right here um so the Windows 8 kernel pool is is not fundamentally",
    "start": "1590919",
    "end": "1598840"
  },
  {
    "text": "changing any of the algorithms unlike what we've seen in user mode it's more of a hardened version of Windows 7 so",
    "start": "1598840",
    "end": "1605039"
  },
  {
    "start": "1600000",
    "end": "1600000"
  },
  {
    "text": "there's we don't have this any significant structure changes but we have a lot of more uh checks so there's",
    "start": "1605039",
    "end": "1611720"
  },
  {
    "text": "basically uh heaps of checks regarding the pool header you know validating all the values properly having validation on",
    "start": "1611720",
    "end": "1619520"
  },
  {
    "text": "the link list so it's not only safe on linking it's also safe linking uh they",
    "start": "1619520",
    "end": "1624559"
  },
  {
    "text": "also use cookies to protect pointers of various kinds uh and it also introduces",
    "start": "1624559",
    "end": "1631279"
  },
  {
    "text": "what is known as the non-executable non-page pool and this is to prevent an attacker from injecting Shell Code into",
    "start": "1631279",
    "end": "1638120"
  },
  {
    "text": "non-page memory um which um complement uh another Hardware mitigation called",
    "start": "1638120",
    "end": "1644919"
  },
  {
    "text": "smap uh in a way um so the end next pool uh as I said is introduced in Windows 8",
    "start": "1644919",
    "end": "1651520"
  },
  {
    "text": "and it's uh basically a new pool type so each driver has to request this type in",
    "start": "1651520",
    "end": "1657320"
  },
  {
    "text": "order to get U nonexecutable uh non-page memory um most of the non-paged",
    "start": "1657320",
    "end": "1663760"
  },
  {
    "text": "allocations in Windows now use this and this also includes the empty objects so",
    "start": "1663760",
    "end": "1668960"
  },
  {
    "text": "if you allocate an object uh you know that you can query it address through anti through anti query uh uh",
    "start": "1668960",
    "end": "1676919"
  },
  {
    "text": "information well forgot its name but anyway you can create its address and then you can put Shell Code in these",
    "start": "1676919",
    "end": "1682880"
  },
  {
    "text": "objects and you can chain them in order to create arbitary length CH code uh in",
    "start": "1682880",
    "end": "1688000"
  },
  {
    "text": "kernel memory uh with this uh you can no longer do that uh this also requires you",
    "start": "1688000",
    "end": "1693440"
  },
  {
    "text": "to have dep enabled so if if dep is disabled uh the NX pool is also disabled",
    "start": "1693440",
    "end": "1699440"
  },
  {
    "text": "and this is indicated by a a pool flag um so when when Windows uses this",
    "start": "1699440",
    "end": "1706440"
  },
  {
    "start": "1703000",
    "end": "1703000"
  },
  {
    "text": "NX pool descriptor it allocat it's two uh pool uh non-page descriptors per",
    "start": "1706440",
    "end": "1712000"
  },
  {
    "text": "non-page pool basically and this is the executable and the non-executable uh it",
    "start": "1712000",
    "end": "1717039"
  },
  {
    "text": "also uses or has uh non-page NX lookus ey lists and this is per processor uh",
    "start": "1717039",
    "end": "1724399"
  },
  {
    "text": "and it's per processor because of the optimization so cach use Etc and instead",
    "start": "1724399",
    "end": "1729880"
  },
  {
    "text": "of using uh the pull type to differentiate between the two it it calls this MMS non-page pool NX function",
    "start": "1729880",
    "end": "1738399"
  },
  {
    "text": "uh to determine whether memory should be returned to either the executable or the non-executable descriptor and this",
    "start": "1738399",
    "end": "1745000"
  },
  {
    "text": "function looks up the page table entry or the page directory entry and checks the NX bit in in that uh structure and",
    "start": "1745000",
    "end": "1752320"
  },
  {
    "text": "this is for instance used by by the free algorithm so one of the major um",
    "start": "1752320",
    "end": "1759679"
  },
  {
    "start": "1756000",
    "end": "1756000"
  },
  {
    "text": "mitigations that were introduced was the Kel pool cookie and this is used to protect uh like I me mentioned initially",
    "start": "1759679",
    "end": "1767640"
  },
  {
    "text": "uh pointer is referenced by the free algorithms and the allocation algorithms",
    "start": "1767640",
    "end": "1773559"
  },
  {
    "text": "uh such as in the Lo aide lists or you know process object pointers that are needed to uh whenever an allocation is",
    "start": "1773559",
    "end": "1781360"
  },
  {
    "text": "qua charge it is associated with a process so it stores a process object pointer uh within uh with the allocation",
    "start": "1781360",
    "end": "1788880"
  },
  {
    "text": "itself um it's also used to protect certain cach line allocations uh and",
    "start": "1788880",
    "end": "1794720"
  },
  {
    "text": "we'll get back to how that is implemented uh in the the kernel P pool cookie itself is initialized on boot and",
    "start": "1794720",
    "end": "1802799"
  },
  {
    "text": "this function called initialized pool and it's randomized with several system counters so this is basically this the",
    "start": "1802799",
    "end": "1810240"
  },
  {
    "start": "1807000",
    "end": "1807000"
  },
  {
    "text": "function for for seating or or or generating this cookie value so it takes",
    "start": "1810240",
    "end": "1815480"
  },
  {
    "text": "the tick count uh the number of system calls at a time the interupt time the current system time and calls this xgen",
    "start": "1815480",
    "end": "1823279"
  },
  {
    "text": "random function which returns a pseudo random number extor all these values together and then uh gives you the",
    "start": "1823279",
    "end": "1829919"
  },
  {
    "text": "cookie uh if the value is zero it ensures that the value is non zero by setting it to one so it the cookie will",
    "start": "1829919",
    "end": "1836640"
  },
  {
    "text": "never actually be zero if you call this function uh so there was this xgen",
    "start": "1836640",
    "end": "1842919"
  },
  {
    "text": "random value which is actually the function responsible for generating the pseudo random value which is seaing also",
    "start": "1842919",
    "end": "1850080"
  },
  {
    "text": "used by in generating the cookie and this is uh based on a l lagged Fibonacci",
    "start": "1850080",
    "end": "1855600"
  },
  {
    "text": "generator um and it's this generator is seated by boot entropy in the loader",
    "start": "1855600",
    "end": "1861320"
  },
  {
    "text": "parameter uh parameter block which is uh a a data structure pass to the kernel by",
    "start": "1861320",
    "end": "1868399"
  },
  {
    "text": "windload um and this is used by a number of functions now like for image base",
    "start": "1868399",
    "end": "1874120"
  },
  {
    "text": "randomization for PEB randomization uh stack cookie generation and and a lot of",
    "start": "1874120",
    "end": "1879279"
  },
  {
    "text": "other stuff U the boot entropy itself is gathered by uh windload as I said and",
    "start": "1879279",
    "end": "1885480"
  },
  {
    "start": "1880000",
    "end": "1880000"
  },
  {
    "text": "it's from basically six different sources uh so some of these sources will look at registry keys they will Cate the",
    "start": "1885480",
    "end": "1892600"
  },
  {
    "text": "the uh pseudo uh random number generator if you have a TPM enabled um and if you",
    "start": "1892600",
    "end": "1898919"
  },
  {
    "text": "have the new Ivy Bridge you will also use the new Rd ran instruction which is a new uh pseudo random number generator",
    "start": "1898919",
    "end": "1906480"
  },
  {
    "text": "uh embedded by the CPU um so in Windows 7 uh there was uh",
    "start": "1906480",
    "end": "1914200"
  },
  {
    "start": "1909000",
    "end": "1909000"
  },
  {
    "text": "uh the research I did previously was a very a number of attacks uh in regards",
    "start": "1914200",
    "end": "1920159"
  },
  {
    "text": "to how you could leverage kernel pool uh uh Corruptions in exploiting",
    "start": "1920159",
    "end": "1925960"
  },
  {
    "text": "vulnerabilities and um when you when you quit a charge allocations you typically store a pointer to the associated uh",
    "start": "1925960",
    "end": "1933440"
  },
  {
    "text": "process object uh in in that allocation on 32bit you you you add the number of",
    "start": "1933440",
    "end": "1940360"
  },
  {
    "text": "bytes by four so you store the the pointer as the last four bytes while in",
    "start": "1940360",
    "end": "1945399"
  },
  {
    "text": "64-bit you you put the um pointer in the pool header itself and when that",
    "start": "1945399",
    "end": "1951679"
  },
  {
    "text": "allocation is freed it checks this pointer uh not only does it check it but it reference the pointer and finds this",
    "start": "1951679",
    "end": "1958600"
  },
  {
    "text": "uh quota data structure in order to lower the quota uh so this could be used",
    "start": "1958600",
    "end": "1963799"
  },
  {
    "text": "if you control this pointer you could basically get an arbitrary de rent of arbitrary",
    "start": "1963799",
    "end": "1968840"
  },
  {
    "text": "memory uh so this is how this attack worked uh you had the pool overflow the first thing you overflow is the process",
    "start": "1968840",
    "end": "1975279"
  },
  {
    "text": "pointer uh so it was very easy to pull off you didn't really need to if you could control the length of the Overflow",
    "start": "1975279",
    "end": "1981559"
  },
  {
    "text": "you didn't need really need to corrupt any adjacent or bordering allocations",
    "start": "1981559",
    "end": "1986600"
  },
  {
    "text": "and this could be used to you know treent any any type of memory at any",
    "start": "1986600",
    "end": "1992120"
  },
  {
    "start": "1992000",
    "end": "1992000"
  },
  {
    "text": "address um in Windows a they address this attack by by exor and coding the",
    "start": "1992120",
    "end": "1997440"
  },
  {
    "text": "process pointer so they use this this pool cookie and exore it with the address of the chunk that you're you're",
    "start": "1997440",
    "end": "2004200"
  },
  {
    "text": "attacking or or checking and uh it also exorts it with the process pointer U and",
    "start": "2004200",
    "end": "2010000"
  },
  {
    "text": "and not only this but it also ensures that when it has decoded this value that it points into kernel address space so",
    "start": "2010000",
    "end": "2016679"
  },
  {
    "text": "in Windows uh so when I demonstrated this in Windows 7 uh I typ I could set",
    "start": "2016679",
    "end": "2022480"
  },
  {
    "text": "up a data structure in user mode and create a fake process object but now you would have to have that data structure",
    "start": "2022480",
    "end": "2028519"
  },
  {
    "text": "in kernel mode as well so it gets a lot harder and it would you know have to defeat the uh uh uh decoding which is",
    "start": "2028519",
    "end": "2036519"
  },
  {
    "text": "considered infeasible in a way um so this is how this encoding works so you",
    "start": "2036519",
    "end": "2044000"
  },
  {
    "text": "have you know you try to attach this process pointer but now when the the allocation is freed it decodes and it",
    "start": "2044000",
    "end": "2051960"
  },
  {
    "text": "checks if the decoded pointer is above system range start and if it's uh not it",
    "start": "2051960",
    "end": "2058800"
  },
  {
    "text": "bug checks if it is you know it will try to do some additional stuff but you know if you don't guess the right value uh it",
    "start": "2058800",
    "end": "2066398"
  },
  {
    "text": "will probably trigger an ACC violation or or crash at some",
    "start": "2066399",
    "end": "2071720"
  },
  {
    "start": "2072000",
    "end": "2072000"
  },
  {
    "text": "point um so look asy lists are used for you know servicing allocations quickly",
    "start": "2072000",
    "end": "2079079"
  },
  {
    "text": "uh they do not require you to lock the pool descriptor so it's very fast uh",
    "start": "2079079",
    "end": "2084158"
  },
  {
    "text": "it's singly linked it uses like optimized instructions for link list",
    "start": "2084159",
    "end": "2089679"
  },
  {
    "text": "operations uh in a Windows 7 you could since it's singly linked in Windows 7 you could simply overwrite the pointer",
    "start": "2089679",
    "end": "2096599"
  },
  {
    "text": "to the next Chunk on this list and that would give you control of the next allocation the address of the next",
    "start": "2096599",
    "end": "2103920"
  },
  {
    "text": "allocation um so in Windows 8 each of these look aside entries are protected",
    "start": "2103920",
    "end": "2109920"
  },
  {
    "start": "2104000",
    "end": "2104000"
  },
  {
    "text": "by a randomized cookie and this is checked whenever you allocate something so you you you try to corrupt this value",
    "start": "2109920",
    "end": "2117440"
  },
  {
    "text": "and you try to have the allocator return an address like in kernel space that you want to corrupt instead of giving you",
    "start": "2117440",
    "end": "2124599"
  },
  {
    "text": "that allocation uh uh when you whenever you free something it will put this",
    "start": "2124599",
    "end": "2130119"
  },
  {
    "text": "cookie uh which is the pull cookie extorted with a pull address right in front of the pointer to you know the",
    "start": "2130119",
    "end": "2137280"
  },
  {
    "text": "free list uh the the Lucas side list pointer uh on 64-bit instead of storing",
    "start": "2137280",
    "end": "2142680"
  },
  {
    "text": "it right before it will store it in the pool header so you know even if you have",
    "start": "2142680",
    "end": "2147800"
  },
  {
    "text": "an overflow it's it's going to be from a a a previous chunk anyway so it doesn't really matter as long as it's stored in",
    "start": "2147800",
    "end": "2154760"
  },
  {
    "text": "next chunk before before the um uh look aide list pointer uh this this thing",
    "start": "2154760",
    "end": "2161079"
  },
  {
    "text": "this um protection is also used in the pending freeze list which is an",
    "start": "2161079",
    "end": "2166119"
  },
  {
    "text": "optimization by the kernel pool in order to avoid you to having to do pool descriptor locking every time you free",
    "start": "2166119",
    "end": "2172720"
  },
  {
    "text": "something they will have a a long list of allocations or freed allocations that they will process in one",
    "start": "2172720",
    "end": "2179920"
  },
  {
    "text": "go um I think the notes about the release preview is that there is currently no cookie to uh for protecting",
    "start": "2179920",
    "end": "2186960"
  },
  {
    "text": "the pool Page look asy lists uh I've heard some some rumors about this having",
    "start": "2186960",
    "end": "2193160"
  },
  {
    "text": "been fixed now so it just like kills the last attack I had uh well we have some",
    "start": "2193160",
    "end": "2198880"
  },
  {
    "text": "more so just wait for that um so this is uh the the Overflow and you try to",
    "start": "2198880",
    "end": "2206920"
  },
  {
    "text": "attack this next pointer on this list in order to get control of the next allocation um now it it checks you know",
    "start": "2206920",
    "end": "2214640"
  },
  {
    "text": "the the it has the encoded value so it checks uh the cookie",
    "start": "2214640",
    "end": "2221359"
  },
  {
    "text": "um so I I briefly mentioned cash aligned allocations so when you when you",
    "start": "2221359",
    "end": "2227599"
  },
  {
    "start": "2222000",
    "end": "2222000"
  },
  {
    "text": "allocate pool memory you can request it to be aligned on a cache boundary uh",
    "start": "2227599",
    "end": "2233200"
  },
  {
    "text": "meaning that um you won't have the double cache you could potentially just",
    "start": "2233200",
    "end": "2238400"
  },
  {
    "text": "have one cache Miss right instead of two depending on where on where where uh the",
    "start": "2238400",
    "end": "2243440"
  },
  {
    "text": "allocation on which address the allocation is and you you do this by giving it the pool type of four which is",
    "start": "2243440",
    "end": "2250160"
  },
  {
    "text": "a non-page pool cach align or page pool cach align anything like that um and",
    "start": "2250160",
    "end": "2256079"
  },
  {
    "text": "this the allocator in order to ensure that it always gets uh cach align memory",
    "start": "2256079",
    "end": "2261319"
  },
  {
    "text": "it will increase the size requested uh so it runs up to the nearest cach line size and it adds the cach line size",
    "start": "2261319",
    "end": "2269520"
  },
  {
    "text": "again and The Cash Line size can be uh retrieved by looking at the NT bang X",
    "start": "2269520",
    "end": "2275280"
  },
  {
    "text": "cach line size uh value and this greatly favors performance over",
    "start": "2275280",
    "end": "2281319"
  },
  {
    "text": "uh space usage so if you on on 32bit if you try to allocate 40 hex BTE uh of",
    "start": "2281319",
    "end": "2289440"
  },
  {
    "text": "cacheline of the cacheline type it will end up with a c0 hex allocation uh in",
    "start": "2289440",
    "end": "2295839"
  },
  {
    "text": "order to ensure that uh uh you know the the fragment that it needs is on a cach",
    "start": "2295839",
    "end": "2301880"
  },
  {
    "text": "Aline B boundary and in carving out that fragment it does not bother returning",
    "start": "2301880",
    "end": "2307119"
  },
  {
    "text": "any unused bytes it it simply just uh lets the btes uh be in that",
    "start": "2307119",
    "end": "2314040"
  },
  {
    "start": "2314000",
    "end": "2314000"
  },
  {
    "text": "allocation so since you have this unused uh memory uh Windows 8 tries to insert a",
    "start": "2314040",
    "end": "2320079"
  },
  {
    "text": "cookie whenever uh there's space available like if the alloc allocator didn't serve you a a cach aligned",
    "start": "2320079",
    "end": "2327800"
  },
  {
    "text": "allocation but had to uh scan forwards until it found the cachon boundary and",
    "start": "2327800",
    "end": "2334040"
  },
  {
    "text": "having scanned forwards it leaves space for the cookie it tries to insert a",
    "start": "2334040",
    "end": "2339079"
  },
  {
    "text": "cookie in in this previous chunk uh so this cookie is is computed by exerting",
    "start": "2339079",
    "end": "2345640"
  },
  {
    "text": "the used chunk the address of the used chunk uh with the pool cookie and then it stores this cookie in that previous",
    "start": "2345640",
    "end": "2353319"
  },
  {
    "text": "chunk and for the allocator to know whether it needs to uh validate this",
    "start": "2353319",
    "end": "2359920"
  },
  {
    "text": "cookie it looks at the cacheline pool type so the cacheline pool type is is",
    "start": "2359920",
    "end": "2365119"
  },
  {
    "text": "defined by this this chunk that is on the cach line binary in the pool header and if this type is present it notices",
    "start": "2365119",
    "end": "2373640"
  },
  {
    "text": "uh it has to do the validation while if it's not there it doesn't care about or",
    "start": "2373640",
    "end": "2378960"
  },
  {
    "text": "it doesn't need to do a validation um so this is uh basically",
    "start": "2378960",
    "end": "2384480"
  },
  {
    "text": "how this works uh so in this is so so all of this is really the entire chunk",
    "start": "2384480",
    "end": "2391280"
  },
  {
    "text": "that was initially returned by the allocator uh or or by the um backend part of the allocator and then",
    "start": "2391280",
    "end": "2398400"
  },
  {
    "text": "it it notices that you know this is not on the caline boundary so it will scan forwards and and set the pool header at",
    "start": "2398400",
    "end": "2405400"
  },
  {
    "text": "this specific location and then it notices that it has unused bite so it will insert a cookie in front of of this",
    "start": "2405400",
    "end": "2414720"
  },
  {
    "start": "2414000",
    "end": "2414000"
  },
  {
    "text": "allocation um so in Windows 7 uh Windows 7 was the U really the the first uh",
    "start": "2414720",
    "end": "2422680"
  },
  {
    "text": "operating system version that introduced any sort of mitigations to the kernel pool so before Windows 7 uh you could",
    "start": "2422680",
    "end": "2430000"
  },
  {
    "text": "exploit or you could attack any sort of list entry structure used by the kernel pool and get a right four and get a win",
    "start": "2430000",
    "end": "2437680"
  },
  {
    "text": "pretty easily um in Windows 7 um they they added safe on linking so it became",
    "start": "2437680",
    "end": "2444400"
  },
  {
    "text": "a lot more difficult all of a sudden and uh well apart from these attacks uh in",
    "start": "2444400",
    "end": "2451440"
  },
  {
    "text": "that they validated uh each of these chunks and ensure that on W link lists",
    "start": "2451440",
    "end": "2456560"
  },
  {
    "text": "adjacent chunk pointed back to uh each other um the thing to note here was that",
    "start": "2456560",
    "end": "2463720"
  },
  {
    "text": "the checks were generally made when a chunk was unlined and there were no CH checks when when linking a chunk into a",
    "start": "2463720",
    "end": "2470560"
  },
  {
    "text": "a double link free list so in Windows 8 they they do both now safe linking and",
    "start": "2470560",
    "end": "2476160"
  },
  {
    "start": "2472000",
    "end": "2472000"
  },
  {
    "text": "unlinking so both when allocating chunks from a fre list and when freeing chunks",
    "start": "2476160",
    "end": "2481280"
  },
  {
    "text": "back to a free list and this also includes you know certain scenarios where you get",
    "start": "2481280",
    "end": "2487640"
  },
  {
    "text": "when you request uh a certain number of bytes but get more memory than you requested because there were uh for",
    "start": "2487640",
    "end": "2494040"
  },
  {
    "text": "instance this free list was was empty so it had to pick the next one uh and it",
    "start": "2494040",
    "end": "2499160"
  },
  {
    "text": "even checks you know when it puts that fragment back that it doesn't need uh into the the free lists again it even",
    "start": "2499160",
    "end": "2505640"
  },
  {
    "text": "checks that it these lists are consistent uh it also checks uh the",
    "start": "2505640",
    "end": "2511560"
  },
  {
    "text": "entry uh list entry structure for all the lists uh not just the uh the um list",
    "start": "2511560",
    "end": "2518240"
  },
  {
    "text": "entry structures associated with the pool uh allocations that it gets so this",
    "start": "2518240",
    "end": "2523880"
  },
  {
    "text": "this kills one of the attacks on Windows 7 uh where they didn't properly check uh",
    "start": "2523880",
    "end": "2528960"
  },
  {
    "text": "the F link that pointed to the first allocation that was uh first entry on a",
    "start": "2528960",
    "end": "2534480"
  },
  {
    "text": "free list so so this is um basically um you",
    "start": "2534480",
    "end": "2540880"
  },
  {
    "text": "have this list entry structure of free lists pointing to um pointing to entries",
    "start": "2540880",
    "end": "2547240"
  },
  {
    "text": "on this list and whenever you allocate something you will you will have validation of all these values uh so",
    "start": "2547240",
    "end": "2553640"
  },
  {
    "text": "it's pretty uh pretty good um so what I think this is the last",
    "start": "2553640",
    "end": "2561559"
  },
  {
    "start": "2558000",
    "end": "2558000"
  },
  {
    "text": "attack that was on Windows 7 uh so Windows 7 7 didn't check the pool index",
    "start": "2561559",
    "end": "2567520"
  },
  {
    "text": "uh for I pool chunk so the pool index basically defines uh what pool",
    "start": "2567520",
    "end": "2573760"
  },
  {
    "text": "descriptor a pool chunk belongs to and since it it's an index it looks up in in",
    "start": "2573760",
    "end": "2579559"
  },
  {
    "text": "an array of pointers uh which point to these p descriptors u so what you could do on",
    "start": "2579559",
    "end": "2585520"
  },
  {
    "text": "Windows 7 is you could simply uh reference an out of- bounds value in this array and that would do reference",
    "start": "2585520",
    "end": "2592200"
  },
  {
    "text": "an all pointer and since you were allowed to allocate an all page you could completely control the pool",
    "start": "2592200",
    "end": "2597760"
  },
  {
    "text": "descriptor and you can control where all these chunks were inserted uh so you could come you could you do a lot of",
    "start": "2597760",
    "end": "2604559"
  },
  {
    "text": "stuff including right to arbitrary memory you could do a right four uh it was pretty easy um so in this case uh",
    "start": "2604559",
    "end": "2612839"
  },
  {
    "text": "you can see on the left side the P index so it's like the second BTE in the pool header so you only needed like two bite",
    "start": "2612839",
    "end": "2620000"
  },
  {
    "text": "overflow and you can uh completely control all the all the uh free lists for uh which this allocation was free to",
    "start": "2620000",
    "end": "2628680"
  },
  {
    "text": "um so in Windows 8 they do a very simple fix they just check the pull index",
    "start": "2628680",
    "end": "2634000"
  },
  {
    "text": "against the number of pools that are defined uh so if we're talking about a page pull they check the X number of",
    "start": "2634000",
    "end": "2640960"
  },
  {
    "text": "page pull value and not only this but they also check uh that the um they also",
    "start": "2640960",
    "end": "2648319"
  },
  {
    "text": "checks when when the chunk is being linked into the list so if we look at this um the way you could get uh",
    "start": "2648319",
    "end": "2655359"
  },
  {
    "text": "arbitrary uh memory corruption in this case was that you controlled the Fink",
    "start": "2655359",
    "end": "2660640"
  },
  {
    "text": "and the values of of the of the uh double of the free lists in this null",
    "start": "2660640",
    "end": "2666160"
  },
  {
    "text": "page pull Des script um since they check and when you link in",
    "start": "2666160",
    "end": "2671400"
  },
  {
    "text": "you can no longer do this uh you can also not map to all page now because they have on 32bit wdm is disabled by",
    "start": "2671400",
    "end": "2679760"
  },
  {
    "text": "default so you need to actively go in and enable that uh subsystem and on 30",
    "start": "2679760",
    "end": "2685000"
  },
  {
    "text": "uh 64-bit uh there's no vdm so there's no need for uh there's no uh way to map",
    "start": "2685000",
    "end": "2690559"
  },
  {
    "text": "the N page so in summary uh you know they've",
    "start": "2690559",
    "end": "2695920"
  },
  {
    "start": "2692000",
    "end": "2692000"
  },
  {
    "text": "done a lot of good things in Windows 8 um in Windows 7 we had safe on linking",
    "start": "2695920",
    "end": "2701200"
  },
  {
    "text": "uh Windows 8 improves this uh pretty dram dramatically uh they also add safe",
    "start": "2701200",
    "end": "2707040"
  },
  {
    "text": "linking uh pool cookies are used in in mostly all of these lists now uh we have",
    "start": "2707040",
    "end": "2713280"
  },
  {
    "text": "pool index validation we have encoding of the process pointers which are associated with pool chunks and we also",
    "start": "2713280",
    "end": "2720559"
  },
  {
    "text": "have the NX non-page pool so despite of all these uh fixes uh",
    "start": "2720559",
    "end": "2728839"
  },
  {
    "text": "there's a major uh drawback uh still and",
    "start": "2728839",
    "end": "2734040"
  },
  {
    "start": "2733000",
    "end": "2733000"
  },
  {
    "text": "in that the pool header is not encoded in any way so you can still write into",
    "start": "2734040",
    "end": "2740319"
  },
  {
    "text": "the pool header and possibly fake values as long as uh validation succeeds right",
    "start": "2740319",
    "end": "2748040"
  },
  {
    "text": "uh and one one other thing here is that it can be really hard to properly validate some of these fields for",
    "start": "2748040",
    "end": "2754000"
  },
  {
    "text": "instance block size values so because the lack of dependencies in Block size values like the only way the allocator",
    "start": "2754000",
    "end": "2762040"
  },
  {
    "text": "can can determine whether a block size is of the actual size is by looking at",
    "start": "2762040",
    "end": "2767200"
  },
  {
    "text": "surrounding chunks and if those checks uh by of looking at surrounding chunks",
    "start": "2767200",
    "end": "2773280"
  },
  {
    "text": "are bypassed then it can potentially uh extend like a limited corruption into an",
    "start": "2773280",
    "end": "2781240"
  },
  {
    "text": "arbitrary uh inite corruption so to speak so there's two ways of doing this",
    "start": "2781240",
    "end": "2786559"
  },
  {
    "text": "uh it's what I call the block size attack and the split fragment attack so",
    "start": "2786559",
    "end": "2792720"
  },
  {
    "start": "2792000",
    "end": "2792000"
  },
  {
    "text": "like I said the block size and previous size are fields in the pool header that are used",
    "start": "2792720",
    "end": "2798119"
  },
  {
    "text": "to determine the size of of a chunk in a previous chunk and this is used by the",
    "start": "2798119",
    "end": "2803280"
  },
  {
    "text": "allocator for instance for putting it into the right freist uh for doing",
    "start": "2803280",
    "end": "2808319"
  },
  {
    "text": "merging of chunks in order to reduce fragmentation um and it's also used in",
    "start": "2808319",
    "end": "2813839"
  },
  {
    "text": "validating this P these pull chunks so when you freeze some something typically it will look at the Block size of the",
    "start": "2813839",
    "end": "2820480"
  },
  {
    "text": "chunk that you're freeing and use that to get the next chunk and check if that",
    "start": "2820480",
    "end": "2825760"
  },
  {
    "text": "chunk previous size corresponds to the block size of the chunk that you're Fring uh the exception to this rule is",
    "start": "2825760",
    "end": "2833400"
  },
  {
    "text": "when this next chunk is on the next page because it doesn't validate across Pages",
    "start": "2833400",
    "end": "2838800"
  },
  {
    "text": "because the previous size will be null uh there's no uh guarantee that the next",
    "start": "2838800",
    "end": "2844559"
  },
  {
    "text": "page is even mapped in so it doesn't have have an in checks on that so uh for the block size attack you",
    "start": "2844559",
    "end": "2853160"
  },
  {
    "text": "know when you when you free something it's put into a a Freel list or look",
    "start": "2853160",
    "end": "2858319"
  },
  {
    "text": "aide based on its block size so if an attacker overwrites uh the block size",
    "start": "2858319",
    "end": "2863800"
  },
  {
    "text": "you can basically put this block into an arbitrary freelist um and if you moreover set this",
    "start": "2863800",
    "end": "2870359"
  },
  {
    "text": "block size to cover or fill the rest of the page uh you completely avoid this",
    "start": "2870359",
    "end": "2875880"
  },
  {
    "text": "block size previous side check uh when this allocation is freed um so this is",
    "start": "2875880",
    "end": "2883280"
  },
  {
    "text": "kind of a simple uh illustration of how this attack Works uh you have an",
    "start": "2883280",
    "end": "2888800"
  },
  {
    "text": "allocated chunk that you you use in a vulnerability memory corruption",
    "start": "2888800",
    "end": "2894040"
  },
  {
    "text": "vulnerability and you overwrite say you have like a 4 byte or three by memory corruption so you overwrite the block",
    "start": "2894040",
    "end": "2900079"
  },
  {
    "text": "size of the next chunk and you set that size to cover the rest of the page obviously this requires you to know some",
    "start": "2900079",
    "end": "2908040"
  },
  {
    "text": "somewhat the locality of the the chunk that you're um attacking but uh still if",
    "start": "2908040",
    "end": "2915000"
  },
  {
    "text": "you if you spray same siiz allocations you will be able to you may be able to control this but it relies somewhat on",
    "start": "2915000",
    "end": "2922480"
  },
  {
    "text": "on on the on the circumstances around vulnerability uh so you set this chunk",
    "start": "2922480",
    "end": "2928119"
  },
  {
    "text": "to cover the rest of the page and then uh when that is freed you can reallocate",
    "start": "2928119",
    "end": "2933440"
  },
  {
    "text": "that memory uh like using a string and you can um compl completely control or",
    "start": "2933440",
    "end": "2940640"
  },
  {
    "text": "partly control the the memory of of the allocation that you're attacking uh so these are the basic",
    "start": "2940640",
    "end": "2947680"
  },
  {
    "start": "2945000",
    "end": "2945000"
  },
  {
    "text": "steps here uh you corrupt the block size uh you free the corrupted pool chunk U",
    "start": "2947680",
    "end": "2953640"
  },
  {
    "text": "make sure that it covers the rest of the page and reallocate that free memory like using a Unicode string or or",
    "start": "2953640",
    "end": "2959760"
  },
  {
    "text": "something that makes that allocation um the next part is about uh",
    "start": "2959760",
    "end": "2966040"
  },
  {
    "start": "2963000",
    "end": "2963000"
  },
  {
    "text": "split chunk pool allocations so I I think I mentioned this briefly but when",
    "start": "2966040",
    "end": "2971079"
  },
  {
    "text": "you allocate something it will scan these fre lists until it finds uh uh",
    "start": "2971079",
    "end": "2977520"
  },
  {
    "text": "something of a suitable size so it starts at the Block size that you request and if that list is empty it",
    "start": "2977520",
    "end": "2983920"
  },
  {
    "text": "will continue to the next block size etc etc and when you get a chunk it will",
    "start": "2983920",
    "end": "2989839"
  },
  {
    "text": "notice that it's larger than the one you requested so it will split the chunk and return the fragment back to to the",
    "start": "2989839",
    "end": "2997079"
  },
  {
    "text": "allocator and it uses the block size to do the splitting um there's a good",
    "start": "2997079",
    "end": "3002119"
  },
  {
    "text": "amount of Sandage checking in this case it checks all the F links and B Links of all the lists uh it even validates the",
    "start": "3002119",
    "end": "3009119"
  },
  {
    "text": "the pull index uh so you cannot you know pull any pull index attacks um but",
    "start": "3009119",
    "end": "3015079"
  },
  {
    "text": "there's no validation on the Block size so this basically enables an attacker to",
    "start": "3015079",
    "end": "3020960"
  },
  {
    "text": "extend a a semi-controlled 3 by um overflow into an arbitrary memory",
    "start": "3020960",
    "end": "3027440"
  },
  {
    "text": "corruption by by setting the block size to something larger than it actually is and by fooling the allocator to thinking",
    "start": "3027440",
    "end": "3034319"
  },
  {
    "text": "that oh I got I got an allocation here that is a u large much larger than an",
    "start": "3034319",
    "end": "3039559"
  },
  {
    "text": "actual needs I'm going to free this part of the chunk that is uh not in use that",
    "start": "3039559",
    "end": "3044760"
  },
  {
    "text": "it thinks it's it's not in use and back to the allocator so this can a basically enable",
    "start": "3044760",
    "end": "3051040"
  },
  {
    "text": "you to free and use memory um so in this case uh you can start you can have have",
    "start": "3051040",
    "end": "3057240"
  },
  {
    "text": "an A corruption at the end of a page which overflows uh into the next page",
    "start": "3057240",
    "end": "3063720"
  },
  {
    "text": "and you set it's uh this allocation being freed and you said its box size to be um you know double the value um and",
    "start": "3063720",
    "end": "3072079"
  },
  {
    "text": "when when you allocate this it will notice that um the block size is larger",
    "start": "3072079",
    "end": "3077119"
  },
  {
    "text": "than it needs so it will free this next piece of memory and then you can reallocate that memory to completely",
    "start": "3077119",
    "end": "3083799"
  },
  {
    "text": "control uh this next uh chunk on the",
    "start": "3083799",
    "end": "3089240"
  },
  {
    "text": "page uh so again here are the steps um you corrupt a free chunk you set it to",
    "start": "3089920",
    "end": "3096280"
  },
  {
    "start": "3090000",
    "end": "3090000"
  },
  {
    "text": "something larger um and you the allocator splits and and returns that fragment back into",
    "start": "3096280",
    "end": "3102559"
  },
  {
    "text": "the allocator OR to the free lists and then you reallocate that memory using uh again something predictable and",
    "start": "3102559",
    "end": "3109119"
  },
  {
    "text": "controllable like like Unicode string or something like associate a unic code string associated with an N object for",
    "start": "3109119",
    "end": "3115480"
  },
  {
    "text": "instance so um you know they're not like",
    "start": "3115480",
    "end": "3121319"
  },
  {
    "text": "groundbre breaking attacks but they're still might be useful in some situations",
    "start": "3121319",
    "end": "3126520"
  },
  {
    "text": "where you can extend something limited into uh something a bit more useful uh so to wrap up and conclude uh",
    "start": "3126520",
    "end": "3136720"
  },
  {
    "start": "3132000",
    "end": "3132000"
  },
  {
    "text": "unlike the Windows 8 Heap that Chris talked about uh the kernel pool is really deterministic uh because it's biased",
    "start": "3136720",
    "end": "3143760"
  },
  {
    "text": "towards efficient efficiency it needs performance well it uses Loos lists it",
    "start": "3143760",
    "end": "3149319"
  },
  {
    "text": "it it tries to use CPU cache as much as possible you know avoid cach misses and",
    "start": "3149319",
    "end": "3155599"
  },
  {
    "text": "uh it allows an attacker to very this allows an attacker to very accurately um you know make allocations from from uh",
    "start": "3155599",
    "end": "3164040"
  },
  {
    "text": "from where it wants to uh you know manipulate to heat manipulation or that sort of stuff uh and because it is it's",
    "start": "3164040",
    "end": "3171640"
  },
  {
    "text": "it's very likely that aack on pool content will be a likely Vector on on window eight uh even though the the the",
    "start": "3171640",
    "end": "3179520"
  },
  {
    "text": "metadata associated with pool chunks are are very hardened now uh pool content is",
    "start": "3179520",
    "end": "3185040"
  },
  {
    "text": "still a very uh feasible way of of attacking uh uh or or leveraging pool",
    "start": "3185040",
    "end": "3191119"
  },
  {
    "text": "corruption vulnerabilities um the block size attacks like I mentioned are rely very",
    "start": "3191119",
    "end": "3198319"
  },
  {
    "text": "much on pool determinism so if you reduce it you can really reduce the",
    "start": "3198319",
    "end": "3203880"
  },
  {
    "text": "feasibility of of this these types of ta um and it can also be addressed by",
    "start": "3203880",
    "end": "3209400"
  },
  {
    "text": "improving the validation so if you if you allocate something from a block from a free list um and you make sure that",
    "start": "3209400",
    "end": "3217400"
  },
  {
    "text": "the block size corresponds to the block size the list manages uh you can kill",
    "start": "3217400",
    "end": "3223200"
  },
  {
    "text": "off the um the split fragment attack um and additionally the block size attacks",
    "start": "3223200",
    "end": "3229640"
  },
  {
    "text": "also rely you to do very specific pool manipulation so in some situations like",
    "start": "3229640",
    "end": "3234839"
  },
  {
    "text": "if you having remote overflow something like that it can be impractical because you need to uh Force",
    "start": "3234839",
    "end": "3241079"
  },
  {
    "text": "these very specific allocations in order to to um pull off these attacks",
    "start": "3241079",
    "end": "3248520"
  },
  {
    "start": "3248000",
    "end": "3248000"
  },
  {
    "text": "basically um yeah so you know you saw Taro through his things as well and I",
    "start": "3248720",
    "end": "3254480"
  },
  {
    "text": "think it's pretty closely related to the user land um the Windows 7 exploitation",
    "start": "3254480",
    "end": "3260119"
  },
  {
    "text": "Tech uh is basically down the drain now uh it's pretty well remediated and and",
    "start": "3260119",
    "end": "3265240"
  },
  {
    "text": "it's going to be hard to use those techniques uh in the userland side determinism about uh the locality of",
    "start": "3265240",
    "end": "3271880"
  },
  {
    "text": "chunks whether in the low fragmentation Heap or say virtually allocated memory",
    "start": "3271880",
    "end": "3276960"
  },
  {
    "text": "is is not very useful or or good anymore um you know I don't ever want to say",
    "start": "3276960",
    "end": "3282960"
  },
  {
    "text": "heat metadata corruption attacks are dead because as long as there's metadata there to corrupt they will probably used",
    "start": "3282960",
    "end": "3289680"
  },
  {
    "text": "uh but you know most likely you're going to try to attack some kind of C++ object",
    "start": "3289680",
    "end": "3295280"
  },
  {
    "text": "or something else um but if you do have a very limited overflow where you don't control the contents there's things like",
    "start": "3295280",
    "end": "3301280"
  },
  {
    "text": "the heat user data header attack that could uh prove to be uh fruitful um you",
    "start": "3301280",
    "end": "3306680"
  },
  {
    "text": "know use after free bugs are going to be a bit harder but uh you know not not",
    "start": "3306680",
    "end": "3311720"
  },
  {
    "text": "impossible um Microsoft fixed a lot of things I think they paid a lot of attention and did a great job of fixing",
    "start": "3311720",
    "end": "3317640"
  },
  {
    "text": "all the stuff up that was publicly available and people were using to to write exploits",
    "start": "3317640",
    "end": "3324000"
  },
  {
    "start": "3323000",
    "end": "3323000"
  },
  {
    "text": "with um yeah so so you know all the attacks that were demonstrated on Windows 7 have been pretty much",
    "start": "3324680",
    "end": "3330880"
  },
  {
    "text": "addressed in Windows 8 uh you have the proper safe linking proper safe unlinking you have the randomization of",
    "start": "3330880",
    "end": "3337039"
  },
  {
    "text": "cookies uh to or the randomized cookies to protect pointers uh still the pool",
    "start": "3337039",
    "end": "3343000"
  },
  {
    "text": "header is not protected it's not encoded so you can still overflow into chunks uh",
    "start": "3343000",
    "end": "3348520"
  },
  {
    "text": "and totally you know bypass uh checks um and because of this there's no real need",
    "start": "3348520",
    "end": "3355400"
  },
  {
    "text": "to repair to pull structures etc etc uh some lookaside lists are still not",
    "start": "3355400",
    "end": "3360799"
  },
  {
    "text": "protected um the pool page lookaside list uh was not protected in the release",
    "start": "3360799",
    "end": "3366640"
  },
  {
    "text": "preview but I suspect it protected now but still there's uh these other look",
    "start": "3366640",
    "end": "3371960"
  },
  {
    "text": "aide lists that that Windows uses for specific things that still are not protected",
    "start": "3371960",
    "end": "3378280"
  },
  {
    "text": "so uh one last thing uh if you enjoyed any of this or want to get into it in further detail uh tar and I uh worked",
    "start": "3378280",
    "end": "3385920"
  },
  {
    "text": "pretty on releasing a paper that is going to be released with the slides as well so you should check it out yeah",
    "start": "3385920",
    "end": "3392160"
  },
  {
    "text": "question questions comments Jers",
    "start": "3392160",
    "end": "3398400"
  },
  {
    "text": "cheers question what's up",
    "start": "3398400",
    "end": "3407079"
  },
  {
    "text": "uhhuh to so you won't know what's uh you can't guarantee what's an adjacent",
    "start": "3423359",
    "end": "3428400"
  },
  {
    "text": "memory right you can't say I guarantee it's going to be allocated at slot one and I know in slot two there's this",
    "start": "3428400",
    "end": "3433680"
  },
  {
    "text": "object I want to overwrite",
    "start": "3433680",
    "end": "3437200"
  },
  {
    "text": "you yeah I mean you can you can probably put it in a state where you're confident about the number of allocations and",
    "start": "3443039",
    "end": "3449599"
  },
  {
    "text": "potential offsets that are there but you'll never really 100% know",
    "start": "3449599",
    "end": "3455160"
  },
  {
    "text": "anymore sweet thanks awesome yeah let's go let's go",
    "start": "3455160",
    "end": "3464599"
  },
  {
    "text": "Dre good job",
    "start": "3468880",
    "end": "3472720"
  }
]