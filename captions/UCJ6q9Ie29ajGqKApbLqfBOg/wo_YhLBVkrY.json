[
  {
    "start": "0",
    "end": "187000"
  },
  {
    "text": "[Music]",
    "start": "3580",
    "end": "15280"
  },
  {
    "text": "hi everyone welcome to our talk about hacking the supply chain the ripple 20 vulnerabilities that",
    "start": "15280",
    "end": "21279"
  },
  {
    "text": "hundreds of millions of devices what about who we are joseph is a software security",
    "start": "21279",
    "end": "27199"
  },
  {
    "text": "consultancy we do security research penetration testing uh consulting on secure development as",
    "start": "27199",
    "end": "33520"
  },
  {
    "text": "well as some training my name is shlomi obermann i'm a co-founder at jsof together with me we'll be speaking moshe",
    "start": "33520",
    "end": "39760"
  },
  {
    "text": "cole a security researcher at jasof and the founder of the ripple 20 vulnerabilities and",
    "start": "39760",
    "end": "45200"
  },
  {
    "text": "ariel shawn a security researcher at jasof also heavily involved in the research",
    "start": "45200",
    "end": "50879"
  },
  {
    "text": "today we'll be talking about what ripple 20 is and then diving in detail into one of the vulnerabilities",
    "start": "50879",
    "end": "57120"
  },
  {
    "text": "cve 2020 11901 after that we'll be showing some of the",
    "start": "57120",
    "end": "62640"
  },
  {
    "text": "details about exploitation of cve 2020 11901 and a demo of exploitation on a vulnerable",
    "start": "62640",
    "end": "70000"
  },
  {
    "text": "device so ripple 20 ripple 20 is a series of 19 zero-day vulnerabilities in a tcpatc ip",
    "start": "70000",
    "end": "77920"
  },
  {
    "text": "stack called trek tcpip 19 vulnerabilities give or take two of",
    "start": "77920",
    "end": "84000"
  },
  {
    "text": "these vulnerabilities were actually reported anonymously at the same time as we reported and actually resulted in 24",
    "start": "84000",
    "end": "90960"
  },
  {
    "text": "patches altogether so depends how you count these vulnerabilities were amplified by the",
    "start": "90960",
    "end": "96000"
  },
  {
    "text": "supply chain something that we'll be talking about and showing to affect hundreds of millions of devices",
    "start": "96000",
    "end": "101600"
  },
  {
    "text": "across a wide range of verticals uh pretty much any type of iot device you can think",
    "start": "101600",
    "end": "106720"
  },
  {
    "text": "about out of these vulnerabilities four of the vulnerabilities are critical remote code execution vulnerabilities",
    "start": "106720",
    "end": "113200"
  },
  {
    "text": "this is not necessarily according to the cvss but according to our assessment of the vulnerabilities",
    "start": "113200",
    "end": "119280"
  },
  {
    "text": "but four of them are also critical cvss eight of the vulnerabilities are medium",
    "start": "119280",
    "end": "124560"
  },
  {
    "text": "to high severity vulnerabilities with some chance of remote code execution and other effects",
    "start": "124560",
    "end": "130720"
  },
  {
    "text": "the uh devices affected are made by vendors you all know large vendors uh",
    "start": "130720",
    "end": "137520"
  },
  {
    "text": "devices of high impact as well as smaller smaller vendors vendors really range from all types of",
    "start": "137520",
    "end": "145200"
  },
  {
    "text": "iot devices and from fortune 500 companies to one-person shops tiny little",
    "start": "145200",
    "end": "150720"
  },
  {
    "text": "companies making embedded specialist devices the types of devices you can encounter in your hospital at home on your network",
    "start": "150720",
    "end": "158879"
  },
  {
    "text": "power water cellular utilities things you use in your everyday life transportation pretty much anything we",
    "start": "158879",
    "end": "165920"
  },
  {
    "text": "do is powered by devices affected by ripple 20 vulnerabilities at this stage knowing what we know about",
    "start": "165920",
    "end": "171840"
  },
  {
    "text": "affected devices and effective vulnerabilities we're assuming every mid to large organization in the u.s has at least one",
    "start": "171840",
    "end": "179040"
  },
  {
    "text": "vulnerable device whether it be a networking device a printing device",
    "start": "179040",
    "end": "184480"
  },
  {
    "text": "ics device uh etc why did this happen so it all has to do with the supply",
    "start": "184480",
    "end": "190959"
  },
  {
    "start": "187000",
    "end": "187000"
  },
  {
    "text": "chain somebody takes a piece of source code a library and embeds it into a larger component say an",
    "start": "190959",
    "end": "197760"
  },
  {
    "text": "operating system this component then gets embedded further in a system-on-module or a",
    "start": "197760",
    "end": "202879"
  },
  {
    "text": "larger component which then once again gets embedded into a larger component and so on and so forth until we reach",
    "start": "202879",
    "end": "208959"
  },
  {
    "text": "our final product at the certain moment in the supply chain nobody knows they're using the",
    "start": "208959",
    "end": "214799"
  },
  {
    "text": "original library there nobody knows they're using this original source code just imagine what happens if one of the",
    "start": "214799",
    "end": "221040"
  },
  {
    "text": "components along the way one of the companies along the way goes",
    "start": "221040",
    "end": "226080"
  },
  {
    "text": "bankrupt or cc's operation how difficult it is to fix these uh vulnerabilities",
    "start": "226080",
    "end": "231760"
  },
  {
    "text": "and so with this supply chain we have a network of devices that embed different components",
    "start": "231760",
    "end": "236959"
  },
  {
    "text": "beginning at a single library a single piece of source code and if a vulnerability exists in a",
    "start": "236959",
    "end": "244239"
  },
  {
    "text": "certain library at the beginning of the supply chain this vulnerability infects the other",
    "start": "244239",
    "end": "249439"
  },
  {
    "text": "parts of the network kind of like a plague and the vulnerability travels from one device to the other device reaching all",
    "start": "249439",
    "end": "256560"
  },
  {
    "text": "kinds of different areas in the supply chain reaching different types of devices",
    "start": "256560",
    "end": "261840"
  },
  {
    "text": "this is what happened with ripple 20 a vulnerability deep in the supply chain that affected other devices affected",
    "start": "261840",
    "end": "268400"
  },
  {
    "text": "more and more devices as the piece of code traveled",
    "start": "268400",
    "end": "273759"
  },
  {
    "start": "272000",
    "end": "272000"
  },
  {
    "text": "um why we chose track tcp and why we think this uh this research is interesting for the",
    "start": "273759",
    "end": "280479"
  },
  {
    "text": "community and for the listeners well the first issue is the issue of supply chain not in the sense that",
    "start": "280479",
    "end": "286240"
  },
  {
    "text": "somebody put a backdoor in your supply chain in the sense that one vulnerability",
    "start": "286240",
    "end": "291280"
  },
  {
    "text": "in a single piece of code travels across the supply chain so one vulnerability multiple products multiple products a few dozen",
    "start": "291280",
    "end": "298560"
  },
  {
    "text": "different vendors few hundreds of different types of products extremely large iot",
    "start": "298560",
    "end": "303759"
  },
  {
    "text": "uh impact and the potential for zombie vulnerabilities zombie vulnerabilities these vulnerabilities we're not exactly",
    "start": "303759",
    "end": "310320"
  },
  {
    "text": "sure whether to call them one days or zero days because we've already reported them but",
    "start": "310320",
    "end": "316000"
  },
  {
    "text": "probably not going to be fixed in some of these devices where the company went bankrupt chose not to fix",
    "start": "316000",
    "end": "322000"
  },
  {
    "text": "the supply chain is too complex to follow etc and of course a good attack surface tcp",
    "start": "322000",
    "end": "328320"
  },
  {
    "text": "mostly unauthenticated a lot of parsing pretty old code um the perfect",
    "start": "328320",
    "end": "334639"
  },
  {
    "text": "attack candidate a little bit about the concrete specific tcp stack that we",
    "start": "334639",
    "end": "341199"
  },
  {
    "text": "chose uh track tcpip a pretty successful tcp stack one of the leading tcp stacks",
    "start": "341199",
    "end": "349199"
  },
  {
    "text": "at least for a while trek is a small american company that makes tcpac stack a fully",
    "start": "349199",
    "end": "356960"
  },
  {
    "text": "featured tcp stack all the way going all the way from the link layer to application layer protocols",
    "start": "356960",
    "end": "364319"
  },
  {
    "text": "complete with all the rfcs needed to be implemented and has been available for over 20 years",
    "start": "364319",
    "end": "370240"
  },
  {
    "text": "no usually used in embedded devices and real-time operating systems and very importantly for our research",
    "start": "370240",
    "end": "376560"
  },
  {
    "text": "very very configurable so each instance of the trek stack each device implementing the trek stack has a",
    "start": "376560",
    "end": "382240"
  },
  {
    "text": "slightly different version of trek and this affected a lot of the vulnerabilities and a lot of the way we",
    "start": "382240",
    "end": "387840"
  },
  {
    "text": "did our research this happens because different vendors compile the trek stack differently and because they use different versions",
    "start": "387840",
    "end": "393600"
  },
  {
    "text": "of trek and then sometimes stop support and most importantly it's strategically located at the very",
    "start": "393600",
    "end": "400639"
  },
  {
    "text": "beginning of an extremely long supply chain so in some cases we've seen companies",
    "start": "400639",
    "end": "405680"
  },
  {
    "text": "that are second hand third hand forward forward-hand fourth-hand users of trek and had no idea they were using this piece of code",
    "start": "405680",
    "end": "412960"
  },
  {
    "start": "411000",
    "end": "411000"
  },
  {
    "text": "um a little bit about how we conducted our research so because every piece of uh",
    "start": "412960",
    "end": "419039"
  },
  {
    "text": "trek tcp stack is different every instance is different we took six data points six different",
    "start": "419039",
    "end": "424560"
  },
  {
    "text": "devices and reverse engineered them in multiple versions we didn't spend as much effort on every one of the devices",
    "start": "424560",
    "end": "431280"
  },
  {
    "text": "the same amount of effort on all the devices but we used these in order to understand the um the",
    "start": "431280",
    "end": "437759"
  },
  {
    "text": "situation better understand how the vulnerabilities change over time every one of our devices had different",
    "start": "437759",
    "end": "443120"
  },
  {
    "text": "configuration a different version the research took approximately nine one months with different levels of",
    "start": "443120",
    "end": "449120"
  },
  {
    "text": "intensity starting september 19th ending uh sometime around june 20th with the public disclosure",
    "start": "449120",
    "end": "457280"
  },
  {
    "text": "and the research involved a few strange architectures a few strange frameworks we'll be talking about one of them today",
    "start": "457280",
    "end": "464879"
  },
  {
    "text": "unfortunately we can't go into all the details today we only have 35 minutes but we did release two white papers",
    "start": "464879",
    "end": "471280"
  },
  {
    "text": "detailing uh full technical details uh of several of the vulnerabilities as well as",
    "start": "471280",
    "end": "476879"
  },
  {
    "text": "exploitation uh you're welcome to to look them up on our um on our website today we're going to",
    "start": "476879",
    "end": "482319"
  },
  {
    "start": "481000",
    "end": "481000"
  },
  {
    "text": "be talking mostly about a single cve which is the cve we find most interesting",
    "start": "482319",
    "end": "487680"
  },
  {
    "text": "and perhaps the most critical of the ripple 20 vulnerabilities",
    "start": "487680",
    "end": "493280"
  },
  {
    "text": "it's a vulnerability a client side vulnerability and trek's dns resolver component",
    "start": "493280",
    "end": "498639"
  },
  {
    "text": "it can result in remote code execution and we've demonstrated this and the interesting thing about it is",
    "start": "498639",
    "end": "503759"
  },
  {
    "text": "that because dns will travel from inside your corporate network to the internet a sophisticated attacker",
    "start": "503759",
    "end": "509520"
  },
  {
    "text": "can potentially use this to attack a device from outside network boundaries",
    "start": "509520",
    "end": "514959"
  },
  {
    "text": "another interesting thing is because the trek tcpip stack is so configurable this one cv actually hides four",
    "start": "514959",
    "end": "521599"
  },
  {
    "text": "vulnerabilities and one what we're calling an artifact a bug that makes it easier for us to exploit",
    "start": "521599",
    "end": "528480"
  },
  {
    "text": "different versions of the track different vendors have different versions of the vulnerabilities",
    "start": "528480",
    "end": "534000"
  },
  {
    "text": "all of them have a remote code execution in this case but just an example of how complex this really is today we'll be talking",
    "start": "534000",
    "end": "540959"
  },
  {
    "text": "about three of these vulnerabilities and the artifact now i'm going to hand over the",
    "start": "540959",
    "end": "546240"
  },
  {
    "text": "microphone to moche call who is going to be discussing the vulnerabilities in detail",
    "start": "546240",
    "end": "552800"
  },
  {
    "text": "hi i'm moshe security researcher at jasof and i will be talking about three of the vulnerabilities that",
    "start": "552800",
    "end": "558160"
  },
  {
    "text": "comprise cv2020 11901 also known as the dns box so",
    "start": "558160",
    "end": "564160"
  },
  {
    "start": "563000",
    "end": "563000"
  },
  {
    "text": "as long we said the vulnerability is found in the dns resolver component of track tcp and we need to refresh our",
    "start": "564160",
    "end": "570720"
  },
  {
    "text": "memory about the basics of the dns protocol so dns",
    "start": "570720",
    "end": "576880"
  },
  {
    "text": "is a core internet protocol designed to map between domain names and ip addresses it's a query response protocol client",
    "start": "576880",
    "end": "583760"
  },
  {
    "text": "server architecture so the client resolves the name by issuing a query to a dns server",
    "start": "583760",
    "end": "589440"
  },
  {
    "text": "so if for example you browse to www.exemple.com your browser issues a dns query of type",
    "start": "589440",
    "end": "596800"
  },
  {
    "text": "a to one of the configured dns servers and the dns server look up the name and returns a response",
    "start": "596800",
    "end": "604000"
  },
  {
    "text": "each response has a value for type a the value is an ipv for others",
    "start": "604000",
    "end": "610959"
  },
  {
    "start": "609000",
    "end": "609000"
  },
  {
    "text": "dns servers can return multiple answers in the same dns response and an answer is specified as a resource",
    "start": "610959",
    "end": "617760"
  },
  {
    "text": "record which consists of the following fields according to to the rfc",
    "start": "617760",
    "end": "622880"
  },
  {
    "text": "and the name specifies uh specifies the the name to which the cycle differs each",
    "start": "622880",
    "end": "629519"
  },
  {
    "text": "records have a type we talk about the the type shortly a class field within in practice is",
    "start": "629519",
    "end": "634880"
  },
  {
    "text": "always constant a ttl field which specifies the number of seconds this record is valid and the value is",
    "start": "634880",
    "end": "642000"
  },
  {
    "text": "specified in the r data field whose length is specified in the audi length field",
    "start": "642000",
    "end": "647360"
  },
  {
    "text": "so both questions and answers have a type some of the common type includes type a",
    "start": "647360",
    "end": "654720"
  },
  {
    "text": "which we saw before specifies an ipv4 address for the query domain type c name which defines an alias a",
    "start": "654720",
    "end": "662079"
  },
  {
    "text": "canonical name for the query domain and the type mx that specifies a domain name of a mail",
    "start": "662079",
    "end": "668560"
  },
  {
    "text": "server for the query domain so if you send an email to gmail.com your mail client issues a dns",
    "start": "668560",
    "end": "676000"
  },
  {
    "text": "query of type amix and get back a domain name of a mail server for gmail.com and because this is a name",
    "start": "676000",
    "end": "683360"
  },
  {
    "text": "this name need to be resolved in into an ip address so a second dns query of type a",
    "start": "683360",
    "end": "689200"
  },
  {
    "text": "in this case is generated by the client in practice most dns servers simply hand in",
    "start": "689200",
    "end": "694880"
  },
  {
    "text": "type a records in the first dns response to reduce latency but nonetheless this",
    "start": "694880",
    "end": "700839"
  },
  {
    "text": "functionality should be supported by dns resolvers so a little bit about domain names",
    "start": "700839",
    "end": "707360"
  },
  {
    "start": "705000",
    "end": "705000"
  },
  {
    "text": "encoding so domain names are encoded as a sequence of labels so www is a label example is a label",
    "start": "707360",
    "end": "715440"
  },
  {
    "text": "each label is preceded by length byte which specifies the number of characters",
    "start": "715440",
    "end": "721839"
  },
  {
    "text": "this label occupies and the name is terminated with the zero length byte",
    "start": "721839",
    "end": "727040"
  },
  {
    "text": "and according to the rfc the maximum label length is 63 this will come up later",
    "start": "727040",
    "end": "733839"
  },
  {
    "start": "732000",
    "end": "732000"
  },
  {
    "text": "so what the designers of the dns protocol notice is that there is a lot of repetition in a single",
    "start": "733920",
    "end": "739839"
  },
  {
    "text": "dns packet so to reduce the size of the dns",
    "start": "739839",
    "end": "745200"
  },
  {
    "text": "messages they simply employ a compression scheme in this scheme",
    "start": "745200",
    "end": "750959"
  },
  {
    "text": "cooperation is achieved by replacing a sequence of labels with a pointer to prior occurrence of the same sequence",
    "start": "750959",
    "end": "757519"
  },
  {
    "text": "so you can see a sample dns response packet or for of type mx",
    "start": "757519",
    "end": "763680"
  },
  {
    "text": "for gmail.com you can see gmail.com is specified literally in the packet in offset hex c from the start and it so",
    "start": "763680",
    "end": "771600"
  },
  {
    "text": "happens that gmat.com need to be specified additional times in the packet so instead of specifying gmail.com",
    "start": "771600",
    "end": "778399"
  },
  {
    "text": "literally we we will use the the compression scheme",
    "start": "778399",
    "end": "783839"
  },
  {
    "text": "we'll replace it with the pointer to to the offset from the start of the header with",
    "start": "783839",
    "end": "788880"
  },
  {
    "text": "where it it is written so if you want to to write smtp.gmail.com we only need to write",
    "start": "788880",
    "end": "795120"
  },
  {
    "text": "smtp the first label literally and the next two labels are specified using the compression pointer",
    "start": "795120",
    "end": "801839"
  },
  {
    "text": "so in this scheme compression pointers are encoded in two bytes the first byte begins with one one as",
    "start": "801839",
    "end": "808240"
  },
  {
    "text": "most significant bits and the other 14 bits specify an offset from the start of the header so we found",
    "start": "808240",
    "end": "817040"
  },
  {
    "start": "815000",
    "end": "815000"
  },
  {
    "text": "the three vulnerabilities in the dns pulsing logic of track tcpap specifically in the function",
    "start": "817040",
    "end": "823519"
  },
  {
    "text": "tf dns callbacks with which is responsible for the parsing and here you can see a pseudo code of",
    "start": "823519",
    "end": "830079"
  },
  {
    "text": "this function responsible for pulsing mx resource records",
    "start": "830079",
    "end": "835360"
  },
  {
    "text": "so we can see that the length of the hammock source name is calculated by the function expand label length",
    "start": "835360",
    "end": "842000"
  },
  {
    "text": "based on that length a buffer is allocated on the heap and then a label to ascii",
    "start": "842000",
    "end": "848399"
  },
  {
    "text": "copies the mxos name as ascii to the previously allocated buffer pointed to by ascii ptr and the snippet",
    "start": "848399",
    "end": "856240"
  },
  {
    "text": "and what we can see is that labor task is not aware of the length of the allocated buffer",
    "start": "856240",
    "end": "861360"
  },
  {
    "text": "this means that if for some reason expand label lengths return a length value which is too small then",
    "start": "861360",
    "end": "869199"
  },
  {
    "text": "labor to ascii will overflow the buffer because it simply copies the bytes until a null byte is reached so",
    "start": "869199",
    "end": "876800"
  },
  {
    "text": "this motivates us to look further into expand level length",
    "start": "876800",
    "end": "882560"
  },
  {
    "start": "882000",
    "end": "882000"
  },
  {
    "text": "so this is a pseudocode for expandable lengths what this function is basically doing is sums up all the length byte",
    "start": "882560",
    "end": "888800"
  },
  {
    "text": "while honoring compression so in more details it reads the current label length it then checks to see if there is",
    "start": "888800",
    "end": "895040"
  },
  {
    "text": "compression or not if there is no compression which is the common case uh",
    "start": "895040",
    "end": "900560"
  },
  {
    "text": "it adds the current label length plus one to the total length variable which is later returned",
    "start": "900560",
    "end": "906160"
  },
  {
    "text": "from this function uh and advanced the inputted if there is compression it reads the",
    "start": "906160",
    "end": "912160"
  },
  {
    "text": "compression offset computes a new label pointer based on that offset and then checks to see that the new",
    "start": "912160",
    "end": "919440"
  },
  {
    "text": "level ptl points before the initial label pointer this means we can only jump backwards",
    "start": "919440",
    "end": "926000"
  },
  {
    "text": "and we cannot jump forward this will come up later and the length calculation continues from the",
    "start": "926000",
    "end": "932959"
  },
  {
    "text": "new label point so as you can see expand label length is not aware of the",
    "start": "932959",
    "end": "940560"
  },
  {
    "text": "bounds of the packet buffer this led us to the first vulnerability a readout of bound vulnerability",
    "start": "940560",
    "end": "946639"
  },
  {
    "start": "942000",
    "end": "942000"
  },
  {
    "text": "so this vulnerability could result in a deny of service if for example while",
    "start": "946639",
    "end": "952399"
  },
  {
    "text": "iterating over the length bytes we read from an unmapped page but more",
    "start": "952399",
    "end": "957839"
  },
  {
    "text": "interestingly it can lead to an info leak so",
    "start": "957839",
    "end": "962959"
  },
  {
    "text": "tf dns label to ascii the function that does the copying has no bond checks either",
    "start": "962959",
    "end": "968000"
  },
  {
    "text": "this means that data from the heap could be interpreted as dynamic source name this semi source",
    "start": "968000",
    "end": "973519"
  },
  {
    "text": "name is later resolved by the client in an attempt to get an ip address uh so this means the data is leaked",
    "start": "973519",
    "end": "980399"
  },
  {
    "text": "inside the mxos name itself so this vulnerability affects track",
    "start": "980399",
    "end": "985600"
  },
  {
    "text": "version at least 4.7 it was fixed in later versions as we we see we don't know the exact",
    "start": "985600",
    "end": "992560"
  },
  {
    "text": "date they fixed the vulnerability but nonetheless the vulnerability is still",
    "start": "992560",
    "end": "998240"
  },
  {
    "text": "found in the wild due to the complex supply chain effect so some vendors don't receive support",
    "start": "998240",
    "end": "1003920"
  },
  {
    "text": "from track or don't apply patches um and some devices don't even have the means to have them",
    "start": "1003920",
    "end": "1010720"
  },
  {
    "text": "themselves so still something to worry about and this is nice and all but we are looking",
    "start": "1010720",
    "end": "1017040"
  },
  {
    "text": "for an lc so let's go back to the function that calculates the length and examine its operation there are more",
    "start": "1017040",
    "end": "1023759"
  },
  {
    "text": "issues with it so there is a limitation on the maximum on the the length of the domain name and the",
    "start": "1023759",
    "end": "1031038"
  },
  {
    "text": "limitation according to the lfc is 255 characters and this limitation is not enforced um",
    "start": "1031039",
    "end": "1038240"
  },
  {
    "text": "expandable links further does not validate that the characters of the domain name",
    "start": "1038240",
    "end": "1045199"
  },
  {
    "text": "they should be alphanumeric and iphone only but it doesn't validate the characters",
    "start": "1045199",
    "end": "1051440"
  },
  {
    "text": "and most importantly the total length variables is stored as an unsight shot",
    "start": "1051440",
    "end": "1056720"
  },
  {
    "text": "16 bit width and this is also the return value of explained label length",
    "start": "1056720",
    "end": "1062400"
  },
  {
    "text": "so we will try to get rce by overflowing the total length variable",
    "start": "1062400",
    "end": "1067919"
  },
  {
    "start": "1067000",
    "end": "1067000"
  },
  {
    "text": "so in order to pull this thing off we we need to construct a name whose length is larger than 64k",
    "start": "1067919",
    "end": "1074640"
  },
  {
    "text": "and we wonder is it really possible can we we do this can we overflow the total",
    "start": "1074640",
    "end": "1079679"
  },
  {
    "text": "rank variable within a single dns response bucket and the answer is yes we use the dns compression feature",
    "start": "1079679",
    "end": "1086400"
  },
  {
    "text": "to achieve this the idea was to nest compression pointers within themselves",
    "start": "1086400",
    "end": "1091919"
  },
  {
    "text": "so recall that expand the balance does not validate the characters of the domain name this means we can embed",
    "start": "1091919",
    "end": "1099600"
  },
  {
    "text": "inside the name itself any bytes we want and in this case we chose compression pointers as we will see in the example shortly",
    "start": "1099600",
    "end": "1107600"
  },
  {
    "text": "keep in mind during the example that we have two challenges to overcome uh first the there is a limitation on",
    "start": "1107600",
    "end": "1113760"
  },
  {
    "text": "the on the size of the dns response packet the maximum size allowed is",
    "start": "1113760",
    "end": "1119240"
  },
  {
    "text": "1460 bytes over udp and keep in mind that we can only jump",
    "start": "1119240",
    "end": "1124640"
  },
  {
    "text": "backwards from our current level pointer so we need to overcome this challenge also",
    "start": "1124640",
    "end": "1130640"
  },
  {
    "text": "so what you see in front of you is the basic construction we used in order to overflow the total length",
    "start": "1130640",
    "end": "1136960"
  },
  {
    "text": "variable you can see a name arranging the metrics like form each row in the matrix has length 16",
    "start": "1136960",
    "end": "1144480"
  },
  {
    "text": "bluish cells represent compression pointers and pink cells represent branch byte talk about those",
    "start": "1144480",
    "end": "1151120"
  },
  {
    "text": "shortly so let's assume that we start expanding the name from this spot that is",
    "start": "1151120",
    "end": "1158400"
  },
  {
    "text": "calculating the length we can actually achieve this in practice by using another compression pointer that will",
    "start": "1158400",
    "end": "1164240"
  },
  {
    "text": "lend us exactly in that spot but for now take it as a given so if we start expanding the",
    "start": "1164240",
    "end": "1170559"
  },
  {
    "text": "the length from this byte uh what expandable length does it checks to see if there is compression or not",
    "start": "1170559",
    "end": "1176880"
  },
  {
    "text": "there is no compression in this case so we simply add zero f plus one bytes to the total",
    "start": "1176880",
    "end": "1184160"
  },
  {
    "text": "length variable and skip zero f plus one because the metric is arranging this",
    "start": "1184160",
    "end": "1189840"
  },
  {
    "text": "special matrix form we simply move to the next row and stay in the same column",
    "start": "1189840",
    "end": "1195280"
  },
  {
    "text": "so the process repeats until we reach a branch byte for this value of th the purpose of the",
    "start": "1195280",
    "end": "1201039"
  },
  {
    "text": "branch byte is to lead us to the next compression pointer for this value of the branch of the branch but we we will end at this",
    "start": "1201039",
    "end": "1207679"
  },
  {
    "text": "compression pointer uh we can tell that it is compression pointer because the high nibble of the",
    "start": "1207679",
    "end": "1212720"
  },
  {
    "text": "first byte is c and at this point we read the compression offset in this case it's",
    "start": "1212720",
    "end": "1218320"
  },
  {
    "text": "zero e which uh points before our initial level pointer our initial offset that",
    "start": "1218320",
    "end": "1224720"
  },
  {
    "text": "was zero f so we passed the the check that we can only jump backward and we continue expanding uh from this",
    "start": "1224720",
    "end": "1231440"
  },
  {
    "text": "part the process continues we will reach a branch by it will end in another compression pointer and you can",
    "start": "1231440",
    "end": "1238000"
  },
  {
    "text": "see that the total length value nearly doubles itself after we did this compression trick",
    "start": "1238000",
    "end": "1244080"
  },
  {
    "text": "so we simply dude continue expanding the the name",
    "start": "1244080",
    "end": "1249520"
  },
  {
    "text": "until the an albert is reached you can see that the total length value uh in this example turns out to be 1502",
    "start": "1249520",
    "end": "1258799"
  },
  {
    "text": "bytes which is pretty neat if you consider the fact that the name only occupies 128 bytes",
    "start": "1258799",
    "end": "1265120"
  },
  {
    "text": "so this of course doesn't overflow the total length variable yet but when we use the maximum label length",
    "start": "1265120",
    "end": "1271120"
  },
  {
    "text": "allowed of x3f instead of xf shown in the example",
    "start": "1271120",
    "end": "1276720"
  },
  {
    "text": "we reached using this construction a name whose length is greater than 64k thus",
    "start": "1276720",
    "end": "1284000"
  },
  {
    "text": "overflowing the total length variable and recall that if expandable length returns a value which",
    "start": "1284000",
    "end": "1290799"
  },
  {
    "text": "which is too small than the actual value we have in any base buffer overflow so this is a",
    "start": "1290799",
    "end": "1298480"
  },
  {
    "text": "good rca candidate and it's important to know that this vulnerability can be triggered",
    "start": "1298480",
    "end": "1304000"
  },
  {
    "text": "in response to every query type supported by the network stack by using cname resource records which",
    "start": "1304000",
    "end": "1310720"
  },
  {
    "text": "must be passed in every dns response and this vulnerability affects the",
    "start": "1310720",
    "end": "1316640"
  },
  {
    "text": "latest track version at the time of disclosure so we were pretty happy about it at this",
    "start": "1316640",
    "end": "1323200"
  },
  {
    "text": "stage and we purchased a new device schneiderlin qps device at this point",
    "start": "1323200",
    "end": "1329440"
  },
  {
    "text": "and we wanted to to know if the vulnerabilities uh affect this ups",
    "start": "1329440",
    "end": "1336559"
  },
  {
    "text": "device and what we saw is the track fixes the readout of the band vulnerability which",
    "start": "1336559",
    "end": "1342320"
  },
  {
    "start": "1341000",
    "end": "1341000"
  },
  {
    "text": "means the ups device has a slightly newer version of track than the one we examined",
    "start": "1342320",
    "end": "1348159"
  },
  {
    "text": "you can see that the audi length value is checked against the remaining size of the packet",
    "start": "1348159",
    "end": "1354880"
  },
  {
    "text": "and now expand level lengths accept a third argument label nptr which is calculated based on",
    "start": "1354880",
    "end": "1362400"
  },
  {
    "text": "the rdl x value so what expandable length does when it reaches label nptel",
    "start": "1362400",
    "end": "1368720"
  },
  {
    "text": "it simply stops processing without any error and returns the current total length this is perfect from an",
    "start": "1368720",
    "end": "1374960"
  },
  {
    "text": "attacker's standpoint because audi length is attacker controlled so if we can specify a value which is",
    "start": "1374960",
    "end": "1381200"
  },
  {
    "start": "1376000",
    "end": "1376000"
  },
  {
    "text": "smaller than the actual audix value there is a chance that expanded balance",
    "start": "1381200",
    "end": "1387200"
  },
  {
    "text": "returns a value which is too small so here for example you can see",
    "start": "1387200",
    "end": "1392320"
  },
  {
    "text": "a resource record uh so instead of specifying 20 as the audience we specify",
    "start": "1392320",
    "end": "1398240"
  },
  {
    "text": "seven and level and ptr will points here in this case but expand level length returns five and",
    "start": "1398240",
    "end": "1405520"
  },
  {
    "text": "tf dns label to ask you will copy the entire name exhaust name thus overflowing our buffer so another",
    "start": "1405520",
    "end": "1412080"
  },
  {
    "text": "artifact we found during our research is that we can link another infrastructure",
    "start": "1412080",
    "end": "1418640"
  },
  {
    "start": "1413000",
    "end": "1413000"
  },
  {
    "text": "uh during the mx parsing logic so you can see here when other infrastructure is allocated",
    "start": "1418640",
    "end": "1424880"
  },
  {
    "text": "and in these two error flows it is not freed so this means we have two ways to to",
    "start": "1424880",
    "end": "1430640"
  },
  {
    "text": "leak another infrastructure first by specifying an audi length value which is smaller than two",
    "start": "1430640",
    "end": "1436559"
  },
  {
    "text": "like one or by causing expandable lengths to return a length of zero",
    "start": "1436559",
    "end": "1441919"
  },
  {
    "text": "and we can do this by using a bad compression pointer for example so the size of the leak is hex 3c and",
    "start": "1441919",
    "end": "1448880"
  },
  {
    "text": "this leaks come in handy when exploiting heavy vulnerabilities and in fact we use the exact same memory",
    "start": "1448880",
    "end": "1455120"
  },
  {
    "text": "leak in our exploit as you will see later so to summarize uh cv 2020 11901 is comprised of four",
    "start": "1455120",
    "end": "1463919"
  },
  {
    "start": "1460000",
    "end": "1460000"
  },
  {
    "text": "vulnerabilities we talk about three of them and one artifact so the first vulnerability readout of",
    "start": "1463919",
    "end": "1469120"
  },
  {
    "text": "band vulnerability affects older versions of the stack but was fixed in later versions as we saw the integer over",
    "start": "1469120",
    "end": "1475600"
  },
  {
    "text": "flow vulnerability and affects both old and newer versions of the stack the bad arduino's vulnerability is a",
    "start": "1475600",
    "end": "1482159"
  },
  {
    "text": "result from a bad fix for the results of band vulnerability so it affects only newer versions of the",
    "start": "1482159",
    "end": "1488799"
  },
  {
    "text": "stack and the artifact is present in a bottle and your version of the stack so the main takeaway from this",
    "start": "1488799",
    "end": "1495039"
  },
  {
    "text": "part is that a device can be affected by one or more vulnerabilities depending on the exact version of track they use",
    "start": "1495039",
    "end": "1501520"
  },
  {
    "text": "and this fragmentation causes it security personnel",
    "start": "1501520",
    "end": "1506880"
  },
  {
    "text": "this fragmentation makes the life of the i.t security personnel more challenging to know whether their devices are",
    "start": "1506880",
    "end": "1512880"
  },
  {
    "text": "affected or not so now i'll hand over the mic to ariel shawn he will talk about exploitation",
    "start": "1512880",
    "end": "1520000"
  },
  {
    "text": "thanks moshe hi i'm ariel i'm also a security researcher at jsof and today i'm going to talk about",
    "start": "1520000",
    "end": "1526960"
  },
  {
    "text": "exploitation specifically exploiting one of the vulnerabilities moshe talked about on a schneider electric ups device",
    "start": "1526960",
    "end": "1534080"
  },
  {
    "start": "1533000",
    "end": "1533000"
  },
  {
    "text": "so a ups ups essentially stands for uninterruptable power supply it's a big",
    "start": "1534080",
    "end": "1541279"
  },
  {
    "text": "battery connected to the wall and you plug all sorts of devices into it that you don't want them to suffer",
    "start": "1541279",
    "end": "1546400"
  },
  {
    "text": "from power outages or power fluctuations such as medical devices critical infrastructure",
    "start": "1546400",
    "end": "1551840"
  },
  {
    "text": "server racks stuff like that um so we exploit on a ups made by schneider specifically on",
    "start": "1551840",
    "end": "1558400"
  },
  {
    "text": "the network card um this uh the network card houses a",
    "start": "1558400",
    "end": "1563600"
  },
  {
    "text": "turbo 186 processor it's an x86 based processor all code runs in 16-bit real mode so os",
    "start": "1563600",
    "end": "1570559"
  },
  {
    "text": "track app whatever everything meaning also that it has basically no modern mitigation so no slr",
    "start": "1570559",
    "end": "1577840"
  },
  {
    "text": "no depth making our life a bit easier um one crook that this processor is",
    "start": "1577840",
    "end": "1584159"
  },
  {
    "text": "different from x86 is that the it shifts it shifts the segment register",
    "start": "1584159",
    "end": "1589520"
  },
  {
    "text": "by eight bits instead of four bits and we'll talk about that a bit more later",
    "start": "1589520",
    "end": "1594799"
  },
  {
    "text": "and during our research we had essentially no debugging capabilities so we focused mainly on the static",
    "start": "1594799",
    "end": "1601120"
  },
  {
    "text": "analysis and reverse engineering and we also had a little bit of assistance from partial crash dumps",
    "start": "1601120",
    "end": "1606320"
  },
  {
    "text": "including a stack trace and some registers so just to recap the vulnerability",
    "start": "1606320",
    "end": "1612400"
  },
  {
    "start": "1610000",
    "end": "1610000"
  },
  {
    "text": "um our primitive is a heap overflow through dns response parsing and because this is a slightly newer",
    "start": "1612400",
    "end": "1618720"
  },
  {
    "text": "version of trek we can only overflow with alphanumeric characters and hyphens we chose to exploit on this device using",
    "start": "1618720",
    "end": "1627360"
  },
  {
    "text": "the bad rd length venerability um so we can overflow through",
    "start": "1627360",
    "end": "1633919"
  },
  {
    "start": "1630000",
    "end": "1630000"
  },
  {
    "text": "all dns response types as much as i said earlier so whether it be cname a mx ptr all response types",
    "start": "1633919",
    "end": "1641520"
  },
  {
    "text": "and but we chose the overflow specifically through mx and because when the device boots up the network card will send out",
    "start": "1641520",
    "end": "1647760"
  },
  {
    "text": "three mx requests to notify about some events via email and",
    "start": "1647760",
    "end": "1653120"
  },
  {
    "text": "this is very advantageous from an exploitation point of view and because we would like as much interactivity as possible in our exploit",
    "start": "1653120",
    "end": "1659760"
  },
  {
    "text": "to allow easier heap shaping we don't care a lot and that we need to crash the",
    "start": "1659760",
    "end": "1666399"
  },
  {
    "text": "device in order for this to happen since we probably need to get the heap into a relatively deterministic state",
    "start": "1666399",
    "end": "1671840"
  },
  {
    "text": "anyway having no debugging capability so no real insight into the heap and also the penalty for crashing the",
    "start": "1671840",
    "end": "1677919"
  },
  {
    "text": "network card is relatively low as it has no functional or vis",
    "start": "1677919",
    "end": "1683039"
  },
  {
    "text": "or visual influence on the ups and the only effect is a few minutes a",
    "start": "1683039",
    "end": "1688799"
  },
  {
    "text": "few seconds of downtime on the network card web interface",
    "start": "1688799",
    "end": "1694158"
  },
  {
    "start": "1694000",
    "end": "1694000"
  },
  {
    "text": "so we chose to overflow the ts dns cache entry struct using our heap overflow",
    "start": "1694320",
    "end": "1700159"
  },
  {
    "text": "um as you can see it has all sorts of interesting fields um it has a list of other info",
    "start": "1700159",
    "end": "1706559"
  },
  {
    "text": "structs adder info holds the contents of dns responses so if you resolve an ip address it will have the",
    "start": "1706559",
    "end": "1712399"
  },
  {
    "text": "ip if you resolve the name it will have a name all sorts of stuff like that and other than that",
    "start": "1712399",
    "end": "1717679"
  },
  {
    "text": "it has other interesting pointers you can see it's in a doubly linked list always advantageous for exploitation and",
    "start": "1717679",
    "end": "1724159"
  },
  {
    "text": "it's referenced often in dns response parsing logic which is the logic we can trigger so this track was interesting for us so",
    "start": "1724159",
    "end": "1731600"
  },
  {
    "text": "assuming we can overflow this truck what can we do with it so for example during cname record",
    "start": "1731600",
    "end": "1738799"
  },
  {
    "start": "1738000",
    "end": "1738000"
  },
  {
    "text": "processing you can see this bit of pseudocode it will first take a pointer from the cache",
    "start": "1738799",
    "end": "1744640"
  },
  {
    "text": "entry the the adderinfo list ptr and save it in a local variable it will then expand the cname allocate",
    "start": "1744640",
    "end": "1752080"
  },
  {
    "text": "the cname we provided on the heap and it will later put the pointer to that heap buffer",
    "start": "1752080",
    "end": "1759520"
  },
  {
    "text": "into the address provided from dns cache entry so basically if we can overflow the dns",
    "start": "1759520",
    "end": "1765919"
  },
  {
    "text": "ptr field of the cache entry we can with some arbitrary value we can write a pointer",
    "start": "1765919",
    "end": "1772559"
  },
  {
    "text": "to some address in the address space so a control pointer right uh pointers",
    "start": "1772559",
    "end": "1780320"
  },
  {
    "start": "1778000",
    "end": "1778000"
  },
  {
    "text": "in six and bit real mode are made absolute pointers are made of two bytes offset and two byte segment",
    "start": "1780320",
    "end": "1785440"
  },
  {
    "text": "and we can write them to any alphanumeric address since our overflow is alphanumeric and this is a",
    "start": "1785440",
    "end": "1791039"
  },
  {
    "text": "strong exploitation primitive writing data to places you're not supposed to write to is always interesting from an exploiter",
    "start": "1791039",
    "end": "1796960"
  },
  {
    "text": "point of view so we chose to go ahead with this primitive our overflow",
    "start": "1796960",
    "end": "1802559"
  },
  {
    "start": "1801000",
    "end": "1801000"
  },
  {
    "text": "is a simple heap overflow it's from the end of the mx name buffer with no jumps it's a contiguous overflow so in",
    "start": "1802559",
    "end": "1809520"
  },
  {
    "text": "order to overflow the dns cache entry we need it to be placed linearly after us",
    "start": "1809520",
    "end": "1816559"
  },
  {
    "text": "this can prove a bit tricky since the dns cache entry is allocated on dns request creation",
    "start": "1817039",
    "end": "1822480"
  },
  {
    "text": "and our mx name buffer is obviously allocated on response parsing which happens chronologically later and",
    "start": "1822480",
    "end": "1829520"
  },
  {
    "text": "we need the cache entry to be placed after our name buffer so we need to do some shaping to make this",
    "start": "1829520",
    "end": "1834960"
  },
  {
    "text": "happen luckily this heap is a bit sophisticated and it",
    "start": "1834960",
    "end": "1841120"
  },
  {
    "start": "1836000",
    "end": "1836000"
  },
  {
    "text": "supports tight fit preference meaning that if you have a hole of a specific",
    "start": "1841120",
    "end": "1846640"
  },
  {
    "text": "size as shown in this diagram it will prefer to take the tightest fit for the allocation size",
    "start": "1846640",
    "end": "1853200"
  },
  {
    "text": "requested from all the three blocks so if we create for example a whole pattern",
    "start": "1853200",
    "end": "1858799"
  },
  {
    "text": "that has a hole the size of the dns cache entry struct after a hole the size of the mxname",
    "start": "1858799",
    "end": "1864559"
  },
  {
    "text": "buffer we're going to allocate um it can assist us in reaching the linear overflow target",
    "start": "1864559",
    "end": "1870880"
  },
  {
    "text": "however we do need to separate these holes with some allocated separator of some sort to prevent free block",
    "start": "1870880",
    "end": "1876840"
  },
  {
    "text": "coalescing so we'll use the memory leak artifact",
    "start": "1876840",
    "end": "1882399"
  },
  {
    "text": "moshe talked about to create the separators and simple name dns name allocation to",
    "start": "1882399",
    "end": "1887440"
  },
  {
    "text": "create the names as they are freed after dns response parsing is finished and we have three responses",
    "start": "1887440",
    "end": "1894000"
  },
  {
    "start": "1894000",
    "end": "1894000"
  },
  {
    "text": "so the limitations on our cname pointer right are the cname pointer is written to an",
    "start": "1894000",
    "end": "1899360"
  },
  {
    "text": "address we overflowed into the cache entry so it must be alphanumeric um this is a little ndn architecture",
    "start": "1899360",
    "end": "1906960"
  },
  {
    "text": "um so the offset and segment will look like that and since our overflow is after all a",
    "start": "1906960",
    "end": "1912320"
  },
  {
    "text": "string overflow we do have a trailing nullbyte which can be used as the segment most significant byte allowing us a bit more",
    "start": "1912320",
    "end": "1918480"
  },
  {
    "text": "flexibility in what we can overflow however nothing interesting is placed in",
    "start": "1918480",
    "end": "1924080"
  },
  {
    "text": "a strictly alpha numeric address so no code no heap no stack no globals and nothing interesting really",
    "start": "1924080",
    "end": "1931679"
  },
  {
    "text": "luckily because of the weird segmentation feature of this processor and we can easily combine two",
    "start": "1931679",
    "end": "1937760"
  },
  {
    "text": "alphanumeric bytes to reach a non-alphanumeric byte so that will look something like this if",
    "start": "1937760",
    "end": "1942880"
  },
  {
    "text": "we have a valid segment that we can overflow such as nullbyte4b and we add to it an alphanumeric offset",
    "start": "1942880",
    "end": "1949440"
  },
  {
    "text": "such as a a the result will contain a non-alphanumeric",
    "start": "1949440",
    "end": "1955519"
  },
  {
    "text": "byte corresponding directly to a non-alphanumeric segment this is possible due to the fact that",
    "start": "1955519",
    "end": "1960880"
  },
  {
    "text": "the shift is by 8 bits and not 4 bits giving us more flexibility in this calculation",
    "start": "1960880",
    "end": "1965919"
  },
  {
    "text": "and using this technique we can reach the heap utility functions text section allowing us to",
    "start": "1965919",
    "end": "1972240"
  },
  {
    "text": "directly override with our pointer heap code again no mitigation so no depth no",
    "start": "1972240",
    "end": "1977840"
  },
  {
    "text": "slr um so when you can overwrite code with a pointer one of the interesting",
    "start": "1977840",
    "end": "1983519"
  },
  {
    "text": "things to do in x86 is to overwrite the far call destination as it is encoded directly with an",
    "start": "1983519",
    "end": "1988880"
  },
  {
    "start": "1986000",
    "end": "1986000"
  },
  {
    "text": "absolute pointer in it um so if we can overwrite a farco like",
    "start": "1988880",
    "end": "1994080"
  },
  {
    "text": "this in the in some hebrew flow we can cause the far call to direct execution",
    "start": "1994080",
    "end": "2000880"
  },
  {
    "text": "to our cname buffer instead of the original destination and we chose in our example to patch",
    "start": "2000880",
    "end": "2006880"
  },
  {
    "text": "a farco in a free airflow called when heap metadata corruption is detected and",
    "start": "2006880",
    "end": "2013519"
  },
  {
    "text": "so when the metadata corruption is detected the farco will execute our payload so just to",
    "start": "2013519",
    "end": "2019919"
  },
  {
    "text": "recap the vulnerability we shape the heap to allow the mxn name buffer to be placed before the dns cache",
    "start": "2019919",
    "end": "2025760"
  },
  {
    "text": "entry we then overflow the dnsc other info ptr so it will point into some heap code",
    "start": "2025760",
    "end": "2032720"
  },
  {
    "text": "specifically a farco then a cnn record we provided is processed and the name and the r data of the",
    "start": "2032720",
    "end": "2040960"
  },
  {
    "text": "cname is allocated on the heap in this case it will be some evil payloads or some alphanumeric shell code of some sort",
    "start": "2040960",
    "end": "2047440"
  },
  {
    "text": "then the pointer to that buffer will be placed into the pointer we overflowed on the",
    "start": "2047440",
    "end": "2052878"
  },
  {
    "text": "cache entry struct essentially overriding the farco destination in the free airflow",
    "start": "2052879",
    "end": "2059440"
  },
  {
    "text": "redirects redirecting execution to the evil payload",
    "start": "2059440",
    "end": "2064560"
  },
  {
    "start": "2064000",
    "end": "2064000"
  },
  {
    "text": "so to trigger this this error flow will be triggered when we free the mx name we overflowed",
    "start": "2064560",
    "end": "2072158"
  },
  {
    "text": "from since we overflowed the end of it some metadata was corrupted and when it will be freed",
    "start": "2072159",
    "end": "2077358"
  },
  {
    "text": "um our code will get executed and our payload contains a two-stage decoder",
    "start": "2077359",
    "end": "2083280"
  },
  {
    "text": "to allow us to run arbitrary payloads and not be contained only to alphanumeric shell",
    "start": "2083280",
    "end": "2089200"
  },
  {
    "text": "codes and in the demo you'll see soon we execute a payload",
    "start": "2089200",
    "end": "2094560"
  },
  {
    "text": "turning of power to the ups power outlets essentially turning off any device connected to it",
    "start": "2094560",
    "end": "2100800"
  },
  {
    "text": "achieving arbitrary payload execution and owning the device so let's see a short table",
    "start": "2100800",
    "end": "2117838"
  },
  {
    "text": "foreign",
    "start": "2128839",
    "end": "2131839"
  },
  {
    "text": "so",
    "start": "2142839",
    "end": "2145839"
  },
  {
    "text": "foreign",
    "start": "2156880",
    "end": "2159838"
  },
  {
    "text": "so everyone thanks for listening thanks for",
    "start": "2170839",
    "end": "2176880"
  },
  {
    "text": "joining us uh we're here to take uh any questions uh you have about uh what we've just",
    "start": "2176880",
    "end": "2183440"
  },
  {
    "text": "seen uh feel free in the last questions in the chat",
    "start": "2183440",
    "end": "2189680"
  },
  {
    "text": "um all the speakers are here i'm shlomi and ariel and monsieur are here with me",
    "start": "2191839",
    "end": "2201520"
  },
  {
    "text": "so we have questions um someone asked about finding these",
    "start": "2201520",
    "end": "2206560"
  },
  {
    "text": "vulnerabilities they were all found manually by reverse engineering we had to reverse engineer",
    "start": "2206560",
    "end": "2212079"
  },
  {
    "text": "several different devices to get a handle on on the the variances in the track stack",
    "start": "2212079",
    "end": "2217760"
  },
  {
    "text": "the different uh variations of uh what the vulnerabilities look like but",
    "start": "2217760",
    "end": "2223280"
  },
  {
    "text": "everything was done uh manually and then some bindif and you know on the basic tools gabra",
    "start": "2223280",
    "end": "2230800"
  },
  {
    "text": "some ida some hacked ida modules to support",
    "start": "2230800",
    "end": "2238000"
  },
  {
    "text": "architectures",
    "start": "2240839",
    "end": "2243839"
  },
  {
    "text": "maybe we have another one no these are source code okay so john",
    "start": "2246000",
    "end": "2253839"
  },
  {
    "text": "is asking if we had source code for our research yeah so um",
    "start": "2253839",
    "end": "2261200"
  },
  {
    "text": "so yeah the answer is no we we did our research engineering several devices",
    "start": "2261200",
    "end": "2269119"
  },
  {
    "text": "and and what we saw in the slides of the pseudocode essentially",
    "start": "2269119",
    "end": "2275520"
  },
  {
    "text": "decompilation what we did have is we had pretty good uh the bad symbols",
    "start": "2275520",
    "end": "2281119"
  },
  {
    "text": "um the stack being in so many different devices different vendors",
    "start": "2281119",
    "end": "2287280"
  },
  {
    "text": "compile them differently um so some of the vendors compiled them with quite a few uh debug symbols and that was of course",
    "start": "2287280",
    "end": "2294240"
  },
  {
    "text": "very helpful okay we have a [Music]",
    "start": "2294240",
    "end": "2299839"
  },
  {
    "text": "question what effect will ripple 20 have on the defense industries um so that's that's a pretty",
    "start": "2299839",
    "end": "2306720"
  },
  {
    "text": "good question it's a question that we're at to some extent asking ourselves because of course it's it's",
    "start": "2306720",
    "end": "2312160"
  },
  {
    "text": "uh quite difficult to get reliable information in this case um we can say that we do",
    "start": "2312160",
    "end": "2318560"
  },
  {
    "text": "know of at least a few defense contractors",
    "start": "2318560",
    "end": "2323760"
  },
  {
    "text": "from different countries that are affected and also that the green hills integrity",
    "start": "2323760",
    "end": "2329920"
  },
  {
    "text": "operating system is to some extent affected and it's used heavily in the defense sector so the",
    "start": "2329920",
    "end": "2335119"
  },
  {
    "text": "defence sector is affected but of course the whole uh",
    "start": "2335119",
    "end": "2341359"
  },
  {
    "text": "the risk model is uh is different there the risks are different and the flow of information is very",
    "start": "2341359",
    "end": "2348640"
  },
  {
    "text": "difficult um okay we have another question from cameron",
    "start": "2348640",
    "end": "2354720"
  },
  {
    "text": "uh was there a response from apc or schneiderlin so um schneider were very responsive",
    "start": "2354720",
    "end": "2362400"
  },
  {
    "text": "um and we're very communicative and they've released patches for the abc devices as well as their other devices and",
    "start": "2362400",
    "end": "2370640"
  },
  {
    "text": "at this point if you apply patches all the apc devices are you know not affected by all these if uh",
    "start": "2370640",
    "end": "2377920"
  },
  {
    "text": "if you apply the patches",
    "start": "2377920",
    "end": "2383040"
  },
  {
    "text": "um okay so brent is asking what are the top vendors that you think are most important that people should worry about",
    "start": "2383040",
    "end": "2390240"
  },
  {
    "text": "patching like common hd printers",
    "start": "2390240",
    "end": "2395440"
  },
  {
    "text": "yeah so i think it very much depends on your industry and your you know the assets on your network um",
    "start": "2398079",
    "end": "2404880"
  },
  {
    "text": "as well as um the uh",
    "start": "2404880",
    "end": "2411839"
  }
]