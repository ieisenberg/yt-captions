[
  {
    "text": "[Music]",
    "start": "1130",
    "end": "14320"
  },
  {
    "text": "hello everyone thanks uh for attending uh our session today we are gonna show you how we can bypass memory corruption",
    "start": "14320",
    "end": "21119"
  },
  {
    "text": "and mitigation using a speculative execution before going to the details of our talk a little bit about ourselves um my name",
    "start": "21119",
    "end": "28960"
  },
  {
    "text": "is andre mambretti and i'm a system security researcher at ibm research in zurich i'm also a phd student at",
    "start": "28960",
    "end": "36239"
  },
  {
    "text": "northeastern university along with me",
    "start": "36239",
    "end": "41840"
  },
  {
    "text": "there is alexander sandulescu she works at google and in the security team",
    "start": "41840",
    "end": "48320"
  },
  {
    "text": "and she's a former colleague of us in ibm research where this work was actually",
    "start": "48320",
    "end": "53440"
  },
  {
    "text": "done okay before going into the details of the technical",
    "start": "53440",
    "end": "58640"
  },
  {
    "text": "details of our talk we need to uh look at what transient execution is",
    "start": "58640",
    "end": "64239"
  },
  {
    "text": "transit execution uh it's a type of execution that happens in modern cpus",
    "start": "64239",
    "end": "71119"
  },
  {
    "text": "that are highly optimized and these cpus whenever there",
    "start": "71119",
    "end": "76400"
  },
  {
    "text": "is a like a possibility to guess for future operations to optimize the",
    "start": "76400",
    "end": "81759"
  },
  {
    "text": "pipeline they will employ transient execution that will start",
    "start": "81759",
    "end": "87040"
  },
  {
    "text": "the execution of a series of transient instructions and these instructions will cross the pipeline",
    "start": "87040",
    "end": "93520"
  },
  {
    "text": "in the back end of the cpu and their output is actually unknown so",
    "start": "93520",
    "end": "100960"
  },
  {
    "text": "we don't know uh what is going to be the uh the possible outcome for for each one of these distractions until the very end",
    "start": "100960",
    "end": "107680"
  },
  {
    "text": "and the cpu uh will decide uh when they reach the end of the pipeline if",
    "start": "107680",
    "end": "112960"
  },
  {
    "text": "retiring these instructions and that means that their side effects will be architecturally visible to our",
    "start": "112960",
    "end": "120079"
  },
  {
    "text": "program and or basically squash these instructions",
    "start": "120079",
    "end": "125920"
  },
  {
    "text": "and that means that the cpu has decided that uh the optimization the",
    "start": "125920",
    "end": "132480"
  },
  {
    "text": "the gas that was employed was actually not correct and these distractions are not needed anymore",
    "start": "132480",
    "end": "138560"
  },
  {
    "text": "and therefore we'll try to lower back all the side effects that these instructions have left in the back end",
    "start": "138560",
    "end": "144239"
  },
  {
    "text": "of the cpu the problem is that this rolling back of the state of the micro architecture",
    "start": "144239",
    "end": "151760"
  },
  {
    "text": "is not complete and actually these this uh allows for a",
    "start": "151760",
    "end": "156959"
  },
  {
    "text": "possibility for attacks so an attack in the transit execution uh works as follow we have like some",
    "start": "156959",
    "end": "163760"
  },
  {
    "text": "transient destruction that is generated by the cpu because of some optimization and these transient instruction will",
    "start": "163760",
    "end": "170319"
  },
  {
    "text": "access a secret the idea here is that by accessing the secret",
    "start": "170319",
    "end": "175440"
  },
  {
    "text": "they will these distractions they will leave some footprint in the micro architecture that are not rolled back by",
    "start": "175440",
    "end": "181840"
  },
  {
    "text": "the cpu when this destruction will be squashed and an attacker through one of the many",
    "start": "181840",
    "end": "187599"
  },
  {
    "text": "side channels that are available in the micro architecture will be able to leak",
    "start": "187599",
    "end": "193040"
  },
  {
    "text": "this footprint and will be able to uh find out what was the secret that was",
    "start": "193040",
    "end": "200080"
  },
  {
    "text": "accessed so what are the uh what is the threat model for uh for this type of attacks so",
    "start": "200080",
    "end": "206480"
  },
  {
    "text": "the threat model is always a victim programmer that is holding a secret and is handling a secret and that",
    "start": "206480",
    "end": "213840"
  },
  {
    "text": "is that uh this victim program running on a cpu that employs a",
    "start": "213840",
    "end": "220319"
  },
  {
    "text": "transient execution will leave some side effects behind and we will have an attacker program running",
    "start": "220319",
    "end": "227040"
  },
  {
    "text": "on the same machine that is trying to uh look at these footprints that is left",
    "start": "227040",
    "end": "233680"
  },
  {
    "text": "behind and try to guess what was the secret handled by the by the victim program",
    "start": "233680",
    "end": "240640"
  },
  {
    "text": "so let's now have a look at one example of a speculative execution attacks let's have a look",
    "start": "240640",
    "end": "246400"
  },
  {
    "text": "at the spectra version 101 which is also known as a speculative buffer overflow",
    "start": "246400",
    "end": "251760"
  },
  {
    "text": "that was presented by kirianski back in 2018. this this attack leverages a piece",
    "start": "251760",
    "end": "257759"
  },
  {
    "text": "of code such as this one where we have a buffer and we have a bounce check on this",
    "start": "257759",
    "end": "264240"
  },
  {
    "text": "buffer before making a store towards the buffer so um",
    "start": "264240",
    "end": "269759"
  },
  {
    "text": "here is the layout on the of the stack of of this uh little snippet of code we",
    "start": "269759",
    "end": "275600"
  },
  {
    "text": "have the array and we have like some other information stored in the stack",
    "start": "275600",
    "end": "280840"
  },
  {
    "text": "so when we start to execute this piece of code when we reach this instruction as you can see",
    "start": "280840",
    "end": "287040"
  },
  {
    "text": "the size of the array is not present into the cache we assume that this value is not present in the cache and we also",
    "start": "287040",
    "end": "293120"
  },
  {
    "text": "assume that the x the value of x is under attacker control and it's actually",
    "start": "293120",
    "end": "299040"
  },
  {
    "text": "out of bound the cpu modern cpu since the size of",
    "start": "299040",
    "end": "304160"
  },
  {
    "text": "array is not ready will not stall but it will start to speculative execute and if",
    "start": "304160",
    "end": "310400"
  },
  {
    "text": "we assume that this piece of code was executed many times before with vaccine bound",
    "start": "310400",
    "end": "316479"
  },
  {
    "text": "the cpu will be tricked to think that the x is inbound also this time and so the cpu will move on to this instruction",
    "start": "316479",
    "end": "324160"
  },
  {
    "text": "and it will perform the the store this store that is out of bound",
    "start": "324160",
    "end": "329280"
  },
  {
    "text": "basically we are going to achieve the buffer overflow in a speculative manner",
    "start": "329280",
    "end": "335840"
  },
  {
    "text": "as i said x is under attacker control and we assume that the attacker is",
    "start": "335840",
    "end": "341600"
  },
  {
    "text": "powerful enough to know where for instance the return value on the stack is stored",
    "start": "341600",
    "end": "347360"
  },
  {
    "text": "the attacker will be able to override the the return value and",
    "start": "347360",
    "end": "353280"
  },
  {
    "text": "if you assume that the speculative window is actually long enough to reach this return",
    "start": "353280",
    "end": "359360"
  },
  {
    "text": "uh the attacker will be able to perform basically a speculative control",
    "start": "359360",
    "end": "364720"
  },
  {
    "text": "flow hijack using the value that was overwritten on the on the stack",
    "start": "364720",
    "end": "370160"
  },
  {
    "text": "at this stage basically the attacker is able to steer speculative execution wherever he wants and the idea is that",
    "start": "371440",
    "end": "378319"
  },
  {
    "text": "we the attacker will want to send the speculative execution towards a piece of code that we call a",
    "start": "378319",
    "end": "384639"
  },
  {
    "text": "speculative execution side channel send gadget",
    "start": "384639",
    "end": "390160"
  },
  {
    "text": "and this gadget will allow the attacker to leave some footprint that",
    "start": "390160",
    "end": "397440"
  },
  {
    "text": "that can be read out from another process using the",
    "start": "397759",
    "end": "402800"
  },
  {
    "text": "unknown side channel this type of attacks is not the only attack that",
    "start": "402800",
    "end": "408800"
  },
  {
    "text": "allows us to achieve a speculative control flow hijacks there are many other ways to achieve",
    "start": "408800",
    "end": "414319"
  },
  {
    "text": "this very powerful primitive let's have a look at the overview on how can we achieve a speculative control flow",
    "start": "414319",
    "end": "420400"
  },
  {
    "text": "hijacks so we can achieve a specialty control fly jacks by",
    "start": "420400",
    "end": "426560"
  },
  {
    "text": "leveraging microarchitectural components such as the rsb and the btb",
    "start": "426560",
    "end": "431599"
  },
  {
    "text": "the rsb the return stack buffer is used to predict return instructions when the value is",
    "start": "431599",
    "end": "437759"
  },
  {
    "text": "not ready on the stack or the btb is used to predict the possible outcome of an indirect column",
    "start": "437759",
    "end": "444000"
  },
  {
    "text": "in direct jumps where the the the target is not known during",
    "start": "444000",
    "end": "449039"
  },
  {
    "text": "execution and these works have proven that",
    "start": "449039",
    "end": "454880"
  },
  {
    "text": "this type of attacks actually work we can poison this internal structure of the cpu",
    "start": "454880",
    "end": "460960"
  },
  {
    "text": "and then have a victim use those poison value and basically redirect the victim wherever we want in",
    "start": "460960",
    "end": "466720"
  },
  {
    "text": "a speculative control hijack manner the other on the other side of the spectrum we have",
    "start": "466720",
    "end": "472800"
  },
  {
    "text": "we can achieve speculative control for hijacks using architecturally architectural components such as",
    "start": "472800",
    "end": "479440"
  },
  {
    "text": "registers and memory locations and we can poison these elements",
    "start": "479440",
    "end": "485759"
  },
  {
    "text": "either with a speculative override or a concrete override at the",
    "start": "485759",
    "end": "490879"
  },
  {
    "text": "architectural level and we can overwrite in both of the cases backward and forward edges",
    "start": "490879",
    "end": "497280"
  },
  {
    "text": "so this uh a big family uh of this sub-family of",
    "start": "497280",
    "end": "503039"
  },
  {
    "text": "speculative control fly jacks we call them spear speculative architectural control for hijacks",
    "start": "503039",
    "end": "510720"
  },
  {
    "text": "the first case the speculative override of a backward edge was actually already considered by kenyansky in the",
    "start": "510879",
    "end": "518320"
  },
  {
    "text": "speculative buffer overflow however the other three cases nobody has ever looked at them and we did it in our work",
    "start": "518320",
    "end": "526160"
  },
  {
    "text": "so we tried to find use cases for these three other overrides",
    "start": "526160",
    "end": "532959"
  },
  {
    "text": "and what we did was like we started to look at the mitigations uh memory corruption mitigations",
    "start": "532959",
    "end": "538880"
  },
  {
    "text": "we started to look at the these memory corruption mitigations because for instance if we have an architecture",
    "start": "538880",
    "end": "544480"
  },
  {
    "text": "override of a backward edge which is a normal buffer overflow of course if there is no mitigation in place we can",
    "start": "544480",
    "end": "550800"
  },
  {
    "text": "perform a buffer overflow so memory corruption we can exploit the memory correction vulnerability so we don't",
    "start": "550800",
    "end": "556399"
  },
  {
    "text": "really need the speculative execution but in the case of where we have this primitive but the",
    "start": "556399",
    "end": "562880"
  },
  {
    "text": "primitive is mitigated by the for instance a stock smashing protector then",
    "start": "562880",
    "end": "568320"
  },
  {
    "text": "we wanted to investigate if we can leverage speculative execution to bypass uh such protection and still perform",
    "start": "568320",
    "end": "575200"
  },
  {
    "text": "some sort of attack the first step we did that towards uh towards analyzing these three cases was",
    "start": "575200",
    "end": "582800"
  },
  {
    "text": "actually using a tool that we wrote to observe a speculative execution and",
    "start": "582800",
    "end": "588560"
  },
  {
    "text": "called the speculator that we published the taxa 2019 and",
    "start": "588560",
    "end": "594080"
  },
  {
    "text": "with speculator what we tried to do was actually to verify if we can perform this control",
    "start": "594080",
    "end": "600640"
  },
  {
    "text": "flow hijack and we brought for each one of the cases a smaller snippet of a small test such",
    "start": "600640",
    "end": "607839"
  },
  {
    "text": "as this one this one is a refers to the architectural override of a backward edge",
    "start": "607839",
    "end": "613920"
  },
  {
    "text": "and what we this test works as follows so we we first make a copy of the return value",
    "start": "613920",
    "end": "622079"
  },
  {
    "text": "that we have on the stack and we save the in a different memory location then",
    "start": "622079",
    "end": "627200"
  },
  {
    "text": "we perform the architectural override we basically simulate a buffer overflow",
    "start": "627200",
    "end": "633200"
  },
  {
    "text": "and we point the new return address towards the target location of our",
    "start": "633200",
    "end": "638399"
  },
  {
    "text": "choosing then we use a cl flash instruction to evict the",
    "start": "638399",
    "end": "644560"
  },
  {
    "text": "save the return value so that when we reach this comparison that is going to",
    "start": "644560",
    "end": "650720"
  },
  {
    "text": "try to figure out if the value on the stock and the value saved are actually the same",
    "start": "650720",
    "end": "657279"
  },
  {
    "text": "basically the cpu will not be ready to execute this instruction until the store",
    "start": "657279",
    "end": "662560"
  },
  {
    "text": "threat comes back from from main memory and so we trigger speculative execution at this point",
    "start": "662560",
    "end": "669360"
  },
  {
    "text": "of course this at the architectural level this piece of code will always reach the function my exit",
    "start": "669360",
    "end": "675920"
  },
  {
    "text": "but since we are starting we are tricking the cpu to actually start",
    "start": "675920",
    "end": "681440"
  },
  {
    "text": "speculative execution at this comparison we expect the speculative execution to",
    "start": "681440",
    "end": "686800"
  },
  {
    "text": "actually reach this return instruction and if this piece of code reaches the return",
    "start": "686800",
    "end": "694000"
  },
  {
    "text": "instruction then it will it will use the poison value that we have on the stack",
    "start": "694000",
    "end": "699120"
  },
  {
    "text": "so we will send the execution to our target location and speculator is able",
    "start": "699120",
    "end": "704399"
  },
  {
    "text": "to see if speculative execution will reach the target location or not so these are the results of our findings",
    "start": "704399",
    "end": "710079"
  },
  {
    "text": "for each one of the of the tests we brought in each one of the cases and as you can see we",
    "start": "710079",
    "end": "717440"
  },
  {
    "text": "have a speculative control hijacks happening almost hundred percent of the time so this type of hijack happens of course",
    "start": "717440",
    "end": "724959"
  },
  {
    "text": "this is a lab test so it's really far from an actual attack",
    "start": "724959",
    "end": "731360"
  },
  {
    "text": "real world attack but it's a the first step to understand if these attacks are possible or not alexandra uh now will",
    "start": "731360",
    "end": "738800"
  },
  {
    "text": "basically walk you through to actually the real world attack that we build",
    "start": "738800",
    "end": "745120"
  },
  {
    "text": "after we figure out that control flow hijack actually is possible in these cases we demonstrate a local arbitrary",
    "start": "745120",
    "end": "752880"
  },
  {
    "text": "memory read attack using the spear architectural backward edge override attack vector",
    "start": "752880",
    "end": "759120"
  },
  {
    "text": "the scheme here shows an overview of the steps required to perform the attack",
    "start": "759120",
    "end": "765040"
  },
  {
    "text": "the attack has a preparation phase in steps one and two where eviction sets are identified",
    "start": "765040",
    "end": "773040"
  },
  {
    "text": "memory used by the side channel is flushed and rope gadgets are prepared",
    "start": "773040",
    "end": "778560"
  },
  {
    "text": "the attacker then submits the payload to the victim in step 3. the payload is crafted to exploit the",
    "start": "778560",
    "end": "785920"
  },
  {
    "text": "stack buffer overflow here traditional exploitation of the memory safety violation is prevented by",
    "start": "785920",
    "end": "793040"
  },
  {
    "text": "ssp however the attacker uses a speculative execution attack to bypass the mechanism",
    "start": "793040",
    "end": "801120"
  },
  {
    "text": "by overwriting the return address and obtaining a speculative control flow",
    "start": "801120",
    "end": "806320"
  },
  {
    "text": "hijack as a result the victim is tricked into",
    "start": "806320",
    "end": "811680"
  },
  {
    "text": "executing a side channel send of attacker chosen memory location",
    "start": "811680",
    "end": "817839"
  },
  {
    "text": "this happens in step 6. this is achieved with the rob component which",
    "start": "817839",
    "end": "825040"
  },
  {
    "text": "reuses code snippets from the victim program which are selected and primed in the",
    "start": "825040",
    "end": "832240"
  },
  {
    "text": "initialization phase the attacker can then execute the corresponding side channel receive in",
    "start": "832240",
    "end": "838560"
  },
  {
    "text": "step 7. the success rate of the attack is increased by concurrently executing an",
    "start": "838560",
    "end": "846079"
  },
  {
    "text": "eviction loop to lengthen the speculation window with previously computed eviction sets",
    "start": "846079",
    "end": "852480"
  },
  {
    "text": "for the stack canary the spear attack vector",
    "start": "852480",
    "end": "858560"
  },
  {
    "text": "present in an ssp hardened program will provide us with the necessary",
    "start": "858560",
    "end": "864079"
  },
  {
    "text": "speculative execution primitive for arbitrary victim memory read",
    "start": "864079",
    "end": "869760"
  },
  {
    "text": "we'll first discuss the vulnerability and the necessary attack building blocks",
    "start": "869760",
    "end": "876000"
  },
  {
    "text": "this code example shows a function which is vulnerable to stack buffer overflow but is protected",
    "start": "876240",
    "end": "883120"
  },
  {
    "text": "by ssp um there is a call to mem copy",
    "start": "883120",
    "end": "889279"
  },
  {
    "text": "um that which has like an attacker controlled source and size uh which",
    "start": "889279",
    "end": "895680"
  },
  {
    "text": "overwrites the stack past the store return address",
    "start": "895680",
    "end": "900880"
  },
  {
    "text": "the malicious payload will be architecturally written to the stack in this case",
    "start": "900880",
    "end": "906320"
  },
  {
    "text": "the canary check makes the stack buffer overflow vulnerability unexploitable",
    "start": "906320",
    "end": "913360"
  },
  {
    "text": "in an attempt like this the program will abort due to the canary mismatch",
    "start": "913360",
    "end": "920079"
  },
  {
    "text": "however even if ssp protects against the",
    "start": "920079",
    "end": "925440"
  },
  {
    "text": "architectural exploitation of this vulnerability it also provides us with",
    "start": "925440",
    "end": "930480"
  },
  {
    "text": "the primitives for a speculative control flow hijack the canary check executed before the",
    "start": "930480",
    "end": "937600"
  },
  {
    "text": "function return will trigger the speculative execution if the instruction operands are not",
    "start": "937600",
    "end": "944320"
  },
  {
    "text": "cached and in order to trigger the speculative execution of the vulnerable path which",
    "start": "944320",
    "end": "950639"
  },
  {
    "text": "is the one taken the attacker will send a number of valid requests prior to the",
    "start": "950639",
    "end": "955920"
  },
  {
    "text": "malicious one uh in our experiments uh five valid requests are enough to train the pattern",
    "start": "955920",
    "end": "962959"
  },
  {
    "text": "history table uh such that um the uh the taken branch will be",
    "start": "962959",
    "end": "969199"
  },
  {
    "text": "executed speculatively after the canary cache miss",
    "start": "969199",
    "end": "975279"
  },
  {
    "text": "the compiler generated assembly code for ssp shows the exact operations and",
    "start": "976880",
    "end": "982880"
  },
  {
    "text": "control flow graph in the function prologue the global canary value is stored on the stack",
    "start": "982880",
    "end": "989759"
  },
  {
    "text": "and before return the canary integrity is checked by comparing the value stored",
    "start": "989759",
    "end": "995279"
  },
  {
    "text": "on the stack with the global value this introduces the first attack prerequisite namely the canary eviction",
    "start": "995279",
    "end": "1003199"
  },
  {
    "text": "this triggers the speculative execution of the taken branch leading to",
    "start": "1003199",
    "end": "1008639"
  },
  {
    "text": "speculative control flow hijacking the next attack prerequisite is a reliable rid primitive constructed",
    "start": "1008639",
    "end": "1016639"
  },
  {
    "text": "from rope gadgets that are present in the victim memory space even if",
    "start": "1016639",
    "end": "1022560"
  },
  {
    "text": "ssp is supposed to protect against the function ever reaching the return",
    "start": "1022560",
    "end": "1029438"
  },
  {
    "text": "with the corrupted stack at speculative return the control flow reaches the attacker-crafted drop chain",
    "start": "1029439",
    "end": "1038400"
  },
  {
    "text": "in our experimental setup we tested a drop chain with five gadgets in the stock and and also a stack private with",
    "start": "1038400",
    "end": "1046079"
  },
  {
    "text": "five gadgets and we concluded that the buffer override size must be greater or",
    "start": "1046079",
    "end": "1053120"
  },
  {
    "text": "equal to 50 to sorry 40 bytes to fit the chain",
    "start": "1053120",
    "end": "1058960"
  },
  {
    "text": "the victim stack canary eviction will give the attacker a large enough speculation window for the spear attack",
    "start": "1058960",
    "end": "1066640"
  },
  {
    "text": "the first step of the attack is finding the correct eviction sets for the for",
    "start": "1066640",
    "end": "1072640"
  },
  {
    "text": "the victim step canary we use uh two different processes for the attack that communicate to share",
    "start": "1072640",
    "end": "1079120"
  },
  {
    "text": "memory one of the attackers it is compiled with ssb is the one on the right",
    "start": "1079120",
    "end": "1085919"
  },
  {
    "text": "they both run a synchronous loop",
    "start": "1085919",
    "end": "1091120"
  },
  {
    "text": "the first one will load one llc eviction set and the second one will probe the",
    "start": "1091120",
    "end": "1098080"
  },
  {
    "text": "canary access time and for exactly one eviction set the attacker program on the right will",
    "start": "1098080",
    "end": "1105440"
  },
  {
    "text": "encounter a cache miss and as a result the attacker will know the exact llc",
    "start": "1105440",
    "end": "1111520"
  },
  {
    "text": "slides and cache set corresponding to the canary of the other process",
    "start": "1111520",
    "end": "1117440"
  },
  {
    "text": "now the next part the attacker must make sure that the victim canary",
    "start": "1117440",
    "end": "1124160"
  },
  {
    "text": "lies in the same physical memory location as the one discovered previously",
    "start": "1124160",
    "end": "1130640"
  },
  {
    "text": "we evaluated the reuse of the underlying physical page of the canary in three",
    "start": "1130640",
    "end": "1136960"
  },
  {
    "text": "different setups the first setup is when the victim program is exact by",
    "start": "1136960",
    "end": "1143440"
  },
  {
    "text": "the attacker in the second setup the victim is a separate process spawned by the attacker",
    "start": "1143440",
    "end": "1150960"
  },
  {
    "text": "and in a third setup the victim is a completely separate process running on",
    "start": "1150960",
    "end": "1156000"
  },
  {
    "text": "the same system as the attacker the canary page reuse success will be",
    "start": "1156000",
    "end": "1161200"
  },
  {
    "text": "100 for the first two cases due to the body allocator the allocation and",
    "start": "1161200",
    "end": "1168480"
  },
  {
    "text": "allocation patterns but for the latter use case the success",
    "start": "1168480",
    "end": "1173520"
  },
  {
    "text": "will depend on the resident memory statistics granularity present on the machine that",
    "start": "1173520",
    "end": "1181200"
  },
  {
    "text": "detects the attack runs on in this example we'll consider the first scenario",
    "start": "1181200",
    "end": "1188640"
  },
  {
    "text": "where the attacker process will execute the victim program and thus the canary memory page",
    "start": "1188640",
    "end": "1195919"
  },
  {
    "text": "is preserved at a victim startup",
    "start": "1195919",
    "end": "1200720"
  },
  {
    "text": "the sets that were previously previously computed",
    "start": "1201679",
    "end": "1208320"
  },
  {
    "text": "are still are still usable such that",
    "start": "1208320",
    "end": "1214400"
  },
  {
    "text": "the attacker can now evict the canary value in the victim process",
    "start": "1214400",
    "end": "1222240"
  },
  {
    "text": "to address the canary eviction we came up with a novel approach of",
    "start": "1225360",
    "end": "1230559"
  },
  {
    "text": "the victim victim data for existing methods incur high penalty",
    "start": "1230559",
    "end": "1236559"
  },
  {
    "text": "on the on the rope execution success our method has the advantage of being",
    "start": "1236559",
    "end": "1241840"
  },
  {
    "text": "non-intrusive and noise-free compared to existing solutions",
    "start": "1241840",
    "end": "1248679"
  },
  {
    "text": "now regarding speculative drop the attack payload uh is composed of",
    "start": "1249120",
    "end": "1254880"
  },
  {
    "text": "carefully carefully uh chosen rob gadgets that are prepared prepared as part of the initialization phase in step",
    "start": "1254880",
    "end": "1263280"
  },
  {
    "text": "one the gadgets must be chosen from code pages that are already present in victim",
    "start": "1263280",
    "end": "1270400"
  },
  {
    "text": "memory and have a valid tlb mapping moreover during a rock chain",
    "start": "1270400",
    "end": "1277919"
  },
  {
    "text": "initialization phase the attacker executes the chain in a loop um pinned to the same physical core",
    "start": "1277919",
    "end": "1285840"
  },
  {
    "text": "as the victim process this uh in our experiments lower the chances of instruction cache misses",
    "start": "1285840",
    "end": "1293200"
  },
  {
    "text": "during a rock chain execution the canary eviction will ensure a long",
    "start": "1293200",
    "end": "1298559"
  },
  {
    "text": "enough speculation window inside of which we run the attack payload the",
    "start": "1298559",
    "end": "1304240"
  },
  {
    "text": "outcome of this attack is the side channel send represented by an effect on the cache",
    "start": "1304240",
    "end": "1310400"
  },
  {
    "text": "which cannot be rolled back when misprediction is detected",
    "start": "1310400",
    "end": "1315840"
  },
  {
    "text": "in contrast with a traditional drop speculative rope gadgets must be chosen",
    "start": "1315840",
    "end": "1321600"
  },
  {
    "text": "such that the chain has the minimum possible length in the paper we show exactly what",
    "start": "1321600",
    "end": "1327919"
  },
  {
    "text": "gadgets worked in our attack and from what libraries and binaries we obtain those gadgets",
    "start": "1327919",
    "end": "1334000"
  },
  {
    "text": "uh in this example however the gadgets are the basic building blocks of the successful arbitrary victim",
    "start": "1334000",
    "end": "1342000"
  },
  {
    "text": "memory read followed by a side channel sent in the first gadget",
    "start": "1342000",
    "end": "1348960"
  },
  {
    "text": "we see that uh there is a load of the victim secret uh byte",
    "start": "1348960",
    "end": "1355600"
  },
  {
    "text": "um this load uh to increase the success of the attack this load should hit the",
    "start": "1355600",
    "end": "1360640"
  },
  {
    "text": "cache this will provide during the speculation window will",
    "start": "1360640",
    "end": "1366559"
  },
  {
    "text": "provide the attacker with the victim secret bike that they intend to leak",
    "start": "1366559",
    "end": "1373679"
  },
  {
    "text": "the second the next gadget will compute the exact offset in the side channel array",
    "start": "1373679",
    "end": "1381200"
  },
  {
    "text": "that corresponds to the victim secret byte value to reduce the noise at the receive end",
    "start": "1381200",
    "end": "1388960"
  },
  {
    "text": "each side channel array element is of size 256 the noise source here comes from",
    "start": "1388960",
    "end": "1396320"
  },
  {
    "text": "adjacent cache lines being fetched together with the requested line next",
    "start": "1396320",
    "end": "1402559"
  },
  {
    "text": "the side channel the side channel array base is added to the previously computed offset resulting",
    "start": "1402559",
    "end": "1410240"
  },
  {
    "text": "in the memory address of the entry corresponding to the victim secret byte",
    "start": "1410240",
    "end": "1415760"
  },
  {
    "text": "value and lastly a load is performed in order to bring",
    "start": "1415760",
    "end": "1421919"
  },
  {
    "text": "this exact side channel array element in cache this operation represents the side",
    "start": "1421919",
    "end": "1427200"
  },
  {
    "text": "channel send operation the attack uses the de facto option in",
    "start": "1427200",
    "end": "1434880"
  },
  {
    "text": "speculative execution attacks namely the cache site channel although other side channels would work",
    "start": "1434880",
    "end": "1441520"
  },
  {
    "text": "as well here the cache side channel can use any shared memory region between attacker",
    "start": "1441520",
    "end": "1447600"
  },
  {
    "text": "and victim as side channel array for example any dynamic library used by",
    "start": "1447600",
    "end": "1453520"
  },
  {
    "text": "the victim program the shared space constraints that we found",
    "start": "1453520",
    "end": "1460400"
  },
  {
    "text": "the attack needs at least 64 kilobytes size and eventually low noise",
    "start": "1460400",
    "end": "1467600"
  },
  {
    "text": "the attacker may prefer a shared library which is not accessed in close time proximity with the attack",
    "start": "1467600",
    "end": "1473919"
  },
  {
    "text": "for convenience here we used leap thread",
    "start": "1473919",
    "end": "1478960"
  },
  {
    "text": "the side channel array is primed by the attacker immediately after sending the payload by flashing all array elements",
    "start": "1478960",
    "end": "1486640"
  },
  {
    "text": "from all cache levels since the memory area is shared between the attacker and victim the attacker can",
    "start": "1486640",
    "end": "1493200"
  },
  {
    "text": "execute this phase on its side the attacker triggers the side-channel send operation on the victim by crafting",
    "start": "1493200",
    "end": "1500880"
  },
  {
    "text": "a payload that triggers the spear vulnerable code path and",
    "start": "1500880",
    "end": "1506400"
  },
  {
    "text": "eventually hijacks the program control flow during speculation window in step 7",
    "start": "1506400",
    "end": "1513279"
  },
  {
    "text": "the attacker will probe the array to read the side channel signal sent by the",
    "start": "1513279",
    "end": "1521520"
  },
  {
    "text": "speculative rope in the absence of noise the probing will result in one single",
    "start": "1521520",
    "end": "1528880"
  },
  {
    "text": "side channel array element cached this would reveal the victim secret",
    "start": "1528880",
    "end": "1534400"
  },
  {
    "text": "value corresponding to the signal array element",
    "start": "1534400",
    "end": "1540360"
  },
  {
    "text": "uh the end-to-end spear architectural backward edge override attack",
    "start": "1542799",
    "end": "1549039"
  },
  {
    "text": "results in a local arbitrary memory read of the victim memory we achieved an",
    "start": "1549039",
    "end": "1555520"
  },
  {
    "text": "end-to-end uh leakage rate of 0.3 bytes per second um",
    "start": "1555520",
    "end": "1561039"
  },
  {
    "text": "to increase the success rate uh there is a phase in our attack where the attacker needs to run co-located with the victim",
    "start": "1561039",
    "end": "1568559"
  },
  {
    "text": "but for a short period of time various noise sources require the attack",
    "start": "1568559",
    "end": "1574000"
  },
  {
    "text": "to be executed multiple times in order to distinguish a clear signal during situational receive for this",
    "start": "1574000",
    "end": "1581039"
  },
  {
    "text": "reason we ran the attack 100 times for each victim by to filter out the noise",
    "start": "1581039",
    "end": "1587360"
  },
  {
    "text": "and our measurements in here include the victim crash and startup times",
    "start": "1587360",
    "end": "1593039"
  },
  {
    "text": "the attack works on sky lake and coffee lake with all spectre mitigations enabled and we also",
    "start": "1593039",
    "end": "1600720"
  },
  {
    "text": "tested on two ubuntu versions 16.4 and 20.4 we observed a slight uh success rate",
    "start": "1600720",
    "end": "1608960"
  },
  {
    "text": "change in 20.4 due to the another bean utils version",
    "start": "1608960",
    "end": "1615039"
  },
  {
    "text": "and to increase the attack success and reduce the noise further work would be needed on the rope",
    "start": "1615039",
    "end": "1623120"
  },
  {
    "text": "chain optimization side attacker and victim synchronization and",
    "start": "1623120",
    "end": "1628240"
  },
  {
    "text": "less noisy side channel arrays for the next part mitigations and",
    "start": "1628240",
    "end": "1634720"
  },
  {
    "text": "future work i'll leave andrea to continue thank you alexandra um so",
    "start": "1634720",
    "end": "1641279"
  },
  {
    "text": "uh as the at the beginning of the presentation uh i was mentioning that we didn't we also looked at other use cases",
    "start": "1641279",
    "end": "1649360"
  },
  {
    "text": "and uh among these use cases there is the memory safe languages",
    "start": "1649360",
    "end": "1654559"
  },
  {
    "text": "in this category we looked at go and rasta in particular and we found",
    "start": "1654559",
    "end": "1659679"
  },
  {
    "text": "out that both of the these languages when they introduce security checks",
    "start": "1659679",
    "end": "1665600"
  },
  {
    "text": "they basically introduce avenues for us spear attacks they both are affected we brought pocs for each one of the",
    "start": "1665600",
    "end": "1672640"
  },
  {
    "text": "these two languages and for go we conducted the go security team in november 2019 and we discussed",
    "start": "1672640",
    "end": "1679279"
  },
  {
    "text": "with them of possible solutions and uh the outcome of our discussion was uh this new spectre flag that was",
    "start": "1679279",
    "end": "1686559"
  },
  {
    "text": "introduced in ago version 115 uh and so we with the use of this flag basically",
    "start": "1686559",
    "end": "1693760"
  },
  {
    "text": "um these problems this pr problem was was uh resolved for uh rust we reported",
    "start": "1693760",
    "end": "1700399"
  },
  {
    "text": "our findings in december 2020 and we are currently in discussion to uh towards a",
    "start": "1700399",
    "end": "1705440"
  },
  {
    "text": "solution for this more details about our work on memories uh safe languages",
    "start": "1705440",
    "end": "1712159"
  },
  {
    "text": "can be found in our eurosmp 2021 paper",
    "start": "1712159",
    "end": "1717200"
  },
  {
    "text": "the final use case that we looked in uh during our work was actually the control flow integrity case that",
    "start": "1717200",
    "end": "1723760"
  },
  {
    "text": "is related to the architectural override of forward edges in this case we looked at the",
    "start": "1723760",
    "end": "1729919"
  },
  {
    "text": "implementation of the llvmc5 and the gcc vtv we found out that llvm cfi was actually",
    "start": "1729919",
    "end": "1738000"
  },
  {
    "text": "not by possible using spear attacks and this is due to one very fortunate design decision from llvm",
    "start": "1738000",
    "end": "1746080"
  },
  {
    "text": "that basically embeds some of the metadata within the pointer and so when we",
    "start": "1746080",
    "end": "1751120"
  },
  {
    "text": "try to evict the metadata we also evicted pointer and and so the speculative execution will block",
    "start": "1751120",
    "end": "1757440"
  },
  {
    "text": "and and also there are other checks that llvmcfi introduces but there are against the constant that are in line in the",
    "start": "1757440",
    "end": "1763520"
  },
  {
    "text": "code so we cannot really evict those and to start our uh our attack",
    "start": "1763520",
    "end": "1769760"
  },
  {
    "text": "for uh gcc tv instead uh the type of checks that the gccvtv introduces is",
    "start": "1769760",
    "end": "1776000"
  },
  {
    "text": "actually vulnerable to spear and we have a smaller poc that that proves it",
    "start": "1776000",
    "end": "1781279"
  },
  {
    "text": "um one key point from our analysis of control flow integrity is uh is really",
    "start": "1781279",
    "end": "1786640"
  },
  {
    "text": "that uh this type of attacks the spear attacks are really implement implementation dependent so each one of",
    "start": "1786640",
    "end": "1793440"
  },
  {
    "text": "the mitigations each one of the versions of the mitigations that are out there should be verified to be",
    "start": "1793440",
    "end": "1800000"
  },
  {
    "text": "uh resilient against this type of attacks again more details on how we did",
    "start": "1800000",
    "end": "1805679"
  },
  {
    "text": "our analysis on control for integrity is available in our eurosmp paper",
    "start": "1805679",
    "end": "1812480"
  },
  {
    "text": "so we so far we didn't really speak much about mitigations there are of course",
    "start": "1812480",
    "end": "1817679"
  },
  {
    "text": "mitigations against our spear attacks one set of mitigations is actually",
    "start": "1817679",
    "end": "1824720"
  },
  {
    "text": "instrumentation of the application that we want to protect the the there are already",
    "start": "1824720",
    "end": "1832240"
  },
  {
    "text": "compiler passes that helps the user to instrument the application",
    "start": "1832240",
    "end": "1837840"
  },
  {
    "text": "against against the spear for instance we have the llvm speculation speculative load hardening",
    "start": "1837840",
    "end": "1843600"
  },
  {
    "text": "the problem with this type of approach of inlining defenses is that there is always a very fine line between",
    "start": "1843600",
    "end": "1850799"
  },
  {
    "text": "a harder trade-off between you know coverage and overhead so the more",
    "start": "1850799",
    "end": "1856480"
  },
  {
    "text": "uh patterns in the code we we protect uh the higher is the overhead and so",
    "start": "1856480",
    "end": "1863039"
  },
  {
    "text": "it's very hard to find which are the sensible uh code patterns that we want to protect versus the one that we want",
    "start": "1863039",
    "end": "1869760"
  },
  {
    "text": "to leave not protected um examples of this type of instrumentation there are fencing",
    "start": "1869760",
    "end": "1876080"
  },
  {
    "text": "instruction that can be in line in the code there is a branchless masking or construct such as red pulling",
    "start": "1876080",
    "end": "1884080"
  },
  {
    "text": "there are other type of mitigations that the microarchitectural community",
    "start": "1884080",
    "end": "1890320"
  },
  {
    "text": "has been working on and these these mitigations aim to change the design in",
    "start": "1890320",
    "end": "1895760"
  },
  {
    "text": "which the uh the cpu uh works and the idea one line of work is",
    "start": "1895760",
    "end": "1901360"
  },
  {
    "text": "actually to introduce data flow analysis in the cpu pipeline such that",
    "start": "1901360",
    "end": "1906559"
  },
  {
    "text": "the cpu will be able to identify unsafe operations and will be",
    "start": "1906559",
    "end": "1911600"
  },
  {
    "text": "able to block those unsafe operations to take place and delay them when it's safe for them",
    "start": "1911600",
    "end": "1917519"
  },
  {
    "text": "to be executed them this line of work would actually prevent completely all our spirit attacks",
    "start": "1917519",
    "end": "1925440"
  },
  {
    "text": "the second line of work instead focuses on changing the um the cash hierarchy design",
    "start": "1925440",
    "end": "1932960"
  },
  {
    "text": "such that the side channels and cover channels in the in the cache",
    "start": "1932960",
    "end": "1938159"
  },
  {
    "text": "will be eliminated while this is effective uh for certain sphere attacks that are",
    "start": "1938159",
    "end": "1944320"
  },
  {
    "text": "based on the on the cache uh they do not work for a spear attacks",
    "start": "1944320",
    "end": "1950640"
  },
  {
    "text": "that are mounted with other side channels for instance support contention or b2b",
    "start": "1950640",
    "end": "1957679"
  },
  {
    "text": "one problem with this type of design approach is that they only cover new",
    "start": "1958000",
    "end": "1963200"
  },
  {
    "text": "iterations of the cpu but they don't cover currently existing architecture",
    "start": "1963200",
    "end": "1969360"
  },
  {
    "text": "um so what are the takeaway ways of our talk so we we showed that we are able to bypass using a sphere",
    "start": "1969360",
    "end": "1976480"
  },
  {
    "text": "current mitigations and memory safety mechanism to leak confidential data",
    "start": "1976480",
    "end": "1984000"
  },
  {
    "text": "one key point here is that new and old mitigation should be",
    "start": "1984000",
    "end": "1989840"
  },
  {
    "text": "analyzed to see if they are actually resilient against these attacks and some of the design must change to basically",
    "start": "1989840",
    "end": "1996880"
  },
  {
    "text": "make sure that the spear attacks are not possible against them",
    "start": "1996880",
    "end": "2002158"
  },
  {
    "text": "as alexandra showed you these type of attacks in real-world settings have many stages",
    "start": "2002720",
    "end": "2009360"
  },
  {
    "text": "and they are relatively in each one of these stages as a success rate",
    "start": "2009360",
    "end": "2014480"
  },
  {
    "text": "and everything should work together to have a successful attack but",
    "start": "2014480",
    "end": "2020480"
  },
  {
    "text": "it is also sure that they are practical that we can achieve an end-to-end attack and the idea here is that with new tools",
    "start": "2020480",
    "end": "2027760"
  },
  {
    "text": "more tailor tools again towards like automating each one of the phases will",
    "start": "2027760",
    "end": "2032880"
  },
  {
    "text": "improve again the practicality of this uh of these type of attacks finally in a in our end-to-end poc we",
    "start": "2032880",
    "end": "2040559"
  },
  {
    "text": "employ speculative rope and we show that it's possible to use speculative drop in in these attacks and",
    "start": "2040559",
    "end": "2047039"
  },
  {
    "text": "this technique actually helps a great deal to for instance build uh complex",
    "start": "2047039",
    "end": "2052480"
  },
  {
    "text": "gadgets such as the spectral v1 gadgets such and send that",
    "start": "2052480",
    "end": "2058638"
  },
  {
    "text": "really uh is hard to find in normally in in a in the user's code",
    "start": "2058639",
    "end": "2065040"
  },
  {
    "text": "in general uh we foresee that speculative execution attacks will be the challenge for the next decade",
    "start": "2065040",
    "end": "2072638"
  },
  {
    "text": "so far uh we still lack of many tools uh to understand and study and build",
    "start": "2072639",
    "end": "2079679"
  },
  {
    "text": "these attacks as well as like only very few attacks have been uh been studied then we've believed that there is the",
    "start": "2079679",
    "end": "2086240"
  },
  {
    "text": "attack surface still quite large to be explored and also we will need to work a lot in",
    "start": "2086240",
    "end": "2093040"
  },
  {
    "text": "defenses because as i was mentioning before for instance in the inlining type of defenses it's very hard to find the",
    "start": "2093040",
    "end": "2098640"
  },
  {
    "text": "right trade-off and so we might need to come up with a better heuristic for this and with this i conclude here are some",
    "start": "2098640",
    "end": "2106800"
  },
  {
    "text": "of the references that we used during our talk if you have any questions",
    "start": "2106800",
    "end": "2113440"
  },
  {
    "text": "thank you",
    "start": "2113440",
    "end": "2116160"
  }
]