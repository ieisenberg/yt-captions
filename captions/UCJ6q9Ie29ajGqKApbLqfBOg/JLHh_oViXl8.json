[
  {
    "text": "today I'm going to talk about downfall single instruction multiple data leaks",
    "start": "3800",
    "end": "8920"
  },
  {
    "text": "in Cutting Edge CPUs today I'm going to first talk about The Gather instruction it's a",
    "start": "8920",
    "end": "15879"
  },
  {
    "text": "instruction in Intel CPUs x86 CPUs in general uh a little bit history of this",
    "start": "15879",
    "end": "22240"
  },
  {
    "text": "kind of microarchitectural data leaks vulnerabilities and then I'm going to",
    "start": "22240",
    "end": "27320"
  },
  {
    "text": "introduce the gather data sampling attack technique and how we can use this attack technique",
    "start": "27320",
    "end": "33040"
  },
  {
    "text": "to steal encryption keys from other users and applications how we can use this attack to also steal arbitary data",
    "start": "33040",
    "end": "39800"
  },
  {
    "text": "from other applications and finally how it impacts security of Intel SG secure",
    "start": "39800",
    "end": "46680"
  },
  {
    "text": "enclaves and finally we're going to talk a little bit about mitigation options and conclude the",
    "start": "46680",
    "end": "53920"
  },
  {
    "text": "talk let's talk about The Gather instruction The Gather instruction is this instruction that that is introduced",
    "start": "54359",
    "end": "61160"
  },
  {
    "text": "about 15 years ago as part of the ax 2 extension to speed up accessing",
    "start": "61160",
    "end": "67560"
  },
  {
    "text": "scattered data in memory and it has various forms various data types that",
    "start": "67560",
    "end": "72960"
  },
  {
    "text": "you can use it in x86 assembly but you can also use this instruction as part of the Intel ining Library when you're",
    "start": "72960",
    "end": "80119"
  },
  {
    "text": "writing C code and this instruction actually used everywhere nowadays a little uh Google uh GitHub search I I",
    "start": "80119",
    "end": "88720"
  },
  {
    "text": "figured out that this instru is using things like database cryptography scientific Computing library and so many",
    "start": "88720",
    "end": "95399"
  },
  {
    "text": "different other places essentially any application that is data intensive they want to do fast data processing they can",
    "start": "95399",
    "end": "103320"
  },
  {
    "text": "benefit from this particular instruction so what is this instruction",
    "start": "103320",
    "end": "108840"
  },
  {
    "text": "about uh imagine I'm a software developer I'm trying to write an algorithm that uh perform some uh data",
    "start": "108840",
    "end": "117360"
  },
  {
    "text": "accesses from scattered memory I have a look up table I have some uh indexes and",
    "start": "117360",
    "end": "122920"
  },
  {
    "text": "what I would do generally is that I write a for Loop go through each of these indexes and access the memory",
    "start": "122920",
    "end": "129560"
  },
  {
    "text": "based on these indexes and here in this particular case I want to only do a computation where these indexes are odd",
    "start": "129560",
    "end": "137000"
  },
  {
    "text": "so for every other index in the memory I can rewrite this algorithm a",
    "start": "137000",
    "end": "143599"
  },
  {
    "text": "lot simpler by using the gather instruction which the idea is that you provide the vector of index a vector of",
    "start": "143599",
    "end": "151160"
  },
  {
    "text": "mask and a memory look up and then it does this memory access for you and then you can use another Vector instruction",
    "start": "151160",
    "end": "158160"
  },
  {
    "text": "to do the final computation and this looks like something like this when you uh when you",
    "start": "158160",
    "end": "164480"
  },
  {
    "text": "have the memory you have this bunch of data that is scattered in the memory and then the CPU figure out where this",
    "start": "164480",
    "end": "170959"
  },
  {
    "text": "memory exists based on that index register and it's going to bring those values into this Vector",
    "start": "170959",
    "end": "178040"
  },
  {
    "text": "register but CPU designers have a lot of choice to make this instruction super",
    "start": "178760",
    "end": "184120"
  },
  {
    "text": "fast for example when you access this memory from uh from the Dr uh you may",
    "start": "184120",
    "end": "191040"
  },
  {
    "text": "access the same data from the same cach ton and the CPU can use let's say a buffer inside the CPU core to",
    "start": "191040",
    "end": "197680"
  },
  {
    "text": "essentially reuse the same cach line so for different memory operations it doesn't have to go uh fetch the memory",
    "start": "197680",
    "end": "204959"
  },
  {
    "text": "again and again or it can use the same buffer to also preserve part IAL",
    "start": "204959",
    "end": "210120"
  },
  {
    "text": "execution of The Gather instruction The Gather instruction in x86 can access up",
    "start": "210120",
    "end": "215280"
  },
  {
    "text": "to 16 different memory memory pieces and sometimes some of these may may be",
    "start": "215280",
    "end": "220439"
  },
  {
    "text": "service faster than others uh but you may have some interupts happening in the meantime and the CPU can just preserve",
    "start": "220439",
    "end": "227080"
  },
  {
    "text": "the data so when that interrupt resumes it can go gather the rest of the",
    "start": "227080",
    "end": "232280"
  },
  {
    "text": "data and it can also just forward these data pieces to the next instruction and",
    "start": "232280",
    "end": "238159"
  },
  {
    "text": "uh doesn't have to wait for all the data beats to be available so this buffer can really help with all of that essentially",
    "start": "238159",
    "end": "245200"
  },
  {
    "text": "the CPU can allocate a buffer inside the physical register file and a speculatively forward data to the next",
    "start": "245200",
    "end": "251959"
  },
  {
    "text": "instructions so this gather operation executes",
    "start": "251959",
    "end": "257720"
  },
  {
    "text": "fast and this looks like something like this we have the software registers on the right side the memory but in reality",
    "start": "257720",
    "end": "264440"
  },
  {
    "text": "there's this Hardware register that is not accessible to the software and the CPU is going to at some entries in this",
    "start": "264440",
    "end": "270800"
  },
  {
    "text": "Hardware register going to eventually bring this data bits and map them to the software and in the meantime it can also",
    "start": "270800",
    "end": "278360"
  },
  {
    "text": "continue forwarding this data to the next instructions and continue the",
    "start": "278360",
    "end": "283919"
  },
  {
    "text": "computation wait a minute shared buffers forwarding data speculatively what can go wrong with this this is fast but we",
    "start": "283919",
    "end": "291320"
  },
  {
    "text": "have seen in the past that this can have some vulnerabilities if you go back to 2018",
    "start": "291320",
    "end": "299120"
  },
  {
    "text": "when was introduced uh we learned that CPUs can leak data from other user and",
    "start": "299120",
    "end": "305960"
  },
  {
    "text": "you could leak data from the data cache that is shared across different users on the same CPU",
    "start": "305960",
    "end": "313160"
  },
  {
    "text": "core and the mitigation for that was that there were some software mitigation But ultimately Intel fixed this in",
    "start": "313160",
    "end": "320160"
  },
  {
    "text": "Hardware with the ninth generation Intel coffee leg CPUs and then later on in 2019 a few",
    "start": "320160",
    "end": "328600"
  },
  {
    "text": "researchers including myself we looked at the Meltdown fix and we realized that this fix is not working properly and we",
    "start": "328600",
    "end": "335479"
  },
  {
    "text": "can still leak data because there are other buffers inside the CPU core that they still leak data and the the",
    "start": "335479",
    "end": "342720"
  },
  {
    "text": "response to that was Intel issued the micro code fix the micro code fix uh",
    "start": "342720",
    "end": "347840"
  },
  {
    "text": "enabled the operating system to flush the buffers across Contex switching and also they suggested to disable hyper",
    "start": "347840",
    "end": "354919"
  },
  {
    "text": "trading for some workloads and ultimately Intel fixed this one VAB ility again in the in the ice l 10",
    "start": "354919",
    "end": "362160"
  },
  {
    "text": "generation CPUs there were some glitches how they push this mitigation forward so there",
    "start": "362160",
    "end": "368400"
  },
  {
    "text": "were some uh parts that would still leak data some of the I CPU didn't have the",
    "start": "368400",
    "end": "373840"
  },
  {
    "text": "mitigations enabled properly and ultimately by the middle of 20202 2020",
    "start": "373840",
    "end": "380960"
  },
  {
    "text": "we knew we knew that this problem is solved and we don't have these kind of vulnerabilities that enable an attacker",
    "start": "380960",
    "end": "387240"
  },
  {
    "text": "to leak arbitrary data anymore and one thing all these vulnerabilities",
    "start": "387240",
    "end": "393039"
  },
  {
    "text": "in the past had in common is that there are these CPU buffers that are shared across users and keep data from other",
    "start": "393039",
    "end": "399800"
  },
  {
    "text": "users and when an attacker could access some memory and and experience of fault",
    "start": "399800",
    "end": "406039"
  },
  {
    "text": "or micro censis inside the CPU they could leak data from these buffers meltdown was leaking data from the L1",
    "start": "406039",
    "end": "413280"
  },
  {
    "text": "data cache there was the Fallout or micral store buffer data sampling",
    "start": "413280",
    "end": "418520"
  },
  {
    "text": "leaking data from the store buffer and there were also other buffers like line field buffer and load buffer and that",
    "start": "418520",
    "end": "425720"
  },
  {
    "text": "that was like a research effort by multiple people multiple University including myself and people figure that",
    "start": "425720",
    "end": "431479"
  },
  {
    "text": "there are all these buffers and you can attack them now today I'm going to talk about",
    "start": "431479",
    "end": "436759"
  },
  {
    "text": "that buffer in that midle which is the vector register file and how The Gather instruction can leak from this this",
    "start": "436759",
    "end": "443080"
  },
  {
    "text": "buffer inside the CPU gather data sampling the idea of the",
    "start": "443080",
    "end": "449639"
  },
  {
    "text": "data sampling is simple once I discovered this vulnerability it's pretty easy to understand and exploit it",
    "start": "449639",
    "end": "455879"
  },
  {
    "text": "imagine we have a we have a user that is running some Vector operation for example the user is loading data from",
    "start": "455879",
    "end": "463440"
  },
  {
    "text": "the memory to the V to the to some of the vector registers and this is a",
    "start": "463440",
    "end": "468639"
  },
  {
    "text": "common use case and then in the attacker executes four steps to leak this data",
    "start": "468639",
    "end": "475000"
  },
  {
    "text": "running on the same CPU core in the first step of the the attack",
    "start": "475000",
    "end": "480319"
  },
  {
    "text": "the attacker is going to execute a series of instructions to put the CPU in a speculative execution State and here",
    "start": "480319",
    "end": "486960"
  },
  {
    "text": "in this case what we are doing is that we exe we execute a bunch of instructions that create a cache Miss",
    "start": "486960",
    "end": "492840"
  },
  {
    "text": "and when these cache misses occur the CPU is going to execute the following instructions in a speculative in a",
    "start": "492840",
    "end": "499280"
  },
  {
    "text": "speculative fashion here the following instruction is The Gather instruction that load the",
    "start": "499280",
    "end": "506120"
  },
  {
    "text": "load scattered data from memory and then we're going to encode the output of this instruction to the cache and scan the",
    "start": "506120",
    "end": "513479"
  },
  {
    "text": "cache and the last two step is very similar to the original meltdown attack so I'm not going to really expand on",
    "start": "513479",
    "end": "521200"
  },
  {
    "text": "that so let's see how this looks like in practice so in practice here there's a",
    "start": "522080",
    "end": "527880"
  },
  {
    "text": "sample code that you can also access online but the idea is that there's one",
    "start": "527880",
    "end": "533040"
  },
  {
    "text": "uh one CPU thread that accessing a bunch of string values and the other CPU",
    "start": "533040",
    "end": "539000"
  },
  {
    "text": "thread thre can leak data leak those string values when we execute this so after I discovered this uh this",
    "start": "539000",
    "end": "547240"
  },
  {
    "text": "particular vulnerability then I was like okay what are the other instructions that could leak to the gathered data",
    "start": "547240",
    "end": "553720"
  },
  {
    "text": "sampling and I wrote a simple tool to automatically find what instructions",
    "start": "553720",
    "end": "559480"
  },
  {
    "text": "leak to gather data sampling the idea is that I collect a bunch of memory",
    "start": "559480",
    "end": "564600"
  },
  {
    "text": "instructions from the llvm assembler test case automatically execute them",
    "start": "564600",
    "end": "569640"
  },
  {
    "text": "and in the same CPU thread CPU core I'm going to execute the gather data sampling and record any data leak that I",
    "start": "569640",
    "end": "577360"
  },
  {
    "text": "see the highlight of the highlight of this experiment was that I realized all",
    "start": "577360",
    "end": "583000"
  },
  {
    "text": "simd instruction assign the instructions that load data from memory they all leak",
    "start": "583000",
    "end": "588640"
  },
  {
    "text": "but that includes things like asni and shyi extensions that are designed for",
    "start": "588640",
    "end": "594120"
  },
  {
    "text": "cryptography to speed up cryptography but also there are some other instructions on x86 that are",
    "start": "594120",
    "end": "601800"
  },
  {
    "text": "encoded to micro code inside the CPU that use this Vector register buffer and",
    "start": "601800",
    "end": "608040"
  },
  {
    "text": "rep move is an instruction that is available in all application to copy data efficiently and this instruction",
    "start": "608040",
    "end": "615079"
  },
  {
    "text": "also use the same register file and there are also some other special instruction to restore the register",
    "start": "615079",
    "end": "622519"
  },
  {
    "text": "context when we perform context features this is used in the operating system in hypervisor or in anywhere that",
    "start": "622519",
    "end": "628399"
  },
  {
    "text": "applications to do do context s each and this instruction also use the same register file and essentially we can use",
    "start": "628399",
    "end": "635160"
  },
  {
    "text": "the gather data sampling to leak data from all of these",
    "start": "635160",
    "end": "640480"
  },
  {
    "text": "instructions another thing that I was interested in is to know how many data byes I can leak every time I execute",
    "start": "640480",
    "end": "648160"
  },
  {
    "text": "this scatter operation so I designed an experiment that this time I'm going to",
    "start": "648160",
    "end": "653720"
  },
  {
    "text": "encode the entire 32 BYT of a vector register to the cache and see how many",
    "start": "653720",
    "end": "659200"
  },
  {
    "text": "bytes I observe in the cache and in The Sibling CPU tread that runs on the same",
    "start": "659200",
    "end": "664839"
  },
  {
    "text": "core I'm going to populate the sly register file with the same data content that I know what it",
    "start": "664839",
    "end": "672320"
  },
  {
    "text": "is the highlight of this experiment experiment on on Intel 11 generation",
    "start": "672320",
    "end": "677800"
  },
  {
    "text": "core CPUs was that we can leak something between two to 22 bytes of contous data",
    "start": "677800",
    "end": "684160"
  },
  {
    "text": "bites each time we execute this GA operation and a lot of these are something with between 16 to 21 bytes",
    "start": "684160",
    "end": "692200"
  },
  {
    "text": "and compared to previous microarchitectural data sampling attack this is a lot more data because MDS",
    "start": "692200",
    "end": "698880"
  },
  {
    "text": "attacks previously could only leak three or four bytes every time you would access the memory subsystem but this",
    "start": "698880",
    "end": "704800"
  },
  {
    "text": "time we can leak a lot more data another experiment I did is to",
    "start": "704800",
    "end": "711680"
  },
  {
    "text": "understand the data pattern when we leak from this register file so this time the",
    "start": "711680",
    "end": "717680"
  },
  {
    "text": "the test program that load data into the register file is going to load data with different patterns to the register file",
    "start": "717680",
    "end": "724279"
  },
  {
    "text": "and then I'm going to execute the GDs again but with different word size for 32bit or 64bit granular operation that",
    "start": "724279",
    "end": "732839"
  },
  {
    "text": "The Gather instruction supports and the other thing we can do here is also every time we do a leak we",
    "start": "732839",
    "end": "740639"
  },
  {
    "text": "permute the output of The Gather operation uh before encoding it to the cach so we can choose which part of this",
    "start": "740639",
    "end": "746880"
  },
  {
    "text": "Vector register we want to leak the highlight of this was that I realize",
    "start": "746880",
    "end": "752760"
  },
  {
    "text": "you can leak only four or eight by chunks of continuous data so the way this data is laid out in the register",
    "start": "752760",
    "end": "759399"
  },
  {
    "text": "file it's not going to be continuously leaked to The Gather instruction but we can leak up to8 bites of data",
    "start": "759399",
    "end": "766199"
  },
  {
    "text": "continuously but we can also use the permute instruction to choose which part of the register file register we lick",
    "start": "766199",
    "end": "773839"
  },
  {
    "text": "and that's the kind of data pattern we observe that we can on the left side see the for by data words we are leaking on",
    "start": "773839",
    "end": "780560"
  },
  {
    "text": "the eight on the right side we see the8 by data words we are leaking so this time we are executing",
    "start": "780560",
    "end": "787000"
  },
  {
    "text": "the same test but we are trying to leak different part of the data that we put into the register file and we can see",
    "start": "787000",
    "end": "793600"
  },
  {
    "text": "that when we I provide different indexes we are leaking different words like e efgh is leaking now and the next time ik",
    "start": "793600",
    "end": "800639"
  },
  {
    "text": "jkl is leaking so it's different part of the the register",
    "start": "800639",
    "end": "806240"
  },
  {
    "text": "file and here also in the source code we see this test program puts this string data into the into the register file",
    "start": "806240",
    "end": "814399"
  },
  {
    "text": "with with using other memory",
    "start": "814399",
    "end": "818560"
  },
  {
    "text": "operations all right so now we have this uh powerful primitive that we can use it",
    "start": "824399",
    "end": "830320"
  },
  {
    "text": "to attack real application so far we show that how we can use this to steal data from other Treads other programs",
    "start": "830320",
    "end": "837600"
  },
  {
    "text": "and how how can we use this to steal encryption keys so there is this attack I developed in the research paper but I",
    "start": "837600",
    "end": "844240"
  },
  {
    "text": "also I provided the proof of concept and video on the website but the idea is that we have a v team that logs into a",
    "start": "844240",
    "end": "851519"
  },
  {
    "text": "computer and it encrypts random data with the after sh of op SSL command line",
    "start": "851519",
    "end": "857320"
  },
  {
    "text": "tool and this looks like something like this we execute op SSL we ask op SSL to",
    "start": "857320",
    "end": "862360"
  },
  {
    "text": "increase with as 12 128bit and it we encryp some random data",
    "start": "862360",
    "end": "868320"
  },
  {
    "text": "through away and it uses the same key each time and here when we do this the",
    "start": "868320",
    "end": "874720"
  },
  {
    "text": "AES algorithm naturally expand this master key to some round keys because",
    "start": "874720",
    "end": "880480"
  },
  {
    "text": "that's how the as algorithm operates and the asni which is the lowlevel extension",
    "start": "880480",
    "end": "885880"
  },
  {
    "text": "in the CPU has to every time load all these round keys from the memory to the",
    "start": "885880",
    "end": "891079"
  },
  {
    "text": "to the registers to be able to do encryption and we know one of these",
    "start": "891079",
    "end": "896440"
  },
  {
    "text": "round Keys is the master key that we want to Ste and this looks like like something like this imagine this is 128",
    "start": "896440",
    "end": "903720"
  },
  {
    "text": "bit of data that is the master key it's in the register and then there are also",
    "start": "903720",
    "end": "909199"
  },
  {
    "text": "some other round keys that the as has generated we don't necessarily care about them but they're going to be in",
    "start": "909199",
    "end": "914360"
  },
  {
    "text": "the register file anyway and there are going to be also a lot of garbage data in the register file because we are",
    "start": "914360",
    "end": "920199"
  },
  {
    "text": "encrypting random data so when we execute the gathered",
    "start": "920199",
    "end": "925440"
  },
  {
    "text": "data sampling attack on this state when the CPU has this state one of the",
    "start": "925440",
    "end": "930959"
  },
  {
    "text": "observation is that these round keys are going to be repeated with a high frequency because they are being",
    "start": "930959",
    "end": "936880"
  },
  {
    "text": "executed again and again but those random garbage data is not going to be",
    "start": "936880",
    "end": "942360"
  },
  {
    "text": "repeated so here the attacker execute the GDs attack lecking 8 by chunks of",
    "start": "942360",
    "end": "948079"
  },
  {
    "text": "the register file each time and we then keep these chunks that have a high frequency but also the ones that have a",
    "start": "948079",
    "end": "955319"
  },
  {
    "text": "uniform random distribution because the cryptography Keys generally have a uniform random",
    "start": "955319",
    "end": "961160"
  },
  {
    "text": "distribution and then we combine these eight by chunks to create a list of key",
    "start": "961160",
    "end": "966639"
  },
  {
    "text": "candidates for the 16 by AES key candidates or if it's a as 256 bit we",
    "start": "966639",
    "end": "972199"
  },
  {
    "text": "create those chunks for a um for a 30 32 by key",
    "start": "972199",
    "end": "978360"
  },
  {
    "text": "candidates and then we Brute Force those key candidates to recover the as key and we can do two we can use two things to",
    "start": "978360",
    "end": "985959"
  },
  {
    "text": "do the Brute Force One is use the pl T Cipher Tak pair that we have or alternatively we can just test these",
    "start": "985959",
    "end": "992680"
  },
  {
    "text": "round Keys we have recovered against each other and see which one produce the correct master",
    "start": "992680",
    "end": "998759"
  },
  {
    "text": "key so imagine this is the register file and here we just show this with two",
    "start": "998759",
    "end": "1003839"
  },
  {
    "text": "round keys but the same applies when we have the 10 round keys in a 128 bit and",
    "start": "1003839",
    "end": "1009319"
  },
  {
    "text": "the idea is we lick the first8 by chunks with because they have a higher uh",
    "start": "1009319",
    "end": "1014839"
  },
  {
    "text": "higher uh chance of being in the register file higher repetition then we do the same thing for the second one and",
    "start": "1014839",
    "end": "1021920"
  },
  {
    "text": "then we match all these and we have a list of candidates and one of these candidates is the correct a key and here",
    "start": "1021920",
    "end": "1029959"
  },
  {
    "text": "in this case we see that there is only four candidate but when we do this for 10 round Keys there's about like 128",
    "start": "1029959",
    "end": "1036880"
  },
  {
    "text": "candidates that we have to Brute Force which is very easy on a personal computer to do this Brute",
    "start": "1036880",
    "end": "1042918"
  },
  {
    "text": "Force here I have a demo that shows this attack in action",
    "start": "1042919",
    "end": "1049440"
  },
  {
    "text": "here I log in to this shared computer",
    "start": "1049440",
    "end": "1055960"
  },
  {
    "text": "and we see that it's running a Intel 11 generation uh",
    "start": "1058039",
    "end": "1064240"
  },
  {
    "text": "CPU that is not vulnerable to any of the previous meltdown or MDS",
    "start": "1064240",
    "end": "1069799"
  },
  {
    "text": "attacks then another user logs in as a",
    "start": "1069799",
    "end": "1074679"
  },
  {
    "text": "victim and the victim has some scripts to do the AES encryption I mentioned",
    "start": "1077400",
    "end": "1084200"
  },
  {
    "text": "earlier and we're going to compile the attack code on the attacker",
    "start": "1084200",
    "end": "1089600"
  },
  {
    "text": "side here we execute the victim victim is doing some encryption and this is the",
    "start": "1089600",
    "end": "1094640"
  },
  {
    "text": "attacker this is the key we want to steal on the victim side on the attacker side we have some pieces recovered and",
    "start": "1094640",
    "end": "1101440"
  },
  {
    "text": "then we do the brute force and this is the stolen key which is matching the the",
    "start": "1101440",
    "end": "1106640"
  },
  {
    "text": "original key [Applause]",
    "start": "1106640",
    "end": "1114280"
  },
  {
    "text": "this time I'm I'm timing it to see how many seconds it takes and it recovered the stolen key in",
    "start": "1114280",
    "end": "1122400"
  },
  {
    "text": "about 13 13 seconds it's match the original",
    "start": "1122400",
    "end": "1130840"
  },
  {
    "text": "key and in the last demo I'm going to show how this also works against as 256",
    "start": "1133600",
    "end": "1139480"
  },
  {
    "text": "bit uh obviously the Brute Force takes a few minutes so I fast forward the the",
    "start": "1139480",
    "end": "1146919"
  },
  {
    "text": "video Let's uh go here we are doing The Brute",
    "start": "1149880",
    "end": "1156440"
  },
  {
    "text": "first this is the stallen key it tookes about",
    "start": "1167240",
    "end": "1172360"
  },
  {
    "text": "6",
    "start": "1172360",
    "end": "1174679"
  },
  {
    "text": "minutes and it's matching the original key from the user",
    "start": "1180200",
    "end": "1187600"
  },
  {
    "text": "side all right",
    "start": "1193159",
    "end": "1200240"
  },
  {
    "text": "well I hope you enjoyed that 256bit asq being stallen uh now I'm going to talk",
    "start": "1200640",
    "end": "1206720"
  },
  {
    "text": "about how we can potentially use this attack to steal arbitrary data not just",
    "start": "1206720",
    "end": "1212200"
  },
  {
    "text": "the data that is accessed by by another program so there is this particular",
    "start": "1212200",
    "end": "1218120"
  },
  {
    "text": "feature in in CPUs that they like to prefetch data to speed up computations",
    "start": "1218120",
    "end": "1223559"
  },
  {
    "text": "again and uh one of the observations I had is that there are two conditions",
    "start": "1223559",
    "end": "1228600"
  },
  {
    "text": "that the CPU prefetches data that is not even accessed by the software and the",
    "start": "1228600",
    "end": "1233960"
  },
  {
    "text": "first one I call it out of bound prefetch the idea is that you ask the",
    "start": "1233960",
    "end": "1239559"
  },
  {
    "text": "CPU as a software to only read let's say 100 byte of data but the CPU is going to",
    "start": "1239559",
    "end": "1244600"
  },
  {
    "text": "prefet more than 100 byte to to speed up computations potentially and the other",
    "start": "1244600",
    "end": "1250640"
  },
  {
    "text": "one I call it no up prefet the idea is that the instruction doesn't even read any data architecturally but the CPU is",
    "start": "1250640",
    "end": "1258440"
  },
  {
    "text": "going to prefetch data anyway and there are two affected instructions that have",
    "start": "1258440",
    "end": "1263600"
  },
  {
    "text": "this Behavior one is this mask move instruction in in x86 and the idea is",
    "start": "1263600",
    "end": "1269600"
  },
  {
    "text": "that it this instruction conditionally load data from memory to the vector register file and it turns out this",
    "start": "1269600",
    "end": "1277200"
  },
  {
    "text": "instruction always load one cach line anyway even if all the mask bits are on sets which means even if this",
    "start": "1277200",
    "end": "1283159"
  },
  {
    "text": "instruction is not supposed to load anything it's going to always load one cach line to the physical register file",
    "start": "1283159",
    "end": "1289679"
  },
  {
    "text": "the other one is the rep move instruction that I mentioned earlier also and this instruction is supposed to",
    "start": "1289679",
    "end": "1296080"
  },
  {
    "text": "copy some chunks of data based on the R6 register value and then from The Source",
    "start": "1296080",
    "end": "1302279"
  },
  {
    "text": "register to the destination register and it turns out this instruction always prefetches two cach lines into the",
    "start": "1302279",
    "end": "1310120"
  },
  {
    "text": "physical register file even if the size is zero even if we tell this instruction to not uh copy any data",
    "start": "1310120",
    "end": "1320039"
  },
  {
    "text": "So based on the second one the rep move instruction I identified several gadgets",
    "start": "1320039",
    "end": "1325840"
  },
  {
    "text": "the M Copy gadgets that one can find them in other application and try to exploit them to steal arbitrary",
    "start": "1325840",
    "end": "1332799"
  },
  {
    "text": "data the idea is that when we write this M Copy or me move function and we use it",
    "start": "1332799",
    "end": "1339640"
  },
  {
    "text": "in in C application compilers translate this to the rep move underneath and we",
    "start": "1339640",
    "end": "1345400"
  },
  {
    "text": "also see that in a lot of softwares we have this property that we copy users data",
    "start": "1345400",
    "end": "1351440"
  },
  {
    "text": "from an untrusted source to a local buffer and we does we do some processing and naturally uh we do some sanity",
    "start": "1351440",
    "end": "1359080"
  },
  {
    "text": "checks to make sure we don't get any like traditional software vulnerabilities like buffer overflows",
    "start": "1359080",
    "end": "1364600"
  },
  {
    "text": "because U otherwise that software would be compromised anyway and the idea is that these",
    "start": "1364600",
    "end": "1370480"
  },
  {
    "text": "gadgets enable an attacker to exploit these non- exploitable software gadgets to leak",
    "start": "1370480",
    "end": "1376640"
  },
  {
    "text": "arbitrary data so how does these Gadget look like so",
    "start": "1376640",
    "end": "1381840"
  },
  {
    "text": "the first one I have here is just a regular M Copy copying user data from an",
    "start": "1381840",
    "end": "1388080"
  },
  {
    "text": "untrusted source to a local buffer and naturally what we do here is that we check the copy size and the index from",
    "start": "1388080",
    "end": "1395039"
  },
  {
    "text": "The Source because we don't want the user to provide some malicious copy size or index so this is a correct copy",
    "start": "1395039",
    "end": "1401640"
  },
  {
    "text": "checking uh but when we execute this this copy is going to prefetch more data",
    "start": "1401640",
    "end": "1406799"
  },
  {
    "text": "that than that lies to that physical register file and we can leak it with gather data",
    "start": "1406799",
    "end": "1412480"
  },
  {
    "text": "sampling the other one is more interesting in C programming uh one thing that is",
    "start": "1412480",
    "end": "1418960"
  },
  {
    "text": "supported is to call the M Copy function with the size of zero and when we do",
    "start": "1418960",
    "end": "1424600"
  },
  {
    "text": "that the rep move also has a size of zero and both of these means there shouldn't be any copy operation so a c",
    "start": "1424600",
    "end": "1432159"
  },
  {
    "text": "program or a compiler can optimize this these sanity checks that if there is is",
    "start": "1432159",
    "end": "1438200"
  },
  {
    "text": "this uh if the sanity checks are not met put this copy size to zero and this is a",
    "start": "1438200",
    "end": "1444200"
  },
  {
    "text": "safe operation because that M Copy is not going to do anything but here actually an attacker",
    "start": "1444200",
    "end": "1450760"
  },
  {
    "text": "can provide arbitrary address there even though that M Copy doesn't do anything architecturally is going to load",
    "start": "1450760",
    "end": "1457880"
  },
  {
    "text": "arbitrary data to the physical register file and the last Gadget here is a",
    "start": "1457880",
    "end": "1463919"
  },
  {
    "text": "gadget that it's buggy it's a buggy the software should not gener do that but sometimes we see that we find these bugs",
    "start": "1463919",
    "end": "1470880"
  },
  {
    "text": "that are not exploitable the sanity check only is checking the size is not checking the",
    "start": "1470880",
    "end": "1476360"
  },
  {
    "text": "index but the attacker can provide the wrong index and even if it's not exploitable necessarily because the",
    "start": "1476360",
    "end": "1482559"
  },
  {
    "text": "local buffer is never exposed outside the attacker can use this gadget to load arbitrary data to the register",
    "start": "1482559",
    "end": "1490480"
  },
  {
    "text": "file here in this demo I'm going to show how uh you can use this one of these",
    "start": "1490480",
    "end": "1497159"
  },
  {
    "text": "gadgets to leak data from the kernel memory so here the second Gadget is a",
    "start": "1497159",
    "end": "1502279"
  },
  {
    "text": "safe operation I put this into the Linux kernel with the help of a kernal Maur just for the sake of the",
    "start": "1502279",
    "end": "1509840"
  },
  {
    "text": "demonstration and then we can use GDs to attack this and leak arbitrary data from",
    "start": "1509840",
    "end": "1515640"
  },
  {
    "text": "the Linux Kel and here I chose to leak the Linux uh",
    "start": "1515640",
    "end": "1521279"
  },
  {
    "text": "Banner uh that's uh that's embedded into the Linux uh",
    "start": "1521279",
    "end": "1526679"
  },
  {
    "text": "binary",
    "start": "1526679",
    "end": "1529679"
  },
  {
    "text": "[Applause]",
    "start": "1533120",
    "end": "1542119"
  },
  {
    "text": "all right the last thing I'm going to discuss is how this impact the security of Intel sjs so far",
    "start": "1550440",
    "end": "1558320"
  },
  {
    "text": "I've demonstrated this that this attack can steal data from other users that could happen from other virtual machines",
    "start": "1558320",
    "end": "1565120"
  },
  {
    "text": "other processes but there's also this technology that promises extra security on Intel CPUs Intel",
    "start": "1565120",
    "end": "1572159"
  },
  {
    "text": "SGS is supposed to protect secure enclaves from other users and the operating system so any untrusted",
    "start": "1572159",
    "end": "1579440"
  },
  {
    "text": "software that runs on your computer whether it's the hypervisor whether it's the operating system is not supposed to",
    "start": "1579440",
    "end": "1584559"
  },
  {
    "text": "access the memory of this secure Enclave because it's protected by the CPU the",
    "start": "1584559",
    "end": "1589600"
  },
  {
    "text": "CPU does extra uh sanity checks extra access checks so you can access the",
    "start": "1589600",
    "end": "1594720"
  },
  {
    "text": "memory and the other feature of this is that the they use remote attestation to",
    "start": "1594720",
    "end": "1600559"
  },
  {
    "text": "ensure that the CPU and Enclave has the right platform and it has the right",
    "start": "1600559",
    "end": "1605679"
  },
  {
    "text": "Integrity so a remote user can trust that it's communicating to a cloud",
    "start": "1605679",
    "end": "1611440"
  },
  {
    "text": "computer that has the right CPU and the right Enclave one of the thing about this",
    "start": "1611440",
    "end": "1617080"
  },
  {
    "text": "technology is the OS is still managing the availability of the resources even though the OS can't access the",
    "start": "1617080",
    "end": "1623919"
  },
  {
    "text": "memory one thing the OS can do that people shown in the past is that a",
    "start": "1623919",
    "end": "1629120"
  },
  {
    "text": "malicious operating system can interrupt The Enclave frequently and also control",
    "start": "1629120",
    "end": "1634760"
  },
  {
    "text": "the execution of The Enclave at instruction level granularity there's this Tool uh one of the researchers in",
    "start": "1634760",
    "end": "1641840"
  },
  {
    "text": "the community yanul has developed a jle step that enable U you to basically",
    "start": "1641840",
    "end": "1647720"
  },
  {
    "text": "control the execution Enclave with single steps single",
    "start": "1647720",
    "end": "1652880"
  },
  {
    "text": "stepping so the idea is that we can attack this with combining GDs which S6",
    "start": "1652880",
    "end": "1658399"
  },
  {
    "text": "step the idea is that we execute The Enclave until a software register that",
    "start": "1658399",
    "end": "1663600"
  },
  {
    "text": "we want to Target have some Secrets imagine you know the binary layout of a program and you know at this stage it's",
    "start": "1663600",
    "end": "1669760"
  },
  {
    "text": "going to have have a secret that you want to steal then when we reach there",
    "start": "1669760",
    "end": "1675480"
  },
  {
    "text": "we're going to repeatedly cause context to the Intel SJ uh and then we this",
    "start": "1675480",
    "end": "1681200"
  },
  {
    "text": "Contex switch happen always with the same register State and as I mentioned earlier there are these register reor",
    "start": "1681200",
    "end": "1688320"
  },
  {
    "text": "operations that that are going to leak data to the gathered data sampling so every time we do a context s we can",
    "start": "1688320",
    "end": "1694320"
  },
  {
    "text": "execute the gather data sampling and leak leak the target register that we want to uh steal some secret from",
    "start": "1694320",
    "end": "1701679"
  },
  {
    "text": "it what did we do with this attack in the paper I I published the idea is that",
    "start": "1701679",
    "end": "1707480"
  },
  {
    "text": "we can steal the remote attestation key or the ceiling key of s and essentially",
    "start": "1707480",
    "end": "1712880"
  },
  {
    "text": "compromise all s enclaves and and the security of singes the idea is that",
    "start": "1712880",
    "end": "1719200"
  },
  {
    "text": "Intel s remote attestation protocol use some provisioning Enclave that is",
    "start": "1719200",
    "end": "1724640"
  },
  {
    "text": "deployed as part of SG software development kit and this proag Enclave",
    "start": "1724640",
    "end": "1730000"
  },
  {
    "text": "uh seal this seal the seal the key seal the attestation key using uh using S",
    "start": "1730000",
    "end": "1737640"
  },
  {
    "text": "itself so if we steal this stealing key we can also steal the attestation key and all of a sudden all s enclaves",
    "start": "1737640",
    "end": "1745240"
  },
  {
    "text": "cannot be trusted anymore so I looked at the sg's ceiling function uh binary this",
    "start": "1745240",
    "end": "1752799"
  },
  {
    "text": "function essentially call this other functions SG get key which is getting a key from the hardware it's a hardware",
    "start": "1752799",
    "end": "1759559"
  },
  {
    "text": "dried key and then that Hardware Drive key is passed through this a key expansion and when we look at this key",
    "start": "1759559",
    "end": "1766960"
  },
  {
    "text": "expansion function at the first three instructions the second instruction load",
    "start": "1766960",
    "end": "1772240"
  },
  {
    "text": "the master key to the xmm0 register here so to attack this we're going to use the",
    "start": "1772240",
    "end": "1779159"
  },
  {
    "text": "S step tool to bring the computation until this next instruction and here we",
    "start": "1779159",
    "end": "1786279"
  },
  {
    "text": "know that the xmm zero is going to have the master key master ceiling key and",
    "start": "1786279",
    "end": "1791880"
  },
  {
    "text": "then we mark this code page as non-executable so when the CPU go execute that next instruction is going",
    "start": "1791880",
    "end": "1798880"
  },
  {
    "text": "to hit an exception and then we use the gather data sampling to sample data from",
    "start": "1798880",
    "end": "1804000"
  },
  {
    "text": "that register register file that holds that register and then we handle the",
    "start": "1804000",
    "end": "1809320"
  },
  {
    "text": "exception and we go back we again face an exception and we keep doing that until we know that we have leaked all",
    "start": "1809320",
    "end": "1815600"
  },
  {
    "text": "the bytes of that that master key and that way we can compromise the SJ",
    "start": "1815600",
    "end": "1823159"
  },
  {
    "text": "attestation all right so what can we do about this attack so one of the common way to",
    "start": "1825600",
    "end": "1833399"
  },
  {
    "text": "generally mitigate this kind of attacks against shared shared microarchitectural buffers is to flush microarchitectural",
    "start": "1833399",
    "end": "1840159"
  },
  {
    "text": "buffers using some mechanism so right now there is no instruction sequence to",
    "start": "1840159",
    "end": "1846080"
  },
  {
    "text": "flush the vector register file and there has not been any indication that Intel is planning to make such an instruction",
    "start": "1846080",
    "end": "1853159"
  },
  {
    "text": "available to the software it's it's possible probably to to flush the register file with writing",
    "start": "1853159",
    "end": "1859120"
  },
  {
    "text": "some sort of software sequence let's say when you do context switching but I highly do not recommend that because",
    "start": "1859120",
    "end": "1865440"
  },
  {
    "text": "when I tried this it was not very efficient but also very unreliable because the CPU does some optimization",
    "start": "1865440",
    "end": "1872080"
  },
  {
    "text": "inside that there is a chance that this would not be a very effective mitigation also flushing micro arital",
    "start": "1872080",
    "end": "1878720"
  },
  {
    "text": "buffers generally does not mitigate attack when there is a hyper trading",
    "start": "1878720",
    "end": "1884120"
  },
  {
    "text": "situation where two Treads running on the CPU core at the same time time the option that is available the",
    "start": "1884120",
    "end": "1891159"
  },
  {
    "text": "Practical mitigation today is to apply Intel micro code update and this micro",
    "start": "1891159",
    "end": "1896480"
  },
  {
    "text": "code update prevent The Gather from speculatively forwarding data to the",
    "start": "1896480",
    "end": "1901720"
  },
  {
    "text": "following instruction which it comes with a cost of performance for workloads that use this instruction to access data",
    "start": "1901720",
    "end": "1909600"
  },
  {
    "text": "fast and the performance apparently according to Intel for some workload could be none for some workload could be",
    "start": "1909600",
    "end": "1916519"
  },
  {
    "text": "up to 50% person depending if they use this scatter instruction and depending if it's on the critical",
    "start": "1916519",
    "end": "1922760"
  },
  {
    "text": "path another important thing for mitigation is that people who use Intel SGS need to make sure that they check",
    "start": "1922760",
    "end": "1930399"
  },
  {
    "text": "the remote attestation is correctly because Intel is going to revoke the old",
    "start": "1930399",
    "end": "1935440"
  },
  {
    "text": "keys and recover The Trusted Computing base because every time there is a vulnerability like this all Intel SS are",
    "start": "1935440",
    "end": "1942240"
  },
  {
    "text": "going to be compromised and you have to again recover the trust and Computing base",
    "start": "1942240",
    "end": "1948279"
  },
  {
    "text": "another important note here is that uh Intel CPUs Intel performance courses",
    "start": "1948279",
    "end": "1953519"
  },
  {
    "text": "starting 12 Generations are not affected by this vulnerability um I don't think",
    "start": "1953519",
    "end": "1959080"
  },
  {
    "text": "this has been a choice in terms of security this has been just an accident of some design uh but another important",
    "start": "1959080",
    "end": "1966760"
  },
  {
    "text": "thing is if you update your CPU it's not vulnerable to this particular",
    "start": "1966760",
    "end": "1972240"
  },
  {
    "text": "vulnerability I mentioned that uh intels users need to to check the remote",
    "start": "1972240",
    "end": "1978159"
  },
  {
    "text": "attestation unfortunately this is not going to help until September 19 apparently all cheeks uh users are going",
    "start": "1978159",
    "end": "1986559"
  },
  {
    "text": "to be vulnerable until then until the TCB is",
    "start": "1986559",
    "end": "1991639"
  },
  {
    "text": "recovered so getting back to this timeline from 2022 to",
    "start": "1992080",
    "end": "1997720"
  },
  {
    "text": "2023 it was silent we didn't hear anything about this attacks so again we",
    "start": "1997720",
    "end": "2002799"
  },
  {
    "text": "have them again there's the downfall attack that leak data from the vector Reg file and we have now mitigations",
    "start": "2002799",
    "end": "2009679"
  },
  {
    "text": "that applies to all CPUs until the 11th generation and these CPUs are used",
    "start": "2009679",
    "end": "2015559"
  },
  {
    "text": "everywhere in the cloud in the desktop in laptops and everywhere in",
    "start": "2015559",
    "end": "2021799"
  },
  {
    "text": "conclusion uh we see that a single Hardware vulnerabilities can un undermine all security boundaries",
    "start": "2021799",
    "end": "2028799"
  },
  {
    "text": "including user and kernel cross process and cross VM and also ints GS",
    "start": "2028799",
    "end": "2035720"
  },
  {
    "text": "Enclave we we see that downfall attacks are practical and easy to exploit as I",
    "start": "2035720",
    "end": "2040799"
  },
  {
    "text": "demonstrated by the attack on AES also we see that despite all efforts",
    "start": "2040799",
    "end": "2048079"
  },
  {
    "text": "post the Meltdown attack in the past 5 years we still have CPUs that expose",
    "start": "2048079",
    "end": "2053638"
  },
  {
    "text": "users data and we see that complex optimization CPUs essentially introduce",
    "start": "2053639",
    "end": "2059720"
  },
  {
    "text": "new vulnerabilities and there are a lot of gaps in pre-silicon and post post",
    "start": "2059720",
    "end": "2065320"
  },
  {
    "text": "silicon validation for testing CPUs and how we test CPUs for",
    "start": "2065320",
    "end": "2071398"
  },
  {
    "text": "security so I would uh encourage people to ask their oems and providers to",
    "start": "2071399",
    "end": "2077878"
  },
  {
    "text": "provide microd fixes for this vulnerability and I have one",
    "start": "2077879",
    "end": "2086040"
  },
  {
    "text": "other demo here now that we have time and the idea is that um this is a attack",
    "start": "2086040",
    "end": "2093960"
  },
  {
    "text": "that doesn't even need to explicitly run on the same CPU core but you the",
    "start": "2093960",
    "end": "2099160"
  },
  {
    "text": "attacker Chan just spawn some CPU Treads and spy on all the text that are running",
    "start": "2099160",
    "end": "2105320"
  },
  {
    "text": "in the in the computer system with that I would like to conclude my talk",
    "start": "2105320",
    "end": "2111240"
  },
  {
    "text": "downfall uh exploit the physical register file and you can learn more",
    "start": "2111240",
    "end": "2116520"
  },
  {
    "text": "about it uh in the website there is proof of concept there is a Q&A and some other information thank",
    "start": "2116520",
    "end": "2124280"
  },
  {
    "text": "you",
    "start": "2125800",
    "end": "2128800"
  }
]