[
  {
    "text": "good afternoon and welcome to automation techniques in C++ reverse engineering in",
    "start": "0",
    "end": "5790"
  },
  {
    "text": "Laguna JKL presented by rolf rolous just a couple of quick notes don't forget to stop by",
    "start": "5790",
    "end": "12540"
  },
  {
    "text": "the business hall located in Mandalay Bay and blackhat Arsenal is also in the business hall on level 2 and then one",
    "start": "12540",
    "end": "19680"
  },
  {
    "text": "final reminder to make sure that all of your phones are silenced thank you very much",
    "start": "19680",
    "end": "25699"
  },
  {
    "text": "hello everybody thank you for coming to my talk this is about automation",
    "start": "30179",
    "end": "36660"
  },
  {
    "text": "techniques and C++ reverse engineering the genesis of this research is I was",
    "start": "36660",
    "end": "42719"
  },
  {
    "text": "doing research for an upcoming training class in C++ reverse engineering so I",
    "start": "42719",
    "end": "50010"
  },
  {
    "text": "was practicing statically reverse engineering some large C++ binaries and for the first few weeks of this I was",
    "start": "50010",
    "end": "57120"
  },
  {
    "text": "just using the same techniques that I've been using for the past 15 years and it",
    "start": "57120",
    "end": "63660"
  },
  {
    "text": "was it was working but it was a slow going tedious process I noticed I was spending 85 to 95 percent of my time creating",
    "start": "63660",
    "end": "72180"
  },
  {
    "text": "type information that is to say recreating structures and assigning",
    "start": "72180",
    "end": "77780"
  },
  {
    "text": "structures in the disassembly listing as well as setting types to hex raised",
    "start": "77780",
    "end": "83100"
  },
  {
    "text": "variables and because this was consuming so much of my time I decided maybe it's",
    "start": "83100",
    "end": "88200"
  },
  {
    "text": "a good idea to try to figure out can I automate these techniques so we're gonna",
    "start": "88200",
    "end": "93810"
  },
  {
    "text": "be focusing on dynamically allocated structures we're gonna be deriving metadata from run time accesses and then",
    "start": "93810",
    "end": "101729"
  },
  {
    "text": "collecting this data and exploiting it within Ida and hex rays there are two",
    "start": "101729",
    "end": "106890"
  },
  {
    "text": "primary analyses that I'm going to present one tracks accesses two structures and the other one is a",
    "start": "106890",
    "end": "114210"
  },
  {
    "text": "dynamic data flow analysis tracking data from allocation sites into function arguments so pictorially the big picture",
    "start": "114210",
    "end": "125549"
  },
  {
    "text": "behind why did I do this research in the first place what is this all about this",
    "start": "125549",
    "end": "131129"
  },
  {
    "text": "is your stereotypical see looking D compilation listing all of this naked size type pointer",
    "start": "131129",
    "end": "138760"
  },
  {
    "text": "dereferences frankly I find this stuff borderline unreadable or at least",
    "start": "138760",
    "end": "146280"
  },
  {
    "text": "requiring more effort than necessary so on the other hand when I switched to the",
    "start": "146280",
    "end": "152410"
  },
  {
    "text": "next slide the difference here is I've created a structure and I have set the",
    "start": "152410",
    "end": "158170"
  },
  {
    "text": "function prototype such that both arguments are that structure and it returns void and now you can see all of",
    "start": "158170",
    "end": "164830"
  },
  {
    "text": "those nasty casts disappear that this looks more or less what the original source code look like - names and",
    "start": "164830",
    "end": "172360"
  },
  {
    "text": "comments so type information is the difference between unreadable gibberish",
    "start": "172360",
    "end": "177640"
  },
  {
    "text": "and stuff that's Pleasant and easy to read but it's tedious to create and",
    "start": "177640",
    "end": "183070"
  },
  {
    "text": "apply all this type information to the database so we're gonna focus on automating these tasks so we're going to",
    "start": "183070",
    "end": "193480"
  },
  {
    "text": "be targeting each structure that is exercised through through runtime",
    "start": "193480",
    "end": "201670"
  },
  {
    "text": "runtime behavior we're gonna want to figure out the size of each structure the layout which is to say where the",
    "start": "201670",
    "end": "208750"
  },
  {
    "text": "fields are within the structure as well as what their sizes are every location",
    "start": "208750",
    "end": "213820"
  },
  {
    "text": "within the binary that accesses the structures that were interested in figure out type relationships between",
    "start": "213820",
    "end": "219610"
  },
  {
    "text": "fields of different structures and also we'll be interested in variable and function argument types and there's some",
    "start": "219610",
    "end": "226090"
  },
  {
    "text": "more experimental stuff also so once I",
    "start": "226090",
    "end": "231190"
  },
  {
    "text": "really got in the swing of applying these techniques I found that I was",
    "start": "231190",
    "end": "237040"
  },
  {
    "text": "applying more more type information to my database in a matter of days than I",
    "start": "237040",
    "end": "243370"
  },
  {
    "text": "had in six weeks of manual reverse engineering for the for one of the targets I've been looking at these",
    "start": "243370",
    "end": "249580"
  },
  {
    "text": "techniques helped me to recover about two 200 structures and sent about the",
    "start": "249580",
    "end": "255970"
  },
  {
    "text": "types for about six thousand variables and x-rays automatically and apply tens of thousands of structure offsets in the",
    "start": "255970",
    "end": "263770"
  },
  {
    "text": "disassembly listing all made or semi-automated fashion so",
    "start": "263770",
    "end": "272150"
  },
  {
    "text": "without further ado this is the first of the two analyses that I mentioned this",
    "start": "272150",
    "end": "277669"
  },
  {
    "text": "has to do with tracking accesses to structures so in this regard I was",
    "start": "277669",
    "end": "284449"
  },
  {
    "text": "inspired by existing academic work I remembered a paper that I had read many",
    "start": "284449",
    "end": "289460"
  },
  {
    "text": "years ago called Howard and there's a few other related works such as die",
    "start": "289460",
    "end": "296689"
  },
  {
    "text": "instruct for which source code is available so I had in mind that I wanted",
    "start": "296689",
    "end": "302719"
  },
  {
    "text": "to experiment with ideas similar to these however these ideas seem to have some",
    "start": "302719",
    "end": "308659"
  },
  {
    "text": "fundamental performance overhead associated with them so I wanted to experiment with them to see if I could",
    "start": "308659",
    "end": "314360"
  },
  {
    "text": "eliminate that as well as make the techniques a little bit more flexible so what follows is my journey along those",
    "start": "314360",
    "end": "321289"
  },
  {
    "text": "lines so on the high level the way these",
    "start": "321289",
    "end": "328189"
  },
  {
    "text": "tools work is they locate and hook the memory allocation functions malloc and",
    "start": "328189",
    "end": "335089"
  },
  {
    "text": "free but also things like realloc inside",
    "start": "335089",
    "end": "340219"
  },
  {
    "text": "of these hooks they record metadata about every memory allocation where it",
    "start": "340219",
    "end": "345680"
  },
  {
    "text": "was allocated from what's the allocated pointer how big is it then they run the",
    "start": "345680",
    "end": "351050"
  },
  {
    "text": "programs under a dynamic binary instrumentation log every access within one of these dynamically allocated",
    "start": "351050",
    "end": "357949"
  },
  {
    "text": "memory regions and finally this generates a lot of data which within post process to obtain information about",
    "start": "357949",
    "end": "364490"
  },
  {
    "text": "structures so I'll go through these steps individually step one is to locate",
    "start": "364490",
    "end": "372169"
  },
  {
    "text": "the memory allocators that you're interested in this might different depending upon the",
    "start": "372169",
    "end": "379039"
  },
  {
    "text": "scenario upon the slide here I have your memory allocator czar imported from some",
    "start": "379039",
    "end": "384979"
  },
  {
    "text": "other library via the import table but it might also be the case that maybe",
    "start": "384979",
    "end": "389990"
  },
  {
    "text": "there's a custom memory allocator in the binary which is a function so just locate the locate these things",
    "start": "389990",
    "end": "396940"
  },
  {
    "text": "number one number two hook them redirect them into our own memory allocation",
    "start": "396940",
    "end": "404770"
  },
  {
    "text": "functions again this might be as simple as overwriting a function pointer if it's an import or it might be more along",
    "start": "404770",
    "end": "411310"
  },
  {
    "text": "the lines of having to hook a function prologue if it's something that's contained in the binary the hooks",
    "start": "411310",
    "end": "419199"
  },
  {
    "text": "themselves are not that difficult for example looking at the hook for malloc",
    "start": "419199",
    "end": "425199"
  },
  {
    "text": "off to the left first thing it does is just call the original malloc two to",
    "start": "425199",
    "end": "430330"
  },
  {
    "text": "obtain whatever pointer would have been obtained by calling malloc then it calls this function remember which memorizes",
    "start": "430330",
    "end": "438039"
  },
  {
    "text": "the details for the memory allocation which is to say what the pointer is how big is it and where was it allocated",
    "start": "438039",
    "end": "445090"
  },
  {
    "text": "from and finally just return that back to the caller and the free hook is even simpler just discard the information",
    "start": "445090",
    "end": "452110"
  },
  {
    "text": "about that allocation and return back to the caller so this is all transparent to the application when it comes down to it",
    "start": "452110",
    "end": "459070"
  },
  {
    "text": "the application really doesn't care about its memory allocator it's pretty much just a function that it calls to",
    "start": "459070",
    "end": "464139"
  },
  {
    "text": "obtain pointers or to destroy pointers",
    "start": "464139",
    "end": "468720"
  },
  {
    "text": "so inside of the malloc hook the remember function is going to store allocation records which is the pointer",
    "start": "470190",
    "end": "478030"
  },
  {
    "text": "itself that was allocated the size and the r-va within the image that it was allocated so this is recorded relative",
    "start": "478030",
    "end": "485409"
  },
  {
    "text": "to the base address of the image so we don't have issues with a SLR and aggregating the results across multiple",
    "start": "485409",
    "end": "491710"
  },
  {
    "text": "runs it's going to store these",
    "start": "491710",
    "end": "498580"
  },
  {
    "text": "allocation records in some sort of data structure so later on we're going to",
    "start": "498580",
    "end": "504370"
  },
  {
    "text": "have to look up addresses within these allocations so we'll be looking up not",
    "start": "504370",
    "end": "509860"
  },
  {
    "text": "just by the base of the allocation but also anywhere within the allocations so for this purpose usually something like",
    "start": "509860",
    "end": "517060"
  },
  {
    "text": "a binary tree is preferred AVL trees are good here they have strict balancing",
    "start": "517060",
    "end": "523570"
  },
  {
    "text": "requirements whereas red-black trees work but their lookups are a little slower than",
    "start": "523570",
    "end": "529240"
  },
  {
    "text": "AVL trees I recently realized you could use something along the lines of not",
    "start": "529240",
    "end": "534460"
  },
  {
    "text": "quite a hash table but sort of segment the address is the same way that the page table translation process does it",
    "start": "534460",
    "end": "541890"
  },
  {
    "text": "that's yet to be explored so remember adds items into this map and",
    "start": "541890",
    "end": "549990"
  },
  {
    "text": "forget removes them okay so that's the",
    "start": "549990",
    "end": "556900"
  },
  {
    "text": "part where we hook the memory allocator and record allocation memory to a metadata now we're going to find",
    "start": "556900",
    "end": "564580"
  },
  {
    "text": "accesses to these allocations so the",
    "start": "564580",
    "end": "570130"
  },
  {
    "text": "next step in these tools is to run the programs under dynamic binary instrumentation and provide whatever",
    "start": "570130",
    "end": "577210"
  },
  {
    "text": "inputs you need to drive execution throughout the program you know if you're running Adobe Reader or something",
    "start": "577210",
    "end": "584950"
  },
  {
    "text": "this means provide a PDF for it to open or something along these lines and then",
    "start": "584950",
    "end": "590470"
  },
  {
    "text": "we're going to log accesses to the allocated structures and record it so",
    "start": "590470",
    "end": "599380"
  },
  {
    "text": "via dbi we are going to insert callback routines on every memory access",
    "start": "599380",
    "end": "607350"
  },
  {
    "text": "so the callback routine is going to be given the address that is to be accessed",
    "start": "609570",
    "end": "616720"
  },
  {
    "text": "by the memory access it's going to take that look it up within the map that",
    "start": "616720",
    "end": "622330"
  },
  {
    "text": "we're that we keep the allocation metadata in and if we find the address",
    "start": "622330",
    "end": "628209"
  },
  {
    "text": "within one of the allocation records that means we have just discovered a memory access to one of the dynamically",
    "start": "628209",
    "end": "634779"
  },
  {
    "text": "allocated memory regions so we're going to log that which is to say let's say",
    "start": "634779",
    "end": "640120"
  },
  {
    "text": "this instruction was observed accessing that particular address ending in 28 and",
    "start": "640120",
    "end": "646140"
  },
  {
    "text": "we look that address up in the map and we find that we have that same address",
    "start": "646140",
    "end": "651160"
  },
  {
    "text": "ending in 0-0 with the size of 80 hexadecimal having been allocated at",
    "start": "651160",
    "end": "656230"
  },
  {
    "text": "that RBA so now we just log the details of that access where the allocation came from",
    "start": "656230",
    "end": "662860"
  },
  {
    "text": "how big the allocation was where'd the instruction that access it was how big the access was we're within the",
    "start": "662860",
    "end": "669430"
  },
  {
    "text": "structure was it accessing and was it a read or write so we just run the program",
    "start": "669430",
    "end": "676389"
  },
  {
    "text": "and collect up all of this metadata and",
    "start": "676389",
    "end": "681779"
  },
  {
    "text": "afterwards we have a enormous text file which we then take and post process to",
    "start": "681779",
    "end": "688750"
  },
  {
    "text": "recover higher-level information so",
    "start": "688750",
    "end": "696399"
  },
  {
    "text": "we'll have information set logged through the proceeding process such as",
    "start": "696399",
    "end": "701529"
  },
  {
    "text": "the following the table that we see on the slide here so the first step is to",
    "start": "701529",
    "end": "709779"
  },
  {
    "text": "take these things and just segregate them by the allocation site just take",
    "start": "709779",
    "end": "716199"
  },
  {
    "text": "everything that was allocated from the same location and aggregate all of those things together and at this point if we",
    "start": "716199",
    "end": "727750"
  },
  {
    "text": "happen to know for some reason a priori that two sites allocate the same data",
    "start": "727750",
    "end": "733779"
  },
  {
    "text": "type that we can at this point just merge their data together and now we can",
    "start": "733779",
    "end": "741819"
  },
  {
    "text": "take this information and rebuild structures from it so sort for any given",
    "start": "741819",
    "end": "747100"
  },
  {
    "text": "allocation take take the accesses that we observed sort the offsets at which",
    "start": "747100",
    "end": "753370"
  },
  {
    "text": "the accesses took place and remove duplicates and then simply convert those",
    "start": "753370",
    "end": "760449"
  },
  {
    "text": "into structured declarations choose C data types of the appropriate size and",
    "start": "760449",
    "end": "768279"
  },
  {
    "text": "lay them out in the sequence in which they were observed so that seems pretty easy a brief digression in fact through",
    "start": "768279",
    "end": "780160"
  },
  {
    "text": "this process we don't just discover a flat list of fields but we can discover nested structures contained within other",
    "start": "780160",
    "end": "787240"
  },
  {
    "text": "structures so for example if we observed the access",
    "start": "787240",
    "end": "794000"
  },
  {
    "text": "we see on the top of the slide here you can see the x86 instruction has EA X + 8",
    "start": "794000",
    "end": "800080"
  },
  {
    "text": "whereas the recorded accent offset is 28 so the only way that's possible is if at",
    "start": "800080",
    "end": "808010"
  },
  {
    "text": "that at the time that we logged this data that EA X was pointing plus 20 hexadecimal into that particular",
    "start": "808010",
    "end": "814610"
  },
  {
    "text": "allocation site so that means the program is passing around pointers plus",
    "start": "814610",
    "end": "819650"
  },
  {
    "text": "20 hexadecimal into that allocation and what that means in brief is that there's a structure that begins at plus 20",
    "start": "819650",
    "end": "826580"
  },
  {
    "text": "hexadecimal so we can use this information to recover nested structures",
    "start": "826580",
    "end": "831920"
  },
  {
    "text": "not just a flat list of fields okay so",
    "start": "831920",
    "end": "839920"
  },
  {
    "text": "the picture so far was a little simplified compared to real life as it",
    "start": "839920",
    "end": "845810"
  },
  {
    "text": "happens there is some noise some imperfection in the data some of its",
    "start": "845810",
    "end": "851780"
  },
  {
    "text": "from natural causes in the source code some of it comes from compiler optimizations we'll talk briefly about",
    "start": "851780",
    "end": "857360"
  },
  {
    "text": "those and what we do about them so first",
    "start": "857360",
    "end": "864170"
  },
  {
    "text": "of all it's perfectly legal to cast integer data types from one size to the",
    "start": "864170",
    "end": "871070"
  },
  {
    "text": "other so we might be dealing with a situation where we have a structure in the source code which has a 32-bit",
    "start": "871070",
    "end": "877640"
  },
  {
    "text": "integer and then if some access to that structure is actually only using 16 bits",
    "start": "877640",
    "end": "883790"
  },
  {
    "text": "worth of it we'll see what's in the middle column which is the use of a 16-bit register or for example we could",
    "start": "883790",
    "end": "891740"
  },
  {
    "text": "also just cast to the low eight bits of that of that structure of that field and so we'll see the use of an 8-bit",
    "start": "891740",
    "end": "898460"
  },
  {
    "text": "register and so this casting might give",
    "start": "898460",
    "end": "904760"
  },
  {
    "text": "us multiple different sized accesses to the same location in the structure which",
    "start": "904760",
    "end": "910220"
  },
  {
    "text": "leads to ambiguity about what field actually is supposed to be at that",
    "start": "910220",
    "end": "915650"
  },
  {
    "text": "location so my solution to this and most of most of these related issues that",
    "start": "915650",
    "end": "921740"
  },
  {
    "text": "we'll see is I just use the ax that we generated at runtime and then",
    "start": "921740",
    "end": "927460"
  },
  {
    "text": "choose the configuration that agrees with the largest number of observed data points and this turns out to work very",
    "start": "927460",
    "end": "934060"
  },
  {
    "text": "well for most of these issues another",
    "start": "934060",
    "end": "941140"
  },
  {
    "text": "issue has to do with compiler optimizations here again we're assuming there's a 32-bit integer contained",
    "start": "941140",
    "end": "947650"
  },
  {
    "text": "within a structure and here we're testing it against the 32-bit constant 40 hexadecimal so the natural way to",
    "start": "947650",
    "end": "955060"
  },
  {
    "text": "implement that an assembly language would be the topmost assembly language instruction which is treat that location",
    "start": "955060",
    "end": "960610"
  },
  {
    "text": "as a D word and encode a D word size constant as the last four bytes of the",
    "start": "960610",
    "end": "966490"
  },
  {
    "text": "instruction but actually it's perfectly legal to convert the instruction into a",
    "start": "966490",
    "end": "972670"
  },
  {
    "text": "bite-sized access instead where since the only nonzero byte within that 32-bit",
    "start": "972670",
    "end": "978910"
  },
  {
    "text": "constant that we're adding in is the lowest one and just take that and turn it into an 8-bit access instead so again",
    "start": "978910",
    "end": "986920"
  },
  {
    "text": "this leads to ambiguity about what is the size of the field at that location we might see multiple size accesses",
    "start": "986920",
    "end": "996000"
  },
  {
    "text": "highly related but slightly different is this what if on the last slide",
    "start": "997230",
    "end": "1006270"
  },
  {
    "text": "instead of ending with 40 hexadecimal we ended with 400 hexadecimal so this this",
    "start": "1006270",
    "end": "1014010"
  },
  {
    "text": "gives rise to a similar optimization opportunity except since the 400",
    "start": "1014010",
    "end": "1021630"
  },
  {
    "text": "hexadecimal only has a nonzero byte at +1 into the constant that we can still",
    "start": "1021630",
    "end": "1028800"
  },
  {
    "text": "convert it into a byte size access exactly as we did on the previous slide but we have to increment the address",
    "start": "1028800",
    "end": "1035819"
  },
  {
    "text": "that we're accessing by 1 which is why you see the es I plus 1 in the second assembly language instruction so now it",
    "start": "1035819",
    "end": "1042900"
  },
  {
    "text": "looks like we have this field within the structure that's not really there that just sort of that access arose as a",
    "start": "1042900",
    "end": "1048780"
  },
  {
    "text": "result of a compiler optimization",
    "start": "1048780",
    "end": "1052730"
  },
  {
    "text": "another another issue is called store aggregation this is when you have",
    "start": "1055519",
    "end": "1061220"
  },
  {
    "text": "multiple smaller writes all targeting adjacent fields that the compiler can",
    "start": "1061220",
    "end": "1067470"
  },
  {
    "text": "take them and aggregate them into one larger write in this case we have two",
    "start": "1067470",
    "end": "1073830"
  },
  {
    "text": "boolean variables right next to one another in the structure and we're assigning both of them to zero so rather",
    "start": "1073830",
    "end": "1080309"
  },
  {
    "text": "than generating two instructions that move one byte at a time the compiler can",
    "start": "1080309",
    "end": "1085769"
  },
  {
    "text": "detect that these things are right next to one another and it said write one word at a time to override both of those",
    "start": "1085769",
    "end": "1091440"
  },
  {
    "text": "fields at the same time so whereas the previous optimizations that we saw can",
    "start": "1091440",
    "end": "1096659"
  },
  {
    "text": "lead to smaller accesses at a given location this one can actually lead to bigger accesses at a given location",
    "start": "1096659",
    "end": "1104509"
  },
  {
    "text": "another source of imprecision is bulk copies and assignment things like mem",
    "start": "1107389",
    "end": "1113309"
  },
  {
    "text": "set and mem copy so off to the left we see a structure with a fairly intricate",
    "start": "1113309",
    "end": "1120200"
  },
  {
    "text": "configuration of fields within the first eight byte there are two 8-bit sized",
    "start": "1120200",
    "end": "1125820"
  },
  {
    "text": "fields one 16-bit field and then the 32-bit field and whereas memset if we",
    "start": "1125820",
    "end": "1132000"
  },
  {
    "text": "set this structure to zero the code that might be generated simply overwrites 64",
    "start": "1132000",
    "end": "1138000"
  },
  {
    "text": "bits at a time of zeroes oblivious to whatever the layout of the structure is",
    "start": "1138000",
    "end": "1143669"
  },
  {
    "text": "just right bulk data so for all of the",
    "start": "1143669",
    "end": "1152759"
  },
  {
    "text": "issues so far my solution has just been to count the number of accesses we see",
    "start": "1152759",
    "end": "1159049"
  },
  {
    "text": "to given at given sizes and offsets within the structure and then just choose the configuration that agrees",
    "start": "1159049",
    "end": "1165600"
  },
  {
    "text": "with the largest number of accesses and this works very well plus its principal we don't have to make guesses we just",
    "start": "1165600",
    "end": "1171960"
  },
  {
    "text": "try to optimize according to the data that we see now there are two more that",
    "start": "1171960",
    "end": "1179190"
  },
  {
    "text": "are a little uglier unions for example allows us to statically assign different",
    "start": "1179190",
    "end": "1186539"
  },
  {
    "text": "types and different sizes to the same location within a structure so we might have an integer",
    "start": "1186539",
    "end": "1192700"
  },
  {
    "text": "and a character pointer let's say in a union that means it's perfectly legal for us to see differently size access to",
    "start": "1192700",
    "end": "1199630"
  },
  {
    "text": "the same field because there are in fact differently sized types being stored at that location so my solution of this one",
    "start": "1199630",
    "end": "1206770"
  },
  {
    "text": "is the same as before and it's not a good solution it's basically to just ignore the fact that unions exist unions",
    "start": "1206770",
    "end": "1213310"
  },
  {
    "text": "are kind of thorny honestly and finally array accesses produce these",
    "start": "1213310",
    "end": "1221260"
  },
  {
    "text": "offsets non-constant offsets area of this RB x x for within the memory access",
    "start": "1221260",
    "end": "1227140"
  },
  {
    "text": "so I have it in mind in the future I have some ideas for what to do about this but for now I'm just not handling",
    "start": "1227140",
    "end": "1232780"
  },
  {
    "text": "this case at all I just punt anytime we see in access with a non-constant location just thrown away",
    "start": "1232780",
    "end": "1238380"
  },
  {
    "text": "now that's not a real solution obviously",
    "start": "1238380",
    "end": "1242640"
  },
  {
    "text": "ok so thus far I've largely been talking about the existing dbi based solutions",
    "start": "1247200",
    "end": "1254290"
  },
  {
    "text": "as well as some of my solutions to the issues that I saw coming from using",
    "start": "1254290",
    "end": "1260020"
  },
  {
    "text": "solutions like that one in actuality I did not use D bi for my implementation",
    "start": "1260020",
    "end": "1265420"
  },
  {
    "text": "of this idea there are several reasons for this",
    "start": "1265420",
    "end": "1270460"
  },
  {
    "text": "first one is I am simply not an expert when it comes to D bi and I anticipated",
    "start": "1270460",
    "end": "1275620"
  },
  {
    "text": "there would be a learning curve to it and I wanted to see if the idea would work immediately so I kind of wanted to",
    "start": "1275620",
    "end": "1282640"
  },
  {
    "text": "come up with a quick implementation but in fact there are some more principal",
    "start": "1282640",
    "end": "1288160"
  },
  {
    "text": "and realistic reasons to look for solutions other than D bi so although",
    "start": "1288160",
    "end": "1293290"
  },
  {
    "text": "the D bi solution is comprehensive and fully automated it also requires that",
    "start": "1293290",
    "end": "1298330"
  },
  {
    "text": "you instrument every memory access that takes place throughout runtime execution means every time there's a memory access",
    "start": "1298330",
    "end": "1305950"
  },
  {
    "text": "we're going to insert a lookup into a map so this is a fairly heavyweight application of D bi and the larger the",
    "start": "1305950",
    "end": "1313900"
  },
  {
    "text": "overhead that means the harder it is to interact with the application the harder it is to interact with the app",
    "start": "1313900",
    "end": "1319460"
  },
  {
    "text": "that means the less coverage we're able to drive and the less coverage there is means the fewer the a smaller amount of",
    "start": "1319460",
    "end": "1327380"
  },
  {
    "text": "information we're able to observe about the structure accesses and furthermore",
    "start": "1327380",
    "end": "1332810"
  },
  {
    "text": "no matter how we might try to optimize a dbi implementation that fundamentally",
    "start": "1332810",
    "end": "1338120"
  },
  {
    "text": "the way the solution works is by instrumenting every memory access so there are real limitations about how far",
    "start": "1338120",
    "end": "1345140"
  },
  {
    "text": "we can go with optimization so I just",
    "start": "1345140",
    "end": "1353810"
  },
  {
    "text": "described the fundamental overhead from the approach itself there's also overhead with regards to",
    "start": "1353810",
    "end": "1359750"
  },
  {
    "text": "having to track every allocation site within the program so we're in we're",
    "start": "1359750",
    "end": "1366140"
  },
  {
    "text": "inserting these map lookups all over the place and the more allocation sites that we're tracking at any given time that",
    "start": "1366140",
    "end": "1373900"
  },
  {
    "text": "more expensive of these map lookups are going to be so I wanted to know",
    "start": "1373900",
    "end": "1380620"
  },
  {
    "text": "experiment with maybe maybe tracking less data at any given time could lead",
    "start": "1380620",
    "end": "1386990"
  },
  {
    "text": "to better performance and finally these dbi based solutions are sort of just",
    "start": "1386990",
    "end": "1394340"
  },
  {
    "text": "these like monolithic black box we're put in program press button get out",
    "start": "1394340",
    "end": "1399800"
  },
  {
    "text": "structure configurations and I'm a professional reverse engineer maybe I can figure out better uses to which to",
    "start": "1399800",
    "end": "1406430"
  },
  {
    "text": "put that data recovering structures is cool and all but maybe there's more there's more I can do with the data",
    "start": "1406430",
    "end": "1412040"
  },
  {
    "text": "perhaps so I wanted to experiment how could I make this an interactive tool",
    "start": "1412040",
    "end": "1417320"
  },
  {
    "text": "that reverse engineers could use in a friendly fashion so the ability to to",
    "start": "1417320",
    "end": "1424310"
  },
  {
    "text": "choose parts of the program that we're interested in and how do I present the results to the user in a way that's most",
    "start": "1424310",
    "end": "1430280"
  },
  {
    "text": "beneficial to them while they're reverse engineering so right roughly those are",
    "start": "1430280",
    "end": "1439220"
  },
  {
    "text": "the directions that I'm going to explore trying to replace dbi with some other form of tracking accesses to structures",
    "start": "1439220",
    "end": "1446150"
  },
  {
    "text": "and then allow more flexibility in what we're tracking and how we're",
    "start": "1446150",
    "end": "1451560"
  },
  {
    "text": "tracking it performance optimize everything and try to make good use of the data be as friendly as we can make",
    "start": "1451560",
    "end": "1458580"
  },
  {
    "text": "the reverse engineers lives easier so my",
    "start": "1458580",
    "end": "1468450"
  },
  {
    "text": "first order of business was to figure out some way to track accesses to allocated data without using dynamic",
    "start": "1468450",
    "end": "1476340"
  },
  {
    "text": "binary instrumentation and brainstorming about this my first idea was maybe I can",
    "start": "1476340",
    "end": "1483480"
  },
  {
    "text": "use the x86 hardware read and write debug breakpoints so for example every",
    "start": "1483480",
    "end": "1490950"
  },
  {
    "text": "time I call to malloc takes place just set read and write breakpoints across the entire structure so this isn't a",
    "start": "1490950",
    "end": "1497070"
  },
  {
    "text": "good idea it does not work because we simply don't have enough breakpoints x86",
    "start": "1497070",
    "end": "1503280"
  },
  {
    "text": "only gives us four breakpoints which means a total of 32 bytes of memory that",
    "start": "1503280",
    "end": "1508560"
  },
  {
    "text": "we can track and that's not even enough to cover one small size structure that",
    "start": "1508560",
    "end": "1517170"
  },
  {
    "text": "said though although the breakpoint idea does not work it does have this interesting feature where it sort of is",
    "start": "1517170",
    "end": "1524310"
  },
  {
    "text": "fundamentally different in how it tracks the accesses whereas with the DPI solution we have to insert",
    "start": "1524310",
    "end": "1530900"
  },
  {
    "text": "instrumentation all over the place and dig out the memory accesses by looking",
    "start": "1530900",
    "end": "1537660"
  },
  {
    "text": "them up every time in the map with the breakpoint approach we can just specify here's the memory locations that were",
    "start": "1537660",
    "end": "1543690"
  },
  {
    "text": "interested in and then the processor effectively gives us callbacks in the form of debug exceptions telling us when",
    "start": "1543690",
    "end": "1549960"
  },
  {
    "text": "that memory is accesses so I wanted a solution with that kind of feature to it",
    "start": "1549960",
    "end": "1555480"
  },
  {
    "text": "where I didn't have to instrument everything I could just sort of specify what it was that I wanted to track but",
    "start": "1555480",
    "end": "1563340"
  },
  {
    "text": "fundamentally x86 hardware breakpoints can't do the job for us because we simply don't have enough of them on an",
    "start": "1563340",
    "end": "1569220"
  },
  {
    "text": "architectural level so then I remembered there was a command in the kernel",
    "start": "1569220",
    "end": "1575610"
  },
  {
    "text": "debugger soft dice and it's also been implemented in a couple of other tools",
    "start": "1575610",
    "end": "1580830"
  },
  {
    "text": "in the meantime called breakpoint on memory range which allowed you to set as memory as many",
    "start": "1580830",
    "end": "1587640"
  },
  {
    "text": "memory breakpoints as you wanted and of as large size as you wanted you can",
    "start": "1587640",
    "end": "1593880"
  },
  {
    "text": "implement this in either user mode or kernel mode so Ida also implements this",
    "start": "1593880",
    "end": "1599310"
  },
  {
    "text": "as does Olli debug so that sounds promising let's review briefly how that works",
    "start": "1599310",
    "end": "1607340"
  },
  {
    "text": "fundamentally the implementation has to do with virtual memory and on-demand paging so in a demand paged environment",
    "start": "1609020",
    "end": "1620060"
  },
  {
    "text": "processes appear to have a large address space but in reality they only consume",
    "start": "1620060",
    "end": "1626190"
  },
  {
    "text": "as much memory as there are physical pages assigned to their virtual pages so",
    "start": "1626190",
    "end": "1632190"
  },
  {
    "text": "for example on this diagram that the virtual page number 4 does not have a corresponding physical mapping so it",
    "start": "1632190",
    "end": "1638070"
  },
  {
    "text": "doesn't have to consume a physical page for that for that virtual page the page",
    "start": "1638070",
    "end": "1647640"
  },
  {
    "text": "table dictates the translations between",
    "start": "1647640",
    "end": "1652920"
  },
  {
    "text": "virtual and physical pages basically specifies the high bits of the virtual page and the high bits of the",
    "start": "1652920",
    "end": "1660060"
  },
  {
    "text": "corresponding physical page with some flags and also this present bit at the bottom which we'll talk about again in a",
    "start": "1660060",
    "end": "1666570"
  },
  {
    "text": "minute as the program requested the",
    "start": "1666570",
    "end": "1672390"
  },
  {
    "text": "operating system can allocate more memory and basically add new physical",
    "start": "1672390",
    "end": "1678180"
  },
  {
    "text": "virtual to physical mappings on the fly",
    "start": "1678180",
    "end": "1682700"
  },
  {
    "text": "at some point if the process starts running out of memory then the operating",
    "start": "1684650",
    "end": "1691380"
  },
  {
    "text": "system can go around and start reclaiming memory so this makes use of",
    "start": "1691380",
    "end": "1696420"
  },
  {
    "text": "the present flag at the bottom of the page table entry for that corresponding virtual to physical mapping so the",
    "start": "1696420",
    "end": "1704550"
  },
  {
    "text": "operating system just writes the cott that copy of that physical page to disk sets the present bit to 0 and the page",
    "start": "1704550",
    "end": "1711210"
  },
  {
    "text": "table entry and then later on when the program goes",
    "start": "1711210",
    "end": "1717960"
  },
  {
    "text": "to try to access that page since the present bit is not set this",
    "start": "1717960",
    "end": "1723210"
  },
  {
    "text": "results in an exception being generated the the the operating system kernel catches that page fault exception",
    "start": "1723210",
    "end": "1730520"
  },
  {
    "text": "realizes that the exception arises from a member a page having been reclaimed",
    "start": "1730520",
    "end": "1735840"
  },
  {
    "text": "and written to disk reads the page off the disk and then sets the present flag",
    "start": "1735840",
    "end": "1740910"
  },
  {
    "text": "to 0 to 1 again and then continues execution so all of this happens in a",
    "start": "1740910",
    "end": "1746790"
  },
  {
    "text": "transparent fashion the user mode application doesn't even realize that anything has happened the kernel just",
    "start": "1746790",
    "end": "1752670"
  },
  {
    "text": "takes care of all that in the background",
    "start": "1752670",
    "end": "1756350"
  },
  {
    "text": "so that's the background that this is how the BPR memory breakpoint feature",
    "start": "1759440",
    "end": "1765780"
  },
  {
    "text": "works so we're going to make use of this nonpresent mechanism where for pages",
    "start": "1765780",
    "end": "1772920"
  },
  {
    "text": "that were interested in tracking we set the present flag to to false that's",
    "start": "1772920",
    "end": "1779370"
  },
  {
    "text": "going to give us exceptions when we try to add when the application tries to",
    "start": "1779370",
    "end": "1784500"
  },
  {
    "text": "access the pages with if we find an access to what we're interested in we'll",
    "start": "1784500",
    "end": "1790530"
  },
  {
    "text": "log it other than continue execution in any case so here's an animation of how",
    "start": "1790530",
    "end": "1798420"
  },
  {
    "text": "this process plays out in real-time so let's assume that this first instruction here is going to access memory so let's",
    "start": "1798420",
    "end": "1807180"
  },
  {
    "text": "assume that we have marked this page at eb x + 4 as non present so then when the",
    "start": "1807180",
    "end": "1815730"
  },
  {
    "text": "instruction goes to execute because the memory is non present that processor",
    "start": "1815730",
    "end": "1822300"
  },
  {
    "text": "generates a page fault exception now we have installed an exception Handler and",
    "start": "1822300",
    "end": "1828570"
  },
  {
    "text": "we're able to inspect these inception exceptions that come in so first we see",
    "start": "1828570",
    "end": "1834690"
  },
  {
    "text": "was this exception our fault which is to say is it a page fault that arose because we set the present flag to false",
    "start": "1834690",
    "end": "1841290"
  },
  {
    "text": "on some page so if it wasn't we just pass it off the next exception handler",
    "start": "1841290",
    "end": "1846300"
  },
  {
    "text": "in the chain if it we process it so if it was our fault now",
    "start": "1846300",
    "end": "1855850"
  },
  {
    "text": "we are in the exact same position as the dbi based tools are where at this very moment now we know that this particular",
    "start": "1855850",
    "end": "1862750"
  },
  {
    "text": "instruction tried to access some allocated region that we're interested in so right here this is how we replace",
    "start": "1862750",
    "end": "1871060"
  },
  {
    "text": "D bi is log right in the in the page fault handler the details of where the",
    "start": "1871060",
    "end": "1877030"
  },
  {
    "text": "allocation came from as well as what instruction accessed it so now we need",
    "start": "1877030",
    "end": "1883480"
  },
  {
    "text": "to let the process a continued execution but it's a little tricky so we save the",
    "start": "1883480",
    "end": "1889000"
  },
  {
    "text": "address of defaulting instruction we mark the page as present and before we",
    "start": "1889000",
    "end": "1898990"
  },
  {
    "text": "continue execution we have to have some way of making sure that we get control",
    "start": "1898990",
    "end": "1904780"
  },
  {
    "text": "again if we were to simply mark the page as non present and then just let the application run then we would basically",
    "start": "1904780",
    "end": "1911350"
  },
  {
    "text": "have one-shot breakpoints we want to be able to track subsequent accesses to the",
    "start": "1911350",
    "end": "1916540"
  },
  {
    "text": "same allocation so to do that we set the x86 trap flag which is the same",
    "start": "1916540",
    "end": "1922510"
  },
  {
    "text": "mechanism that debuggers use to implement single stepping if the trap flag is set at the end of an instruction",
    "start": "1922510",
    "end": "1928780"
  },
  {
    "text": "it causes the processor to generate a single step exception after it executes",
    "start": "1928780",
    "end": "1935610"
  },
  {
    "text": "so then we resume execution now back",
    "start": "1935610",
    "end": "1941290"
  },
  {
    "text": "trying to execute the program again the structure access succeeds this time because that memory is marked as present",
    "start": "1941290",
    "end": "1949020"
  },
  {
    "text": "but since we set the trap flag that now the subsequent instruction false so back",
    "start": "1949020",
    "end": "1958630"
  },
  {
    "text": "in our exception handler we see if this is a single step exception is it a single step exception immediately after",
    "start": "1958630",
    "end": "1965410"
  },
  {
    "text": "the last instruction that we saw ie is this our fault if not pass it off the next Handler and the chain otherwise",
    "start": "1965410",
    "end": "1970960"
  },
  {
    "text": "process it so now we make the page non present again so that on subsequent",
    "start": "1970960",
    "end": "1977320"
  },
  {
    "text": "accesses will catch the we'll catch them and then just resume execution so that",
    "start": "1977320",
    "end": "1988630"
  },
  {
    "text": "there is the architecture that I came up with for replacing dbi in tracking",
    "start": "1988630",
    "end": "1993820"
  },
  {
    "text": "structure accesses where I install this exception Handler and it's has it",
    "start": "1993820",
    "end": "2000570"
  },
  {
    "text": "activates it runs inside of each thread that is associated with the ordinary",
    "start": "2000570",
    "end": "2005670"
  },
  {
    "text": "program so each thread just catches these page faults implements the exception logic and stores these",
    "start": "2005670",
    "end": "2012870"
  },
  {
    "text": "accesses into a ring buffer and then I have a controller thread which just periodically pulls the ring buffers from",
    "start": "2012870",
    "end": "2019350"
  },
  {
    "text": "the other threads and D duplicates the data and logs it to disk so since the",
    "start": "2019350",
    "end": "2029460"
  },
  {
    "text": "last time I gave this presentation I had a few optimization ideas and some",
    "start": "2029460",
    "end": "2034500"
  },
  {
    "text": "members of my prior audience also had some suggestions for me one person",
    "start": "2034500",
    "end": "2040740"
  },
  {
    "text": "suggested that having two single step inside of the page fault handler is slow",
    "start": "2040740",
    "end": "2047550"
  },
  {
    "text": "because this results in an extra user to kernel mode transition so if I were to",
    "start": "2047550",
    "end": "2052590"
  },
  {
    "text": "implement a little emulator to mimic the effects of the instructions rather than",
    "start": "2052590",
    "end": "2058590"
  },
  {
    "text": "simply letting it execute and having to incur this extra user kernel transition overhead that I might get a performance",
    "start": "2058590",
    "end": "2065790"
  },
  {
    "text": "boost and he was right it was a nice 40 percent performance increase some other",
    "start": "2065790",
    "end": "2072240"
  },
  {
    "text": "people suggested that I could use guard pages instead of setting the pages as",
    "start": "2072240",
    "end": "2077790"
  },
  {
    "text": "non presence guard pages has have this advantage of number one the operating",
    "start": "2077790",
    "end": "2085320"
  },
  {
    "text": "system has optimized pathways for them because it uses guard pages internally and number two that what a guard page",
    "start": "2085320",
    "end": "2094080"
  },
  {
    "text": "exception takes place that the operating system automatically marks the page as",
    "start": "2094080",
    "end": "2099270"
  },
  {
    "text": "present so this eliminates another user kernel transition where we would have to call virtual protect to mark the page as",
    "start": "2099270",
    "end": "2106770"
  },
  {
    "text": "present before we could single step that was another reasonable speed up and I",
    "start": "2106770",
    "end": "2112560"
  },
  {
    "text": "did some standard optimization tricks with like forcing things to reside on different cores my",
    "start": "2112560",
    "end": "2118620"
  },
  {
    "text": "lager thread should have low priority and it should be on the bad course and give all the good course with high",
    "start": "2118620",
    "end": "2124110"
  },
  {
    "text": "priority to the the application itself and then I implemented a second version of the x86 emulator based on JIT so",
    "start": "2124110",
    "end": "2132600"
  },
  {
    "text": "these numbers come from my laptop that was the trail of performance on my desktop it's more like 15.6 million page",
    "start": "2132600",
    "end": "2139620"
  },
  {
    "text": "faults per minute million structure accesses it's pretty good so another",
    "start": "2139620",
    "end": "2149550"
  },
  {
    "text": "major optimization idea I had had to do with only tracking specific allocation",
    "start": "2149550",
    "end": "2154950"
  },
  {
    "text": "sites so it's heretofore I've shown you how these dbi tools work and the basic",
    "start": "2154950",
    "end": "2161700"
  },
  {
    "text": "idea behind my replacement for it but I haven't really told you how we apply this page fault based memory",
    "start": "2161700",
    "end": "2167730"
  },
  {
    "text": "tracking so we could either go the dbi route and just track every allocation in",
    "start": "2167730",
    "end": "2174060"
  },
  {
    "text": "the program or perhaps we could track only certain allocations so if we're",
    "start": "2174060",
    "end": "2181050"
  },
  {
    "text": "going the dbi route of just track everything in the program all of them on execution then it's pretty simple to",
    "start": "2181050",
    "end": "2187350"
  },
  {
    "text": "accommodate that we just add a breakpoint a base on paging in the",
    "start": "2187350",
    "end": "2193170"
  },
  {
    "text": "allocation hook and in the free hook we just removed that breakpoint however if",
    "start": "2193170",
    "end": "2200490"
  },
  {
    "text": "we're only tracking certain allocation sites we end up with situations like this where let's say we're interested in",
    "start": "2200490",
    "end": "2206670"
  },
  {
    "text": "the red region in the middle and because we're only tracking certain allocations",
    "start": "2206670",
    "end": "2212400"
  },
  {
    "text": "that the adjacent memory regions might contain other allocations that we are",
    "start": "2212400",
    "end": "2218340"
  },
  {
    "text": "not tracking that we are not interested in but because the technique works at the granularity of pages that means we",
    "start": "2218340",
    "end": "2225150"
  },
  {
    "text": "are going to take page faults in these allocated regions regardless despite the",
    "start": "2225150",
    "end": "2230220"
  },
  {
    "text": "fact that we're not interested in them and so more page faults means more overhead and this situation gets even",
    "start": "2230220",
    "end": "2237930"
  },
  {
    "text": "worse if for example that allocation that we're interested happens to lie right across a page boundary we might be",
    "start": "2237930",
    "end": "2243780"
  },
  {
    "text": "say tracking 8 kilobytes of memory despite the we're only interested in 32 bytes or",
    "start": "2243780",
    "end": "2249400"
  },
  {
    "text": "something like this so for best performance we only want to take page faults upon accesses that we're",
    "start": "2249400",
    "end": "2257380"
  },
  {
    "text": "interested in so my idea here was just",
    "start": "2257380",
    "end": "2263920"
  },
  {
    "text": "sort of allow the user to specify the sites that they are interested in and then redirect these things into a custom",
    "start": "2263920",
    "end": "2273820"
  },
  {
    "text": "allocator so why not we hook the memory allocator we can do that I'll let let the user specify a list of",
    "start": "2273820",
    "end": "2280450"
  },
  {
    "text": "allocation sites that they want and any time we see allocations taking place from those sites we put those things",
    "start": "2280450",
    "end": "2286780"
  },
  {
    "text": "into our own private memory allocator and that way that memory allocator only",
    "start": "2286780",
    "end": "2291970"
  },
  {
    "text": "has objects that we are interested in tracking we don't have any additional overhead that comes from spurious page",
    "start": "2291970",
    "end": "2300730"
  },
  {
    "text": "faults so the most flexibility you can",
    "start": "2300730",
    "end": "2307780"
  },
  {
    "text": "get here is just used some sort of off-the-shelf memory allocator that allows you to you know variable size",
    "start": "2307780",
    "end": "2313300"
  },
  {
    "text": "accesses and this - and performance and so on so this is you easy to implement usually these things are thread safe and",
    "start": "2313300",
    "end": "2320370"
  },
  {
    "text": "performance tuned and they handle different sized allocations however these things have in band",
    "start": "2320370",
    "end": "2325870"
  },
  {
    "text": "metadata which means you're also going to be taking page faults within the allocator itself so for optimum",
    "start": "2325870",
    "end": "2334300"
  },
  {
    "text": "performance mostly the way I apply this technique is I use a fixed size slab",
    "start": "2334300",
    "end": "2339430"
  },
  {
    "text": "allocator basically I select a bunch of allocation sites and then I choose the largest size",
    "start": "2339430",
    "end": "2345400"
  },
  {
    "text": "that is allocated and then I just create a slab allocator where every allocation",
    "start": "2345400",
    "end": "2350440"
  },
  {
    "text": "is that size and then there's no in-band metadata and allocation and free are",
    "start": "2350440",
    "end": "2358140"
  },
  {
    "text": "basically basically free in terms of performance and it's very easy to do range lookups and so on so this is how",
    "start": "2358140",
    "end": "2366490"
  },
  {
    "text": "you get the best performance but you have to be judicious about how you apply it so the way I use these techniques in the",
    "start": "2366490",
    "end": "2374050"
  },
  {
    "text": "present is basically if I want to say track track all of the allocations in a",
    "start": "2374050",
    "end": "2379720"
  },
  {
    "text": "given program I'll just take a list of all the allocation sites all divided by the",
    "start": "2379720",
    "end": "2384920"
  },
  {
    "text": "number of cores I'm willing to provide to this procedure I'll run say six copies of the program",
    "start": "2384920",
    "end": "2392380"
  },
  {
    "text": "divide the allocation sites up into six groups so I can parallel paralyze the",
    "start": "2392380",
    "end": "2397820"
  },
  {
    "text": "data collection and I'll use a slab allocation to make sure it's as fast as possible so basically the difference",
    "start": "2397820",
    "end": "2410900"
  },
  {
    "text": "here is rather than instrumenting every",
    "start": "2410900",
    "end": "2415940"
  },
  {
    "text": "memory reference and and looking looking",
    "start": "2415940",
    "end": "2423050"
  },
  {
    "text": "up at the time of every memory reference whether or not it refers to an allocation instead I just divert the",
    "start": "2423050",
    "end": "2429440"
  },
  {
    "text": "allocations that I want into a custom allocator and then mark the pages as non present and catch those in an exception",
    "start": "2429440",
    "end": "2436460"
  },
  {
    "text": "handler so that is the large-scale summary of the difference between what I did and the DPI based solutions is it",
    "start": "2436460",
    "end": "2444350"
  },
  {
    "text": "better is it worse I can't I can't answer that question because I haven't implemented the dbi based one what I can",
    "start": "2444350",
    "end": "2451760"
  },
  {
    "text": "say for certain that this is a lot more flexible than the dbi based solution especially with all the performance",
    "start": "2451760",
    "end": "2457430"
  },
  {
    "text": "optimizations I'm able to target specific allocation sites and in some cases if the structures aren't used all",
    "start": "2457430",
    "end": "2463970"
  },
  {
    "text": "that frequently I can continue using the application interactively as though it were not being instrumented you don't",
    "start": "2463970",
    "end": "2470360"
  },
  {
    "text": "notice the overhead again that depends on how frequently the structure is being accessed so I think in the interest of",
    "start": "2470360",
    "end": "2479750"
  },
  {
    "text": "time I'm going to skip ahead to the next one and then hopefully give a demonstration of both so as I mentioned",
    "start": "2479750",
    "end": "2488600"
  },
  {
    "text": "there are two different analyses that are taking place here we were just talking about tracking accesses to structures by a dbi or by a non present",
    "start": "2488600",
    "end": "2497510"
  },
  {
    "text": "pages we're not doing that anymore this is analysis number two it is something completely separate the big picture here",
    "start": "2497510",
    "end": "2505940"
  },
  {
    "text": "is I want to track allocations from their allocation sites into function",
    "start": "2505940",
    "end": "2511670"
  },
  {
    "text": "arguments so basically anytime a pointer is allocated I want to find out anytime",
    "start": "2511670",
    "end": "2517880"
  },
  {
    "text": "subsequently a function is called where one of its arguments is derived from that pointer so for example we have this",
    "start": "2517880",
    "end": "2526610"
  },
  {
    "text": "allocation taking place at location 5 6 7 it's an allocation of size 138 and",
    "start": "2526610",
    "end": "2531980"
  },
  {
    "text": "it's flowing into sub 3 4 5 the third argument and the offset is 16 so I want",
    "start": "2531980",
    "end": "2539210"
  },
  {
    "text": "to record data such as a liqu function was 345 argument was 3 allocation site",
    "start": "2539210",
    "end": "2546140"
  },
  {
    "text": "was 5 6 7 size was 138 and the offset was 16 so I chose to go X 64 specific on",
    "start": "2546140",
    "end": "2559370"
  },
  {
    "text": "this for simplicity on my on my part the",
    "start": "2559370",
    "end": "2564410"
  },
  {
    "text": "X 64 exception metadata gives you the addresses of all of the functions within the binary this is a change from the",
    "start": "2564410",
    "end": "2570860"
  },
  {
    "text": "32-bit Windows environment so it tells you where the function begins as well as where as its first region like its first",
    "start": "2570860",
    "end": "2577910"
  },
  {
    "text": "triblock or its the end of it if there is none so then I just filter out",
    "start": "2577910",
    "end": "2584840"
  },
  {
    "text": "functions that I'm interested in basically I want to see is there something that would prevent me from hooking this function like is there",
    "start": "2584840",
    "end": "2591020"
  },
  {
    "text": "control flow somewhere in the first several instructions or is there cross-references coming from somewhere",
    "start": "2591020",
    "end": "2596810"
  },
  {
    "text": "else or things like this so I just iterate through the instructions I have a couple of checks that I do and then",
    "start": "2596810",
    "end": "2603020"
  },
  {
    "text": "once I get 5 bytes into the function if none of the checks has failed that means I have at least 5 bytes of space to work",
    "start": "2603020",
    "end": "2609890"
  },
  {
    "text": "with so I noticed in practice that hex",
    "start": "2609890",
    "end": "2618230"
  },
  {
    "text": "Ray's would generate calling conventions that did not match up with real life",
    "start": "2618230",
    "end": "2624470"
  },
  {
    "text": "whereas on x64 windows there is only one calling convention fast call by default",
    "start": "2624470",
    "end": "2629480"
  },
  {
    "text": "that hex rays would nevertheless generate user-defined calling conventions so this sort of wreaks havoc",
    "start": "2629480",
    "end": "2636710"
  },
  {
    "text": "on our ability to give a consistent name to an argument or its location so I",
    "start": "2636710",
    "end": "2642200"
  },
  {
    "text": "wrote a little script that just converts all of these user call function Prolog function prototypes into",
    "start": "2642200",
    "end": "2648140"
  },
  {
    "text": "standard fast call and then for every function I just make a list of all of",
    "start": "2648140",
    "end": "2656000"
  },
  {
    "text": "the pointer sized arguments as well as their argument numbers now that we have consistently numbered them according to",
    "start": "2656000",
    "end": "2662660"
  },
  {
    "text": "fast call so this is the data that I",
    "start": "2662660",
    "end": "2668810"
  },
  {
    "text": "collect I just where the function is how many bytes in the prologue are we going",
    "start": "2668810",
    "end": "2674030"
  },
  {
    "text": "to will be we be over writing and then",
    "start": "2674030",
    "end": "2679370"
  },
  {
    "text": "how many arguments are we tracking and where are the arguments so now at",
    "start": "2679370",
    "end": "2687110"
  },
  {
    "text": "runtime we hook the memory allocators same as before not not the paging stuff",
    "start": "2687110",
    "end": "2692690"
  },
  {
    "text": "but just keeping track of where the allocations are where the pointers are how big they are and where they came",
    "start": "2692690",
    "end": "2697700"
  },
  {
    "text": "from now for every function that we collected metadata about just going to",
    "start": "2697700",
    "end": "2706310"
  },
  {
    "text": "hook every function in the binary copy the leading instructions into some other",
    "start": "2706310",
    "end": "2711800"
  },
  {
    "text": "memory that we've allocated insert a jump back after those copied instructions this is our reentry thunk",
    "start": "2711800",
    "end": "2718580"
  },
  {
    "text": "this is if we want to actually if we want to actually call this function in a non hooked fashion this will do it then",
    "start": "2718580",
    "end": "2726020"
  },
  {
    "text": "we record this information in the hash table basically where is the new new function entry for for every function",
    "start": "2726020",
    "end": "2734260"
  },
  {
    "text": "divert every function into a common logging routine common logging routine",
    "start": "2734380",
    "end": "2742880"
  },
  {
    "text": "basically is a little assembly language the thunk that just saves the registers and flags calls another common logging",
    "start": "2742880",
    "end": "2749210"
  },
  {
    "text": "routine then afterwards it adjusts the return address to go back to the non hooked version of the function restores",
    "start": "2749210",
    "end": "2755330"
  },
  {
    "text": "the registers and the flags and continues so then this is the C version",
    "start": "2755330",
    "end": "2761780"
  },
  {
    "text": "of the logging function which is just look up in the hash table the list of pointer sized arguments as well as the",
    "start": "2761780",
    "end": "2768470"
  },
  {
    "text": "re-entry location and then for each argument log it which is to say for each",
    "start": "2768470",
    "end": "2776000"
  },
  {
    "text": "pointer sized argument lookup is this within our allocation map does this does this argument correspond to",
    "start": "2776000",
    "end": "2782670"
  },
  {
    "text": "something that is currently allocated and then log if so log the function",
    "start": "2782670",
    "end": "2789140"
  },
  {
    "text": "which arguments where the allocation came from how big the allocation was and",
    "start": "2789140",
    "end": "2794640"
  },
  {
    "text": "the offset into the allocation so we",
    "start": "2794640",
    "end": "2800730"
  },
  {
    "text": "generate a lot of data in this fashion 60,000 entries for my target but that's",
    "start": "2800730",
    "end": "2806609"
  },
  {
    "text": "a good thing because this data is extremely valuable so this is a little",
    "start": "2806609",
    "end": "2816839"
  },
  {
    "text": "unfortunate I have about three and a half minutes left and I had I wanted to",
    "start": "2816839",
    "end": "2822180"
  },
  {
    "text": "show you demos of all of this stuff in action but it's looking like I'm not",
    "start": "2822180",
    "end": "2828180"
  },
  {
    "text": "going to have time that's very unfortunate so instead I'm just going to",
    "start": "2828180",
    "end": "2833670"
  },
  {
    "text": "talk about some of the challenges that arise and trying to use this data properly and then I'll conclude and if I",
    "start": "2833670",
    "end": "2839460"
  },
  {
    "text": "have time left we'll take questions otherwise afterwards I'll be in the wrap room across the hall taking questions so",
    "start": "2839460",
    "end": "2853770"
  },
  {
    "text": "this is a dynamic analysis which means it can only record information about the",
    "start": "2853770",
    "end": "2858960"
  },
  {
    "text": "program which was observed at at run time through execution so if there are",
    "start": "2858960",
    "end": "2865619"
  },
  {
    "text": "locations in the program that were never accessed but they would have had structure accesses in them that means we",
    "start": "2865619",
    "end": "2871680"
  },
  {
    "text": "aren't going to observe them so I don't have any contribution to every dynamic analysis has this problem although I did",
    "start": "2871680",
    "end": "2878700"
  },
  {
    "text": "incorporate a static analysis that uses hex rays to find other accesses to the",
    "start": "2878700",
    "end": "2884160"
  },
  {
    "text": "same structure variables that were not observed at run time and a fundamental",
    "start": "2884160",
    "end": "2891000"
  },
  {
    "text": "issue really is that once I get once I've recovered my structures and I go to",
    "start": "2891000",
    "end": "2896520"
  },
  {
    "text": "apply this type information in the database basically I need to assign one unique type at every location in the",
    "start": "2896520",
    "end": "2904230"
  },
  {
    "text": "database so that presents ambiguities when I have multiple one instruction is",
    "start": "2904230",
    "end": "2910320"
  },
  {
    "text": "observed accessing multiple allocations so for example if I will observe this",
    "start": "2910320",
    "end": "2916140"
  },
  {
    "text": "instruction is accessing these four allocations I need to assign one type",
    "start": "2916140",
    "end": "2924150"
  },
  {
    "text": "here and what is the type so as it turns out I have the source code for this one",
    "start": "2924150",
    "end": "2929550"
  },
  {
    "text": "so I know two of those allocation sites allocate the same type ns for the third",
    "start": "2929550",
    "end": "2935070"
  },
  {
    "text": "one well there's there's three copies of that type within the other ones so there",
    "start": "2935070",
    "end": "2940740"
  },
  {
    "text": "in fact there is a type that we can associate with that location but it is",
    "start": "2940740",
    "end": "2945900"
  },
  {
    "text": "it's not trivial to know what the type is so none of these techniques are crazy",
    "start": "2945900",
    "end": "2959820"
  },
  {
    "text": "sophisticated I've run into some some serious mathematics in trying to recover",
    "start": "2959820",
    "end": "2965370"
  },
  {
    "text": "every single structure in the program at the same time recovering one structure individually or a couple of structures",
    "start": "2965370",
    "end": "2971850"
  },
  {
    "text": "this is no problem but if you want to recover every structure in the binary it's not just a problem of recovering",
    "start": "2971850",
    "end": "2977790"
  },
  {
    "text": "each individual structure in isolation from one another that you have to take into account overlapping accesses and so",
    "start": "2977790",
    "end": "2985020"
  },
  {
    "text": "on this is kind of difficult but that being said these techniques even if they",
    "start": "2985020",
    "end": "2991440"
  },
  {
    "text": "haven't produced full automation yet in a semi-automated fashion they are",
    "start": "2991440",
    "end": "2996660"
  },
  {
    "text": "they're very useful in that in allowing me to reverse engineer programs with",
    "start": "2996660",
    "end": "3002660"
  },
  {
    "text": "structures in them in a much more rapid fashion like I said I applied more type",
    "start": "3002660",
    "end": "3008360"
  },
  {
    "text": "information to my database in two days than I had in six weeks of manual reverse engineering it turned out this",
    "start": "3008360",
    "end": "3014030"
  },
  {
    "text": "stuff was a better use of my time than actually reading code which is kind of trippy to think about so I'm still",
    "start": "3014030",
    "end": "3022370"
  },
  {
    "text": "working on getting the code ready for a release of I spent my time coming up with new features but it's coming soon",
    "start": "3022370",
    "end": "3029500"
  },
  {
    "text": "so my light just went red I am over my time which means I'll have to divert any",
    "start": "3029500",
    "end": "3036770"
  },
  {
    "text": "questions to the wrap room across the hall thanks everybody for coming sorry I didn't have time for the demo",
    "start": "3036770",
    "end": "3042530"
  },
  {
    "text": "[Applause]",
    "start": "3042530",
    "end": "3046219"
  }
]