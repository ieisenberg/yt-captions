[
  {
    "text": "Consulting I'm a reverse engineer and I think I'm going to speak about Heap corruption issues and how to exploit",
    "start": "2120",
    "end": "7359"
  },
  {
    "text": "Heap corruption issues to write to arbitrary memory",
    "start": "7359",
    "end": "11559"
  },
  {
    "text": "locations I had hoped I wouldn't be speaking that quickly never mind okay",
    "start": "12360",
    "end": "17600"
  },
  {
    "text": "so the speech will consist of two halves and I'll start off with an",
    "start": "17600",
    "end": "22880"
  },
  {
    "text": "introduction where I Define what I understand is a first generation a second generation or a third generation",
    "start": "22880",
    "end": "28480"
  },
  {
    "text": "exploit afterwards go a bit into Heap structure exploitation I'll cover some generalities on heat management I'll",
    "start": "28480",
    "end": "35960"
  },
  {
    "text": "speak a bit about how I go about um well understanding a heap manager a close Source heat manager from the",
    "start": "35960",
    "end": "42280"
  },
  {
    "text": "disassembly I'll then go into detail on how to exploit a heap smash like a buffer overun and heat memory and a ball",
    "start": "42280",
    "end": "47800"
  },
  {
    "text": "and see um both regular smashes and off by ones I'll then talk about a bit about",
    "start": "47800",
    "end": "53559"
  },
  {
    "text": "the win2k heat manager and show one of the many ways you can exploit this one",
    "start": "53559",
    "end": "58719"
  },
  {
    "text": "oh yeah I'll be demonstrating stuff as well and then I'll be speaking a bit about the future of exploits because",
    "start": "58719",
    "end": "64439"
  },
  {
    "text": "landscape is CH changing a bit these days and hopefully we'll take a break",
    "start": "64439",
    "end": "70400"
  },
  {
    "text": "then in the second half I'll be speaking a little bit about format string bugs I know most of you have probably heard",
    "start": "70400",
    "end": "76520"
  },
  {
    "text": "about those but um as they fall into a similar category as Heap Heap issues as",
    "start": "76520",
    "end": "81560"
  },
  {
    "text": "they can write to arbitrary addresses and don't take control of the instruction pointer directly I think I",
    "start": "81560",
    "end": "86680"
  },
  {
    "text": "would be wise to cover them as well and the of the speech will basically be um",
    "start": "86680",
    "end": "92200"
  },
  {
    "text": "techniques to make ant exploits more Rel reliable I mean we all know those things that you have to guess remote Service",
    "start": "92200",
    "end": "97799"
  },
  {
    "text": "Pack you have to guess what kind of os is installed if it's 2K XP whatever so",
    "start": "97799",
    "end": "103880"
  },
  {
    "text": "um I used to work for a German pentesting company and their pentesters were not very very much into coding",
    "start": "103880",
    "end": "109840"
  },
  {
    "text": "exploits so they bought exploits of me and um I had to make sure that these exploits work under pretty much all",
    "start": "109840",
    "end": "117200"
  },
  {
    "text": "conditions I mean it's an issue to get anti export reliable so I'll be speaking about",
    "start": "117200",
    "end": "124560"
  },
  {
    "text": "that any questions concerning the schedule anything I should add add or explain more in depth right now no good",
    "start": "124560",
    "end": "132959"
  },
  {
    "text": "sorry is there any water around oh yeah",
    "start": "132959",
    "end": "138720"
  },
  {
    "text": "thanks okay we all know about first generation exploits those regular stack measures this string copy we've all",
    "start": "138720",
    "end": "144280"
  },
  {
    "text": "heard about them um well just a short diagram to remind everybody how these",
    "start": "144280",
    "end": "149519"
  },
  {
    "text": "things work we have local variables of a c style function in green we have the frame pointer in White and the return",
    "start": "149519",
    "end": "154959"
  },
  {
    "text": "address in red and now somebody starts blindly copying data into one of the local variables and overwrites both the",
    "start": "154959",
    "end": "162640"
  },
  {
    "text": "frame pointer and the return address when this function returns it gets its return address not um well it gets the",
    "start": "162640",
    "end": "170400"
  },
  {
    "text": "return address but that return address has been supplied by an attacker so he can gain",
    "start": "170400",
    "end": "175400"
  },
  {
    "text": "control this is basically what I Define as first generation exploits they're simple stack measures they've been",
    "start": "175519",
    "end": "181000"
  },
  {
    "text": "documented pretty much everywhere every little kitty magazine has written about how to exploit a buffer",
    "start": "181000",
    "end": "187120"
  },
  {
    "text": "overrun um they're pretty boring actually um and they exploit a hardware",
    "start": "187120",
    "end": "192159"
  },
  {
    "text": "feature they exploit the fact that return value takes the snack pointer well di takes the return instruction",
    "start": "192159",
    "end": "200840"
  },
  {
    "text": "takes the address at the stack pointer in order to jump back so it's pretty low to the hardware when it comes to the",
    "start": "200840",
    "end": "207159"
  },
  {
    "text": "level of of abstraction where we're dealing um well first generation exploits are",
    "start": "207159",
    "end": "213400"
  },
  {
    "text": "usually or usually when there's something like a string copy it gets a sprintf um I mentioned before they are",
    "start": "213400",
    "end": "220959"
  },
  {
    "text": "boring and they can be deted via stress testing as the application will SE fold once the return address is overwritten I",
    "start": "220959",
    "end": "227720"
  },
  {
    "text": "mean it will just jump somewhere like in some non-page space",
    "start": "227720",
    "end": "232760"
  },
  {
    "text": "there will be a page fault and an exception being raised so you could find these bugs with stress testing and um I",
    "start": "232760",
    "end": "240079"
  },
  {
    "text": "think it was Microsoft people who claimed that statistically speaking stress testing would find most of",
    "start": "240079",
    "end": "245879"
  },
  {
    "text": "them that was supposed to be a",
    "start": "245879",
    "end": "249599"
  },
  {
    "text": "joke anyways they're almost extinct these days as every kid was auditing",
    "start": "251000",
    "end": "256199"
  },
  {
    "text": "everything at least they're extinct in open source um you still find a few of",
    "start": "256199",
    "end": "261680"
  },
  {
    "text": "those things or few of these bugs in close Source but even there they're getting rare because even the most",
    "start": "261680",
    "end": "267800"
  },
  {
    "text": "backwards programmer has heard that spring copy and gets might not be good",
    "start": "267800",
    "end": "273240"
  },
  {
    "text": "ideas second generation exploits those were the exploits that came up when the string copies gets and sprinters went",
    "start": "273520",
    "end": "279919"
  },
  {
    "text": "rarer and rarer they're basically um well they come first off from the misuse",
    "start": "279919",
    "end": "285479"
  },
  {
    "text": "of the so-called safe prototypes sdrn copy sdrn cat and they come from the fact that CR array indexing starts at",
    "start": "285479",
    "end": "292000"
  },
  {
    "text": "zero so therefore addressing a 20 by buffer at well index 20 is going to",
    "start": "292000",
    "end": "297720"
  },
  {
    "text": "write out of the boundaries of the buffer um they're fairly well documented there have been frag articles about them and",
    "start": "297720",
    "end": "304440"
  },
  {
    "text": "in contrast to the first generation exploits they don't take control directly from EIP and they don't even",
    "start": "304440",
    "end": "309759"
  },
  {
    "text": "exploit the hardware feature itself but they exploit something which was like convention in all compilers was the",
    "start": "309759",
    "end": "315520"
  },
  {
    "text": "standard prologue and epilog for all C functions um they can be quite hard to detect especially in decoding Loops like",
    "start": "315520",
    "end": "321720"
  },
  {
    "text": "base 64 decoding um mcode or mtex decoding like Lotus Domino envid um they",
    "start": "321720",
    "end": "329960"
  },
  {
    "text": "can be quite hard to find and therefore there are still a few of those around even in major open source",
    "start": "329960",
    "end": "336918"
  },
  {
    "text": "applications when they actually get executed or when such an buffer overrun",
    "start": "338120",
    "end": "343840"
  },
  {
    "text": "actually occurs we can get control by overwriting and manipulating the frame pointer now in this diagram we have a",
    "start": "343840",
    "end": "351039"
  },
  {
    "text": "Target buffer in blue to which we copy the the data we have the white frame",
    "start": "351039",
    "end": "357039"
  },
  {
    "text": "pointer and we have the red return address so we start copying data into into the target buffer and override the",
    "start": "357039",
    "end": "364520"
  },
  {
    "text": "lowest order bite of EBP the function executes the regular C",
    "start": "364520",
    "end": "370960"
  },
  {
    "text": "epilog moving EBP into ESP which removes all the local variables from the",
    "start": "370960",
    "end": "377039"
  },
  {
    "text": "stack and then pops EBP our manipulated EBP value into the EVP",
    "start": "377039",
    "end": "384280"
  },
  {
    "text": "register and then ises a return now we have to keep in mind here that EBP has",
    "start": "384280",
    "end": "389919"
  },
  {
    "text": "been manipulated now when the next function returns we again have user Supply data in blue the",
    "start": "389919",
    "end": "396759"
  },
  {
    "text": "safed EBP in White and the saved EIP in Red so the standard epilog is executed",
    "start": "396759",
    "end": "404280"
  },
  {
    "text": "again which moves EBP into ESP and what happens now is that the stack pointer slides upwards in memory",
    "start": "404280",
    "end": "411319"
  },
  {
    "text": "because we overrode the lowest order by so instead of pointing to the saf EVP",
    "start": "411319",
    "end": "417319"
  },
  {
    "text": "and safet EIP slides upward s into the user Supply data and then it returns",
    "start": "417319",
    "end": "423840"
  },
  {
    "text": "takes its return value from the user Supply data and the the attacker has gotten controlled",
    "start": "423840",
    "end": "430160"
  },
  {
    "text": "again",
    "start": "430800",
    "end": "433800"
  },
  {
    "text": "okay I mentioned before that I have to consider format string bugs part of the third generation or of third generation",
    "start": "437800",
    "end": "444360"
  },
  {
    "text": "exploits um they surfaced in summer 2000 by or through uh w fpd export that got",
    "start": "444360",
    "end": "450080"
  },
  {
    "text": "posted to Bure I think the export was written by somebody called tf8 um it's pretty much a new buuk or it",
    "start": "450080",
    "end": "456039"
  },
  {
    "text": "used to be a new buuk family nobody knew about it before besides a few people in France it seems for a few years um",
    "start": "456039",
    "end": "463720"
  },
  {
    "text": "they've had General keys to to pretty much any computer in the world for a few years so um I'll get into the politics",
    "start": "463720",
    "end": "470720"
  },
  {
    "text": "what happened after forat string Bugs Got public a bit later on anyways um",
    "start": "470720",
    "end": "475759"
  },
  {
    "text": "these bugs come from a misuse of print style functions where user Supply data is given into the function as a format",
    "start": "475759",
    "end": "482680"
  },
  {
    "text": "string they're really trivial to spot and by now they are widely exploited and well",
    "start": "482680",
    "end": "490120"
  },
  {
    "text": "documented they allow an Checker not to take control directly but they allow reading and writing to arbitrary memory addresses so in that aspect they're",
    "start": "490120",
    "end": "496759"
  },
  {
    "text": "similar to the Malo overflows which we're going to cover next um another thing is that they are not actually",
    "start": "496759",
    "end": "503039"
  },
  {
    "text": "exploiting any hardware feature they're exploiting something that is in the nzc standard which apparently nobody",
    "start": "503039",
    "end": "508759"
  },
  {
    "text": "bothered to read before but um it's not like we're dealing with something that cannot be",
    "start": "508759",
    "end": "514399"
  },
  {
    "text": "changed we could theoretically patch the Lipsy and remove certain format characters would just not be standards",
    "start": "514399",
    "end": "519640"
  },
  {
    "text": "compliant anymore so um the this Buck species has",
    "start": "519640",
    "end": "525040"
  },
  {
    "text": "been well hunted to Extinction very quickly because they're very very easy to spot they're very powerful and",
    "start": "525040",
    "end": "531040"
  },
  {
    "text": "they're easy to exploit so you have to well imagine it like a bug or any kind",
    "start": "531040",
    "end": "536200"
  },
  {
    "text": "of animal you'd get a high market price for and that's really stupid and will not run away when you look at it so um",
    "start": "536200",
    "end": "543480"
  },
  {
    "text": "they're pretty much gone in open source uh you can still find them in closed Source um not in all close Source",
    "start": "543480",
    "end": "549200"
  },
  {
    "text": "anymore checkpoint fixed about 100 of them last year um well they're probably",
    "start": "549200",
    "end": "555440"
  },
  {
    "text": "the only bug class there is that can be 100% automatically detected so um that",
    "start": "555440",
    "end": "561040"
  },
  {
    "text": "might be one of the reasons why they are gone so quickly okay Heap structure exploits now",
    "start": "561040",
    "end": "568480"
  },
  {
    "text": "for a long time everybody thought that a Malo buffer is not really dangerous when it gets overwritten only if there is",
    "start": "568480",
    "end": "573760"
  },
  {
    "text": "important data behind it and a while ago solar designer posted um I think it was",
    "start": "573760",
    "end": "579560"
  },
  {
    "text": "a trace route trace route exploit to Bure where he basically manipulated the",
    "start": "579560",
    "end": "584959"
  },
  {
    "text": "Heap management structures the structures the Heap implementation uses for managing memory chunks and",
    "start": "584959",
    "end": "591040"
  },
  {
    "text": "manipulated these to make the Heap management function right to arbitrary addresses so um that spawned a whole new",
    "start": "591040",
    "end": "598040"
  },
  {
    "text": "line of research into to well how to abuse Heap implementations to write to arbitrary addresses and these days it",
    "start": "598040",
    "end": "604320"
  },
  {
    "text": "seems that the Moc free exploits are more common than the standard stack smashes because in in a lot of software",
    "start": "604320",
    "end": "610800"
  },
  {
    "text": "the standard stack smashing has been almost eliminated while things like a double free like one pointer which is",
    "start": "610800",
    "end": "616959"
  },
  {
    "text": "free twice or um a heap overrun have gone unnoticed um is way like is on a way",
    "start": "616959",
    "end": "625160"
  },
  {
    "text": "higher level of abstraction than either generation one or two similar to The Format strings and um for Unix it has",
    "start": "625160",
    "end": "633240"
  },
  {
    "text": "been docu or they have been documented in the recent Frack by Max from Synergy and the funny thing is depending",
    "start": "633240",
    "end": "639720"
  },
  {
    "text": "on your HEAP implementation they are not or very hard to detect via stress testing because the data you override",
    "start": "639720",
    "end": "646920"
  },
  {
    "text": "the control structure with has to have a certain format in order to trigger anything so if you just fuzz in there",
    "start": "646920",
    "end": "652480"
  },
  {
    "text": "with straight like with a bunch of A's or just send lots of X or whatever with a PR script chances are that you're",
    "start": "652480",
    "end": "659839"
  },
  {
    "text": "dealing with a heap implementation that will not react to this kind of data so",
    "start": "659839",
    "end": "665480"
  },
  {
    "text": "um there really is no way to reliably find these bugs without some sort of auditing beforehand some sort of manual",
    "start": "665480",
    "end": "672160"
  },
  {
    "text": "source code or binary",
    "start": "672160",
    "end": "675480"
  },
  {
    "text": "analysis some generalities on Heap management um Heap is that place where",
    "start": "678600",
    "end": "683839"
  },
  {
    "text": "memory comes from if you do a Malo and where it goes to when you do a free that's all the programmer supposed to",
    "start": "683839",
    "end": "689560"
  },
  {
    "text": "know um there are a whole bunch of different memory management and Heap management algorithms um I think there's",
    "start": "689560",
    "end": "696399"
  },
  {
    "text": "it's like a standard computer science exercise to write your own um the the Unix book by or book on Unix",
    "start": "696399",
    "end": "704440"
  },
  {
    "text": "kernel internals by Ralia lists at least eight different kernel level memory allocators so you might have an idea of",
    "start": "704440",
    "end": "710560"
  },
  {
    "text": "how many user mode allocators there are pretty much every compiler brings their own um many compilers bring more than",
    "start": "710560",
    "end": "717800"
  },
  {
    "text": "one implementation lot of applications actually have their own memory management in there in order to optimize",
    "start": "717800",
    "end": "724040"
  },
  {
    "text": "performance for example if you have it's actually recommended to do that if you have an application which frequently allocates chunks of 20 bytes you want to",
    "start": "724040",
    "end": "731320"
  },
  {
    "text": "have an Heap implementation that specializes in making those 20 byte allocations as quick as possible so many",
    "start": "731320",
    "end": "737279"
  },
  {
    "text": "large applications like um Oracle like Netscape Enterprise bring their own Heap",
    "start": "737279",
    "end": "744160"
  },
  {
    "text": "implementation and then there's the operating system which might provide their own Heap implementation as as well",
    "start": "744160",
    "end": "749240"
  },
  {
    "text": "as NT 2K and um XP do every Heap implementation requires a different way",
    "start": "749240",
    "end": "756240"
  },
  {
    "text": "of exploitation and every Heap implementation requires a different data format to use in stress",
    "start": "756240",
    "end": "763519"
  },
  {
    "text": "testing so um it's a lot of work and it's pretty much well it creates jobs",
    "start": "763519",
    "end": "769920"
  },
  {
    "text": "for people who like to read s sces or",
    "start": "769920",
    "end": "773760"
  },
  {
    "text": "binaries any questions so far",
    "start": "775160",
    "end": "780839"
  },
  {
    "text": "okay so we look at the Ballon C++ allocator um it is similar to something",
    "start": "784160",
    "end": "790639"
  },
  {
    "text": "called du leas Melo which is the Melo implementation which is present in G lipy it is relatively simple in design",
    "start": "790639",
    "end": "797160"
  },
  {
    "text": "I'll show you a flow graph in order to make that more",
    "start": "797160",
    "end": "804920"
  },
  {
    "text": "clear",
    "start": "807760",
    "end": "810760"
  },
  {
    "text": "um it'll take a while it's an evaluation version all right",
    "start": "820560",
    "end": "829519"
  },
  {
    "text": "so this would be a binary flow diagram of the Boland Heap implementation",
    "start": "829880",
    "end": "836519"
  },
  {
    "text": "doesn't look all that simple right now but if you compare it to um Microsoft's Heap implementation it is really really",
    "start": "836519",
    "end": "841839"
  },
  {
    "text": "simple like uh less than a quarter of the size so",
    "start": "841839",
    "end": "849639"
  },
  {
    "text": "um back to the slides the exploitation of ball and C++ is very similar to the",
    "start": "849639",
    "end": "855519"
  },
  {
    "text": "methods you use when you exploit a g lip over foro and um as most Heap implementation",
    "start": "855519",
    "end": "862480"
  },
  {
    "text": "it mixes control structures with actual data in the like in the allocated Heap",
    "start": "862480",
    "end": "867680"
  },
  {
    "text": "segments for example the the free BSD or open BSD I don't know um allocator",
    "start": "867680",
    "end": "873120"
  },
  {
    "text": "doesn't store the control structures in the same place the memory is being taken from so you don't have the mixing",
    "start": "873120",
    "end": "878639"
  },
  {
    "text": "between allocated space control structure allocated space but just allocated space allocated space allocated space which makes it pretty",
    "start": "878639",
    "end": "885920"
  },
  {
    "text": "much impossible to exploit these kind of things so um it would be considered one",
    "start": "885920",
    "end": "891240"
  },
  {
    "text": "of the less secure whatever um algorithms for Heap Heap implementation",
    "start": "891240",
    "end": "897320"
  },
  {
    "text": "for various reasons so um every memory block you allocate",
    "start": "897320",
    "end": "902680"
  },
  {
    "text": "for example with a Moc 20 gets a 4 byte control structure which is right in front of the block so a programmer would",
    "start": "902680",
    "end": "909639"
  },
  {
    "text": "Moc 20 bytes and he'd get a pointer right to this location back and before that location there is four bytes which",
    "start": "909639",
    "end": "916079"
  },
  {
    "text": "sto sto store some information about the memory block following",
    "start": "916079",
    "end": "922120"
  },
  {
    "text": "it and um the Heap would look similar to this once you've allocated two squential",
    "start": "922120",
    "end": "927959"
  },
  {
    "text": "B two blocks sequentially if block free is B uh Block",
    "start": "927959",
    "end": "934839"
  },
  {
    "text": "B is free um the control structure does not consist of only one double word but of three double words and whenever you",
    "start": "934839",
    "end": "942079"
  },
  {
    "text": "now free memory block a the Heap l or the Heap implementation would try to defragment the Heap by",
    "start": "942079",
    "end": "948800"
  },
  {
    "text": "coalescing the two free buffers it's very inefficient for a heap to have a lot of small free buffers anywhere on",
    "start": "948800",
    "end": "955680"
  },
  {
    "text": "the Heap so most Heap implementations attempt to have any any kind of ad junctioned free buffers coist into one",
    "start": "955680",
    "end": "962079"
  },
  {
    "text": "large buffer so assuming we free memory block a right now the two buffers get",
    "start": "962079",
    "end": "970079"
  },
  {
    "text": "cores and we have one large block with three double words as a control structure in front of",
    "start": "970079",
    "end": "978680"
  },
  {
    "text": "it so assuming we're overflowing memory block",
    "start": "979480",
    "end": "984839"
  },
  {
    "text": "a we want to basically create fake free chunks here basically",
    "start": "985600",
    "end": "992600"
  },
  {
    "text": "make the program the Heap implementation think that the following block the block after memory block a is",
    "start": "992600",
    "end": "998639"
  },
  {
    "text": "free and then we want to create fake control structures here so that when the",
    "start": "998639",
    "end": "1004519"
  },
  {
    "text": "Heap implementation tries to coales these two blocks wres to arbitrary",
    "start": "1004519",
    "end": "1010560"
  },
  {
    "text": "locations Oops let's look at the graph",
    "start": "1010920",
    "end": "1016440"
  },
  {
    "text": "again",
    "start": "1017480",
    "end": "1020480"
  },
  {
    "text": "okay I've added some niffy colors",
    "start": "1036480",
    "end": "1042120"
  },
  {
    "text": "um this is the same same diagram as before I've just colored the place where the actual kesing happens",
    "start": "1042120",
    "end": "1049000"
  },
  {
    "text": "in magenta and the code path which leads to this place in yellow",
    "start": "1049000",
    "end": "1055120"
  },
  {
    "text": "so we now be reading a little bit of Assembly",
    "start": "1055120",
    "end": "1059679"
  },
  {
    "text": "Language this is standard function prologue and AR zero the pointer to the",
    "start": "1066919",
    "end": "1072440"
  },
  {
    "text": "memory Lo which we are freeing is loaded in E then the number four or get subtracted",
    "start": "1072440",
    "end": "1079799"
  },
  {
    "text": "from eex and um the value at that location is loaded into ECX it's tested we can't",
    "start": "1079799",
    "end": "1086559"
  },
  {
    "text": "influence this value at all it is in our diagram",
    "start": "1086559",
    "end": "1092880"
  },
  {
    "text": "whoops where am I in our diagram that would be a",
    "start": "1092880",
    "end": "1098919"
  },
  {
    "text": "data so we can't take any influence on this and therefore this Branch will go",
    "start": "1098919",
    "end": "1106760"
  },
  {
    "text": "down here where the other yellow box is some flag will be",
    "start": "1106760",
    "end": "1112120"
  },
  {
    "text": "set and um it'll load the size basic",
    "start": "1113320",
    "end": "1119280"
  },
  {
    "text": "wait it load the size of this block out of this double word it then adds it to a",
    "start": "1119280",
    "end": "1125799"
  },
  {
    "text": "pointer to get the beginning of Block B of the next block at this point it",
    "start": "1125799",
    "end": "1130919"
  },
  {
    "text": "checks whether the next block is free or not you can see that in the",
    "start": "1130919",
    "end": "1136240"
  },
  {
    "text": "graph right here",
    "start": "1136240",
    "end": "1140320"
  },
  {
    "text": "if the next next block is free it goes about and tries to coales the two",
    "start": "1142640",
    "end": "1147760"
  },
  {
    "text": "buffers we can safely ignore this piece of code and here we are edx Plus 8 is the beginning",
    "start": "1150840",
    "end": "1159400"
  },
  {
    "text": "of the buffer B the D word there gets being put in ECX",
    "start": "1159400",
    "end": "1166520"
  },
  {
    "text": "Plus 8 and ECX Plus 8 gets loaded at x + 4 um I'm not sure whether I have it",
    "start": "1166520",
    "end": "1171799"
  },
  {
    "text": "somewhere more visual but we can demonstrate that in a sec a few seconds",
    "start": "1171799",
    "end": "1177039"
  },
  {
    "text": "so basically um these two double words",
    "start": "1177039",
    "end": "1182240"
  },
  {
    "text": "tell us what to do or we have to tell these double words where to write",
    "start": "1182240",
    "end": "1189200"
  },
  {
    "text": "um we can see from the flow graph that the data with which we overriding the beginning of B has to have this format",
    "start": "1189200",
    "end": "1195840"
  },
  {
    "text": "I'll explain why in a second well these",
    "start": "1195840",
    "end": "1201120"
  },
  {
    "text": "two things here the two words at plus 4 and plus 8 are fairly obvious from this",
    "start": "1201120",
    "end": "1209200"
  },
  {
    "text": "point here edx + 4 gets loaded into",
    "start": "1209200",
    "end": "1214600"
  },
  {
    "text": "ECX to this location the value in edx Plus 8 is being written so basically",
    "start": "1214600",
    "end": "1220080"
  },
  {
    "text": "these are being exchanged and written to a certain location and the format of this one is a bit tricky but in order to even",
    "start": "1220080",
    "end": "1227840"
  },
  {
    "text": "reach the code which which we are dealing",
    "start": "1227840",
    "end": "1233799"
  },
  {
    "text": "oops we have to adhere to this format because right",
    "start": "1235880",
    "end": "1241039"
  },
  {
    "text": "here we have a certain flag being set or double word pointer eax plus edx plus",
    "start": "1241039",
    "end": "1247640"
  },
  {
    "text": "42 now if we do",
    "start": "1247640",
    "end": "1253279"
  },
  {
    "text": "not make sure that this e e plus edx plus plus 4 Points to page location will",
    "start": "1253480",
    "end": "1260840"
  },
  {
    "text": "crash the program so if we put the value to f f ff1 it'll basically",
    "start": "1260840",
    "end": "1269159"
  },
  {
    "text": "be a negative value a very small negative value it'll be subtracted and four will be added so we're writing",
    "start": "1269159",
    "end": "1274919"
  },
  {
    "text": "three bytes backwards in heat memory which will still be paged if you put any value here that is not large enough to",
    "start": "1274919",
    "end": "1280799"
  },
  {
    "text": "make this semi wraparound happen you write to an unpage location and just crash the program all theory is gray I",
    "start": "1280799",
    "end": "1288279"
  },
  {
    "text": "think we'd better demonstrate this",
    "start": "1288279",
    "end": "1291400"
  },
  {
    "text": "once there's a small example program I'll use for",
    "start": "1309080",
    "end": "1315600"
  },
  {
    "text": "exploitation doesn't do much just overflows lock buffer and freeze the buffers",
    "start": "1315600",
    "end": "1321520"
  },
  {
    "text": "afterwards I'll quickly loog the executable up in Ida so we can have a better idea of what's going",
    "start": "1323200",
    "end": "1330840"
  },
  {
    "text": "on okay so we're dealing with test BCC",
    "start": "1346960",
    "end": "1354799"
  },
  {
    "text": "exe",
    "start": "1354799",
    "end": "1357799"
  },
  {
    "text": "and we'll run this program",
    "start": "1360279",
    "end": "1364279"
  },
  {
    "text": "once overflow the buffer a",
    "start": "1366279",
    "end": "1370159"
  },
  {
    "text": "bit and see what the program wants to tell us",
    "start": "1373760",
    "end": "1379960"
  },
  {
    "text": "whoops that was wrong never",
    "start": "1381240",
    "end": "1385799"
  },
  {
    "text": "mind let's do it this way I've pre-prepared this block here for",
    "start": "1386600",
    "end": "1393679"
  },
  {
    "text": "overflowing what we have here is A's which will fill up the entire buffer a",
    "start": "1393679",
    "end": "1400240"
  },
  {
    "text": "and afterwards F1 FF FF FF as I mentioned before and then two values which will",
    "start": "1400240",
    "end": "1407520"
  },
  {
    "text": "are gu to be paged to which we can write arbitrary values I'll just pipe this into our",
    "start": "1407520",
    "end": "1415760"
  },
  {
    "text": "program now wait a second we'll have",
    "start": "1418000",
    "end": "1422360"
  },
  {
    "text": "to make sure the debugger will kick",
    "start": "1425240",
    "end": "1429440"
  },
  {
    "text": "in okay we're in the the middle of the ball and Heap implementation so we Trace around a bit",
    "start": "1436200",
    "end": "1444080"
  },
  {
    "text": "until we reach the part of the code we wanted to get to this is the control block of a which I mentioned before",
    "start": "1444080",
    "end": "1450159"
  },
  {
    "text": "which we cannot influence in any way the flag is getting set blah blah",
    "start": "1450159",
    "end": "1457559"
  },
  {
    "text": "blah youve all seen",
    "start": "1457559",
    "end": "1460919"
  },
  {
    "text": "that okay here we go",
    "start": "1463159",
    "end": "1468880"
  },
  {
    "text": "edx as we can see is the data we have supplied fff1 ffff blah blah blah and",
    "start": "1468880",
    "end": "1476159"
  },
  {
    "text": "the value at edx Plus 8 namely this value gets loaded into register",
    "start": "1476159",
    "end": "1484559"
  },
  {
    "text": "ebx value at edx plus 4 gets loaded into register ECX and",
    "start": "1485679",
    "end": "1493000"
  },
  {
    "text": "now we're writing the value at e X Plus 8 into the location at edx plus",
    "start": "1493440",
    "end": "1503000"
  },
  {
    "text": "4 up here so basically by changing these",
    "start": "1503240",
    "end": "1508399"
  },
  {
    "text": "locations we can write any value to any address as long as both the value and the address are paged in",
    "start": "1508399",
    "end": "1515000"
  },
  {
    "text": "memory um does everybody believe that or should I demonstrate that we can change the numbers and things would still",
    "start": "1515000",
    "end": "1521559"
  },
  {
    "text": "work okay I should be changing the numbers somebody tell me a number um eight digits",
    "start": "1521559",
    "end": "1526679"
  },
  {
    "text": "please",
    "start": "1526679",
    "end": "1529679"
  },
  {
    "text": "okay well we come up with",
    "start": "1532760",
    "end": "1535919"
  },
  {
    "text": "something that should do",
    "start": "1544880",
    "end": "1548360"
  },
  {
    "text": "it of course we get a sec fault now",
    "start": "1556679",
    "end": "1564759"
  },
  {
    "text": "but okay ebx is being loaded with bad code spelled",
    "start": "1565159",
    "end": "1572200"
  },
  {
    "text": "backwards ECX is getting loaded with the other value we supplied if you wonder why these values",
    "start": "1572200",
    "end": "1578200"
  },
  {
    "text": "are all changed around that's due to nness in the file versus nness in memory and then they write to ECX Plus",
    "start": "1578200",
    "end": "1584760"
  },
  {
    "text": "8 which is non page which will trigger an ception and the program",
    "start": "1584760",
    "end": "1590679"
  },
  {
    "text": "dies any questions concerning this yes so what's the purpose of the",
    "start": "1590679",
    "end": "1597679"
  },
  {
    "text": "original uh Mal to write that memory um the question is what the why the",
    "start": "1597679",
    "end": "1603799"
  },
  {
    "text": "original free is writing to that memory yeah basically they're trying to Callis the two blocks like the two free blocks",
    "start": "1603799",
    "end": "1611399"
  },
  {
    "text": "and then moving pointers around like what what what is the uh what pointer is",
    "start": "1611399",
    "end": "1616760"
  },
  {
    "text": "add the original location of a free Block uh excuse me what you know how",
    "start": "1616760",
    "end": "1623640"
  },
  {
    "text": "when you free a block three uh 3D words yeah that they're allocated",
    "start": "1623640",
    "end": "1631799"
  },
  {
    "text": "yeah uh what what is the what is the structure that holds what are those are those pointers in those dwords that are",
    "start": "1631799",
    "end": "1638799"
  },
  {
    "text": "supposed to be pointing back to uh memory like link list holding or",
    "start": "1638799",
    "end": "1645760"
  },
  {
    "text": "something they usually paint through a t of free blocks so they are supposed to enter themselves into this free table I",
    "start": "1645760",
    "end": "1652600"
  },
  {
    "text": "haven't really investigated what ball Andy does exactly at this point I don't really look much further than on where",
    "start": "1652600",
    "end": "1659600"
  },
  {
    "text": "to exploit it um on the other hand um yeah it's it's usually used for",
    "start": "1659600",
    "end": "1665399"
  },
  {
    "text": "coalescing of blogs or for putting a free blog into some kind of linked list or some kind of table any other",
    "start": "1665399",
    "end": "1672720"
  },
  {
    "text": "questions concerning this all right then we'll be moving on",
    "start": "1672720",
    "end": "1679519"
  },
  {
    "text": "okay so um we're lucky with ball and C++ in contrast to Windows 2K we can exploit",
    "start": "1680720",
    "end": "1686880"
  },
  {
    "text": "off by ones in heat memory um we'll have a look at the code in a",
    "start": "1686880",
    "end": "1695120"
  },
  {
    "text": "seconds never go go partying with Microsoft people seriously",
    "start": "1695120",
    "end": "1701960"
  },
  {
    "text": "Nots",
    "start": "1706440",
    "end": "1709440"
  },
  {
    "text": "okay I have another graph for",
    "start": "1712720",
    "end": "1716840"
  },
  {
    "text": "this okay now assuming we're exploring an off",
    "start": "1736399",
    "end": "1741840"
  },
  {
    "text": "by one I mentioned before that we can't really Reach This bite before us the",
    "start": "1741840",
    "end": "1747240"
  },
  {
    "text": "control block of a what can happen though is that not our buffer which we overflowed gets freed",
    "start": "1747240",
    "end": "1753120"
  },
  {
    "text": "first but the buffer into which we overr or into which we well overr by one bite",
    "start": "1753120",
    "end": "1759120"
  },
  {
    "text": "accidentally so what happens here is that the lowest bite of this um double word which is being checked is set to",
    "start": "1759120",
    "end": "1765240"
  },
  {
    "text": "zero so we have had this part on the graph before and at",
    "start": "1765240",
    "end": "1772159"
  },
  {
    "text": "that time we couldn't influence this particular check here so now we're overriding this location with a zero",
    "start": "1772159",
    "end": "1779559"
  },
  {
    "text": "byte so um this test here instead of",
    "start": "1779559",
    "end": "1784640"
  },
  {
    "text": "taking this Branch down here is going over here and we can see that we can",
    "start": "1784640",
    "end": "1790120"
  },
  {
    "text": "reach the same magenta Cod block via this route as if we had gone through this",
    "start": "1790120",
    "end": "1798320"
  },
  {
    "text": "here and land it in a different magenta block wait a second I'll compare the two for a second so there's one one overflow",
    "start": "1798320",
    "end": "1806360"
  },
  {
    "text": "or not one overflow one AR arbitrary memory override happening in this block and one here and the route we just took",
    "start": "1806360",
    "end": "1812240"
  },
  {
    "text": "was this one and the route we can now take with Y",
    "start": "1812240",
    "end": "1818519"
  },
  {
    "text": "by one is this",
    "start": "1818519",
    "end": "1824039"
  },
  {
    "text": "one so we're basically setting the next Block's lowest order bite of the control",
    "start": "1826240",
    "end": "1832120"
  },
  {
    "text": "to zero we can pretty much safely ignore this entire block over here and then we",
    "start": "1832120",
    "end": "1840640"
  },
  {
    "text": "land at the typical pointer exchange again same game same",
    "start": "1840640",
    "end": "1847640"
  },
  {
    "text": "layout and there really isn't much different",
    "start": "1847640",
    "end": "1852760"
  },
  {
    "text": "here this time just that um we have to control the next buffer meaning",
    "start": "1852760",
    "end": "1860080"
  },
  {
    "text": "um we have to control not only this buffer which we overrun but we have",
    "start": "1860080",
    "end": "1865279"
  },
  {
    "text": "control to control the contents of this buffer as well because what we're doing right now is we're making the free",
    "start": "1865279",
    "end": "1871200"
  },
  {
    "text": "belief that he should be taking three control blocks from here which obviously",
    "start": "1871200",
    "end": "1876480"
  },
  {
    "text": "are not there if we can't control that buffer so we need to control both this",
    "start": "1876480",
    "end": "1881799"
  },
  {
    "text": "buffer which we overrun and the buffer into which we overrun by one bite",
    "start": "1881799",
    "end": "1888840"
  },
  {
    "text": "I'll have a demonstration for that as",
    "start": "1888840",
    "end": "1892158"
  },
  {
    "text": "well another small program which this time gets two buffers which we could control and freeze them conse",
    "start": "1905440",
    "end": "1914200"
  },
  {
    "text": "consecutively and something which will first overflow",
    "start": "1916159",
    "end": "1921720"
  },
  {
    "text": "the first buffer with an off by",
    "start": "1921720",
    "end": "1926760"
  },
  {
    "text": "one and which will then put these three double",
    "start": "1927120",
    "end": "1933360"
  },
  {
    "text": "words followed by Ooa new line into the following",
    "start": "1933360",
    "end": "1941080"
  },
  {
    "text": "buffer",
    "start": "1946080",
    "end": "1949080"
  },
  {
    "text": "okay so we're tressing down a bit this is the branch that we normally could not be influencing but which we are now",
    "start": "1961000",
    "end": "1970360"
  },
  {
    "text": "taking some flag is being said we want to ignore all this crap and here we are",
    "start": "1970360",
    "end": "1979039"
  },
  {
    "text": "classic pointer exchange the three double",
    "start": "1979080",
    "end": "1984398"
  },
  {
    "text": "words and we're overriding arbitrary locations any questions if the freeze",
    "start": "1984880",
    "end": "1992440"
  },
  {
    "text": "were reversed would you just reverse the data from the two in the two gaps if the freeze were",
    "start": "1992440",
    "end": "1998039"
  },
  {
    "text": "reversed um well why would I be reversing in the code if it was it was",
    "start": "1998039",
    "end": "2003799"
  },
  {
    "text": "uh free data to then free dat so the code you sure it was free data 2 then free data 1 yes if the if it was free",
    "start": "2003799",
    "end": "2011200"
  },
  {
    "text": "data 1 then free data 2 would you reverse where you're putting the data",
    "start": "2011200",
    "end": "2016240"
  },
  {
    "text": "for the GS uh no because I can't really reverse that because um explo I'm sorry it",
    "start": "2016240",
    "end": "2024440"
  },
  {
    "text": "wouldn't be exploitable in that case to be honest I haven't tried should I try sure all right afterward it's fine um",
    "start": "2024440",
    "end": "2032279"
  },
  {
    "text": "but let me think for a second to be honest as the the actual point override happens not in the free of oh wait a",
    "start": "2032279",
    "end": "2038480"
  },
  {
    "text": "second we'll we'll just check it it happens in the seconde right uh no it happens in the first free so as this",
    "start": "2038480",
    "end": "2045039"
  },
  {
    "text": "happens anyways in the free of this buffer freeing this buffer first should not have any impact but uh should have",
    "start": "2045039",
    "end": "2051480"
  },
  {
    "text": "and does not have our two very very different things so we'll just try",
    "start": "2051480",
    "end": "2058240"
  },
  {
    "text": "that",
    "start": "2059639",
    "end": "2062638"
  },
  {
    "text": "that's okay",
    "start": "2065280",
    "end": "2068879"
  },
  {
    "text": "whoops uh I should compile it",
    "start": "2071440",
    "end": "2075800"
  },
  {
    "text": "first um yes",
    "start": "2079359",
    "end": "2084440"
  },
  {
    "text": "good okay um right now we don't have a break",
    "start": "2090520",
    "end": "2097400"
  },
  {
    "text": "point on the allocator so we got to load this fun Ida and set a break point on the",
    "start": "2097400",
    "end": "2102880"
  },
  {
    "text": "allocation function I'll take a",
    "start": "2102880",
    "end": "2107440"
  },
  {
    "text": "minute take a Time",
    "start": "2123440",
    "end": "2128800"
  },
  {
    "text": "there you",
    "start": "2135880",
    "end": "2138200"
  },
  {
    "text": "go so this is the small memory",
    "start": "2148200",
    "end": "2152400"
  },
  {
    "text": "allocator and that's at 41 co4",
    "start": "2153520",
    "end": "2158800"
  },
  {
    "text": "we quickly plch oh what we quickly patch a break point at that",
    "start": "2161599",
    "end": "2168720"
  },
  {
    "text": "location and try it out",
    "start": "2181319",
    "end": "2188720"
  },
  {
    "text": "so this is the first free which should not do anything so we'll just forget it",
    "start": "2191240",
    "end": "2197480"
  },
  {
    "text": "this is the second",
    "start": "2197480",
    "end": "2200119"
  },
  {
    "text": "free which it seems to go somewhere completely",
    "start": "2209359",
    "end": "2215680"
  },
  {
    "text": "different I'm a bit lost right now wait a second oh um this is called a bit too often",
    "start": "2215680",
    "end": "2222599"
  },
  {
    "text": "something is going wrong wouldn't you need to reverse the",
    "start": "2222599",
    "end": "2230440"
  },
  {
    "text": "data why would I'm not quite sure because to be honest I'll try that later and we'll see",
    "start": "2230440",
    "end": "2237200"
  },
  {
    "text": "then because um mainly it it shouldn't make any difference because we're manipulating this point and the data is",
    "start": "2237200",
    "end": "2243640"
  },
  {
    "text": "still in here and we're overflowing this buffer anyway so um re reverting the",
    "start": "2243640",
    "end": "2249000"
  },
  {
    "text": "data would not really at least in theory should not do any or be anything different but then again theory is is",
    "start": "2249000",
    "end": "2256520"
  },
  {
    "text": "Theory let's move on to Wind 32 heat management um this is",
    "start": "2256520",
    "end": "2262760"
  },
  {
    "text": "a nice diagram I came up with one day um basically when you're dealing with Wind",
    "start": "2262760",
    "end": "2267880"
  },
  {
    "text": "32 heat management you have a lot of different possibilities with which maloc implementation you are dealing there",
    "start": "2267880",
    "end": "2273200"
  },
  {
    "text": "could be a customized Heap implementation that the application has provided itself in order to enhance",
    "start": "2273200",
    "end": "2279000"
  },
  {
    "text": "performance could be the regular lipy which is provided with every compiler like the Balland",
    "start": "2279000",
    "end": "2284920"
  },
  {
    "text": "lipy or the visual C lipy maloc or it could be the direct way to the anti- Heap memory API via Heap aloc Heap free",
    "start": "2284920",
    "end": "2292200"
  },
  {
    "text": "and so on and um what's funny though is that all three",
    "start": "2292200",
    "end": "2299599"
  },
  {
    "text": "allocation functions in the win32 API local eloc aloc Heap aloc and Global",
    "start": "2299599",
    "end": "2305000"
  },
  {
    "text": "aloc end up calling RL allocate Heap and NTD I heard that these two are only",
    "start": "2305000",
    "end": "2311839"
  },
  {
    "text": "there for legacy reasons so um that might be an explanation so what we need to do is",
    "start": "2311839",
    "end": "2318920"
  },
  {
    "text": "take apart RL allocate Heap in order to find out what we have to do in order to write to arbitrary",
    "start": "2318920",
    "end": "2325240"
  },
  {
    "text": "addresses um while the entire RTL allocator is not documented by Microsoft at least not publicly",
    "start": "2326119",
    "end": "2332359"
  },
  {
    "text": "available um it seems to change from time to time at least I've seen an builds which had a different allocator",
    "start": "2332359",
    "end": "2337920"
  },
  {
    "text": "than my 2k build has and it is considerably more complex than Ballance algorithm I'll quickly show a small",
    "start": "2337920",
    "end": "2347519"
  },
  {
    "text": "graph",
    "start": "2365440",
    "end": "2368440"
  },
  {
    "text": "so um this is the simple free in RTL",
    "start": "2371440",
    "end": "2377520"
  },
  {
    "text": "fre but it calls a bunch of sub functions which are um not really to be called Simple this",
    "start": "2377520",
    "end": "2385359"
  },
  {
    "text": "is the um wind Tok Heap implementation function which is there for coaling free",
    "start": "2385359",
    "end": "2392720"
  },
  {
    "text": "blocks normally people people would laugh at this point come",
    "start": "2394880",
    "end": "2400040"
  },
  {
    "text": "on is everybody that tired didn't see any of you singing Koke",
    "start": "2401079",
    "end": "2409318"
  },
  {
    "text": "yesterday pass out okay that's an excuse all right um there's two",
    "start": "2410960",
    "end": "2418839"
  },
  {
    "text": "different ways of exploitation of um buffer overuns in the um win 2K heat",
    "start": "2418839",
    "end": "2424079"
  },
  {
    "text": "manager I'll just cover one the other one is for exercise at home",
    "start": "2424079",
    "end": "2431480"
  },
  {
    "text": "so um in the wind 2K environment you have an eight block control block before",
    "start": "2431520",
    "end": "2437200"
  },
  {
    "text": "every memory block so um after two allocations of 32 bytes we",
    "start": "2437200",
    "end": "2443280"
  },
  {
    "text": "again have those two adjunction blocks with control blocks in between the two and when we're now overriding",
    "start": "2443280",
    "end": "2449599"
  },
  {
    "text": "control Block B um we can play a few funny games where was where we right here so",
    "start": "2449599",
    "end": "2459280"
  },
  {
    "text": "I've highlighted in magenta again the two overrides which we want to get to or",
    "start": "2459280",
    "end": "2464560"
  },
  {
    "text": "we only want to get to one which is over here this",
    "start": "2464560",
    "end": "2472200"
  },
  {
    "text": "one so I'll quickly highlight the code path we have to",
    "start": "2473880",
    "end": "2480040"
  },
  {
    "text": "take",
    "start": "2485240",
    "end": "2488240"
  },
  {
    "text": "I should get the full version of this program",
    "start": "2496440",
    "end": "2500000"
  },
  {
    "text": "soon this LIC to sorry is this license to uh well must be a",
    "start": "2501640",
    "end": "2509440"
  },
  {
    "text": "mistake happens sometimes okay",
    "start": "2509440",
    "end": "2517599"
  },
  {
    "text": "so this is the path we want to",
    "start": "2517599",
    "end": "2521720"
  },
  {
    "text": "take going all the way through all the Yellow Boxes and Landing down",
    "start": "2523319",
    "end": "2528520"
  },
  {
    "text": "here so we'll have to read a little bit of assembly",
    "start": "2528880",
    "end": "2533599"
  },
  {
    "text": "again um standard prologue more or less um setting a few variables to zero and",
    "start": "2535000",
    "end": "2540880"
  },
  {
    "text": "so on testing whether this is the the pointer being passed into the free is not zero",
    "start": "2540880",
    "end": "2548160"
  },
  {
    "text": "whoops I shouldn't buy this program just",
    "start": "2550640",
    "end": "2556078"
  },
  {
    "text": "crashed didn't do that in rehearsal",
    "start": "2560079",
    "end": "2564119"
  },
  {
    "text": "though okay",
    "start": "2573000",
    "end": "2578160"
  },
  {
    "text": "so we have the standard prologue we following the",
    "start": "2585680",
    "end": "2593520"
  },
  {
    "text": "graph is not really interesting to us right now here we see that the control block",
    "start": "2593520",
    "end": "2599119"
  },
  {
    "text": "address that the control block address is being loaded into ESI and",
    "start": "2599119",
    "end": "2605079"
  },
  {
    "text": "then the bit one of the bite at ESI plus 5 is",
    "start": "2605079",
    "end": "2611000"
  },
  {
    "text": "being tested in order to get to the code we want to reach it has to be set so we",
    "start": "2611000",
    "end": "2616839"
  },
  {
    "text": "know that the data with which we overflowing the buffer has to have the bit one of the fifth bite",
    "start": "2616839",
    "end": "2625160"
  },
  {
    "text": "set this is just a well there is not an important check you just have to make",
    "start": "2630240",
    "end": "2636240"
  },
  {
    "text": "sure that these three bits are not set otherwise it'll report an error and not get to where we want to",
    "start": "2636240",
    "end": "2642800"
  },
  {
    "text": "go and",
    "start": "2642800",
    "end": "2649000"
  },
  {
    "text": "whoops oh no um",
    "start": "2649280",
    "end": "2656079"
  },
  {
    "text": "okay then we'll do it a bit less",
    "start": "2656079",
    "end": "2660200"
  },
  {
    "text": "visual so this is the disassembly",
    "start": "2663359",
    "end": "2668000"
  },
  {
    "text": "quite lost though I need that graph damn",
    "start": "2677440",
    "end": "2681280"
  },
  {
    "text": "it",
    "start": "2694960",
    "end": "2697960"
  },
  {
    "text": "okay we've been here before we've been here before here we are Field Four the bite",
    "start": "2703040",
    "end": "2709960"
  },
  {
    "text": "at ESI plus 4 has to be smaller than 40 40 hex in order to reach our code so um",
    "start": "2709960",
    "end": "2715960"
  },
  {
    "text": "40 hex is like one below the a so if you stress test the Heap implementation with",
    "start": "2715960",
    "end": "2723040"
  },
  {
    "text": "A's or B's or any kind of letter you will not reach the relevant",
    "start": "2723040",
    "end": "2728520"
  },
  {
    "text": "code so just sending large strings will not",
    "start": "2728960",
    "end": "2733520"
  },
  {
    "text": "help okay this is not really interesting blah",
    "start": "2734440",
    "end": "2740960"
  },
  {
    "text": "blah blah and we end up at this point here where the bite at",
    "start": "2740960",
    "end": "2748359"
  },
  {
    "text": "ESI + 5 is tested against having bit four set if that bit is zero we're getting to",
    "start": "2748359",
    "end": "2757400"
  },
  {
    "text": "where we want to go so from this graph we can see that the",
    "start": "2757400",
    "end": "2762920"
  },
  {
    "text": "criteria for the block which we have to write are Bit Zero of flags have to be",
    "start": "2762920",
    "end": "2768559"
  },
  {
    "text": "set Flags is the bite at ESI plus 5 bit three of flags must be",
    "start": "2768559",
    "end": "2773680"
  },
  {
    "text": "set Field Four must be smaller than 40 and the first field own size must be",
    "start": "2773680",
    "end": "2780079"
  },
  {
    "text": "larger than 80 I'm not sure where we had that larger than 80 but it has to be that way so um",
    "start": "2780079",
    "end": "2787680"
  },
  {
    "text": "the block XXX 99xx meets all the requirements and if we actually overflow",
    "start": "2787680",
    "end": "2793359"
  },
  {
    "text": "using that block or with that block we end up at this",
    "start": "2793359",
    "end": "2799440"
  },
  {
    "text": "point at ESI Min - 24 and then we have the pointer",
    "start": "2800079",
    "end": "2807078"
  },
  {
    "text": "exchange so ESI was before pointing to the Block B Control Data and then slides backwards into the",
    "start": "2808000",
    "end": "2815839"
  },
  {
    "text": "the memory error which we control remember we're currently freeing memory block b we're not freeing memory",
    "start": "2815839",
    "end": "2821480"
  },
  {
    "text": "memory block a slides back into memory block a to this",
    "start": "2821480",
    "end": "2827680"
  },
  {
    "text": "location and then it loads the double word at that",
    "start": "2827880",
    "end": "2833240"
  },
  {
    "text": "location saves it into a local variable loads the double word at that location plus 4 saves it into a local",
    "start": "2833240",
    "end": "2841760"
  },
  {
    "text": "variable and then does the traditional pointer Exchange",
    "start": "2841760",
    "end": "2847720"
  },
  {
    "text": "so we can have a quick demonstration of how this works as",
    "start": "2850680",
    "end": "2855599"
  },
  {
    "text": "well okay this should be",
    "start": "2865280",
    "end": "2872559"
  },
  {
    "text": "20 30 32",
    "start": "2872559",
    "end": "2877720"
  },
  {
    "text": "two okay um obviously we do have a SE",
    "start": "2878359",
    "end": "2885599"
  },
  {
    "text": "F would be nice if I could show how we got there though",
    "start": "2885599",
    "end": "2891079"
  },
  {
    "text": "so okay we're going to set a break point on this location here for1 2",
    "start": "2896040",
    "end": "2903559"
  },
  {
    "text": "A5",
    "start": "2904640",
    "end": "2907640"
  },
  {
    "text": "um 2 A5 was that what I said",
    "start": "2915800",
    "end": "2922000"
  },
  {
    "text": "okay oh yeah",
    "start": "2922880",
    "end": "2928040"
  },
  {
    "text": "okay here's our break point which Trace into RTL free Heap",
    "start": "2930240",
    "end": "2937599"
  },
  {
    "text": "ESI + 5 the flag bite is",
    "start": "2942079",
    "end": "2950119"
  },
  {
    "text": "tested um does anybody happen to have a paper tissue my nose seems to be running",
    "start": "2956240",
    "end": "2962920"
  },
  {
    "text": "uh we're entering a critical section",
    "start": "2962920",
    "end": "2967520"
  },
  {
    "text": "there's a new word I learned two days ago it's called mooch",
    "start": "2968520",
    "end": "2976160"
  },
  {
    "text": "thanks oh let's switch the microphone off damn",
    "start": "2984400",
    "end": "2991400"
  },
  {
    "text": "it now I do have enough stuff to present I'm not trying to waste",
    "start": "2994520",
    "end": "3001440"
  },
  {
    "text": "time",
    "start": "3005559",
    "end": "3008559"
  },
  {
    "text": "okay back to work all right we just entered the critical",
    "start": "3011720",
    "end": "3017480"
  },
  {
    "text": "section and here we are add ESI minus 18 hex which is 24",
    "start": "3017480",
    "end": "3027440"
  },
  {
    "text": "save it into a local variable load eax with a double word at that location look what's in E right",
    "start": "3028520",
    "end": "3035720"
  },
  {
    "text": "now the stuff we supplied down",
    "start": "3035720",
    "end": "3043040"
  },
  {
    "text": "here all those letters that we typed before it's being saved in a local",
    "start": "3043680",
    "end": "3049119"
  },
  {
    "text": "variable ESI gets loaded with a double word at ESI plus 4 so ESI has Supply bar as well and",
    "start": "3049119",
    "end": "3058200"
  },
  {
    "text": "then they try to write this value to the location at",
    "start": "3058200",
    "end": "3063240"
  },
  {
    "text": "ESI right here and to write ESI to the location at eix plus 4 right below so again we can",
    "start": "3063240",
    "end": "3070880"
  },
  {
    "text": "write any value to any location as long as both values are paged and um we now get a nice",
    "start": "3070880",
    "end": "3079880"
  },
  {
    "text": "fa any questions no all",
    "start": "3080240",
    "end": "3088119"
  },
  {
    "text": "right okay so things to note down for the wind 2K heat manager if we can override r at",
    "start": "3091200",
    "end": "3098599"
  },
  {
    "text": "least the lowest six bytes of the next control block we can have the the pointer slide backwards 24 bytes in the",
    "start": "3098599",
    "end": "3105480"
  },
  {
    "text": "middle of our buffer and the right then right to arbitrary addresses secondly um",
    "start": "3105480",
    "end": "3110520"
  },
  {
    "text": "it's quite important to know that there is way more than one way to exploit these",
    "start": "3110520",
    "end": "3116240"
  },
  {
    "text": "um you've seen how large the entire RL free Heap and the kesing is I do have a",
    "start": "3116240",
    "end": "3121760"
  },
  {
    "text": "complete decompile of the RL free Heap but I haven't bothered to decompile that kesing function yet because it's so ugly",
    "start": "3121760",
    "end": "3128000"
  },
  {
    "text": "um so there are many more ways to do this really depends on your situation",
    "start": "3128000",
    "end": "3133599"
  },
  {
    "text": "take a disassembler take your debugger take a few",
    "start": "3133599",
    "end": "3138559"
  },
  {
    "text": "days and um well good",
    "start": "3138799",
    "end": "3143920"
  },
  {
    "text": "luck okay um so to sum up the first half or to begin with summing up the first",
    "start": "3143920",
    "end": "3150480"
  },
  {
    "text": "half things are changing these days um especially the way bugs are being exploited and the kind of bugs that are",
    "start": "3150480",
    "end": "3156520"
  },
  {
    "text": "being discovered change the standard stack measures are slowly going away and",
    "start": "3156520",
    "end": "3163720"
  },
  {
    "text": "um what is more prominent these days are heat-based overflows double freeze um",
    "start": "3163720",
    "end": "3170440"
  },
  {
    "text": "format string bugs and close Source applications and um I think the standard",
    "start": "3170440",
    "end": "3176200"
  },
  {
    "text": "how to exploit a string copy is not going to be very relevant in the future um especially with um Microsoft",
    "start": "3176200",
    "end": "3183280"
  },
  {
    "text": "finally introducing something kind of like stack out for visual c um the",
    "start": "3183280",
    "end": "3188720"
  },
  {
    "text": "standard EIP overwriting on the stack will not be there anymore which doesn't bother because it's boring",
    "start": "3188720",
    "end": "3195440"
  },
  {
    "text": "anyways right um well you can see biological anal an analogies in the",
    "start": "3195440",
    "end": "3200640"
  },
  {
    "text": "world of bugs that valuable and easy to find bugs are not going to last long so",
    "start": "3200640",
    "end": "3207040"
  },
  {
    "text": "we've seen with with format string bugs that a particularly easy to spun bug",
    "start": "3207040",
    "end": "3212839"
  },
  {
    "text": "which is very powerful will be very very very quickly gone and some people have realized over this entire format format",
    "start": "3212839",
    "end": "3219200"
  },
  {
    "text": "string things thing that bugs are something like a natural resource and um that's basically where",
    "start": "3219200",
    "end": "3226400"
  },
  {
    "text": "most of the the push these days from the hacking communi should not publish anything anymore comes from because some",
    "start": "3226400",
    "end": "3231960"
  },
  {
    "text": "people have realized damn we might be running out of bugs at some point",
    "start": "3231960",
    "end": "3237160"
  },
  {
    "text": "so um it's it's quite funny because on the one hand you have people like Microsoft and this entire Alliance of",
    "start": "3237160",
    "end": "3243240"
  },
  {
    "text": "security companies saying well we weren't responsibil disclosure and so on and on the other side you have the the",
    "start": "3243240",
    "end": "3248880"
  },
  {
    "text": "hackers or lots of the hackers saying hey we're not going to publish anything anymore anyways um so we really have a bit of a",
    "start": "3248880",
    "end": "3255799"
  },
  {
    "text": "paradigm shift here that I think the future is heading towards administrators",
    "start": "3255799",
    "end": "3260960"
  },
  {
    "text": "who get owned with zero day and that is every administrator nightmare",
    "start": "3260960",
    "end": "3267079"
  },
  {
    "text": "so secondly um the bugs are changing as the language is changing as more and",
    "start": "3269799",
    "end": "3275680"
  },
  {
    "text": "more programmers use C++ o STL whatever to write their code we will not have",
    "start": "3275680",
    "end": "3280880"
  },
  {
    "text": "those or we don't really have those string copy overflows anymore because everybody's using string classes but a",
    "start": "3280880",
    "end": "3286599"
  },
  {
    "text": "lot of those pitfalls and those languages haven't been really discovered it it took us 15 years to find format string bugs in",
    "start": "3286599",
    "end": "3292440"
  },
  {
    "text": "C so who knows what's there hiding some somewhere in Java or somewhere else um",
    "start": "3292440",
    "end": "3298839"
  },
  {
    "text": "especially with STL off by ones are possible I mean everybody knows that um or anybody who has programmed with STL",
    "start": "3298839",
    "end": "3304480"
  },
  {
    "text": "knows how annoying it can be to use an iterator which is not valid anymore or similar things so um you can mess up C++",
    "start": "3304480",
    "end": "3312280"
  },
  {
    "text": "code quite badly as well um well the new bugs which are currently coming out are mostly Heap",
    "start": "3312280",
    "end": "3318359"
  },
  {
    "text": "overuns and due to their nature they are not being found via stress testing anymore or well not many of them anyways",
    "start": "3318359",
    "end": "3325599"
  },
  {
    "text": "so um pretty much we can kiss Pearl goodbye all those million Pearl scripts that we've written to to fuzz every",
    "start": "3325599",
    "end": "3331280"
  },
  {
    "text": "server there is um we don't really need things like uh retina anymore with its",
    "start": "3331280",
    "end": "3337760"
  },
  {
    "text": "Advanced II that's built into Pearl and um well fuzzing will not do it in the",
    "start": "3337760",
    "end": "3343880"
  },
  {
    "text": "long run we need people to read the code actually I think we have to get away from the idea that that is possible to",
    "start": "3343880",
    "end": "3350400"
  },
  {
    "text": "to remove bugs automatically in any way um bugs can only be removed d by a human",
    "start": "3350400",
    "end": "3355839"
  },
  {
    "text": "because any solution of or even identifying a logic bug in the implementation of anything is equivalent",
    "start": "3355839",
    "end": "3362200"
  },
  {
    "text": "to the haling problem and is not solvable automatically so um don't think bug",
    "start": "3362200",
    "end": "3369119"
  },
  {
    "text": "finding can be automated some parts can be but nothing is well nothing will",
    "start": "3369119",
    "end": "3375079"
  },
  {
    "text": "prevent you from having to read the stuff reverse Engineers are well have a",
    "start": "3375079",
    "end": "3380599"
  },
  {
    "text": "bit of an advantage when it comes to close Source applications because they're the the ones that can document",
    "start": "3380599",
    "end": "3385680"
  },
  {
    "text": "and analyze the Heap implementations um as somebody who doesn't know Assembly Language you're going to have a hard time finding out",
    "start": "3385680",
    "end": "3392359"
  },
  {
    "text": "what exactly is going on or how to even exploit a heap overun with a stack stack smash it's fairly easy you just smash",
    "start": "3392359",
    "end": "3399119"
  },
  {
    "text": "the stack point the point somewhere take somebody else's Shell Code put in there and hope that it'll work with Heap over",
    "start": "3399119",
    "end": "3405079"
  },
  {
    "text": "runs especially in a closed Source environment you need to analyze the Heap implementation yourself there's just no",
    "start": "3405079",
    "end": "3411240"
  },
  {
    "text": "way around it um well whether you're sure of if your Java runtime is working 100%",
    "start": "3411240",
    "end": "3418039"
  },
  {
    "text": "correctly I will not even ask that um then we have to know that Library",
    "start": "3418039",
    "end": "3424680"
  },
  {
    "text": "functions are increasingly or not increasingly but they're being discovered as being a major source for bugs and many compilers have buggy",
    "start": "3424680",
    "end": "3431599"
  },
  {
    "text": "Library functions for example ball and C has a buggy Malo and um well if you run Statistics",
    "start": "3431599",
    "end": "3438359"
  },
  {
    "text": "over source code I don't think you'll find any Library call that's used more frequently than Malo um anybody spot the",
    "start": "3438359",
    "end": "3446119"
  },
  {
    "text": "mistake mistake is defined as anything that um would Malo behave in a way that",
    "start": "3446119",
    "end": "3451359"
  },
  {
    "text": "it's not supposed to",
    "start": "3451359",
    "end": "3454440"
  },
  {
    "text": "behave aign size is furthermore used never check for negative sorry",
    "start": "3457119",
    "end": "3463400"
  },
  {
    "text": "never checks for negative size right exactly so if you put something in",
    "start": "3463400",
    "end": "3469039"
  },
  {
    "text": "there like request in size of minus one or 4 GB wrap around down here and",
    "start": "3469039",
    "end": "3474799"
  },
  {
    "text": "allocate something like 8 bytes and miss or 9 bytes and mess the Heap up during that process so um any kind of Moc which",
    "start": "3474799",
    "end": "3483920"
  },
  {
    "text": "takes a user influence value is dangerous and there's a lot of mocs which take user influence values for example if you try to allocate an error",
    "start": "3483920",
    "end": "3490680"
  },
  {
    "text": "of structures and the user puts something in there like um user supplied value times size of",
    "start": "3490680",
    "end": "3497920"
  },
  {
    "text": "structure which would locate an arror if that wraps around or even gets to 4 GB and the program thinks everything's fine",
    "start": "3497920",
    "end": "3504440"
  },
  {
    "text": "because Meo didn't fail but returned a poter to a 12 bite buffer things are going to get screwed",
    "start": "3504440",
    "end": "3511599"
  },
  {
    "text": "somewhow and um some people claim that major bugs are or the the major bugs are",
    "start": "3512319",
    "end": "3518559"
  },
  {
    "text": "slowly going out of the open source project as well um this is an allocator from a",
    "start": "3518559",
    "end": "3525079"
  },
  {
    "text": "major a major major major open source application and that one is buggy as",
    "start": "3525079",
    "end": "3531760"
  },
  {
    "text": "well um those people who were in my class know this one already so they're excluded from answering this um anybody",
    "start": "3531760",
    "end": "3539039"
  },
  {
    "text": "else know the",
    "start": "3539039",
    "end": "3541520"
  },
  {
    "text": "mistake",
    "start": "3563640",
    "end": "3566640"
  },
  {
    "text": "uh let me think well what you mean by it doesn't check",
    "start": "3573680",
    "end": "3578960"
  },
  {
    "text": "size it does block with size yes but it",
    "start": "3582400",
    "end": "3590240"
  },
  {
    "text": "checks it Che re size for uh negative value but doesn't check",
    "start": "3590240",
    "end": "3595680"
  },
  {
    "text": "um um it doesn't check size for negative value yes so",
    "start": "3595680",
    "end": "3601720"
  },
  {
    "text": "if re size",
    "start": "3601720",
    "end": "3605920"
  },
  {
    "text": "is she gave I think some small value forze",
    "start": "3612640",
    "end": "3620599"
  },
  {
    "text": "generate a negative value um not exactly but you're you're close to actually the the logic bug is basically that they",
    "start": "3620599",
    "end": "3627240"
  },
  {
    "text": "check size uh check Rec size but use size what they what happens here is they round the request size up to the next",
    "start": "3627240",
    "end": "3634599"
  },
  {
    "text": "align value so um and Rec size is an INT a signed int and signed ins become",
    "start": "3634599",
    "end": "3641599"
  },
  {
    "text": "negative as soon as the highest level bit is being set so if you send something in there which is like right below 2",
    "start": "3641599",
    "end": "3649240"
  },
  {
    "text": "gbes it'll around like right a very large positive number which is very close to being negative which will wrap",
    "start": "3649240",
    "end": "3657079"
  },
  {
    "text": "around to be negative if you add two or three this rounding up will wrap it around to be",
    "start": "3657079",
    "end": "3662480"
  },
  {
    "text": "negative and this check will pass because you put a positive value in there and this call will corrupt the",
    "start": "3662480",
    "end": "3670319"
  },
  {
    "text": "heat um and as long as we find bugs like these in CS which are that frequently",
    "start": "3670319",
    "end": "3677160"
  },
  {
    "text": "used as maloc I don't really think that um anyone of us is going to be out of a job",
    "start": "3677160",
    "end": "3683440"
  },
  {
    "text": "soon anyways I think it's time well not exactly yet but I think it's time to",
    "start": "3683440",
    "end": "3689760"
  },
  {
    "text": "have a break thank",
    "start": "3689760",
    "end": "3693680"
  },
  {
    "text": "you",
    "start": "3713440",
    "end": "3716440"
  }
]