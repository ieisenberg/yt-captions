[
  {
    "text": "uh everyone welcome to at this is a Zer",
    "start": "29039",
    "end": "37399"
  },
  {
    "text": "Zer it's going to be talking about the checking array bound uh violation using",
    "start": "37399",
    "end": "43079"
  },
  {
    "text": "segmentation Hardware okay okay thanks so um so um in this talk I'm going to",
    "start": "43079",
    "end": "50399"
  },
  {
    "text": "talk about a sort of like a somewhat technical way of um checking aray bang uh violation so the basic idea is try to",
    "start": "50399",
    "end": "58160"
  },
  {
    "text": "use this program transformation approach so that we can uh compile a program in",
    "start": "58160",
    "end": "63359"
  },
  {
    "text": "such a way that the resulting binary is is guaranteed to be free from buffer overflow vulnerabilities and its",
    "start": "63359",
    "end": "70200"
  },
  {
    "text": "longtime performance overhead is relatively low compared to existing approach so if you look at the landscape",
    "start": "70200",
    "end": "76759"
  },
  {
    "text": "in terms of the attack Primitives that modern worms use yeah they actually fall into two categories the first category",
    "start": "76759",
    "end": "82600"
  },
  {
    "text": "is sort of automatic approach like you know you just you don't have any you know you don't have to do anything as a user you don't have to do anything you",
    "start": "82600",
    "end": "88640"
  },
  {
    "text": "just have some vable program running on some servers and attackers are able to",
    "start": "88640",
    "end": "93920"
  },
  {
    "text": "exploit this vulnerability and try to get in control your application and even underline machines what they can do is",
    "start": "93920",
    "end": "99680"
  },
  {
    "text": "they can inject some code into these applications or they can actually use the existing code already in the",
    "start": "99680",
    "end": "105040"
  },
  {
    "text": "application that's known as return to lipy attack or they can actually just change some of the data in the",
    "start": "105040",
    "end": "110360"
  },
  {
    "text": "application in such a way they can subtly change the program flow or even the arguments to the system calls the",
    "start": "110360",
    "end": "116479"
  },
  {
    "text": "second categor requires user input like you know somebody send a malicious",
    "start": "116479",
    "end": "121759"
  },
  {
    "text": "attachment in the emails and so user actually have to click on it or you know send in some something embeding",
    "start": "121759",
    "end": "128000"
  },
  {
    "text": "something in the web download HTML Pages or even just like files being transferred between FTP sites and P2P",
    "start": "128000",
    "end": "135680"
  },
  {
    "text": "softwares so today we are going to look at mainly these automatic attacks because for modern worm that's what we",
    "start": "135680",
    "end": "141480"
  },
  {
    "text": "are worried about like you know that you just have software vulnerability and somebody can exploit it to try to",
    "start": "141480",
    "end": "147040"
  },
  {
    "text": "propagate worms from one machine to the other so these automatic attacks typically are referred to as control",
    "start": "147040",
    "end": "152959"
  },
  {
    "text": "hijacking attacks because they try to hijack the control of the victim applications and sometimes even the",
    "start": "152959",
    "end": "159280"
  },
  {
    "text": "underlying machines turn them into a zombie or something and interestingly enough these control hijacking attacks",
    "start": "159280",
    "end": "165080"
  },
  {
    "text": "typically have a well defined three-step recipe it's actually very very clearly defined how they actually do these kind",
    "start": "165080",
    "end": "171280"
  },
  {
    "text": "of things so the first thing they try to do is they want try to insert some sort of malicious stuff into the address bace",
    "start": "171280",
    "end": "177440"
  },
  {
    "text": "of the victim application so you have victim applications running on the machines somehow you know the attacker",
    "start": "177440",
    "end": "183040"
  },
  {
    "text": "by inputting something you can tamper with the address base of the application so this is just like a re you know",
    "start": "183040",
    "end": "188959"
  },
  {
    "text": "airplane hijacking you try to sneak some weapons into an airplane or and the second step the the attacker triy to do",
    "start": "188959",
    "end": "195799"
  },
  {
    "text": "is that once you can inject something into the address space then you try to trick the victim application to transfer",
    "start": "195799",
    "end": "201280"
  },
  {
    "text": "control to some place either to the injected code or to some existing Cod so it's like a a hijacker trying to take",
    "start": "201280",
    "end": "207920"
  },
  {
    "text": "control of the victim's airplane and once the the attackers grabs control of the victim application now he can do",
    "start": "207920",
    "end": "214799"
  },
  {
    "text": "whatever he wants by you know issuing some sort of damaging system call to achieve whatever purpose that that he",
    "start": "214799",
    "end": "220560"
  },
  {
    "text": "has in mind so so the question here is that how does a attacker actually override or",
    "start": "220560",
    "end": "227360"
  },
  {
    "text": "temple with the victim applications address bace so the most dominant way that people use today are is sort of is",
    "start": "227360",
    "end": "233720"
  },
  {
    "text": "buff overflowing they try to input something and then overflow the particular uh storage space allocated to",
    "start": "233720",
    "end": "240879"
  },
  {
    "text": "receive that input packet and the other possible possibilities include integer",
    "start": "240879",
    "end": "245959"
  },
  {
    "text": "overflowing this exploits the the finite Precision computer arithmetic underflow",
    "start": "245959",
    "end": "251519"
  },
  {
    "text": "overflow or the attacker can prepare malicious format streams used in the print F like functions so they can read",
    "start": "251519",
    "end": "258600"
  },
  {
    "text": "stuff or write stuff into the address space and the kind of Target they use to overwrite including things things like",
    "start": "258600",
    "end": "265000"
  },
  {
    "text": "stack hip or Global area so these are all pretty well understood",
    "start": "265000",
    "end": "270120"
  },
  {
    "text": "stuff so just to give you an example to illustrate this three-step procedure so this is a simple example that I that I",
    "start": "270120",
    "end": "277039"
  },
  {
    "text": "made up so basically we have a program that has that consists of two function man and input in the input it allocates",
    "start": "277039",
    "end": "283600"
  },
  {
    "text": "a local integer array called user ID which has five integers and in this",
    "start": "283600",
    "end": "288759"
  },
  {
    "text": "particular uh program in this particular function input when you try to input something from the outside it doesn't",
    "start": "288759",
    "end": "294280"
  },
  {
    "text": "check AR bound and that's where the mistake is so as a result the the the attacker could actually overflow this",
    "start": "294280",
    "end": "300400"
  },
  {
    "text": "particular array user ID and try to override something behind this array and typically what they try to override is",
    "start": "300400",
    "end": "307160"
  },
  {
    "text": "something call control sensitive data structure like return address function pointer go and so on in this case it's a",
    "start": "307160",
    "end": "313440"
  },
  {
    "text": "return address and the value they use to override it is some some places they they inject the code in this case",
    "start": "313440",
    "end": "320000"
  },
  {
    "text": "position 100 so that that's what happens so you can say the first step they try to do is they try to overflow and that's",
    "start": "320000",
    "end": "325520"
  },
  {
    "text": "the very first step so they can overflow behind this allocated storage space and then they try to steal the control of",
    "start": "325520",
    "end": "331840"
  },
  {
    "text": "the application by overwriting that control sensitive data structure which is something that they inject and then",
    "start": "331840",
    "end": "338240"
  },
  {
    "text": "eventually once they grab control they can make system calls whatever system call they want in particular you know forking a Shar sending a fire and so on",
    "start": "338240",
    "end": "346120"
  },
  {
    "text": "so given this this analysis of the three-step procedure being used in this",
    "start": "346120",
    "end": "351199"
  },
  {
    "text": "control hijacking attacks we can actually develop a corresponding multi-prong defense strategy so if we",
    "start": "351199",
    "end": "357919"
  },
  {
    "text": "want to startop this kind of control hijacking attacks and again these control hying attacks are The Primitives",
    "start": "357919",
    "end": "363280"
  },
  {
    "text": "used in modern worms we can actually do sort of one of the three things so the",
    "start": "363280",
    "end": "368319"
  },
  {
    "text": "first thing is that we can stop this uh control hijacking attacks by preventing overflowing in the first place we just",
    "start": "368319",
    "end": "374199"
  },
  {
    "text": "don't want anybody to overflow and temper with bigtim applications of Dr space and that's aay bang checkin which",
    "start": "374199",
    "end": "381160"
  },
  {
    "text": "is the topic of today's talk or you can stop control hijacking attacks by saying",
    "start": "381160",
    "end": "386639"
  },
  {
    "text": "that I'm going to prevent any illegitimate control transfer right remember the idea there is that the attacker can actually override some",
    "start": "386639",
    "end": "393080"
  },
  {
    "text": "sensitive data structure like return address or function pointer and steer the control of the application to",
    "start": "393080",
    "end": "398599"
  },
  {
    "text": "wherever the attacker wants it to go so if we can somehow stop that then still",
    "start": "398599",
    "end": "403720"
  },
  {
    "text": "the attacker will not have a chance and this is a par another project called food they actually try to check the",
    "start": "403720",
    "end": "409800"
  },
  {
    "text": "target address of every indirect branches that include return include indirect jump and in including indirect",
    "start": "409800",
    "end": "417080"
  },
  {
    "text": "call so every such instruction they tar tget address will get checked and to see to make sure that they don't go to uh",
    "start": "417080",
    "end": "423199"
  },
  {
    "text": "bad places so that's the idea of the full project or you can say that this guy is really good then somehow he can",
    "start": "423199",
    "end": "429520"
  },
  {
    "text": "you know overflow something and steal the control of the application and then start to making system call and you can",
    "start": "429520",
    "end": "434919"
  },
  {
    "text": "also start you know this control hijacking attack by saying I'm going to prevent all the IL legitimated system",
    "start": "434919",
    "end": "440240"
  },
  {
    "text": "call so you have to have a notion of what system calls are legitimate and what system calls are not so there's",
    "start": "440240",
    "end": "446520"
  },
  {
    "text": "actually a project called paid that does exactly that from a particular application we are able to come up with",
    "start": "446520",
    "end": "452240"
  },
  {
    "text": "the the legitimate system call pattern and at the wrong time we check it whether it's actually legitimate or not",
    "start": "452240",
    "end": "458280"
  },
  {
    "text": "and so so this is the talk that I gave last year so so basically any one of",
    "start": "458280",
    "end": "463440"
  },
  {
    "text": "these three lines of defenses will do okay depending on the user requirements or system",
    "start": "463440",
    "end": "469280"
  },
  {
    "text": "configuration but today we are going to look at only AR bang checking all right so so the basic idea is that we don't",
    "start": "469280",
    "end": "476319"
  },
  {
    "text": "want people to overflow we don't want people to to temper with my address space so we want to prevent all unau",
    "start": "476319",
    "end": "483199"
  },
  {
    "text": "unauthorized modification of the address space so this should be the cleanest solution right there are a lot of uh",
    "start": "483199",
    "end": "489720"
  },
  {
    "text": "solutions to the software security problem they try to do really weird things when they once they come in we check this we check that I I I claim",
    "start": "489720",
    "end": "497560"
  },
  {
    "text": "that the clean solution is to stop them from overflowing in the first place they should not come in and Temple with your",
    "start": "497560",
    "end": "502879"
  },
  {
    "text": "address space in any way they want so that that's the that's that's what I think is the the best way to solve this",
    "start": "502879",
    "end": "508080"
  },
  {
    "text": "problem so the basic idea of array Bank checking is to say that for every memory reference in the program I'm going to",
    "start": "508080",
    "end": "514479"
  },
  {
    "text": "check whether this particular reference lies within the upper and lower limit of",
    "start": "514479",
    "end": "519800"
  },
  {
    "text": "the corresponding object right that's the basic idea so for every memory reference if it belongs to an array I",
    "start": "519800",
    "end": "524959"
  },
  {
    "text": "can find out what its lower bank and upper bank and make sure that no reference can exceed it this includes",
    "start": "524959",
    "end": "530440"
  },
  {
    "text": "both uh uh arrays as well as buffer so it includes also things allocated from Mal for example so there are actually",
    "start": "530440",
    "end": "537480"
  },
  {
    "text": "just two issues you need to deal with to do something like this from every memory reference first you have to figure out",
    "start": "537480",
    "end": "543360"
  },
  {
    "text": "what is its corresponding object higher level object like array structure you",
    "start": "543360",
    "end": "548640"
  },
  {
    "text": "know and buffer and so on and then you can perform the corresponding limit check like does this particular",
    "start": "548640",
    "end": "554240"
  },
  {
    "text": "reference exceeding the upper and lower limit and so on so this is like a pretty simple idea of course that's what you",
    "start": "554240",
    "end": "560880"
  },
  {
    "text": "should have done in order to prevent people from tempering with your address space so if array Bank checking is such",
    "start": "560880",
    "end": "568279"
  },
  {
    "text": "a great idea how come it was never adopted as a mainstream solution to this buffer overflow problem right it's sort",
    "start": "568279",
    "end": "575480"
  },
  {
    "text": "of obvious and then you know seems like you know there's a well welln algorithm to do this and the the answer is because",
    "start": "575480",
    "end": "583160"
  },
  {
    "text": "existing software based arang checking compiler is just simply too slow okay so",
    "start": "583160",
    "end": "588640"
  },
  {
    "text": "the performance penalty reported in the literature is is ranges um from two to",
    "start": "588640",
    "end": "594120"
  },
  {
    "text": "30 times slow down so the main issue that this particular talk tries to address is that how to reduce or even",
    "start": "594120",
    "end": "601680"
  },
  {
    "text": "eliminate this wrong time penalty by exploiting uh certain architectural feature in x 86",
    "start": "601680",
    "end": "608720"
  },
  {
    "text": "architecture so before we we go into the the idea I just want to review the virtual memory Hardware architecture in",
    "start": "608720",
    "end": "615720"
  },
  {
    "text": "x86 uh architecture so every memory reference in x86 architecture includes",
    "start": "615720",
    "end": "622399"
  },
  {
    "text": "two components one is a segment selector the other is offset okay so whenever you",
    "start": "622399",
    "end": "628200"
  },
  {
    "text": "write a c program for example eventually get compiled into binary every memory reference consist of these two things",
    "start": "628200",
    "end": "633880"
  },
  {
    "text": "you have to specify the segment selector and you have to specify the offset and with that segment selector is going to",
    "start": "633880",
    "end": "639839"
  },
  {
    "text": "go to either a global descriptor table gdt or local descriptor table and find",
    "start": "639839",
    "end": "645480"
  },
  {
    "text": "out a corresponding segments base and with that base it's going to add it to the offset to form a So-Cal linear",
    "start": "645480",
    "end": "651880"
  },
  {
    "text": "address and from that linear address you you can go through this So-Cal two level page table to arrive at the",
    "start": "651880",
    "end": "658120"
  },
  {
    "text": "corresponding physical code address which is the address that you use to access main memory so so in this process",
    "start": "658120",
    "end": "665160"
  },
  {
    "text": "it actually does one more thing which is called segment limit check so just to",
    "start": "665160",
    "end": "670279"
  },
  {
    "text": "make it simple so basically we have a virtual address which consists of segment selector plus offset and in the",
    "start": "670279",
    "end": "675639"
  },
  {
    "text": "process of forming linear address the hardware already performed such a check",
    "start": "675639",
    "end": "681560"
  },
  {
    "text": "that it Mak sure that the resing linear address lies within the lower and upper",
    "start": "681560",
    "end": "686920"
  },
  {
    "text": "limit of the corresponding segment and virtual memory Hardware of x86",
    "start": "686920",
    "end": "692920"
  },
  {
    "text": "architecture has been doing this for years it just said for most operating system they simply ignore segments so",
    "start": "692920",
    "end": "700040"
  },
  {
    "text": "this particular Hardware feature never get used so it's not like a additional Hardware support or anything you know",
    "start": "700040",
    "end": "706040"
  },
  {
    "text": "every memory reference in every x86 Box is doing that just that nobody tried to use it to to to their advantage to do",
    "start": "706040",
    "end": "712760"
  },
  {
    "text": "something and that's exactly what we are trying to do so so the basic I the basic goal of this cach system is trying to",
    "start": "712760",
    "end": "720240"
  },
  {
    "text": "exploit this segment limit check Hardware to perform a ray bang checking for free right so you see the similarity",
    "start": "720240",
    "end": "727200"
  },
  {
    "text": "between the two right for array Bank checking we say for every memory reference I'm going to find a corresponding object and figure out",
    "start": "727200",
    "end": "733920"
  },
  {
    "text": "whether this particular memory reference lies within a lower and upper limit of that object for Segment it does similar",
    "start": "733920",
    "end": "740040"
  },
  {
    "text": "thing right for every reference it also checks whether it lies within the lower and upper limit of that corresponding",
    "start": "740040",
    "end": "745760"
  },
  {
    "text": "segment so that's exactly what you want so all we have to do is just to allocate a segment for each array or buffer in",
    "start": "745760",
    "end": "753560"
  },
  {
    "text": "the program and then generate code accordingly such that the resulting",
    "start": "753560",
    "end": "758959"
  },
  {
    "text": "segment limit check Hardware is doing this AR bang checking for us essentially",
    "start": "758959",
    "end": "764680"
  },
  {
    "text": "right so that's the that's the trick to twist it to do it and therefore you don't really need special Hardware support and you can speed up the arang",
    "start": "764680",
    "end": "771600"
  },
  {
    "text": "checkin dramatically so so there are a couple of design",
    "start": "771600",
    "end": "777560"
  },
  {
    "text": "issues associated with with u uh cache so the first issue is that given a",
    "start": "777560",
    "end": "783480"
  },
  {
    "text": "memory reference how do you map or find the corresponding high level object that",
    "start": "783480",
    "end": "788720"
  },
  {
    "text": "includes that particular memory reference and the second thing is how do you generate code such that you know you",
    "start": "788720",
    "end": "794480"
  },
  {
    "text": "can twist the segment limit uh check Hardware to do what is supposed to do imply performing aray bang checking and",
    "start": "794480",
    "end": "802120"
  },
  {
    "text": "then in in some cases you just cannot use this uh segment limit check to perform aray bang check so you actually",
    "start": "802120",
    "end": "808120"
  },
  {
    "text": "you actually have to fall back to software array bang check so in those cases we have to generate code such that",
    "start": "808120",
    "end": "814160"
  },
  {
    "text": "uh everything get checked but then there are other sort of excuse me architectural limitations of x86",
    "start": "814160",
    "end": "822560"
  },
  {
    "text": "architecture that sort of prevent this idea from uh happening easily for",
    "start": "822560",
    "end": "827639"
  },
  {
    "text": "example there are only a finite number of segment descriptors in x86 architecture uh specification and",
    "start": "827639",
    "end": "834839"
  },
  {
    "text": "there's a very small number of segment register that keeps uh you know us from using multiple segments simultaneously",
    "start": "834839",
    "end": "842240"
  },
  {
    "text": "and also there's this issue of once you want to allocate a segment for each uh",
    "start": "842240",
    "end": "847600"
  },
  {
    "text": "array or object you have to modify this local descriptor table lodt very",
    "start": "847600",
    "end": "852959"
  },
  {
    "text": "frequently and lodt typically is living in the kernel space and therefore it means that you have to make a lot of",
    "start": "852959",
    "end": "858959"
  },
  {
    "text": "system code just to modify it and that turns out to be a big issue for",
    "start": "858959",
    "end": "864079"
  },
  {
    "text": "us so for the first problem like how do you uh associate a particular memory",
    "start": "864079",
    "end": "869120"
  },
  {
    "text": "reference with its corresponding high level memory object one approach is to organize all the memory objects in the",
    "start": "869120",
    "end": "876120"
  },
  {
    "text": "program as a spray tree it's just like a you know just like a try essentially so you can actually find given a memory",
    "start": "876120",
    "end": "882399"
  },
  {
    "text": "address think of is just like a tree you can give a memory address you can actually look it up in the tree and to",
    "start": "882399",
    "end": "887920"
  },
  {
    "text": "search the corresponding object and there you will include a corresponding lower and upper bank so in this",
    "start": "887920",
    "end": "893880"
  },
  {
    "text": "particular approach that means for every memory reference I need a spread tree Lookout like the memory access is very",
    "start": "893880",
    "end": "900120"
  },
  {
    "text": "simple read and write a single instruction but for that I need to do a spray tree lookup so that's like a you",
    "start": "900120",
    "end": "906240"
  },
  {
    "text": "know pretty expensive but the good thing about this approach is it's compatible you don't really it's compatible with",
    "start": "906240",
    "end": "911800"
  },
  {
    "text": "the Legacy libraries or legacy codes and this approach has been used in Imperial College fun checking compiler right so",
    "start": "911800",
    "end": "919920"
  },
  {
    "text": "as I said the advantage is compatible with the Legacy code that's pretty nice is actually very important and the disadvantage is very slow so sometimes",
    "start": "919920",
    "end": "926800"
  },
  {
    "text": "it could be up to 30 times slower okay because of this uh additional lookout for every memory access instruction so",
    "start": "926800",
    "end": "933680"
  },
  {
    "text": "that's kind of bad the an a alternative approach to the spray tree implementation is to use",
    "start": "933680",
    "end": "940480"
  },
  {
    "text": "Shadow variable or soal fat pointer it's a matter of whether you you maintain a satellite data structure for every",
    "start": "940480",
    "end": "947040"
  },
  {
    "text": "pointer variable and then whether they are know consecutively located with the together with the pointer or they are",
    "start": "947040",
    "end": "953600"
  },
  {
    "text": "you know store someplace else so whenever you want to uh access something",
    "start": "953600",
    "end": "958839"
  },
  {
    "text": "instead of looking up in a spray tree the corresponding satellite data structure contains all the information you want and then you can do your check",
    "start": "958839",
    "end": "965680"
  },
  {
    "text": "accordingly so that's pretty easy so the advantage of this approach is fast but the disadvantage is U there's a",
    "start": "965680",
    "end": "972399"
  },
  {
    "text": "compatibility issue like you can imagine that for every uh pointer there's actually a satellite data structure and",
    "start": "972399",
    "end": "978160"
  },
  {
    "text": "when you actually have to pass a pointer you have to pass the corresponding uh satellite data structure so the API",
    "start": "978160",
    "end": "984319"
  },
  {
    "text": "interface will not be compartible anymore right so you have to pass in additional stuff so there's a compatibility issue here and also the",
    "start": "984319",
    "end": "992319"
  },
  {
    "text": "idea of share variable and fed pointer is somewhat competent for some data structure right if you have a some",
    "start": "992319",
    "end": "998360"
  },
  {
    "text": "pointer it's probably easy but what if you have pointers within a structure within a structure and so on so where",
    "start": "998360",
    "end": "1004519"
  },
  {
    "text": "are you going to put this Shadow uh satellite data structure and so on so there are issues like that that makes",
    "start": "1004519",
    "end": "1011120"
  },
  {
    "text": "this particular approach not as clean as a spray tree implementation all",
    "start": "1011120",
    "end": "1016440"
  },
  {
    "text": "right so so it just as a example to demon to show that how this is done so for example you have a",
    "start": "1016440",
    "end": "1023040"
  },
  {
    "text": "original pointer P to on the left column so you you have to orament this particular pointer with additional data",
    "start": "1023040",
    "end": "1029400"
  },
  {
    "text": "structure to recall uh additional stuff in this case you have to recall the corresponding segment remember we",
    "start": "1029400",
    "end": "1036000"
  },
  {
    "text": "allocate segment for every object right so I have to recall the corresponding objects segment there's LTI the index",
    "start": "1036000",
    "end": "1043360"
  },
  {
    "text": "into the LT and then we we have to recall the corresponding base and limit this is this is used for for software uh",
    "start": "1043360",
    "end": "1049919"
  },
  {
    "text": "array Bank check as a fullback mechanism and for array we have to do allocate additional satellite structure like this",
    "start": "1049919",
    "end": "1056640"
  },
  {
    "text": "and then whenever you do arithmetic operation with pointer now not only you have to assign pointer you also have to",
    "start": "1056640",
    "end": "1063960"
  },
  {
    "text": "assign the corresponding fields in a satellite data structure right so in this case you you assign a to P the",
    "start": "1063960",
    "end": "1070640"
  },
  {
    "text": "right hand side then you have to manipulate their corresponding satellite data structures according all right so",
    "start": "1070640",
    "end": "1076360"
  },
  {
    "text": "that's what you need to do like like once you create this additional data structure to keep track of which pointer",
    "start": "1076360",
    "end": "1082440"
  },
  {
    "text": "belongs to which object that's add additional stuff that you have to generate so cach actually uses a hybrid",
    "start": "1082440",
    "end": "1089840"
  },
  {
    "text": "approach we actually try to maintain the compatibility as much as possible so in",
    "start": "1089840",
    "end": "1094919"
  },
  {
    "text": "general it's a spread tree but we know that spread tree is very slow right because of every memory reference you",
    "start": "1094919",
    "end": "1101000"
  },
  {
    "text": "actually have to look up that spread tree so we try to take advantage of the fact that for many memory references",
    "start": "1101000",
    "end": "1107120"
  },
  {
    "text": "there are so So-Cal name references like you know you don't really use you don't need to Der reference a pointer in those",
    "start": "1107120",
    "end": "1114120"
  },
  {
    "text": "cases we are going to use a shadow variable and only for pointer references we use spreadsheet okay so that that's",
    "start": "1114120",
    "end": "1120440"
  },
  {
    "text": "that that's the the key idea and moreover we are trying to the way that we maintain this uh Shadow variables are",
    "start": "1120440",
    "end": "1127440"
  },
  {
    "text": "sort of somewhat unique compared to previous approach in the sense that we try to maintain compatibility so instead",
    "start": "1127440",
    "end": "1133039"
  },
  {
    "text": "of passing the shadow variables of these pointers across function boundary through the stack we actually pass them",
    "start": "1133039",
    "end": "1140200"
  },
  {
    "text": "through the hip by maintaining a shadow stack so this guarantees that even when our program call a legacy program or a",
    "start": "1140200",
    "end": "1147760"
  },
  {
    "text": "legacy program call us your works right there's no problem there so it we actually guaranteed the U backward",
    "start": "1147760",
    "end": "1154640"
  },
  {
    "text": "compatiability that way so as a example for example you have this function called chain fub1 call F2 F2 call F3 F3",
    "start": "1154640",
    "end": "1162880"
  },
  {
    "text": "cause F4 and so on so F2 is a legacy function okay and F1 F3 f for our new",
    "start": "1162880",
    "end": "1168919"
  },
  {
    "text": "one that we compile right so fub1 can pass something into FS2 so in in this",
    "start": "1168919",
    "end": "1174520"
  },
  {
    "text": "case FS1 C FS2 so it has to pass in F A1 A2 A3 and we also pass the corresponding",
    "start": "1174520",
    "end": "1180960"
  },
  {
    "text": "shadow um uh construct like a1. s a2. s",
    "start": "1180960",
    "end": "1186440"
  },
  {
    "text": "and A3 doesn't need it because it's not a pointer and so on and for when F F3 calls F4 again F3 will pass a A7 s a a8.",
    "start": "1186440",
    "end": "1196000"
  },
  {
    "text": "s these are the corresponding satellite structure all right now in this particular case",
    "start": "1196000",
    "end": "1201440"
  },
  {
    "text": "because F2 is a legacy function it really doesn't check this Shadow stack so even though F1 pass something to FS2",
    "start": "1201440",
    "end": "1208760"
  },
  {
    "text": "those things that get passed essentially get ignored by FS2 but when FS2 call F3",
    "start": "1208760",
    "end": "1214200"
  },
  {
    "text": "F2 doesn't send anything to F3 so when we compile F3 we know that sometime we might get called but by a legacy",
    "start": "1214200",
    "end": "1221000"
  },
  {
    "text": "function so we check the Shad stack and since F2 doesn't send anything to F3 we say oh I I probably get CAU by a legacy",
    "start": "1221000",
    "end": "1227919"
  },
  {
    "text": "function so I don't really have any Shadow data structure to work with and so on but that's fine but between F3 and F4 they are all compiled by cache so",
    "start": "1227919",
    "end": "1235000"
  },
  {
    "text": "they have the corresponding Shadow structure and they can work correctly right so that that's the",
    "start": "1235000",
    "end": "1240120"
  },
  {
    "text": "idea so so given that we already can set up sort of the the code correctly so that we can check the the we can map the",
    "start": "1240120",
    "end": "1247720"
  },
  {
    "text": "particular memory reference to the corresponding object so now how do we generate code so this gives you a simple",
    "start": "1247720",
    "end": "1253679"
  },
  {
    "text": "example so the the source code statement is AI equal to 10 right I have an array I just pick up the",
    "start": "1253679",
    "end": "1261039"
  },
  {
    "text": "I element of that array a and assign the value 10 to it that's that's the source",
    "start": "1261039",
    "end": "1266320"
  },
  {
    "text": "code statement without array Bank checking that's the four instruction that you need you are going to load that",
    "start": "1266320",
    "end": "1272279"
  },
  {
    "text": "index I and then you multiply multiply it by four so that they give you the four by um uh entry and then you load",
    "start": "1272279",
    "end": "1279440"
  },
  {
    "text": "the Base address and then now you're going to assign that value 10 to the corresponding memory location so that's",
    "start": "1279440",
    "end": "1284799"
  },
  {
    "text": "that's it pretty pretty simple now if you add array B checking code that's what you get you do the same thing load",
    "start": "1284799",
    "end": "1291159"
  },
  {
    "text": "I and then multiply that I by four and then load the Base address now you have to load the corresponding Shadow",
    "start": "1291159",
    "end": "1297640"
  },
  {
    "text": "structure pointer as well all right and you have to now that you allocate a segment for that particular a you cannot",
    "start": "1297640",
    "end": "1304400"
  },
  {
    "text": "use the same segment anymore so each array or each object or each buffer has",
    "start": "1304400",
    "end": "1309679"
  },
  {
    "text": "its own uh segment so we are going to load the the corresponding segment into the segment register and then we are",
    "start": "1309679",
    "end": "1316880"
  },
  {
    "text": "going to compute the offset and then we are going to assign doing the assignment so the the red ones are the ones that we",
    "start": "1316880",
    "end": "1322640"
  },
  {
    "text": "have to add additionally all right and it turns out that if this code is actually executed within a loop those",
    "start": "1322640",
    "end": "1329919"
  },
  {
    "text": "three instruction the red ones need to be inserted for every memory reference but those three instructions are",
    "start": "1329919",
    "end": "1336279"
  },
  {
    "text": "actually Loop independent so you don't really even need to do anything you just you know generate this instructions",
    "start": "1336279",
    "end": "1342320"
  },
  {
    "text": "inside a loop body and when you turn on the optim compiler optimization these three instruction will get lifted up out",
    "start": "1342320",
    "end": "1348159"
  },
  {
    "text": "of the loop body so essentially what you do is that in the loop body you still have four instruction not seven",
    "start": "1348159",
    "end": "1353520"
  },
  {
    "text": "instruction the three instruction that we add actually get lifted out of the loop automatically without us doing",
    "start": "1353520",
    "end": "1359279"
  },
  {
    "text": "anything so essentially what this means is that in order to use this cach idea",
    "start": "1359279",
    "end": "1364799"
  },
  {
    "text": "there's actually no additional overhead for every array reference but there's some preparation overhead in the",
    "start": "1364799",
    "end": "1371799"
  },
  {
    "text": "beginning of the loop these are these three instruction I'm talking about right so that's the beauty of it like",
    "start": "1371799",
    "end": "1377240"
  },
  {
    "text": "previously we said say that every time if you want to implement a ray Bank checkin you have to spend additional time to look up you know to associate a",
    "start": "1377240",
    "end": "1384600"
  },
  {
    "text": "particular memory reference with is corresponding object and then you have to perform the lower and upper Bank",
    "start": "1384600",
    "end": "1389720"
  },
  {
    "text": "limit right there you probably need six instruction just to do lower and upper Bank um check but here every memory",
    "start": "1389720",
    "end": "1397480"
  },
  {
    "text": "reference array reference doesn't require any uh additional overhead so that that's the beauty of",
    "start": "1397480",
    "end": "1404000"
  },
  {
    "text": "cach now one of the problem with the cach approach is that x86 architecture only provides a very",
    "start": "1404000",
    "end": "1411640"
  },
  {
    "text": "small number of segment registers right it only provides six of them and three",
    "start": "1411640",
    "end": "1416840"
  },
  {
    "text": "of them are already taken the co segment data segment and stack segment okay so",
    "start": "1416840",
    "end": "1422039"
  },
  {
    "text": "we are only left with three segment register on top of that some uh stream",
    "start": "1422039",
    "end": "1427480"
  },
  {
    "text": "manipulation instruction actually use one of the segment register es so in order for us to use three we actually",
    "start": "1427480",
    "end": "1434360"
  },
  {
    "text": "have to modify some of the stream manipulation function in GPC see uh so that they can use some other segments so",
    "start": "1434360",
    "end": "1442400"
  },
  {
    "text": "and we can actually try to use the FSE segment register like SS if we can replace all the push and PP instructions",
    "start": "1442400",
    "end": "1449720"
  },
  {
    "text": "with just move instructions we can also do that but we didn't actually do that so in the end we only have three segment",
    "start": "1449720",
    "end": "1455520"
  },
  {
    "text": "registers to work with that means that at any point in time I can only have three objects buffer or array three",
    "start": "1455520",
    "end": "1462919"
  },
  {
    "text": "buffer or array uh in the processor simultaneously if we within a loop that",
    "start": "1462919",
    "end": "1468840"
  },
  {
    "text": "Loop actually uses more than three arrays or buffers then I have a problem okay and this is where software array B",
    "start": "1468840",
    "end": "1475600"
  },
  {
    "text": "checking comes in if you have a loop or especially nested Loop that uses more than three buffers or objects then all",
    "start": "1475600",
    "end": "1483559"
  },
  {
    "text": "the other array references behind the first three need to be checked in software okay and that's why we need",
    "start": "1483559",
    "end": "1489399"
  },
  {
    "text": "this additional fullback mechanism uh using software Aang checkin okay so that's one problem with",
    "start": "1489399",
    "end": "1496399"
  },
  {
    "text": "uh segment uh the the very small number of the segment register so this is sort of a concern that we have in the",
    "start": "1496399",
    "end": "1503159"
  },
  {
    "text": "beginning of the project we don't really know better we have to really implement it and then try it on real program to see whether this is a problem or not but",
    "start": "1503159",
    "end": "1509960"
  },
  {
    "text": "in the end it could be that you know a lot of the AR bank checks actually need to be done in software so it defeats the",
    "start": "1509960",
    "end": "1515720"
  },
  {
    "text": "whole purpose of cach which Tred to exploit the segment limit check hardware and the other issue is the",
    "start": "1515720",
    "end": "1522640"
  },
  {
    "text": "segment descriptor Management in x86 architecture it only has uh 8",
    "start": "1522640",
    "end": "1528279"
  },
  {
    "text": "92 um segment descriptors AK essentially all right so so it's it's it's it's not",
    "start": "1528279",
    "end": "1536360"
  },
  {
    "text": "particularly large but it's not small either right but you know we don't really know whether this is a n for not and remember I want to allocate a",
    "start": "1536360",
    "end": "1543399"
  },
  {
    "text": "segment for every buffer and array in the program including local array every",
    "start": "1543399",
    "end": "1548480"
  },
  {
    "text": "time you call a function that function include the local array that local array also needs a segment all right so we",
    "start": "1548480",
    "end": "1554840"
  },
  {
    "text": "potentially we could need a lot of segments of if I had have a recursive call and that recursive call has a know",
    "start": "1554840",
    "end": "1561760"
  },
  {
    "text": "a really long depth and that recursive function actually includes a local function that I could have a problem so",
    "start": "1561760",
    "end": "1568320"
  },
  {
    "text": "whenever I do this for local array you know I I can allocate a segment for a local array statically so because it's",
    "start": "1568320",
    "end": "1574880"
  },
  {
    "text": "declared and for I'm sorry for Global array I can allocate the segment for it",
    "start": "1574880",
    "end": "1580120"
  },
  {
    "text": "statically and for local array I have to I have to allocate it dynamically so whenever I enter a function I see",
    "start": "1580120",
    "end": "1586640"
  },
  {
    "text": "there's a local array that I need to uh grab a segment from the segment pool and the same thing with Dynamic array like",
    "start": "1586640",
    "end": "1593440"
  },
  {
    "text": "mik and free so I would I would allocate when M and deallocate when free so as I",
    "start": "1593440",
    "end": "1598960"
  },
  {
    "text": "say there are only 81 92 segments two of them are already used by US one is used",
    "start": "1598960",
    "end": "1605240"
  },
  {
    "text": "to implement a special Core case called cach modify LT I'll talk about it in a",
    "start": "1605240",
    "end": "1610559"
  },
  {
    "text": "minute and the other is a fullback thing so this particular uh segment is whose",
    "start": "1610559",
    "end": "1616000"
  },
  {
    "text": "segment limit is set to 4 G that's the entire address space that that essentially says that you don't do any check right because you know there's no",
    "start": "1616000",
    "end": "1623279"
  },
  {
    "text": "upper and lower B it covers the entire address space of course you know any check is is a is a no no up operation so",
    "start": "1623279",
    "end": "1630240"
  },
  {
    "text": "this is meant for fullback so again I'll talk about it in a minute so really we only have 81 8190 segment and some of",
    "start": "1630240",
    "end": "1637520"
  },
  {
    "text": "the segment actually get used by Linux as well so so in the sense we don't really have we probably have something",
    "start": "1637520",
    "end": "1643520"
  },
  {
    "text": "like 8180 segments to work with and the question is that is it good enough for real Network application that are",
    "start": "1643520",
    "end": "1650600"
  },
  {
    "text": "potentially vulnerable to buffer overflow attacks again we don't know in the beginning of the project so we have",
    "start": "1650600",
    "end": "1656200"
  },
  {
    "text": "to try and see what happens so one of the major issue that we run into in this project is this LT",
    "start": "1656200",
    "end": "1663559"
  },
  {
    "text": "multiplication overhead so the problem is the following remember for local uh",
    "start": "1663559",
    "end": "1668600"
  },
  {
    "text": "array if you have a function that know allocate a local array and I say that for every array I need to allocate a",
    "start": "1668600",
    "end": "1676039"
  },
  {
    "text": "segment for it but but in order to allocate segment I need to fill in the corresponding segments a segment",
    "start": "1676039",
    "end": "1682799"
  },
  {
    "text": "descriptor table entry LT entry right but LT lives in the kernel space so that",
    "start": "1682799",
    "end": "1689360"
  },
  {
    "text": "means that for every function call I need to make at least one or two system calls just to manipulate these lodt",
    "start": "1689360",
    "end": "1696919"
  },
  {
    "text": "entries and that's not very nice right I mean I don't really want to turn every function call into a system core that's",
    "start": "1696919",
    "end": "1703919"
  },
  {
    "text": "like a pretty expensive so one one way to solve this problem is that what if we lift this lodt from kernel space to user",
    "start": "1703919",
    "end": "1711559"
  },
  {
    "text": "space right so then then we can manipulate lodt at the user space and so",
    "start": "1711559",
    "end": "1717360"
  },
  {
    "text": "the the the original assumption is that since nobody is really using segments anyway like most of the application no",
    "start": "1717360",
    "end": "1723000"
  },
  {
    "text": "most oper system simply just assume a couple of segments and that's it they leave the lodt along they never actually touch them anymore so there's actually",
    "start": "1723000",
    "end": "1730120"
  },
  {
    "text": "nothing sensitive you know in know ldt in in theory that's correct unfortunately in x86 architecture it",
    "start": "1730120",
    "end": "1736960"
  },
  {
    "text": "also allows people to set up something called cor gate and the cor gate is a",
    "start": "1736960",
    "end": "1742320"
  },
  {
    "text": "special segment that allows uh that can point to any code and that corate allows",
    "start": "1742320",
    "end": "1747640"
  },
  {
    "text": "users to run any code that it points to at the kernel level so that means that if I get to manipulate LT at the user",
    "start": "1747640",
    "end": "1754200"
  },
  {
    "text": "space I can set up corate then I can run a piece of code at the colal level if I want to and that's obviously not a good",
    "start": "1754200",
    "end": "1761000"
  },
  {
    "text": "idea so that means the idea of lifting lodt from kernel space to user space is no good it's just not acceptable from a",
    "start": "1761000",
    "end": "1768159"
  },
  {
    "text": "security point of view so we then we said okay maybe I can try to make the system call as fast as possible so you",
    "start": "1768159",
    "end": "1774600"
  },
  {
    "text": "know if you just call in Linux it actually provides a generic system call for you to modify your DT entry like in",
    "start": "1774600",
    "end": "1780840"
  },
  {
    "text": "this case it takes probably something like 781 clock Cycles so we try to reduce it do whatever we can you know",
    "start": "1780840",
    "end": "1786880"
  },
  {
    "text": "reduce unnecessary check and so on and using call gate to set up this system call you know it reduces the L to uh 253",
    "start": "1786880",
    "end": "1793880"
  },
  {
    "text": "clock cycle still pretty high so turns out that sort of that this is kind of important so we actually have to do",
    "start": "1793880",
    "end": "1799960"
  },
  {
    "text": "something else so that something else is about caching so the general scenario",
    "start": "1799960",
    "end": "1805519"
  },
  {
    "text": "that we observe is that in a lot of this program sample program that we tested um",
    "start": "1805519",
    "end": "1811679"
  },
  {
    "text": "sometimes you actually de allocate something and then then reallocate again and deallocate something and reallocate",
    "start": "1811679",
    "end": "1816720"
  },
  {
    "text": "again so an example will be something like this so let's say you have a function man and that that that has a",
    "start": "1816720",
    "end": "1822840"
  },
  {
    "text": "loop in that Loop you call another function fo and within that F you actually need a local array so in within",
    "start": "1822840",
    "end": "1829760"
  },
  {
    "text": "a loop you repeatedly call F and every time you call F you actually have to allocate entry from LT and every time",
    "start": "1829760",
    "end": "1836360"
  },
  {
    "text": "you return from food you have to deallocate but the good news is that this pattern is repeatable so instead of",
    "start": "1836360",
    "end": "1844159"
  },
  {
    "text": "repeatedly allocating and deallocating by manipulating the LT entries directly",
    "start": "1844159",
    "end": "1850200"
  },
  {
    "text": "we keep a user level cach to say that if if the the the next request Quest whose",
    "start": "1850200",
    "end": "1858240"
  },
  {
    "text": "base and limmit is the same as the previous one that I deallocate then I don't have to touch the kernel because I",
    "start": "1858240",
    "end": "1864600"
  },
  {
    "text": "don't really need to rewrite the kernel uh the ldt the segment descriptor table it's the same right so this this idea",
    "start": "1864600",
    "end": "1871679"
  },
  {
    "text": "actually reduces a lot of the overhead related to lodt modifcation and it turns",
    "start": "1871679",
    "end": "1876880"
  },
  {
    "text": "out that it's particularly effective for this local arrays call within a uh function or call within a",
    "start": "1876880",
    "end": "1883320"
  },
  {
    "text": "loop so that's the example and it turns out it's actually sort of this is the main reason why the whole thing can work",
    "start": "1883320",
    "end": "1890000"
  },
  {
    "text": "like if you have to pick an idea other than the general idea of you know allocating a segment for every array and",
    "start": "1890000",
    "end": "1896440"
  },
  {
    "text": "up and buffer this is the main key that without this you would be very bad right for local array you know you have to",
    "start": "1896440",
    "end": "1902880"
  },
  {
    "text": "make a even a lightway system call is just too much and then there's some kind of other",
    "start": "1902880",
    "end": "1909200"
  },
  {
    "text": "issues there somewhat sort of Exotica related to x86 architecture so in x86",
    "start": "1909200",
    "end": "1915320"
  },
  {
    "text": "architecture if you have a segment that's uh less than 1 Megabyte then",
    "start": "1915320",
    "end": "1921039"
  },
  {
    "text": "remember there's a segment limit right so the the the question is that the segment limit is in terms of what right",
    "start": "1921039",
    "end": "1927159"
  },
  {
    "text": "so usually you it has a a particular bit called granularity bit in the corresponding segment descripted table",
    "start": "1927159",
    "end": "1933799"
  },
  {
    "text": "entry that gr when a granularity bit is off that means that when you specify limit it's in terms of bytes all right",
    "start": "1933799",
    "end": "1940919"
  },
  {
    "text": "but when a granularity bit is on it means it specify limit in terms of megabyte right so this allows you to",
    "start": "1940919",
    "end": "1947679"
  },
  {
    "text": "grow sort of the the segment Beyond one megabyte essentially that's the",
    "start": "1947679",
    "end": "1952840"
  },
  {
    "text": "idea so so if you look at a we have an array that is more than 1 Megabyte that",
    "start": "1952840",
    "end": "1958679"
  },
  {
    "text": "means that we have to turn on the granular bit right because I need a segment that's larger than one megabyte",
    "start": "1958679",
    "end": "1965000"
  },
  {
    "text": "so in order to do that I have to turn down that granularity bit so that means that you know I might have some problem",
    "start": "1965000",
    "end": "1970600"
  },
  {
    "text": "in terms of U um doing exact AR bang checking so this example shows you that",
    "start": "1970600",
    "end": "1977120"
  },
  {
    "text": "so imagine that I have an array that's uh expressed by the interval between",
    "start": "1977120",
    "end": "1982320"
  },
  {
    "text": "these two red lines okay and but in order to do this I actually have to specify this in terms actually I'm sorry",
    "start": "1982320",
    "end": "1989120"
  },
  {
    "text": "so when a granularity bit is on the unit is actually 4K by not one one megabyte",
    "start": "1989120",
    "end": "1994639"
  },
  {
    "text": "it's actually 4K by so that means that whenever I allocate a segment for this",
    "start": "1994639",
    "end": "2000120"
  },
  {
    "text": "particular array which is larger than 1 Megabyte I have to allocate the the smallest integral multiple of four",
    "start": "2000120",
    "end": "2007279"
  },
  {
    "text": "kilobytes Bey this particular array right and that's what happened that's what that yellow line represent so if I",
    "start": "2007279",
    "end": "2014159"
  },
  {
    "text": "actually do array bang checking I'm actually checking the lower bang and upper B of the segment which is not the",
    "start": "2014159",
    "end": "2021639"
  },
  {
    "text": "same as lower bang and upper B of the array got it right because I have I have",
    "start": "2021639",
    "end": "2028039"
  },
  {
    "text": "I'm forced to allocate a little bit more than what I actually need when the array is greater than 1 Megabyte that's just",
    "start": "2028039",
    "end": "2035000"
  },
  {
    "text": "the know peculiarity in x86 architecture so when I do this that",
    "start": "2035000",
    "end": "2040919"
  },
  {
    "text": "means that when I'm checking things I'm I'm not exactly checking the array bounds right I'm checking the segment",
    "start": "2040919",
    "end": "2045960"
  },
  {
    "text": "bounds these two things are not the same but it's actually okay not too bad so what we do is we align the upper bound",
    "start": "2045960",
    "end": "2052118"
  },
  {
    "text": "of the array with the upper bounds of the segment because most of the array bound violation is related to Upper",
    "start": "2052119",
    "end": "2058599"
  },
  {
    "text": "bound but there are still something that's related to lower bound especially with respect to integer overflow so what",
    "start": "2058599",
    "end": "2064320"
  },
  {
    "text": "we do is that whatever in between the lower B of the array and the lower B of the segment we should not allocate",
    "start": "2064320",
    "end": "2070358"
  },
  {
    "text": "anything right so that means okay you can underflow the array but you cannot underflow the segment but between the",
    "start": "2070359",
    "end": "2077040"
  },
  {
    "text": "lower bound of array and lower bound of segment there's nothing important that you can overflow so you can overflow but",
    "start": "2077040",
    "end": "2082919"
  },
  {
    "text": "there's nothing there so so that's probably not too bad so that that's what what we end up doing to solve this particular",
    "start": "2082919",
    "end": "2089599"
  },
  {
    "text": "problem so now with all these machineries in place that we we we actually Implement a a full scale um uh",
    "start": "2089599",
    "end": "2097040"
  },
  {
    "text": "B checking compiler uh using based on GCC and actually based on a particular version of GCC that already performs a",
    "start": "2097040",
    "end": "2104880"
  },
  {
    "text": "limited form of B checking called BCC okay and this runs on this particular",
    "start": "2104880",
    "end": "2110000"
  },
  {
    "text": "platform and so on um so so if we take a step back and try to figure out what",
    "start": "2110000",
    "end": "2115119"
  },
  {
    "text": "exactly we are trying to do so remember the idea is that I'm going to twist the segment limit check in x86 architectures",
    "start": "2115119",
    "end": "2122520"
  },
  {
    "text": "virtual memory Hardware to perform a rayang check-in for free that's the idea",
    "start": "2122520",
    "end": "2127839"
  },
  {
    "text": "so we are claiming that for every memory reference you don't really need to do anything the hardware is already doing",
    "start": "2127839",
    "end": "2134599"
  },
  {
    "text": "the stuff for you that's the claim but in order to make that happen we have to",
    "start": "2134599",
    "end": "2139880"
  },
  {
    "text": "set things up all right and that incurs additional overhead it turns out there are three types of overhead one is per",
    "start": "2139880",
    "end": "2146400"
  },
  {
    "text": "program overhead like you are given a program in in the initialization phase I have to set up this uh you know free",
    "start": "2146400",
    "end": "2152720"
  },
  {
    "text": "list for lodt cash and so on as well as alocate entries for Global arrays and so",
    "start": "2152720",
    "end": "2158079"
  },
  {
    "text": "on and then this is per array overhead this is in particular with respect to uh",
    "start": "2158079",
    "end": "2163560"
  },
  {
    "text": "local array within a function every time you call a function right remember I need to actually make some call in order",
    "start": "2163560",
    "end": "2170920"
  },
  {
    "text": "to modify the corresponding lodt entry right to add the entry into the LT and when the function exit I have to",
    "start": "2170920",
    "end": "2177400"
  },
  {
    "text": "deallocate it and so on that's per array and there is something called per array",
    "start": "2177400",
    "end": "2182440"
  },
  {
    "text": "Ed so for example within a function you might declare a local array but that array get used in two Loops right so",
    "start": "2182440",
    "end": "2189960"
  },
  {
    "text": "this per array used overhead captures that every time an array is used what's",
    "start": "2189960",
    "end": "2195160"
  },
  {
    "text": "the additional overhead you need right so an array could be used in multiple loops and that's for each such use it is",
    "start": "2195160",
    "end": "2202000"
  },
  {
    "text": "going to incur something some overhead so it turns out that the the most important part is really this per array",
    "start": "2202000",
    "end": "2208880"
  },
  {
    "text": "overhead thing per array use is not nothing it's is related to how you load the segment register and compute the",
    "start": "2208880",
    "end": "2215400"
  },
  {
    "text": "offset and so on and per array overhead is the one that we try to modify right we say lifting the whole thing to user",
    "start": "2215400",
    "end": "2222079"
  },
  {
    "text": "space no good and you know trying to have a streamlined optimized modify lodt system call it gives you a little bit",
    "start": "2222079",
    "end": "2229079"
  },
  {
    "text": "better results but it eventually the main you know performance uh differentiator is really comes from this",
    "start": "2229079",
    "end": "2234680"
  },
  {
    "text": "idea of ldt Entry caching and that's actually where it comes from that's where the power of the approach comes",
    "start": "2234680",
    "end": "2240000"
  },
  {
    "text": "from so we are trying to compare three cases one is GCC that doesn't have any",
    "start": "2240000",
    "end": "2245400"
  },
  {
    "text": "arang checkin at all right and the other thing is cach that's ours and the third thing is Bank checking compiler that's",
    "start": "2245400",
    "end": "2251359"
  },
  {
    "text": "like the state of the art Bank software based Bank checking compiler so these are three cases no check state-ofthe-art",
    "start": "2251359",
    "end": "2258359"
  },
  {
    "text": "software based Bank checking compiler and cach which exploits secondment limit",
    "start": "2258359",
    "end": "2263440"
  },
  {
    "text": "check Hardware so that we try sort of simple program kernel program loops with a lot",
    "start": "2263440",
    "end": "2270200"
  },
  {
    "text": "of loops and know numerical programs and so on so you have a set of program with SVD volume rendering 2df F and so on so",
    "start": "2270200",
    "end": "2278560"
  },
  {
    "text": "the so cash incurs this kind of overhead it's like 1.8% 3.3% and so on so the",
    "start": "2278560",
    "end": "2284760"
  },
  {
    "text": "original program Run 100 millisecond this is going to run 101.8 millisecond this this kind of",
    "start": "2284760",
    "end": "2291680"
  },
  {
    "text": "thing and BCC incurs as we expected 120% 126% and so on right remember the BCC",
    "start": "2291680",
    "end": "2298280"
  },
  {
    "text": "also doesn't use that spray tree that's why it doesn't suffer as much performance overhead as Imperial College",
    "start": "2298280",
    "end": "2304440"
  },
  {
    "text": "BN checking compiler so this actually shows pretty promising is pretty promising right that that the overhead",
    "start": "2304440",
    "end": "2310920"
  },
  {
    "text": "is almost nothing in the statistical noise and the reason that it's so good is because if you com really check the",
    "start": "2310920",
    "end": "2317319"
  },
  {
    "text": "number of uh checks that uh the the the cach compiler generate that requires",
    "start": "2317319",
    "end": "2323920"
  },
  {
    "text": "software fullback check is zero for all this program right so the the software",
    "start": "2323920",
    "end": "2329000"
  },
  {
    "text": "checks do not there's no need for software for back check right so those things that we need to worry about like you probably don't have announc segment",
    "start": "2329000",
    "end": "2335400"
  },
  {
    "text": "descriptors you probably don't have a non segment registers and you know for some some real cases you need to fall",
    "start": "2335400",
    "end": "2341760"
  },
  {
    "text": "back to software arank checks they do not happen and that's why the performance overhead is so low",
    "start": "2341760",
    "end": "2348280"
  },
  {
    "text": "right so but this is just a toy programs right micro Benchmark so so let's try a sort of slightly larger uh program so",
    "start": "2348280",
    "end": "2355280"
  },
  {
    "text": "these are all a bunch of libraries that that are pretty substantial some you know for C gzip to PNG converter it",
    "start": "2355280",
    "end": "2362760"
  },
  {
    "text": "probably has a know 47,000 lines of code and so on for example the last one so we",
    "start": "2362760",
    "end": "2367920"
  },
  {
    "text": "also try to measure something in terms of the number of Loops in the source code that contain sort of that use array",
    "start": "2367920",
    "end": "2374800"
  },
  {
    "text": "references and then out of those how many of them actually use more than three arrays simultaneously those are",
    "start": "2374800",
    "end": "2381440"
  },
  {
    "text": "the cases that we need to worry about those are the cases that eventually going to require software array B",
    "start": "2381440",
    "end": "2386880"
  },
  {
    "text": "checking as a fullback mechanism so the the right right right hand side the",
    "start": "2386880",
    "end": "2392000"
  },
  {
    "text": "column actually gives you the numbers all right so this just give you give us an IND indication whether know this is",
    "start": "2392000",
    "end": "2397640"
  },
  {
    "text": "going to be a problem or not and then we actually run the program and then try to compare the differences so again the",
    "start": "2397640",
    "end": "2403960"
  },
  {
    "text": "performance results is slightly worse compared to the micro Benchmark results but it's still not too bad so the the",
    "start": "2403960",
    "end": "2410560"
  },
  {
    "text": "worst case is quat it's about 16% performance overhead but compared to B",
    "start": "2410560",
    "end": "2416160"
  },
  {
    "text": "BCC it's 238% performance overhead all right so again I'm I like to claim that",
    "start": "2416160",
    "end": "2422480"
  },
  {
    "text": "this is really nothing compared to you know what we what if if we can have a way to actually stop all buffer overflow",
    "start": "2422480",
    "end": "2430480"
  },
  {
    "text": "attacks with a performance overhead of 16% it's pretty reasonable price to pay",
    "start": "2430480",
    "end": "2436359"
  },
  {
    "text": "okay but again these are just macro Benchmark what about like real applications so let's try really you",
    "start": "2436359",
    "end": "2442880"
  },
  {
    "text": "know real complete Network application like Q poer Apachi s mail this ft PD and",
    "start": "2442880",
    "end": "2450520"
  },
  {
    "text": "bind name server so on this are you know big program not not nobody can claim that this is a toy program right let's",
    "start": "2450520",
    "end": "2457079"
  },
  {
    "text": "try real thing and again we do the same thing you know analyze the whole the whole thing and then we do two test one",
    "start": "2457079",
    "end": "2463520"
  },
  {
    "text": "is on latency test and one is on throughput test and the other is on sort of like binary uh space overhead so",
    "start": "2463520",
    "end": "2470800"
  },
  {
    "text": "latency is the amount of time required for a request to be sent in and get a response back so we you know send a th",
    "start": "2470800",
    "end": "2477480"
  },
  {
    "text": "thousands of requests and trying to measure the penalty in terms of latency and the other thing is throughput",
    "start": "2477480",
    "end": "2482960"
  },
  {
    "text": "throughput is that within a unit of time how much stuff get done right and there's actually a difference between",
    "start": "2482960",
    "end": "2488640"
  },
  {
    "text": "the two between the because of pipeline right so so we just want to know you know in terms of these two performance",
    "start": "2488640",
    "end": "2494599"
  },
  {
    "text": "metrix whether you know cach actually performs well and and space overhead is a increase in binary size so it's it's",
    "start": "2494599",
    "end": "2501680"
  },
  {
    "text": "it's because you actually have to add additional stuff especially for the Library part so uh the space overhead is",
    "start": "2501680",
    "end": "2508079"
  },
  {
    "text": "slightly larger but you know as long as it doesn't affect the performance you know people probably don't care so again",
    "start": "2508079",
    "end": "2514599"
  },
  {
    "text": "for all these results we are talking about under 10% the worst case is s maale and the reason s mail performs",
    "start": "2514599",
    "end": "2520680"
  },
  {
    "text": "worse is because that it indeed has some uh uh Loops that use more than three uh",
    "start": "2520680",
    "end": "2527560"
  },
  {
    "text": "uh objects uh and therefore some of the the array references indeed need to use",
    "start": "2527560",
    "end": "2533240"
  },
  {
    "text": "this uh software aray Bank check as a fallback so there are actually a couple",
    "start": "2533240",
    "end": "2539640"
  },
  {
    "text": "of lessons that we learned in this particular process remember so the basic idea is very simple and when we explain",
    "start": "2539640",
    "end": "2545880"
  },
  {
    "text": "this idea to others other tend to say of course you should do that I don't know why people don't do it but you know but",
    "start": "2545880",
    "end": "2551720"
  },
  {
    "text": "that that that's but there are actually some caveats like before you actually uh embarking on this particular project you",
    "start": "2551720",
    "end": "2557200"
  },
  {
    "text": "have to worry about this worry about that to see eventually all this idea can fit together and pan out it turns out",
    "start": "2557200",
    "end": "2563040"
  },
  {
    "text": "that you know the the experimental results actually demonstrate that the idea seems to to work just fine like you",
    "start": "2563040",
    "end": "2568880"
  },
  {
    "text": "know you can say we are lucky and so on but you know the the common program that we need to worry about just work",
    "start": "2568880",
    "end": "2575640"
  },
  {
    "text": "reasonably work well for our assumptions so for example more than 90% of the time",
    "start": "2575640",
    "end": "2580760"
  },
  {
    "text": "four segment registers are sufficient okay so you don't have to worry about like maybe you have a loop that actually",
    "start": "2580760",
    "end": "2586440"
  },
  {
    "text": "use 10 arrays or 10 buffers simultaneously that's just not a common case Okay fortunately and on the ey",
    "start": "2586440",
    "end": "2594160"
  },
  {
    "text": "average how many segment descriptors we need remember we have about 8,000 of them it turns out that there are plenty",
    "start": "2594160",
    "end": "2599960"
  },
  {
    "text": "of there are there are more than enough for most of the applications that we test right 10 segments for my mro",
    "start": "2599960",
    "end": "2606400"
  },
  {
    "text": "Benchmark programs or 163 segments for mro Benchmark programs 292 segments for",
    "start": "2606400",
    "end": "2611920"
  },
  {
    "text": "Network applications and so on and we also evaluate that idea of ldd caching",
    "start": "2611920",
    "end": "2617319"
  },
  {
    "text": "it turns out that the heat rate is also pretty high again it capture this idea of you know uh local array using a",
    "start": "2617319",
    "end": "2623920"
  },
  {
    "text": "function call by within a loop so that that scenario actually is not too bad so almost half of the the time we don't",
    "start": "2623920",
    "end": "2630640"
  },
  {
    "text": "really need to go into the kernel we can just you know do the allocation and delocation at the user space so that's",
    "start": "2630640",
    "end": "2636200"
  },
  {
    "text": "actually no problem there now there are actually a couple of limitations and misconception when",
    "start": "2636200",
    "end": "2643040"
  },
  {
    "text": "people hear about this idea you know people tend to be sort of somewhat uh stand standoff issue when they hear",
    "start": "2643040",
    "end": "2650000"
  },
  {
    "text": "about segmentation Hardware or segments in general so for example they worry",
    "start": "2650000",
    "end": "2655200"
  },
  {
    "text": "about you know when I use the segments would it actually introduce fragmentation right that's the",
    "start": "2655200",
    "end": "2660240"
  },
  {
    "text": "well-known problem with segmentation right that you know the reason that people choose not to do segmentation",
    "start": "2660240",
    "end": "2666520"
  },
  {
    "text": "is because you know pagent gives you you know better results in terms of Elimina this external",
    "start": "2666520",
    "end": "2672599"
  },
  {
    "text": "fragmentation and the the the the this is a misconception right here we don't",
    "start": "2672599",
    "end": "2678359"
  },
  {
    "text": "really use segment to do memory allocation every memory allocation you are doing mail and everything is still",
    "start": "2678359",
    "end": "2685119"
  },
  {
    "text": "page based think of it is like it's already page based all I'm adding is that I just artificially add a fragment",
    "start": "2685119",
    "end": "2692280"
  },
  {
    "text": "layer on top of it right so there one way to look at it is I just have a bunch of pages but another way is I'm I'm",
    "start": "2692280",
    "end": "2698160"
  },
  {
    "text": "adding a segment say oh by the way this part of the this page and this part of that page constitutes one segment right",
    "start": "2698160",
    "end": "2705119"
  },
  {
    "text": "so I'm not touching anything about a Linux kernel in terms of memory allocation they do exactly what they are",
    "start": "2705119",
    "end": "2710400"
  },
  {
    "text": "supposed to do in the generic Linux all we are doing is just add a layers so that the way I'm generating references I",
    "start": "2710400",
    "end": "2717920"
  },
  {
    "text": "can use that segment and I'm leveraging that segment limit check to perform that imprecate Aang check for me so that",
    "start": "2717920",
    "end": "2724319"
  },
  {
    "text": "that's sort of a good thing and the other thing is that it cach doesn't require soal Adas analysis right we",
    "start": "2724319",
    "end": "2730680"
  },
  {
    "text": "don't really need to do pointer analysis to do this to figure out for those of you who don't know Adas analysis",
    "start": "2730680",
    "end": "2736920"
  },
  {
    "text": "basically means that in a program a single object can have multiple names that's the notion of areas multiple",
    "start": "2736920",
    "end": "2743200"
  },
  {
    "text": "names right and you have to figure out that maybe that's that multiple name how do you determine that these multiple",
    "start": "2743200",
    "end": "2748520"
  },
  {
    "text": "names actually refer to the same object or not that's called alas analysis we don't really need that because the way",
    "start": "2748520",
    "end": "2754200"
  },
  {
    "text": "we do this is we carry the information about a pointer with it right either we",
    "start": "2754200",
    "end": "2760240"
  },
  {
    "text": "go through this static we Shadow variable or fed pointer approach or we use spreadsheet to look it up",
    "start": "2760240",
    "end": "2765839"
  },
  {
    "text": "dynamically so there's no need for areas analysis we don't really statically there's no sophisticated analysis like",
    "start": "2765839",
    "end": "2772040"
  },
  {
    "text": "Alas and you need to do so and then there are issues about if we only take care of references within",
    "start": "2772040",
    "end": "2779359"
  },
  {
    "text": "an array within a Loops then what about those array and buffer references outside Loops it turns out that we can",
    "start": "2779359",
    "end": "2785480"
  },
  {
    "text": "do this using software Aang check without any problems and compatibility with existing code base yes they do we",
    "start": "2785480",
    "end": "2793680"
  },
  {
    "text": "original version of cash does have this problem because we use f pointer and Shadow variable but the the second",
    "start": "2793680",
    "end": "2799880"
  },
  {
    "text": "version of cach solved this problem by using that shadow stack on the hip approach and then this problem goes away",
    "start": "2799880",
    "end": "2805960"
  },
  {
    "text": "we can demonstrate that this thing can work with the old version of gdpc or",
    "start": "2805960",
    "end": "2811119"
  },
  {
    "text": "cash compiled gdpc together there's no problem there the only weakness with with this approach is right now we don't",
    "start": "2811119",
    "end": "2817720"
  },
  {
    "text": "support type casting pointers like so you have an integer and out of the blue you cast it into a pointer I cannot help",
    "start": "2817720",
    "end": "2824480"
  },
  {
    "text": "you with that so you have to have a well written program that you already you know declare some variable as a pointer",
    "start": "2824480",
    "end": "2830760"
  },
  {
    "text": "variable right from the beginning at the wrong time you suddenly cast it into no something into a pointer that that's not",
    "start": "2830760",
    "end": "2837319"
  },
  {
    "text": "something we we cover right now right so so there's there's some limitation there but we claim that that's probably not",
    "start": "2837319",
    "end": "2843839"
  },
  {
    "text": "much issue in general and there are also some security consideration that I want to uh mention",
    "start": "2843839",
    "end": "2851079"
  },
  {
    "text": "so so in theory right now the cach compiler performance is actually already",
    "start": "2851079",
    "end": "2856200"
  },
  {
    "text": "a little bit uh sort of pessimistic it could be even better and the reason is",
    "start": "2856200",
    "end": "2862079"
  },
  {
    "text": "that in theory we only need to check right access to arrays why do I need to",
    "start": "2862079",
    "end": "2868040"
  },
  {
    "text": "worry about reais because that's not overflow right so I only need to check the right AIS so that potentially can uh",
    "start": "2868040",
    "end": "2875920"
  },
  {
    "text": "can reduce the overhead even further right and the other thing is that some",
    "start": "2875920",
    "end": "2881160"
  },
  {
    "text": "some people is saying that oh you maintain this lot free lodt entry in the user space wouldn't that cause a",
    "start": "2881160",
    "end": "2886680"
  },
  {
    "text": "security problem just like you cannot uh put lodt at the user space and the the",
    "start": "2886680",
    "end": "2892079"
  },
  {
    "text": "issue here is that yes there there could be some security problem but the worst that can happen is that the attacker can",
    "start": "2892079",
    "end": "2899040"
  },
  {
    "text": "use this uh um Can leverage to crash a process but not corrupt the underlying",
    "start": "2899040",
    "end": "2904319"
  },
  {
    "text": "operating system okay so that that's the that's the trade-off we have to live with that you know they they can massage",
    "start": "2904319",
    "end": "2909839"
  },
  {
    "text": "this L free LT entry list but the worst thing that can happen when that kind of tempering happens is that the underlying",
    "start": "2909839",
    "end": "2917839"
  },
  {
    "text": "that particular process might crash but not the corruption of the underly operate system finally our sort of new",
    "start": "2917839",
    "end": "2925240"
  },
  {
    "text": "cash modifi LT uh system call guarantees that there's no core gate that can be set up so this is the the reason why we",
    "start": "2925240",
    "end": "2932559"
  },
  {
    "text": "cannot maintain LT at the user space so we make sure that that doesn't",
    "start": "2932559",
    "end": "2938240"
  },
  {
    "text": "happen now up to now we are talking about mainly buffer overflow right so",
    "start": "2938240",
    "end": "2944160"
  },
  {
    "text": "remember the big picture the big picture is that for control hijacking attack there are this three there this three",
    "start": "2944160",
    "end": "2950079"
  },
  {
    "text": "step procedure and the first step is overflowing or tampering with the address space of the victim application",
    "start": "2950079",
    "end": "2956720"
  },
  {
    "text": "right and up until now I just explained to you that how we can actually stop that from happening if you give me an",
    "start": "2956720",
    "end": "2964040"
  },
  {
    "text": "arbitrary C program I can compile it in such a way that these guarantees will never happen arbitrary C program right",
    "start": "2964040",
    "end": "2971680"
  },
  {
    "text": "on Linux right now you know I don't have a version for Windows but you know on Linux right now guaranteed that won't",
    "start": "2971680",
    "end": "2976839"
  },
  {
    "text": "happen right but then people will say that what about other ways no no yes buffer overflow is fine get rid of that",
    "start": "2976839",
    "end": "2982799"
  },
  {
    "text": "what about other ways can we do something about the other um other approaches to temper with the address",
    "start": "2982799",
    "end": "2989440"
  },
  {
    "text": "bace of the victim application so one way is integer overflow so basically exploit overflow or underflow from",
    "start": "2989440",
    "end": "2995880"
  },
  {
    "text": "finite Precision computer arithmetic all type casting like you you you cast some",
    "start": "2995880",
    "end": "3001040"
  },
  {
    "text": "lower Precision uh so higher Precision number to low Precision number and or you you intentionally overflow or",
    "start": "3001040",
    "end": "3006960"
  },
  {
    "text": "underflow your finite Precision uh numbers so the potential damages is you can crash the application because you",
    "start": "3006960",
    "end": "3013640"
  },
  {
    "text": "know you can turn a lumber that's pretty small but but when you wrap around becomes really big and you use that as",
    "start": "3013640",
    "end": "3018799"
  },
  {
    "text": "an argument to M and M doesn't allow you and therefore the process crashes all right or you can use this to exceed the",
    "start": "3018799",
    "end": "3026240"
  },
  {
    "text": "bound the lower and upper bound but the second problem can be caught by cash it's only the first problem that could",
    "start": "3026240",
    "end": "3032319"
  },
  {
    "text": "cause the so so in the worst case still for integer overflow now you can only crash the application if your",
    "start": "3032319",
    "end": "3038640"
  },
  {
    "text": "application get compiled with cash no buff overflow can happen because of the integer overflow so integer overflow",
    "start": "3038640",
    "end": "3045880"
  },
  {
    "text": "sometimes can be used to mount buffer overflow attack cash can catch those attacks as well right so the worst case",
    "start": "3045880",
    "end": "3052880"
  },
  {
    "text": "that can happen now for integer overflow is really crashing okay but if you really want to stop that",
    "start": "3052880",
    "end": "3058520"
  },
  {
    "text": "as well it's possible to add code to do this overflow and and underflow software",
    "start": "3058520",
    "end": "3063640"
  },
  {
    "text": "check for tented arithmetic uh operation that means that anything that come from",
    "start": "3063640",
    "end": "3068960"
  },
  {
    "text": "the network packets and they try to do some sort of arithmetic you should do a double checking to see whether he",
    "start": "3068960",
    "end": "3075200"
  },
  {
    "text": "actually wrapped around or or not so that that's what it means if you want to do that you can add additional",
    "start": "3075200",
    "end": "3081520"
  },
  {
    "text": "codes now another the the other way that they can be used to temper with the",
    "start": "3081520",
    "end": "3087119"
  },
  {
    "text": "network applications address bace is format string right so the idea is that the user can actually input a format",
    "start": "3087119",
    "end": "3093440"
  },
  {
    "text": "stream or input something that's part of the format stream used in a print family",
    "start": "3093440",
    "end": "3098559"
  },
  {
    "text": "of functions so the damage could be it could cause the information leakage it can read the entire memory uh address",
    "start": "3098559",
    "end": "3105680"
  },
  {
    "text": "space or it can update the arbitrary memory location so that's pretty bad the second one so essentially you can update",
    "start": "3105680",
    "end": "3111160"
  },
  {
    "text": "you know return address function pointer all these things so right now there's isn't them um that good a solution",
    "start": "3111160",
    "end": "3117799"
  },
  {
    "text": "around but presumably one way to solve this problem is you can add additional checks to ensure that the Forman stream",
    "start": "3117799",
    "end": "3124079"
  },
  {
    "text": "doesn't contain all these weird speci files when print F has only one argument so that that's usually the the problem",
    "start": "3124079",
    "end": "3131079"
  },
  {
    "text": "all right so you can actually presumably do something along this line to stop formance string attack so the the",
    "start": "3131079",
    "end": "3137160"
  },
  {
    "text": "overall goal of the project is to say that nobody can touch my address base that's what we want to do and we",
    "start": "3137160",
    "end": "3144079"
  },
  {
    "text": "basically get rid of the bu overflow sort of threat so we just have to move on to integer overflow and format stream",
    "start": "3144079",
    "end": "3150839"
  },
  {
    "text": "so that nobody can touch my address space and then then I don't have to worry about what actually happens",
    "start": "3150839",
    "end": "3156960"
  },
  {
    "text": "after now as a side note um the the this segmentation Hardware just as a as a",
    "start": "3156960",
    "end": "3164400"
  },
  {
    "text": "history the segmentation Hardware in x86 architecture comes from this uh you know",
    "start": "3164400",
    "end": "3169880"
  },
  {
    "text": "Intel 432 architecture right capability based this and that and there's actually",
    "start": "3169880",
    "end": "3176160"
  },
  {
    "text": "uh a a reason why they actually implement this because you know this Intel X 4432 actually try to support",
    "start": "3176160",
    "end": "3183200"
  },
  {
    "text": "various kind of protection model used in motics right but people in research",
    "start": "3183200",
    "end": "3189040"
  },
  {
    "text": "Community academic in general and in commercial World simply ignore segmentation Hardware there's actually a",
    "start": "3189040",
    "end": "3195760"
  },
  {
    "text": "well-known question asked by John Hennessy and Patterson in their computer architecture book is it useful is",
    "start": "3195760",
    "end": "3203640"
  },
  {
    "text": "segmentation Hardware useful in terms of improving the Internet Security and all",
    "start": "3203640",
    "end": "3210280"
  },
  {
    "text": "the work on cash demonstrate that yes it is useful and not only we demonstrate that there are other people that also",
    "start": "3210280",
    "end": "3216680"
  },
  {
    "text": "demonstrate that segmentation Hardware is actually our friend unfortunately just get ignore for a long time PEX",
    "start": "3216680",
    "end": "3223960"
  },
  {
    "text": "project use segmentation Hardware to make sure that either you can write to something or you can execute something",
    "start": "3223960",
    "end": "3229559"
  },
  {
    "text": "you cannot either you cannot both write and execute so that's the way exe implements and n no execute uh uh pages",
    "start": "3229559",
    "end": "3237400"
  },
  {
    "text": "and then some that we also do another project that try to exploit segmentation Hardware to do very fast intro address",
    "start": "3237400",
    "end": "3243799"
  },
  {
    "text": "Bas protection domain and that may be very useful for safe Java native method invocation right when you have Java",
    "start": "3243799",
    "end": "3250480"
  },
  {
    "text": "unfortunately this is Little Thing Called native method interface that allows you to interface Java with c and",
    "start": "3250480",
    "end": "3257640"
  },
  {
    "text": "so all your type security of java might gu grp because you have a c somewhere lying around in the same address space",
    "start": "3257640",
    "end": "3264319"
  },
  {
    "text": "so conclusion I just want to to tell you that there's such a thing called Cash and this is",
    "start": "3264319",
    "end": "3270119"
  },
  {
    "text": "this is the world's fastest AR Bank checking technology for C and C++ programs on x86 Hardware this is a",
    "start": "3270119",
    "end": "3277119"
  },
  {
    "text": "accurate technically accurate statement right and moreover it guarantees no buff",
    "start": "3277119",
    "end": "3282319"
  },
  {
    "text": "overflow attack so so with this if you have x86 Buck there's really no reason",
    "start": "3282319",
    "end": "3287799"
  },
  {
    "text": "not to use it right just compile it you know on Linux there's no problem you don't really have to worry about all",
    "start": "3287799",
    "end": "3293760"
  },
  {
    "text": "these other junks that you know people people are talking about and it's reasonably low overhead right I already show you even for big programs like",
    "start": "3293760",
    "end": "3300440"
  },
  {
    "text": "Apachi and S it's fine and and original concern that we have software fall back",
    "start": "3300440",
    "end": "3306640"
  },
  {
    "text": "you know the limited number of segment descriptor segment register turns out not to be a problem it's a good news",
    "start": "3306640",
    "end": "3312760"
  },
  {
    "text": "that it's not a problem now the bad news is that unfortunately ia64 and itanium",
    "start": "3312760",
    "end": "3318799"
  },
  {
    "text": "and the 64bit version of AMD they itanian doesn't even support a l i6 4",
    "start": "3318799",
    "end": "3325520"
  },
  {
    "text": "and AMD 64bit version only support segmentation Hardware in the backw competive mode not in their native mode",
    "start": "3325520",
    "end": "3333240"
  },
  {
    "text": "all right so that's the bad news so now right now it really only works on on I 32 or in the compatibility mode of",
    "start": "3333240",
    "end": "3341240"
  },
  {
    "text": "I64 so future work we want to port cach to Java right now it only works for C",
    "start": "3341240",
    "end": "3347280"
  },
  {
    "text": "Java simp presumably is a simpler case you know because it doesn't have a lot of pointers and and we already solved",
    "start": "3347280",
    "end": "3353240"
  },
  {
    "text": "the Legacy Cod compatiability problem one of the thing that we are thinking about is that how do we do this uh using",
    "start": "3353240",
    "end": "3359280"
  },
  {
    "text": "source to Source cach transformation the problem is that we don't have access to the compiler source code on the Windows",
    "start": "3359280",
    "end": "3364839"
  },
  {
    "text": "platform other than that uh that um Linux like um uh GCC like a platform so",
    "start": "3364839",
    "end": "3372680"
  },
  {
    "text": "we don't want that we just want something like visual studio right that that's the kind of thing that people use today on the Windows platform so one",
    "start": "3372680",
    "end": "3379039"
  },
  {
    "text": "idea is that can I implement this idea by taking users source code and then transforming somehow and then compile",
    "start": "3379039",
    "end": "3386000"
  },
  {
    "text": "using visual studio that would be nice right so just having a source to Source version of cach probably can solve this",
    "start": "3386000",
    "end": "3392640"
  },
  {
    "text": "problem of not being able to access the source code of Windows compiler and then the ultimate goal is to stop all sort of",
    "start": "3392640",
    "end": "3399680"
  },
  {
    "text": "tempering attempts uh into the address bace so so the the whole package is",
    "start": "3399680",
    "end": "3405440"
  },
  {
    "text": "available in this particular um web page so you wel come to download it and try it out and we we are committed to fixing",
    "start": "3405440",
    "end": "3412000"
  },
  {
    "text": "the box if you have uh some box to report so if you have any questions I'll be",
    "start": "3412000",
    "end": "3417400"
  },
  {
    "text": "happy to answer them",
    "start": "3417400",
    "end": "3421558"
  },
  {
    "text": "yes the hash within the what hash we are talking",
    "start": "3431839",
    "end": "3437760"
  },
  {
    "text": "about",
    "start": "3438480",
    "end": "3441480"
  },
  {
    "text": "yes no not really so that hash um which hash",
    "start": "3443799",
    "end": "3450680"
  },
  {
    "text": "we are talking about actually I'm not really sure so there's actually a hash that allows you to find for memory reference which is the corresponding uh",
    "start": "3450680",
    "end": "3458319"
  },
  {
    "text": "object and then from there we have to retrieve the corresponding segment and load the corresponding segment",
    "start": "3458319",
    "end": "3464559"
  },
  {
    "text": "descriptor into the segment register so for every memory reference is always checked there's no bypassing so the hash",
    "start": "3464559",
    "end": "3471200"
  },
  {
    "text": "is mainly to look up Which object it is so that I can load the correspondence segment into my segment",
    "start": "3471200",
    "end": "3478440"
  },
  {
    "text": "register oh cach yes sorry so so that cach only uh allows you to bypass the",
    "start": "3481880",
    "end": "3489359"
  },
  {
    "text": "manipulation of LT so ldt entry still within there so you don't touch it",
    "start": "3489359",
    "end": "3494480"
  },
  {
    "text": "because you don't make system call so because so essentially let's say I have a array right and I'm going to put it in",
    "start": "3494480",
    "end": "3501000"
  },
  {
    "text": "the LT entry number three okay but the right way to do it is that every time I",
    "start": "3501000",
    "end": "3506400"
  },
  {
    "text": "use it I allocate one entry and every time I exit I deallocate it and if the",
    "start": "3506400",
    "end": "3511720"
  },
  {
    "text": "pattern is that the same object the same array within a function needs to be allocated and deallocated I say that",
    "start": "3511720",
    "end": "3518480"
  },
  {
    "text": "don't touch LT in at the user level I can check oh this is the same guy so I don't even need to allocate or",
    "start": "3518480",
    "end": "3524280"
  },
  {
    "text": "deallocate RT so that's the main issue so but this has nothing to do with the actual AR Bank checkin it's just about",
    "start": "3524280",
    "end": "3531119"
  },
  {
    "text": "how do you allocate and deallocate LT entries but you're right in it turns out this is",
    "start": "3531119",
    "end": "3537880"
  },
  {
    "text": "you know if it is Major idea that's that's it that's the idea that we hit out without that that's performance is",
    "start": "3537880",
    "end": "3543400"
  },
  {
    "text": "sort of pretty",
    "start": "3543400",
    "end": "3546078"
  },
  {
    "text": "bad start going Bigg memory model yes that could be a problem so you know as I say",
    "start": "3563640",
    "end": "3569920"
  },
  {
    "text": "that you know this is really artifact of having only six segment register so you know we are trying to convince uh uh",
    "start": "3569920",
    "end": "3576359"
  },
  {
    "text": "Intel that you know please preserve the segment Hardware feature and by the way increase the number of segment register",
    "start": "3576359",
    "end": "3582160"
  },
  {
    "text": "is really nothing right I mean this is a couple of register there's no need to be you know uh know economical about this",
    "start": "3582160",
    "end": "3588760"
  },
  {
    "text": "right so so but you are right that you know if you use more and more then some of this segment register might get used",
    "start": "3588760",
    "end": "3594440"
  },
  {
    "text": "by for some other purpose so we will end up using having smaller number of segment register to use but one pro one",
    "start": "3594440",
    "end": "3601319"
  },
  {
    "text": "one potential uh solution to this problem is that we now we actually have to move the segment register as part of",
    "start": "3601319",
    "end": "3607760"
  },
  {
    "text": "the you know function call routine like when you save the context you need to save the segment register as well and",
    "start": "3607760",
    "end": "3613599"
  },
  {
    "text": "you have to keep track of them and so on so that that sort of complicates the the the code a little",
    "start": "3613599",
    "end": "3619400"
  },
  {
    "text": "bit yes",
    "start": "3619400",
    "end": "3626559"
  },
  {
    "text": "yes so so that's what we are talking about one example is this es that the GPC so we carefully checked whether",
    "start": "3631720",
    "end": "3638200"
  },
  {
    "text": "these segment registers have been used or not and then the only thing that we find out is this GPC is a stream",
    "start": "3638200",
    "end": "3643359"
  },
  {
    "text": "manipulation function actually use them so as I say in in typical Linux there are only four segments so code CS is DS",
    "start": "3643359",
    "end": "3650960"
  },
  {
    "text": "SS and and some other thing all right so so so these four segment do not exist",
    "start": "3650960",
    "end": "3656920"
  },
  {
    "text": "simultaneously right so so they don't really use that many segment registers the only sort of significant application",
    "start": "3656920",
    "end": "3663480"
  },
  {
    "text": "that we can think of they actually use segments is this wine project they actually use segments but you know that",
    "start": "3663480",
    "end": "3669920"
  },
  {
    "text": "that in general is not really a a problem for",
    "start": "3669920",
    "end": "3675640"
  },
  {
    "text": "now this this is actually is GPL yes so the kernel dependency is very small the",
    "start": "3677880",
    "end": "3684720"
  },
  {
    "text": "only thing we need is that that F system call to modify that's the only thing if you",
    "start": "3684720",
    "end": "3689760"
  },
  {
    "text": "don't want that and you don't care about that you don't really need that additional kernel support everything we talked about here is actually user label",
    "start": "3689760",
    "end": "3696480"
  },
  {
    "text": "though I mean I can allocate the segment register anywhere I want it when I compile my thing right so there's no",
    "start": "3696480",
    "end": "3701680"
  },
  {
    "text": "need for any additional Kel support so you know so so but you know",
    "start": "3701680",
    "end": "3707760"
  },
  {
    "text": "so so the general thing is that the kernel support is mainly for performance optimization but if you don't really uh",
    "start": "3707760",
    "end": "3714640"
  },
  {
    "text": "one day you can suffer you can you can live with a little bit higher performance overhead you probably don't need that colal support and then it it",
    "start": "3714640",
    "end": "3721200"
  },
  {
    "text": "could should be pretty easy to Port it to some other units like",
    "start": "3721200",
    "end": "3727038"
  },
  {
    "text": "platforms",
    "start": "3729039",
    "end": "3732039"
  },
  {
    "text": "yes first come first for the first three arrays yes we don't actually do sort of register ocation algorism coloring you",
    "start": "3743359",
    "end": "3750640"
  },
  {
    "text": "know and spilling and so on so we Tred we we think we are considering and then",
    "start": "3750640",
    "end": "3756200"
  },
  {
    "text": "we say let's try the simple approach and then we never actually goes back because it doesn't seem to be a",
    "start": "3756200",
    "end": "3762720"
  },
  {
    "text": "problem all right okay thank you thanks",
    "start": "3768920",
    "end": "3776359"
  },
  {
    "text": "e",
    "start": "3833279",
    "end": "3836279"
  },
  {
    "text": "e",
    "start": "3863200",
    "end": "3866200"
  },
  {
    "text": "e",
    "start": "3893160",
    "end": "3896160"
  },
  {
    "text": "for",
    "start": "3923079",
    "end": "3926079"
  },
  {
    "text": "e",
    "start": "3953079",
    "end": "3956079"
  },
  {
    "text": "e",
    "start": "3983000",
    "end": "3986000"
  }
]