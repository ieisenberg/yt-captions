[
  {
    "start": "0",
    "end": "40000"
  },
  {
    "text": "all right good evening everyone I'm here to talk to you about breaking the x86 instruction set architecture I think it",
    "start": "0",
    "end": "6540"
  },
  {
    "text": "should be a pretty fun conclusion to a really cool black hat first off my name is Christopher Domus I'm a cybersecurity",
    "start": "6540",
    "end": "13110"
  },
  {
    "text": "researcher at a place called the Battelle Memorial Institute I really really like working here I get a chance",
    "start": "13110",
    "end": "19080"
  },
  {
    "text": "to encounter a lot of really difficult problems but what I think I like the most is that with the problems and",
    "start": "19080",
    "end": "25230"
  },
  {
    "text": "people I work with on a day to day basis I actually get a lot of really neat ideas on fringe areas of cybersecurity",
    "start": "25230",
    "end": "31289"
  },
  {
    "text": "that I can sort of explore in my free time so that's what I want to talk to you about today is a little side project I've been working on on and off for the",
    "start": "31289",
    "end": "37829"
  },
  {
    "text": "last few months called sand sifter so this whole thing comes down to an issue",
    "start": "37829",
    "end": "42870"
  },
  {
    "start": "40000",
    "end": "40000"
  },
  {
    "text": "of trust and I'm going to start out with a really obvious observation we don't trust software and that's a really good",
    "start": "42870",
    "end": "49530"
  },
  {
    "text": "thing software's horrible so we audit software to make sure that it's working the way we expect it to",
    "start": "49530",
    "end": "56129"
  },
  {
    "text": "work we reverse engineer software to make sure there's no secret functionality in it we want to make sure minesweeper is not dialing out some",
    "start": "56129",
    "end": "62730"
  },
  {
    "text": "Russian website right we break software we try to find vulnerabilities and we exploit software for the sake of",
    "start": "62730",
    "end": "68340"
  },
  {
    "text": "hardening hardening it to make it more trustworthy and then we still after all",
    "start": "68340",
    "end": "73409"
  },
  {
    "text": "this we still don't trust software so we just stand box it to try to minimize the damage when something goes rogue so but",
    "start": "73409",
    "end": "81060"
  },
  {
    "text": "what about the processor itself you know the thing responsible for running all this software the thing responsible for",
    "start": "81060",
    "end": "87119"
  },
  {
    "text": "enforcing all the security boundaries on the system even though we don't trust software the processor we just blindly",
    "start": "87119",
    "end": "93180"
  },
  {
    "text": "trust and there's a reason for that we don't have reverse engineering and introspection auditing tools for",
    "start": "93180",
    "end": "99990"
  },
  {
    "text": "hardware the way that we have them for software we don't really have a way to establish trust in the processor the",
    "start": "99990",
    "end": "106770"
  },
  {
    "text": "best thing we have are reference manuals and specifications that describe what this processor does we have to read",
    "start": "106770",
    "end": "112229"
  },
  {
    "text": "these documents and just assume on faith that this is how the processor actually operates and I think that's absolutely",
    "start": "112229",
    "end": "118140"
  },
  {
    "text": "crazy because we would never do that in software right you would never download some random executable from a website",
    "start": "118140",
    "end": "123299"
  },
  {
    "text": "read the readme see the readme says totally not a virus and think yeah this is totally not a virus I'll go ahead and",
    "start": "123299",
    "end": "129599"
  },
  {
    "text": "run it but that's exactly what we're doing with our process all we have to go on is the documentation that says this is how the",
    "start": "129599",
    "end": "135980"
  },
  {
    "text": "processor operates so why is that why do we blindly trust the processor even when",
    "start": "135980",
    "end": "141170"
  },
  {
    "text": "we're so untrusting of software because hardware has all the exact same problems",
    "start": "141170",
    "end": "146540"
  },
  {
    "text": "that software has so in software we worry about secret functionality right well hardware has secret functionality",
    "start": "146540",
    "end": "152870"
  },
  {
    "text": "for example intel infamously had what were called the appendix h documents with the pentium processor this was like",
    "start": "152870",
    "end": "158960"
  },
  {
    "text": "a secret set of documentation that described proprietary parts of the architecture that they didn't want the",
    "start": "158960",
    "end": "163970"
  },
  {
    "text": "regular public to know about you can only get access to appendix H if you are a trusted Intel partner what about bugs",
    "start": "163970",
    "end": "170060"
  },
  {
    "text": "we worry about bugs and software right does hardware have bugs absolutely the Pentium had the food bug where you could",
    "start": "170060",
    "end": "176630"
  },
  {
    "text": "give it what was called a lock cop exchange instruction the processor itself would lock up the serious",
    "start": "176630",
    "end": "181670"
  },
  {
    "text": "security vulnerability the Pentium had the F did bugs where in one in a couple billion floating-point instructions",
    "start": "181670",
    "end": "186680"
  },
  {
    "text": "would be off by a fraction of a percent cost until about five hundred million dollars has well has T effects bugs you",
    "start": "186680",
    "end": "193670"
  },
  {
    "text": "may have heard that they had to completely disable transactional memory support and has well because of bugs skylake has hyper-threading bugs things",
    "start": "193670",
    "end": "200959"
  },
  {
    "text": "that look pretty serious and could cause data corruption you may have heard about the risen bugs where in risen processors",
    "start": "200959",
    "end": "206090"
  },
  {
    "text": "will lock up or crash under heavy SMA three instruction modes we're just riddled with bugs in our",
    "start": "206090",
    "end": "212930"
  },
  {
    "text": "modern processors what about vulnerabilities and worried about vulnerabilities and software processors have vulnerabilities to assist read",
    "start": "212930",
    "end": "219800"
  },
  {
    "text": "vulnerability on x86 allowed kernel privilege escalation on a wide variety",
    "start": "219800",
    "end": "224959"
  },
  {
    "text": "of operating systems to cache poisoning and memory sinkhole attacks allowed privilege escalation into system",
    "start": "224959",
    "end": "230900"
  },
  {
    "text": "management mode on x86 processors we have vulnerability to the lore on these processors as well so if if processors",
    "start": "230900",
    "end": "238459"
  },
  {
    "text": "have all the same issues as software we should really stop just blindly trusting",
    "start": "238459",
    "end": "243530"
  },
  {
    "text": "the hardware so what kind of things that we need to worry about when I say we should stop trusting the hardware so",
    "start": "243530",
    "end": "250010"
  },
  {
    "text": "much well the the main thing I was interested in for the purposes of this research where hidden instructions built",
    "start": "250010",
    "end": "255500"
  },
  {
    "text": "into the processor basically secret functionality that could give you backdoor or powerful access to some sort",
    "start": "255500",
    "end": "260750"
  },
  {
    "text": "of processor internals this sounds almost conspiracy theory astray like this is crazy but it's not all",
    "start": "260750",
    "end": "266120"
  },
  {
    "text": "far removed from reality we actually have some pretty good historical examples of this kind of thing built into x86 so for example at 56 used to",
    "start": "266120",
    "end": "274310"
  },
  {
    "text": "have what was called the ice breakpoint instruction this was an undocumented instruction not acknowledged by the manufacturer that would put the",
    "start": "274310",
    "end": "280610"
  },
  {
    "text": "processor into a special privileged ice mode used to have the load all instruction another undocumented",
    "start": "280610",
    "end": "286520"
  },
  {
    "text": "unacknowledged instruction that would allow you to load secret processor registers with values that you couldn't",
    "start": "286520",
    "end": "292550"
  },
  {
    "text": "normally get into those registers even looking at more recent examples you may have heard about the API call",
    "start": "292550",
    "end": "298690"
  },
  {
    "text": "vulnerabilities and the Microsoft x86 emulator is essentially Microsoft backdoored the ud0 instruction in x86 to",
    "start": "298690",
    "end": "306800"
  },
  {
    "text": "redefine that instruction to me something entirely different and then didn't really acknowledge that that instruction existed so this is not all",
    "start": "306800",
    "end": "313639"
  },
  {
    "text": "that far removed from reality the possibility of powerful hidden instructions is very real and sort of",
    "start": "313639",
    "end": "319580"
  },
  {
    "text": "hit that home if you open up x86 software developer manual guides you",
    "start": "319580",
    "end": "325130"
  },
  {
    "text": "look towards the back of Intel SDM vol 2 you'll see page after page of tables that look like this these are the",
    "start": "325130",
    "end": "331610"
  },
  {
    "text": "processor opcode Maps they basically are supposed to tell you every instruction that exists in your processor they tell",
    "start": "331610",
    "end": "336950"
  },
  {
    "text": "you when your processor sees this byte it executed this instruction when it see this bite it executes this instruction",
    "start": "336950",
    "end": "342800"
  },
  {
    "text": "but you may notice something if you look really closely at these opcode maps there's something a little unusual here there's a gap down on the bottom here",
    "start": "342800",
    "end": "349460"
  },
  {
    "text": "now this is the document that's supposed to tell us exactly what this processor does this is a document we're basing all",
    "start": "349460",
    "end": "356060"
  },
  {
    "text": "of our trust on but it's intentionally leaving things out now we don't have",
    "start": "356060",
    "end": "361370"
  },
  {
    "text": "reverse engineering or auditing tools for x86 we really just have this document and it's intentionally not",
    "start": "361370",
    "end": "367940"
  },
  {
    "text": "giving us all of the information so that's not a really good start towards trusting these processors right so my",
    "start": "367940",
    "end": "374930"
  },
  {
    "start": "373000",
    "end": "373000"
  },
  {
    "text": "goal when I set out on this project was to find a way to sort of audit the processor figure out what instructions are really on this thing so how do we",
    "start": "374930",
    "end": "382910"
  },
  {
    "start": "381000",
    "end": "381000"
  },
  {
    "text": "find hidden instructions in the x86 architecture and whether there's a unique challenge in x86 maybe that",
    "start": "382910",
    "end": "389449"
  },
  {
    "text": "instructions and x86 are very complex they can be either 1 byte long so for example increment EAX is a 1 byte",
    "start": "389449",
    "end": "395510"
  },
  {
    "text": "instruction just hex 40 or they can be up to 15 long so la CAD Huard TS override some",
    "start": "395510",
    "end": "402300"
  },
  {
    "text": "complicated address some complicated immediate value is a 15 byte instruction in the x86 architecture so if you look",
    "start": "402300",
    "end": "409650"
  },
  {
    "text": "at a worst case scenario how many instructions could there possibly be in x86 if we just say what if all",
    "start": "409650",
    "end": "414750"
  },
  {
    "text": "instructions are 15 bytes long the maximum length it's somewhere in the order of 1.3 undecillion possible",
    "start": "414750",
    "end": "420780"
  },
  {
    "text": "instructions that's that's a really really unfathomably large search space",
    "start": "420780",
    "end": "425850"
  },
  {
    "text": "right which means that the obvious approaches to trying to search through this instruction set don't really work",
    "start": "425850",
    "end": "432570"
  },
  {
    "text": "you can't just try all the instructions that might work on our RISC processor that's not going to work on an x86",
    "start": "432570",
    "end": "437610"
  },
  {
    "text": "processor you can't really just try random instructions it's going to give you really really poor coverage if you",
    "start": "437610",
    "end": "443490"
  },
  {
    "text": "just generate random instructions to see how they execute on the processor so you might think well could we could we guide",
    "start": "443490",
    "end": "449940"
  },
  {
    "text": "our fuzzing based on the processor documentation whether there's two big problems with that one I think we've",
    "start": "449940",
    "end": "455850"
  },
  {
    "text": "already kind of established the documentation isn't telling us everything the documentation can't be trusted if you guide your analysis based on the",
    "start": "455850",
    "end": "462720"
  },
  {
    "text": "documentation you're sort of going to lose right from the start another big",
    "start": "462720",
    "end": "468300"
  },
  {
    "text": "issue with that you might think well we saw those gaps in the opcode maps right why don't we just like buzz around those",
    "start": "468300",
    "end": "473640"
  },
  {
    "text": "gaps those gaps really only tell you the first byte of the instruction so if you're dealing with a complex",
    "start": "473640",
    "end": "479340"
  },
  {
    "text": "instruction that exists within one of those gaps you're still not going to be able to find it with any naive approach trying to focus just on my gapped area",
    "start": "479340",
    "end": "486360"
  },
  {
    "text": "we need something a lot more intelligent to search through the x86 instruction space so our goal here since we've got",
    "start": "486360",
    "end": "493710"
  },
  {
    "text": "so many possible bytes in an instruction is to quickly skip over the bytes that don't matter so that we can focus on the",
    "start": "493710",
    "end": "499980"
  },
  {
    "text": "bytes that actually do matter so I start out with an observation here the meaningful bytes in an x86 instruction",
    "start": "499980",
    "end": "505950"
  },
  {
    "text": "impact either that instructions length or its exception behavior in other words the bytes that really matter are",
    "start": "505950",
    "end": "512039"
  },
  {
    "text": "changing something fundamental about that instruction and the bytes that don't matter tend to just be register or",
    "start": "512039",
    "end": "518520"
  },
  {
    "text": "immediate values that don't really change anything fundamental about that instruction so I want to find a way to focus on those meaningful bytes and I",
    "start": "518520",
    "end": "524910"
  },
  {
    "text": "kind of came up with an approach that would use a depth first search algorithm to quickly enumerate the x86 instruction",
    "start": "524910",
    "end": "530700"
  },
  {
    "text": "set and it works something like this we're going to guess in arbitrary x86 instruction I'm going to basically guess",
    "start": "530700",
    "end": "536640"
  },
  {
    "text": "15 bytes let's start out with just 15 bytes of zeros then we're going to execute this instruction on the",
    "start": "536640",
    "end": "541770"
  },
  {
    "text": "processor and through that execution we're going to look at how long that instruction actually is in this",
    "start": "541770",
    "end": "547500"
  },
  {
    "text": "situation when we actually shoot that instruction we'll see that it's a 2-byte instruction so then I'm going to move to",
    "start": "547500",
    "end": "553110"
  },
  {
    "text": "the last byte of that instruction and I'm going to increment that last byte of the instruction and then I'm going to rerun the instruction to see how long it",
    "start": "553110",
    "end": "559920"
  },
  {
    "text": "is again again we'll see that this instruction is 2 bytes long we'll increment the last byte we execute it",
    "start": "559920",
    "end": "565110"
  },
  {
    "text": "observe its length increment the last byte executed observe its length and eventually when you increment that last",
    "start": "565110",
    "end": "570930"
  },
  {
    "text": "byte you're going to find something when you have to do the instruction the length of that instruction is going to change it just became 3 bytes now so",
    "start": "570930",
    "end": "578100"
  },
  {
    "text": "when you observe that the length of an instruction changes we're going to move to the last byte of the instruction and increment it again and begin the process",
    "start": "578100",
    "end": "584190"
  },
  {
    "text": "all over execute the instruction observe its length increment when you start doing this to search through the",
    "start": "584190",
    "end": "589680"
  },
  {
    "text": "instruction set these are the kinds of patterns you're going to find we'll start at 0 0 become 0 1 and when we",
    "start": "589680",
    "end": "595440"
  },
  {
    "text": "start incrementing eventually our instruction grows in length we'll keep incrementing and eventually",
    "start": "595440",
    "end": "600720"
  },
  {
    "text": "we'll observe another length change so as you can sort of see here we end up with more more complex instructions as",
    "start": "600720",
    "end": "607260"
  },
  {
    "text": "we drill deeper and deeper into the instruction set with this approach now eventually you're going to go through",
    "start": "607260",
    "end": "613050"
  },
  {
    "start": "611000",
    "end": "611000"
  },
  {
    "text": "all possibilities of that last byte of the instruction and the length isn't going to change any more so when that happens when you've tried all 256",
    "start": "613050",
    "end": "620160"
  },
  {
    "text": "possibilities for that last byte when that last bite is FF you're going to increment it to let it roll over and",
    "start": "620160",
    "end": "626190"
  },
  {
    "text": "you're going to move back up to the previous byte that way it's going to become your new marker that's what we're going to increment from from now on so",
    "start": "626190",
    "end": "632430"
  },
  {
    "text": "we're going to increment the marker execute the instruction observe its length if the length didn't change just",
    "start": "632430",
    "end": "637560"
  },
  {
    "text": "repeat that process increment the marker execute the instructions observe its length and we'll keep doing it eventually in this situation that marker",
    "start": "637560",
    "end": "644160"
  },
  {
    "text": "will roll over again so we'll move back another byte the marker will roll over we'll keep moving back and we keep doing",
    "start": "644160",
    "end": "649620"
  },
  {
    "text": "this continuously incrementing and moving back now until eventually when we",
    "start": "649620",
    "end": "654900"
  },
  {
    "text": "increment one of these bytes and execute the instruction the length of that instruction is going to change again so",
    "start": "654900",
    "end": "660330"
  },
  {
    "text": "we know that we changed another fundamental piece of this instruction so now we're going to move to the end of the instruction",
    "start": "660330",
    "end": "665830"
  },
  {
    "text": "the process all over again so what this approach does is essentially lets you",
    "start": "665830",
    "end": "672540"
  },
  {
    "text": "tunnel through this instruction space to quickly skip over these bytes that don't matter and really focus on the bytes",
    "start": "672540",
    "end": "678940"
  },
  {
    "text": "that do matter it lets you exhaustively search the bytes that actually impact the instruction execution and",
    "start": "678940",
    "end": "684790"
  },
  {
    "text": "effectively that reduces your search space from one point three times ten to the thirty-six impossible 15 bytes",
    "start": "684790",
    "end": "690130"
  },
  {
    "text": "instructions down to about a hundred million instructions which you can search through and about a day of",
    "start": "690130",
    "end": "695440"
  },
  {
    "text": "scanning the system but there's a big catch here that I kind of glossed over in order for this to work you need to",
    "start": "695440",
    "end": "700900"
  },
  {
    "start": "697000",
    "end": "697000"
  },
  {
    "text": "know what the length of an x86 instruction is now that seems like it should be easy it shouldn't be too hard",
    "start": "700900",
    "end": "705970"
  },
  {
    "text": "to figure out what the length of an instruction is but you can't just disassemble it because we're possibly dealing with undocumented instructions",
    "start": "705970",
    "end": "711790"
  },
  {
    "text": "right an obvious approach if you know x86 pretty well might be to try to use",
    "start": "711790",
    "end": "717160"
  },
  {
    "text": "the trap flag so the way the trap slide works in x86 is you set the trap flag you execute an instruction that",
    "start": "717160",
    "end": "722770"
  },
  {
    "text": "instruction runs and then the trap signal is generated your trap handler gets controlled now what your trap",
    "start": "722770",
    "end": "728590"
  },
  {
    "text": "handler could do is it could look at the new instruction pointer and compare that to the old instruction pointer the",
    "start": "728590",
    "end": "734380"
  },
  {
    "text": "difference between those two would be the length of your instruction it's seems easy enough but this fails to find",
    "start": "734380",
    "end": "739780"
  },
  {
    "text": "the length of faulting instructions because faulting instructions in x86 don't actually execute there's no change",
    "start": "739780",
    "end": "746260"
  },
  {
    "text": "in the instruction pointer so there's no what to resolve the length of a faulting instruction why do we hear about faulting instructions well trying to",
    "start": "746260",
    "end": "753460"
  },
  {
    "text": "execute a privileged instruction in a non privileged mode will generate a fault I want to find all instructions in",
    "start": "753460",
    "end": "760000"
  },
  {
    "text": "the x86 is a not just the one if that exists in my current mode so for example loading up control register is an",
    "start": "760000",
    "end": "767200"
  },
  {
    "text": "instruction that only exists in ring 0 the VM enter instruction is an instruction that only exists in the",
    "start": "767200",
    "end": "772720"
  },
  {
    "text": "hypervisor the resume instruction is something that only exists in system management mode I want to find all of",
    "start": "772720",
    "end": "777880"
  },
  {
    "text": "these instructions regardless of where I'm scanning from so I need to be able to find the length of faulting instructions as well as executing",
    "start": "777880",
    "end": "784030"
  },
  {
    "text": "instructions so this resolution I came up for with this was a sort of a page fault analysis so here's how this would",
    "start": "784030",
    "end": "790060"
  },
  {
    "start": "788000",
    "end": "788000"
  },
  {
    "text": "work to figure out an instruction length basically we're going to start with a candidate instruction we don't know how long this instruction actually is we're",
    "start": "790060",
    "end": "796450"
  },
  {
    "text": "in a set of two pages in memory the first page is going to have rewrite and execute permissions the second page is going to have only read",
    "start": "796450",
    "end": "803140"
  },
  {
    "text": "and write permissions we're going to put our instruction into these pages so the first byte of the instruction it's on",
    "start": "803140",
    "end": "808480"
  },
  {
    "text": "the last byte of the executable page and the rest of the instruction is on the non-executable page then we're going to",
    "start": "808480",
    "end": "814240"
  },
  {
    "text": "jump to the instruction to try to execute it so here's what happens internally in the processor when we do",
    "start": "814240",
    "end": "819370"
  },
  {
    "text": "it when we do this the process referred fetches that first byte that OS bite out of the executable page and",
    "start": "819370",
    "end": "826150"
  },
  {
    "text": "it sees Oh F is not instruction by itself it needs more bytes for this instruction so then it's going to try to",
    "start": "826150",
    "end": "831910"
  },
  {
    "text": "fetch the next byte it tries to fetch that six a that six a is sitting in a non executable page that means we're",
    "start": "831910",
    "end": "837760"
  },
  {
    "text": "going to get a page fault exception when it tries to hit six a specifically we get a page fault exception with the CR",
    "start": "837760",
    "end": "844030"
  },
  {
    "text": "to register loaded with the address of the page fault so C r2 is going to point to the address of that second page in",
    "start": "844030",
    "end": "850570"
  },
  {
    "text": "memory when we get this fault so if we receive that page fault exception with c r2 pointing to the second page in memory",
    "start": "850570",
    "end": "857830"
  },
  {
    "text": "we know that our instruction is longer than just that Oh F so we move the whole instruction back a byte and repeat the",
    "start": "857830",
    "end": "864130"
  },
  {
    "text": "process execute the instruction the decoder is going to look at that Oh F say I need another bite now can",
    "start": "864130",
    "end": "869680"
  },
  {
    "text": "successfully fetch the six a since it's ending in an executable page it's going to realize I still need more bytes for",
    "start": "869680",
    "end": "875290"
  },
  {
    "text": "this instruction to be complete so it's going to try to fetch that six zero now we get the page fault exception again",
    "start": "875290",
    "end": "880720"
  },
  {
    "text": "move the instruction back up byte and just continue this process as long as we're getting page faults with CR to set",
    "start": "880720",
    "end": "886390"
  },
  {
    "text": "to the address of the second page continue this process and eventually what you'll find is your entire",
    "start": "886390",
    "end": "891580"
  },
  {
    "text": "instruction sits in the executable memory and when that happens a lot of different things can occur either the",
    "start": "891580",
    "end": "898090"
  },
  {
    "text": "instruction could successfully run the instruction could throw an entirely different faults or the instruction could throw a page fault just with a",
    "start": "898090",
    "end": "904330"
  },
  {
    "text": "different value in C r2 but regardless of what happens here in all cases we know that the instruction has now been",
    "start": "904330",
    "end": "909550"
  },
  {
    "text": "successfully decoded so it must reside entirely the executable page meaning that we know the instructions lengths at",
    "start": "909550",
    "end": "915340"
  },
  {
    "text": "this point so we figured out how many bytes the instruction decoder consumed",
    "start": "915340",
    "end": "920650"
  },
  {
    "text": "but that doesn't actually mean that this instruction exists yet just because the bytes are decoded it doesn't mean this instruction is real even non-existing",
    "start": "920650",
    "end": "927520"
  },
  {
    "text": "instructions have to be decoded so how do we figure out if an instruction actually exists in the architecture well if the",
    "start": "927520",
    "end": "934010"
  },
  {
    "text": "instruction does not exist the processor is going to generate an undefined opcode exception after the instruction decode",
    "start": "934010",
    "end": "939440"
  },
  {
    "text": "phase so if we don't receive that UD exception that means that this",
    "start": "939440",
    "end": "944630"
  },
  {
    "text": "instruction exists so the neat thing about this approach is it gives us a way to find the lengths of successfully executing instructions faulting",
    "start": "944630",
    "end": "950870"
  },
  {
    "text": "instructions even privileged instructions so even sitting in ring 3 on the processor I can find out whether",
    "start": "950870",
    "end": "956150"
  },
  {
    "text": "certain instructions exist in ring 0 or ring -1 a ring - - using this approach so I threw all this functionality into a",
    "start": "956150",
    "end": "963490"
  },
  {
    "start": "960000",
    "end": "960000"
  },
  {
    "text": "process that I called the injector it basically does this page fault analysis and this instruction tunneling to search",
    "start": "963490",
    "end": "969800"
  },
  {
    "text": "through the x86 instruction set very quickly but the injector has a really big problem it's buzzing the device that",
    "start": "969800",
    "end": "976850"
  },
  {
    "start": "971000",
    "end": "971000"
  },
  {
    "text": "it's running on so how does the injector keep itself from crashing well it takes a little bit of work to make this happen",
    "start": "976850",
    "end": "982430"
  },
  {
    "text": "so very first thing we're going to do to keep the injector from crashing itself we are going to limit ourselves to ring",
    "start": "982430",
    "end": "987920"
  },
  {
    "text": "3 now that's not such a big limitation the injector can still resolve the lengths and existence of instructions inside of other more privileged rings so",
    "start": "987920",
    "end": "995360"
  },
  {
    "text": "that's actually ok but basically limiting ourselves to ring 3 prevent catastrophic system failure",
    "start": "995360",
    "end": "1000580"
  },
  {
    "text": "for bad instructions with the exception of very serious processor bugs so that's",
    "start": "1000580",
    "end": "1006160"
  },
  {
    "text": "nice that's a good first step toward keeping ourselves running the next thing we're going to do is we're going to hook all of the exceptions that these",
    "start": "1006160",
    "end": "1013240"
  },
  {
    "text": "instructions that we're generating could create so for example in Linux we're going to hook segmentation faults we're",
    "start": "1013240",
    "end": "1018850"
  },
  {
    "text": "going to hook illegal instruction exceptions hook floating-point exceptions hook bus errors and hope trap",
    "start": "1018850",
    "end": "1023860"
  },
  {
    "text": "exceptions and by hooking all of these things whenever an instruction throws one of these exceptions our process will",
    "start": "1023860",
    "end": "1030040"
  },
  {
    "text": "get controlled and it can correct the system state and by correct assistant state I mean our process is basically",
    "start": "1030040",
    "end": "1035350"
  },
  {
    "text": "going to reload the processes registers with known good values to allow execution to to continue so we're",
    "start": "1035350",
    "end": "1042428"
  },
  {
    "text": "getting further but we're not there yet the next step is we're going to initialize all general-purpose registers to 0 right before we execute these",
    "start": "1042429",
    "end": "1049720"
  },
  {
    "text": "candidate instructions with that lets us do is it lets us find or generate an arbitrary instruction like this which",
    "start": "1049720",
    "end": "1055750"
  },
  {
    "text": "writes a value to some arbitrary location in memory and it ensures that that address calculation resolves to 0",
    "start": "1055750",
    "end": "1062740"
  },
  {
    "text": "so EAX x + 4 times ETA is zero as long as our registers roll",
    "start": "1062740",
    "end": "1067990"
  },
  {
    "text": "initialize to zero that ensures that memory accesses don't accidentally hit the processes address space you don't",
    "start": "1067990",
    "end": "1073990"
  },
  {
    "text": "accidentally corrupt your process data in this process so it gets us a little closer but x86 has some really",
    "start": "1073990",
    "end": "1080230"
  },
  {
    "text": "complicated addressing forms so for example we can do EA X + 4 x EA x + some",
    "start": "1080230",
    "end": "1085240"
  },
  {
    "text": "big 32-bit value now even though those registers are initialized to 0 on the left test that calculation will be 0 is",
    "start": "1085240",
    "end": "1091630"
  },
  {
    "text": "that if that offset part of the calculation hits the instructor hits the processes address space we could still",
    "start": "1091630",
    "end": "1098200"
  },
  {
    "text": "corrupt our process and not be able to recover fortunately we're in good shape",
    "start": "1098200",
    "end": "1103630"
  },
  {
    "text": "here because of the tunneling approach to how we generate these instructions so basically tunneling is fuzzing one",
    "start": "1103630",
    "end": "1110350"
  },
  {
    "text": "byte of the instruction at a time so that offset in the memory access has to",
    "start": "1110350",
    "end": "1116500"
  },
  {
    "text": "have three bytes of zeros inside of it and one byte of non zeros so it just so happens that all the possible offsets we",
    "start": "1116500",
    "end": "1123160"
  },
  {
    "text": "can generate through tunneling don't hit the processors address space so we don't corrupt our system state now any of",
    "start": "1123160",
    "end": "1129790"
  },
  {
    "text": "those other offsets do generate a segfault exception but that's fine we catch saved faults and recover from them",
    "start": "1129790",
    "end": "1135430"
  },
  {
    "text": "inside of our process so you can throw faulting instructions now anything about non faulting instructions basically the",
    "start": "1135430",
    "end": "1143170"
  },
  {
    "text": "analysis needs to continue after the instruction successfully execute so imagine that you randomly generate an",
    "start": "1143170",
    "end": "1148990"
  },
  {
    "text": "instruction that says jump back 40 bytes well now you're going to be executing random code and that's going to",
    "start": "1148990",
    "end": "1154390"
  },
  {
    "text": "irrevocably corrupt your process state and the injector is going to come crashing down we don't want that to occur we need to systematically get",
    "start": "1154390",
    "end": "1161290"
  },
  {
    "text": "control back after these instructions execute so here's where the traps I can actually help us will set the trap flag",
    "start": "1161290",
    "end": "1166840"
  },
  {
    "text": "right before we execute one of these candidate instructions and in our trap handler we'll reload the registers to",
    "start": "1166840",
    "end": "1172240"
  },
  {
    "text": "some known good state so regardless of what that instruction did to the registers were restore them to good value so with all these approaches by",
    "start": "1172240",
    "end": "1179770"
  },
  {
    "text": "limiting ourselves to rank 3 by handling all the possible exceptions by initializing registers and maintaining",
    "start": "1179770",
    "end": "1185410"
  },
  {
    "text": "registers in a known good state and trapping these executions of these instructions the injector is actually",
    "start": "1185410",
    "end": "1190900"
  },
  {
    "text": "able to survive now so at this point we've got a way to search the x86",
    "start": "1190900",
    "end": "1196210"
  },
  {
    "text": "instruction space but now how do we make sense of the instructions that were actually executing so I designed what I",
    "start": "1196210",
    "end": "1203660"
  },
  {
    "start": "1202000",
    "end": "1202000"
  },
  {
    "text": "called the sifter for this sifter is basically a wrapper around the injector and the sifters job is to parse and",
    "start": "1203660",
    "end": "1210140"
  },
  {
    "text": "process the results of the injector and look for anomalies in the execution now",
    "start": "1210140",
    "end": "1215930"
  },
  {
    "text": "what do I mean when I say an execution anomaly basically what I want to find is anywhere where what the processor",
    "start": "1215930",
    "end": "1221660"
  },
  {
    "text": "actually does deviate from what the processor manuals say the processor should do now the easiest way to",
    "start": "1221660",
    "end": "1228320"
  },
  {
    "start": "1228000",
    "end": "1228000"
  },
  {
    "text": "accomplish that is to find some sort of ground truth that represents the processor manuals so what I did for this is that it's used a disassembler as my",
    "start": "1228320",
    "end": "1235400"
  },
  {
    "text": "ground truth capstone in this situation the idea here being that the disassembler is written based off of the",
    "start": "1235400",
    "end": "1241940"
  },
  {
    "text": "processor documentation so if I find some difference between the actual execution and capstone that indicates a",
    "start": "1241940",
    "end": "1248810"
  },
  {
    "text": "difference between actual execution and documentation so how do we actually pull",
    "start": "1248810",
    "end": "1253970"
  },
  {
    "text": "out interesting anomalies then now that we've got this disassembler as our ground truth well we can pull and pull",
    "start": "1253970",
    "end": "1259730"
  },
  {
    "text": "out undocumented instructions this way if the disassembler doesn't recognize a byte sequence but the instruction",
    "start": "1259730",
    "end": "1266300"
  },
  {
    "text": "generates anything other than an undefined opcode exception that indicates that this instruction exists on the processor but it's not documented",
    "start": "1266300",
    "end": "1274030"
  },
  {
    "text": "we can also pull out software bugs using this approach basically if the disassembler recognizes an instruction",
    "start": "1274030",
    "end": "1279590"
  },
  {
    "text": "but it thinks it's one length and the processor says it's a different length that usually indicates that there's some sort of bug in our disassembler okay",
    "start": "1279590",
    "end": "1286820"
  },
  {
    "text": "also by hardware bugs with this approach now there's no really good heuristic for pulling out Hardware bugs basically",
    "start": "1286820",
    "end": "1292370"
  },
  {
    "text": "everything just goes haywire when there's hardware bugs and I'll show what that looks like a little bit later on it requires a little bit of manual analysis",
    "start": "1292370",
    "end": "1298910"
  },
  {
    "text": "to us to identify so I'm going to try to demonstrate this and sift or tool for",
    "start": "1298910",
    "end": "1304460"
  },
  {
    "text": "you here what I'm going to do is I'm going to fire up a sand sifter and see",
    "start": "1304460",
    "end": "1311510"
  },
  {
    "text": "if we can adjust this so what we see",
    "start": "1311510",
    "end": "1316730"
  },
  {
    "text": "here is Stan's if you're scanning through the x86 instruction set architecture on the top here are the",
    "start": "1316730",
    "end": "1324230"
  },
  {
    "text": "instructions that can scepter is currently injecting into the processor on the right is the raw bite sequence",
    "start": "1324230",
    "end": "1330320"
  },
  {
    "text": "that it's generating and if you watch that byte sequence you can actually sort of see how this tunneling process is working how it's",
    "start": "1330320",
    "end": "1336540"
  },
  {
    "text": "incrementally building more and more complex instructions by modifying the last byte of the instruction this",
    "start": "1336540",
    "end": "1343230"
  },
  {
    "text": "highlighted part in white here is indicating the actual observed instruction length as seen on the processor itself whereas this part on",
    "start": "1343230",
    "end": "1350010"
  },
  {
    "text": "the left here is showing me what capstone thinks the instruction looks like in other words what the documentation says this instruction is",
    "start": "1350010",
    "end": "1356460"
  },
  {
    "text": "if we let this run for a while it will actually start seeing it dumping out a couple of anomalies in the window down",
    "start": "1356460",
    "end": "1363480"
  },
  {
    "text": "here essentially it's looking for places where the documentation and the actual execution differ now tunneling is a",
    "start": "1363480",
    "end": "1370560"
  },
  {
    "text": "really good way to very thoroughly go through every instruction in the x86 instruction in the x86 architecture but",
    "start": "1370560",
    "end": "1378960"
  },
  {
    "text": "tunneling is not the fastest thing in the world so if I really want to fast results I can actually switch this thing",
    "start": "1378960",
    "end": "1385230"
  },
  {
    "text": "over to totally random buzzing by us changing modes here just generating",
    "start": "1385230",
    "end": "1390630"
  },
  {
    "text": "completely arbitrary instructions we won't get as good coverage of the instruction space but we'll get some really quick results so what you see",
    "start": "1390630",
    "end": "1397350"
  },
  {
    "text": "dumping out in the red on the bottom is undocumented instruction secret instructions that are sitting in my CPU",
    "start": "1397350",
    "end": "1403560"
  },
  {
    "text": "right now and I find this really unsettling because we're basing all of our trust off of these documentation for",
    "start": "1403560",
    "end": "1410580"
  },
  {
    "text": "the processor and there are a lot of things in that processor that they're not telling us about now if you let this",
    "start": "1410580",
    "end": "1417240"
  },
  {
    "text": "thing run overnight it'll basically complete the actual tunneling approach complete its total scan and at the end",
    "start": "1417240",
    "end": "1423540"
  },
  {
    "text": "it will dump out everything is found so on most modern x86 processors it'll find a couple million of interesting things",
    "start": "1423540",
    "end": "1429330"
  },
  {
    "text": "now that's a lot to sift through by hand we need some way to quickly make sense of this kind of information so I build",
    "start": "1429330",
    "end": "1437010"
  },
  {
    "text": "what I call the summarizer it will take all the results of sand sifter and try to summarize it in a digestible form so",
    "start": "1437010",
    "end": "1443520"
  },
  {
    "text": "this is a breakdown of the key instructions that I found in a scan of a via nano processor so I can scan through",
    "start": "1443520",
    "end": "1450960"
  },
  {
    "text": "here and basically he different categories of instructions so for example it's telling me honest by a nano",
    "start": "1450960",
    "end": "1456120"
  },
  {
    "text": "processor there was a set of instructions that started with Oh F 1 B that weren't documented it found 64",
    "start": "1456120",
    "end": "1461790"
  },
  {
    "text": "instructions in this category and then I can start drilling down into these the sets of instructions and a little",
    "start": "1461790",
    "end": "1467429"
  },
  {
    "text": "bit more depth so for example here I'm examining one of the undocumented instructions that found OS a 7 C 3 it's",
    "start": "1467429",
    "end": "1475019"
  },
  {
    "text": "telling me that when this instruction ran it generated a trap exception and then it gives this instruction is three",
    "start": "1475019",
    "end": "1480240"
  },
  {
    "text": "different disassemblers none of these it's assemblers recognize what this instruction is which is a very very",
    "start": "1480240",
    "end": "1485370"
  },
  {
    "text": "strong indicator that this instruction is not documented and is not known by anybody even though it's running on our",
    "start": "1485370",
    "end": "1491279"
  },
  {
    "text": "processor so at this point we have a way to systematically scan our processor for",
    "start": "1491279",
    "end": "1497640"
  },
  {
    "start": "1493000",
    "end": "1493000"
  },
  {
    "text": "secrets in bugs and I think that's that's really cool so I stand eight of the test systems that I had in my",
    "start": "1497640",
    "end": "1504210"
  },
  {
    "text": "library and I want to share with you what I found on these systems because I came up with a lot of really interesting",
    "start": "1504210",
    "end": "1509610"
  },
  {
    "text": "results first I found hidden instructions on every single X ad chips x86 chip I scanned I found ubiquitous",
    "start": "1509610",
    "end": "1517889"
  },
  {
    "text": "software bugs in all sorts of different programs I found flaws and enterprise hypervisors and I found some very",
    "start": "1517889",
    "end": "1523799"
  },
  {
    "text": "security critical hardware bugs on x86 processors so let's start with the one I set out to find I set out to find these",
    "start": "1523799",
    "end": "1530340"
  },
  {
    "text": "hidden instructions on x86 chips so I started with scanning an Intel Core i7 processor this processor was",
    "start": "1530340",
    "end": "1536250"
  },
  {
    "start": "1533000",
    "end": "1533000"
  },
  {
    "text": "manufactured around 2012 the first set of instructions I found on the processor aren't terribly interesting of√∂ do f-18",
    "start": "1536250",
    "end": "1543899"
  },
  {
    "text": "Oh F 1a both AE all of these instructions are undocumented for",
    "start": "1543899",
    "end": "1548970"
  },
  {
    "text": "certain combinations of bits inside of that instruction but those combinations of bits still execute on the processor",
    "start": "1548970",
    "end": "1555600"
  },
  {
    "text": "now some of these instructions intel is very recently updated their their manuals to actually include so for",
    "start": "1555600",
    "end": "1562350"
  },
  {
    "text": "example o f1 eight in o f1 a became documented by Intel and their December",
    "start": "1562350",
    "end": "1567450"
  },
  {
    "text": "2016 edition of the reference manuals but I ran this test on a processor manufactured in 2012 these instructions",
    "start": "1567450",
    "end": "1573960"
  },
  {
    "text": "were sitting around in my processor undocumented secret for a very very long time other instructions found on the",
    "start": "1573960",
    "end": "1580289"
  },
  {
    "text": "processor on the other hand vbe 0 d FF 1 c 0 d 0 d to f6 f7 an entire classes of",
    "start": "1580289",
    "end": "1586740"
  },
  {
    "text": "instructions still don't appear anywhere in the reference manuals we have no idea what these instructions actually do so I",
    "start": "1586740",
    "end": "1594299"
  },
  {
    "start": "1594000",
    "end": "1594000"
  },
  {
    "text": "started scanning other systems I scan an AMD geode system these are the undocumented",
    "start": "1594299",
    "end": "1600400"
  },
  {
    "text": "instructions I found on Andy now when I started scanning systems for processors",
    "start": "1600400",
    "end": "1605650"
  },
  {
    "text": "from different manufacturers I noticed some interesting patterns there are a lot of overlaps in the undocumented",
    "start": "1605650",
    "end": "1610960"
  },
  {
    "text": "instructions across different manufacturers which means even though that we don't know what these instructions do because they're not in",
    "start": "1610960",
    "end": "1616900"
  },
  {
    "text": "the documentation the manufacturers are coordinating on what these instructions actually do so for example on an AMD",
    "start": "1616900",
    "end": "1623170"
  },
  {
    "text": "system I found the same vbe gyro DBE one in DF instructions that I found on Intel",
    "start": "1623170",
    "end": "1628390"
  },
  {
    "text": "systems but the really interesting places that came up where the place that didn't overlap where there is some",
    "start": "1628390",
    "end": "1634330"
  },
  {
    "text": "unique instruction only on this version of the architecture so in this AMD chip I found a set of unique instructions at",
    "start": "1634330",
    "end": "1640960"
  },
  {
    "text": "OS OS 40 80 followed by some final bytes now some versions of these instructions",
    "start": "1640960",
    "end": "1646720"
  },
  {
    "text": "for that final byte were documented but the vast majority of them that actually executed on the processor were not",
    "start": "1646720",
    "end": "1652210"
  },
  {
    "text": "documented by AMD I scanned a via system and we found sort of the same things a",
    "start": "1652210",
    "end": "1657520"
  },
  {
    "text": "lot of overlap with other undocumented instructions from other manufacturers but then unique sets of instructions",
    "start": "1657520",
    "end": "1663730"
  },
  {
    "text": "that only appeared on via so specifically the OFA 7 group on via is actually bios proprietary padlock",
    "start": "1663730",
    "end": "1670600"
  },
  {
    "text": "instructions it's a set of cryptographic instructions that only exist on biochips and by a documents the padlock",
    "start": "1670600",
    "end": "1676450"
  },
  {
    "text": "instructions but they don't document ofa 7 c1 through c7 so that is a set of",
    "start": "1676450",
    "end": "1682150"
  },
  {
    "text": "cryptographic instructions on this processor for which there is no documentation we have no idea what they",
    "start": "1682150",
    "end": "1687220"
  },
  {
    "text": "actually do so as far as like trying to figure out what do these things really",
    "start": "1687220",
    "end": "1692680"
  },
  {
    "text": "do some of these have been reverse-engineered if you if you dig around enough online you can actually",
    "start": "1692680",
    "end": "1698650"
  },
  {
    "text": "find people who have stumbled across some of these instructions before looked at how the register values are changing on these instructions and inferred what",
    "start": "1698650",
    "end": "1705100"
  },
  {
    "text": "that instruction behavior is but some of these instructions have absolutely no record at all no record in any of the",
    "start": "1705100",
    "end": "1710710"
  },
  {
    "text": "reference manuals from the manufacturer and no other record anywhere else online so there's no way to tell what these",
    "start": "1710710",
    "end": "1716260"
  },
  {
    "text": "things really do and I find that pretty unsettling in terms of trusting our processors right so let's let's look at",
    "start": "1716260",
    "end": "1725050"
  },
  {
    "text": "a totally different thing I didn't set out to find software bugs but I ended up finding a lot of really interesting ones so there is an issue I",
    "start": "1725050",
    "end": "1732470"
  },
  {
    "text": "faced my sand sifter is forced to use a disassembler as a ground truth and I",
    "start": "1732470",
    "end": "1737630"
  },
  {
    "text": "tried a lot of different disassemblers as brown truths and all of them were absolutely littered with bugs so for the",
    "start": "1737630",
    "end": "1743870"
  },
  {
    "text": "most part the bugs and disassemblers only appeared in a couple of the disassemblers that i tried so it wasn't",
    "start": "1743870",
    "end": "1749990"
  },
  {
    "text": "especially interesting when only one disassembler has its own class of bugs we should fix those bugs but that's not",
    "start": "1749990",
    "end": "1755360"
  },
  {
    "text": "like a security critical thing but we did find some interesting bugs we found some bugs that appeared in literally",
    "start": "1755360",
    "end": "1761000"
  },
  {
    "text": "every tool that we threw this thing against and you can actually use these bugs to your advantage if you're an",
    "start": "1761000",
    "end": "1766700"
  },
  {
    "text": "attacker so two of the more interesting ones I found where the jump and call instruction so in the 64-bit version of",
    "start": "1766700",
    "end": "1773840"
  },
  {
    "text": "the x86 architecture theoretically ye9 is a jump instruction v8 is a call instruction and 66 is what's called a",
    "start": "1773840",
    "end": "1780830"
  },
  {
    "text": "data size override prefix and what 66 is supposed to do which is supposed to",
    "start": "1780830",
    "end": "1786020"
  },
  {
    "text": "change the default operand size of that instruction so normally 9 and EI take a",
    "start": "1786020",
    "end": "1791390"
  },
  {
    "text": "32-bit operand so 66 is supposed to change that either to a 16-bit operand or to a 64-bit operand turns out on x86",
    "start": "1791390",
    "end": "1798890"
  },
  {
    "text": "it does neither or on Intel processors it does neither 66 is just ignored by the processor but nobody expected that",
    "start": "1798890",
    "end": "1805910"
  },
  {
    "text": "everyone parses the instructions wrong so what does that mean well all these",
    "start": "1805910",
    "end": "1811910"
  },
  {
    "text": "tools have this exact same bug in them I tried this with Ida valgrind gdb object on visual studio capstone qmu and about",
    "start": "1811910",
    "end": "1818960"
  },
  {
    "text": "a dozen others and they all had this bug so let's look at this instruction in Ida for example you'll see that Ida is",
    "start": "1818960",
    "end": "1825830"
  },
  {
    "start": "1821000",
    "end": "1821000"
  },
  {
    "text": "parsing this as a four byte instruction because it thinks that this 66 / ID prefix changes this to a 16-bit operand",
    "start": "1825830",
    "end": "1832730"
  },
  {
    "text": "that's not the correct behavior this instruction is not being parsed correctly by Ida our reverse engineering",
    "start": "1832730",
    "end": "1837860"
  },
  {
    "text": "tool let's look at it in Visual Studio Visual Studio has a different version of the same bug you'll see that it actually",
    "start": "1837860",
    "end": "1843350"
  },
  {
    "text": "does recognize even with the 66 over I prefix this is a 32-bit operand but he thinks the 60-66 override prefix causes",
    "start": "1843350",
    "end": "1852590"
  },
  {
    "text": "the jump target to be truncated to 16 bits that's also not the correct behavior Visual Studio is not correctly",
    "start": "1852590",
    "end": "1858800"
  },
  {
    "text": "resolving the target of this jump instruction an attacker can actually use this too that's malicious behavior in software",
    "start": "1858800",
    "end": "1865610"
  },
  {
    "text": "you can basically use this to throw off the disassembly so that our analysis tools don't see malicious instructions",
    "start": "1865610",
    "end": "1871490"
  },
  {
    "start": "1871000",
    "end": "1871000"
  },
  {
    "text": "as an example of that this is looking at the 66 jump instruction and observe so",
    "start": "1871490",
    "end": "1876950"
  },
  {
    "text": "what I have here is that 66 jump and obstinate is miss parsing that instruction it thinks it's a four byte",
    "start": "1876950",
    "end": "1882110"
  },
  {
    "text": "instruction when it's really a six byte instruction what that means is that obstinate is also miss parsed all the",
    "start": "1882110",
    "end": "1887360"
  },
  {
    "text": "subsequent instructions since it's now off by two bytes so even though ox jump and gdb in the situation will see a jump",
    "start": "1887360",
    "end": "1893780"
  },
  {
    "text": "instruction followed by an ADD followed by an ADD followed by a move ABS that's not the real instructions that are there",
    "start": "1893780",
    "end": "1900020"
  },
  {
    "text": "what's really going to happen here is this is going to be a 32-bit operand that's going to jump into the middle of",
    "start": "1900020",
    "end": "1905179"
  },
  {
    "text": "one of these move ABS instructions and execute a malicious instruction embedded in this immediate value sort of a",
    "start": "1905179",
    "end": "1912280"
  },
  {
    "text": "highlight the implications of this in terms of our analysis tools I wrote a little malicious program that's going to",
    "start": "1912280",
    "end": "1919159"
  },
  {
    "text": "operate differently inside of qmu versus running on a bare metal processor so",
    "start": "1919159",
    "end": "1924799"
  },
  {
    "text": "what I'm going to do is I'm going to SSH into my Q mu VM and I'm going to run this program this program is very very",
    "start": "1924799",
    "end": "1930770"
  },
  {
    "text": "simple but it starts out with one of these 66 jump instructions q mu miss emulates that instruction and it thinks",
    "start": "1930770",
    "end": "1937190"
  },
  {
    "text": "that this program is totally benign because that's the execution that Q mu sees but now when I exit out of my VM",
    "start": "1937190",
    "end": "1943309"
  },
  {
    "text": "and I run this exact same thing on bare metal that instruction executes differently we now get malicious",
    "start": "1943309",
    "end": "1949400"
  },
  {
    "text": "behavior from our program and I think the neat thing about this is there is no Q mu detection logic inside of this",
    "start": "1949400",
    "end": "1955549"
  },
  {
    "text": "program it just started out with that one malformed jump instruction that caused everything else in the emulation",
    "start": "1955549",
    "end": "1961880"
  },
  {
    "text": "to go haywire so so this is an interesting bug and I was curious about why does everybody screw this",
    "start": "1961880",
    "end": "1967700"
  },
  {
    "text": "instruction up and I think the answer is AMD processors actually obey that instruction that 66 override change of",
    "start": "1967700",
    "end": "1975470"
  },
  {
    "text": "the operand size to 16 bits on an AMD processor where Intel processors are actually ignoring that that prefix so",
    "start": "1975470",
    "end": "1983690"
  },
  {
    "text": "it's a really interesting difference in the architecture and whenever we can't agree on a standard for our architecture",
    "start": "1983690",
    "end": "1989030"
  },
  {
    "text": "bad things start to happen so last major time to happen when Intel deviated from AMD specifications they",
    "start": "1989030",
    "end": "1995150"
  },
  {
    "text": "result in what was called the sister bug it caused a kernel privilege escalation vulnerability and nearly",
    "start": "1995150",
    "end": "2000970"
  },
  {
    "text": "every major operating system because of a very small change between the way these two processors operated so you",
    "start": "2000970",
    "end": "2007570"
  },
  {
    "text": "think well why don't we just update all of our tools to support the correct or the more common Intel behavior since Intel is 95 percent of the market share",
    "start": "2007570",
    "end": "2014110"
  },
  {
    "text": "let's just go with what Intel does well the problem is either Intel or AMD are going to be vulnerable because of this",
    "start": "2014110",
    "end": "2020830"
  },
  {
    "text": "difference there's no winning here and I think it really just shows how impractically complex this architecture",
    "start": "2020830",
    "end": "2027640"
  },
  {
    "text": "is when tools can't just process or parse simple jump instructions correctly suppose some of the interesting software",
    "start": "2027640",
    "end": "2034419"
  },
  {
    "text": "about there are a lot more net that I don't have time to cover I also found some really cool hypervisor bugs so when",
    "start": "2034419",
    "end": "2040149"
  },
  {
    "text": "I was in the early stages of this research and trying to find interesting things in the instruction set I got",
    "start": "2040149",
    "end": "2045159"
  },
  {
    "text": "tired of waiting a day for these instruction scans to complete so I added multi-core support to the scanner and I",
    "start": "2045159",
    "end": "2051010"
  },
  {
    "text": "thought well wouldn't it be neat if I could just have 20 course turning away on the instruction set at once then I could scan in an hour what used to take",
    "start": "2051010",
    "end": "2057820"
  },
  {
    "text": "me a day so I rented in Azure instance with 24 so I could run these instruction searches but really quickly I found out",
    "start": "2057820",
    "end": "2064419"
  },
  {
    "text": "that these scans weren't working inside a badger so basically azure had this really",
    "start": "2064419",
    "end": "2069520"
  },
  {
    "start": "2068000",
    "end": "2068000"
  },
  {
    "text": "interesting bug where the trap flag is missed when you execute a CPUID instruction so if you have a CPUID",
    "start": "2069520",
    "end": "2076179"
  },
  {
    "text": "instruction and you execute it with the trap flag set what's supposed to happen is the cpu ID caused the vm exit the vm",
    "start": "2076179",
    "end": "2083800"
  },
  {
    "text": "is then responsible for emulating that CPUID instruction and the last thing it",
    "start": "2083800",
    "end": "2089290"
  },
  {
    "text": "to do last thing the hypervisor should do is check is the trap flag set and if it is it should inject the trap",
    "start": "2089290",
    "end": "2094540"
  },
  {
    "text": "exception into the into the guest now as you're forgetting that last step of checking that trap like in injecting",
    "start": "2094540",
    "end": "2101470"
  },
  {
    "text": "that exception so sort of as a demo of this of this bug in Azure I've got a",
    "start": "2101470",
    "end": "2106660"
  },
  {
    "text": "little test program here and when I run this thing on bare metal here's what it's going to do it's going to execute a",
    "start": "2106660",
    "end": "2113770"
  },
  {
    "text": "series of instructions going to execute a CPU ID followed by not followed by an up and the trap flag is going to be set",
    "start": "2113770",
    "end": "2119230"
  },
  {
    "text": "during that cpuid executions now what we expect to happen is we expect to get a trap on that first knob instruction and",
    "start": "2119230",
    "end": "2125260"
  },
  {
    "text": "what we really get is a trap on that first not the construction but if I ask the station to my as your instance and run that exact same",
    "start": "2125260",
    "end": "2133110"
  },
  {
    "text": "program we're now going to get entirely different results we executed cpuid knob knob and we",
    "start": "2133110",
    "end": "2139410"
  },
  {
    "text": "expected a trap on that first map what we got was a trap on the second knob the hypervisor forgot to emulate the trap",
    "start": "2139410",
    "end": "2146160"
  },
  {
    "text": "exception now this is not a security critical bug this is a very very minor thing but it's always a little",
    "start": "2146160",
    "end": "2152280"
  },
  {
    "text": "unsettling when the hypervisor is not properly emulating some of the very basic functionality of the underlying",
    "start": "2152280",
    "end": "2158100"
  },
  {
    "text": "architecture so that takes us the hardware bugs I think the most entries interesting results of this little",
    "start": "2158100",
    "end": "2165090"
  },
  {
    "text": "research effort hardware bugs are troubling because if you have a hardware bug it basically means you have that",
    "start": "2165090",
    "end": "2170970"
  },
  {
    "text": "exact same bug in all of your software and hardware bugs are very difficult to find they are very difficult to fix",
    "start": "2170970",
    "end": "2177570"
  },
  {
    "text": "so hardware bugs even when they're small are never a good thing so I started out scanning several Intel",
    "start": "2177570",
    "end": "2183810"
  },
  {
    "start": "2179000",
    "end": "2179000"
  },
  {
    "text": "processors and unfortunately I didn't find anything terribly interesting here I found the foof bug on a Pentium",
    "start": "2183810",
    "end": "2190500"
  },
  {
    "text": "processor so foof was a lock cop exchange instruction that would lock up a Pentium processor this is a well known",
    "start": "2190500",
    "end": "2196530"
  },
  {
    "text": "bug from very old processors so this was a little anticlimactic but it did show",
    "start": "2196530",
    "end": "2202620"
  },
  {
    "text": "that this technique is able to find these malformed instructions that cause bad things to happen so it was good",
    "start": "2202620",
    "end": "2208560"
  },
  {
    "text": "validation so the next thing I scan were some AMD processors I noticed an interesting thing on AMD namely on",
    "start": "2208560",
    "end": "2214890"
  },
  {
    "start": "2209000",
    "end": "2209000"
  },
  {
    "text": "several of these processors they can generate an undefined opcode exception prior to completing the instruction",
    "start": "2214890",
    "end": "2220710"
  },
  {
    "text": "fetch so I don't mean to aim these reference manuals and found that this is not the correct behavior for this",
    "start": "2220710",
    "end": "2226650"
  },
  {
    "text": "processor a page fault exception during the instruction fetch should take priority over an undefined opcode",
    "start": "2226650",
    "end": "2233760"
  },
  {
    "text": "exception so in our instruction search where we have the last few bytes of an instruction sitting on a non executable",
    "start": "2233760",
    "end": "2240360"
  },
  {
    "text": "page we should be getting a page fault exception not undefined opcode exception so that's not the correct behavior it's",
    "start": "2240360",
    "end": "2247020"
  },
  {
    "text": "a minor thing but that is a processor errata until when I was making this presentation I looked at newest version",
    "start": "2247020",
    "end": "2252510"
  },
  {
    "text": "of the AMD documentation and in March 2017 just a couple months ago somebody",
    "start": "2252510",
    "end": "2257550"
  },
  {
    "text": "at AMD must have stumbled across this and they added this little footnote to processor interrupt exception priority",
    "start": "2257550",
    "end": "2263799"
  },
  {
    "text": "tables that basically allows for this situation now I think this was a little bit of a cop-out if your processor has",
    "start": "2263799",
    "end": "2269710"
  },
  {
    "text": "an errata in it and then you update the documentation to allow that errata is it",
    "start": "2269710",
    "end": "2274809"
  },
  {
    "text": "still an errata I think it is but I'm apparently this is allowed in the newest version of the AMD manuals I scanned a",
    "start": "2274809",
    "end": "2281440"
  },
  {
    "start": "2279000",
    "end": "2279000"
  },
  {
    "text": "transmeta processor transmeta is not especially popular anymore but they were kind of interesting a couple of years",
    "start": "2281440",
    "end": "2288400"
  },
  {
    "text": "back I found some interesting result from the transmeta where this series of instructions OS 71 72 or 73 could",
    "start": "2288400",
    "end": "2296259"
  },
  {
    "text": "generate a floating-point exception during the instruction such days so if you had a floating-point exception pending and you try to execute one of",
    "start": "2296259",
    "end": "2302259"
  },
  {
    "text": "these instructions you would get a floating-point exception before the instruction was completely fetched",
    "start": "2302259",
    "end": "2307630"
  },
  {
    "text": "that's also not the correct behavior the correct behavior here is to get a page full of instruction during the instruction fetch so again very very",
    "start": "2307630",
    "end": "2315039"
  },
  {
    "text": "minor errata that you would never see in any normal situation but it's all bling",
    "start": "2315039",
    "end": "2320529"
  },
  {
    "text": "when when there's a bug and hardware so that brings me to the last hardware bug",
    "start": "2320529",
    "end": "2326079"
  },
  {
    "text": "that I found in this research and this is I think the most interesting one so I found this on one processor essentially",
    "start": "2326079",
    "end": "2333430"
  },
  {
    "text": "a halt and catch fire instruction what I mean by that is it is a single malformed",
    "start": "2333430",
    "end": "2338829"
  },
  {
    "text": "instruction and if we run this inside of ring three the least privileged ring on the processor it will lock the processor",
    "start": "2338829",
    "end": "2345279"
  },
  {
    "text": "entirely I want to be really really sure that this was in a kernel bug that I was",
    "start": "2345279",
    "end": "2350349"
  },
  {
    "text": "seeing so I tried this on three different Linux kernels two different Windows kernels and always got the same results a complete processor lock when",
    "start": "2350349",
    "end": "2357579"
  },
  {
    "text": "we execute this one bad instruction to be really sure that it wasn't a kernel bug I developed the loadable kernel",
    "start": "2357579",
    "end": "2363279"
  },
  {
    "text": "module in Linux that would hook the interrupt scripture cable hook all the exceptions that can possibly occur on",
    "start": "2363279",
    "end": "2369700"
  },
  {
    "text": "the processor and dump exception information to serial whenever an interrupt on the processor occurred I was a little bit worried that maybe is",
    "start": "2369700",
    "end": "2375969"
  },
  {
    "text": "just an inner elf storm that was making it look like the processor was locked based on this debugging it sort of",
    "start": "2375969",
    "end": "2381039"
  },
  {
    "text": "validated that this is in fact the total processor lock on an unprivileged malformed bring through exception now",
    "start": "2381039",
    "end": "2388150"
  },
  {
    "text": "unfortunately I found this two weeks before this presentation which means the vendor has not had time to respond to",
    "start": "2388150",
    "end": "2393219"
  },
  {
    "text": "this issue on I'm not going to shoot them in the foot here there's really no details available on what chips or vendors or actual",
    "start": "2393219",
    "end": "2399970"
  },
  {
    "text": "instruction cause this issue right now but I do want to give you a quick demonstration of this ring 3 processor",
    "start": "2399970",
    "end": "2406570"
  },
  {
    "text": "Doss on the system so what I've got here is I've got Debian booted you can see it",
    "start": "2406570",
    "end": "2412030"
  },
  {
    "text": "can run any normal program but if I run my a dot out program it out only contains one instruction it contains",
    "start": "2412030",
    "end": "2418210"
  },
  {
    "text": "this one malformed ring 3 instruction now when I run a dot out the processor",
    "start": "2418210",
    "end": "2423310"
  },
  {
    "text": "entirely locks I don't mean the process locks I mean the processor locks we can",
    "start": "2423310",
    "end": "2428380"
  },
  {
    "text": "try to kill the process with ctrl C it won't respond we can try to change run levels to a get get into some more",
    "start": "2428380",
    "end": "2435190"
  },
  {
    "text": "simple state the system won't respond we can try to use the Linux magic ciserek keys the system won't respond that",
    "start": "2435190",
    "end": "2443200"
  },
  {
    "text": "processor is completely done executing instructions and is hard locked at this",
    "start": "2443200",
    "end": "2448240"
  },
  {
    "text": "point so I think this is a really interesting sign because this is the",
    "start": "2448240",
    "end": "2453280"
  },
  {
    "text": "first such attack sound in 20 years so last time this happened with on the original Pentium processors with that",
    "start": "2453280",
    "end": "2459100"
  },
  {
    "text": "foof instruction that could lock the processor I don't think anything like this has been seen in the 20 years since",
    "start": "2459100",
    "end": "2464410"
  },
  {
    "text": "but I also don't want to make it sound like the sky is falling this was found on one very esoteric processor that is",
    "start": "2464410",
    "end": "2471730"
  },
  {
    "text": "not used in widespread production I think it's mostly interesting from an academic perspective that we have a tool",
    "start": "2471730",
    "end": "2478360"
  },
  {
    "text": "that is able to find these kinds of things now and this should be I think obvious this is a significant security",
    "start": "2478360",
    "end": "2484540"
  },
  {
    "text": "concern right if an unprivileged user can mount a Doss attack against the processor itself a real problem so I'm",
    "start": "2484540",
    "end": "2492370"
  },
  {
    "text": "hoping I can release details for this within the next month or so stay tuned I'll be posting information about this",
    "start": "2492370",
    "end": "2498850"
  },
  {
    "text": "if the responsible disclosure goes ok like I said I wanted this to be a tool that everybody could actually use that",
    "start": "2498850",
    "end": "2504520"
  },
  {
    "start": "2500000",
    "end": "2500000"
  },
  {
    "text": "people could use to check their own systems for problems so I open force this as the sand sifter scanning tool",
    "start": "2504520",
    "end": "2511000"
  },
  {
    "text": "it's on github now github.com slash X or e ax e ax ax slash sand sifter I'm just",
    "start": "2511000",
    "end": "2518110"
  },
  {
    "text": "remembering right now I actually forgot to click the public button before this talk so in about five minutes after the talk this will be available to you so I",
    "start": "2518110",
    "end": "2526180"
  },
  {
    "text": "encourage you to go check this thing out audit your processor figure out what are the secret instructions sitting in your",
    "start": "2526180",
    "end": "2531999"
  },
  {
    "text": "system right now break disassemblers break emulators break hypervisors find",
    "start": "2531999",
    "end": "2538209"
  },
  {
    "text": "these halt and catch fire instructions now you know the system I found that on didn't literally halt and catch fire but",
    "start": "2538209",
    "end": "2543880"
  },
  {
    "text": "who knows maybe yours will I think that would be awesome so hopefully you'll be able to find something interesting if",
    "start": "2543880",
    "end": "2549099"
  },
  {
    "text": "you try this tool out and I really want to emphasize I've only scanned a few of the systems that I have right now and",
    "start": "2549099",
    "end": "2554349"
  },
  {
    "text": "this is just a tiny fraction of what I found on those systems it's just what I could cram into a 45 minute presentation",
    "start": "2554349",
    "end": "2559719"
  },
  {
    "text": "so who knows what exists on your system so I encourage you to check your system",
    "start": "2559719",
    "end": "2565059"
  },
  {
    "text": "if you're not sure about the results that you're seeing feel free to reach out to me I can help you interpret those but the real point here even if you",
    "start": "2565059",
    "end": "2571839"
  },
  {
    "text": "don't use a tool don't blind me trust the specifications anymore you know up until now we've been forced",
    "start": "2571839",
    "end": "2578650"
  },
  {
    "text": "to blindly trust specifications because we had no way to look into what the processor was actually doing and I think",
    "start": "2578650",
    "end": "2584650"
  },
  {
    "text": "now that's what sand sifter gives us it's a primitive first step that allows us to introspect this black box that is",
    "start": "2584650",
    "end": "2591190"
  },
  {
    "text": "at the heart of all of our systems and I think that's a really important first step in terms of establishing trust on",
    "start": "2591190",
    "end": "2596859"
  },
  {
    "text": "these processors so with that sort of wrapping everything up one more time",
    "start": "2596859",
    "end": "2601959"
  },
  {
    "text": "that length is github.com slash x or IX II IX II IX that's the sand sifter",
    "start": "2601959",
    "end": "2607150"
  },
  {
    "text": "project you can also find some other fun things that I've worked on over the last few years for no reason at all I wrote a",
    "start": "2607150",
    "end": "2613269"
  },
  {
    "text": "single instruction C compiler that's on there so if you're curious about how that works you can check it out I've got",
    "start": "2613269",
    "end": "2618549"
  },
  {
    "text": "some fun stuff for manipulating program control flow to mess with people in Ida a couple years ago I released an",
    "start": "2618549",
    "end": "2624910"
  },
  {
    "text": "architectural privileged escalation vulnerability on x86 you can find that code there as well there's lots of other miscellaneous",
    "start": "2624910",
    "end": "2630849"
  },
  {
    "text": "projects I've tinkered with recently so I hope you'll check that out I'd really really like to get feedback and ideas",
    "start": "2630849",
    "end": "2637239"
  },
  {
    "text": "from people on this work so that I can update this and make this more useful for everyone if you've got any of that",
    "start": "2637239",
    "end": "2644440"
  },
  {
    "text": "I'd love to talk to you after my presentation or you can reach out to me on twitter x or e ax c ax e ax i'll be",
    "start": "2644440",
    "end": "2650739"
  },
  {
    "text": "posting more information about that ring 3 daus instruction in the near future or you can reach out to me on email so",
    "start": "2650739",
    "end": "2659019"
  },
  {
    "text": "that's all I've got I'd love to talk with you stage as soon as this is over thank you everyone for attending",
    "start": "2659019",
    "end": "2665090"
  },
  {
    "text": "[Applause]",
    "start": "2665090",
    "end": "2670670"
  }
]