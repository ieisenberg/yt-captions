[
  {
    "start": "0",
    "end": "299000"
  },
  {
    "text": "[Music]",
    "start": "1130",
    "end": "13679"
  },
  {
    "text": "Aloha and welcome to armed and dangerous to talk about analyzing arm 64 mare",
    "start": "13679",
    "end": "19400"
  },
  {
    "text": "targeting Macos my name is Patrick wartle I am the creator of The Objective",
    "start": "19400",
    "end": "25119"
  },
  {
    "text": "C tool suite and Max security website the organizer of the object Ive by the C",
    "start": "25119",
    "end": "30679"
  },
  {
    "text": "Mac OS security conference and also the author of the The Art of Mac maare",
    "start": "30679",
    "end": "35760"
  },
  {
    "text": "analysis book so today we're going to be talking about analyzing M1 malware that is arm",
    "start": "35760",
    "end": "43039"
  },
  {
    "text": "64 malware targeting Mac OS after covering some introductory",
    "start": "43039",
    "end": "48440"
  },
  {
    "text": "topics we're going to talk about finding such mare to analyze now before we can",
    "start": "48440",
    "end": "53719"
  },
  {
    "text": "dive into reverse engineering and disassembling such a m we need to understand arm 64",
    "start": "53719",
    "end": "60519"
  },
  {
    "text": "the the instruction set such malware decompiles and disassembles into finally",
    "start": "60519",
    "end": "66560"
  },
  {
    "text": "we'll apply our now understanding of arm 64 to analyze some M1",
    "start": "66560",
    "end": "72680"
  },
  {
    "text": "hour so first let's cover some introductory topics now this should really be no",
    "start": "72680",
    "end": "79200"
  },
  {
    "text": "surprise to anybody but Mac OS Macs are becoming ever more prevalent ever more",
    "start": "79200",
    "end": "84799"
  },
  {
    "text": "popular and this unfortunately means so to is malware targeting this platform",
    "start": "84799",
    "end": "91119"
  },
  {
    "text": "right as any technology becomes more prevalent more popular malicious code targeting it does as",
    "start": "91119",
    "end": "98040"
  },
  {
    "text": "well now there are various reasons why Mac are becoming ever more popular but one of the main reasons is Apple's new",
    "start": "98040",
    "end": "105240"
  },
  {
    "text": "M1 chip even the CEO of Apple Tim Cook has noted this as really one of the",
    "start": "105240",
    "end": "111719"
  },
  {
    "text": "driving factors and the reason behind Mac os's and Mac's really almost",
    "start": "111719",
    "end": "117960"
  },
  {
    "text": "explosive growth especially in the Enterprise so what is M1 or apple silicon well it's",
    "start": "117960",
    "end": "125960"
  },
  {
    "text": "an armed based system on a chip or sock the system on a chip combines multiple",
    "start": "125960",
    "end": "132120"
  },
  {
    "text": "Technologies on a single chip so for example in the M1 it's got CPU GPU and",
    "start": "132120",
    "end": "138120"
  },
  {
    "text": "various memories as well again all on one chip now in the context of malare",
    "start": "138120",
    "end": "143480"
  },
  {
    "text": "analysis in the context of this presentation today the most important thing to know is that it runs or the CPU",
    "start": "143480",
    "end": "149879"
  },
  {
    "text": "supports An Arm based instruction set specifically arm 64 which means any",
    "start": "149879",
    "end": "155080"
  },
  {
    "text": "malware that's been compiled to run natively on this system is going to",
    "start": "155080",
    "end": "161519"
  },
  {
    "text": "disassemble into these instructions I also briefly want to talk",
    "start": "161519",
    "end": "167599"
  },
  {
    "text": "about Rosetta which is the translation technology that Apple employs so that",
    "start": "167599",
    "end": "172920"
  },
  {
    "text": "Legacy Intel applications can still run even on these M1 Apple silicon systems",
    "start": "172920",
    "end": "179280"
  },
  {
    "text": "now as Apple notes as Apple points out this is really not a substitute for",
    "start": "179280",
    "end": "184760"
  },
  {
    "text": "creating a native version of an application and there's a few reasons for this first and foremost anytime a",
    "start": "184760",
    "end": "192319"
  },
  {
    "text": "legacy application is run and Rosetta kind of jumps in the way and translates it that's going to take some amount of",
    "start": "192319",
    "end": "199080"
  },
  {
    "text": "time so there's definitely a a minor performance hit there's going to be some slow down also Rosetta has had a few",
    "start": "199080",
    "end": "206640"
  },
  {
    "text": "hiccups and there's some translations that it it did maybe still does struggle with that result in uh crashes less than",
    "start": "206640",
    "end": "215519"
  },
  {
    "text": "idea now why are we even talking about M1 Mal well three main reasons first",
    "start": "215519",
    "end": "221239"
  },
  {
    "text": "it's inevitable obviously Mal authors are going to either recompile their existing",
    "start": "221239",
    "end": "228200"
  },
  {
    "text": "malare or as they're creating new malare they're going to compile it so it runs natively on Apple's M1 systems this is",
    "start": "228200",
    "end": "235920"
  },
  {
    "text": "so they don't have to worry about any Rosetta issues and also so that you know they don't have any speed performance or",
    "start": "235920",
    "end": "242799"
  },
  {
    "text": "issues also and this is interesting to me at least uh I took a piece of malare",
    "start": "242799",
    "end": "248040"
  },
  {
    "text": "that had been built compiled for both Intel and arm platforms uh uploaded it to virus total and observed the fact",
    "start": "248040",
    "end": "254879"
  },
  {
    "text": "that even though the maare was logically equivalent 100% the same uh the arm",
    "start": "254879",
    "end": "260320"
  },
  {
    "text": "variant was detected about 10% less than the Intel version which to be shows that",
    "start": "260320",
    "end": "265759"
  },
  {
    "text": "there's some discrepancy in the way that antivirus signatures are detecting such code so that's something to be aware of",
    "start": "265759",
    "end": "271800"
  },
  {
    "text": "something problematic you we should really make sure that our av signatures are architecturally",
    "start": "271800",
    "end": "277840"
  },
  {
    "text": "agnostic finally most important for this presentation is the fact that as I noted",
    "start": "277840",
    "end": "284639"
  },
  {
    "text": "malicious code that has been compiled to natively run on Apple silicon will",
    "start": "284639",
    "end": "289759"
  },
  {
    "text": "disassemble into arm instructions so we must have an understanding of this instruction set in order to",
    "start": "289759",
    "end": "296400"
  },
  {
    "text": "comprehensively understand these threats so now let's talk about uncovering or",
    "start": "296400",
    "end": "302600"
  },
  {
    "start": "299000",
    "end": "466000"
  },
  {
    "text": "hunting for M1 maare in the wild because before we can analyze some specimens",
    "start": "302600",
    "end": "307680"
  },
  {
    "text": "well we got to find some right so the first question is how do we",
    "start": "307680",
    "end": "314120"
  },
  {
    "text": "identify natively compiled M1 code a binary that can run natively on Apple",
    "start": "314120",
    "end": "319160"
  },
  {
    "text": "silicon well in short it's going to be a Mac binary obviously that contains arm",
    "start": "319160",
    "end": "325039"
  },
  {
    "text": "64 or arm 64 e code and we can determine this pretty easily for example we can",
    "start": "325039",
    "end": "330680"
  },
  {
    "text": "use the file utility to show the architectures that a binary supports so",
    "start": "330680",
    "end": "335800"
  },
  {
    "text": "for example when we run it on Apple's calculator application we can see that this is a universal binary containing",
    "start": "335800",
    "end": "341800"
  },
  {
    "text": "code that will run both natively on Intel and arm this is likely what you'll see even in malware because it ensures",
    "start": "341800",
    "end": "348919"
  },
  {
    "text": "that native compatibility is retained on both Intel and arm-based systems now we also want to ensure that",
    "start": "348919",
    "end": "355560"
  },
  {
    "text": "the binary is designed for Mac OS because iOS also supports arm you can",
    "start": "355560",
    "end": "361680"
  },
  {
    "text": "use the O tool command and look for load commands within the binary that specify",
    "start": "361680",
    "end": "366960"
  },
  {
    "text": "the platform it was built for here for example we can see calculator.app was built to run on Mac",
    "start": "366960",
    "end": "374120"
  },
  {
    "text": "OS now to hunt for N1 M1 maare I decided to pop onto virus total and earlier this",
    "start": "374120",
    "end": "382160"
  },
  {
    "text": "year perform a search to see if there was any Mac malware that would natively Target Apple silicon in the wild",
    "start": "382160",
    "end": "390440"
  },
  {
    "text": "so here we can see my search query in short I leveraged virus totals search",
    "start": "390440",
    "end": "395960"
  },
  {
    "text": "tags to tell it to only look for Mac OS Universal binaries that contained 64-bit",
    "start": "395960",
    "end": "403440"
  },
  {
    "text": "code I went one step further and said I only am interested in malware or files",
    "start": "403440",
    "end": "409560"
  },
  {
    "text": "that have been flagged by at least two antivirus products the idea was I simply wanted to find any Mac malware even if",
    "start": "409560",
    "end": "415120"
  },
  {
    "text": "it was existing Intel Intel based malware that had been Rec compiled to",
    "start": "415120",
    "end": "420199"
  },
  {
    "text": "run natively on Apple's new M1 systems this query resulted in a single",
    "start": "420199",
    "end": "426400"
  },
  {
    "text": "candidate file a binary named go search 22 using the file and the oool commands",
    "start": "426400",
    "end": "434240"
  },
  {
    "text": "I could confirm that indeed it was a Mac OS application binary that had arm 64",
    "start": "434240",
    "end": "440680"
  },
  {
    "text": "code in other words it had been compiled to natively run on Apple silicon in",
    "start": "440680",
    "end": "445759"
  },
  {
    "text": "terms of answering the question was it malicious or not as I mentioned a few antivirus products already had flagged",
    "start": "445759",
    "end": "452520"
  },
  {
    "text": "it plus Apple had actually already revoked it certificate continuing analysis confirmed that yes indeed it",
    "start": "452520",
    "end": "458800"
  },
  {
    "text": "was malicious and it turned out to be a new variant of the very prolific Mac malware family",
    "start": "458800",
    "end": "466440"
  },
  {
    "start": "466000",
    "end": "685000"
  },
  {
    "text": "pirate so hooray we've uncovered which what was the first publicly known",
    "start": "466440",
    "end": "472000"
  },
  {
    "text": "instance of Mal natively compiled to run on Apple silicon in the wild now before",
    "start": "472000",
    "end": "478639"
  },
  {
    "text": "we can dive into it to reverse engineer it we need to gain at least a",
    "start": "478639",
    "end": "484280"
  },
  {
    "text": "fundamental understanding of arm 64 this is again the instruction set that such malware will disassemble",
    "start": "484280",
    "end": "492840"
  },
  {
    "text": "into before we dive into instructions and registers and pneumonics and",
    "start": "492840",
    "end": "498680"
  },
  {
    "text": "operand I want to you know call out some really helpful helpful resources uh",
    "start": "498680",
    "end": "504240"
  },
  {
    "text": "first and foremost that really helped me gain an understanding of this instruction set but also o to put them",
    "start": "504240",
    "end": "510599"
  },
  {
    "text": "on a slide in case after this talk you want to dive deeper into arm 64 so take",
    "start": "510599",
    "end": "516200"
  },
  {
    "text": "a look um these are great super helpful awesome book and the ones listed below are available online for",
    "start": "516200",
    "end": "524080"
  },
  {
    "text": "free so first up we have registers uh if you've done any reverse engineering",
    "start": "524080",
    "end": "529160"
  },
  {
    "text": "probably familiar with registers they're basically temporary storage slots on the",
    "start": "529160",
    "end": "534519"
  },
  {
    "text": "CPU that can be referenced via name I like to think of them somewhat as you",
    "start": "534519",
    "end": "539560"
  },
  {
    "text": "know synonymous to variables in a high level programming language now arm 64",
    "start": "539560",
    "end": "545480"
  },
  {
    "text": "supports 31 64bit general purpose registers named x0 through",
    "start": "545480",
    "end": "553360"
  },
  {
    "text": "x30 you can also refer to the lower 32-bit components of these registers",
    "start": "553360",
    "end": "559120"
  },
  {
    "text": "with the w prefix so for example if you want to refer to the lower 32 bits of",
    "start": "559120",
    "end": "564800"
  },
  {
    "text": "the x0 register you do that via w0 and you will see this occasionally in",
    "start": "564800",
    "end": "570880"
  },
  {
    "text": "disassemblies especially when it's referencing 32bit integers for example",
    "start": "570880",
    "end": "576920"
  },
  {
    "text": "now arm also supports several specific purpose registers such as the stack",
    "start": "576920",
    "end": "582519"
  },
  {
    "text": "pointer and the program counter it also has a virtual register the zero register",
    "start": "582519",
    "end": "589800"
  },
  {
    "text": "which its value is always set to zero finally it has an entity called the",
    "start": "589800",
    "end": "595000"
  },
  {
    "text": "processor State this is not a register per se but it does have condition flags",
    "start": "595000",
    "end": "601160"
  },
  {
    "text": "that instructions can indirectly set and that then subsequent instructions can",
    "start": "601160",
    "end": "606920"
  },
  {
    "text": "conditionally check to perform conditional executions uh so in some some sense you can think of it as a",
    "start": "606920",
    "end": "612000"
  },
  {
    "text": "Flags register we'll dive into that more later now in the context of a function",
    "start": "612000",
    "end": "618360"
  },
  {
    "text": "call which is very important when you're analyzing malitia code is to gain an",
    "start": "618360",
    "end": "623560"
  },
  {
    "text": "understanding of how registers are used this is defined in something called an",
    "start": "623560",
    "end": "628920"
  },
  {
    "text": "applic ation binary interface or Ai and for arm 64 on Mac OS these are",
    "start": "628920",
    "end": "635800"
  },
  {
    "text": "the following rules the eight registers the initial eight arguments passed to a",
    "start": "635800",
    "end": "642079"
  },
  {
    "text": "functions to a function will be found in x0 through X7 so the first argument arg0",
    "start": "642079",
    "end": "649160"
  },
  {
    "text": "is going to found be found in x0 second one in AR uh in X1 etc etc in the",
    "start": "649160",
    "end": "655639"
  },
  {
    "text": "context of the function the stack frame pointer will will be found in x29 or the",
    "start": "655639",
    "end": "661639"
  },
  {
    "text": "FP frame pointer register the return address will be stored in the x30",
    "start": "661639",
    "end": "667880"
  },
  {
    "text": "register which is also referred to as the link register or LR finally when the function returns its",
    "start": "667880",
    "end": "676320"
  },
  {
    "text": "return value will be found in the x0 register or if it's a 128bit value it'll",
    "start": "676320",
    "end": "682279"
  },
  {
    "text": "be also found in the X1 register next up we have instructions",
    "start": "682279",
    "end": "688760"
  },
  {
    "start": "685000",
    "end": "986000"
  },
  {
    "text": "instructions instruct the CPU what to do they basically map a specific sequence of",
    "start": "688760",
    "end": "695800"
  },
  {
    "text": "byes to tell the CPU to perform a specific operation instructions start with",
    "start": "695800",
    "end": "702760"
  },
  {
    "text": "something known as a pneumonic and this is a human readable abbreviation that kind of maps to the",
    "start": "702760",
    "end": "710639"
  },
  {
    "text": "operation the instruction performs so for example on the slide we have an add",
    "start": "710639",
    "end": "715959"
  },
  {
    "text": "instruction the pneumonic is ADD and it performs addition easy peasy",
    "start": "715959",
    "end": "723279"
  },
  {
    "text": "right following the pneumonic are operand operand come in three types the",
    "start": "723279",
    "end": "730399"
  },
  {
    "text": "first is a constant or an immediate type this is things like constant numbers",
    "start": "730399",
    "end": "736000"
  },
  {
    "text": "42 the second type are register operand and these are one of the a",
    "start": "736000",
    "end": "741720"
  },
  {
    "text": "aforementioned registers X1 x0 etc etc and finally you can have memory operands",
    "start": "741720",
    "end": "749440"
  },
  {
    "text": "which are register values that point to a memory address you can think of them",
    "start": "749440",
    "end": "754959"
  },
  {
    "text": "as pointers and as we'll see it's the register with brackets around it one other thing to point out is that",
    "start": "754959",
    "end": "763600"
  },
  {
    "text": "instructions the first operand is usually the destination register so on",
    "start": "763600",
    "end": "768639"
  },
  {
    "text": "the slide we have ADD X1 x0 42 what this does is tell the CPU to take the value",
    "start": "768639",
    "end": "775320"
  },
  {
    "text": "of 42 add it to the x0 register and then save or store that in X1 X1 is again the",
    "start": "775320",
    "end": "783560"
  },
  {
    "text": "first operand it is the destination that will have the result of the action in this case the",
    "start": "783560",
    "end": "790519"
  },
  {
    "text": "addition we also need to talk about arms memory access model it is based on",
    "start": "790519",
    "end": "796079"
  },
  {
    "text": "something called load and store what happens is there are Specific",
    "start": "796079",
    "end": "801360"
  },
  {
    "text": "Instructions designed for memory access so for example you have instructions",
    "start": "801360",
    "end": "807199"
  },
  {
    "text": "that are capable of loading data data from memory into registers then the majority of other instructions will",
    "start": "807199",
    "end": "814320"
  },
  {
    "text": "perform all sorts of operations additions bitwise ores etc etc once",
    "start": "814320",
    "end": "820720"
  },
  {
    "text": "those instructions are done operating on the contents of memory which is now been moved into a register it will be saved",
    "start": "820720",
    "end": "828480"
  },
  {
    "text": "to memory via the store command let's look at this a little",
    "start": "828480",
    "end": "835480"
  },
  {
    "text": "closer so the way that data is loaded for memory into the register on R 64 is",
    "start": "837199",
    "end": "842600"
  },
  {
    "text": "via the ldr instruction or one of its variants as the animation showed it's",
    "start": "842600",
    "end": "848240"
  },
  {
    "text": "going to grab something from memory and move it into a register if we look at the instruction on the slide we see ldr",
    "start": "848240",
    "end": "855720"
  },
  {
    "text": "load X1 and then x0 again x0 has brackets around it which delineate as a",
    "start": "855720",
    "end": "863639"
  },
  {
    "text": "pointer to memory so what the CPU does is it will dreference the value in x",
    "start": "863639",
    "end": "869160"
  },
  {
    "text": "zero and load it into the X1 register again X1 being the first operand the",
    "start": "869160",
    "end": "874320"
  },
  {
    "text": "destination register I've also added the analogous C statement to the slide to kind of help",
    "start": "874320",
    "end": "881440"
  },
  {
    "text": "with some understanding as well all right so now let's talk about the store instruction or St",
    "start": "881440",
    "end": "888800"
  },
  {
    "text": "Str the store instruction as the animation shows stores something from a register into a specified memory address",
    "start": "888800",
    "end": "896160"
  },
  {
    "text": "it's important though to understand that unlike the majority of other instructions the first operand is",
    "start": "896160",
    "end": "902880"
  },
  {
    "text": "actually the source register so on the slide we have s strr store X1 and then",
    "start": "902880",
    "end": "908839"
  },
  {
    "text": "x0 in Brackets the CPU will take the value in X1 and store it at the memory",
    "start": "908839",
    "end": "916360"
  },
  {
    "text": "address specified in x0 again analogous C instruction might",
    "start": "916360",
    "end": "923040"
  },
  {
    "text": "be a little more illustrative as well we also need to talk about",
    "start": "923040",
    "end": "929279"
  },
  {
    "text": "conditions a lot of times malware will perform some action query its environment and then based on that query",
    "start": "929279",
    "end": "937240"
  },
  {
    "text": "or that observation perform some conditional action which may impact our",
    "start": "937240",
    "end": "942279"
  },
  {
    "text": "analysis there therefore it's it's important to understand how conditions and conditional executions occur in arm",
    "start": "942279",
    "end": "949720"
  },
  {
    "text": "64 so we have the compare instruction CMP which as its name implies performs a",
    "start": "949720",
    "end": "956600"
  },
  {
    "text": "comparison between two operands specifically though it subtracts the two",
    "start": "956600",
    "end": "962199"
  },
  {
    "text": "operands discards the subtraction result but then updates the flags in the pstate",
    "start": "962199",
    "end": "969120"
  },
  {
    "text": "OR processor State entity so we have the instruction CMP x0",
    "start": "969120",
    "end": "974959"
  },
  {
    "text": "42 if x0 equals 42 the subtraction of 42 - 42 will equal 0 which means the Z flag",
    "start": "974959",
    "end": "983319"
  },
  {
    "text": "will be set in the processor State now once the condition flag have",
    "start": "983319",
    "end": "989240"
  },
  {
    "start": "986000",
    "end": "1435000"
  },
  {
    "text": "been set for example by the compare instruction subsequent instructions will",
    "start": "989240",
    "end": "994360"
  },
  {
    "text": "act on these flags via condition codes uh and these condition codes are things",
    "start": "994360",
    "end": "1000160"
  },
  {
    "text": "like equal not equal less than greater than things that you would expect so here we have an example uh",
    "start": "1000160",
    "end": "1007480"
  },
  {
    "text": "this is code from an M1 Mal sample and it is invoking a function to check if it",
    "start": "1007480",
    "end": "1013839"
  },
  {
    "text": "is running in a de booger as we'll see this is kind of a standard anti-analysis check",
    "start": "1013839",
    "end": "1019560"
  },
  {
    "text": "what the disassemble instructions do once the function returns is check the",
    "start": "1019560",
    "end": "1024678"
  },
  {
    "text": "return value again the return value is going to be an x0 or w0 so we see a compare instruction checking to see if",
    "start": "1024679",
    "end": "1032079"
  },
  {
    "text": "this value was one this will set the zero flag if and only if the function",
    "start": "1032079",
    "end": "1038120"
  },
  {
    "text": "returned one or true below that we see a b. NE instruction that is a branch not",
    "start": "1038120",
    "end": "1045760"
  },
  {
    "text": "equal we'll talk about branches on the next slide but for now think of it almost as a conditional jump instruction",
    "start": "1045760",
    "end": "1052360"
  },
  {
    "text": "what this will do is it will take the jump if and only if the comparison was",
    "start": "1052360",
    "end": "1058799"
  },
  {
    "text": "not true right that's what the ne in the branch instruction uh means so if we",
    "start": "1058799",
    "end": "1064520"
  },
  {
    "text": "look at this disassembly snippet again we can see that if the malware is not",
    "start": "1064520",
    "end": "1069640"
  },
  {
    "text": "being debugged it will continue operation as expected but if the Mi being debug bugged function returns a",
    "start": "1069640",
    "end": "1076559"
  },
  {
    "text": "one or true the conditional branch will not be taken and if we look below we can",
    "start": "1076559",
    "end": "1082440"
  },
  {
    "text": "see the malware will then execute an instruction which causes it to prematurely",
    "start": "1082440",
    "end": "1089158"
  },
  {
    "text": "exit let's look a little closer at branches which alter control flow of a",
    "start": "1089320",
    "end": "1094840"
  },
  {
    "text": "program there's three types the first is an unconditional branch and this will jump to a specified uh memory address or",
    "start": "1094840",
    "end": "1103400"
  },
  {
    "text": "value in a register unconditionally you can think about this similar to a jump in a you know the Intel instruction",
    "start": "1103400",
    "end": "1110000"
  },
  {
    "text": "set the second type is the conditional uh Branch we saw that on the previous",
    "start": "1110000",
    "end": "1115840"
  },
  {
    "text": "slide and this will jump this will Branch if and only if the condition is fulfilled if not it's essentially a no",
    "start": "1115840",
    "end": "1122720"
  },
  {
    "text": "op the branch will not be taken finally we have the BL or blr instruction which",
    "start": "1122720",
    "end": "1128919"
  },
  {
    "text": "stands for branch and Link and this is how calls are performed in arm 64",
    "start": "1128919",
    "end": "1135000"
  },
  {
    "text": "instructions so what this will do behind the scenes is first store the address of",
    "start": "1135000",
    "end": "1140360"
  },
  {
    "text": "the next instruction in the x30 or the link register it'll then jump to the",
    "start": "1140360",
    "end": "1146280"
  },
  {
    "text": "specified address which is going to be a function execute the function and then when a return instruction is executed",
    "start": "1146280",
    "end": "1154760"
  },
  {
    "text": "behind the scenes the return instruction will read the value that has been stored in the link register and jump back to it",
    "start": "1154760",
    "end": "1162320"
  },
  {
    "text": "returning control flow back to the caller so now we have you know a basic",
    "start": "1162320",
    "end": "1168480"
  },
  {
    "text": "under understanding of arm 64 instructions let's now walk through reverse engineering fully a compiled M1",
    "start": "1168480",
    "end": "1176960"
  },
  {
    "text": "binary using the quintessential hello",
    "start": "1176960",
    "end": "1181600"
  },
  {
    "text": "world on the top of the slide we have The Objective C source code this is what",
    "start": "1183320",
    "end": "1188720"
  },
  {
    "text": "gets compiled into the M1 binary on the other side we have the arm 64",
    "start": "1188720",
    "end": "1194280"
  },
  {
    "text": "disassembly now before we dive into the disassembly one point the autoease Block",
    "start": "1194280",
    "end": "1200840"
  },
  {
    "text": "in The Objective C source code is going to get compiled into a pool push and",
    "start": "1200840",
    "end": "1206480"
  },
  {
    "text": "pool pop function call we'll see this in the disassembly so just be aware of that",
    "start": "1206480",
    "end": "1212640"
  },
  {
    "text": "fact first up we have what is known as a function prologue function prologs are",
    "start": "1212640",
    "end": "1218400"
  },
  {
    "text": "not specific to arm 64 you probably encountered them when reversing other binaries and their job is basically to",
    "start": "1218400",
    "end": "1224960"
  },
  {
    "text": "adjust the stack pointer to make space for local variables in the function function prologs can also store various",
    "start": "1224960",
    "end": "1232240"
  },
  {
    "text": "registers that need to be maintained across function calls um and then you know you'll often see initialization of",
    "start": "1232240",
    "end": "1237760"
  },
  {
    "text": "local V variables that is exactly what happens here we see via the sub",
    "start": "1237760",
    "end": "1243720"
  },
  {
    "text": "instruction that hex3 is subtracted from the stack pointer via the STP or store",
    "start": "1243720",
    "end": "1250640"
  },
  {
    "text": "pair instruction the CPU will store a pair of registers x29 and x30 onto the",
    "start": "1250640",
    "end": "1257360"
  },
  {
    "text": "stack then adjust adjusts the frame pointer and saves some other registers and initializes some other local",
    "start": "1257360",
    "end": "1264640"
  },
  {
    "text": "variables we then encounter the first call to a function uh and this is a branch to the pool push API",
    "start": "1264640",
    "end": "1272919"
  },
  {
    "text": "function as we mentioned it's going to use the BL or the branch link instruction which remember will first",
    "start": "1272919",
    "end": "1279640"
  },
  {
    "text": "store the address of the next instruction in the link register so that when the function is done it can return",
    "start": "1279640",
    "end": "1285240"
  },
  {
    "text": "back and control flow can continue now this function doesn't take any parameters so there's no registers that",
    "start": "1285240",
    "end": "1291360"
  },
  {
    "text": "have to be initialized with arguments but I do want to point out that this function does return a value",
    "start": "1291360",
    "end": "1297960"
  },
  {
    "text": "specifically a pool object the code wants to save this so we can see in the",
    "start": "1297960",
    "end": "1303360"
  },
  {
    "text": "highlighted instruction it stores the value found in x0 Remembering x0 holds",
    "start": "1303360",
    "end": "1309200"
  },
  {
    "text": "the return value from a function into or onto the stack so now the pool object",
    "start": "1309200",
    "end": "1315600"
  },
  {
    "text": "has been saved then we see a call to the NS log",
    "start": "1315600",
    "end": "1322159"
  },
  {
    "text": "function we start at the bottom we see NS log is invoked with the BL instruction no surprises here however",
    "start": "1322159",
    "end": "1328960"
  },
  {
    "text": "the NS log function takes a single parameter so this argument has to be",
    "start": "1328960",
    "end": "1334480"
  },
  {
    "text": "initialized so if we look back in the disassembly we can see the disassembly Building the address to the hello world",
    "start": "1334480",
    "end": "1341159"
  },
  {
    "text": "string object and then it is moved into the x0 register via the move instruction",
    "start": "1341159",
    "end": "1348080"
  },
  {
    "text": "again recall Rec calling that the first argument is always going to be found in",
    "start": "1348080",
    "end": "1353679"
  },
  {
    "text": "x0 next up we see another function call this time to the pool pop object",
    "start": "1354080",
    "end": "1360840"
  },
  {
    "text": "function rather and this function also takes a parameter which means that x0 is",
    "start": "1360840",
    "end": "1367120"
  },
  {
    "text": "going to have to be reinitialized with the parameter this function expects which is the pool object that was",
    "start": "1367120",
    "end": "1373679"
  },
  {
    "text": "previously returned by the pool push function so the way this register is",
    "start": "1373679",
    "end": "1380480"
  },
  {
    "text": "initialized is via the ldr instruction because recall the pool object was stored on the stack so again arm is this",
    "start": "1380480",
    "end": "1387559"
  },
  {
    "text": "load store architecture so it's previously stored so now the load instruction will load it from the stack",
    "start": "1387559",
    "end": "1392640"
  },
  {
    "text": "into the x0 register once that's been initialized the function call can be",
    "start": "1392640",
    "end": "1397679"
  },
  {
    "text": "made via the BL instruction finally we have the function",
    "start": "1397679",
    "end": "1403000"
  },
  {
    "text": "epilog this restores the two registers that were saved to the stack um it then",
    "start": "1403000",
    "end": "1409240"
  },
  {
    "text": "readjusts the stack and then finally returns to the caller as we mentioned",
    "start": "1409240",
    "end": "1415360"
  },
  {
    "text": "the return instruction will pop or read the address stored in the x30 OR link",
    "start": "1415360",
    "end": "1421159"
  },
  {
    "text": "register and jump back to it uh also should point out that the function epilog also initializes the return value",
    "start": "1421159",
    "end": "1429120"
  },
  {
    "text": "so that when the main function returns its caller can you know examine its",
    "start": "1429120",
    "end": "1435120"
  },
  {
    "start": "1435000",
    "end": "1446000"
  },
  {
    "text": "value Pew that was a a whirlwind kind of tour",
    "start": "1435120",
    "end": "1440360"
  },
  {
    "text": "of the arm 64 instruction set and if you're feeling a bit overwhelmed that is",
    "start": "1440360",
    "end": "1445679"
  },
  {
    "text": "okay why well normally you really don't have to dive that deeply into a binary",
    "start": "1445679",
    "end": "1452039"
  },
  {
    "start": "1446000",
    "end": "1482000"
  },
  {
    "text": "and understand every last arm 64 assembly instruction and that's a good thing because you know who is time for",
    "start": "1452039",
    "end": "1458279"
  },
  {
    "text": "that right and there's two reasons why we don't generally have to care about this as much uh the first is that",
    "start": "1458279",
    "end": "1465200"
  },
  {
    "text": "decompilers do a great job of reconstructing a representation of the",
    "start": "1465200",
    "end": "1471279"
  },
  {
    "text": "almost original source code from a binary on the slide we can see the decompilation of the hello world binary",
    "start": "1471279",
    "end": "1477960"
  },
  {
    "text": "and wow yeah it looks impressively close to the original source code we can also leverage Dynamic analysis tools when",
    "start": "1477960",
    "end": "1484799"
  },
  {
    "start": "1482000",
    "end": "1505000"
  },
  {
    "text": "analyzing malware to uncover persistence capabilities functionalities Often by",
    "start": "1484799",
    "end": "1490760"
  },
  {
    "text": "simply just running the malware and observing what it does passively here's",
    "start": "1490760",
    "end": "1496240"
  },
  {
    "text": "another malicious sample run in conjunction with a file Monitor and we can see we've trivially been able to",
    "start": "1496240",
    "end": "1502799"
  },
  {
    "text": "uncover its persistence mechanism so you might be thinking wait",
    "start": "1502799",
    "end": "1507880"
  },
  {
    "start": "1505000",
    "end": "1570000"
  },
  {
    "text": "Patrick does does this mean I don't have to you know learn any arm 64 I wish we",
    "start": "1507880",
    "end": "1512960"
  },
  {
    "text": "wish right malare authors unfortunately realized how powerful both decompilers",
    "start": "1512960",
    "end": "1519000"
  },
  {
    "text": "and dynamic analysis tools are so they add anti-analysis logic into their",
    "start": "1519000",
    "end": "1525120"
  },
  {
    "text": "malicious Creations to thwart such tools so so as we'll see Mau often queries its",
    "start": "1525120",
    "end": "1530960"
  },
  {
    "text": "environment to say hey am I being debugged or hey am I running in an analysis system or a virtual machine and",
    "start": "1530960",
    "end": "1537159"
  },
  {
    "text": "if so exit so before we can run these Dynamic analysis tools which will answer",
    "start": "1537159",
    "end": "1542760"
  },
  {
    "text": "many of the questions which we seek about the functionality and capability of the malware we often first have to",
    "start": "1542760",
    "end": "1549360"
  },
  {
    "text": "identify the anti-analysis logic by reading the arm 64 instructions found in",
    "start": "1549360",
    "end": "1554840"
  },
  {
    "text": "the disassembly the good news is once we have uh identified these instructions we",
    "start": "1554840",
    "end": "1561600"
  },
  {
    "text": "can trivially bypass them and then fall back to these more complex or powerful",
    "start": "1561600",
    "end": "1566919"
  },
  {
    "text": "let's say uh Dynamic analysis",
    "start": "1566919",
    "end": "1570639"
  },
  {
    "start": "1570000",
    "end": "1606000"
  },
  {
    "text": "tools I also want to point out that ghost search 22 also contains static analysis obfuscations which kind of make",
    "start": "1572960",
    "end": "1580159"
  },
  {
    "text": "decompilation almost useless so there's a few screenshots on the slide of me",
    "start": "1580159",
    "end": "1585640"
  },
  {
    "text": "attempting to decompile go search2 to and we can see you know there's just",
    "start": "1585640",
    "end": "1591240"
  },
  {
    "text": "garbage instructions spous function calls so really the only option for us",
    "start": "1591240",
    "end": "1596480"
  },
  {
    "text": "is to you know roll up our sleeves and really dive into the arm 64 disassembly",
    "start": "1596480",
    "end": "1602240"
  },
  {
    "text": "to uncover the anti-analysis logic so let's do that now uh it's you",
    "start": "1602240",
    "end": "1608960"
  },
  {
    "text": "know I think interesting and also allow us to apply some of the concepts we've just talked",
    "start": "1608960",
    "end": "1615000"
  },
  {
    "text": "about so if you run go search 22 in the bugger which is something you often do when Ma analyzing malware it will",
    "start": "1615000",
    "end": "1622919"
  },
  {
    "text": "prematurely exit which is problematic because obviously you want to have the malware continue executing so that you",
    "start": "1622919",
    "end": "1629840"
  },
  {
    "text": "can continue your analysis so what gives clearly the malware is somehow detecting that a",
    "start": "1629840",
    "end": "1635840"
  },
  {
    "text": "debugger is running and prematurely exiting or terminating so here are five uh arm 64",
    "start": "1635840",
    "end": "1644799"
  },
  {
    "text": "assembly instructions that are responsible for go search 22 use anti-debugging logic and we'll go",
    "start": "1644799",
    "end": "1650960"
  },
  {
    "text": "through each of them so first we see four move instructions and if we look",
    "start": "1650960",
    "end": "1656640"
  },
  {
    "text": "closely we can see it's initializing the x0 through X3 registers immediately below that is a",
    "start": "1656640",
    "end": "1664799"
  },
  {
    "text": "SVC instruction which is a supervisor or system call instruction kind of like an",
    "start": "1664799",
    "end": "1670440"
  },
  {
    "text": "INT 80 on Intel platforms if we read up a little bit",
    "start": "1670440",
    "end": "1676200"
  },
  {
    "text": "more about supervisor call we see that it expects a system function a system",
    "start": "1676200",
    "end": "1681640"
  },
  {
    "text": "call you know uh to execute and then any parameters that that specific system",
    "start": "1681640",
    "end": "1687039"
  },
  {
    "text": "call or supervisor call expects we look back in the disassembly we see that x0",
    "start": "1687039",
    "end": "1693640"
  },
  {
    "text": "which is going to contain the first argument is initialized with the value of hex 1A if we Google that that turns",
    "start": "1693640",
    "end": "1701039"
  },
  {
    "text": "out to be Cy pce or the number representing the P trce system call the",
    "start": "1701039",
    "end": "1706519"
  },
  {
    "text": "second parameter which we can find in X1 is initialized with hex1 f reading up on",
    "start": "1706519",
    "end": "1712799"
  },
  {
    "text": "the P trce system call we see that this is the flag that gets pass to it and one F maps to the PT deny attach flag this",
    "start": "1712799",
    "end": "1721440"
  },
  {
    "text": "flag tells the operating system to terminate the process if it's currently being debugging and also prevent any",
    "start": "1721440",
    "end": "1729120"
  },
  {
    "text": "other future attachments by a debugger so basically this is go search 22's",
    "start": "1729120",
    "end": "1735120"
  },
  {
    "text": "anti-analysis uh logic so now we have identified this logic by",
    "start": "1735120",
    "end": "1741600"
  },
  {
    "start": "1738000",
    "end": "1793000"
  },
  {
    "text": "reading the disassembly and understanding the arm 64 instructions we obviously want to bypass it so that our",
    "start": "1741600",
    "end": "1748120"
  },
  {
    "text": "analysis can continue well the good news is this is pretty easy against uh since",
    "start": "1748120",
    "end": "1753840"
  },
  {
    "text": "again we we've just identified the the logic what we can do is we can simply set a breakpoint on the supervisor call",
    "start": "1753840",
    "end": "1761039"
  },
  {
    "text": "instruction in the debugger and then when that breakpoint is hit right before the supervisor call instruction is",
    "start": "1761039",
    "end": "1768120"
  },
  {
    "text": "executed we simply modify the instruction pointer the PC register to",
    "start": "1768120",
    "end": "1773440"
  },
  {
    "text": "actually point to the next instruction and we can do that via the regge right",
    "start": "1773440",
    "end": "1779919"
  },
  {
    "text": "deug command this has the effect of Simply skipping the supervisor call this",
    "start": "1779919",
    "end": "1785240"
  },
  {
    "text": "will therefore skip the anti-debugging logic and the malware is none the wiser",
    "start": "1785240",
    "end": "1792159"
  },
  {
    "text": "that's awesome unfortunately I continued executing hour",
    "start": "1792159",
    "end": "1798600"
  },
  {
    "text": "and it's still prematurely terminated so I dug into this deeper looking at the disassembly and",
    "start": "1798600",
    "end": "1804640"
  },
  {
    "text": "eventually I found this line of code that executed something that would",
    "start": "1804640",
    "end": "1809960"
  },
  {
    "text": "eventually result in the malware prematurely exiting and fortunately though we can",
    "start": "1809960",
    "end": "1815880"
  },
  {
    "text": "understand what the instructions are doing we can't really get a ton of information they're not that informative",
    "start": "1815880",
    "end": "1822919"
  },
  {
    "text": "meaning we can see that there's a blr or Branch link register instruction that's",
    "start": "1822919",
    "end": "1828440"
  },
  {
    "text": "going to Branch to whatever is in the X8 register but from the disassembly we",
    "start": "1828440",
    "end": "1833519"
  },
  {
    "text": "cannot see what's in the X8 register good news is since we've",
    "start": "1833519",
    "end": "1839159"
  },
  {
    "text": "bypassed the anti-debugging logic we can simply set a breakpoint on this function",
    "start": "1839159",
    "end": "1844480"
  },
  {
    "text": "call and then introspect the values of the registers so that's exactly what we",
    "start": "1844480",
    "end": "1849799"
  },
  {
    "text": "do and we can see when we print out the value of X8 which is where the code is",
    "start": "1849799",
    "end": "1855679"
  },
  {
    "text": "going to jump or Branch to we can see it's the OB C message uh message send",
    "start": "1855679",
    "end": "1863600"
  },
  {
    "text": "function that is the method that any Objective C call is routed through Apple",
    "start": "1863600",
    "end": "1870919"
  },
  {
    "text": "has documented this so we can go read up on it and we can see that its first",
    "start": "1870919",
    "end": "1876159"
  },
  {
    "text": "argument is a pointer to an Objective C object and the second parameter the",
    "start": "1876159",
    "end": "1881360"
  },
  {
    "text": "second argument is going to be the method that is about to be invoked so since we've set a break point on this",
    "start": "1881360",
    "end": "1887679"
  },
  {
    "text": "function function call we can examine the values of both the object and the",
    "start": "1887679",
    "end": "1893840"
  },
  {
    "text": "method and we can see in our in the debugger that it's an NS task object and",
    "start": "1893840",
    "end": "1899200"
  },
  {
    "text": "the method that's about to be executed is the launch method we can read up then on the NS",
    "start": "1899200",
    "end": "1906639"
  },
  {
    "text": "task object and its methods uh we can see it's kind of an Objective C abstraction of an execution context um",
    "start": "1906639",
    "end": "1915120"
  },
  {
    "text": "and the launch method is to you know kick off or execute uh you know a command or a program much",
    "start": "1915120",
    "end": "1920279"
  },
  {
    "text": "like a an exec V call right we also see that the nstask object has various",
    "start": "1920279",
    "end": "1926399"
  },
  {
    "text": "properties specifically a launch path and an arguments property that we can",
    "start": "1926399",
    "end": "1931519"
  },
  {
    "text": "query in the debugger to see what this NS task was initialized with we can see",
    "start": "1931519",
    "end": "1937080"
  },
  {
    "text": "on the slide its launch path has been set to bins which is the shell and we can see",
    "start": "1937080",
    "end": "1945039"
  },
  {
    "text": "that its arguments are going to execute the CSR util command with the status",
    "start": "1945039",
    "end": "1951120"
  },
  {
    "text": "flag this is a built-in Mac OS utility a command that will return the Sip status",
    "start": "1951120",
    "end": "1957279"
  },
  {
    "text": "the system Integrity protection status why is it checking the system Integrity protection status well a lot",
    "start": "1957279",
    "end": "1963679"
  },
  {
    "text": "of times analysts including myself will turn this off when debugging a sample",
    "start": "1963679",
    "end": "1969279"
  },
  {
    "text": "because it's just easier to introspect and a debug a system when system Integrity protection is turned off so",
    "start": "1969279",
    "end": "1976039"
  },
  {
    "text": "the maare is rightfully saying hey if I detect system Integrity protection is",
    "start": "1976039",
    "end": "1981080"
  },
  {
    "text": "off I'm probably running on an analysis machine so I'm going to prematurely exit",
    "start": "1981080",
    "end": "1987200"
  },
  {
    "text": "that's exactly what go search 22 did again we can trivially bypass this",
    "start": "1987200",
    "end": "1993519"
  },
  {
    "text": "now that we have identified this by setting a breakpoint on this call and then when that breakpoint is hit just",
    "start": "1993519",
    "end": "1999760"
  },
  {
    "text": "changing the PC the instruction pointer register to point to the next instruction which has the effect of",
    "start": "1999760",
    "end": "2005799"
  },
  {
    "text": "skipping the call and the end analysis logic is",
    "start": "2005799",
    "end": "2011600"
  },
  {
    "start": "2011000",
    "end": "2046000"
  },
  {
    "text": "bypassed finally the Mal also employs some virtual machine detection this similarly",
    "start": "2011600",
    "end": "2018480"
  },
  {
    "text": "goes through another Obi message send call uh but again we can use the same",
    "start": "2018480",
    "end": "2023760"
  },
  {
    "text": "trick of setting a breakpoint examining what it's going to execute and skipping over that after we understand it we do",
    "start": "2023760",
    "end": "2029799"
  },
  {
    "text": "that here we can see that again it's executing NS task launch this time",
    "start": "2029799",
    "end": "2034919"
  },
  {
    "text": "though it's executing a kind of a large script that's looking for artifacts from various virtualization products if the",
    "start": "2034919",
    "end": "2041399"
  },
  {
    "text": "malware finds any of these it's going to prematurely exit so that wraps up ghost search 22's",
    "start": "2041399",
    "end": "2048480"
  },
  {
    "start": "2046000",
    "end": "2157000"
  },
  {
    "text": "anti-analysis logic since we've identified it all and bypass it all we can now kind of return",
    "start": "2048480",
    "end": "2056398"
  },
  {
    "text": "to our normal malware analysis approaches using Dynamic analysis tools that's",
    "start": "2056399",
    "end": "2062079"
  },
  {
    "text": "awesome so let's wrap up the talk all right we don't have time to kind of to to get into that uh comprehensive",
    "start": "2062079",
    "end": "2068320"
  },
  {
    "text": "analysis but again the point is we really don't need a lot of information about arm 64 at that point because we",
    "start": "2068320",
    "end": "2074919"
  },
  {
    "text": "can leverage now you know dynamic analysis tools because we have identified and bypassed the uh",
    "start": "2074919",
    "end": "2081358"
  },
  {
    "text": "anti-analysis logic so first key takeaway M1 Mau is",
    "start": "2081359",
    "end": "2086720"
  },
  {
    "text": "here to stay this is totally unsurprising obviously maare authors are going to recompile their code or as",
    "start": "2086720",
    "end": "2093960"
  },
  {
    "text": "they're building New Creations compile them to run natively on on Apple",
    "start": "2093960",
    "end": "2099000"
  },
  {
    "text": "silicon we talked a little bit about hunting M1 Mau and interestingly enough",
    "start": "2099000",
    "end": "2104720"
  },
  {
    "text": "if you take that uh search query that I mentioned earlier and go to virus total today you'll see it now detects a myriad",
    "start": "2104720",
    "end": "2111240"
  },
  {
    "text": "of you know more malare there's there's new malare out there that has been compiled to run natively on the M1",
    "start": "2111240",
    "end": "2118200"
  },
  {
    "text": "systems the cor the talk really introduced some key components some foundational components about the arm 64",
    "start": "2118200",
    "end": "2125480"
  },
  {
    "text": "instruction set which is the instruction set this malware disassembles to finally",
    "start": "2125480",
    "end": "2131960"
  },
  {
    "text": "we applied some of that understanding some of that knowledge to uncover go search 22's anti-analysis logic which",
    "start": "2131960",
    "end": "2139240"
  },
  {
    "text": "allowed us to then bypass that anti-analysis logic so that Dynamic analysis of the malware sample could",
    "start": "2139240",
    "end": "2146200"
  },
  {
    "text": "commence and really the main goal today is to present these topics to you to",
    "start": "2146200",
    "end": "2152240"
  },
  {
    "text": "kind of give you the foundations to become a proficient analyst of M1 m",
    "start": "2152240",
    "end": "2159400"
  },
  {
    "start": "2157000",
    "end": "2214000"
  },
  {
    "text": "obviously though this is somewhat the tip of the iceberg I mean an important tip but nonetheless there's you know way",
    "start": "2159400",
    "end": "2166319"
  },
  {
    "text": "more to dig into so here are some resources if you're interested in learning more or kind of taking it to",
    "start": "2166319",
    "end": "2172280"
  },
  {
    "text": "the next level so first uh the modern arm assembly language programming book",
    "start": "2172280",
    "end": "2177800"
  },
  {
    "text": "really good resource if you really want to dig into the eternals of uh arm 64",
    "start": "2177800",
    "end": "2183599"
  },
  {
    "text": "also if you're interested in learning more about Mac Mau in general including you know more anti-analysis stuff more",
    "start": "2183599",
    "end": "2190599"
  },
  {
    "text": "uh Dynamic analysis tools uh I've written a book on the subject it's free online and you can check it out at",
    "start": "2190599",
    "end": "2197599"
  },
  {
    "text": "tm.org finally if you're interested in Mac OS security topics uh we're hosting",
    "start": "2197599",
    "end": "2203960"
  },
  {
    "text": "the fourth iteration of the objective by the Sea Mac OS security conference uh",
    "start": "2203960",
    "end": "2209319"
  },
  {
    "text": "later this year this fall in Sunny Hawaii you should definitely come for end I just want to thank some",
    "start": "2209319",
    "end": "2217960"
  },
  {
    "start": "2214000",
    "end": "2257000"
  },
  {
    "text": "individuals and some organizations first and foremost I want to thank the black hat uh conference the organizers um you",
    "start": "2217960",
    "end": "2226319"
  },
  {
    "text": "know especially this year with everything's going on thank you for for hosting this and allowing me to speak",
    "start": "2226319",
    "end": "2231839"
  },
  {
    "text": "also thank you the attendees for tuning into my talk really appreciate that and",
    "start": "2231839",
    "end": "2238480"
  },
  {
    "text": "finally I also want to thank the amazing companies that support my independent research because without them I wouldn't",
    "start": "2238480",
    "end": "2244680"
  },
  {
    "text": "be here sharing this information with you today so again that's a wrap thank you so much",
    "start": "2244680",
    "end": "2250280"
  },
  {
    "text": "for attending my talk and hope to see you all at objective by the sea in Sunny",
    "start": "2250280",
    "end": "2255359"
  },
  {
    "text": "Maui ala",
    "start": "2255359",
    "end": "2259119"
  }
]