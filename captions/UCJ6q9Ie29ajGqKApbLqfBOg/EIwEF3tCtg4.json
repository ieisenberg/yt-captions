[
  {
    "text": "[Music]",
    "start": "1180",
    "end": "14720"
  },
  {
    "text": "hello everyone i'm very happy to be with you virtually today my name is rishi",
    "start": "16560",
    "end": "22240"
  },
  {
    "text": "chen a phd student from pennsylvania state university you can call me lewis",
    "start": "22240",
    "end": "28720"
  },
  {
    "text": "in this talk i'd like to share with you some outcomes of my recent research work",
    "start": "28720",
    "end": "33920"
  },
  {
    "text": "with my lab mate temple and my advisor xinhu this talk is about an exploitation",
    "start": "33920",
    "end": "40160"
  },
  {
    "text": "approach which can bypass many protections in os kernel many blackhead talks will describe how",
    "start": "40160",
    "end": "47120"
  },
  {
    "text": "to find new vulnerabilities for new exploitation tricks however in this presentation i'm going",
    "start": "47120",
    "end": "53840"
  },
  {
    "text": "to review an exploitation approach that has existed for almost a decade we",
    "start": "53840",
    "end": "59600"
  },
  {
    "text": "demonstrate that this attack is not only severe but also general",
    "start": "59600",
    "end": "64640"
  },
  {
    "text": "thus we propose our mitigation design to deal with this attack this presentation is organized as",
    "start": "64640",
    "end": "71680"
  },
  {
    "text": "follows first i will introduce several kernel protections that are going to bypass as",
    "start": "71680",
    "end": "77759"
  },
  {
    "text": "well as some conservative data we want to leak second i will describe the exploitation",
    "start": "77759",
    "end": "84000"
  },
  {
    "text": "approach using two examples one for linux kernel and another is for",
    "start": "84000",
    "end": "89119"
  },
  {
    "text": "windows kernel followed by this i will show how we track diagnostic objects in the kernel",
    "start": "89119",
    "end": "95200"
  },
  {
    "text": "codebase elastic objects is the key in this attack i will display the severity of",
    "start": "95200",
    "end": "102320"
  },
  {
    "text": "this exploitation approach and the reason why we need to study the generality of this attack",
    "start": "102320",
    "end": "109280"
  },
  {
    "text": "after this i will describe the way we use to study the generality and the outcome of the study",
    "start": "109280",
    "end": "115840"
  },
  {
    "text": "finally i will go through several kernel mitigations that seem to be able to circumvent the attack by the fail in the",
    "start": "115840",
    "end": "122560"
  },
  {
    "text": "real world therefore we propose a mitigation which is simple but effective",
    "start": "122560",
    "end": "128800"
  },
  {
    "text": "this presentation takes about 14 minutes for 30 pages if you have any questions feel",
    "start": "128800",
    "end": "135680"
  },
  {
    "text": "free to ask and also i paste my content and paste my contact at the last page of",
    "start": "135680",
    "end": "142080"
  },
  {
    "text": "the slide in case you don't have chance to ask questions i hope you can enjoy the presentation",
    "start": "142080",
    "end": "148160"
  },
  {
    "text": "and send me your comments so that we can first advance our research",
    "start": "148160",
    "end": "154160"
  },
  {
    "text": "first things first i will describe several kernel protections that i plan to bypass",
    "start": "154560",
    "end": "160319"
  },
  {
    "text": "the first protection is that canary which is pretty standard protection in linux freebsd xnu and windows kernel",
    "start": "160319",
    "end": "168560"
  },
  {
    "text": "the idea is quite simple when having a stack of buffer overflow the anniversary can overwrite the return address in",
    "start": "168560",
    "end": "176560"
  },
  {
    "text": "current stack frame later when the function returns the kernel execution is directed to the malicious address to",
    "start": "176560",
    "end": "184239"
  },
  {
    "text": "protect this override during the prologue the kernel places the stack nary which is several bytes of random",
    "start": "184239",
    "end": "191280"
  },
  {
    "text": "value right below the written address and odbp during the epilogue the current test is",
    "start": "191280",
    "end": "197920"
  },
  {
    "text": "the canary on stack against the distal one to see if any corruptions happened",
    "start": "197920",
    "end": "203599"
  },
  {
    "text": "if stack buffer overflow is triggered the stack canary is tempered thus when the kernel finds a mismatch",
    "start": "203599",
    "end": "210799"
  },
  {
    "text": "between the canary on stack and the start one this means stack corruption has happened and the return address is",
    "start": "210799",
    "end": "218080"
  },
  {
    "text": "no longer trustworthy to bypass this mitigation the diversity",
    "start": "218080",
    "end": "223120"
  },
  {
    "text": "either uses brute force method or rely relies on information leaking",
    "start": "223120",
    "end": "229200"
  },
  {
    "text": "the bluetooth force method is to guess a canary by by bat byte which reduces the",
    "start": "229200",
    "end": "234319"
  },
  {
    "text": "complexity from 6464 over 2 to 8 over 2 on a big o",
    "start": "234319",
    "end": "240720"
  },
  {
    "text": "information leaking is another approach in which the adversary can leak the canary to use a space",
    "start": "240720",
    "end": "246959"
  },
  {
    "text": "in this presentation i will show how we can obtain a leaking primitive from a limited right primitive to expose the",
    "start": "246959",
    "end": "254319"
  },
  {
    "text": "stack canary there are many other protections of the similar goal for example the arm pack",
    "start": "254319",
    "end": "260880"
  },
  {
    "text": "and the k-stack overflow from geosecurity as they rely on specific hardware features or are not adopted by the",
    "start": "260880",
    "end": "267600"
  },
  {
    "text": "mainline kernel we don't elaborate on them in this presentation",
    "start": "267600",
    "end": "273440"
  },
  {
    "text": "the second projection on stack i want to introduce is config initial stack all",
    "start": "273440",
    "end": "278639"
  },
  {
    "text": "and a config gcc plugin stack stack league both mitigations are responsible for",
    "start": "278639",
    "end": "284240"
  },
  {
    "text": "poisoning the kernel stack at the end of system call the kernel is buggy as we all know",
    "start": "284240",
    "end": "290240"
  },
  {
    "text": "one type of the bug is uninitialized stack the adversary can exploit the type of",
    "start": "290240",
    "end": "296400"
  },
  {
    "text": "this type of bug using stack spray when the machine enters the current mode the kernel stack is used to store local",
    "start": "296400",
    "end": "303520"
  },
  {
    "text": "variables some of the local variables can be sensitive for example keys for encrypt for encryption the anniversary can use a",
    "start": "303520",
    "end": "311680"
  },
  {
    "text": "system call to store the incentive data on kernel stack and then he or she can",
    "start": "311680",
    "end": "317120"
  },
  {
    "text": "use another system call to trigger the uninitialized checkbox",
    "start": "317120",
    "end": "322160"
  },
  {
    "text": "as part of the stack is uninitialized the sensitive data is not erased from the stack",
    "start": "322160",
    "end": "328160"
  },
  {
    "text": "later on when part of the stack is copied to user space the incentive data",
    "start": "328160",
    "end": "333280"
  },
  {
    "text": "is leaked last year a stack-based information leaking in a2 mp of bluetooth is",
    "start": "333280",
    "end": "340000"
  },
  {
    "text": "discovered basically practicing practicing this idea to circumvent this leaking there have",
    "start": "340000",
    "end": "346160"
  },
  {
    "text": "been proposed many protections for example randomize the base address of kernel stack so that the two system",
    "start": "346160",
    "end": "353120"
  },
  {
    "text": "calls are not using the same memory region the two protections are mentioned up",
    "start": "353120",
    "end": "358160"
  },
  {
    "text": "here for another approach which is to poison the constant at the end of system call",
    "start": "358160",
    "end": "364319"
  },
  {
    "text": "since a sensitive data is erased the advisory cannot use the uninitialized stack bug in a second",
    "start": "364319",
    "end": "371039"
  },
  {
    "text": "system called leak data the difference between the two mitigations are that the former is",
    "start": "371039",
    "end": "376880"
  },
  {
    "text": "implemented in gcc plugin and the latter is in chrono codebase and also the former poison the whole",
    "start": "376880",
    "end": "383680"
  },
  {
    "text": "stack and the lateral only eraser stack region that has been used in this system call",
    "start": "383680",
    "end": "390080"
  },
  {
    "text": "no matter which mitigations you used both have the limitation that it only",
    "start": "390080",
    "end": "395199"
  },
  {
    "text": "works for multi-system core stack attack because poisoning happens at the end of system",
    "start": "395199",
    "end": "401360"
  },
  {
    "text": "call if adversary can read the data before returning back to user space information",
    "start": "401360",
    "end": "407120"
  },
  {
    "text": "leaking is still doable in the exploitation approach i'm going to describe in this presentation a limit",
    "start": "407120",
    "end": "413759"
  },
  {
    "text": "the right primitive on current heap can be used to leak the data on stack in one system call that you not using in",
    "start": "413759",
    "end": "420960"
  },
  {
    "text": "unusualized stack bug on slab slab allocator one of the",
    "start": "420960",
    "end": "426639"
  },
  {
    "text": "protections is config slab furious hardened this protection introduced includes",
    "start": "426639",
    "end": "432720"
  },
  {
    "text": "three patches and i showed them diagram of one patch on the slide",
    "start": "432720",
    "end": "437759"
  },
  {
    "text": "the three slots in slab allocator are chained using a singly linked list the head of the list is named free list",
    "start": "437759",
    "end": "445280"
  },
  {
    "text": "when a slot is in three status the first eight bytes are used to store the edges",
    "start": "445280",
    "end": "450319"
  },
  {
    "text": "of the next slot in the list this is situation before the patch is applied",
    "start": "450319",
    "end": "456080"
  },
  {
    "text": "after the patch is applied the first 8 bytes of the fluid slot stores xor",
    "start": "456080",
    "end": "461360"
  },
  {
    "text": "result of first the address of nexus slot which is short 363 in the diagram second address of the",
    "start": "461360",
    "end": "469759"
  },
  {
    "text": "free list head and third the random number without the patch the adversary can",
    "start": "469759",
    "end": "476000"
  },
  {
    "text": "forge a fake address using hip buffer overflow and misleads the kernel to return the memory region indicated by",
    "start": "476000",
    "end": "483199"
  },
  {
    "text": "the fake address in the next allocation this allows adversary to temper the data",
    "start": "483199",
    "end": "488960"
  },
  {
    "text": "stored in the fake address however with this patch the kernel will calculate the address of next freight",
    "start": "488960",
    "end": "495440"
  },
  {
    "text": "slot by reversing xor by reversing xor's data in the first eight bytes",
    "start": "495440",
    "end": "501599"
  },
  {
    "text": "even if the adversary can forge the data using heap of buffer overflow the calculated address is not what the",
    "start": "501599",
    "end": "508080"
  },
  {
    "text": "address wants this is because the random number is involved in the calculation",
    "start": "508080",
    "end": "514399"
  },
  {
    "text": "according to one study early last year the entropy of the hardening is very low",
    "start": "514399",
    "end": "519518"
  },
  {
    "text": "and thus forging an address is possible as complement in the exploitation",
    "start": "519519",
    "end": "525279"
  },
  {
    "text": "approach i will describe in this presentation the first eight bytes of xor can be leaked with the limited right",
    "start": "525279",
    "end": "532320"
  },
  {
    "text": "primitive on kernel heap the leakage eight bytes can then be used for forging",
    "start": "532320",
    "end": "538320"
  },
  {
    "text": "i caused eight bytes as hip cookie in the following slides due to this weakness weakness the use",
    "start": "538320",
    "end": "545200"
  },
  {
    "text": "the kernel has further hardened the key cookie design after version 5.6.4 similar ideas also adopted in",
    "start": "545200",
    "end": "553040"
  },
  {
    "text": "excel xnu using a different implementation",
    "start": "553040",
    "end": "558079"
  },
  {
    "text": "another protection on slab's lab is a pair of initial analog and initial r3",
    "start": "558560",
    "end": "564880"
  },
  {
    "text": "these two mitigations show some similarities with the stack poisoning we've discussed in the previous slides",
    "start": "564880",
    "end": "571680"
  },
  {
    "text": "like kernel stack the heap object included scientific data like function pointer and keys for encryption",
    "start": "571680",
    "end": "579360"
  },
  {
    "text": "without the protection the content in the heap object is left unchanged after the object is freed",
    "start": "579360",
    "end": "586800"
  },
  {
    "text": "later when the slot holding object is recycled for the following allocations the advisory can use an uninitialized",
    "start": "586800",
    "end": "594320"
  },
  {
    "text": "heap bug to leak the data to this end the two mitigations are responsible for reserving out the heap",
    "start": "594320",
    "end": "601279"
  },
  {
    "text": "object at the time of freeing and reallocation respectively as such the sensitive data is removed",
    "start": "601279",
    "end": "608240"
  },
  {
    "text": "and legal data is all zeroed out the two protections work for use of the",
    "start": "608240",
    "end": "614079"
  },
  {
    "text": "free exploitation and double free exploitation because the two types of vulnerability needed to reason about",
    "start": "614079",
    "end": "620640"
  },
  {
    "text": "freeing and reallocation however when the key object is in use the sensitive data is stored on kernel",
    "start": "620640",
    "end": "627600"
  },
  {
    "text": "heap this gave us the chance to reach the sensitive data in the hip object using",
    "start": "627600",
    "end": "632800"
  },
  {
    "text": "the leak primitive obtained from limited right primitive i will elaborate on this later",
    "start": "632800",
    "end": "640480"
  },
  {
    "text": "the next protection i want to describe is k-a-s-r colon address space layout randomization on a slide i show part of",
    "start": "640720",
    "end": "648880"
  },
  {
    "text": "the color memory layout with this protection the loaded colony text image could be anywhere from a to",
    "start": "648880",
    "end": "655760"
  },
  {
    "text": "zero to schedule zero as long as it complies with alignment policy loaded and column modules could be",
    "start": "655760",
    "end": "662480"
  },
  {
    "text": "anywhere from set to 0 to say to 0 to 4 to 0 as long as it complies with",
    "start": "662480",
    "end": "668640"
  },
  {
    "text": "alignment policy 2. this is the situation of x64 and other architectures are similar",
    "start": "668640",
    "end": "675839"
  },
  {
    "text": "kasr is adopted in xnu and windows this protection works because it's very",
    "start": "675839",
    "end": "682160"
  },
  {
    "text": "hard for those exploitation approaches to reliably jump to the target code if",
    "start": "682160",
    "end": "687440"
  },
  {
    "text": "they want to execute current instructions for managers ago to defeat this protection the commonly",
    "start": "687440",
    "end": "694000"
  },
  {
    "text": "commonly used approach is to leak the address of a global variable or function point or function",
    "start": "694000",
    "end": "700880"
  },
  {
    "text": "then the adversary can calculate the base address of loaded current image or module through offset",
    "start": "700880",
    "end": "707600"
  },
  {
    "text": "that's why i say in the previous slides the return address and the function pointer are sensitive data because they",
    "start": "707600",
    "end": "714639"
  },
  {
    "text": "store their address or functions once their value is leakage kasr can be",
    "start": "714639",
    "end": "720000"
  },
  {
    "text": "bypassed this is the first shortcoming of kscr another shortcoming is low entropy",
    "start": "720000",
    "end": "726480"
  },
  {
    "text": "because there are only so many locations a current conflicting someone thinks attacker can guess the",
    "start": "726480",
    "end": "732240"
  },
  {
    "text": "base address without too much trouble as such kslr in function in kslr in",
    "start": "732240",
    "end": "738800"
  },
  {
    "text": "functional granularity is proposed i cannot go into details of this new",
    "start": "738800",
    "end": "744639"
  },
  {
    "text": "protection because it's still in development the main idea is to randomize address or functions when",
    "start": "744639",
    "end": "750880"
  },
  {
    "text": "loading the current image the entropy is much higher in this granularity and one leaking is far away",
    "start": "750880",
    "end": "757440"
  },
  {
    "text": "from being enough to defeat this fine granularity protection",
    "start": "757440",
    "end": "763120"
  },
  {
    "text": "apart from protections which rely on hiding sensitive data on this page i list the two types of synthetic data",
    "start": "763839",
    "end": "770720"
  },
  {
    "text": "that can be leakaged from corner from kernel according to andrew's exploit",
    "start": "770720",
    "end": "776880"
  },
  {
    "text": "the first is the content of the file etc shadow in the key ring demo",
    "start": "776880",
    "end": "783120"
  },
  {
    "text": "this file stores a hashed value of the user's passwords the adversary can use hash collision to",
    "start": "783120",
    "end": "789360"
  },
  {
    "text": "reverse engineer the hashed value and obtain the password the earner of this file is root and the",
    "start": "789360",
    "end": "795920"
  },
  {
    "text": "group is shadow with a leak primitive advisory can scan physical memory to search for the",
    "start": "795920",
    "end": "802079"
  },
  {
    "text": "pattern because the first entry of the file is always for root and loaded to the beginning of the page",
    "start": "802079",
    "end": "810000"
  },
  {
    "text": "the second is interrupt descriptor table when interrupt happens the kernel will",
    "start": "810000",
    "end": "815440"
  },
  {
    "text": "jump to the interrupt procedure for further process the offset to the procedural entry is",
    "start": "815440",
    "end": "820959"
  },
  {
    "text": "stopped in the table if the adversary can leak offset he or she can calculate the base edges of",
    "start": "820959",
    "end": "827680"
  },
  {
    "text": "loaded kernel image and thus bypass kslr there are many other types of sensitive",
    "start": "827680",
    "end": "833600"
  },
  {
    "text": "data in kernel due to the time limit i cannot enumerate them and i'm happy to learn more if you know know more about",
    "start": "833600",
    "end": "840240"
  },
  {
    "text": "them the exploitation approach i want to describe today is not a new attack it is",
    "start": "840240",
    "end": "847680"
  },
  {
    "text": "used in pong2 on 2017 for cve 2017-7184",
    "start": "847680",
    "end": "854680"
  },
  {
    "text": "in the exploitation of this vulnerability the attacker uses a flexible structure named transform the",
    "start": "855279",
    "end": "861760"
  },
  {
    "text": "play state esn as shown in the diagram on the slide this structure has two fields one field",
    "start": "861760",
    "end": "869120"
  },
  {
    "text": "is build map length which is an integer and another it is bin map which is a buffer",
    "start": "869120",
    "end": "874639"
  },
  {
    "text": "the length of a build map is determined dynamically and indicated by bitmap length",
    "start": "874639",
    "end": "880000"
  },
  {
    "text": "when kernel uses a structure it obtained the length beta map from bitmap length",
    "start": "880000",
    "end": "886079"
  },
  {
    "text": "to do the exploitation the attacker performs hip feng shui and places transform replace steady esn right after",
    "start": "886079",
    "end": "893440"
  },
  {
    "text": "the vulnerable object then the tackle triggers the keep above overflow to overwrite bitmap length",
    "start": "893440",
    "end": "900320"
  },
  {
    "text": "the bitmap lens is enlarged and the mix leads the kernel to believe the size of",
    "start": "900320",
    "end": "905440"
  },
  {
    "text": "bin map is larger than actual size later when retrieve receive messages",
    "start": "905440",
    "end": "911920"
  },
  {
    "text": "system call comes the content in the bitmap is copied to the user space while narrowing the put function",
    "start": "911920",
    "end": "919040"
  },
  {
    "text": "since the bitmap length is enlarged the heap region after the bitmap is also",
    "start": "919040",
    "end": "924320"
  },
  {
    "text": "copied out causing an overread the attacker places a 5 structure after",
    "start": "924320",
    "end": "930079"
  },
  {
    "text": "bitmap the file structure has a function pointer field named fop which points to",
    "start": "930079",
    "end": "935759"
  },
  {
    "text": "a static variable ext4 file operations by leaking the value value of the",
    "start": "935759",
    "end": "941360"
  },
  {
    "text": "function pointer the attacker knows the address of a static variable and then",
    "start": "941360",
    "end": "946560"
  },
  {
    "text": "calculates the base edges of loaded current image for bypass kscr",
    "start": "946560",
    "end": "951680"
  },
  {
    "text": "the flexible object has two advantages in exploitation one is its ability to dig data another",
    "start": "951680",
    "end": "958560"
  },
  {
    "text": "is the size of object can be determined dynamically so it can be allocated to several",
    "start": "958560",
    "end": "964639"
  },
  {
    "text": "general caches to be paired with vulnerable object and victim object",
    "start": "964639",
    "end": "970959"
  },
  {
    "text": "the same attack is observed in linux windows kernel exploitation the example on the slide is a one from a",
    "start": "970959",
    "end": "978079"
  },
  {
    "text": "previous blackhead asia talk by u1 in this exploitation the attack code",
    "start": "978079",
    "end": "983680"
  },
  {
    "text": "uses the use of the free tag pro plot list to override c entries",
    "start": "983680",
    "end": "989040"
  },
  {
    "text": "and i first three fields in the zombie tag prop list tag prob list happens to be an elastic",
    "start": "989040",
    "end": "996160"
  },
  {
    "text": "structure similar to the one in the previous slide c entries the lens field and i first",
    "start": "996160",
    "end": "1002639"
  },
  {
    "text": "free is a flexible buffer after corrupting c entries and the iphone's free fields the taco continues",
    "start": "1002639",
    "end": "1010399"
  },
  {
    "text": "to the right attack wnd object to obtain arbitrary read and write",
    "start": "1010399",
    "end": "1015839"
  },
  {
    "text": "from this example we know that elastic object attack is not specific to linux",
    "start": "1015839",
    "end": "1021440"
  },
  {
    "text": "but also other os kernels because the implementation of elastic objects follow",
    "start": "1021440",
    "end": "1026880"
  },
  {
    "text": "similar patterns before we describe what else we can do",
    "start": "1026880",
    "end": "1032079"
  },
  {
    "text": "using elastic objects we investigate its implementation patterns",
    "start": "1032079",
    "end": "1037120"
  },
  {
    "text": "on the slide i should display three other ways of implementing elastic objects the first way is to have a large",
    "start": "1037120",
    "end": "1043760"
  },
  {
    "text": "buffer defined in the middle of a data object the length field within that object",
    "start": "1043760",
    "end": "1048960"
  },
  {
    "text": "indicates actual buffer size or more precisely speaking the actual about",
    "start": "1048960",
    "end": "1054559"
  },
  {
    "text": "actual bytes used for storing data at the time of defining the actual number of bytes used for storing data",
    "start": "1054559",
    "end": "1062160"
  },
  {
    "text": "chrono typically examines the length field and ensures it doesn't go beyond the boundary of the large buffer",
    "start": "1062160",
    "end": "1069200"
  },
  {
    "text": "however we discover that the kernel doesn't always enforce this check at the",
    "start": "1069200",
    "end": "1074400"
  },
  {
    "text": "time of reading data from that buffer as such it eases and tackles ability to",
    "start": "1074400",
    "end": "1080400"
  },
  {
    "text": "manipulate the length field and thus construct a buffer overread in the second and third way the eq",
    "start": "1080400",
    "end": "1087200"
  },
  {
    "text": "implementations do not enclose the lens field and the flexible buffer in the same kernel object instead they place",
    "start": "1087200",
    "end": "1094400"
  },
  {
    "text": "the lens field and the flexible buffer in two individual cone objects the difference in that the second",
    "start": "1094400",
    "end": "1101280"
  },
  {
    "text": "implementation contains an explicit reference to the flexible buffer while the third implementation references the",
    "start": "1101280",
    "end": "1108320"
  },
  {
    "text": "flexible buffer through a third intermediate kernel object",
    "start": "1108320",
    "end": "1114000"
  },
  {
    "text": "now let's see what we can do using elastic objects the assumption of this attack is that",
    "start": "1114720",
    "end": "1120559"
  },
  {
    "text": "we've already obtained the right primitive on kernel heap we use that right primitive to tempo the",
    "start": "1120559",
    "end": "1126160"
  },
  {
    "text": "lens field as well as the point of field later the value of lens field is propagated to",
    "start": "1126160",
    "end": "1132480"
  },
  {
    "text": "the size argument of copy user function copy user function has three arguments",
    "start": "1132480",
    "end": "1138559"
  },
  {
    "text": "the first argument is destination indicating where the data is copied to",
    "start": "1138559",
    "end": "1143840"
  },
  {
    "text": "the second argument is source which indicates where the data is copied from",
    "start": "1143840",
    "end": "1149200"
  },
  {
    "text": "the third argument is size which represents how many bytes of data to copy",
    "start": "1149200",
    "end": "1154640"
  },
  {
    "text": "now we've already controlled the size argument on the right side of the slide i show",
    "start": "1154640",
    "end": "1160080"
  },
  {
    "text": "three situations where the source could come from the first situation is the",
    "start": "1160080",
    "end": "1165840"
  },
  {
    "text": "soft argument is the address of corner stack in this situation if we enlarge the size",
    "start": "1165840",
    "end": "1171520"
  },
  {
    "text": "value using the right primitive we can over read the kernel stack and leak the stack canary and return address to user",
    "start": "1171520",
    "end": "1178400"
  },
  {
    "text": "space the second situation is a source argument in the address of conor heap",
    "start": "1178400",
    "end": "1184960"
  },
  {
    "text": "we can ever read the corner heap to disclose function pointer and keep cookie",
    "start": "1184960",
    "end": "1190960"
  },
  {
    "text": "the third situation is the source argument is from the point of field in elastic object and is also tempered by",
    "start": "1190960",
    "end": "1198080"
  },
  {
    "text": "the adversary using the right primitive in this situation we can make the source",
    "start": "1198080",
    "end": "1203600"
  },
  {
    "text": "argument to be any current address as such we can leak sensitive data like etc",
    "start": "1203600",
    "end": "1209280"
  },
  {
    "text": "shadow or interrupt descriptor table which we mentioned in the previous slide",
    "start": "1209280",
    "end": "1215679"
  },
  {
    "text": "the severity of this attack is obvious if the adversary has limited the right primitive on current heap by triggering",
    "start": "1215679",
    "end": "1222720"
  },
  {
    "text": "the vulnerabilities like slab outer bound right use of the free and a double free he or she can transfer this right",
    "start": "1222720",
    "end": "1229760"
  },
  {
    "text": "primitive to obtain a leak primitive this capability enables adversary to",
    "start": "1229760",
    "end": "1235280"
  },
  {
    "text": "leak stationary written address encrypted heap cookies function pointer",
    "start": "1235280",
    "end": "1240480"
  },
  {
    "text": "etc shadow interrupts descriptor table and many other scientific data with recent data in hand it becomes",
    "start": "1240480",
    "end": "1247760"
  },
  {
    "text": "easier for the tackle to perform following exploitation steps",
    "start": "1247760",
    "end": "1253440"
  },
  {
    "text": "regarding generality of this attack it's unknown unfortunately first we don't know what else channel",
    "start": "1253440",
    "end": "1260240"
  },
  {
    "text": "functions in kernel like copy to user can provide us with the ability to",
    "start": "1260240",
    "end": "1265679"
  },
  {
    "text": "communicate between kernel space and user space second how many elastic structures and",
    "start": "1265679",
    "end": "1272080"
  },
  {
    "text": "objects are there in the kernel code base if we only have two or three it's very hard to it's very hard to cover most",
    "start": "1272080",
    "end": "1279360"
  },
  {
    "text": "slab caches let alone to say pairing them with vulnerability",
    "start": "1279360",
    "end": "1284799"
  },
  {
    "text": "the third question is even if we have enough elastic structures it doesn't mean the lens field and the point of",
    "start": "1284799",
    "end": "1291360"
  },
  {
    "text": "field of them can be propagated to the channel functions without this guarantee the adversary can",
    "start": "1291360",
    "end": "1297679"
  },
  {
    "text": "hardly control the size argument as well as a source argument the last question giving a vulnerability",
    "start": "1297679",
    "end": "1304720"
  },
  {
    "text": "does it provide us with the right primitive to override the length field and the point of field it's possible",
    "start": "1304720",
    "end": "1310960"
  },
  {
    "text": "that most vulnerabilities don't have that strong capability however general relative problem is of",
    "start": "1310960",
    "end": "1317919"
  },
  {
    "text": "vital importance because it is related to the question that do we need to pay attention to this attack and do we need",
    "start": "1317919",
    "end": "1325039"
  },
  {
    "text": "to make need a new mitigation if the attack is very ad hoc i don't see",
    "start": "1325039",
    "end": "1330400"
  },
  {
    "text": "any necessity to build a new mitigation probably simple patching is enough",
    "start": "1330400",
    "end": "1336159"
  },
  {
    "text": "as such our research work many focuses on studying the generality of this attack",
    "start": "1336159",
    "end": "1341840"
  },
  {
    "text": "we define generality from two perspectives first if there are enough number of",
    "start": "1341840",
    "end": "1347440"
  },
  {
    "text": "elastic objects in the kernel and second can most vulnerabilities provide us with",
    "start": "1347440",
    "end": "1352960"
  },
  {
    "text": "the capability to make use of elastic object for exploitation",
    "start": "1352960",
    "end": "1359799"
  },
  {
    "text": "first things first we identify some channel functions in the kernel and list them on the slide",
    "start": "1360000",
    "end": "1366880"
  },
  {
    "text": "we group them into three categories",
    "start": "1366880",
    "end": "1370720"
  },
  {
    "text": "the first one is memory access api which is copy to user the second one is specific to net link socket which is a",
    "start": "1372559",
    "end": "1380000"
  },
  {
    "text": "networking between kernel space and user space to use this functionality requires",
    "start": "1380000",
    "end": "1385600"
  },
  {
    "text": "network and administration capability which is grant which can be granted in the user space username space",
    "start": "1385600",
    "end": "1392640"
  },
  {
    "text": "so you don't worry about like you don't have the capability to use this socket uh for exploitation",
    "start": "1392640",
    "end": "1399440"
  },
  {
    "text": "take that uh take the net link input function as example attribute length which is highlight",
    "start": "1399440",
    "end": "1405120"
  },
  {
    "text": "highlighted with underlying is a size argument and a data which is in both the source argument",
    "start": "1405120",
    "end": "1413039"
  },
  {
    "text": "the third one is general networking for example skb put data in which lengthy is",
    "start": "1413039",
    "end": "1418799"
  },
  {
    "text": "a science argument and a data is a source argument some channel functions are the",
    "start": "1418799",
    "end": "1424000"
  },
  {
    "text": "combination of two functions for example in netlink the return value of netiquette message data the source",
    "start": "1424000",
    "end": "1430640"
  },
  {
    "text": "argument which is later used in memory copy function the size argument is count in memory",
    "start": "1430640",
    "end": "1436880"
  },
  {
    "text": "copy no matter what the function prototypes are all of all of them have a source",
    "start": "1436880",
    "end": "1442640"
  },
  {
    "text": "argument and a size argument our analysis begins from these channel functions",
    "start": "1442640",
    "end": "1449840"
  },
  {
    "text": "the first step in our static analysis is to identify the leaking angle which is",
    "start": "1450320",
    "end": "1456400"
  },
  {
    "text": "which is invoking to channel functions in the code base i use red to represent source argument",
    "start": "1456400",
    "end": "1462880"
  },
  {
    "text": "and a green for a size argument in the channel function the first step is to check where is the",
    "start": "1462880",
    "end": "1468559"
  },
  {
    "text": "lens flow in the diagram the lens is from a structural variable named u payload its",
    "start": "1468559",
    "end": "1474799"
  },
  {
    "text": "type is user key payload the third step is to check where is the size from",
    "start": "1474799",
    "end": "1480480"
  },
  {
    "text": "in the diagram the source is the return value of key malloc the type of the source is user key payload 2.",
    "start": "1480480",
    "end": "1488000"
  },
  {
    "text": "we can clearly see that the source and the length are both from the same structure type",
    "start": "1488000",
    "end": "1494000"
  },
  {
    "text": "besides we can learn that this structural variable is on heap because it is generated through allocation",
    "start": "1494000",
    "end": "1500480"
  },
  {
    "text": "what's more user key payload is a standard flexible structure because its size is a constant plus variable",
    "start": "1500480",
    "end": "1507600"
  },
  {
    "text": "the offset of the length field and the flexible buffer can also be tracked up",
    "start": "1507600",
    "end": "1512960"
  },
  {
    "text": "through above analysis we can learn that we can learn which slab cache is responsible for holding the object",
    "start": "1512960",
    "end": "1519679"
  },
  {
    "text": "so the user key payload is exactly the elastic structure that we are searching for",
    "start": "1519679",
    "end": "1526240"
  },
  {
    "text": "the last step of the analysis is to collapse the constraints along the path from the ankle retrievals to anchor the",
    "start": "1526240",
    "end": "1533360"
  },
  {
    "text": "leaks data we do this examination because we want to see whether the kernel enforces the",
    "start": "1533360",
    "end": "1539919"
  },
  {
    "text": "checking of lens fields if the if the kind of thing says hey the length cannot be too large the leaking property",
    "start": "1539919",
    "end": "1546640"
  },
  {
    "text": "doesn't work in example on the slides the current only ensures that a user can show the",
    "start": "1546640",
    "end": "1552480"
  },
  {
    "text": "parameter buffer length is larger than the data length therefore this checking doesn't",
    "start": "1552480",
    "end": "1557919"
  },
  {
    "text": "influence the data leaking finally we obtain a record for each",
    "start": "1557919",
    "end": "1564240"
  },
  {
    "text": "identified elastic structure we know the structure name the cache holdings object",
    "start": "1564240",
    "end": "1569600"
  },
  {
    "text": "the offset of length field allocation sites leaking sites as well as what",
    "start": "1569600",
    "end": "1574640"
  },
  {
    "text": "types of sensitive data can be leaked in total the static analysis tracks down",
    "start": "1574640",
    "end": "1580080"
  },
  {
    "text": "49 elastic structures in default configuration we use kernel fuzzing and manual",
    "start": "1580080",
    "end": "1585600"
  },
  {
    "text": "analysis confirmed 38 of them we list these structures here in a table",
    "start": "1585600",
    "end": "1592559"
  },
  {
    "text": "the first column represents which case the object can reside in the second",
    "start": "1592559",
    "end": "1597840"
  },
  {
    "text": "column the structure name the third is the offset of length field and pointer",
    "start": "1597840",
    "end": "1602880"
  },
  {
    "text": "field the fourth is what scientific data can be leaked the fifth is the privilege required to",
    "start": "1602880",
    "end": "1609440"
  },
  {
    "text": "operate the object and the last column is the path constraint to sum up most general caches are",
    "start": "1609440",
    "end": "1616559"
  },
  {
    "text": "covered by our identified structures note that the number 36 and 38 are for",
    "start": "1616559",
    "end": "1623120"
  },
  {
    "text": "structures not objects if we count the number of objects and the program sites that are used objects the statics can be",
    "start": "1623120",
    "end": "1630559"
  },
  {
    "text": "thousands from this perspective the elastic objects are pervasive in kernel codebase",
    "start": "1630559",
    "end": "1638799"
  },
  {
    "text": "we used 31 vulnerabilities to examine what we can do using elastic objects the",
    "start": "1638880",
    "end": "1644640"
  },
  {
    "text": "results show that 23 vulnerabilities is enabled with kscr",
    "start": "1644640",
    "end": "1649840"
  },
  {
    "text": "bypassing and heap cookies leaking 12 of them can leak stationary and five",
    "start": "1649840",
    "end": "1655440"
  },
  {
    "text": "of them and perform actual read thus we want to join the conclusion that",
    "start": "1655440",
    "end": "1660799"
  },
  {
    "text": "elastic object attack is general in linux kernel",
    "start": "1660799",
    "end": "1666240"
  },
  {
    "text": "how about other operating systems kernels in xmu the static analysis tracks down",
    "start": "1666320",
    "end": "1672000"
  },
  {
    "text": "16 structures in freebst and i mean freebsd we have 12 structures",
    "start": "1672000",
    "end": "1680480"
  },
  {
    "text": "we use in total nine cves in freebsd and xnu five of them can bypass kslr four of",
    "start": "1680480",
    "end": "1687919"
  },
  {
    "text": "them they keep cookies because freebsd doesn't have keep cookie three of them can perform arbitrary read",
    "start": "1687919",
    "end": "1695120"
  },
  {
    "text": "it assumes elastic object attack is an issue not only in linux but also in freebsd and xmu",
    "start": "1695120",
    "end": "1703360"
  },
  {
    "text": "someone may ask that we can use elastic object for leaking because the kernel data can be copied from kernel space to",
    "start": "1703360",
    "end": "1710320"
  },
  {
    "text": "user space via channel functions like copy to user is it possible that we use elastic",
    "start": "1710320",
    "end": "1716720"
  },
  {
    "text": "object for arbitrary writing using functions that copy data from user space to kernel space",
    "start": "1716720",
    "end": "1722799"
  },
  {
    "text": "to answer this question i i add copy from user function to our static analysis and found three candidate",
    "start": "1722799",
    "end": "1729279"
  },
  {
    "text": "structures the first is io vector a commonly used one however this structure is enforced",
    "start": "1729279",
    "end": "1736000"
  },
  {
    "text": "with lens checking the two others are dmio control and fd table",
    "start": "1736000",
    "end": "1742240"
  },
  {
    "text": "to overwrite requires data rays and the time windows is very small it's impractical to use them for",
    "start": "1742240",
    "end": "1748880"
  },
  {
    "text": "arbitrary writing i want to emphasize that this study is limited because i don't include other",
    "start": "1748880",
    "end": "1754880"
  },
  {
    "text": "functions in fact i know some exploits use elastic object to realize actually",
    "start": "1754880",
    "end": "1760720"
  },
  {
    "text": "right i plan to leave it as my future work since we've released our code i also",
    "start": "1760720",
    "end": "1766799"
  },
  {
    "text": "invite you to do some contribution if you are interested",
    "start": "1766799",
    "end": "1771520"
  },
  {
    "text": "there are several mitigations in linux kernel that seems effective to prevent this elastic object attack",
    "start": "1772399",
    "end": "1779200"
  },
  {
    "text": "the first potential mitigation is freeless to randomization without this mitigation the freed slots",
    "start": "1779200",
    "end": "1785600"
  },
  {
    "text": "are chained in the list linearly this means the freed slots are physically continuous",
    "start": "1785600",
    "end": "1791919"
  },
  {
    "text": "with this feature the adversary can predict the slab layout and perform stable hip function",
    "start": "1791919",
    "end": "1798480"
  },
  {
    "text": "with this mitigation the three slots are shuffled when corners create a slab cast",
    "start": "1798480",
    "end": "1804399"
  },
  {
    "text": "thus the order of three slots are randomized in this way the adversary cannot predict the kernel of predictive",
    "start": "1804399",
    "end": "1811600"
  },
  {
    "text": "slab layout and it's harder for their hiroshi to exploit slab out of bound",
    "start": "1811600",
    "end": "1816799"
  },
  {
    "text": "right vulnerability the limitations of these mitigations at first it has no effects on use of the",
    "start": "1816799",
    "end": "1824000"
  },
  {
    "text": "free double free exploitation this is because the exploitation of these two bytes",
    "start": "1824000",
    "end": "1829840"
  },
  {
    "text": "these two types doesn't require to predict slab layout and second there are many bypassing",
    "start": "1829840",
    "end": "1835919"
  },
  {
    "text": "techniques against this mitigation for example groom which is to first allocate a bunch",
    "start": "1835919",
    "end": "1842080"
  },
  {
    "text": "of placeholder objects and victim objects to the current heap the anniversary frees the placeholder",
    "start": "1842080",
    "end": "1848480"
  },
  {
    "text": "objects and leaves holes on heap after this he or she can allocate the vulnerable object to the hose to perform",
    "start": "1848480",
    "end": "1855600"
  },
  {
    "text": "hip function another technique to bypass the freelance randomization is the freelance",
    "start": "1855600",
    "end": "1861279"
  },
  {
    "text": "reversal due to the time limit i will not elaborate on them in this presentation and more details can be",
    "start": "1861279",
    "end": "1867840"
  },
  {
    "text": "found online the second potential mitigation is a",
    "start": "1867840",
    "end": "1873760"
  },
  {
    "text": "config gcc plugin random structure this mitigation tries to randomize the order",
    "start": "1873760",
    "end": "1879039"
  },
  {
    "text": "of fields in a structure under the compilation phase it prevents attackers from predicting",
    "start": "1879039",
    "end": "1884880"
  },
  {
    "text": "the offset of scientific data within the structure take the structure on the slide as an",
    "start": "1884880",
    "end": "1890320"
  },
  {
    "text": "example the attackers want to override function point of field initial to hijack control flow",
    "start": "1890320",
    "end": "1897039"
  },
  {
    "text": "without the randomization the offset of the initial field is fixed and predictable",
    "start": "1897039",
    "end": "1903200"
  },
  {
    "text": "with the randomization the initial field is shuffled to another order thus the override doesn't always work",
    "start": "1903200",
    "end": "1910480"
  },
  {
    "text": "as such this mitigation seems a threat to the tackle however i want to say that this defense",
    "start": "1910480",
    "end": "1917600"
  },
  {
    "text": "relies on a random seed to perform randomization and the protection of this seed is not trivial for example linux",
    "start": "1917600",
    "end": "1925440"
  },
  {
    "text": "distributors have to expose the random seed to their users for building third-party current modules this is",
    "start": "1925440",
    "end": "1932159"
  },
  {
    "text": "because the third-party column modules need to know how exactly the structure is defined after layout layout",
    "start": "1932159",
    "end": "1938880"
  },
  {
    "text": "randomization for using them the mitigation works well in house building kernel if the random seed can",
    "start": "1938880",
    "end": "1945679"
  },
  {
    "text": "be protected appropriately but for districts like ubentu and debian it's not very practical",
    "start": "1945679",
    "end": "1953518"
  },
  {
    "text": "the last potential mitigation is config hardened user copy which is important from pax user copy",
    "start": "1954080",
    "end": "1960880"
  },
  {
    "text": "this mitigation exam examines the size argument of copy to user",
    "start": "1960880",
    "end": "1965919"
  },
  {
    "text": "if the source argument is a constant address this defense ensures that the size argument is smaller than the frame",
    "start": "1965919",
    "end": "1972960"
  },
  {
    "text": "size only data in the current stack frame can be copied out if the source argument is called heap",
    "start": "1972960",
    "end": "1979600"
  },
  {
    "text": "address this defense ensures that the size argument is smaller than the slot",
    "start": "1979600",
    "end": "1984720"
  },
  {
    "text": "slice the cross slide overread is disallowed the similar mechanism is also used in",
    "start": "1984720",
    "end": "1991120"
  },
  {
    "text": "xnu kernel while this technique can mitigate the threat of some elastic objects it",
    "start": "1991120",
    "end": "1997200"
  },
  {
    "text": "suffers from two problems on the one hand it only enforces the length checking for copy to user",
    "start": "1997200",
    "end": "2003760"
  },
  {
    "text": "other critical kernel functions for data transferring are not included on the other hand the legit lens range",
    "start": "2003760",
    "end": "2010720"
  },
  {
    "text": "is not restricted enough the sensitive data can reside in a cache slot or stack",
    "start": "2010720",
    "end": "2015919"
  },
  {
    "text": "frame it's still possible to leak them even after the mitigation is enforced",
    "start": "2015919",
    "end": "2022320"
  },
  {
    "text": "according to our discussion in previous slides there are now no mitigation in the kernel that can perfectly neutralize",
    "start": "2022320",
    "end": "2029440"
  },
  {
    "text": "the thread of elastic objects to this end we propose a new defense mechanism",
    "start": "2029440",
    "end": "2035440"
  },
  {
    "text": "this mechanism isolates elastic objects that we define or that we identified into individual shadow caches",
    "start": "2035440",
    "end": "2042559"
  },
  {
    "text": "to be specific we create an isolated shadow cache for each general cache",
    "start": "2042559",
    "end": "2047679"
  },
  {
    "text": "during corner boot up using shadow caches we store elastic objects with the corresponding sizes for",
    "start": "2047679",
    "end": "2054398"
  },
  {
    "text": "example the elastic objects originally allocated in kinematic 96 will be",
    "start": "2054399",
    "end": "2059919"
  },
  {
    "text": "assigned in cape melon isolated isolated 96 after the isolation mechanism is",
    "start": "2059919",
    "end": "2065118"
  },
  {
    "text": "enabled to support this isolation we modified the kernel source code by adding one",
    "start": "2065119",
    "end": "2071520"
  },
  {
    "text": "more flag at allocation site this flag specifies that the object to be allocated is elastic object and should",
    "start": "2071520",
    "end": "2079040"
  },
  {
    "text": "be placed in the shadow caches with vein's isolation mechanism an",
    "start": "2079040",
    "end": "2084240"
  },
  {
    "text": "adversary has little chance to leverage the vulnerability tied to other objects to manipulate length field and a point",
    "start": "2084240",
    "end": "2091358"
  },
  {
    "text": "of field in elastic objects besides the common heap spray objects",
    "start": "2091359",
    "end": "2096638"
  },
  {
    "text": "and con objects with scientific information like function pointers are also isolated from the elastic objects",
    "start": "2096639",
    "end": "2104000"
  },
  {
    "text": "they could not be used for hip feng shui and spraying i learned from just security that they",
    "start": "2104000",
    "end": "2110400"
  },
  {
    "text": "have implemented more advanced isolation in their new defense named auto slab",
    "start": "2110400",
    "end": "2116000"
  },
  {
    "text": "outer slab is much more aggressive in heap object isolation although i don't",
    "start": "2116000",
    "end": "2121040"
  },
  {
    "text": "know more details of about auto load or oslab autosap i'm pretty sure that this",
    "start": "2121040",
    "end": "2126720"
  },
  {
    "text": "security improvement is very significant too",
    "start": "2126720",
    "end": "2131839"
  },
  {
    "text": "we evaluated the performance overhead of our proposed mitigation we use the three",
    "start": "2131839",
    "end": "2137040"
  },
  {
    "text": "sets of benchmarks the first set is micro benchmarks from rm bench which",
    "start": "2137040",
    "end": "2142560"
  },
  {
    "text": "tests the latency and the bandwidth of common system calls and io operations",
    "start": "2142560",
    "end": "2148240"
  },
  {
    "text": "the second benchmark is my macro benchmarks from feronix test suite 9.8",
    "start": "2148240",
    "end": "2154560"
  },
  {
    "text": "which runs five real-world applications to prevent the overhead from being hidden behind the sophisticated kernel",
    "start": "2154560",
    "end": "2161440"
  },
  {
    "text": "execution we specifically designed the third set benchmark to stress test the",
    "start": "2161440",
    "end": "2167200"
  },
  {
    "text": "impact of our mitigation approach this set of customized benchmarks use",
    "start": "2167200",
    "end": "2173200"
  },
  {
    "text": "the system core sequences to reach elastic object allocation and the corresponding data leakage intensively",
    "start": "2173200",
    "end": "2180560"
  },
  {
    "text": "overall we could observe that the performance overhead is negligible with a performance with average performance",
    "start": "2180560",
    "end": "2187440"
  },
  {
    "text": "job less than one percent we also evaluate the security of our",
    "start": "2187440",
    "end": "2195280"
  },
  {
    "text": "security improvement of our proposed mitigation approach by using the 31 vulnerabilities that were used to study",
    "start": "2195280",
    "end": "2202400"
  },
  {
    "text": "the generality of elastic object attack for most vulnerabilities we cannot find",
    "start": "2202400",
    "end": "2208079"
  },
  {
    "text": "elastic objects that can be used for exploitation it is because elastic objects and the vulnerable objects are",
    "start": "2208079",
    "end": "2214640"
  },
  {
    "text": "mostly different they are isolated into two different caches",
    "start": "2214640",
    "end": "2220480"
  },
  {
    "text": "there is no longer no longer a possibility to to use a vulnerable object to manipulate",
    "start": "2220480",
    "end": "2226560"
  },
  {
    "text": "the length field of an elastic object for vulnerable objects in cv 2017 71 84",
    "start": "2226560",
    "end": "2235599"
  },
  {
    "text": "and cv 2017-17053 there are elastic objects allocated in",
    "start": "2235599",
    "end": "2242160"
  },
  {
    "text": "shadow caches technically they can be leveraged to override data in isolated caches and",
    "start": "2242160",
    "end": "2248640"
  },
  {
    "text": "thus manipulate the length field of elastic object for data disclosure however we argue that even this",
    "start": "2248640",
    "end": "2255520"
  },
  {
    "text": "situation exists our mitigation still raises the bar because disclosed data is",
    "start": "2255520",
    "end": "2260960"
  },
  {
    "text": "not likely to be useful for bypassing kernel mitigation taking the practice of circumventing",
    "start": "2260960",
    "end": "2267359"
  },
  {
    "text": "kslr using cve",
    "start": "2267359",
    "end": "2270960"
  },
  {
    "text": "2017-13056-553 as an example to use a vulnerable object to reveal a kernel-based address in addition to",
    "start": "2272680",
    "end": "2279599"
  },
  {
    "text": "leveraging the elastic object an attacker usually has to identify a general object that encloses a function",
    "start": "2279599",
    "end": "2286800"
  },
  {
    "text": "pointer then the attacker needs to place the object in the same isolated patch",
    "start": "2286800",
    "end": "2292720"
  },
  {
    "text": "however due to the general due to the isolation between general object an elastic object such an object such an",
    "start": "2292720",
    "end": "2300800"
  },
  {
    "text": "object such a general object is no longer available for this isolated cache",
    "start": "2300800",
    "end": "2308160"
  },
  {
    "text": "in addition to the defense we proposed there are not",
    "start": "2308160",
    "end": "2313440"
  },
  {
    "text": "when available kernel discloses data in an in a flexible buffer at any leaking",
    "start": "2325680",
    "end": "2331200"
  },
  {
    "text": "angle we could check whether the amount of the data migrated to the user space",
    "start": "2331200",
    "end": "2336400"
  },
  {
    "text": "is within a legit range since the construction of shadow memory",
    "start": "2336400",
    "end": "2341440"
  },
  {
    "text": "is inevitably introduces memory and performance overhead the key challenge of this solution is to develop a",
    "start": "2341440",
    "end": "2348240"
  },
  {
    "text": "lightweight method to minimize overhead in a systematic method another possible solution is to design a",
    "start": "2348240",
    "end": "2355200"
  },
  {
    "text": "mechanism to enable the integrity check for the data in length field we introduce a checksum field when the",
    "start": "2355200",
    "end": "2362240"
  },
  {
    "text": "kernel allocates a corresponding object and initialize its length field we could encrypt the length value and start it in",
    "start": "2362240",
    "end": "2369520"
  },
  {
    "text": "the checksum field accordingly with this design at the time of disclosing data in the flexible buffer",
    "start": "2369520",
    "end": "2376000"
  },
  {
    "text": "to be to the userland the kernel could easily retrieve and examine the checksum",
    "start": "2376000",
    "end": "2381920"
  },
  {
    "text": "the key challenge of implementing this idea is to ensure that addition of the",
    "start": "2381920",
    "end": "2387359"
  },
  {
    "text": "checksum field will not influence the usability of the kernel some elastic data structures are",
    "start": "2387359",
    "end": "2393520"
  },
  {
    "text": "designed for protocols which have specific formats after allocating objects in these types",
    "start": "2393520",
    "end": "2400240"
  },
  {
    "text": "the kernel references the data through corresponding offsets if introducing additional field into",
    "start": "2400240",
    "end": "2406560"
  },
  {
    "text": "such objects one has to ensure that the newly added checksum field does not",
    "start": "2406560",
    "end": "2411760"
  },
  {
    "text": "incur in current data reference i summarize the take away of the",
    "start": "2411760",
    "end": "2418480"
  },
  {
    "text": "presentation as follows first using elastic object for leaking is a severe",
    "start": "2418480",
    "end": "2424079"
  },
  {
    "text": "and general approach to bypassing protections in kernel second new mitigations are needed in linux freebst",
    "start": "2424079",
    "end": "2431359"
  },
  {
    "text": "and xnu to prevent elastic in object attack we evaluate our proposed mitigation and",
    "start": "2431359",
    "end": "2437920"
  },
  {
    "text": "showcase that its performance overhead is negligible while security improvement",
    "start": "2437920",
    "end": "2443040"
  },
  {
    "text": "is clear finally it seems that elastic object attack for arbitrary writing is less",
    "start": "2443040",
    "end": "2449280"
  },
  {
    "text": "general but more study is required to confirm this claim",
    "start": "2449280",
    "end": "2454880"
  },
  {
    "text": "thanks for listening and thank you very much for having me here if you want to know more about me and my other projects",
    "start": "2454880",
    "end": "2461200"
  },
  {
    "text": "or you don't have chance to ask questions in this session feel free to follow me on twitter contact me using",
    "start": "2461200",
    "end": "2468240"
  },
  {
    "text": "email and check my personal page we've released the code on github and welcome your contribution thank you all",
    "start": "2468240",
    "end": "2478200"
  }
]