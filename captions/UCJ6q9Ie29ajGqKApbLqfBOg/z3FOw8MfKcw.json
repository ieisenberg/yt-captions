[
  {
    "text": "hi everyone welcome to my talk walking your dog in multiple forests breaking 80 trust boundaries through",
    "start": "2159",
    "end": "7200"
  },
  {
    "text": "gabriel's vulnerabilities my name is joking malma and today i will be talking about some interesting camera",
    "start": "7200",
    "end": "12480"
  },
  {
    "text": "stuff first bit about me i'm der kyon i live in the netherlands i do a combination of hacking right teaming and researching at",
    "start": "12480",
    "end": "18720"
  },
  {
    "text": "voxite and i also like to write tools usually focused on active directory or azure id",
    "start": "18720",
    "end": "24320"
  },
  {
    "text": "and i write about those on my blog or tweet about it on my twitter account so if you're interested",
    "start": "24320",
    "end": "29760"
  },
  {
    "text": "definitely do check that out what i'll be talking about today is cabrals and especially focused on forest",
    "start": "29760",
    "end": "36480"
  },
  {
    "text": "trusts so we start with a quick overview of how kerose works across domains then we move to forest and domain trusts",
    "start": "36480",
    "end": "43520"
  },
  {
    "text": "what they mean and what they do looking at trust transitivity and what exactly transitivity is",
    "start": "43520",
    "end": "49280"
  },
  {
    "text": "breaking forest trust is the conclusion where we can dive into the technical details of",
    "start": "49280",
    "end": "54640"
  },
  {
    "text": "the whole attack path that i developed so let's have a simple",
    "start": "54640",
    "end": "59920"
  },
  {
    "text": "reminder of the camera's terminology the most important thing is that camera is all about",
    "start": "59920",
    "end": "65680"
  },
  {
    "text": "tickets so the first is a tgt or a ticket granting ticket which is given by the domain controller",
    "start": "65680",
    "end": "71280"
  },
  {
    "text": "to an authenticated user they prove that they are the user by sending",
    "start": "71280",
    "end": "76799"
  },
  {
    "text": "along their the password and then the dc gives back a ticket granting tickets that they can use to request other cargo",
    "start": "76799",
    "end": "82799"
  },
  {
    "text": "tickets one such ticket that they can request is a service ticket and a service ticket can be used to",
    "start": "82799",
    "end": "88799"
  },
  {
    "text": "authenticate against services that accept cabros authentication for example file servers or web servers",
    "start": "88799",
    "end": "95439"
  },
  {
    "text": "an important component of the det and also the service ticket is the privilege",
    "start": "95439",
    "end": "100799"
  },
  {
    "text": "attribute certificate or back this is a piece of data that basically describes",
    "start": "100799",
    "end": "107680"
  },
  {
    "text": "all the rights and groups that the user is in so it contains a lot of security identifiers",
    "start": "107680",
    "end": "114720"
  },
  {
    "text": "which are basically the unique ids within a given domain of groups and users and",
    "start": "114720",
    "end": "121119"
  },
  {
    "text": "these tell the server that you're authenticating to which groups you're in without it having to query the domain controller",
    "start": "121119",
    "end": "127360"
  },
  {
    "text": "separately and we'll be seeing a lot of these security identifiers throughout this talk so keep them in mind and there's an example",
    "start": "127360",
    "end": "134319"
  },
  {
    "text": "of how a security identifier looks on the bottom of the slide some really important",
    "start": "134319",
    "end": "140080"
  },
  {
    "text": "points about care bros keros is decentralized so the dc doesn't keep track of all the",
    "start": "140080",
    "end": "145599"
  },
  {
    "text": "details that it gave to people but the tickets themselves are proof that it is a legitimate ticket",
    "start": "145599",
    "end": "153280"
  },
  {
    "text": "by by being encrypted with the passwords that only the domain troll knows so the trust in kerberos is based on",
    "start": "153280",
    "end": "160160"
  },
  {
    "text": "cryptography and we'll see how that works like this and before we dive into it i just want to do a",
    "start": "160160",
    "end": "167280"
  },
  {
    "text": "quick show of how the um the keras authentication work",
    "start": "167280",
    "end": "173200"
  },
  {
    "text": "so if we look at a common example the client that wants to attend the gate to",
    "start": "173840",
    "end": "179360"
  },
  {
    "text": "a server first the client will talk to the dc when it logs in and it will say hey i'm",
    "start": "179360",
    "end": "187120"
  },
  {
    "text": "a client please give me a ticket granting ticket and then it proves that it's actually who it says this by",
    "start": "187120",
    "end": "193680"
  },
  {
    "text": "encrypting the request with the password so the ndc knows that the client is who says it is and it gives the",
    "start": "193680",
    "end": "200400"
  },
  {
    "text": "client a ticket granted ticket then later on the client can the client",
    "start": "200400",
    "end": "206799"
  },
  {
    "text": "can send this ged back to the server and actually request a service ticket and the service ticket",
    "start": "206799",
    "end": "213040"
  },
  {
    "text": "they can use to log in on the server and the dc knows that the tgt is legitimate because it's encrypted with the password",
    "start": "213040",
    "end": "219360"
  },
  {
    "text": "of the kbt account this is only known by the domain controllers and that's how it knows",
    "start": "219360",
    "end": "224879"
  },
  {
    "text": "that the ticket is legitimate because it's encrypted with something that's only doing so it's supposed to know so",
    "start": "224879",
    "end": "231280"
  },
  {
    "text": "the main controller then gives back a service ticket or sd",
    "start": "231280",
    "end": "236319"
  },
  {
    "text": "and this service ticket is no longer encrypted with the the password of the kbtg account but",
    "start": "236319",
    "end": "243360"
  },
  {
    "text": "it's now encrypted with the password of the service account so the service account in this case can",
    "start": "243360",
    "end": "249680"
  },
  {
    "text": "be the account that's used that's the computer account on the server",
    "start": "249680",
    "end": "254959"
  },
  {
    "text": "and if we send this service ticket to the server the server can trust that it's valid because it's encrypted with",
    "start": "254959",
    "end": "260560"
  },
  {
    "text": "its own passwords so only that server can encrypt it and by being able to decrypt it it's kind of proven that the server",
    "start": "260560",
    "end": "269440"
  },
  {
    "text": "the user got the tickets from the legitimate domain network because only the main guitar is supposed to know",
    "start": "269440",
    "end": "274560"
  },
  {
    "text": "the password of the account on the server",
    "start": "274560",
    "end": "278400"
  },
  {
    "text": "and some important points that i just mentioned and the link controller press the td",
    "start": "281040",
    "end": "286320"
  },
  {
    "text": "because it's encrypted with its password and the service trustee service ticket because it's encrypted with its own",
    "start": "286320",
    "end": "291759"
  },
  {
    "text": "password now most times i said um in most cases",
    "start": "291759",
    "end": "296800"
  },
  {
    "text": "only the dc will know the passwords and there are some common attacks and backers that abuse this so if your id is",
    "start": "296800",
    "end": "304000"
  },
  {
    "text": "compromised attacker can dump the password and then create their own tickets these are called golden tickets",
    "start": "304000",
    "end": "309600"
  },
  {
    "text": "you can basically create a ticket that contains any information that you want if you compromise the service passwords",
    "start": "309600",
    "end": "316320"
  },
  {
    "text": "you can create silver tickets which are quite similar but in this case they're encrypted with the password of the",
    "start": "316320",
    "end": "321520"
  },
  {
    "text": "service that you're attending so these are called silver tickets",
    "start": "321520",
    "end": "326479"
  },
  {
    "text": "now what we're talking about today is trusts and especially forest trust a forest stress",
    "start": "328160",
    "end": "334240"
  },
  {
    "text": "is different from a domain trust on the left we see a forest with two domains first a",
    "start": "334240",
    "end": "339280"
  },
  {
    "text": "and subdomain and in in this forest the domains trust each other but all domains are equal and if you compromise one",
    "start": "339280",
    "end": "345600"
  },
  {
    "text": "domain you can basically and use the legitimate functionality to compromise the whole forest first on the",
    "start": "345600",
    "end": "352400"
  },
  {
    "text": "other hand is supposed to be a security boundary and you're not supposed to be able to",
    "start": "352400",
    "end": "357840"
  },
  {
    "text": "go from first a to force b in by default however the truss is",
    "start": "357840",
    "end": "364319"
  },
  {
    "text": "usually set up to allow people to authenticate from first a into first b so if someone is actually",
    "start": "364319",
    "end": "370160"
  },
  {
    "text": "given permissions in force b then well that's intended so it's not a",
    "start": "370160",
    "end": "376479"
  },
  {
    "text": "vulnerability let's have a look at how kerberos authentication looks across trusts",
    "start": "378840",
    "end": "386400"
  },
  {
    "text": "so in this case we have two parts we have force a and force b and once again we are client",
    "start": "388400",
    "end": "394800"
  },
  {
    "text": "enforced a but we want to reach the server in first b what client a will do is we'll simply",
    "start": "394800",
    "end": "401759"
  },
  {
    "text": "ask the domain controller hey i want to authenticate in force b on server b",
    "start": "401759",
    "end": "409440"
  },
  {
    "text": "and the client doesn't know that in a different forest but basically it's asked the domain controller and the domain and sensitivity along the",
    "start": "409440",
    "end": "416960"
  },
  {
    "text": "domain controller would then send a special tt",
    "start": "416960",
    "end": "422800"
  },
  {
    "text": "which is atgt that is that belongs to forest a",
    "start": "422800",
    "end": "428400"
  },
  {
    "text": "but is in fact assigned with a crust key that is part of forest b so when there",
    "start": "428400",
    "end": "434880"
  },
  {
    "text": "there's a forest trust set up a trust key is exchanged and both sides have this key in",
    "start": "434880",
    "end": "440319"
  },
  {
    "text": "possession and that they can exchange scarborough tickets and they know it's a legitimate ticket because it's signed",
    "start": "440319",
    "end": "445840"
  },
  {
    "text": "by the trust key so the client can use this inter-realm",
    "start": "445840",
    "end": "451039"
  },
  {
    "text": "tdt as we call it to request a service ticket in 4xb",
    "start": "451039",
    "end": "456160"
  },
  {
    "text": "and the dcm4sb would then check the ticket and it will send back a service ticket",
    "start": "456160",
    "end": "462880"
  },
  {
    "text": "which the client can use to authenticate to server b now there is one additional point i",
    "start": "463280",
    "end": "469440"
  },
  {
    "text": "wrote a small filter here because there is a part called sid filtering",
    "start": "469440",
    "end": "475919"
  },
  {
    "text": "and what it means is that you cannot simply put anything in the ticket when you exchange it in a different",
    "start": "475919",
    "end": "482560"
  },
  {
    "text": "forest because what we said before is that we assume there is a boundary between these forests",
    "start": "482560",
    "end": "488160"
  },
  {
    "text": "and you're not supposed to simply if you compromise first a you're not supposed to simply create",
    "start": "488160",
    "end": "494080"
  },
  {
    "text": "your gdt which can say that you have for example a high roll a domain admin in force b",
    "start": "494080",
    "end": "500240"
  },
  {
    "text": "so force b actually checks the ticket that send along and it filters out all the security",
    "start": "500240",
    "end": "506080"
  },
  {
    "text": "identifiers that it doesn't know about so in most cases you can pretend any",
    "start": "506080",
    "end": "512000"
  },
  {
    "text": "you are any user in force a but you can't pretend that you're a user in force b using the",
    "start": "512000",
    "end": "517120"
  },
  {
    "text": "interrupt ticket",
    "start": "517120",
    "end": "521839"
  },
  {
    "text": "before we continue i just want to so quickly highlight some previous work uh willen lee did some really nice work",
    "start": "524720",
    "end": "531040"
  },
  {
    "text": "on breaking forest trust last year this was built on camera delegation and that's very technical and we won't have",
    "start": "531040",
    "end": "536880"
  },
  {
    "text": "time to go into it but if you're interested in this definitely read out their blog on the link below this was fixed in 2019",
    "start": "536880",
    "end": "544000"
  },
  {
    "text": "so once after it was fixed it was no longer possible to break forest trust",
    "start": "544000",
    "end": "549440"
  },
  {
    "text": "which is why i decided to research a new way now before we start we have to go with",
    "start": "549440",
    "end": "555839"
  },
  {
    "text": "some assumptions so we assume that we have compromised first a someway and that anything in forest a is",
    "start": "555839",
    "end": "563120"
  },
  {
    "text": "under our control so anything that's on the domain controller on the server",
    "start": "563120",
    "end": "568240"
  },
  {
    "text": "or anything that's exchanged between force a and b that's something we can influence",
    "start": "568240",
    "end": "574240"
  },
  {
    "text": "and we also um assume that anything that is actually transferred can be modified we also",
    "start": "575440",
    "end": "580959"
  },
  {
    "text": "don't issue any non-default configuration or custom setup that's made by the organization",
    "start": "580959",
    "end": "586480"
  },
  {
    "text": "because if permissions are explicitly granted that's obviously not the vulnerability",
    "start": "586480",
    "end": "592320"
  },
  {
    "text": "so let's leave some questions what information is actually exchanged between the two first and can we modify this information in a",
    "start": "592640",
    "end": "599120"
  },
  {
    "text": "way that gains us an advantage to start",
    "start": "599120",
    "end": "604320"
  },
  {
    "text": "us off we need to look at trust transitivity and some people wonder like if there is a three forest",
    "start": "604320",
    "end": "611680"
  },
  {
    "text": "and both forest a and forest b trust each other and force b and force three terms to each other",
    "start": "611680",
    "end": "617200"
  },
  {
    "text": "does that mean that force a implicitly dressed for c well short answer",
    "start": "617200",
    "end": "624240"
  },
  {
    "text": "no that's not true so for forest transitive thrusts which is a thrust between two forests",
    "start": "624240",
    "end": "630320"
  },
  {
    "text": "both forests actually keep a list of domains and security identifiers that are present in the",
    "start": "630320",
    "end": "635600"
  },
  {
    "text": "other forest and only the security identifiers that are on that specific list",
    "start": "635600",
    "end": "640640"
  },
  {
    "text": "will pass the sit filtering so if so first a doesn't have any thrust with",
    "start": "640640",
    "end": "645680"
  },
  {
    "text": "first c and it doesn't even know it exists so if a ticket would somehow arrive uh",
    "start": "645680",
    "end": "651040"
  },
  {
    "text": "from forest c uh we would contain a lot of security identifiers that are in forest c and",
    "start": "651040",
    "end": "656160"
  },
  {
    "text": "force a would be like no you're not on the list i don't know what forrest is so it would completely drop the ticket",
    "start": "656160",
    "end": "662880"
  },
  {
    "text": "so even though trusts aren't called transitive it doesn't just mean that you can hop over trusts without doing",
    "start": "662880",
    "end": "669760"
  },
  {
    "text": "anything now we let's have a look at how these",
    "start": "669760",
    "end": "675519"
  },
  {
    "text": "trusts um work and how the data is stored and how the list of",
    "start": "675519",
    "end": "680560"
  },
  {
    "text": "um of trusted domains is kept so if we look in the in the active",
    "start": "680560",
    "end": "686160"
  },
  {
    "text": "directory users in computers there is a object which trusts the domain object",
    "start": "686160",
    "end": "691760"
  },
  {
    "text": "and it has the name of forest a so this object has a property called the msgs trust forest trust info",
    "start": "691760",
    "end": "699120"
  },
  {
    "text": "which is binary property containing data on the on the trust",
    "start": "699120",
    "end": "705360"
  },
  {
    "text": "we can decode this data it's documented so i wrote a small python script which uses structures from msadts",
    "start": "705360",
    "end": "712720"
  },
  {
    "text": "and basically you see that in this record it contains two pieces of data first is the",
    "start": "712720",
    "end": "720760"
  },
  {
    "text": "forestay.kbt.cloud root domain which has a security identifier and it also has the subdomain",
    "start": "720760",
    "end": "726880"
  },
  {
    "text": "which has a different security identifier so both these domains are stored in the force crystal info and any other domains",
    "start": "726880",
    "end": "733040"
  },
  {
    "text": "or other security identifiers won't pass through the sit filter",
    "start": "733040",
    "end": "737839"
  },
  {
    "text": "so this means looking back to this picture that we can go from force a to first b but we can only put sids in our ticket",
    "start": "738639",
    "end": "746160"
  },
  {
    "text": "that are trusted by forest b and that are on the list",
    "start": "746160",
    "end": "750959"
  },
  {
    "text": "now i wondered suppose a new subdomain is other than forest a does forest b automatically learn that",
    "start": "751440",
    "end": "757920"
  },
  {
    "text": "this new domain exists would it automatically trust it and how is it even communicated how will",
    "start": "757920",
    "end": "764720"
  },
  {
    "text": "force b find out that a new domain is added so i put it to the test and just said",
    "start": "764720",
    "end": "770959"
  },
  {
    "text": "some monitoring and logging and wireshark to see if there was any network traffic and i added a new subdomain to first aid",
    "start": "770959",
    "end": "779279"
  },
  {
    "text": "and as it turns out uh the the main controller of force b queries d to main control of force a",
    "start": "779279",
    "end": "784480"
  },
  {
    "text": "about every 24 hours choose the net logon protocol and use the netar",
    "start": "784480",
    "end": "789519"
  },
  {
    "text": "get forest trust information operation which it can use to get a list of all the domains in the",
    "start": "789519",
    "end": "797680"
  },
  {
    "text": "in the other forest it then uses the trust account which is the same trust account that's",
    "start": "797680",
    "end": "804639"
  },
  {
    "text": "which the password is used to sign the tickets it uses that account to authenticate the network on protocol has",
    "start": "804639",
    "end": "810560"
  },
  {
    "text": "a specific property and you can say that you're authenticating with a trust account and so you",
    "start": "810560",
    "end": "815920"
  },
  {
    "text": "so it can know that it's actually the other forest authenticating and even new forest if a new subdomain",
    "start": "815920",
    "end": "823120"
  },
  {
    "text": "is added in the forest they are automatically added to the msds trust for a stressed info property of",
    "start": "823120",
    "end": "829519"
  },
  {
    "text": "the trusted domain object so a new domain will automatically get added to the list",
    "start": "829519",
    "end": "834959"
  },
  {
    "text": "and users from the new domain can also log in in forest b",
    "start": "834959",
    "end": "840480"
  },
  {
    "text": "i wanted to see how the netlogong call works so i um wrote my own script that used",
    "start": "841199",
    "end": "847360"
  },
  {
    "text": "the network on protocol but but to authenticate i first had to dump the first keys so you can do it with payment",
    "start": "847360",
    "end": "854000"
  },
  {
    "text": "cuts you notice there are two thrust keys one for the incoming cursive",
    "start": "854000",
    "end": "859120"
  },
  {
    "text": "one for the outgoing trust because it's a bi-directional thrust and we see that the clear decks passwords",
    "start": "859120",
    "end": "864480"
  },
  {
    "text": "are the same that's only because the thrust is new and after 30 days both force will",
    "start": "864480",
    "end": "870240"
  },
  {
    "text": "on their own rotate these passwords and it will no longer be the same",
    "start": "870240",
    "end": "875360"
  },
  {
    "text": "so the md4 or the hd4 hmac for kerberos which is the well-known nth is also the",
    "start": "875360",
    "end": "881839"
  },
  {
    "text": "same because it's not salted but the aes keys they do contain assault so these are not identical for the",
    "start": "881839",
    "end": "888320"
  },
  {
    "text": "incoming and outgoing trust which is something you have to keep in mind when you're forging your own trust tickets that you",
    "start": "888320",
    "end": "893680"
  },
  {
    "text": "use the right key so using this trust um tickets or this",
    "start": "893680",
    "end": "899279"
  },
  {
    "text": "just password sorry and um actually using a tool get trust info.pi that is based on",
    "start": "899279",
    "end": "905920"
  },
  {
    "text": "impact and i authenticated to the domain controller and looked up the um the first trust info",
    "start": "905920",
    "end": "914079"
  },
  {
    "text": "in the same way that the u-main telephone force b will do that so you can see that it sends that net",
    "start": "914079",
    "end": "921600"
  },
  {
    "text": "logon request and it will get using the password of the trust",
    "start": "921600",
    "end": "926720"
  },
  {
    "text": "and it will get back a list with security identifiers so in this case we see that the security",
    "start": "926720",
    "end": "933120"
  },
  {
    "text": "identifier for the subdomain ends in its last block on two to one",
    "start": "933120",
    "end": "940880"
  },
  {
    "text": "so now that we have this information in theory we could add new domain sits on the other side of the",
    "start": "940880",
    "end": "946720"
  },
  {
    "text": "trust so if we add a new subdomain and we assume we control all information",
    "start": "946720",
    "end": "952560"
  },
  {
    "text": "we could use a custom security identifier and add that to the trusslist",
    "start": "952560",
    "end": "957759"
  },
  {
    "text": "however this is really useful because we cannot use any existing domain in 4sb because 4hb knows which domains are in",
    "start": "957759",
    "end": "964720"
  },
  {
    "text": "its own domain and it will not accept new new security identifiers that are in its own domain or any or any",
    "start": "964720",
    "end": "972240"
  },
  {
    "text": "other trusted forest so you can't use any security identifier that force b",
    "start": "972240",
    "end": "977519"
  },
  {
    "text": "is already aware of so i really started digging into into",
    "start": "977519",
    "end": "984079"
  },
  {
    "text": "this and couldn't really find a way um except when i started digging into what is really a domain",
    "start": "984079",
    "end": "990560"
  },
  {
    "text": "and you can figure that out by asking a domain joint computer or server how many domains do",
    "start": "990560",
    "end": "996320"
  },
  {
    "text": "you trust and where you would expect it to say i trust only one the ad the active directory i'm joined",
    "start": "996320",
    "end": "1003120"
  },
  {
    "text": "to it will tell you that it just trusts two domains the active directory domain that is joined to",
    "start": "1003120",
    "end": "1008560"
  },
  {
    "text": "but also its local domain which is stored in the in the registry and in the sam partition and this local domain also has",
    "start": "1008560",
    "end": "1016480"
  },
  {
    "text": "a domain sit and it has relative security identifiers",
    "start": "1016480",
    "end": "1021519"
  },
  {
    "text": "a well-known one is the 500 account which is the built-in administrator account but you can also have other local users",
    "start": "1021519",
    "end": "1027678"
  },
  {
    "text": "which will have their own security identifiers but they all have the domain prefix of this local domain",
    "start": "1027679",
    "end": "1033839"
  },
  {
    "text": "on that server or computer an active directory is not aware of all",
    "start": "1033839",
    "end": "1039600"
  },
  {
    "text": "the security identifiers of each member computer and i wondered how much does a computer",
    "start": "1039600",
    "end": "1047360"
  },
  {
    "text": "really trust its domain so if we send it a service ticket that",
    "start": "1047360",
    "end": "1053200"
  },
  {
    "text": "is encrypted with its passwords would it blindly accept that and as an experiment i created two service tickets",
    "start": "1053200",
    "end": "1060080"
  },
  {
    "text": "so i created a fake service ticket with the security identifiers of a user without any special privileges",
    "start": "1060080",
    "end": "1066320"
  },
  {
    "text": "which normally shouldn't be able to do much on that machine except authenticate and i also created a service ticket",
    "start": "1066320",
    "end": "1071760"
  },
  {
    "text": "where i included the local domain set of this of the server nd500 account for the",
    "start": "1071760",
    "end": "1077919"
  },
  {
    "text": "local administrator as an extra security identifier so let's see what it does first we",
    "start": "1077919",
    "end": "1084799"
  },
  {
    "text": "create a silver ticket you can do this using the impactor.py",
    "start": "1084799",
    "end": "1090240"
  },
  {
    "text": "it's one of the examples that is included and we just have to supply all the information in this case i use the aes",
    "start": "1090240",
    "end": "1096640"
  },
  {
    "text": "key of the computer account because this is test and i just wanted to see if the computer accepted it",
    "start": "1096640",
    "end": "1104240"
  },
  {
    "text": "so this user is not in any special groups and as expected we get an access denied error because it",
    "start": "1104400",
    "end": "1110240"
  },
  {
    "text": "can authenticate but it doesn't have any rights on the server it's just a normal domain user",
    "start": "1110240",
    "end": "1115760"
  },
  {
    "text": "and we cannot do anything with it so if we connect over smb we try to list the c",
    "start": "1115760",
    "end": "1121120"
  },
  {
    "text": "c drive which is limited to admin only we get access denied as expected now we create a new silver",
    "start": "1121120",
    "end": "1128640"
  },
  {
    "text": "ticket and this time the user is also only part of the main users so it's not a special user it's not a",
    "start": "1128640",
    "end": "1134640"
  },
  {
    "text": "domain admin but we add extra security identifier to the fake ticket that we created",
    "start": "1134640",
    "end": "1140559"
  },
  {
    "text": "and this security identifier contains the local domain and the 500 user accounts so it",
    "start": "1140559",
    "end": "1146880"
  },
  {
    "text": "basically says that we are also the local administrator on that computer",
    "start": "1146880",
    "end": "1152720"
  },
  {
    "text": "i mentioned am i surprised this worked so we can pretend that we are the local administrator user",
    "start": "1152720",
    "end": "1158880"
  },
  {
    "text": "on this computer and we can actually use the c drive so the computer accepts that that we are",
    "start": "1158880",
    "end": "1166720"
  },
  {
    "text": "the administrator user even though this directory shouldn't be managing that administrator user",
    "start": "1166720",
    "end": "1172080"
  },
  {
    "text": "and it definitely shouldn't be ending up in kerberos tickets",
    "start": "1172080",
    "end": "1178080"
  },
  {
    "text": "so active directory doesn't manage the local domains but still if you use if you include one security",
    "start": "1178080",
    "end": "1183840"
  },
  {
    "text": "identifier from the local domain then the computer will for some reason accept it so this is clearly an issue because we",
    "start": "1183840",
    "end": "1192080"
  },
  {
    "text": "because active directory shouldn't be sending those along and the computer shouldn't blindly trust these service tickets even",
    "start": "1192080",
    "end": "1198480"
  },
  {
    "text": "if it contains a security identifier that's not from active directory and we see that local admin access is",
    "start": "1198480",
    "end": "1204799"
  },
  {
    "text": "granted when either you pretend that the ticket is from the local domain",
    "start": "1204799",
    "end": "1210080"
  },
  {
    "text": "while the local domain doesn't have a domain controller so it doesn't even use kerberos but you can also include it as",
    "start": "1210080",
    "end": "1216640"
  },
  {
    "text": "an extra sit so these are two different ways to get an admin access fun fact this also",
    "start": "1216640",
    "end": "1222240"
  },
  {
    "text": "works when a local admin account is disabled so if you add an extra security identifier it will completely ignore",
    "start": "1222240",
    "end": "1228000"
  },
  {
    "text": "that this account is disabled and just gives you the access you want",
    "start": "1228000",
    "end": "1232480"
  },
  {
    "text": "so using this information um we can design a new forest trusted deck",
    "start": "1233039",
    "end": "1238480"
  },
  {
    "text": "and for that we'll just go back to the drawing board real quick",
    "start": "1238480",
    "end": "1249840"
  },
  {
    "text": "if it wants to work yes so here we see the",
    "start": "1255280",
    "end": "1262799"
  },
  {
    "text": "um the same picture we saw previously i just drew out the subdomain a bit more clear so we see on the left the first a with",
    "start": "1262799",
    "end": "1270400"
  },
  {
    "text": "the subdomain and on the right we see first b now what if we pretend that there's a",
    "start": "1270400",
    "end": "1278880"
  },
  {
    "text": "new subdomain so it's in red and this new subdomain has the same",
    "start": "1278880",
    "end": "1285200"
  },
  {
    "text": "security identifier as a server in this forest",
    "start": "1285200",
    "end": "1292000"
  },
  {
    "text": "so first b will automatically query this information every 24 hours and then actually it will",
    "start": "1292159",
    "end": "1298240"
  },
  {
    "text": "get back to data that there's a new that there's a new domain having the",
    "start": "1298240",
    "end": "1303520"
  },
  {
    "text": "security identifier of the server because forest b is not aware of all the local domains and all the local",
    "start": "1303520",
    "end": "1310000"
  },
  {
    "text": "security identifiers that are in the uh in its own domain it will accept",
    "start": "1310000",
    "end": "1315679"
  },
  {
    "text": "this and it will add the security identifier of the server that is actually in force b will",
    "start": "1315679",
    "end": "1322720"
  },
  {
    "text": "add it to the list of security identifiers that accepted that is accepted from forest a",
    "start": "1322720",
    "end": "1333760"
  },
  {
    "text": "so there are a few missing pieces for this um first we need to convert the theory of spoofing a domain into",
    "start": "1333760",
    "end": "1340080"
  },
  {
    "text": "practice and figure out how that works and of course we also need to somehow obtain the local sit",
    "start": "1340080",
    "end": "1346320"
  },
  {
    "text": "of this victim computer that we want to compromise because this is not something that you can guess and it's not",
    "start": "1346320",
    "end": "1352080"
  },
  {
    "text": "something you can query from active directory because active directory doesn't actually know these local sets so let's start with",
    "start": "1352080",
    "end": "1359919"
  },
  {
    "text": "that we can obtain the local sets on all the windows versions using somewhere rpc",
    "start": "1359919",
    "end": "1365520"
  },
  {
    "text": "which is also how bloodhound queries local groups in the domain but for versions that are newer than",
    "start": "1365520",
    "end": "1372320"
  },
  {
    "text": "windows 10 1607 or for server 2019 this is actually not going to work",
    "start": "1372320",
    "end": "1377679"
  },
  {
    "text": "because you need admin access and if you already have access admin access then what's the point of still doing the",
    "start": "1377679",
    "end": "1382880"
  },
  {
    "text": "attack but there's another api that we can use so we can use this function over rpc",
    "start": "1382880",
    "end": "1389280"
  },
  {
    "text": "from mslset which is the lookup names function which translates a security principle",
    "start": "1389280",
    "end": "1395520"
  },
  {
    "text": "name to their sit form so if we know the security principle name which is the hostname",
    "start": "1395520",
    "end": "1401360"
  },
  {
    "text": "of the computer we can ask it to translate this to the security identifier",
    "start": "1401360",
    "end": "1407120"
  },
  {
    "text": "this is great i also wrote a small script using impact again and",
    "start": "1407120",
    "end": "1414240"
  },
  {
    "text": "using that we can use the user from forest a and authenticate to the server on forest",
    "start": "1414240",
    "end": "1419840"
  },
  {
    "text": "b that can do that because there is a trust in place and we can query the local sit",
    "start": "1419840",
    "end": "1425679"
  },
  {
    "text": "which doesn't require any admin privileges so now we know the local set of this",
    "start": "1425679",
    "end": "1431200"
  },
  {
    "text": "server that we want to compromise now we actually need to spoof a domain",
    "start": "1431200",
    "end": "1438640"
  },
  {
    "text": "there are multiple ways to do that the first one would be to actually add a new sub domain to",
    "start": "1438640",
    "end": "1444240"
  },
  {
    "text": "forest a we would promote a member server and somehow we needed to we would need to make sure",
    "start": "1444240",
    "end": "1449440"
  },
  {
    "text": "that the security identifier that's generated for this new domain ac security attempt is the same as the",
    "start": "1449440",
    "end": "1455360"
  },
  {
    "text": "security identifier that we want to attack a second way would be to actually modify",
    "start": "1455360",
    "end": "1460880"
  },
  {
    "text": "the forest structure via ldap or via dc shadow and other required objects",
    "start": "1460880",
    "end": "1466400"
  },
  {
    "text": "that that would represent the subdomain so we could kind of fool the domain controller into thinking that",
    "start": "1466400",
    "end": "1472400"
  },
  {
    "text": "has more sub domains than it actually has this is kind of hard",
    "start": "1472400",
    "end": "1477520"
  },
  {
    "text": "a way that's less invasive is to actually hook lcs when the net r get the first trust information",
    "start": "1478080",
    "end": "1484400"
  },
  {
    "text": "request is processed and actually are the block containing the data for an extra domain",
    "start": "1484400",
    "end": "1491278"
  },
  {
    "text": "but it is also not that easy there turned out to be a lot of functions so in the end the option i went for is",
    "start": "1491600",
    "end": "1496640"
  },
  {
    "text": "just to hook lcs and and intercept the netark at first trust information call",
    "start": "1496640",
    "end": "1502720"
  },
  {
    "text": "and replace the security identifier of an existing domain with the target security identifier",
    "start": "1502720",
    "end": "1509679"
  },
  {
    "text": "now of course these are not actually easy methods so it took me a lot of time to actually figure this out",
    "start": "1510640",
    "end": "1515840"
  },
  {
    "text": "and there was quite some reversion involved as well but i'll log you to the process first you need to",
    "start": "1515840",
    "end": "1522480"
  },
  {
    "text": "somehow debug lss which is a tricky thing because if you crash it then your pc",
    "start": "1522480",
    "end": "1527600"
  },
  {
    "text": "basically reboots and you can start again but once you finally got it working um",
    "start": "1527600",
    "end": "1532799"
  },
  {
    "text": "you can place a break place a breakpoint on the netark at first trust the information call and basically just step through the",
    "start": "1532799",
    "end": "1539360"
  },
  {
    "text": "functions that are called and see what happens under the hood and at some point i ended up in the",
    "start": "1539360",
    "end": "1545279"
  },
  {
    "text": "function which actually builds the the resulting data blocks of the",
    "start": "1545279",
    "end": "1550320"
  },
  {
    "text": "rpc call and at some point in that function there",
    "start": "1550320",
    "end": "1555919"
  },
  {
    "text": "is there is a function which calculates the length of the security identifier this is a very",
    "start": "1555919",
    "end": "1561919"
  },
  {
    "text": "straightforward function to hook because that's just one argument which is the security identifier so we know for sure that at the moment",
    "start": "1561919",
    "end": "1569360"
  },
  {
    "text": "that this function is called that issue that the first argument",
    "start": "1569360",
    "end": "1574640"
  },
  {
    "text": "will will point to the security identifier of the forest and because it's the third argument uh",
    "start": "1574640",
    "end": "1581279"
  },
  {
    "text": "in exit c4 that's stored as a pointer in the rc-x register and if we look at the heap we see that",
    "start": "1581279",
    "end": "1589520"
  },
  {
    "text": "the security identifier is stored there and it's pointed to by rcx you well you have to believe me on this",
    "start": "1589520",
    "end": "1596320"
  },
  {
    "text": "that this is actually the security identifier now what you can do is obviously attach",
    "start": "1596320",
    "end": "1603200"
  },
  {
    "text": "the debugger to elsa's wait for the calls to come in and then manually intercept it replace the memory but it's",
    "start": "1603200",
    "end": "1609039"
  },
  {
    "text": "kind of tedious and you really have to get the timing right because at some point rpc will just time out and it will",
    "start": "1609039",
    "end": "1614559"
  },
  {
    "text": "do nothing basically so what i did is i automated thing and i used friday",
    "start": "1614559",
    "end": "1621200"
  },
  {
    "text": "so what i actually did was intercept the rtl length hit function which is",
    "start": "1621200",
    "end": "1626960"
  },
  {
    "text": "imported from nt dll and once once this function is called i look if it",
    "start": "1626960",
    "end": "1632320"
  },
  {
    "text": "if the return address of the function call is returning to the place in lsadp which is where the the function",
    "start": "1632320",
    "end": "1639760"
  },
  {
    "text": "that we were previously looking at returns so if it's if this address matches then i know it's called from",
    "start": "1639760",
    "end": "1646640"
  },
  {
    "text": "a place in the in in lss where the block is built and we can just replace",
    "start": "1646640",
    "end": "1651840"
  },
  {
    "text": "the sid that we're looking for with the seat that we want to replace",
    "start": "1651840",
    "end": "1657120"
  },
  {
    "text": "let's see this in action so remember that before we queried um the net log on call and we saw that",
    "start": "1658559",
    "end": "1665279"
  },
  {
    "text": "this this of course the software was returned now we run friday and we basically",
    "start": "1665279",
    "end": "1671120"
  },
  {
    "text": "intercept the security identifier when it's queried so if we run these this tool again we",
    "start": "1671120",
    "end": "1676799"
  },
  {
    "text": "see that this time a completely different city's returned which also happens to be",
    "start": "1676799",
    "end": "1682080"
  },
  {
    "text": "the set of the workstation that we want to attack so now we can actually intercept that",
    "start": "1682080",
    "end": "1687200"
  },
  {
    "text": "call and make sure that when force b queries first a that this security identifier will be different",
    "start": "1687200",
    "end": "1695120"
  },
  {
    "text": "and now we have to wait 24 hours or we can speed up the process a bit and there's actually a way to force this",
    "start": "1695279",
    "end": "1703279"
  },
  {
    "text": "to query so if you go to the trust properties and then you save the present details",
    "start": "1703279",
    "end": "1709360"
  },
  {
    "text": "then it will will perform the query as well and then it will also update it",
    "start": "1709360",
    "end": "1714399"
  },
  {
    "text": "of course it doesn't work in real life because this would require require access to force b but to demonstrate it it's it's just to",
    "start": "1714399",
    "end": "1721279"
  },
  {
    "text": "make it a bit easier if we look at the forest trust info again we see that now the security",
    "start": "1721279",
    "end": "1727840"
  },
  {
    "text": "identifier is different from before and we see that sub.forest a certainly has the same",
    "start": "1727840",
    "end": "1734000"
  },
  {
    "text": "security identifier that we queried from the workstation that we wanted to attack so here you see the local sit",
    "start": "1734000",
    "end": "1740960"
  },
  {
    "text": "from forest b server now matches the sit that for the things that our subdomain has",
    "start": "1740960",
    "end": "1748158"
  },
  {
    "text": "now here's where it gets a little more complicated so now we're going to create our own inter-realm ticket granting tickets",
    "start": "1748320",
    "end": "1756399"
  },
  {
    "text": "what you do here is that you create a tgt and you sign it with the trust key and",
    "start": "1756399",
    "end": "1762159"
  },
  {
    "text": "you add the extra security identifier of the local domain that we want to attack to the tt",
    "start": "1762159",
    "end": "1771760"
  },
  {
    "text": "and this is interrupted so it's it's originating from first a and it'll be sent to forest b",
    "start": "1771760",
    "end": "1780080"
  },
  {
    "text": "now we use that to ask for a service ticket enforce b and we specify the target",
    "start": "1780080",
    "end": "1786799"
  },
  {
    "text": "domain we specify the originating domain this is also custom script that i",
    "start": "1786799",
    "end": "1792480"
  },
  {
    "text": "changed a bit so i can see what's actually returned in the ticket and verified it works",
    "start": "1792480",
    "end": "1798000"
  },
  {
    "text": "and we request access to the sifs spn which is used for smp to request a",
    "start": "1798000",
    "end": "1803919"
  },
  {
    "text": "service ticket to talk to smb on server server b and if we",
    "start": "1803919",
    "end": "1811279"
  },
  {
    "text": "decrypt the resulting service ticket and you see all these values from the sit from the",
    "start": "1811279",
    "end": "1817760"
  },
  {
    "text": "front pack and you see that in extra sits the the sit that we inserted it passes",
    "start": "1817760",
    "end": "1824640"
  },
  {
    "text": "so far b considers it valid and we have now an extra security identifier in our list",
    "start": "1824640",
    "end": "1830320"
  },
  {
    "text": "which um which should allow us to log in on the server so let's test this we give the ticket to",
    "start": "1830320",
    "end": "1838799"
  },
  {
    "text": "smp client we make it connect to the first d server and we see that indeed we can request",
    "start": "1838799",
    "end": "1845279"
  },
  {
    "text": "now the c drive as if we were an administrator so now we complete successfully used",
    "start": "1845279",
    "end": "1851600"
  },
  {
    "text": "only our axes in forest a to compromise a server in force b now this only works",
    "start": "1851600",
    "end": "1857120"
  },
  {
    "text": "on a on a domain only works on member servers not on the main controllers because",
    "start": "1857120",
    "end": "1862159"
  },
  {
    "text": "these don't have a local domain but still there are probably plenty of high value servers",
    "start": "1862159",
    "end": "1868080"
  },
  {
    "text": "in force b as well that we want to compromise now list is using impact you can also do",
    "start": "1868080",
    "end": "1874960"
  },
  {
    "text": "this using mimikatz and ko that also makes it easy to do the windows",
    "start": "1874960",
    "end": "1881039"
  },
  {
    "text": "so first using mimikatz we create the golden ticket we specify the same parameters as before",
    "start": "1881039",
    "end": "1886640"
  },
  {
    "text": "so the local security identifier and the aes trust key then i start a new",
    "start": "1886640",
    "end": "1893120"
  },
  {
    "text": "session using renass which is just a clean way to start a new session without",
    "start": "1893120",
    "end": "1898159"
  },
  {
    "text": "any existing carroll tickets in memory and we start kakeo and kakeo contains",
    "start": "1898159",
    "end": "1905600"
  },
  {
    "text": "a lot more kerberos tools than that mimikatz does you can also use rubios",
    "start": "1905600",
    "end": "1911120"
  },
  {
    "text": "which is a g-sharp rewrite but in this case we're using ko and we actually",
    "start": "1911120",
    "end": "1916240"
  },
  {
    "text": "instructed to request a service ticket in first b and to submit that in our session",
    "start": "1916240",
    "end": "1922960"
  },
  {
    "text": "so now we can list the ticket and we see that that we have the ticket in memory and",
    "start": "1922960",
    "end": "1929039"
  },
  {
    "text": "even with a fake username we can actually list the c drive so that means that we successfully reproduce the",
    "start": "1929039",
    "end": "1934960"
  },
  {
    "text": "same thing here and we are actually now an administrator on forest b",
    "start": "1934960",
    "end": "1940240"
  },
  {
    "text": "just a few notes about this attack so it can be used to compromise any non-domain controller in a trusting",
    "start": "1942720",
    "end": "1948480"
  },
  {
    "text": "forest it does work with the one-way trust but you will need one account in the",
    "start": "1948480",
    "end": "1953600"
  },
  {
    "text": "other trust to actually query the local security identifier because you have to obtain that somehow it doesn't work",
    "start": "1953600",
    "end": "1960720"
  },
  {
    "text": "against the thrust direction so if you have a one-way trust which is outgoing which means that you trust the",
    "start": "1960720",
    "end": "1967440"
  },
  {
    "text": "other domain and not the other way around then you cannot perform this attack",
    "start": "1967440",
    "end": "1972960"
  },
  {
    "text": "i disclosed it to msrc in october 2019 and because it was quite a complex batch",
    "start": "1973200",
    "end": "1979200"
  },
  {
    "text": "day we agreed on february 2020 as a batching date and they released a patch in february on",
    "start": "1979200",
    "end": "1985600"
  },
  {
    "text": "past tuesday and assigned six cve2020665 one away from 666 which would have been",
    "start": "1985600",
    "end": "1991760"
  },
  {
    "text": "cool so this is actually fixed and if you pat your servers",
    "start": "1991760",
    "end": "1996960"
  },
  {
    "text": "then you don't have to worry about this attack anymore some general conclusions even though",
    "start": "1996960",
    "end": "2003919"
  },
  {
    "text": "trust is sometimes or sometimes not recognized as a security boundary a trust still implies that you trust the",
    "start": "2003919",
    "end": "2011600"
  },
  {
    "text": "other side so if the other side gets compromised then something you trust gets",
    "start": "2011600",
    "end": "2016720"
  },
  {
    "text": "compromised and you cannot just assume that because it's trust that you cannot move",
    "start": "2016720",
    "end": "2022000"
  },
  {
    "text": "over interest and what we see so here is that this does require some network",
    "start": "2022000",
    "end": "2028080"
  },
  {
    "text": "access for to domain controllers and to servers and if you have good firewalling and",
    "start": "2028080",
    "end": "2033919"
  },
  {
    "text": "network segmentation on top of your trusts and strict settings that",
    "start": "2033919",
    "end": "2039519"
  },
  {
    "text": "would prevent against this attack as well and even though extended transitivity is",
    "start": "2039519",
    "end": "2044960"
  },
  {
    "text": "not a thing so we couldn't go from first a to first c directly if you compromise one thrust at a time",
    "start": "2044960",
    "end": "2051200"
  },
  {
    "text": "you can still hop over so in this case we could reproduce this exactly we did against force b we",
    "start": "2051200",
    "end": "2057040"
  },
  {
    "text": "could also extend that to first c after compromising force b so if you have multiple trusts then this",
    "start": "2057040",
    "end": "2063520"
  },
  {
    "text": "chain of compromise can really get long some acknowledgements of course this",
    "start": "2063520",
    "end": "2070480"
  },
  {
    "text": "research built forts on a lot of other people's work especially those who also like to dig into gerald's technicalities",
    "start": "2070480",
    "end": "2077358"
  },
  {
    "text": "and those who like to work tools and tutorials so thanks a lot to them as well and to",
    "start": "2077359",
    "end": "2084398"
  },
  {
    "text": "conclude i did upload my scripts on my github so if you want to reproduce this",
    "start": "2084399",
    "end": "2090320"
  },
  {
    "text": "yourself as well you can look at the forest rust tools repository questions are welcome you can add ask",
    "start": "2090320",
    "end": "2096638"
  },
  {
    "text": "them here live in the comments or via dm on twitter later and i'll do my best to answer them",
    "start": "2096639",
    "end": "2102560"
  },
  {
    "text": "thank you for listening and i hope you learned something new and fun bye",
    "start": "2102560",
    "end": "2110160"
  }
]