[
  {
    "start": "0",
    "end": "38000"
  },
  {
    "text": "I'm here today to present drop the rob a fine grenade control flow integrity for the Linux kernel so how's it going how's",
    "start": "0",
    "end": "8550"
  },
  {
    "text": "black hat it's fun right so many gifts okay so uh just work in this one is this",
    "start": "8550",
    "end": "15900"
  },
  {
    "text": "presentation I'm going to introduce Casey Fi which is a de facto implementation of fine grenade control",
    "start": "15900",
    "end": "22529"
  },
  {
    "text": "integrity for Linux kernels and this work was developed in collaboration between the University of Campinas which",
    "start": "22529",
    "end": "29160"
  },
  {
    "text": "is my former University Columbia University and Bravo University and it was developed by my colleagues here and",
    "start": "29160",
    "end": "35700"
  },
  {
    "text": "listed and by me I am Jean Madera Brazilian dude here in Singapore by the",
    "start": "35700",
    "end": "43530"
  },
  {
    "start": "38000",
    "end": "66000"
  },
  {
    "text": "time we developed KCF I was a PhD candidate at the University of Campinas currently no longer a PhD student now",
    "start": "43530",
    "end": "52110"
  },
  {
    "text": "I'm a PhD thanks God and I'm currently working as a live fashion engineer at Sousa so I'm",
    "start": "52110",
    "end": "58410"
  },
  {
    "text": "still hacking the kernel and doing stuff related to I mean kernel itself and",
    "start": "58410",
    "end": "63930"
  },
  {
    "text": "kernel source code so let's get it on so this is our agenda this is basically",
    "start": "63930",
    "end": "69330"
  },
  {
    "start": "66000",
    "end": "110000"
  },
  {
    "text": "what you're going to talk first we're going to do a quick review on kernel return-oriented programming and check",
    "start": "69330",
    "end": "75390"
  },
  {
    "text": "out why this is a thing and then I'm going to give a quick look at comfortable integrity showing its",
    "start": "75390",
    "end": "82350"
  },
  {
    "text": "limitation and the no issues regarding CFI suffice - like a big name currently",
    "start": "82350",
    "end": "87420"
  },
  {
    "text": "but we have to to pinpoint what are the problems behind CFI and then i'm going",
    "start": "87420",
    "end": "93150"
  },
  {
    "text": "to talk about case efi itself which is our implementation I'm going to give some technical details regarding it then",
    "start": "93150",
    "end": "99930"
  },
  {
    "text": "I'm going to talk about which are the improvements that case EFI brings over known CFI issues and then I'm going to",
    "start": "99930",
    "end": "108479"
  },
  {
    "text": "talk a little bit regarding its performance okay so I would have to start talking from the beginning and",
    "start": "108479",
    "end": "114329"
  },
  {
    "start": "110000",
    "end": "134000"
  },
  {
    "text": "because of that we have to talk about memory and safety bugs and as yes most",
    "start": "114329",
    "end": "120689"
  },
  {
    "text": "of you might know I mean memory memory memory bugs memory problems may allow attackers to override code pointers so",
    "start": "120689",
    "end": "127799"
  },
  {
    "text": "they may have control over called pointers be like a function pointer or return address which is on the stack",
    "start": "127799",
    "end": "134040"
  },
  {
    "start": "134000",
    "end": "159000"
  },
  {
    "text": "and because of that they can achieve something that we call control flow hijacking so basically they are able to",
    "start": "134040",
    "end": "139290"
  },
  {
    "text": "achieve arbitrary code execution so imagine that there's like a function pointer in your memory and an attacker",
    "start": "139290",
    "end": "146580"
  },
  {
    "text": "finds a bug that allows him to overwrite whatever value he wants in memory then he can corrupt this this function",
    "start": "146580",
    "end": "154620"
  },
  {
    "text": "pointer which is in memory and then redirect your code towards whatever he wants of course as this is a big issue",
    "start": "154620",
    "end": "161640"
  },
  {
    "start": "159000",
    "end": "402000"
  },
  {
    "text": "there are like many mitigation for this problem so first first mitigation first",
    "start": "161640",
    "end": "167340"
  },
  {
    "text": "one on mitigation is the right execute policies so basically this consists in whenever you have a memory page this",
    "start": "167340",
    "end": "174299"
  },
  {
    "text": "page is either writable or executable but never both so by doing something like this you prevent an attacker for",
    "start": "174299",
    "end": "180870"
  },
  {
    "text": "example to inject malicious payload in your data sections so he's not going to",
    "start": "180870",
    "end": "186959"
  },
  {
    "text": "put code there which is this guy's this data and then redirect control towards whatever he may have injected so he is",
    "start": "186959",
    "end": "194280"
  },
  {
    "text": "not allowed to do that anymore we also have a SLR which is address space layout randomization which",
    "start": "194280",
    "end": "200549"
  },
  {
    "text": "basically consists in whatever whenever you run your your program the data structures and the functions they are in",
    "start": "200549",
    "end": "208079"
  },
  {
    "text": "different memory positions and by doing that you prevent an attacker for from",
    "start": "208079",
    "end": "213419"
  },
  {
    "text": "knowing the addresses of the things that he needs to corrupt or choose or from",
    "start": "213419",
    "end": "218459"
  },
  {
    "text": "knowing where he needs to resurrect contraflow to so this server lives like some sort of obfuscation of course that",
    "start": "218459",
    "end": "225810"
  },
  {
    "text": "there are also ways to bypass these litigations so here we're talking first",
    "start": "225810",
    "end": "230880"
  },
  {
    "text": "about code reuse attacks so code reuse we basically exploit functions which are",
    "start": "230880",
    "end": "238650"
  },
  {
    "text": "already in your inner program so of course that you have a program you have executable code in this in its program",
    "start": "238650",
    "end": "245129"
  },
  {
    "text": "so what an attacker will do he will basically use this code which is already in memory to perform his his deeds so",
    "start": "245129",
    "end": "253250"
  },
  {
    "text": "basically he this memory pages which hold code they are already marked as",
    "start": "253250",
    "end": "258539"
  },
  {
    "text": "executable so this won't be a problem for him to resurrect code there also we",
    "start": "258539",
    "end": "265140"
  },
  {
    "text": "have like memory disclosure bugs that enable an attacker to read arbitrarily from memory and by doing",
    "start": "265140",
    "end": "270900"
  },
  {
    "text": "that he is able to in fear which are the addresses that in easier corridor places",
    "start": "270900",
    "end": "275970"
  },
  {
    "text": "the where he needs to points to point the the code point issues so he's able to in fear which is the randomization of",
    "start": "275970",
    "end": "282690"
  },
  {
    "text": "said use it by the ASL RN bypass the sort of protection and specifically for",
    "start": "282690",
    "end": "287789"
  },
  {
    "text": "the kernel setting we have something that we call return to user attacks so I imagine that an attacker controls a",
    "start": "287789",
    "end": "293550"
  },
  {
    "text": "process which is in user space so he knows the addresses of everything inside",
    "start": "293550",
    "end": "298560"
  },
  {
    "text": "this process so and he also is able to control the page permissions in this",
    "start": "298560",
    "end": "304620"
  },
  {
    "text": "process because he owns this process and thinks he is able to do all that whenever he can exploit bug in the",
    "start": "304620",
    "end": "312720"
  },
  {
    "text": "kernel space in the kernel in the kernel code he can redirect the kernel execution flow towards the user space",
    "start": "312720",
    "end": "319620"
  },
  {
    "text": "memory does bypassing both of the web write text or execute and a SLR so this",
    "start": "319620",
    "end": "325860"
  },
  {
    "text": "is a big thing of course that because of return to user attacks some ideas were",
    "start": "325860",
    "end": "332039"
  },
  {
    "text": "also proposed and the most prominent is the strong address space isolation which basically consists in preventing some",
    "start": "332039",
    "end": "339570"
  },
  {
    "text": "sort of abuses so for example kernel code I mean the kernel context is never",
    "start": "339570",
    "end": "346050"
  },
  {
    "text": "supposed to execute instructions which are in the user space so this is obviously something abnormal and should",
    "start": "346050",
    "end": "352740"
  },
  {
    "text": "be prevented so because of that we have this implementations that try to not",
    "start": "352740",
    "end": "359190"
  },
  {
    "text": "allow the sort of thing so if you're in the kernel context in your trying to run instruction which is an in memory page",
    "start": "359190",
    "end": "365370"
  },
  {
    "text": "marked as a user space page you're not going to be able to do it so the sort of",
    "start": "365370",
    "end": "370409"
  },
  {
    "text": "thing is even implemented in hardware nowadays you have intel's s map which is a hardware extension for preventing the",
    "start": "370409",
    "end": "376889"
  },
  {
    "text": "Seraph abuse but because of these protections because these protections are becoming really common attackers",
    "start": "376889",
    "end": "383639"
  },
  {
    "text": "developed something called drop which is return oriented programming and return oriented programming we basically reuse",
    "start": "383639",
    "end": "390440"
  },
  {
    "text": "code so it's a it's a code reuse attack but it's",
    "start": "390440",
    "end": "395889"
  },
  {
    "text": "actually we use it in a special way to achieve Turing complete computation so",
    "start": "395889",
    "end": "402759"
  },
  {
    "start": "402000",
    "end": "461000"
  },
  {
    "text": "as I said it's going to reuse kernel code and it's going to use a concept that we call gadgets so gadgets are",
    "start": "402759",
    "end": "409599"
  },
  {
    "text": "actually small instruction sequences which are ended by an indirect branch when you're talking about Rob you are",
    "start": "409599",
    "end": "416139"
  },
  {
    "text": "normally talking about the return instruction and these gadgets can be freely changed through a through",
    "start": "416139",
    "end": "422800"
  },
  {
    "text": "corrupting the stack so imagine that an attacker can exploit a bug that allows",
    "start": "422800",
    "end": "428440"
  },
  {
    "text": "him to overwrite your stack and he's going to put a lot of return address",
    "start": "428440",
    "end": "434139"
  },
  {
    "text": "there there as he wants to and he's going to redirect control to a gadget which we run maybe one or two",
    "start": "434139",
    "end": "439720"
  },
  {
    "text": "instructions and then run return when it's running a return it's going to take the next address from the stack which is",
    "start": "439720",
    "end": "446229"
  },
  {
    "text": "controlled by the attacker then it's going to get the execution flow will go to another gadget that you run one or",
    "start": "446229",
    "end": "452380"
  },
  {
    "text": "two instructions and then run a ret and things like this so it's basically reusing the last instructions on each",
    "start": "452380",
    "end": "459759"
  },
  {
    "text": "function which is already present on the code so let's see how it goes so we want",
    "start": "459759",
    "end": "465220"
  },
  {
    "start": "461000",
    "end": "516000"
  },
  {
    "text": "to run a wrap attack to actually bypass a strong address space isolation so",
    "start": "465220",
    "end": "471820"
  },
  {
    "text": "basically what we want to do is we want to disable strong address space isolation and then we want to return",
    "start": "471820",
    "end": "476860"
  },
  {
    "text": "into user space so imagine that an attacker has exploited memory corruption bug and over returned the stack with",
    "start": "476860",
    "end": "484509"
  },
  {
    "text": "with the values that he wants and this first address which is in the the top of",
    "start": "484509",
    "end": "491320"
  },
  {
    "text": "the stack here is the address of this gadget this gadget is like it's the less",
    "start": "491320",
    "end": "496810"
  },
  {
    "text": "instructions in in a function so what is gadget will do is to first run a pop rocks right and when it runs the pop",
    "start": "496810",
    "end": "505120"
  },
  {
    "text": "rocks but what will it do so this equation was rejected there so he will",
    "start": "505120",
    "end": "510280"
  },
  {
    "text": "take the first value on the top of the stack and put it inside rocks right",
    "start": "510280",
    "end": "515709"
  },
  {
    "text": "so basically rocks will contain the value that we call as map killer here we",
    "start": "515709",
    "end": "521500"
  },
  {
    "start": "516000",
    "end": "577000"
  },
  {
    "text": "call it as macular because this value with a specific value that you must put into a control read search disabled web",
    "start": "521500",
    "end": "527320"
  },
  {
    "text": "map so that's what we want to do and when it runs the read what what's it",
    "start": "527320",
    "end": "533529"
  },
  {
    "text": "going to do it will take the next address in the stack and read read control flow there and now it's the",
    "start": "533529",
    "end": "538630"
  },
  {
    "text": "address of another gadget that will run more rocks inside here for and notice",
    "start": "538630",
    "end": "544779"
  },
  {
    "text": "here that here for is the control register that actually controls if Earth",
    "start": "544779",
    "end": "550329"
  },
  {
    "text": "map is on or off so basically we are setting the bits as we want we are controlling here for by first",
    "start": "550329",
    "end": "556870"
  },
  {
    "text": "controlling rocks and then after after disabling Earth Map what we're going to",
    "start": "556870",
    "end": "563560"
  },
  {
    "text": "do is we are going to run a read instruction which will redirect the",
    "start": "563560",
    "end": "568720"
  },
  {
    "text": "control flow to the address of our payload which is actually in user space so basically this is how we get phone",
    "start": "568720",
    "end": "577079"
  },
  {
    "start": "577000",
    "end": "615000"
  },
  {
    "text": "okay so what if we can find the indirect",
    "start": "577079",
    "end": "582850"
  },
  {
    "text": "branches to save previously computed locations so this is basically the idea behind control flow integrity so the",
    "start": "582850",
    "end": "591130"
  },
  {
    "text": "idea is originally indirect branches can resurrect control flow so whatever they want but this may not preventing this",
    "start": "591130",
    "end": "600730"
  },
  {
    "text": "sort of thing preventing this kind of permissiveness is what we want to avoid when we implement something like control",
    "start": "600730",
    "end": "606100"
  },
  {
    "text": "flow integrity so basically we are going to find which are the addresses that each each indirect target should point",
    "start": "606100",
    "end": "613089"
  },
  {
    "text": "to and we're going to enforce this so this paths I mean which are allowed they",
    "start": "613089",
    "end": "618760"
  },
  {
    "start": "615000",
    "end": "633000"
  },
  {
    "text": "are defined by the applications control flow graph and of course that there are different methodologies for computing",
    "start": "618760",
    "end": "624850"
  },
  {
    "text": "and enforcing this control flow graph like a CFG so we have many different implementations that that enforce this",
    "start": "624850",
    "end": "632260"
  },
  {
    "text": "kind of thing if I'm trying to do something like this if I'm trying to",
    "start": "632260",
    "end": "638170"
  },
  {
    "start": "633000",
    "end": "702000"
  },
  {
    "text": "enforce pass to to a program today direct branches what could possibly go",
    "start": "638170",
    "end": "644110"
  },
  {
    "text": "wrong well first thing is a relaxed permissiveness so if you are enforcing paths for your program and you have a",
    "start": "644110",
    "end": "650949"
  },
  {
    "text": "relaxed permissiveness the execution flow is going to be not very",
    "start": "650949",
    "end": "656579"
  },
  {
    "text": "that determinant and because of that attackers may still find paths that",
    "start": "656579",
    "end": "662970"
  },
  {
    "text": "allow them to to exploit your program another problem is of course is coverage so if you have indirect branches which",
    "start": "662970",
    "end": "670499"
  },
  {
    "text": "are not protected then you won't be able to - I mean - to protect the specific",
    "start": "670499",
    "end": "677970"
  },
  {
    "text": "range the net attackers might be able to exploit that specific range and that specific address also you have problems",
    "start": "677970",
    "end": "685499"
  },
  {
    "text": "with all positives because I mean if your control flow graph is too tight I mean if you if you don't predict certain",
    "start": "685499",
    "end": "692699"
  },
  {
    "text": "branches then your your system will raise false alerts and will tell you that something that is not an attack is",
    "start": "692699",
    "end": "699989"
  },
  {
    "text": "actually an attack and you don't want that so first picking on granularity",
    "start": "699989",
    "end": "705389"
  },
  {
    "start": "702000",
    "end": "773000"
  },
  {
    "text": "issues at CTF I we have two major fortifications we have the course grenades EFI schemes and the",
    "start": "705389",
    "end": "711600"
  },
  {
    "text": "fine-grained nc5 schemes so imagine this situation here so we have a function not",
    "start": "711600",
    "end": "717029"
  },
  {
    "text": "a which is calling a function B so on course grenade CFI which is more",
    "start": "717029",
    "end": "722339"
  },
  {
    "text": "permissive you have like a function B and the function C and these two functions are actually allowed to return",
    "start": "722339",
    "end": "728009"
  },
  {
    "text": "to the description which is right after B if their call B so in this scheme I",
    "start": "728009",
    "end": "733319"
  },
  {
    "text": "mean you're not like enforcing that if this call is the call to the function the only B can return here now I mean",
    "start": "733319",
    "end": "739559"
  },
  {
    "text": "whatever function may return to the description which is right after a call so this basically coarse-grain SEFI and",
    "start": "739559",
    "end": "745709"
  },
  {
    "text": "in fine-grain CFI you have more and more detailed CFG so basically if you have a call to be here you will not allow C to",
    "start": "745709",
    "end": "752790"
  },
  {
    "text": "return here because I mean this is a call to B so C is not allowed to return there right so in fact I mean",
    "start": "752790",
    "end": "759360"
  },
  {
    "text": "coarse-grain EDF I've known to be by passable researchers have shown that this this kind of protection is is by",
    "start": "759360",
    "end": "767279"
  },
  {
    "text": "passable and you can actually execute code arbitrarily even under these",
    "start": "767279",
    "end": "772529"
  },
  {
    "text": "circumstances okay now talking about case efi which is our implementation it's a fine grain",
    "start": "772529",
    "end": "779009"
  },
  {
    "start": "773000",
    "end": "823000"
  },
  {
    "text": "edge CFI scheme for the linux kernel it's a tremendous on instrumentation we",
    "start": "779009",
    "end": "785189"
  },
  {
    "text": "use the end which is a compiler for doing this instrumentation the 6g that we use",
    "start": "785189",
    "end": "790830"
  },
  {
    "text": "that we enforce it's computed statically so basically what we do is we do some sort of source code analysis we run a",
    "start": "790830",
    "end": "798630"
  },
  {
    "text": "full compilation round doing analysis on the source code that we are we're actually compiling and we figured out",
    "start": "798630",
    "end": "804060"
  },
  {
    "text": "things like prototypes for pointers prototypes for functions and then on the generated binary we run a binary",
    "start": "804060",
    "end": "810630"
  },
  {
    "text": "analysis where you can figure out more stuff like solving ages like I did find",
    "start": "810630",
    "end": "815760"
  },
  {
    "text": "which function is actually calling another function how the inlining is resolved by the compiler and things like",
    "start": "815760",
    "end": "822180"
  },
  {
    "text": "this okay so how exactly do we compute a control flow graph we have basically two",
    "start": "822180",
    "end": "830370"
  },
  {
    "start": "823000",
    "end": "883000"
  },
  {
    "text": "two major major problems here to solve first problem are the backward edges so",
    "start": "830370",
    "end": "836070"
  },
  {
    "text": "we're talking about return instructions we need to know which are the places to which a return instruction can return to",
    "start": "836070",
    "end": "842580"
  },
  {
    "text": "so it's kind of easy to compute because all you have to do is to take a look at the final binary so if you have a",
    "start": "842580",
    "end": "848790"
  },
  {
    "text": "function a that calls a function B you'll know that the function D must return to the function a whenever it's returning so it's kind of easy it's",
    "start": "848790",
    "end": "857130"
  },
  {
    "text": "already solved problem but we also have the forward edges which are like the indirect calls and for these cases I",
    "start": "857130",
    "end": "865560"
  },
  {
    "text": "mean it's a little bit more complicated because points to analysis is a mathematically infeasible problem so",
    "start": "865560",
    "end": "871380"
  },
  {
    "text": "it's incomplete you cannot just take a look at the source code and say oh this function pointer will call these these",
    "start": "871380",
    "end": "877050"
  },
  {
    "text": "and these daggers I mean you cannot do that precisely so you have to do some sort of heuristics here and what we do",
    "start": "877050",
    "end": "884550"
  },
  {
    "start": "883000",
    "end": "944000"
  },
  {
    "text": "is that I mean we followed the approach which which was originally proposed by Abadi at all I mean this is the guy who",
    "start": "884550",
    "end": "891720"
  },
  {
    "text": "originally proposed cf5 2005 he's a researcher from Microsoft researcher or was I don't know if he",
    "start": "891720",
    "end": "897900"
  },
  {
    "text": "stood there but in his approach basically what he says that if you have a function pointer and this function",
    "start": "897900",
    "end": "904260"
  },
  {
    "text": "pointer has a prototype if you have a function this function has a prototype then you enforce that this prototypes",
    "start": "904260",
    "end": "909959"
  },
  {
    "text": "must match in a way for this code to happen so if you have for example a function which is void and receives no",
    "start": "909959",
    "end": "917100"
  },
  {
    "text": "arguments a function pointer that this void and receives no argument this function pointer can only be used to",
    "start": "917100",
    "end": "923100"
  },
  {
    "text": "call functions which are void and which we will turn forward and receive no arguments so you enforce this sort of matching and",
    "start": "923100",
    "end": "929220"
  },
  {
    "text": "by doing something like this we are actually clustering functions by prototypes so you have a specific",
    "start": "929220",
    "end": "935310"
  },
  {
    "text": "prototype all the functions on that same prototype will be allow it to be called for that function pointer which matches",
    "start": "935310",
    "end": "943019"
  },
  {
    "text": "this prototype so just to make it clear we have an example here so we have this",
    "start": "943019",
    "end": "948540"
  },
  {
    "start": "944000",
    "end": "973000"
  },
  {
    "text": "dysfunction pointer here which is F PTR it's a function pointer of the type that returns a float and receives an",
    "start": "948540",
    "end": "954810"
  },
  {
    "text": "Intendant argument and using this function pointer we can call the function dog and the function cat",
    "start": "954810",
    "end": "959850"
  },
  {
    "text": "because they have the same prototype they are returning float and they're receiving an integer argument but you cannot use this function pointer to call",
    "start": "959850",
    "end": "966899"
  },
  {
    "text": "the function fish because it is a it has a different prototype okay so I think it",
    "start": "966899",
    "end": "972420"
  },
  {
    "text": "makes it clear after building the CFG we need to enforce it so what what do we do",
    "start": "972420",
    "end": "978449"
  },
  {
    "start": "973000",
    "end": "1104000"
  },
  {
    "text": "to enforce it then we recomm pile the kernel code with the CFG in place and we",
    "start": "978449",
    "end": "984089"
  },
  {
    "text": "instrument the generated code with whatever we need so we're basically going to use two different kinds or",
    "start": "984089",
    "end": "991890"
  },
  {
    "text": "primitives for instrumentation here first I imagine this code here I mean originally the derivative function only",
    "start": "991890",
    "end": "998940"
  },
  {
    "text": "had this call which happens to a register here does it is an indirect call and we want to protect this",
    "start": "998940",
    "end": "1004970"
  },
  {
    "text": "indirect call so what are we going to do I think you cannot see the the word here very well but try try your best so what",
    "start": "1004970",
    "end": "1014390"
  },
  {
    "text": "we're going to do is before actually calling the the value which is in the",
    "start": "1014390",
    "end": "1020089"
  },
  {
    "text": "register what we're going to do is we go into the heavens the value which is inside the address add an offset of four",
    "start": "1020089",
    "end": "1025970"
  },
  {
    "text": "in it just to bypass the OP code we'll go to it and see if the value which is",
    "start": "1025970",
    "end": "1031220"
  },
  {
    "text": "there is actually a value that we expect so the functions that are allowed to be called through this construction here",
    "start": "1031220",
    "end": "1038209"
  },
  {
    "text": "they have as their first instruction unknot instruction which is instruction that does not perform anything but",
    "start": "1038209",
    "end": "1044808"
  },
  {
    "text": "actually allows you to encode values inside of it so this is actually working as a watermark so we are actually water",
    "start": "1044809",
    "end": "1051950"
  },
  {
    "text": "marking the functions on it on their first destruction so we are putting a value",
    "start": "1051950",
    "end": "1057080"
  },
  {
    "text": "there that's going to be checked before calling destruction before calling the",
    "start": "1057080",
    "end": "1062210"
  },
  {
    "text": "function for that specific register so if the value compared here match with",
    "start": "1062210",
    "end": "1067400"
  },
  {
    "text": "the value which is here then this jump is taken what makes the the control flow",
    "start": "1067400",
    "end": "1072830"
  },
  {
    "text": "jump to here and then the call happens if this is not the case then we are",
    "start": "1072830",
    "end": "1077930"
  },
  {
    "text": "pushing the the value which was the heifer ins this just as an argument for a violation handler function and then we call what",
    "start": "1077930",
    "end": "1085580"
  },
  {
    "text": "we call a correlation handler which is a function that we actually raise an alert and let your see that men know that",
    "start": "1085580",
    "end": "1091070"
  },
  {
    "text": "something nasty is going on so that's more or less how it happens so here we have what what we call like a guard",
    "start": "1091070",
    "end": "1097460"
  },
  {
    "text": "instrumentation and or a check and here is what we call a tag such as a watermark instrumentation after that we",
    "start": "1097460",
    "end": "1105830"
  },
  {
    "start": "1104000",
    "end": "1150000"
  },
  {
    "text": "have I mean we also need to protect returns as I said and the instrumentation is pretty similar so we",
    "start": "1105830",
    "end": "1112430"
  },
  {
    "text": "have a call to function f1 here then we're going to put the tag right after the call and when as well before before",
    "start": "1112430",
    "end": "1119180"
  },
  {
    "text": "f1 returns it's going to run a check which first will load the address I mean",
    "start": "1119180",
    "end": "1124670"
  },
  {
    "text": "the return address which is in the topmost address of the stack into a register and then we are going to the have friends hit and check if the the",
    "start": "1124670",
    "end": "1131930"
  },
  {
    "text": "values match if they do match we do the jump here and return if they do not match we call the reservation handler so",
    "start": "1131930",
    "end": "1138320"
  },
  {
    "text": "the idea is pretty much the same except that we need to load the address from the stack because it's not it's not like",
    "start": "1138320",
    "end": "1145430"
  },
  {
    "text": "in an actual red shirt that we are calling or something like this so if",
    "start": "1145430",
    "end": "1151760"
  },
  {
    "start": "1150000",
    "end": "1169000"
  },
  {
    "text": "this approach really fine-grained I mean is it like really safe or something well",
    "start": "1151760",
    "end": "1156980"
  },
  {
    "text": "at least it is friend range and of course it is better than the coarse grained approach which were proposed in",
    "start": "1156980",
    "end": "1162050"
  },
  {
    "text": "the past but yet we can still do better I mean now we can do it a little bit",
    "start": "1162050",
    "end": "1167140"
  },
  {
    "text": "further so the presented scheme is actually prone to a problem that we",
    "start": "1167140",
    "end": "1172340"
  },
  {
    "start": "1169000",
    "end": "1237000"
  },
  {
    "text": "identified in that we call transitive clustering relaxation so although this this name is quite complex",
    "start": "1172340",
    "end": "1178100"
  },
  {
    "text": "the problems is really simple so let's see what is it imagine that you have a target for indirect call",
    "start": "1178100",
    "end": "1185930"
  },
  {
    "text": "which is called call it both directly and indirectly so as this targets foreign direct calls",
    "start": "1185930",
    "end": "1193070"
  },
  {
    "text": "as they're clustered so they will have all these functions will have the same tags on their prologues and they will",
    "start": "1193070",
    "end": "1199430"
  },
  {
    "text": "check for the same tags before returning so imagine this situation you have a function a which directly calls the",
    "start": "1199430",
    "end": "1205340"
  },
  {
    "text": "function B and you and you have a function C which has the same prototype of B so these two functions have the",
    "start": "1205340",
    "end": "1211820"
  },
  {
    "text": "same prototype does they're clustered and you have a call in B then because because of the clustering thing C can",
    "start": "1211820",
    "end": "1219590"
  },
  {
    "text": "return to be because the detect that will be in a it's good sorry she can return to the base call site in a",
    "start": "1219590",
    "end": "1225800"
  },
  {
    "text": "because the tag which is in a is the same tag that then will check when B is returning so you have an allow it eggs",
    "start": "1225800",
    "end": "1232790"
  },
  {
    "text": "here that was not supposed to exist which is C returning to a so this is",
    "start": "1232790",
    "end": "1238370"
  },
  {
    "start": "1237000",
    "end": "1275000"
  },
  {
    "text": "basically source code that describes the situation you have a function a which cause B then you have a tag here and you",
    "start": "1238370",
    "end": "1244880"
  },
  {
    "text": "have another function that can call both B and C through a pointer and it must",
    "start": "1244880",
    "end": "1251030"
  },
  {
    "text": "have the same tag here because this tag will be checked when this functions return right so both B and C must check",
    "start": "1251030",
    "end": "1259520"
  },
  {
    "text": "the same tag because they both must return here but the thing is this is a direct call to be even though he can",
    "start": "1259520",
    "end": "1267560"
  },
  {
    "text": "still return there right so just something that we wanted to prevent because this is a necessary relaxation",
    "start": "1267560",
    "end": "1273440"
  },
  {
    "text": "of our scheme so in our code base on the kernel configuration that we that we",
    "start": "1273440",
    "end": "1280280"
  },
  {
    "start": "1275000",
    "end": "1308000"
  },
  {
    "text": "tested this thing only for the void with no arguments prototype we have ten",
    "start": "1280280",
    "end": "1287450"
  },
  {
    "text": "thousand six hundred forty five KO sites with four thousand four hundred eighty",
    "start": "1287450",
    "end": "1292730"
  },
  {
    "text": "four void functions so this is a lot even though I mean we still have other prototypes that add to that in terms of",
    "start": "1292730",
    "end": "1299300"
  },
  {
    "text": "relaxation too so this the CFG this result in CFD is quite permissive so yes",
    "start": "1299300",
    "end": "1305270"
  },
  {
    "text": "we don't want that we want to find a way to prevent that so the way we fix this is by proposing a technique that we call",
    "start": "1305270",
    "end": "1313190"
  },
  {
    "start": "1308000",
    "end": "1419000"
  },
  {
    "text": "it the core graph detaching so a core graph detection is also really simple",
    "start": "1313190",
    "end": "1318530"
  },
  {
    "text": "so first thing we do is that we identify the functions which are called a callable both directly and indirectly",
    "start": "1318530",
    "end": "1325220"
  },
  {
    "text": "this we check the source code to see if there's a function pointer with the",
    "start": "1325220",
    "end": "1331190"
  },
  {
    "text": "prototype for that specific function and we also check the binary to see if that function is eventually call it directly",
    "start": "1331190",
    "end": "1337100"
  },
  {
    "text": "and if this is the case we cloned this function so we make a copy of this function in the resulting binary and",
    "start": "1337100",
    "end": "1343570"
  },
  {
    "text": "then the direct cost of the function they are replace it with calls to the clone so all the direct calls now we go",
    "start": "1343570",
    "end": "1351200"
  },
  {
    "text": "to the clone and not the original function and the clone has a unique tag which is different from the cluster tag",
    "start": "1351200",
    "end": "1357650"
  },
  {
    "text": "so this will result in something which is more or less like this so we have a function a which now calls B clone and",
    "start": "1357650",
    "end": "1365270"
  },
  {
    "text": "we have this word that code here we have this G function that can call both B and",
    "start": "1365270",
    "end": "1371390"
  },
  {
    "text": "C through the pointer does they will put the tag for the prototype here and both",
    "start": "1371390",
    "end": "1377600"
  },
  {
    "text": "B and C J's to check for the same for the same tag before returning but now we",
    "start": "1377600",
    "end": "1385370"
  },
  {
    "text": "have a B clone here that checks for different tags and the B clone is actually who is being called on on a so",
    "start": "1385370",
    "end": "1393170"
  },
  {
    "text": "actually C is no longer allowed to return here so that's more or less how we solve this this transit clearing",
    "start": "1393170",
    "end": "1400910"
  },
  {
    "text": "relaxation problem so by doing this we the allowed call sites reduce it to 224",
    "start": "1400910",
    "end": "1408140"
  },
  {
    "text": "indirectly called void functions so as you can see this is a meaningful optimization I mean we did some",
    "start": "1408140",
    "end": "1414800"
  },
  {
    "text": "advancement here and of course this happens because we have no more sensitiveness",
    "start": "1414800",
    "end": "1420549"
  },
  {
    "start": "1419000",
    "end": "1455000"
  },
  {
    "text": "something else which is important and that we did implement in KCF is the support for assembly code if you don't",
    "start": "1421160",
    "end": "1426860"
  },
  {
    "text": "support the simple code then first thing you're going to get a lot of false positives because if you are indirectly",
    "start": "1426860",
    "end": "1432470"
  },
  {
    "text": "calling assembly assembly code you won't have the tags there also if you have assembly code calling C functions you",
    "start": "1432470",
    "end": "1438860"
  },
  {
    "text": "won't have the tags there does the checks will raise the false alerts also",
    "start": "1438860",
    "end": "1444100"
  },
  {
    "text": "an even worse the indirect branches in the assembly code will be unprotected",
    "start": "1444100",
    "end": "1449330"
  },
  {
    "text": "and this may be a target for attackers to exploit your system so you have support that what we",
    "start": "1449330",
    "end": "1456760"
  },
  {
    "start": "1455000",
    "end": "1517000"
  },
  {
    "text": "do is that I mean we wrote like a bunch of parsers in Lua we well for those who don't know is a great language developed",
    "start": "1456760",
    "end": "1462640"
  },
  {
    "text": "by Brazilian guys so I really approve it it's a lower based parsers that we",
    "start": "1462640",
    "end": "1468460"
  },
  {
    "text": "implemented to automatically rewrite source code so what we do is we have",
    "start": "1468460",
    "end": "1473800"
  },
  {
    "text": "this parsers we feed the assembly code to the parsers and we automatically rewrite it placing the proper tags wherever they",
    "start": "1473800",
    "end": "1480460"
  },
  {
    "text": "should be we replace a few macros in the kernel that for example in the kernel",
    "start": "1480460",
    "end": "1486370"
  },
  {
    "text": "you have a macro called entry which is used to mark the beginning of an assembly function then we have like a new macro that we call entry CFI that",
    "start": "1486370",
    "end": "1493809"
  },
  {
    "text": "also marks the beginning of a function but also places the tag there and things like this so we do all the sort of",
    "start": "1493809",
    "end": "1499270"
  },
  {
    "text": "tricks and of course there are a few handcrafted fixes that we needed to solve by hand because the kernel code is",
    "start": "1499270",
    "end": "1505809"
  },
  {
    "text": "kind of weird and you have like code which is generated by macros and a lot",
    "start": "1505809",
    "end": "1510970"
  },
  {
    "text": "lots and lots and lots of very known pattern recognizable approaches we",
    "start": "1510970",
    "end": "1518620"
  },
  {
    "start": "1517000",
    "end": "1627000"
  },
  {
    "text": "evaluated this thing with three benchmarks first we instrumented spec",
    "start": "1518620",
    "end": "1523809"
  },
  {
    "text": "2006 with kc5 so we compiled it with the checks and we verified an average of 2%",
    "start": "1523809",
    "end": "1530530"
  },
  {
    "text": "overhead on it of course this is not very very presentative because spec spec",
    "start": "1530530",
    "end": "1535600"
  },
  {
    "text": "is very CPU intensive so you don't have like many branches there so we're not",
    "start": "1535600",
    "end": "1540760"
  },
  {
    "text": "really stressing in your mechanism so something else we did just like we compile the kernel with the projections",
    "start": "1540760",
    "end": "1548110"
  },
  {
    "text": "and then we did execute LM Bank on top of this kernel the lemma is like a micro",
    "start": "1548110",
    "end": "1554500"
  },
  {
    "text": "benchmark so as a micro benchmark is expected that it will have like very",
    "start": "1554500",
    "end": "1559510"
  },
  {
    "text": "high overhead sorry it's a micro benchmark it's expected that it will have like very very very large overheads so as a micro",
    "start": "1559510",
    "end": "1567370"
  },
  {
    "text": "benchmark what it will do it will basically run a Cisco or just like a TTP",
    "start": "1567370",
    "end": "1572640"
  },
  {
    "text": "functionality or something very simple which is an functionality from the kernel and we have seen an int and",
    "start": "1572640",
    "end": "1579580"
  },
  {
    "text": "Navarrete of eight percent overhead on it and we also did run for onyx on top of this",
    "start": "1579580",
    "end": "1585010"
  },
  {
    "text": "instrumented Colonel fir onyx it's actually the micro benchmark so basically what products is Franks has a",
    "start": "1585010",
    "end": "1591250"
  },
  {
    "text": "bunch of servers like HP servers FTP servers it has applications that will compress a file and do tests which",
    "start": "1591250",
    "end": "1599050"
  },
  {
    "text": "resemble more what you do in your daily uses on a server or on your computer so",
    "start": "1599050",
    "end": "1604080"
  },
  {
    "text": "it's expected that this kind of benchmark will have a lower overhead because if you run more code in",
    "start": "1604080",
    "end": "1610570"
  },
  {
    "text": "userspace which is not instrumented so we have seen two percent overhead on average for this one and of course I can",
    "start": "1610570",
    "end": "1617620"
  },
  {
    "text": "provide more details regarding the benchmarks I have some slides about it on the on the back part of the slides I",
    "start": "1617620",
    "end": "1624070"
  },
  {
    "text": "just don't want to go into necessary detail now of course that five million",
    "start": "1624070",
    "end": "1629290"
  },
  {
    "start": "1627000",
    "end": "1716000"
  },
  {
    "text": "ca5 not perfect either so left here some some guides proposed I mean they have presented this papers in",
    "start": "1629290",
    "end": "1636460"
  },
  {
    "text": "use Nixon CCS showing that there are cases where cf-52 of vulnerable to",
    "start": "1636460",
    "end": "1641890"
  },
  {
    "text": "attacks of course that these these attacks are very specific and very",
    "start": "1641890",
    "end": "1647110"
  },
  {
    "text": "constrained and there's like there's this a non control data tracks which are",
    "start": "1647110",
    "end": "1653230"
  },
  {
    "text": "attacks that actually may allow an attacker to run code arbitrarily but",
    "start": "1653230",
    "end": "1658540"
  },
  {
    "text": "they're not really literally like targeting controlled data like function pointers or return addresses for example",
    "start": "1658540",
    "end": "1664960"
  },
  {
    "text": "and here in blackhat Asia I think we have two talks regarding it I think that",
    "start": "1664960",
    "end": "1669970"
  },
  {
    "text": "there was one talk right before before mine that was a regarding Microsoft edge and there's going to be another talk",
    "start": "1669970",
    "end": "1675880"
  },
  {
    "text": "tomorrow so this is sort of like a trend in the academia I mean these guys are looking for different ways of exploiting",
    "start": "1675880",
    "end": "1683710"
  },
  {
    "text": "systems even though they are using case efi as more and more people are using case efi daily so the complexity",
    "start": "1683710",
    "end": "1690700"
  },
  {
    "text": "actually actually the complexity behind these methods they showed that CF is actually a relevant method so I mean",
    "start": "1690700",
    "end": "1696490"
  },
  {
    "text": "these attacks are quite complex we don't know if they're like really usable on a",
    "start": "1696490",
    "end": "1702370"
  },
  {
    "text": "daily basis we known of these attacks have ever been shown for the kernel setting so I don't know I mean this at",
    "start": "1702370",
    "end": "1710500"
  },
  {
    "text": "least shows that EFI is a meaningful protection possibly more meaningful day a seller",
    "start": "1710500",
    "end": "1716070"
  },
  {
    "start": "1716000",
    "end": "2170000"
  },
  {
    "text": "okay so now let's go see a demo I'll try to run it live but of course um",
    "start": "1716070",
    "end": "1725050"
  },
  {
    "text": "I am an unlucky guy things go wrong with me all the time so what I'm going to do",
    "start": "1725050",
    "end": "1731710"
  },
  {
    "text": "is that I'm going to run a kernel here which is instrumented with kc5 and I",
    "start": "1731710",
    "end": "1737860"
  },
  {
    "text": "have like a handcrafted exploit in this thing and I'm able to control a function",
    "start": "1737860",
    "end": "1744670"
  },
  {
    "text": "pointer through a synthetic export or something like this so what I'm going to",
    "start": "1744670",
    "end": "1750460"
  },
  {
    "text": "do is that I'm going to log into this machine and I'm going to override this",
    "start": "1750460",
    "end": "1760780"
  },
  {
    "text": "function pointer are you guys able to",
    "start": "1760780",
    "end": "1766540"
  },
  {
    "text": "read that you need to bigger larger font or something larger okay I just don't",
    "start": "1766540",
    "end": "1775840"
  },
  {
    "text": "know where to do it sorry common plus awesome thank you I'm",
    "start": "1775840",
    "end": "1787630"
  },
  {
    "text": "actually learning something here now is it better what's bigger okay so",
    "start": "1787630",
    "end": "1793600"
  },
  {
    "text": "basically we have this tree interfaces that I have created through the bug effect here and whenever I put some",
    "start": "1793600",
    "end": "1801760"
  },
  {
    "text": "value inside over front pointer this is going to actually replace a function pointer which is running on kernel and",
    "start": "1801760",
    "end": "1807490"
  },
  {
    "text": "whenever I put something on invoke function this function pointer will be invoked so that's not really an exploit",
    "start": "1807490",
    "end": "1812860"
  },
  {
    "text": "but it will show us what we want to see so I also changed my module to show me",
    "start": "1812860",
    "end": "1822309"
  },
  {
    "text": "which are the addresses of the functions which I want to check because I'm lazy so we have these two functions once it",
    "start": "1822309",
    "end": "1827710"
  },
  {
    "text": "once one is called allow it allow it has the same prototype of the function pointer that we are going to corrupt and",
    "start": "1827710",
    "end": "1833760"
  },
  {
    "text": "not allow it does not have the same prototype it has a different prototype does it may raise an alert so what I'm",
    "start": "1833760",
    "end": "1840880"
  },
  {
    "text": "going to do first that I'm going to put the address of allowed inside the function pointer",
    "start": "1840880",
    "end": "1847590"
  },
  {
    "text": "and now I'm going to invoke it and I'm",
    "start": "1848640",
    "end": "1855510"
  },
  {
    "text": "going to run the math and they'll see we we executed the function here and here",
    "start": "1855510",
    "end": "1860520"
  },
  {
    "text": "and there was like no no alerts raised now I'm going to execute the not allowed function and I'm going to show you that",
    "start": "1860520",
    "end": "1867240"
  },
  {
    "text": "when the prototype is different this scheme really works but before doing that I want to show you like really how",
    "start": "1867240",
    "end": "1876929"
  },
  {
    "text": "this thing works so I'm going to plug gdb into the kernel and do a step by step execution of the the whole thing so",
    "start": "1876929",
    "end": "1886460"
  },
  {
    "text": "okay now I just plug it into the gdb as you can see it's paused so I'm going to",
    "start": "1893299",
    "end": "1900030"
  },
  {
    "text": "the disassembly the function invoke function which is the function which",
    "start": "1900030",
    "end": "1905390"
  },
  {
    "text": "will be called whenever we do that echo 1 in to invoke funk and the call which",
    "start": "1905390",
    "end": "1911760"
  },
  {
    "text": "is actually being exploited is happening right here so this call which happened",
    "start": "1911760",
    "end": "1919980"
  },
  {
    "text": "through our X as you can see did the instructions on top of it are actually those instructions which I showed I showed earlier for the instrumentation",
    "start": "1919980",
    "end": "1926370"
  },
  {
    "text": "and okay so I'm going to put a breakpoint right here and put the kernel",
    "start": "1926370",
    "end": "1936090"
  },
  {
    "text": "to run I'll have to login again because kernel will stop it and the connection",
    "start": "1936090",
    "end": "1943169"
  },
  {
    "text": "dropped",
    "start": "1943169",
    "end": "1945500"
  },
  {
    "text": "and now I'm going to put the address of the function which is not allowed into the over function pointer interface and",
    "start": "1955140",
    "end": "1965930"
  },
  {
    "text": "now I'm going to invoke this function pointer which is going to trigger the",
    "start": "1965930",
    "end": "1972630"
  },
  {
    "text": "breakpoint on the other screen so just like I said so the first thing we have",
    "start": "1972630",
    "end": "1978360"
  },
  {
    "text": "here is instruction which is actually a loading the address I mean did read the value which is in the register which",
    "start": "1978360",
    "end": "1984780"
  },
  {
    "text": "will be used for the indirect call into our C X okay so our C X now holds the",
    "start": "1984780",
    "end": "1991890"
  },
  {
    "text": "address which will be used for for for calling right so what we're going to do",
    "start": "1991890",
    "end": "1997080"
  },
  {
    "text": "is that what I'm going to show is that I'm going to show you what's there so what we are going to the have friends it just like it's going to be done in this",
    "start": "1997080",
    "end": "2003200"
  },
  {
    "text": "in this specific instruction here so we have to the hair friends this address",
    "start": "2003200",
    "end": "2011710"
  },
  {
    "text": "but the thing is as I told you before this this word is encoded inside an OP",
    "start": "2012100",
    "end": "2017450"
  },
  {
    "text": "instruction so we have to do to add a small offset to it just to bypass the",
    "start": "2017450",
    "end": "2022850"
  },
  {
    "text": "opcode which is an offset of 4 and then we see that it actually holds the value",
    "start": "2022850",
    "end": "2027890"
  },
  {
    "text": "0 7 1 0 0 7 5 a if we disassembly the",
    "start": "2027890",
    "end": "2032960"
  },
  {
    "text": "not allowed function we can see that the same values is in the first instruction",
    "start": "2032960",
    "end": "2038210"
  },
  {
    "text": "of the function so actually as the same construction is actually looking for a",
    "start": "2038210",
    "end": "2043730"
  },
  {
    "text": "different value the value which is which is it is looking is 9 1 2 F 5 2 2 7 then",
    "start": "2043730",
    "end": "2053030"
  },
  {
    "text": "this is not going to be a match so if we run a step here we're going to the jump",
    "start": "2053030",
    "end": "2061010"
  },
  {
    "text": "on eco instruction and but but the thing it's not it's not equal right so as you",
    "start": "2061010",
    "end": "2066919"
  },
  {
    "text": "can see here and in the debugger the jump will not be taken so we're going to go to the next instruction the jump of",
    "start": "2066919",
    "end": "2072590"
  },
  {
    "text": "not taken now we are going to push this this value of the the indirect call into",
    "start": "2072590",
    "end": "2078290"
  },
  {
    "text": "the stack and then we are going to call the correlation handler the conversation",
    "start": "2078290",
    "end": "2084740"
  },
  {
    "text": "handler is a really simple function I mean can implement it however you want currently it's only programmed to give",
    "start": "2084740",
    "end": "2091190"
  },
  {
    "text": "you an alert so I'm just going to hit continue here and go this is now running",
    "start": "2091190",
    "end": "2097670"
  },
  {
    "text": "again and when I log in again if I run out the math here as you can see there's",
    "start": "2097670",
    "end": "2104660"
  },
  {
    "text": "this C fic which is actually the let's say acronym for a CF I call violation or",
    "start": "2104660",
    "end": "2113240"
  },
  {
    "text": "something like this and we have this two addresses which is the address that triggered the violation and the address",
    "start": "2113240",
    "end": "2118970"
  },
  {
    "text": "which was being called by the triggered violation so we were able to map what exactly the guy was trying to run when",
    "start": "2118970",
    "end": "2125180"
  },
  {
    "text": "he did this disappointed corruption so and of course I mean we did not block",
    "start": "2125180",
    "end": "2130849"
  },
  {
    "text": "the function but we could have done this inside the violation handler and the function just printed that this function",
    "start": "2130849",
    "end": "2136550"
  },
  {
    "text": "should not be allowed as the the tag after the function pointer was also different from the tag we decided not",
    "start": "2136550",
    "end": "2143180"
  },
  {
    "text": "allowed function we also have like a return violation that was triggered here and well that's it",
    "start": "2143180",
    "end": "2149180"
  },
  {
    "text": "that's pretty much how the scheme works you could see it like step by step now",
    "start": "2149180",
    "end": "2155330"
  },
  {
    "text": "back to the slides I hope my friends crump liked it and does not block me",
    "start": "2155330",
    "end": "2162109"
  },
  {
    "text": "from joining the USA again",
    "start": "2162109",
    "end": "2165730"
  },
  {
    "start": "2170000",
    "end": "2229000"
  },
  {
    "text": "okay so what are the conclusions that we have here so fine-grained cf5 in the",
    "start": "2170580",
    "end": "2175750"
  },
  {
    "text": "u.s. context is achievable I think this is cool because the guys that presented right right before me they just had the",
    "start": "2175750",
    "end": "2182290"
  },
  {
    "text": "same soundbite and I like oh actually doing the sage cover channel through caches is achievable",
    "start": "2182290",
    "end": "2187540"
  },
  {
    "text": "so I think that most people are here trying to prove stuff that's that's cool we prove the stuff awesome work guys",
    "start": "2187540",
    "end": "2193920"
  },
  {
    "text": "so see if I can be used to provide meaningful level protection as we as we can see by the complexity of the attacks",
    "start": "2193920",
    "end": "2200800"
  },
  {
    "text": "which are actually targeting gf5 and it will push attackers for more constrained",
    "start": "2200800",
    "end": "2206110"
  },
  {
    "text": "and complex exploitation techniques also current existing methods for refining",
    "start": "2206110",
    "end": "2212110"
  },
  {
    "text": "regularity in CFI they can and they must be improved so as I have shown you Coker",
    "start": "2212110",
    "end": "2217540"
  },
  {
    "text": "F detaching is like is a new technique nobody has proposed that before and by doing that we actually refine",
    "start": "2217540",
    "end": "2224140"
  },
  {
    "text": "significantly the fine grain EGF I schemes so I guess that's it I think I",
    "start": "2224140",
    "end": "2231250"
  },
  {
    "start": "2229000",
    "end": "2774000"
  },
  {
    "text": "was like super fast so we have like a thousand hours for I mean I don't have like a very cool quest cuckoo song like",
    "start": "2231250",
    "end": "2237790"
  },
  {
    "text": "they do but we can sing one here go anyway for every boot if they are",
    "start": "2237790",
    "end": "2251440"
  },
  {
    "text": "randomized or something yeah no I mean they are not randomized because we don't it doesn't matter I mean we skim that we",
    "start": "2251440",
    "end": "2260320"
  },
  {
    "text": "do implemented we do not rely on secrecy I mean the idea is that even though we were able to shoot this holes memory I",
    "start": "2260320",
    "end": "2267820"
  },
  {
    "text": "mean the tags in the verifications will still there so we won't be able to resurrect code whatever you want to I",
    "start": "2267820",
    "end": "2273970"
  },
  {
    "text": "mean we are considering that a threat model word for example in your kernel",
    "start": "2273970",
    "end": "2278980"
  },
  {
    "text": "the guy won't be able to inject executable code into your memory so I mean if he is able to put to put data",
    "start": "2278980",
    "end": "2284800"
  },
  {
    "text": "there its data it's not marked as executable so he will not be able to to",
    "start": "2284800",
    "end": "2291360"
  },
  {
    "text": "bypass this kind of thing go ahead",
    "start": "2291360",
    "end": "2298380"
  },
  {
    "text": "okay protect calls from violation handlers it would be required if we had",
    "start": "2302760",
    "end": "2308200"
  },
  {
    "text": "a victim is a direct call so the violation handler is eventually returning and there could be like a bug",
    "start": "2308200",
    "end": "2316140"
  },
  {
    "text": "inside the violation handler that would be we would allow somebody to corrupt",
    "start": "2316140",
    "end": "2323050"
  },
  {
    "text": "the return from the varlet handle yeah it could be possible but what I'm considering that as my violation Handler",
    "start": "2323050",
    "end": "2328660"
  },
  {
    "text": "is really simple and very very tight that there is not about there but definitely yes I mean if if there's a",
    "start": "2328660",
    "end": "2336880"
  },
  {
    "text": "bug inside the validation handler the guy will be able to corrupt the that the",
    "start": "2336880",
    "end": "2341950"
  },
  {
    "text": "return from the violation handler but here comes something right so the violation violation handler was already invoked so this isn't mean I already",
    "start": "2341950",
    "end": "2348580"
  },
  {
    "text": "know that something is happening so and whenever the violation handler is returning the guy would maybe get the",
    "start": "2348580",
    "end": "2354700"
  },
  {
    "text": "control of the system over yes sort of",
    "start": "2354700",
    "end": "2361440"
  },
  {
    "text": "introspection please what do you mean by",
    "start": "2361440",
    "end": "2369640"
  },
  {
    "text": "ensure handlers sorry I could not",
    "start": "2369640",
    "end": "2375340"
  },
  {
    "text": "understand can you talk a little bit longer",
    "start": "2375340",
    "end": "2380250"
  },
  {
    "text": "sorry I still not not able to understand your question no please I want I want to",
    "start": "2388250",
    "end": "2395220"
  },
  {
    "text": "I want to go for it a higher interruption okay so whenever I have",
    "start": "2395220",
    "end": "2400950"
  },
  {
    "text": "like a harder interruption so thing is that the kernel we will start executing",
    "start": "2400950",
    "end": "2407270"
  },
  {
    "text": "frou-frou like an eye gate or something like that and it starts executing",
    "start": "2407270",
    "end": "2412290"
  },
  {
    "text": "normally so we don't really verify if the interruption is really running",
    "start": "2412290",
    "end": "2417590"
  },
  {
    "text": "through let's say a protected a protected gate or something like that so we just assume that okay there's a",
    "start": "2417590",
    "end": "2423870"
  },
  {
    "text": "hardware interest here then you have like the drop handler here the interpreter starts as a cute in here so",
    "start": "2423870",
    "end": "2429630"
  },
  {
    "text": "we assume that this is safe because we don't know much much of how an attack would be able to protect against this",
    "start": "2429630",
    "end": "2435780"
  },
  {
    "text": "and then this handler starts executing and imagine that you have like another interrupt that will get you started here",
    "start": "2435780",
    "end": "2443400"
  },
  {
    "text": "that's what you call like an inter interrupt interruption handlers right so the thing is we this team does not",
    "start": "2443400",
    "end": "2449610"
  },
  {
    "text": "really rely on the context of the execution so that that execution flow",
    "start": "2449610",
    "end": "2454710"
  },
  {
    "text": "just stops and I mean it's just frozen just like it happens normally in the kernel and the new tread starts",
    "start": "2454710",
    "end": "2460260"
  },
  {
    "text": "executing and it's irrespective to the previous one so this code this new code",
    "start": "2460260",
    "end": "2465600"
  },
  {
    "text": "you just start executing and whenever it's calling new functions directly or",
    "start": "2465600",
    "end": "2470820"
  },
  {
    "text": "returning I mean this would be already solved so I mean it's not really a problem to freeze one execution and",
    "start": "2470820",
    "end": "2476910"
  },
  {
    "text": "started it get another one so the whole scheme is already let's say compliant",
    "start": "2476910",
    "end": "2482880"
  },
  {
    "text": "with with interruption requirements",
    "start": "2482880",
    "end": "2487039"
  },
  {
    "text": "anyone else",
    "start": "2488270",
    "end": "2491420"
  },
  {
    "text": "okay so we have like because lied about it here somewhere so okay so for Casey",
    "start": "2494150",
    "end": "2507449"
  },
  {
    "text": "fi we fought the CJD optimization we have like 2% space overhead and we are",
    "start": "2507449",
    "end": "2513059"
  },
  {
    "text": "talking about the kernel that has a 718 megabyte so it raise it to 718 megabytes",
    "start": "2513059",
    "end": "2520890"
  },
  {
    "text": "from 705 if we do the CGG optimization then we are cloning functions does the",
    "start": "2520890",
    "end": "2527880"
  },
  {
    "text": "overhead is bigger then we get like a 4% space overhead so just just to let you",
    "start": "2527880",
    "end": "2536609"
  },
  {
    "text": "know I mean the code the code base we used had like 130 2972 functions and we",
    "start": "2536609",
    "end": "2543749"
  },
  {
    "text": "cloned seven 17,000 functions 17,000 779",
    "start": "2543749",
    "end": "2548789"
  },
  {
    "text": "so in terms of numbers it's considerable but still not that much size overhead of",
    "start": "2548789",
    "end": "2556709"
  },
  {
    "text": "course that I don't know something i would like to us at some time is like if",
    "start": "2556709",
    "end": "2562559"
  },
  {
    "text": "this has a meaningful impact in in power consumption because i mean when we talk",
    "start": "2562559",
    "end": "2568919"
  },
  {
    "text": "about size overhead we eventually end up talking about embedded devices or something like this and these guys have",
    "start": "2568919",
    "end": "2575219"
  },
  {
    "text": "a special criteria for a for a power",
    "start": "2575219",
    "end": "2580829"
  },
  {
    "text": "consumption and i know that for example having the the CGG optimization something that you harm at least",
    "start": "2580829",
    "end": "2586589"
  },
  {
    "text": "slightly your your cache because you're if you're if you were calling the same function indirectly and directly i mean",
    "start": "2586589",
    "end": "2593130"
  },
  {
    "text": "the same code would be in the cache and it would be a cache hit but now that you have like detected these things i mean",
    "start": "2593130",
    "end": "2598949"
  },
  {
    "text": "your cache considers these things to be different so it won't be a cache hit",
    "start": "2598949",
    "end": "2604229"
  },
  {
    "text": "anymore so i would like to see it sometime i just did not it yet please",
    "start": "2604229",
    "end": "2613309"
  },
  {
    "text": "we we implemented it specifically for the x86 54 texture so we the x86",
    "start": "2621260",
    "end": "2629090"
  },
  {
    "text": "architecture has a few of two features that we use for example the tags that we used which I showed you they're",
    "start": "2629090",
    "end": "2635300"
  },
  {
    "text": "implemented as they're not here so they're implemented as not valve",
    "start": "2635300",
    "end": "2640520"
  },
  {
    "text": "instructions right so mobile instructions they're not like available I mean did",
    "start": "2640520",
    "end": "2646910"
  },
  {
    "text": "the instructions they are available in most architectures but not not all of them will allow you to encode the value",
    "start": "2646910",
    "end": "2652100"
  },
  {
    "text": "inside of it so this is something that we are able to achieve in the x86 it's 4th Tector so I believe that for other",
    "start": "2652100",
    "end": "2658580"
  },
  {
    "text": "textures of course there's going to be different constraints but I think that",
    "start": "2658580",
    "end": "2663590"
  },
  {
    "text": "currently the most the most let's say",
    "start": "2663590",
    "end": "2669010"
  },
  {
    "text": "break that for implementing this thing into a different architecture would be",
    "start": "2669010",
    "end": "2674060"
  },
  {
    "text": "having a way for encoding tags properly we actually I mean we know a different",
    "start": "2674060",
    "end": "2679880"
  },
  {
    "text": "way of encoding tags which actually consists in declaring a global variable in the kernel and then in then doing the",
    "start": "2679880",
    "end": "2686510"
  },
  {
    "text": "mobs instruction inside this global variable so the value which has been moved is the tag and the global variable",
    "start": "2686510",
    "end": "2694030"
  },
  {
    "text": "is never going to be used so it's just a way to do a dummy move with a value that",
    "start": "2694030",
    "end": "2699710"
  },
  {
    "text": "we want to be there but the problem is this scheme causes more cache contention this scheme will harm your performance",
    "start": "2699710",
    "end": "2706190"
  },
  {
    "text": "more strictly than using ops but I mean this is a way for example to implement",
    "start": "2706190",
    "end": "2711560"
  },
  {
    "text": "this thing on a different on a different architecture another thing which is",
    "start": "2711560",
    "end": "2717140"
  },
  {
    "text": "which is interesting is that higher-level caches they are inclusive so one thing is that for example when",
    "start": "2717140",
    "end": "2725240"
  },
  {
    "text": "you were the Heffron thing an address for for verifying if a tag is there then",
    "start": "2725240",
    "end": "2731140"
  },
  {
    "text": "if if this this address which are the reference is not in the cache then",
    "start": "2731140",
    "end": "2737800"
  },
  {
    "text": "what's going to happen that it's going to come into the cache as data so it's going to be probably in l2 if I'm not",
    "start": "2737800",
    "end": "2745040"
  },
  {
    "text": "wrong at least and then when you jumping to the destruction to execute it then it's going to be loaded from l2",
    "start": "2745040",
    "end": "2751660"
  },
  {
    "text": "cache and not from from the memory itself so the scheme considering the Intel's architecture for caches is",
    "start": "2751660",
    "end": "2758440"
  },
  {
    "text": "really efficient I'm not sure how it would perform on different architectures",
    "start": "2758440",
    "end": "2763859"
  },
  {
    "text": "more questions ok great then thank you very much for",
    "start": "2763859",
    "end": "2771700"
  },
  {
    "text": "coming thank you for your time [Applause]",
    "start": "2771700",
    "end": "2776579"
  }
]