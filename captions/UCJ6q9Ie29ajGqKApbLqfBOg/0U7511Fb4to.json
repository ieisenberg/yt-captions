[
  {
    "start": "0",
    "end": "0"
  },
  {
    "text": "hi everyone um this is a talk basically about bit flips in other words single",
    "start": "80",
    "end": "5839"
  },
  {
    "text": "bit errors in memory and it's about how to cause them and how to exploit them",
    "start": "5839",
    "end": "12080"
  },
  {
    "text": "and specifically it's about exploiting bit flips caused by a particular Hardware bug known as the rammer",
    "start": "12080",
    "end": "19320"
  },
  {
    "text": "bug so this is a fault with many Dr modules manufactured from around 2010",
    "start": "19320",
    "end": "25039"
  },
  {
    "start": "21000",
    "end": "21000"
  },
  {
    "text": "onwards and the bug is that repeatedly reading from one page in memory can",
    "start": "25039",
    "end": "30480"
  },
  {
    "text": "cause corruption in other pages and potentially those pages can be used by other processes or by the kernel so this",
    "start": "30480",
    "end": "37640"
  },
  {
    "text": "bug is dangerous because it these errors bypass memory protection and all of the",
    "start": "37640",
    "end": "43079"
  },
  {
    "text": "three largest Dr manufacturers have shipped dram with this fault so there's",
    "start": "43079",
    "end": "48160"
  },
  {
    "text": "a whole generation of machines out there that are prone to this problem but this this talk isn't just",
    "start": "48160",
    "end": "55640"
  },
  {
    "text": "about one bug it's also about the connection between reliability and security so in the past memory for",
    "start": "55640",
    "end": "63680"
  },
  {
    "text": "example memory corruption bugs and crashes were often treated as being just reliability issues but people started",
    "start": "63680",
    "end": "71080"
  },
  {
    "text": "coming up with increasingly clever ways to exploit those bugs so the software",
    "start": "71080",
    "end": "76240"
  },
  {
    "text": "industry has gradually been realizing that these bugs aren't just reliability issues they're more dangerous than that",
    "start": "76240",
    "end": "83400"
  },
  {
    "text": "so the software industry has been learning this lesson but I think a lot of the hardware industry hasn't caught",
    "start": "83400",
    "end": "88439"
  },
  {
    "text": "up yet based on how they responded to the rammer bug so I'm going to talk a bit about how",
    "start": "88439",
    "end": "94920"
  },
  {
    "start": "93000",
    "end": "93000"
  },
  {
    "text": "software can cause bit flips using the rammer bug and I'll talk about the two proof of concept privilege escalation",
    "start": "94920",
    "end": "102399"
  },
  {
    "text": "exploits that I wrote that can use these bit flips to escalate privileges then then I'll talk about",
    "start": "102399",
    "end": "108799"
  },
  {
    "text": "mitigations and how the industry responded to the bug and a lot of this was c um was covered in the blog post",
    "start": "108799",
    "end": "116000"
  },
  {
    "text": "that we published on the Google project zero blog earlier this year but I'll also talk about one more topic that",
    "start": "116000",
    "end": "121759"
  },
  {
    "text": "we've learned more about since then which is about the possibility of doing row hammering from",
    "start": "121759",
    "end": "127920"
  },
  {
    "text": "JavaScript so a little bit about us um so I usually work on building sandboxes",
    "start": "127920",
    "end": "133760"
  },
  {
    "start": "129000",
    "end": "129000"
  },
  {
    "text": "rather than breaking them and I've worked on a few different sandboxing systems including some Linux sandboxes",
    "start": "133760",
    "end": "139560"
  },
  {
    "text": "and the native client sandbox and uh lately when I found bugs",
    "start": "139560",
    "end": "145000"
  },
  {
    "text": "I've tried to write exploits for them and I found that to be quite an educational thing to do",
    "start": "145000",
    "end": "150519"
  },
  {
    "text": "um and that's that's kind of what I did here um I I've also found that writing exploits helps to get other people to",
    "start": "150519",
    "end": "157360"
  },
  {
    "text": "take security bugs more seriously um so I really want the sandboxes that I build to to work and to",
    "start": "157360",
    "end": "165040"
  },
  {
    "text": "actually be secure and unfortunately I found I had to write exploits for rammer in order to get people to take it more",
    "start": "165040",
    "end": "171200"
  },
  {
    "text": "seriously and actually fix it and uh good day my name is har I'm",
    "start": "171200",
    "end": "176640"
  },
  {
    "text": "going to be a co-presenter here and uh I've been doing exploitation for a long while uh and I really quite like to work",
    "start": "176640",
    "end": "182640"
  },
  {
    "text": "on tricky to exploit flaws and this was a rather tricky to exploit",
    "start": "182640",
    "end": "188560"
  },
  {
    "text": "one um we announced that we are going to talk a little bit about dram errors and",
    "start": "188560",
    "end": "193720"
  },
  {
    "text": "how to to cause these dram errors oh sorry yes um and uh before we do that",
    "start": "193720",
    "end": "199400"
  },
  {
    "text": "though we should have a look at perhaps completely random bit flips that are not",
    "start": "199400",
    "end": "204720"
  },
  {
    "start": "201000",
    "end": "201000"
  },
  {
    "text": "induced by an attacker that just happen randomly and there's a a fairly interesting paper from 20 three where a",
    "start": "204720",
    "end": "210280"
  },
  {
    "text": "few academics tried to examine exactly the scenario what they did there is they hooked up a heating lamp to the ram of a",
    "start": "210280",
    "end": "216560"
  },
  {
    "text": "machine in order to indu heat induced uh bit flips in dram um and then they showed how they",
    "start": "216560",
    "end": "223599"
  },
  {
    "text": "can use this to break out of the Java sandbox and the way they did this is the Java uh application would fill all of",
    "start": "223599",
    "end": "229720"
  },
  {
    "text": "the memory of the Java VM with references to objects when a bit would flip in one of these references the",
    "start": "229720",
    "end": "235239"
  },
  {
    "text": "reference would then point to a different object of a different type which would then violate the security assumptions of the Java s box so it's",
    "start": "235239",
    "end": "242000"
  },
  {
    "text": "not an entirely new thing to look at random bit flips uh for exploitation and",
    "start": "242000",
    "end": "247159"
  },
  {
    "text": "it's been something that has been been on my mind for a long for a long while there was a paper in 2009 published by",
    "start": "247159",
    "end": "252480"
  },
  {
    "text": "Google actually um that examined the prevalence of truly random bit flips in",
    "start": "252480",
    "end": "258000"
  },
  {
    "text": "the big server Fleet that Google has because Google is monitoring these things and it was really quite interesting because youve had",
    "start": "258000",
    "end": "263960"
  },
  {
    "text": "quantitative numbers in terms of how often does a bit just flip randomly in",
    "start": "263960",
    "end": "269080"
  },
  {
    "text": "Dam without any interaction and that leads to a fairly interesting thought experiment because these days you can",
    "start": "269080",
    "end": "274840"
  },
  {
    "text": "buy ad Impressions and these ad Impressions allow you to run JavaScript or or Flash inside of somebody else's",
    "start": "274840",
    "end": "280720"
  },
  {
    "text": "computer so this leads to a fairly obvious thought experiment in terms of well if random bit flips happen this and",
    "start": "280720",
    "end": "286919"
  },
  {
    "text": "so like this and that often and if I can exploit them to to gain privileges",
    "start": "286919",
    "end": "292320"
  },
  {
    "text": "outside like from a JavaScript sandbox or from a flash sandbox um how many add",
    "start": "292320",
    "end": "298520"
  },
  {
    "text": "Impressions do I need to B before I will compromise a machine just purely randomly by by gam flipping a bit turns",
    "start": "298520",
    "end": "305680"
  },
  {
    "text": "out that it's not quite cost effective yet it was an interesting thing to to look into um in fact though the sort of",
    "start": "305680",
    "end": "313800"
  },
  {
    "start": "311000",
    "end": "311000"
  },
  {
    "text": "memory error we're dealing with here rammer is very very different from the truly random model because the thing",
    "start": "313800",
    "end": "319400"
  },
  {
    "text": "that makes the attack really quite reliable is the fact that we're not randomly flipping bits we're flipping",
    "start": "319400",
    "end": "326400"
  },
  {
    "text": "one bit deterministically we can't choose the bit the assignment of the bit is fairly random but once we see that",
    "start": "326400",
    "end": "331639"
  },
  {
    "text": "bit flip we can make it flip repeatedly and it is that repe repeatability of the bit flip that makes the exploit so so",
    "start": "331639",
    "end": "340440"
  },
  {
    "text": "reliable okay so now I'll talk a bit about rammer specifically but first um I'll give an intro how to dram works so",
    "start": "341160",
    "end": "348880"
  },
  {
    "text": "dram is the main memory of a computer it short for a dynamic RAM and a bank of dram basically consists of a big array",
    "start": "348880",
    "end": "355960"
  },
  {
    "text": "of cells where each cell stores one bit so so daming is quite high capacity and",
    "start": "355960",
    "end": "361199"
  },
  {
    "text": "the reason for that is the circuitry for a cell is very simple and compact so a cell consists of basically just a",
    "start": "361199",
    "end": "367400"
  },
  {
    "text": "capacitor and a transistor and the presence or absence of charge on that capacitor indicates whether it's it's",
    "start": "367400",
    "end": "373360"
  },
  {
    "text": "storing a zero or a one and but because this Arrangement is so simple cells",
    "start": "373360",
    "end": "379080"
  },
  {
    "text": "can't be accessed individually so instead dam is divided into",
    "start": "379080",
    "end": "384400"
  },
  {
    "text": "rows so you can only access one row at a time so if the system wants to access a par particular row it has to First Tell",
    "start": "384400",
    "end": "391319"
  },
  {
    "start": "386000",
    "end": "386000"
  },
  {
    "text": "the bank to activate that row and that basically connects this row cells to something called the row buffer and that",
    "start": "391319",
    "end": "397840"
  },
  {
    "text": "drains this the charge from the cells and in doing so it copies the row data into the bank's row buffer and then the",
    "start": "397840",
    "end": "403960"
  },
  {
    "text": "system can read or write the contents of the row buffer and if the system wants to access a different row then first the",
    "start": "403960",
    "end": "410160"
  },
  {
    "text": "dran bank has to write the data that's in the row buffer back into the r it came from and that involves putting",
    "start": "410160",
    "end": "416639"
  },
  {
    "text": "charge back into the row cells so basically a D um a bank of dram has a notion of a currently activated row and",
    "start": "416639",
    "end": "425120"
  },
  {
    "text": "that acts a bit like a cache so accessing the current row is first and accessing a different row is somewhat",
    "start": "425120",
    "end": "431160"
  },
  {
    "text": "slower so that's basically how rows work and the other thing to note about dram",
    "start": "431160",
    "end": "436800"
  },
  {
    "start": "435000",
    "end": "435000"
  },
  {
    "text": "is that because the cells are capacitors charge tends to leak out of them so the Contex of cells have to be periodically",
    "start": "436800",
    "end": "443520"
  },
  {
    "text": "refreshed and that's why it's called Dynamic RAM and refreshing a row works the same way as accessing it so the",
    "start": "443520",
    "end": "450039"
  },
  {
    "text": "system rows reads a row a row into the row buffer and then writes it back and",
    "start": "450039",
    "end": "455080"
  },
  {
    "text": "the current standard is that a given row should be refreshed at least every 64 milliseconds which is about 16 times a",
    "start": "455080",
    "end": "462400"
  },
  {
    "text": "second so in other words a cell has to hold its contents for at least 64",
    "start": "462400",
    "end": "468800"
  },
  {
    "text": "milliseconds but so that's that's the intro to how dram works but um now I'll",
    "start": "468800",
    "end": "475240"
  },
  {
    "start": "470000",
    "end": "470000"
  },
  {
    "text": "talk about one way in which it goes wrong so I explained that cells have to hold their contents for 64",
    "start": "475240",
    "end": "481960"
  },
  {
    "text": "milliseconds but Dr manufacturers started screwing up by making dram where",
    "start": "481960",
    "end": "487599"
  },
  {
    "text": "the cells don't always hold their contents for that long and the particular problem is that if you",
    "start": "487599",
    "end": "494319"
  },
  {
    "text": "repeatedly activate a row many many times then on some Dr modules some of",
    "start": "494319",
    "end": "500360"
  },
  {
    "text": "the cells in neighboring rows can lose their values in a Time shorter than the",
    "start": "500360",
    "end": "505560"
  },
  {
    "text": "64 milliseconds that's they're supposed to keep them for and this is known as the row Hammer problem because",
    "start": "505560",
    "end": "512320"
  },
  {
    "text": "repeatedly activating a row is referred to as hammering the row and the reason",
    "start": "512320",
    "end": "518039"
  },
  {
    "text": "this has happened is that over time Dr manufacturers have been squeezing more",
    "start": "518039",
    "end": "523279"
  },
  {
    "text": "and more cells onto a chip and as they've done that they put the cells",
    "start": "523279",
    "end": "528440"
  },
  {
    "text": "closer together and the result is that the cells aren't as well isolated from",
    "start": "528440",
    "end": "533519"
  },
  {
    "text": "each other as they used to be so maybe charge can leap between them allly and",
    "start": "533519",
    "end": "538959"
  },
  {
    "text": "as they store less charge then they're more vulnerable to being disturbed so I don't know the exact",
    "start": "538959",
    "end": "545320"
  },
  {
    "text": "electrical explanation but the the end result is that these disturbances are observable observable from software and",
    "start": "545320",
    "end": "553760"
  },
  {
    "text": "software can cause them too and so basically this this problem tends to",
    "start": "553760",
    "end": "561160"
  },
  {
    "start": "557000",
    "end": "557000"
  },
  {
    "text": "be associated with particular bad cells in a d module and those are tend to be",
    "start": "561160",
    "end": "566800"
  },
  {
    "text": "randomly distributed throughout a module and a lot of those bad cells will consistently get bit errors when the",
    "start": "566800",
    "end": "574399"
  },
  {
    "text": "neighboring well is hammered they do tend to have a preferred direction for flipping so some bad cells will tend to",
    "start": "574399",
    "end": "580839"
  },
  {
    "text": "flip from a zero to a one and others from a one to a zero um that direction can change though across a reboot",
    "start": "580839",
    "end": "588680"
  },
  {
    "text": "because memory controllers tend to do this thing called Data scrambling and the seed for that scrambling is is",
    "start": "588680",
    "end": "594680"
  },
  {
    "text": "changed on a reboot so this amount of this this propor of bad cells can can vary quite a",
    "start": "594680",
    "end": "601240"
  },
  {
    "text": "bit between D modules so um for example the percentage of rows containing bad",
    "start": "601240",
    "end": "607440"
  },
  {
    "text": "cells can vary from anything from 30% to",
    "start": "607440",
    "end": "612640"
  },
  {
    "text": "99.9% and also the number of RA activations that you need to cause one of these um errors um Can can vary um on",
    "start": "612640",
    "end": "622000"
  },
  {
    "text": "one module it was as low as 98,000 row activations which was about 8% of what",
    "start": "622000",
    "end": "627959"
  },
  {
    "text": "the DDR three said that that module was supposed to be able to ex um",
    "start": "627959",
    "end": "634760"
  },
  {
    "text": "take and the main reason we know about this is that there was a paper published about it last year by a group at CMU",
    "start": "634760",
    "end": "643079"
  },
  {
    "text": "it's entitled um flipping bits in memory without accessing them there were actually three other papers um published",
    "start": "643079",
    "end": "650120"
  },
  {
    "text": "about it too but they weren't quite as well publicized and they weren't as detailed and so the CMU paper was",
    "start": "650120",
    "end": "657519"
  },
  {
    "text": "published in in June last year here and I came across it later in September and",
    "start": "657519",
    "end": "663160"
  },
  {
    "text": "the reason I mentioned this is it was that it didn't take me very long actually to work out how to exploit this",
    "start": "663160",
    "end": "670600"
  },
  {
    "text": "compared with how long the industry has known about this problem so about 4 days",
    "start": "670600",
    "end": "675720"
  },
  {
    "text": "after reading the paper I found I could Repro the problem on a spare laptop that",
    "start": "675720",
    "end": "681360"
  },
  {
    "text": "I had and then about 4 weeks after reading the paper I had a an nackal an",
    "start": "681360",
    "end": "686680"
  },
  {
    "text": "exploit for Native client working and about 12 weeks after I had a kernel exploit",
    "start": "686680",
    "end": "693279"
  },
  {
    "text": "working so so in contrast to that timeline the origins of the problem go back to about four years earlier so the",
    "start": "693279",
    "end": "701040"
  },
  {
    "text": "earliest laptops and dram that I know of that had the problem are from about",
    "start": "701040",
    "end": "707320"
  },
  {
    "text": "2010 and there's a paper and some patent applications about the problem from",
    "start": "707320",
    "end": "712959"
  },
  {
    "text": "2012 so the industry knew about this for a while but it was generally keeping quite quiet about the problem until the",
    "start": "712959",
    "end": "720040"
  },
  {
    "text": "splash made by the CMU paper last summer okay so I've talked about the the",
    "start": "720040",
    "end": "727440"
  },
  {
    "text": "basic problem and now I'll talk a bit about how you can cause row hammering from software and that's one of the",
    "start": "727440",
    "end": "734040"
  },
  {
    "text": "thing that CMU paper explained they had a a fragment of code that showed how you could do this from software so the basic",
    "start": "734040",
    "end": "741320"
  },
  {
    "text": "the basic problem here is how can you cause repeated activations of a row and",
    "start": "741320",
    "end": "747040"
  },
  {
    "start": "747000",
    "end": "747000"
  },
  {
    "text": "there are basically two requirements for that the first one is that you have to",
    "start": "747040",
    "end": "752760"
  },
  {
    "text": "cause accesses to the underlying dramm so you can't just do normal memory",
    "start": "752760",
    "end": "758519"
  },
  {
    "text": "accesses because to the same um memory location repeatedly because that will",
    "start": "758519",
    "end": "764000"
  },
  {
    "text": "those will get served from the cache um so you have to find a way to bypass the",
    "start": "764000",
    "end": "769160"
  },
  {
    "text": "cache and on an x86 machine the simplest way to do that is to use the CL flush",
    "start": "769160",
    "end": "775519"
  },
  {
    "text": "instruction which flushes a cach line and interestingly uh C flush is an",
    "start": "775519",
    "end": "781040"
  },
  {
    "text": "unprivileged instruction so any process can use it and it actually can't be",
    "start": "781040",
    "end": "786920"
  },
  {
    "text": "disabled um which is slightly surprising because on other architectures like um",
    "start": "786920",
    "end": "792040"
  },
  {
    "text": "the the equivalent cash flash instruction is actually privileged however so if you do a CL",
    "start": "792040",
    "end": "799120"
  },
  {
    "text": "flushed access to a single address that by itself is not going to do row hammering because those accesses will",
    "start": "799120",
    "end": "805560"
  },
  {
    "text": "all go to the same row so the second requirement is um to do row hammering",
    "start": "805560",
    "end": "810839"
  },
  {
    "text": "you have to pick more than two addresses or at Le sorry at least two addresses in different rows and access them",
    "start": "810839",
    "end": "817440"
  },
  {
    "text": "alternately and that forces changes to the current row and there is another requirement too",
    "start": "817440",
    "end": "824639"
  },
  {
    "text": "so um the two addresses you pick have to be in the same bank so that's because D",
    "start": "824639",
    "end": "831199"
  },
  {
    "text": "modules are divided into Banks and each bank has its own independent current row",
    "start": "831199",
    "end": "838320"
  },
  {
    "text": "so if if you were to pick two addresses in the same bank um then that would",
    "start": "838320",
    "end": "843360"
  },
  {
    "text": "activate the the different the rows in those Banks just once and it wouldn't be",
    "start": "843360",
    "end": "848440"
  },
  {
    "text": "causing repeated activations so this so this gives the",
    "start": "848440",
    "end": "855160"
  },
  {
    "text": "question how can we find a pair of addresses that do map two different rows in the same bank and initially that",
    "start": "855160",
    "end": "863399"
  },
  {
    "text": "seems like it would be difficult for a normal process to do CU there's there's two levels of indirection again way so",
    "start": "863399",
    "end": "869759"
  },
  {
    "text": "the process normally sees virtual addresses and those are mapped to physical addresses by the OS via page",
    "start": "869759",
    "end": "875360"
  },
  {
    "text": "tables and then the memory controller Maps those physical addresses to locations in the dram which includes the",
    "start": "875360",
    "end": "883120"
  },
  {
    "text": "the bank number and the row number um so the first mapping is generally hidden and the second mapping isn't documented",
    "start": "883120",
    "end": "890040"
  },
  {
    "text": "or you can although you can revert to engineer it although that's can be a bit complicated",
    "start": "890040",
    "end": "896160"
  },
  {
    "text": "sometimes but well the Insight that I had was you don't actually need to know",
    "start": "896160",
    "end": "901320"
  },
  {
    "text": "about those two mappings to do row hammering from a normal process because we can just pick address pairs",
    "start": "901320",
    "end": "908320"
  },
  {
    "text": "randomly um so typically the number of banks is actually quite small it's something like eight or 16 so that means",
    "start": "908320",
    "end": "915880"
  },
  {
    "text": "we've got an eight a one in8 or 1 in 16 chance of getting two addresses they're",
    "start": "915880",
    "end": "921079"
  },
  {
    "text": "in the same bank and those are actually really good odds because we can try many address pairs in turn as we search for a",
    "start": "921079",
    "end": "929079"
  },
  {
    "text": "pair that can cause a bit error and the result of all this is my",
    "start": "929079",
    "end": "934959"
  },
  {
    "text": "rammer test program which is on GitHub and it has repoed bit flips on quite a",
    "start": "934959",
    "end": "941480"
  },
  {
    "text": "few different machines and so it's fairly simple um it allocates a gigabyte of memory and then it tries to hammer",
    "start": "941480",
    "end": "948639"
  },
  {
    "text": "that memory and it looks forit for bit flips in that memory and it's kind of",
    "start": "948639",
    "end": "953680"
  },
  {
    "text": "risky to run in principle because it could corrupt other processes or it could corrupt the kernel although it doesn't often do that in practice I",
    "start": "953680",
    "end": "960800"
  },
  {
    "text": "think um and so we tested a selection of laptops with this test and we got bit",
    "start": "960800",
    "end": "966480"
  },
  {
    "text": "flips on about half of them although that proportion isn't necessarily very meaningful because of selection bias in",
    "start": "966480",
    "end": "972319"
  },
  {
    "text": "the the sample we tested and the results on our blog post and also this test hasn't been",
    "start": "972319",
    "end": "980880"
  },
  {
    "text": "fine-tuned so there are um there are cases where um a system could be",
    "start": "980880",
    "end": "987000"
  },
  {
    "text": "vulnerable and the test detect that all right and uh so there there are",
    "start": "987000",
    "end": "994040"
  },
  {
    "start": "992000",
    "end": "992000"
  },
  {
    "text": "a number of refinements you can do to the basic rammer testing and I think one of the important refinements we want to",
    "start": "994040",
    "end": "999319"
  },
  {
    "text": "talk about here is something that we call double-sided hammering and um the entire thing started with patient zero",
    "start": "999319",
    "end": "1005959"
  },
  {
    "text": "uh the first laptop that uh Mark reproduced the bit flips on and we were",
    "start": "1005959",
    "end": "1011120"
  },
  {
    "text": "lucky in the sense that that laptop was really bad in terms of RAM and because it was so bad we got a lot of data from",
    "start": "1011120",
    "end": "1017519"
  },
  {
    "text": "that laptop that then allowed us to refine uh our our approach to hammering cuz normally when you Hammer a laptop uh",
    "start": "1017519",
    "end": "1023720"
  },
  {
    "text": "you may get one bit flip every like in a given time frame it's very frustrating to draw inferences and make experiments",
    "start": "1023720",
    "end": "1029558"
  },
  {
    "text": "when the laptop doesn't consistently flip bits it drives you insane so we're lucky to have uh flippy flippy the",
    "start": "1029559",
    "end": "1036798"
  },
  {
    "start": "1036000",
    "end": "1036000"
  },
  {
    "text": "laptop uh Flippy's Ram uh is Stelly bad and when I say Stelly bad is now that we",
    "start": "1036799",
    "end": "1042480"
  },
  {
    "text": "know how to hammer flippy we can cause 50 bits to flip and More in an area of 8 kilobytes so that's lot of bits flipping",
    "start": "1042480",
    "end": "1050160"
  },
  {
    "text": "um and the nice thing really is that flippy being so prone to to causing and",
    "start": "1050160",
    "end": "1055240"
  },
  {
    "text": "having bit flips was great for the research that we did so what we did is uh we run this rammer test for a couple",
    "start": "1055240",
    "end": "1060720"
  },
  {
    "text": "days and rammer test now was searching through physical addresses uh trying to find addresses that will cause bit flips",
    "start": "1060720",
    "end": "1066960"
  },
  {
    "text": "when Hamet and after we had run it for a couple days we took all these addresses that we had seen to cause bit flips and",
    "start": "1066960",
    "end": "1073640"
  },
  {
    "text": "then we hammered them again this time not randomized but seriously just these addresses and uh we collected the data",
    "start": "1073640",
    "end": "1079480"
  },
  {
    "text": "from it and then started looking at it and uh we ended up with this interesting plot where the x-axis is the number of",
    "start": "1079480",
    "end": "1086640"
  },
  {
    "text": "bits that ended up flipping when we hammered two addresses and then on the y- axis you see uh the log two of the",
    "start": "1086640",
    "end": "1092200"
  },
  {
    "text": "Delta between the address where the bit flips occurred and the addresses which we hammered and you see on the far left",
    "start": "1092200",
    "end": "1098080"
  },
  {
    "text": "side that when you have one or two bit flips uh the the Delta to where your hammering is pretty much all over the",
    "start": "1098080",
    "end": "1103919"
  },
  {
    "text": "place there's a lot of variation there but to the right hand side you see fairly consistently well this is just an",
    "start": "1103919",
    "end": "1111400"
  },
  {
    "text": "illustration so you see we're hammering like a blue triangle means this is hammering above one of the the addresses",
    "start": "1111400",
    "end": "1117000"
  },
  {
    "text": "that we were targeting a red triangle is the other Target that we're hammering and uh what we saw very quickly is that",
    "start": "1117000",
    "end": "1124159"
  },
  {
    "text": "any time we got more than a few bit flips like many bit flips 20 plus and so forth um we had a fixed distance that we",
    "start": "1124159",
    "end": "1131799"
  },
  {
    "text": "were hammering from the target area where the bit flips were occurring of roughly 256k above and below meaning",
    "start": "1131799",
    "end": "1138840"
  },
  {
    "text": "that well if you picked your addresses correctly then out of a sudden on models or on laptops of the same model you",
    "start": "1138840",
    "end": "1145120"
  },
  {
    "text": "would be much better at hammering and we we thought about what's going on here and uh then we understood what was",
    "start": "1145120",
    "end": "1151159"
  },
  {
    "text": "happening and what was happening is the following on the left hand side here you see uh a diagram that explains to you or",
    "start": "1151159",
    "end": "1157320"
  },
  {
    "text": "that that illustrates what happens when you're hammering so on the left hand side we're activating two rows that are quite far from each other and every time",
    "start": "1157320",
    "end": "1163799"
  },
  {
    "text": "you activate one of those um it influences its neighboring rows somehow that to make them more prone to bit",
    "start": "1163799",
    "end": "1169600"
  },
  {
    "text": "flipping um and this is illustrated by them being an orange but now on the right hand side we're picking two rows",
    "start": "1169600",
    "end": "1175240"
  },
  {
    "text": "in a way that there's exactly one row in the middle which means that middle row will get hit on every activation not",
    "start": "1175240",
    "end": "1180840"
  },
  {
    "text": "only on one activation every time and this hammering from two sides at once um",
    "start": "1180840",
    "end": "1186080"
  },
  {
    "text": "turns a lot of machines that we previously thought were not vulnerable into vulnerable so my work laptop at the",
    "start": "1186080",
    "end": "1191280"
  },
  {
    "text": "time which I was writing the code that I was running on flippy um had been thought to be not vulnerable and then I",
    "start": "1191280",
    "end": "1196960"
  },
  {
    "text": "wrote the code for double-sided hammering and accidentally at one point launched it on my laptop on my work laptop instead of on Flippy and all of a",
    "start": "1196960",
    "end": "1203559"
  },
  {
    "text": "sudden started producing bit flips there so that was a a big realization for us that if you figure out how to to hammer",
    "start": "1203559",
    "end": "1210080"
  },
  {
    "text": "for a particular laptop model you get much better at hammering for that model the difficulty though is that um you",
    "start": "1210080",
    "end": "1216440"
  },
  {
    "text": "need to pick aggressor rows that are exactly two apart and because the mapping between virtual memory and",
    "start": "1216440",
    "end": "1222200"
  },
  {
    "text": "physical memory uh and then well not virtual memory and physical memory but the mapping between physical addresses",
    "start": "1222200",
    "end": "1228200"
  },
  {
    "text": "and the actual Banks is different uh between different laptops um that means",
    "start": "1228200",
    "end": "1233559"
  },
  {
    "text": "that you really if you really want to be effective at hammering a particular laptop you probably want to have",
    "start": "1233559",
    "end": "1239640"
  },
  {
    "text": "experiments on a laptop of the same type just to make sure that you're uh picking the right distances between addresses to",
    "start": "1239640",
    "end": "1246440"
  },
  {
    "text": "hammer um and we were lucky in the sense that we had a very vulnerable laptop that provided us with enough data so we",
    "start": "1246440",
    "end": "1252200"
  },
  {
    "text": "could infer the proper distances and then use those proper distances to hammer other laptops which then turned out to be vulnerable but we thought",
    "start": "1252200",
    "end": "1258480"
  },
  {
    "text": "we're not vulnerable initially and it's it's almost a pattern that occurred during this this research that the",
    "start": "1258480",
    "end": "1264000"
  },
  {
    "text": "hammering got better over time as we figured out more uh about",
    "start": "1264000",
    "end": "1269600"
  },
  {
    "text": "it right um yeah in fact or in practice there's there's of course the problem",
    "start": "1269640",
    "end": "1275200"
  },
  {
    "text": "that uh you need to a figure out the mapping for the particular laptop model and then you also need to be able to go",
    "start": "1275200",
    "end": "1281159"
  },
  {
    "text": "from virtual memory to at least physical memory um relative addressing meaning you need to be able to pick two physical",
    "start": "1281159",
    "end": "1287720"
  },
  {
    "text": "addresses that are a particular distance apart and on the Linux it is fairly easy because Linux does provide you or used",
    "start": "1287720",
    "end": "1293880"
  },
  {
    "text": "to provide you with a self page map which tells you virtual to physical mapping doesn't anymore I think but um",
    "start": "1293880",
    "end": "1301320"
  },
  {
    "text": "long story short if you don't have the ability to address uh physical memory in that sense the randomized hammering",
    "start": "1301320",
    "end": "1307520"
  },
  {
    "text": "approach of the original row hammer test may be more more appropriate at the cost of causing few bit",
    "start": "1307520",
    "end": "1315000"
  },
  {
    "text": "flips okay so we we've talked about how you can cause bit flips now I'm going to talk a bit about how you can exploit",
    "start": "1316840",
    "end": "1325159"
  },
  {
    "text": "that so so earlier we we posed the question of how you would exploit a bit flip at a completely random place in",
    "start": "1325240",
    "end": "1332600"
  },
  {
    "text": "physical memory and there's actually a generic strategy you could use for that",
    "start": "1332600",
    "end": "1337919"
  },
  {
    "text": "and the the jvm exploit that halar mentioned earlier is an example of that strategy so firstly we would want to",
    "start": "1337919",
    "end": "1344520"
  },
  {
    "text": "find a data structure to attack and that should be one where um a single bit error at a random",
    "start": "1344520",
    "end": "1351400"
  },
  {
    "text": "location has quite a good chance of increasing our Privileges and then we would try and fill as much memory as",
    "start": "1351400",
    "end": "1357559"
  },
  {
    "text": "possible with that data structure and then try and cause bit flips to occur or wait for them and then somehow we need",
    "start": "1357559",
    "end": "1365080"
  },
  {
    "text": "to figure out whether a useful bit flip has occurred and then if it did try and",
    "start": "1365080",
    "end": "1370240"
  },
  {
    "text": "make use of it so I basically built two privilege escalation exploits using the rammer buug and they both use um that",
    "start": "1370240",
    "end": "1377960"
  },
  {
    "text": "generic strategy so the first one escapes from the Native client sandbox so knle sorry",
    "start": "1377960",
    "end": "1385440"
  },
  {
    "text": "native client is an inprocess sandbox that's used in the Chrome web browser and breaking out that sandbox",
    "start": "1385440",
    "end": "1391240"
  },
  {
    "text": "means an attacker can run arbitrary code inside the host process and the second exploit is a root",
    "start": "1391240",
    "end": "1399120"
  },
  {
    "text": "exploit which starts out running in a normal process on Linux but can break out of that process and gain kernel",
    "start": "1399120",
    "end": "1405480"
  },
  {
    "text": "privileges and control over the whole machine so in principle those two exploits could",
    "start": "1405480",
    "end": "1411600"
  },
  {
    "text": "be chained together although I've not actually tried that so you could start off with a naal a native client",
    "start": "1411600",
    "end": "1417080"
  },
  {
    "text": "application running in Chrome and it could escalate to gain control over the whole machine and interestingly it will",
    "start": "1417080",
    "end": "1424080"
  },
  {
    "text": "be using the same underlying Hardware bug for both of those exploit steps so I think that's that's significant because",
    "start": "1424080",
    "end": "1430200"
  },
  {
    "text": "it it's significant because it shows that these um bit flips are exploitable in multiple contexts so each exploit is",
    "start": "1430200",
    "end": "1437679"
  },
  {
    "text": "not a oneoff so even if a system uses multiple layers of security it's",
    "start": "1437679",
    "end": "1443240"
  },
  {
    "text": "possible that multiple layers can be vulnerable to rammer so I'll talk about",
    "start": "1443240",
    "end": "1448679"
  },
  {
    "text": "the um the native client exploit first so native client is known as na for",
    "start": "1448679",
    "end": "1453960"
  },
  {
    "text": "short and this is the exploit that I got working first because it was the easier one to do and because I'm I'm more",
    "start": "1453960",
    "end": "1460520"
  },
  {
    "start": "1460000",
    "end": "1460000"
  },
  {
    "text": "familiar with with nackle so so knle is basically a sandboxing system for",
    "start": "1460520",
    "end": "1465720"
  },
  {
    "text": "running native code such as CN C++ programs and it's used in Chrome and",
    "start": "1465720",
    "end": "1471880"
  },
  {
    "text": "Chrome allows um one variant of knle called portable native client to be used",
    "start": "1471880",
    "end": "1476919"
  },
  {
    "text": "by any web page though I should point out that my exploit only targets a",
    "start": "1476919",
    "end": "1482320"
  },
  {
    "text": "different variant of knle that's only usable by apps in the Chrome web store um so ne's goal is basically to",
    "start": "1482320",
    "end": "1489480"
  },
  {
    "text": "make C and C+ C and C++ code as safe as JavaScript and it's kind of similar in",
    "start": "1489480",
    "end": "1496000"
  },
  {
    "text": "that respect to Asm MJS and and like asm.js it's an inprocess",
    "start": "1496000",
    "end": "1502399"
  },
  {
    "text": "sandbox um so it's memory ACC the memory access to a program inside that sandbox",
    "start": "1502399",
    "end": "1507799"
  },
  {
    "text": "are limited to a range of the processes address space so if you have a Sandbox like that",
    "start": "1507799",
    "end": "1514720"
  },
  {
    "start": "1512000",
    "end": "1512000"
  },
  {
    "text": "um there's a generic strategy that you can use for escaping an inprocess sandbox so firstly you would try to get",
    "start": "1514720",
    "end": "1522320"
  },
  {
    "text": "your shell code your attack code marked as executable and for knle that's actually",
    "start": "1522320",
    "end": "1528000"
  },
  {
    "text": "fairly easy and in the second the Second Step would be to try and cause a jump to",
    "start": "1528000",
    "end": "1533240"
  },
  {
    "text": "that shell Cod and that's the main challenge in this case for",
    "start": "1533240",
    "end": "1538679"
  },
  {
    "text": "knle um the way we get the Shell Code marked as executable is actually kind of",
    "start": "1538760",
    "end": "1543919"
  },
  {
    "text": "similar to how uh jet spraying techniques are used for exploiting JavaScript Jets basically we can hide",
    "start": "1543919",
    "end": "1550840"
  },
  {
    "text": "the code inside other x86 instructions and that's kind of easy to do for knle",
    "start": "1550840",
    "end": "1557320"
  },
  {
    "text": "because Nao allows loading any chunk of x86 code as long as it passes nao's",
    "start": "1557320",
    "end": "1565039"
  },
  {
    "text": "validator so the validator is this thing that checks that code uses a safe set of",
    "start": "1565039",
    "end": "1570159"
  },
  {
    "text": "x86 instructions and that the code passes some other safety properties and knal safety basically",
    "start": "1570159",
    "end": "1577159"
  },
  {
    "text": "works by ensuring you can only do indirect jumps to 32 bite aligned addresses and that will make sure those",
    "start": "1577159",
    "end": "1583840"
  },
  {
    "text": "addresses only contain safe instructions but if you can find a way to jump to a",
    "start": "1583840",
    "end": "1588880"
  },
  {
    "text": "non 32 by aligned address you can escape the sandbox because you can hide other",
    "start": "1588880",
    "end": "1594039"
  },
  {
    "text": "instructions at those addresses like in the example in the slide you can hide an unsafe CIS call instruction inside a",
    "start": "1594039",
    "end": "1601039"
  },
  {
    "text": "safe moabs instruction so normally knle enforces",
    "start": "1601039",
    "end": "1606960"
  },
  {
    "text": "his safety property by saying indirect jumps can only use can only be done via",
    "start": "1606960",
    "end": "1612440"
  },
  {
    "text": "this instruction sequence shown in the slide which forces the destination to be aligned",
    "start": "1612440",
    "end": "1619480"
  },
  {
    "start": "1619000",
    "end": "1619000"
  },
  {
    "text": "um but of course knle assumes that after it's loaded and validated this code it",
    "start": "1619480",
    "end": "1624640"
  },
  {
    "text": "doesn't change if but if we get row Hammer bit flips inside this code then it can",
    "start": "1624640",
    "end": "1631039"
  },
  {
    "text": "easily become unsafe so that's basically the approach I use in a xlo we we load many copies of",
    "start": "1631039",
    "end": "1638279"
  },
  {
    "text": "this code into memory and then we try and cuse bit flips in the code and my exploit can actually use can",
    "start": "1638279",
    "end": "1645840"
  },
  {
    "text": "actually exploit bit flips in any of the register numbers in this code",
    "start": "1645840",
    "end": "1651000"
  },
  {
    "text": "fragment and then then then it would use those to jump to the hidden Shell Code if the exploit gets a bit flip in",
    "start": "1651000",
    "end": "1659360"
  },
  {
    "text": "another part of the code that's not a register number then it actually can't it can't exploit those but it's not",
    "start": "1659360",
    "end": "1666519"
  },
  {
    "text": "going to crash it will just detect that and carry on until it finds another bit flip so it's a fairly lowrisk strategy",
    "start": "1666519",
    "end": "1673279"
  },
  {
    "text": "and actually unit tested the exploit to make sure that handles all those possible bit flips correctly so this",
    "start": "1673279",
    "end": "1680000"
  },
  {
    "text": "this means that about 133% of the possible bit flips in this code sequence are exploitable by my proof of concept",
    "start": "1680000",
    "end": "1686960"
  },
  {
    "text": "code and those are those are quite good odds because we can just keep trying until we get one that is",
    "start": "1686960",
    "end": "1693480"
  },
  {
    "text": "exploitable and I should also point out that there are two aspects of the knal sandbox that make this attack a bit",
    "start": "1695600",
    "end": "1701640"
  },
  {
    "text": "easier so knle allows Dynamic loading of code so we can load lots of copies of this of this sequence and also knle more",
    "start": "1701640",
    "end": "1709880"
  },
  {
    "text": "importantly knle allows a program to read its own code segment so we can read that code segment to see if we've got",
    "start": "1709880",
    "end": "1716919"
  },
  {
    "text": "any bit flips to the code and that's in contrast to um JavaScript VMS where",
    "start": "1716919",
    "end": "1723120"
  },
  {
    "text": "typically the code is hidden I think if knuckle hid the code it would make make",
    "start": "1723120",
    "end": "1728200"
  },
  {
    "text": "exploitation harder but I think it would still be possible because you could probably figure a way to do",
    "start": "1728200",
    "end": "1734480"
  },
  {
    "text": "it and that oh and um so basically we can um we can also Hammer that code",
    "start": "1736399",
    "end": "1742720"
  },
  {
    "text": "segment by doing CL flushed accesses to it which does bring me on to the next point which although knle um Can can",
    "start": "1742720",
    "end": "1750880"
  },
  {
    "text": "enforce that only a subset of instructions used that subset did include CL flush oops um I think the",
    "start": "1750880",
    "end": "1759640"
  },
  {
    "text": "reason it was allowed was because someone was asking the question is there any reason this shouldn't be disallowed and according to the x86 spec it's safe",
    "start": "1759640",
    "end": "1768080"
  },
  {
    "text": "but unfortunately that's not the right question to ask because um there wasn't really any good reason to be allowing it",
    "start": "1768080",
    "end": "1776200"
  },
  {
    "text": "either and we've we've also since changed validated to disallow CL",
    "start": "1776200",
    "end": "1782159"
  },
  {
    "text": "flash okay so I've described how you can escape the knal sandbox um once you've",
    "start": "1783120",
    "end": "1788760"
  },
  {
    "text": "done that what can you do well there's actually not an awful that you can do cuz we're still inside a process level",
    "start": "1788760",
    "end": "1794919"
  },
  {
    "text": "sandbox that's fairly strict and we're not inside the renderer process so you can't steal cookies but we could try um",
    "start": "1794919",
    "end": "1801880"
  },
  {
    "text": "escaping from the process level sandbox 2 and that's what the next exploit tries to do although it's not specific to",
    "start": "1801880",
    "end": "1808279"
  },
  {
    "text": "escaping from a knle",
    "start": "1808279",
    "end": "1811360"
  },
  {
    "text": "process okay so I'll explain the kernel exploit now and in this case the data structure that we attack is Page",
    "start": "1814080",
    "end": "1821559"
  },
  {
    "text": "tables so just a little bit of background about page tables computer science recap here um so they are the",
    "start": "1821559",
    "end": "1828000"
  },
  {
    "text": "data structure that the hardware uses for mapping a process's virtual addresses to the hard to the machine's",
    "start": "1828000",
    "end": "1833880"
  },
  {
    "text": "physical addresses and they're set up by the kernel so for example if you if you",
    "start": "1833880",
    "end": "1839440"
  },
  {
    "text": "allocate a page of memory using map then the kernel allocates a physical page and it also sets up a page table that points",
    "start": "1839440",
    "end": "1846399"
  },
  {
    "text": "that physical page now os's also tend to have features for shared memory that let us map the",
    "start": "1846399",
    "end": "1853240"
  },
  {
    "text": "same page multiple times so if we do that um if we create a shared memory",
    "start": "1853240",
    "end": "1858840"
  },
  {
    "text": "segment and M map it multiple times then we'll get lots of page tables pointing to the same physical pages and suppose",
    "start": "1858840",
    "end": "1866159"
  },
  {
    "text": "we create a 2 megabyte segment of shared memory and mmap it 10,000 times each",
    "start": "1866159",
    "end": "1871960"
  },
  {
    "text": "mapping is going to result in creating one 4K page table so we would get about",
    "start": "1871960",
    "end": "1877880"
  },
  {
    "text": "40 we would get page tables filling 40 megab of physical memory and if we scale",
    "start": "1877880",
    "end": "1884440"
  },
  {
    "text": "that up we can actually use this to fill most of physical memory with page tables",
    "start": "1884440",
    "end": "1891080"
  },
  {
    "text": "and actually Linux lets us do this CU it doesn't have any bound on the number of page tables that you can create it does",
    "start": "1891080",
    "end": "1897799"
  },
  {
    "text": "have a bound on the number of mappings a process can create but that's actually not a problem for us because we can just",
    "start": "1897799",
    "end": "1903559"
  },
  {
    "text": "make our mappings a bit bigger and we can still fill physical memory with page tables so once we've done that what",
    "start": "1903559",
    "end": "1910279"
  },
  {
    "text": "happens if we get a random single bit error somewhere in one of those page",
    "start": "1910279",
    "end": "1915320"
  },
  {
    "text": "tables well if if we're lucky then it will change the physical page not a page",
    "start": "1915320",
    "end": "1921159"
  },
  {
    "text": "number in a page table entry so it now points to a different physical",
    "start": "1921159",
    "end": "1926279"
  },
  {
    "text": "page and since we filled most of physical memory with page tables it's quite likely that the new physical page",
    "start": "1926279",
    "end": "1934440"
  },
  {
    "text": "number is going to be one of the page tables that describes our processes address space so if that happens we've just",
    "start": "1934440",
    "end": "1941679"
  },
  {
    "text": "broken the safety of the system so we've got access to a physical page that we werer supposed to that have access to in",
    "start": "1941679",
    "end": "1948880"
  },
  {
    "text": "particular one of our own page tables and if that happens then we can modify",
    "start": "1948880",
    "end": "1953960"
  },
  {
    "text": "that page table to point to any physical address that we like so we now have read",
    "start": "1953960",
    "end": "1959200"
  },
  {
    "text": "WR access to all a physical memory um we do have to work out which",
    "start": "1959200",
    "end": "1964639"
  },
  {
    "text": "virtual address the page table is is um corresponds to but that's actually",
    "start": "1964639",
    "end": "1970000"
  },
  {
    "text": "fairly straightforward because we can scan address pce to find it we would just have to scan to find a page it now",
    "start": "1970000",
    "end": "1977360"
  },
  {
    "text": "points to something that wasn't the shared memory segment we mapped so we can't unlike for the knal",
    "start": "1977360",
    "end": "1984519"
  },
  {
    "text": "exploit we can't look for the bit flip directly um because we can't read the",
    "start": "1984519",
    "end": "1989559"
  },
  {
    "text": "page tables directly but we can scan virtual juses to find it and so once we've got access to all",
    "start": "1989559",
    "end": "1995880"
  },
  {
    "start": "1993000",
    "end": "1993000"
  },
  {
    "text": "the physical memory it's actually um there's a lot of options for how you would use that for a practical exploit",
    "start": "1995880",
    "end": "2003120"
  },
  {
    "text": "so in my proof of concept um it it can run a command as root so the",
    "start": "2003120",
    "end": "2010240"
  },
  {
    "text": "way I did that was to find a phys the physical page number of some code that belongs to a set ID executable and then",
    "start": "2010240",
    "end": "2017919"
  },
  {
    "text": "we can override that overwrite that code and then run the executable but potentially we could do",
    "start": "2017919",
    "end": "2024360"
  },
  {
    "text": "other things like modify the Kernel's code or we could search through memory to find some other interesting pages to",
    "start": "2024360",
    "end": "2032840"
  },
  {
    "text": "modify so earlier I said that if we're lucky the bit flip would change the page",
    "start": "2032840",
    "end": "2039440"
  },
  {
    "start": "2033000",
    "end": "2033000"
  },
  {
    "text": "number in the page table entry but actually we don't need to be slaves to Randomness here we can actually make our",
    "start": "2039440",
    "end": "2045519"
  },
  {
    "text": "own Lu the idea is that we can take advantage of the fact that rammer bit",
    "start": "2045519",
    "end": "2051398"
  },
  {
    "text": "flips are often repeatable so we can find a victim page",
    "start": "2051399",
    "end": "2056599"
  },
  {
    "text": "that's got a bad memory cell at an offset that's useful to us",
    "start": "2056599",
    "end": "2062079"
  },
  {
    "text": "and then we can deallocate that page with M on map hands it back to the colonel while keeping our aggressor",
    "start": "2062079",
    "end": "2068638"
  },
  {
    "text": "Pages allocated and then we can get the konel to reuse that page as a page table and",
    "start": "2068639",
    "end": "2074919"
  },
  {
    "text": "then cause that memory cell to flip again so this is kind of similar to how",
    "start": "2074919",
    "end": "2081200"
  },
  {
    "text": "you might explo use after to free bug basically we can make a modification",
    "start": "2081200",
    "end": "2086800"
  },
  {
    "text": "to a page even though the Kel thinks we haven't got access to that page and we can also check in advance",
    "start": "2086800",
    "end": "2093240"
  },
  {
    "text": "that the bit that's going to flip is going to be one that's useful to our exploit to our exploit so we know what the format of a",
    "start": "2093240",
    "end": "2100280"
  },
  {
    "text": "page table is we can check that the bit flip is going to hit a a bit in the",
    "start": "2100280",
    "end": "2107079"
  },
  {
    "text": "physical page number that's going to be useful so we don't wanted to hit one of the High bits because that would um give",
    "start": "2107079",
    "end": "2114079"
  },
  {
    "text": "a physical page number that's out of range and that might cause a kernel panic we will basically so on a 4 gab",
    "start": "2114079",
    "end": "2120440"
  },
  {
    "text": "machine for example we'd want to make sure the bit Furs in one of the bottom 20 bits of the physical page number so",
    "start": "2120440",
    "end": "2126960"
  },
  {
    "text": "this means that about 20 of 64 possible bit flips are useful to",
    "start": "2126960",
    "end": "2134680"
  },
  {
    "text": "us um which is pretty good odds still that's like that's a third or",
    "start": "2134680",
    "end": "2139720"
  },
  {
    "text": "so um this also this knowledge of which  is going to flip also lets us",
    "start": "2139720",
    "end": "2145440"
  },
  {
    "text": "speed up the exploit because we know in advance which of the entries in a page table is going to change so when we're",
    "start": "2145440",
    "end": "2151480"
  },
  {
    "text": "spraying a physical memory with page tables we don't have to get all of the entries in a page table populated you",
    "start": "2151480",
    "end": "2158079"
  },
  {
    "text": "only have to get one of the 512 entries populated and that just speeds up the spraying process a lot and the result is",
    "start": "2158079",
    "end": "2165160"
  },
  {
    "text": "We can spray memory at about 1 G gigabyte a second and there's other there's one",
    "start": "2165160",
    "end": "2171839"
  },
  {
    "text": "other refinement I should mention so when we're allocating the shared memory segment that we repeatedly map Linux do",
    "start": "2171839",
    "end": "2178680"
  },
  {
    "text": "does tend to allocate that contiguously and we need to avoid that",
    "start": "2178680",
    "end": "2183760"
  },
  {
    "text": "otherwise if a bit flips in one of the low numbers of the physical it physical Pages it's probably still going to point",
    "start": "2183760",
    "end": "2190359"
  },
  {
    "text": "into the same shared memory segment so I came up with a um a simple",
    "start": "2190359",
    "end": "2196760"
  },
  {
    "text": "way to do all that which is just to force physical memory to be fragmented by allocating a lot of memory and then",
    "start": "2196760",
    "end": "2202560"
  },
  {
    "text": "by deallocating at one page at a time in a random",
    "start": "2202560",
    "end": "2207240"
  },
  {
    "text": "order so that's basically the kernal exploit um I'll talk about a little bit",
    "start": "2208440",
    "end": "2215680"
  },
  {
    "text": "about mitigations now now for the Rohmer problem um so there are basically three",
    "start": "2215680",
    "end": "2222040"
  },
  {
    "start": "2221000",
    "end": "2221000"
  },
  {
    "text": "mitigations there's ECC which you probably heard of there's",
    "start": "2222040",
    "end": "2228040"
  },
  {
    "text": "Target row refresh which you probably haven't heard of and then there's um doubling the refresh rate which is",
    "start": "2228040",
    "end": "2233880"
  },
  {
    "text": "fairly self-explanatory so so the first mitigation is to use ECC memory um so",
    "start": "2233880",
    "end": "2240359"
  },
  {
    "start": "2236000",
    "end": "2236000"
  },
  {
    "text": "ECC is a pretty good mitigation for bammer and most servers do use it",
    "start": "2240359",
    "end": "2245800"
  },
  {
    "text": "although lower end machines like laptops don't tend to have it so ECC can correct",
    "start": "2245800",
    "end": "2251359"
  },
  {
    "text": "some errors but not all of them it usually depends on how many bit errors you get for a per 64-bit word so if you",
    "start": "2251359",
    "end": "2259400"
  },
  {
    "text": "get one error ECC can correct that if you get two ECC can detect it but it",
    "start": "2259400",
    "end": "2265480"
  },
  {
    "text": "can't correct it and that usually leads to a reboot but if you get three errors EC can't even detect that and those",
    "start": "2265480",
    "end": "2273280"
  },
  {
    "text": "errors will be visible to software so the the number of Errors you get is generally going to depend on how",
    "start": "2273280",
    "end": "2278839"
  },
  {
    "text": "bad your dram is if you've got really bad dram you could get a three- bit",
    "start": "2278839",
    "end": "2284720"
  },
  {
    "text": "error but I think it's more likely that an attacker would cause a two bit error first and trigger a reboot so you'd get",
    "start": "2284720",
    "end": "2291520"
  },
  {
    "text": "a lot of reboots before this would be exploitable so basically ECC reduces the problem to being Deni of service problem",
    "start": "2291520",
    "end": "2298480"
  },
  {
    "text": "rather than privilege escalation problem so that is better but it's not",
    "start": "2298480",
    "end": "2303599"
  },
  {
    "text": "ideal so ECC doesn't really deal with the the root of the problem CU it's not it's not really well suited to dealing",
    "start": "2303599",
    "end": "2310520"
  },
  {
    "text": "with systematic errors so the um the second mitigation is called",
    "start": "2310520",
    "end": "2318160"
  },
  {
    "start": "2313000",
    "end": "2313000"
  },
  {
    "text": "Target row refresh and this is this is specific to rammer it does it requires some Hardware",
    "start": "2318160",
    "end": "2324760"
  },
  {
    "text": "changes um it does kind of get to the root of the problem",
    "start": "2324760",
    "end": "2330119"
  },
  {
    "text": "more so the idea behind Target row refresh is to count the number of times",
    "start": "2330359",
    "end": "2336880"
  },
  {
    "text": "each row is activated and if the count for a row reaches a particular threshold then the",
    "start": "2336880",
    "end": "2343280"
  },
  {
    "text": "system would refresh the Row's neighboring rows and there's two levels at which you",
    "start": "2343280",
    "end": "2348720"
  },
  {
    "text": "could Implement that so you could implement it in the cpu's memory controller or you could implement it in",
    "start": "2348720",
    "end": "2355160"
  },
  {
    "text": "the dam itself and it appears that vendors are using both approaches so um 1D run maker",
    "start": "2355160",
    "end": "2363400"
  },
  {
    "text": "data sheets indicate that they are implementing TR in the newer ddr4",
    "start": "2363400",
    "end": "2370440"
  },
  {
    "text": "chips um also it appears that Intel are",
    "start": "2370440",
    "end": "2377319"
  },
  {
    "text": "implementing trra in their CPUs memory controllers unfortunately it's not really clear which CPUs Implement that",
    "start": "2377319",
    "end": "2385960"
  },
  {
    "text": "um so there is one PDF of an Intel presentation from a conference that says",
    "start": "2385960",
    "end": "2391280"
  },
  {
    "text": "that some Zeon CPUs support something called pseudo TR although I've not found",
    "start": "2391280",
    "end": "2396680"
  },
  {
    "text": "any more public documentation about that okay so that's that's TR and it",
    "start": "2396680",
    "end": "2403359"
  },
  {
    "text": "does require newer Hardware so is there anything that we can do to mitigate rammer on existing",
    "start": "2403359",
    "end": "2410359"
  },
  {
    "text": "machines so fortunately there is one existing mitigation and that's to increase the",
    "start": "2410359",
    "end": "2416359"
  },
  {
    "start": "2411000",
    "end": "2411000"
  },
  {
    "text": "memories refresh rate and that's a third mitigation and you can do that with a bios update and some vendors have been",
    "start": "2416359",
    "end": "2422160"
  },
  {
    "text": "doing that they usually double the refresh rate so basically an attacker can only",
    "start": "2422160",
    "end": "2427760"
  },
  {
    "text": "do half as many raw activations as they could before between refreshes there is a question about",
    "start": "2427760",
    "end": "2432880"
  },
  {
    "text": "whether that's enough though um the CMU paper has a graph which shows that even",
    "start": "2432880",
    "end": "2438400"
  },
  {
    "text": "when you're doing one-sided hammering a double refresh rate isn't always enough to eliminate all the errors so maybe an",
    "start": "2438400",
    "end": "2444599"
  },
  {
    "text": "attacker would just have to take longer before they can trigger bit flips and this doesn't even take account for two",
    "start": "2444599",
    "end": "2450200"
  },
  {
    "text": "sided row hammering which would is more likely to cause",
    "start": "2450200",
    "end": "2454280"
  },
  {
    "text": "flips so having talked about mitigations um I think it's it's going to become more",
    "start": "2455319",
    "end": "2462440"
  },
  {
    "text": "interesting to see whether they're getting applied because it's becoming more apparent that it's possible to do",
    "start": "2462440",
    "end": "2467720"
  },
  {
    "text": "row hammering from JavaScript which is the this next section I'll talk about so originally it seemed like this",
    "start": "2467720",
    "end": "2474000"
  },
  {
    "text": "would be difficult to do because you can't use CL flush from JavaScript JavaScript would normally only do normal",
    "start": "2474000",
    "end": "2480800"
  },
  {
    "text": "cached memory accesses um so you would need to find a pattern of accesses that can generate a",
    "start": "2480800",
    "end": "2487400"
  },
  {
    "text": "high rate of cash misses and initially it seems like you would have to figure out how to get cash misses at all of the",
    "start": "2487400",
    "end": "2492839"
  },
  {
    "text": "cash levels so L1 L2 and L3 however it turns out that's easier",
    "start": "2492839",
    "end": "2498640"
  },
  {
    "text": "than it initially seems because on current Intel CPUs evicting a cach line",
    "start": "2498640",
    "end": "2504480"
  },
  {
    "text": "from the L3 cache also evicts it from L1 and L2 so the L1 and L2 caches don't",
    "start": "2504480",
    "end": "2511960"
  },
  {
    "text": "actually matter for our purposes of row hammering so so um if we want to",
    "start": "2511960",
    "end": "2517839"
  },
  {
    "text": "generate all three caches there's a the trick would be to find many addresses that map to the same cach set so for",
    "start": "2517839",
    "end": "2525640"
  },
  {
    "text": "example in a typical system might have a 12-way set associative cache if you can find 13 addresses ma to a cach set then",
    "start": "2525640",
    "end": "2534720"
  },
  {
    "text": "accessing them will generate at least one cach miss and it turns out there's already an",
    "start": "2534720",
    "end": "2540200"
  },
  {
    "text": "algorithm for finding addresses that have that property and it already Works in JavaScript and it works by timing",
    "start": "2540200",
    "end": "2547000"
  },
  {
    "text": "memory accesses uh it's described in a paper called the spy and the sandbox so that",
    "start": "2547000",
    "end": "2553280"
  },
  {
    "text": "gives us a way to generate cash misses the next question is whether we can generate cash misses that are optimal",
    "start": "2553280",
    "end": "2559520"
  },
  {
    "text": "for row hammering so ideally we do want the we would want the the misses to be for just two addresses well in the last",
    "start": "2559520",
    "end": "2566640"
  },
  {
    "text": "um two weeks a group has um from Austria and France have published a draft paper",
    "start": "2566640",
    "end": "2572079"
  },
  {
    "text": "about how to do this and they've got a clever algorithm for finding the right ordering and memory accesses that even",
    "start": "2572079",
    "end": "2578400"
  },
  {
    "text": "works on newer CPUs like Haswell um where the cash eviction is quite uh cash",
    "start": "2578400",
    "end": "2583599"
  },
  {
    "text": "eviction polic is quite complex and it can generate the unoptimal um set of of",
    "start": "2583599",
    "end": "2590359"
  },
  {
    "text": "cash misses so I think the remaining thing um that will be interesting to see is we",
    "start": "2590359",
    "end": "2596359"
  },
  {
    "text": "can also cause rammer bit flips on arm devices which I don't think anyone has really tried hard to do",
    "start": "2596359",
    "end": "2604359"
  },
  {
    "text": "yet given that the average quality of dam in uh in cell phones is likely to be worse than in laptops that may be",
    "start": "2605079",
    "end": "2613160"
  },
  {
    "start": "2612000",
    "end": "2612000"
  },
  {
    "text": "interesting so um so that's that's the JavaScript side of things",
    "start": "2615240",
    "end": "2621200"
  },
  {
    "text": "um so I think there are software bugs to conclude there are some software bugs that are easier to exploit than rammer",
    "start": "2621200",
    "end": "2629280"
  },
  {
    "text": "but as software level sandboxes are getting better um I think it might be",
    "start": "2629280",
    "end": "2634520"
  },
  {
    "text": "the case that uh attackers turn to exploit to exploiting more esoteric bugs",
    "start": "2634520",
    "end": "2640119"
  },
  {
    "text": "like rammer and we have seen multiple times that",
    "start": "2640119",
    "end": "2645160"
  },
  {
    "text": "rammer can actually be easier to exploit than it initially seems so picking how",
    "start": "2645160",
    "end": "2650760"
  },
  {
    "text": "we pick addresses was one example of that and rooh hammering from JavaScript was another example of that and this is",
    "start": "2650760",
    "end": "2657240"
  },
  {
    "text": "kind of unusual for being a hardware bug so normally the hardware can hide physics level issues um like charge",
    "start": "2657240",
    "end": "2664720"
  },
  {
    "text": "leaking but occasionally the hardware manufacturers do screw up and they push things too far so maybe we will see",
    "start": "2664720",
    "end": "2671359"
  },
  {
    "text": "issues like this again in the future and in general it's it's quite difficult to verify what the that the hardware does",
    "start": "2671359",
    "end": "2677880"
  },
  {
    "text": "what it's supposed to do and vendors haven't been terribly open about rammer in particular so I would like to see",
    "start": "2677880",
    "end": "2684880"
  },
  {
    "text": "vendors be more open and and to adopt a security mindset when they're thinking about these issues that appear to be",
    "start": "2684880",
    "end": "2691640"
  },
  {
    "text": "just reliability issues because we' we've shown that they can actually break multiple layers of",
    "start": "2691640",
    "end": "2698880"
  },
  {
    "text": "security so so lastly um if you to see more information about this we have some",
    "start": "2698880",
    "end": "2704880"
  },
  {
    "start": "2700000",
    "end": "2700000"
  },
  {
    "text": "test code on on GitHub and a mailing list for discussing the uh problem and",
    "start": "2704880",
    "end": "2710880"
  },
  {
    "text": "exploits for it and you can also see the the projects there a blog post that we posted any",
    "start": "2710880",
    "end": "2717040"
  },
  {
    "text": "questions yes please um actually questions uh the first is um do you use",
    "start": "2717040",
    "end": "2723079"
  },
  {
    "text": "roow Hammer to escape based sandbox and the second one is do",
    "start": "2723079",
    "end": "2729400"
  },
  {
    "text": "you believe that using J only you can get a so the first the the question was",
    "start": "2729400",
    "end": "2736119"
  },
  {
    "text": "whether rammer would work to escape from a hypervisor based sandbox and the second question is whether um it would",
    "start": "2736119",
    "end": "2742119"
  },
  {
    "text": "be possible to cause a rammer kernel exploit from JavaScript um when it comes to the hypervisor at least in theory",
    "start": "2742119",
    "end": "2749720"
  },
  {
    "text": "there is nothing that would stop rammer from being useful for hypervisor but the same principle would apply that we",
    "start": "2749720",
    "end": "2756319"
  },
  {
    "text": "mentioned earlier we would need to be able to pack Memory full of a data structure that when a bit flips it's",
    "start": "2756319",
    "end": "2762040"
  },
  {
    "text": "useful for us so would somewhat depend on what data structures the hypervisor allows the virtualized environment to to",
    "start": "2762040",
    "end": "2769119"
  },
  {
    "text": "allocate and we haven't looked into that as to the second question causing a kernel exploit from",
    "start": "2769119",
    "end": "2775280"
  },
  {
    "text": "JavaScript I think it may be easier for the attacker to first cause regular code",
    "start": "2775280",
    "end": "2781000"
  },
  {
    "text": "execution within that process from JavaScript by uh I mean the JavaScript",
    "start": "2781000",
    "end": "2786440"
  },
  {
    "text": "interpreter does jit these days so it's quite possible that the attacker is capable of um escaping the JavaScript",
    "start": "2786440",
    "end": "2792359"
  },
  {
    "text": "jitted code and run native code and then from the native code use the kernel escalation yeah you do a two-step thing",
    "start": "2792359",
    "end": "2798960"
  },
  {
    "text": "like in the that we did here think that that just the the basically",
    "start": "2798960",
    "end": "2806119"
  },
  {
    "text": "the same things that you show the question is whether you think be not use",
    "start": "2806119",
    "end": "2811520"
  },
  {
    "text": "that just use Javas to go straight to I think that's going to be much",
    "start": "2811520",
    "end": "2817599"
  },
  {
    "text": "harder if you find a way to fill physical memory with a data structure that the kernel that that has privilege",
    "start": "2817599",
    "end": "2824200"
  },
  {
    "text": "escalation Potential from JavaScript then it should be possible but I don't know like I don't have a good idea on how to do it off the top of",
    "start": "2824200",
    "end": "2830800"
  },
  {
    "text": "my head um hello are you aware of memory scrambling as a mitigation measure that",
    "start": "2830800",
    "end": "2838520"
  },
  {
    "text": "I I contacted my server provider when this happened and they said kind of this can be enabled in bias and as far as I",
    "start": "2838520",
    "end": "2846000"
  },
  {
    "text": "understand it it would change the memory mapping in a way that what the operating system sees as Hardware addresses are",
    "start": "2846000",
    "end": "2853680"
  },
  {
    "text": "not really the hardware addresses in memory so I think if you're doing address scrambling that could probably help mitigate for double-sided hammering",
    "start": "2853680",
    "end": "2860680"
  },
  {
    "text": "but not for one-sided hammering so there's a distinction between data scrambling and address scrambling so I",
    "start": "2860680",
    "end": "2866839"
  },
  {
    "text": "think I think you were talking about address scrambling which would probably help I think data scrambling wouldn't wouldn't help in a service scenario",
    "start": "2866839",
    "end": "2873000"
  },
  {
    "text": "you're probably better off with ECC like the the odds of an being able to escalate privileges without rebooting the machine when you have ECC un n",
    "start": "2873000",
    "end": "2881720"
  },
  {
    "text": "essentially did that answer the",
    "start": "2881720",
    "end": "2885400"
  },
  {
    "text": "question any other questions yes go back slide one side back",
    "start": "2886960",
    "end": "2894599"
  },
  {
    "text": "yeah any other questions yes I I know a lot of the arm embedded processor DDR",
    "start": "2898319",
    "end": "2905119"
  },
  {
    "text": "control BC and that cause a big problem foring this attack a lot of them are",
    "start": "2905119",
    "end": "2911200"
  },
  {
    "text": "enabled we do not know we just uh we did some very superficial Research into",
    "start": "2911200",
    "end": "2916760"
  },
  {
    "text": "trying to cause it on arm but we didn't try very hard so we have no",
    "start": "2916760",
    "end": "2921800"
  },
  {
    "text": "idea any other questions do you think it easier to from",
    "start": "2923720",
    "end": "2931720"
  },
  {
    "text": "java oriented I think it'll be the same for Java or",
    "start": "2934000",
    "end": "2939160"
  },
  {
    "text": "JavaScript yeah I think the because the jit is going toow yeah I think in both cases the jit",
    "start": "2939160",
    "end": "2945839"
  },
  {
    "text": "is going to generate native code which then has to have the proper access patterns so I don't think it matters",
    "start": "2945839",
    "end": "2951440"
  },
  {
    "text": "much all right I think we're out of time uh any other questions right outside thanks a lot",
    "start": "2951440",
    "end": "2959558"
  }
]