[
  {
    "start": "0",
    "end": "17000"
  },
  {
    "text": "um hello everybody and thanks for staying here until the end um my name is vasil Kim and the title of my talk today",
    "start": "240",
    "end": "7759"
  },
  {
    "text": "is red to Deer deconstructing caral isolation and this is Joint work with M poonis and Angelos kitis my colleagues",
    "start": "7759",
    "end": "15120"
  },
  {
    "text": "from Columbia University so before starting some stuff about myself I'm a PhD candidate at",
    "start": "15120",
    "end": "21359"
  },
  {
    "start": "17000",
    "end": "44000"
  },
  {
    "text": "Columbia University I'm a member of the network security lab there I have done work on various security Fields um and",
    "start": "21359",
    "end": "28359"
  },
  {
    "text": "I've published it main mainly in academic conferences lately I'm working on operating system security and",
    "start": "28359",
    "end": "34719"
  },
  {
    "text": "specifically on Kel Self self- Protection um and I also do some uh",
    "start": "34719",
    "end": "39920"
  },
  {
    "text": "offensive stuff and this talk is part of this line of work so um this is the agenda for today",
    "start": "39920",
    "end": "48239"
  },
  {
    "start": "44000",
    "end": "68000"
  },
  {
    "text": "red to Deer is a kernel exploitation technique so I'm going to start by giving an introduction of how kernel",
    "start": "48239",
    "end": "53559"
  },
  {
    "text": "attacks work and what what exactly we try to do with this uh with this technique then I'm going to move on to",
    "start": "53559",
    "end": "61120"
  },
  {
    "text": "how red to Deer works and how it can be used to bypass various kernal protection mechanisms and then I'm going to",
    "start": "61120",
    "end": "66640"
  },
  {
    "text": "conclude by summarizing our findings so let's start um so there is",
    "start": "66640",
    "end": "72200"
  },
  {
    "text": "an increased Focus uh on kernel exploitation nowadays so cural attacks are becoming more and more common and",
    "start": "72200",
    "end": "78680"
  },
  {
    "text": "this is mainly due to three reasons first of all the exploitation of userland privilege processes has become",
    "start": "78680",
    "end": "85360"
  },
  {
    "text": "much harder throughout the years we had various techniques um some of them provided by the operating systems some",
    "start": "85360",
    "end": "92360"
  },
  {
    "text": "other uh provided by compilers or a combination of of those two uh which made their way uh into most of the os's",
    "start": "92360",
    "end": "100320"
  },
  {
    "text": "these days and they they result into hardening applications um against exploits which",
    "start": "100320",
    "end": "107079"
  },
  {
    "text": "leads into moving the target into you know different a different Co a",
    "start": "107079",
    "end": "113360"
  },
  {
    "text": "different piece of code in the software stack and the kernel is an important piece of code because it's privileged so",
    "start": "113360",
    "end": "118960"
  },
  {
    "text": "it makes sense for to go to go after it and not only that it also has a huge",
    "start": "118960",
    "end": "124079"
  },
  {
    "text": "attack surface um there there is a constant stream of new features and",
    "start": "124079",
    "end": "129360"
  },
  {
    "text": "optimizations that gets into this part of code which is supposedly the one that is responsible for the Integrity of all",
    "start": "129360",
    "end": "136480"
  },
  {
    "text": "the security mechanisms in in the operating system and um so because of these three",
    "start": "136480",
    "end": "143200"
  },
  {
    "text": "reasons um we have we see that attackers are trying more and more to go against",
    "start": "143200",
    "end": "148319"
  },
  {
    "text": "the Kel instead of trying to find one privileged uh userland process and",
    "start": "148319",
    "end": "153560"
  },
  {
    "text": "exploit it and then go after go go around uh all these um you know",
    "start": "153560",
    "end": "159319"
  },
  {
    "text": "protection mechanisms that are deployed there um so on the one on the one uh",
    "start": "159319",
    "end": "166200"
  },
  {
    "start": "162000",
    "end": "203000"
  },
  {
    "text": "hand we have this um you know interest on more kernel exploitation but let's see um what the kernel what our kernels",
    "start": "166200",
    "end": "173959"
  },
  {
    "text": "do um in terms of of of bugs of vulnerabilities okay so what you you see",
    "start": "173959",
    "end": "179400"
  },
  {
    "text": "here in this graph is the distinct number the distinct number of uh bugs of",
    "start": "179400",
    "end": "184959"
  },
  {
    "text": "CV numbers specifically assigned to Kernel bugs throughout the years for all the kernels and we're talking about",
    "start": "184959",
    "end": "191159"
  },
  {
    "text": "commodity operating system kernels here like Linux Windows the bsds and so on so forth so as you can see there is an",
    "start": "191159",
    "end": "196440"
  },
  {
    "text": "increasing Trend so not only attackers go after the kernel but they also have a lot of um Candy to to play with um now",
    "start": "196440",
    "end": "205200"
  },
  {
    "start": "203000",
    "end": "307000"
  },
  {
    "text": "if we take a look at one particular operating system this is Linux you see that the same Trend more or less exists",
    "start": "205200",
    "end": "210920"
  },
  {
    "text": "here as well and the question is why do we see that okay did it happen that after 2003 we became terrible in writing",
    "start": "210920",
    "end": "218720"
  },
  {
    "text": "kernel code or is it something else um well as I said in the beginning there is",
    "start": "218720",
    "end": "225159"
  },
  {
    "text": "more interest in kernel exploitation so we have more guys auditing the code or fuzzing the code and trying to to to",
    "start": "225159",
    "end": "232439"
  },
  {
    "text": "exploit it and on this way they found some vulnerabilities and they reported so there is more interest so more",
    "start": "232439",
    "end": "238760"
  },
  {
    "text": "reported bugs on the other hand though um the number of um lines of code that",
    "start": "238760",
    "end": "245239"
  },
  {
    "text": "get into at least Linux has increased a lot but the same Trend also applies into other operating systems so as you can",
    "start": "245239",
    "end": "251920"
  },
  {
    "text": "see here we're comparing 26 2.6.1 with uh 3.10 two Kel versions one of them was",
    "start": "251920",
    "end": "259560"
  },
  {
    "text": "uh released in 2005 and the other one is 20 in 2013 and you can see that the development days for these two versions",
    "start": "259560",
    "end": "265960"
  },
  {
    "text": "is more or less the same but the number of patches that were pushed in the same more or less the same development cycle",
    "start": "265960",
    "end": "271880"
  },
  {
    "text": "in the kernel was much higher from 3.6 uh th000 patches we have in in the",
    "start": "271880",
    "end": "279919"
  },
  {
    "text": "first version we have U 13.3 in the",
    "start": "279919",
    "end": "285360"
  },
  {
    "text": "3.10 which means that we go from roughly two changes per hour to 10 changes nine",
    "start": "285360",
    "end": "291240"
  },
  {
    "text": "changes per hour so we have increased a lot the number of changes in kernel code",
    "start": "291240",
    "end": "296520"
  },
  {
    "text": "and remember this is the part of your code that guarante is all more or less all the Integrity of all the security uh",
    "start": "296520",
    "end": "303680"
  },
  {
    "text": "protections that you have in userland okay so um to give you um a very brief",
    "start": "303680",
    "end": "312360"
  },
  {
    "text": "overview of what what what kernel attacks fall into I have two categories",
    "start": "312360",
    "end": "317800"
  },
  {
    "text": "here um the first one is privilege escalation so here what uh we're talking about is",
    "start": "317800",
    "end": "325919"
  },
  {
    "text": "um attacks where the attacker already has some presence on the operating system he can run something like a",
    "start": "325919",
    "end": "331960"
  },
  {
    "text": "process or he has already managed to let's say take control of a particular",
    "start": "331960",
    "end": "337400"
  },
  {
    "text": "process in the operating system and the goal there is to escalate privilege okay become root let's see the other type of",
    "start": "337400",
    "end": "343639"
  },
  {
    "text": "attacks falls into the second category which is the persistent foothold there the attacker attacks the kernel for a",
    "start": "343639",
    "end": "349680"
  },
  {
    "text": "for a different purpose the purpose there is to he already has access roote",
    "start": "349680",
    "end": "354960"
  },
  {
    "text": "access to the machine and he needs to hold that access okay so we're talking about root kits things like that so in",
    "start": "354960",
    "end": "361600"
  },
  {
    "start": "361000",
    "end": "557000"
  },
  {
    "text": "this talk whenever I I talk about an attack I'm talking about the first class okay the model of the attacker that we",
    "start": "361600",
    "end": "368599"
  },
  {
    "text": "consider here it's somebody who has already uh local access to the machine",
    "start": "368599",
    "end": "373880"
  },
  {
    "text": "not privileged access simple user access he is able to invoke and interact with the Kel through system calls or or",
    "start": "373880",
    "end": "380919"
  },
  {
    "text": "through um some other API which is available and his goal is to escalate privilege now in in most cases in order",
    "start": "380919",
    "end": "388199"
  },
  {
    "text": "to do that uh um what he needs to do is to achieve what we call arbitrary code",
    "start": "388199",
    "end": "393840"
  },
  {
    "text": "execution be being able to run code with the Privileges of the kernel because this part of the code is the most",
    "start": "393840",
    "end": "399840"
  },
  {
    "text": "privileged one in the software stack um and um in order to do that he in more",
    "start": "399840",
    "end": "406800"
  },
  {
    "text": "cases in in all cases actually what what happens is that there is a bug a memory corruption vulnerability in kernel code",
    "start": "406800",
    "end": "413960"
  },
  {
    "text": "um the same more or less the same types of bugs that we have in userland we have them also in in kernel um we have use",
    "start": "413960",
    "end": "420080"
  },
  {
    "text": "after freeer sinus errors integer overflows wild rights off by one off by two you know all these things that we",
    "start": "420080",
    "end": "426400"
  },
  {
    "text": "find in user L software they exist in the kernel as well so these things can be abused in order to corrupt memory and",
    "start": "426400",
    "end": "433199"
  },
  {
    "text": "the end goal is to execute code now as is the case with um uh user processes",
    "start": "433199",
    "end": "439639"
  },
  {
    "text": "when we exploit them um we typically do that either by code injection okay this",
    "start": "439639",
    "end": "444680"
  },
  {
    "text": "is what we used to do in the past we inject some data in the process address space and then we corrupt",
    "start": "444680",
    "end": "450080"
  },
  {
    "text": "Control Data such as a function pointer or turn address pointing it into that code and we execute it now this thing",
    "start": "450080",
    "end": "456319"
  },
  {
    "text": "doesn't work anymore because of the defenses that get deployed uh in in uh",
    "start": "456319",
    "end": "461560"
  },
  {
    "text": "most platforms these days such as non-executable memory or aslr so what we do is the same thing but instead of",
    "start": "461560",
    "end": "468120"
  },
  {
    "text": "injecting code we inject Control Data and perform the exploitation in a rope manner okay now kernel exploits don't",
    "start": "468120",
    "end": "476840"
  },
  {
    "text": "work like that okay there have been kernel exploit where code injection and ROP has been used but in most cases and",
    "start": "476840",
    "end": "484360"
  },
  {
    "text": "I'm talking about the vast majority here um what we do is a different type of attack which I call return to user space",
    "start": "484360",
    "end": "492159"
  },
  {
    "text": "okay so let's see what these attacks are and how they work these attacks they work against operating system kernels",
    "start": "492159",
    "end": "497879"
  },
  {
    "text": "that have a shared kernel user address space layout okay and the way they work is by overwriting kernel code or data",
    "start": "497879",
    "end": "504159"
  },
  {
    "text": "pointers with user space addresses now the payload whether this is cell code R payload tampered with",
    "start": "504159",
    "end": "511039"
  },
  {
    "text": "data structures depending on the exploit depending on the vulnerability that we're exploiting it is placed in user",
    "start": "511039",
    "end": "517120"
  },
  {
    "text": "space but it is executed or referenced from the kernel context and as I said this has been the de facto kernel",
    "start": "517120",
    "end": "523880"
  },
  {
    "text": "exploitation technique um there are exploits in exploit DB from 2003 that",
    "start": "523880",
    "end": "529800"
  },
  {
    "text": "they use this technique and um the last one that I found some days ago was released in this year and still uses the",
    "start": "529800",
    "end": "537160"
  },
  {
    "text": "same technique um so as you can see here the way the whole thing works is by as I",
    "start": "537160",
    "end": "543600"
  },
  {
    "text": "said hosting the payload in user space so in other words we don't need to inject anything in inside the kernel",
    "start": "543600",
    "end": "549000"
  },
  {
    "text": "because it is already there it's already there in the address space that the kernel sees and if we can trick it into",
    "start": "549000",
    "end": "554920"
  },
  {
    "text": "reference it or execute it then we win okay so why do they work they work because the separation between kernel",
    "start": "554920",
    "end": "561399"
  },
  {
    "start": "557000",
    "end": "655000"
  },
  {
    "text": "and user space is weak okay when we designed our kernels we put kernel space along with user space inside the same",
    "start": "561399",
    "end": "567760"
  },
  {
    "text": "address space for performance okay every time every process doesn't do anything by itself it always calls the",
    "start": "567760",
    "end": "574000"
  },
  {
    "text": "operating system to do something useful okay write a file open a connection do some do something like that so you",
    "start": "574000",
    "end": "579360"
  },
  {
    "text": "always need to call the kernel and in order to do that fast you put we designed our our kernels so as that they",
    "start": "579360",
    "end": "586399"
  },
  {
    "text": "have this thing inside the same these two um pieces inside the same address space so as to be able to go from user",
    "start": "586399",
    "end": "593399"
  },
  {
    "text": "space to kol space only by doing a mode switch of course we could have designed it differently and some oses do that the",
    "start": "593399",
    "end": "599839"
  },
  {
    "text": "kernel can reside in a totally different address space but then every time you need to call the kernel you need to do a",
    "start": "599839",
    "end": "605040"
  },
  {
    "text": "complete Cod a complete CeX switch which is much much more expensive now in this model the kenel is",
    "start": "605040",
    "end": "611720"
  },
  {
    "text": "protected from userland okay you cannot write or read Canal memory the memory management unit will give you a fault",
    "start": "611720",
    "end": "618480"
  },
  {
    "text": "okay so we have hard Hardware support for that the problem is that the opposite with the opposite direction",
    "start": "618480",
    "end": "623680"
  },
  {
    "text": "okay when the kernel is running it has complete and unrestricted access to the whole address space and if you think",
    "start": "623680",
    "end": "629120"
  },
  {
    "text": "about about it he needs that access right if you do a read call and you provide a buffer the Kel reads that you",
    "start": "629120",
    "end": "635120"
  },
  {
    "text": "know fills that buffer with the contents of a file or or socket or whatever so it needs to have access to the user space",
    "start": "635120",
    "end": "641360"
  },
  {
    "text": "and that's why we designed the whole thing like this okay now the problem is that part of the user space that the",
    "start": "641360",
    "end": "648120"
  },
  {
    "text": "kernel sees it's completely controlled by the attacker okay both in terms of contents and",
    "start": "648120",
    "end": "654760"
  },
  {
    "text": "permissions now to deal with this issue we we there are various uh protections",
    "start": "654760",
    "end": "660360"
  },
  {
    "start": "655000",
    "end": "830000"
  },
  {
    "text": "and defenses um the first uh two were proposed by and implemented by PX it's K",
    "start": "660360",
    "end": "667399"
  },
  {
    "text": "and UD PX is a a set of third party Linux patches and um they they implement",
    "start": "667399",
    "end": "674519"
  },
  {
    "text": "this what they do is that they try to isolate the two right when the kernel is running they try to make to restrict",
    "start": "674519",
    "end": "681800"
  },
  {
    "text": "what are the user space areas that the kernel has access to okay so how do how",
    "start": "681800",
    "end": "687120"
  },
  {
    "text": "do they do that in x86 they use the segmentation unit so when the kernel gets called they reload um the segment",
    "start": "687120",
    "end": "693800"
  },
  {
    "text": "registers csss DS and Es so as to restrict the and confine the kernel in kernel space in the upper part so every",
    "start": "693800",
    "end": "702000"
  },
  {
    "text": "reference of data and code arbitrary reference in user space will result in a",
    "start": "702000",
    "end": "707519"
  },
  {
    "text": "fault from the segmentation unit in x86 64 since um Intel decided to uh more or",
    "start": "707519",
    "end": "716040"
  },
  {
    "text": "less make the segmentation unit the checks in in the in the segment registers um ineffective they",
    "start": "716040",
    "end": "722399"
  },
  {
    "text": "implemented the same thing differently um UDF works by remapping um user space",
    "start": "722399",
    "end": "728839"
  },
  {
    "text": "so every time the kernel gets called they tweak the page tables so as users so as to make sure that user space is not accessible directly um and for KAC",
    "start": "728839",
    "end": "737720"
  },
  {
    "text": "what they do is that they instrument the code um essentially they when they",
    "start": "737720",
    "end": "743560"
  },
  {
    "text": "compile the kernel they insert checks so is to make sure that you cannot branch and execute something from user space",
    "start": "743560",
    "end": "749720"
  },
  {
    "text": "kard is a system that I build uh that tries to um deal with the same problem",
    "start": "749720",
    "end": "755880"
  },
  {
    "text": "uh in more than one platform so it's a crossplatform solution it also leverages the compiler and again it uses",
    "start": "755880",
    "end": "762519"
  },
  {
    "text": "instrumentation and what we do there is that we instrument the code in and and",
    "start": "762519",
    "end": "767720"
  },
  {
    "text": "inject a bunch of checks to make sure that whenever a function pointer or a returned address uh or a return",
    "start": "767720",
    "end": "774240"
  },
  {
    "text": "instruction or or a jump instruction gets called it will never Branch to user space okay",
    "start": "774240",
    "end": "779959"
  },
  {
    "text": "um so finally Intel and arm implemented um two features um Intel has actually",
    "start": "779959",
    "end": "788120"
  },
  {
    "text": "two of them SM map and SM map um and RM pxn which do more or less the same thing",
    "start": "788120",
    "end": "794079"
  },
  {
    "text": "but use but but by but by leveraging Hardware okay so how they work is by um",
    "start": "794079",
    "end": "801639"
  },
  {
    "text": "in by by leveraging the information that it's already there in the page table so in",
    "start": "801639",
    "end": "808000"
  },
  {
    "text": "the page table we have information that tells us if a page belongs to the kernel or to user space okay so what these",
    "start": "808000",
    "end": "814079"
  },
  {
    "text": "things do is that they trigger a fault if you are running in kernel mode and you try to execute something from a page",
    "start": "814079",
    "end": "821880"
  },
  {
    "text": "that belongs to user space uh this is what smap and pxn does and smap does the same thing but for",
    "start": "821880",
    "end": "828519"
  },
  {
    "text": "data accesses okay so to summarize what I'm trying to say uh is the",
    "start": "828519",
    "end": "835560"
  },
  {
    "start": "830000",
    "end": "900000"
  },
  {
    "text": "following um K EXA kard smap and pxn effectively",
    "start": "835560",
    "end": "842240"
  },
  {
    "text": "block um the a code pointer from pointing into uh code in user space so",
    "start": "842240",
    "end": "851160"
  },
  {
    "text": "every time these techniques every time a function pointer gets called and that function pointer points to user space",
    "start": "851160",
    "end": "857519"
  },
  {
    "text": "you will get a fault immediately and as I said the smap and pxm uh do it using",
    "start": "857519",
    "end": "862839"
  },
  {
    "text": "Hardware the others using software or Hardware in case of Kent exec in 32 bits and so on so forth now f is the same",
    "start": "862839",
    "end": "870120"
  },
  {
    "text": "thing but for data pointers so if you have a data pointer and you corrupt it",
    "start": "870120",
    "end": "876160"
  },
  {
    "text": "by abusing a kernel based uh you know memory corruption bug you cannot Point",
    "start": "876160",
    "end": "881839"
  },
  {
    "text": "make it Point into user space you can overwrite it with a value with a user space value but when you trigger it either through the hardware or because",
    "start": "881839",
    "end": "888480"
  },
  {
    "text": "the p the user space is not it's not there anymore in case of UDF you will get a fault and these techniques will",
    "start": "888480",
    "end": "894759"
  },
  {
    "text": "confine essentially the control flow and the data flow in the upper part in kernal space",
    "start": "894759",
    "end": "900160"
  },
  {
    "start": "900000",
    "end": "964000"
  },
  {
    "text": "okay so in this talk we focus on these techniques um I call them R to user",
    "start": "900160",
    "end": "905959"
  },
  {
    "text": "defenses because they prevent the previous exploitation technique jumping back to user space and executing the the",
    "start": "905959",
    "end": "912800"
  },
  {
    "text": "the cell code or referencing payload from user space and what we want to answer is two two questions the first",
    "start": "912800",
    "end": "918920"
  },
  {
    "text": "one is whether we can subvert them okay whether we can force the kernel to execute or access user control data",
    "start": "918920",
    "end": "925240"
  },
  {
    "text": "because if you recall these things were put in place in order to make sure that the interel cannot go to user space and",
    "start": "925240",
    "end": "930639"
  },
  {
    "text": "access whatever data are there or execute code okay and second question is",
    "start": "930639",
    "end": "936160"
  },
  {
    "text": "whether there are conflicting design choices or optimizations that weaken the SE the strong separation that these",
    "start": "936160",
    "end": "941959"
  },
  {
    "text": "features try to achieve okay in the first place the return to user attacks exist because we chose to put kernel",
    "start": "941959",
    "end": "948600"
  },
  {
    "text": "kernel space and user space inside the same address space okay so it was a designed choice so here we want to see",
    "start": "948600",
    "end": "954720"
  },
  {
    "text": "is the kernel have following certain design patterns that still which in this operation even though we have these",
    "start": "954720",
    "end": "960800"
  },
  {
    "text": "defenses in place this is another question that we want to answer so red to Deer is the um is the new technique",
    "start": "960800",
    "end": "970000"
  },
  {
    "start": "964000",
    "end": "1017000"
  },
  {
    "text": "that I'm going to talk about it's called return to direct map memory it's an attack that can be applied against",
    "start": "970000",
    "end": "976000"
  },
  {
    "text": "hardened kernels everything that you're going to see here is against Linux we focused on Linux because all the",
    "start": "976000",
    "end": "982600"
  },
  {
    "text": "previous defenses were available there so it was a very good test bet for us and at the same time um um it's an",
    "start": "982600",
    "end": "989519"
  },
  {
    "text": "operating system that runs and drives millions of machines so the impact there it's much higher and depending on the",
    "start": "989519",
    "end": "996399"
  },
  {
    "text": "exploit on the vulnerability actually that uh gets exploited in most cases for every return to user exploit that gets",
    "start": "996399",
    "end": "1003720"
  },
  {
    "text": "blocked by one of these protections it will be possible to convert it into a",
    "start": "1003720",
    "end": "1009040"
  },
  {
    "text": "red to De equivalent that bypasses it so this is the technique that I'm going to",
    "start": "1009040",
    "end": "1014399"
  },
  {
    "text": "uh present in the next uh of this talk so before get into the details of",
    "start": "1014399",
    "end": "1019759"
  },
  {
    "start": "1017000",
    "end": "1146000"
  },
  {
    "text": "how exactly it works let me start with the kernel space layout okay so as is",
    "start": "1019759",
    "end": "1024959"
  },
  {
    "text": "the case with user space the kernal space is organized uh in some way and um",
    "start": "1024959",
    "end": "1031520"
  },
  {
    "text": "this the way that it gets organized it's different among different platforms but for for every instance of the same",
    "start": "1031520",
    "end": "1036839"
  },
  {
    "text": "platform it Remains the Same okay so here you have the layouts of um Linux in",
    "start": "1036839",
    "end": "1043038"
  },
  {
    "text": "x86 and x86 64 so we have regions that uh host the",
    "start": "1043039",
    "end": "1049320"
  },
  {
    "text": "kernal image the modules um you know vogs and stuff like that what's interesting for us is a",
    "start": "1049320",
    "end": "1055600"
  },
  {
    "text": "region which is called fish map F map is a region that is inside kernel space and",
    "start": "1055600",
    "end": "1061520"
  },
  {
    "text": "what it does is that it directly maps all physical memory in a one to one manner okay so this region if you go to",
    "start": "1061520",
    "end": "1069320"
  },
  {
    "text": "this particular virtual address that this region region starts and you reference it you're going to get essentially the Contex the contents of",
    "start": "1069320",
    "end": "1075919"
  },
  {
    "text": "the first page frame in Ram if you go a page above that then you get the contents of the second page frame and so",
    "start": "1075919",
    "end": "1082080"
  },
  {
    "text": "on so forth now in 64bit systems um this",
    "start": "1082080",
    "end": "1087559"
  },
  {
    "text": "region is big enough to more or less uh map the whole Ram okay so in uh x86 64",
    "start": "1087559",
    "end": "1096000"
  },
  {
    "text": "Linux for instance this region is 64 terabytes and since in most cases you're not going to find machines with 64",
    "start": "1096000",
    "end": "1102520"
  },
  {
    "text": "terabytes of ram the whole Ram is going to fit inside that region in 32-bit systems uh you have less space so in the",
    "start": "1102520",
    "end": "1110080"
  },
  {
    "text": "most typical scenario where you split the address space uh in such a way where you assign 1 GB in kernal and 3 gabt in",
    "start": "1110080",
    "end": "1117440"
  },
  {
    "text": "user space then because of other stuff that also rely on that 1 gab of the",
    "start": "1117440",
    "end": "1122520"
  },
  {
    "text": "kernel address space you end up with roughly 891 uh",
    "start": "1122520",
    "end": "1127840"
  },
  {
    "text": "megabytes that directly map physical memory so if your physical memory is 2 GB the first 800 will be directly mapped",
    "start": "1127840",
    "end": "1134799"
  },
  {
    "text": "there if you're and the rest or not if you're in the rare case where you have",
    "start": "1134799",
    "end": "1139840"
  },
  {
    "text": "like 512 megabytes the whole Ram again fits inside that region and it's there um so what is the uh role of that",
    "start": "1139840",
    "end": "1149159"
  },
  {
    "start": "1146000",
    "end": "1247000"
  },
  {
    "text": "thing why do we have it well it seems that uh this thing is very important for the kernel it's a fundamental building",
    "start": "1149159",
    "end": "1155559"
  },
  {
    "text": "block of dynamic kernal memory because it allows us to allocate memory without altering page staes more or less so this",
    "start": "1155559",
    "end": "1163400"
  },
  {
    "text": "means that we have minimal latency in fast path operations so if we do a k maloc inside an interrupt service",
    "start": "1163400",
    "end": "1170520"
  },
  {
    "text": "routine we can get we can get memory without without touching page tables without invalidating casses without",
    "start": "1170520",
    "end": "1176320"
  },
  {
    "text": "doing all these things uh it also inflicts less tlb pressure we we don't need to flash the tlb uh the other",
    "start": "1176320",
    "end": "1183159"
  },
  {
    "text": "benefit of that design is that virtually contiguous memory it's guaranteed to be physically contiguous as well so if we",
    "start": "1183159",
    "end": "1190159"
  },
  {
    "text": "do a k maloc and we take that memory and we assign it to a device to do dma we don't have to worry about whether you",
    "start": "1190159",
    "end": "1197120"
  },
  {
    "text": "know uh frames which are sequential in virtual memory are not sequential in dma so when the device gets dma these things",
    "start": "1197120",
    "end": "1203960"
  },
  {
    "text": "will have to go all over the place and then we do we need to do scatter gather to get them back in place and so on so",
    "start": "1203960",
    "end": "1209440"
  },
  {
    "text": "forth um and of course under such a scheme the page frame accounting is super easy okay if I give you a virtual",
    "start": "1209440",
    "end": "1216559"
  },
  {
    "text": "page if I give you a page frame number you can get the virtual address inside that region very easily you just",
    "start": "1216559",
    "end": "1222159"
  },
  {
    "text": "multiplied by the page size and you add the offset that this thing starts from and the opposite is that when you get a",
    "start": "1222159",
    "end": "1228080"
  },
  {
    "text": "virtual address you can get the page frame number just by subtracting the the offset of the region and then dividing",
    "start": "1228080",
    "end": "1234640"
  },
  {
    "text": "by the page size so it's very the kernel then can do very quickly go from a virtual address to the page frame or",
    "start": "1234640",
    "end": "1241240"
  },
  {
    "text": "from page frame to a virtual address and this is something that happens a lot inside the the kernel sorry",
    "start": "1241240",
    "end": "1247520"
  },
  {
    "start": "1247000",
    "end": "1376000"
  },
  {
    "text": "um so let's see um some properties of this region okay so as I said um the",
    "start": "1247520",
    "end": "1254080"
  },
  {
    "text": "starting offset of this region differs in various architectures and also differs depending on the configuration",
    "start": "1254080",
    "end": "1260039"
  },
  {
    "text": "uh between of the not the configuration actually the split between kernel user",
    "start": "1260039",
    "end": "1265200"
  },
  {
    "text": "space in various architectures uh which also affects the size of this region so",
    "start": "1265200",
    "end": "1270559"
  },
  {
    "text": "in x86 for instance in the most typical scenario where you have 3 GB in user space and 1 Gigabyte in kernal space it",
    "start": "1270559",
    "end": "1277159"
  },
  {
    "text": "starts from C 00000000 you know this address um the",
    "start": "1277159",
    "end": "1283159"
  },
  {
    "text": "size of this thing is 891 megabytes and if you go to different splits you have a different starting",
    "start": "1283159",
    "end": "1289840"
  },
  {
    "text": "address and more size and so on so forth um now what's important to note is that these things are not affected by kslr so",
    "start": "1289840",
    "end": "1297720"
  },
  {
    "text": "even though you you may have kernel space kernel address space layout randomization the starting offset of",
    "start": "1297720",
    "end": "1303880"
  },
  {
    "text": "this will remain the same okay what gets moved is the kernel text area and the kernel data and you know these these",
    "start": "1303880",
    "end": "1310480"
  },
  {
    "text": "things the region the FIS map region will remain there and it will always start from this uh fixed um you know",
    "start": "1310480",
    "end": "1317679"
  },
  {
    "text": "offset it's also uh interesting to see what are the protection uh bits in the page",
    "start": "1317679",
    "end": "1323960"
  },
  {
    "text": "tables the page table entries for this particular region in x86 this region is",
    "start": "1323960",
    "end": "1329320"
  },
  {
    "text": "mapped uh readable and writable um but in the other architectures unfortunately uh the",
    "start": "1329320",
    "end": "1335880"
  },
  {
    "text": "permission bits of that region are not in the same state okay um the last uh",
    "start": "1335880",
    "end": "1340919"
  },
  {
    "text": "caral version that I uh x86 64 kernel version that um had it executable was",
    "start": "1340919",
    "end": "1348000"
  },
  {
    "text": "everything below 3.9 so there you have it readable writable and executable",
    "start": "1348000",
    "end": "1353080"
  },
  {
    "text": "everything um after that it's only um read right um same thing for 32bit arm",
    "start": "1353080",
    "end": "1361120"
  },
  {
    "text": "for versions before uh 3. 14 and last",
    "start": "1361120",
    "end": "1366159"
  },
  {
    "text": "time I checked uh it was still execut read writable and executable in the 64bit",
    "start": "1366159",
    "end": "1372400"
  },
  {
    "text": "arm now remember that we're going to use it later um so what's our threat model",
    "start": "1372400",
    "end": "1377960"
  },
  {
    "start": "1376000",
    "end": "1450000"
  },
  {
    "text": "the threat model model that we um we assume here is that we have vulnerability that allows us to",
    "start": "1377960",
    "end": "1383880"
  },
  {
    "text": "overwrite Kernel code or data pointers with user controlled values and this is",
    "start": "1383880",
    "end": "1389120"
  },
  {
    "text": "not something um this is not a strong assumption we have a lot of bugs and lot of",
    "start": "1389120",
    "end": "1395799"
  },
  {
    "text": "vulnerabilities that we can leverage to do that and we also assume a hardened kernel okay we assume the kernel that",
    "start": "1395799",
    "end": "1401880"
  },
  {
    "text": "gets um strong user uh kernel separation",
    "start": "1401880",
    "end": "1406960"
  },
  {
    "text": "through one of the the protection or more than one uh that I talked about before so we cannot do the return to",
    "start": "1406960",
    "end": "1413039"
  },
  {
    "text": "user attack that we could do before okay so let's see how it works okay now",
    "start": "1413039",
    "end": "1421240"
  },
  {
    "text": "we have the physical ra recall that we have the physical RAM directly mapped inside that region okay now whenever we",
    "start": "1421240",
    "end": "1427640"
  },
  {
    "text": "get from user space whenever user space gets physical memory it gets it in lazy",
    "start": "1427640",
    "end": "1432799"
  },
  {
    "text": "manner okay through Page folds okay you allocate a big chunk of memory in user page in US user space say through M up",
    "start": "1432799",
    "end": "1440279"
  },
  {
    "text": "but this doesn't mean that you got it immediately you need to start writing in those regions so as to cause page faults",
    "start": "1440279",
    "end": "1445919"
  },
  {
    "text": "and then get physical memory from the OS okay now the problem with this approach is that because of the existence of fmap",
    "start": "1445919",
    "end": "1454120"
  },
  {
    "start": "1450000",
    "end": "1481000"
  },
  {
    "text": "we get we we end up with address aliasing okay we end up with more than",
    "start": "1454120",
    "end": "1459440"
  },
  {
    "text": "one addresses pointing into the same physical page frame okay so how how we",
    "start": "1459440",
    "end": "1465080"
  },
  {
    "text": "do that right so in the beginning everything is inside fist map so there a kernel address that Maps into that",
    "start": "1465080",
    "end": "1470760"
  },
  {
    "text": "particular page frame when the page frame gets allocated to user space another virtual address a userspace",
    "start": "1470760",
    "end": "1476799"
  },
  {
    "text": "virtual address now maps to the same page frame so we have two now and this",
    "start": "1476799",
    "end": "1482080"
  },
  {
    "start": "1481000",
    "end": "1541000"
  },
  {
    "text": "is the whole thing this is the basis of this attack so since we have two lses one and the problem is that these ls's",
    "start": "1482080",
    "end": "1488880"
  },
  {
    "text": "rely into two different um lie actually in two into two different protection domains one in kernel space and one in",
    "start": "1488880",
    "end": "1495360"
  },
  {
    "text": "user space what we can do is that we can use user space address to copy our",
    "start": "1495360",
    "end": "1501919"
  },
  {
    "text": "payload whatever that is cell code RW payload tampered with data structures wherever somewhere in physical memory",
    "start": "1501919",
    "end": "1508360"
  },
  {
    "text": "this means that it is directly accessible through its synonym in the FIS map region and then when we go ahead",
    "start": "1508360",
    "end": "1515320"
  },
  {
    "text": "and corrupt a code or a CO a kernel code pointer or a or a kernel data pointer",
    "start": "1515320",
    "end": "1520559"
  },
  {
    "text": "instead of corrupting it with the user space address we can corrupt those pointers and override them with the",
    "start": "1520559",
    "end": "1526120"
  },
  {
    "text": "synonyms of those addresses in FIS map and bypass all the previous protection mechanisms because all of them rely on",
    "start": "1526120",
    "end": "1533320"
  },
  {
    "text": "identifying user addresses more or less using different",
    "start": "1533320",
    "end": "1538440"
  },
  {
    "text": "techniques okay so let's see how we're going to do that um we have various problems to deal",
    "start": "1538440",
    "end": "1545840"
  },
  {
    "start": "1541000",
    "end": "1576000"
  },
  {
    "text": "with here okay the first one is to pinpoint of course the exact location of a synonym of user control data in the",
    "start": "1545840",
    "end": "1552960"
  },
  {
    "text": "fish map area Okay so suppose I copy something here in user space as I said this thing get into F map as well I need",
    "start": "1552960",
    "end": "1560279"
  },
  {
    "text": "to know the exact address inside F map because when I'm going to corrupt something like a data pointer in in K in",
    "start": "1560279",
    "end": "1566799"
  },
  {
    "text": "kol space I need to corrupt it and overwrite it with the exact address um",
    "start": "1566799",
    "end": "1572080"
  },
  {
    "text": "inside FIS map that is a synonym of of the user space so the first problem is",
    "start": "1572080",
    "end": "1577480"
  },
  {
    "start": "1576000",
    "end": "1657000"
  },
  {
    "text": "to know the exact location of user control data in the FIS map region the second problem that we have to deal with",
    "start": "1577480",
    "end": "1583679"
  },
  {
    "text": "is that in some cases um as I said before you don't have the complete Ram the complete physical",
    "start": "1583679",
    "end": "1590559"
  },
  {
    "text": "memory in mapped inside the fish map region um this is um actually typical in",
    "start": "1590559",
    "end": "1595760"
  },
  {
    "text": "32bit architectures because as we saw before it's only 891 megabytes directly",
    "start": "1595760",
    "end": "1601039"
  },
  {
    "text": "mapped so there the problem is that we need to force the synonym to emerge",
    "start": "1601039",
    "end": "1606200"
  },
  {
    "text": "inside the fish map area in other words we need to force the allocator to give us to to map a user uh to map user",
    "start": "1606200",
    "end": "1614120"
  },
  {
    "text": "content into a page frame that falls inside that region which has synonyms",
    "start": "1614120",
    "end": "1619320"
  },
  {
    "text": "um and the last problem is that sometimes we have payloads that don't don't fit into one uh one single page",
    "start": "1619320",
    "end": "1627200"
  },
  {
    "text": "okay they span more than one Pages Pages which are which are virtually contiguous",
    "start": "1627200",
    "end": "1632440"
  },
  {
    "text": "in user space doesn't mean that they're going to be physically contiguous as well and this means that they're not",
    "start": "1632440",
    "end": "1637640"
  },
  {
    "text": "going to be contiguous inside FIS map so the problem that we need to solve there is how can we",
    "start": "1637640",
    "end": "1643880"
  },
  {
    "text": "construct um you know regions which are con use inside FIS map and then put our",
    "start": "1643880",
    "end": "1650399"
  },
  {
    "text": "payload there so as to be contigous when the Kel references it so let's see which",
    "start": "1650399",
    "end": "1655480"
  },
  {
    "text": "one of them separately so I'll start with the first one the first one is the most important one right and essentially",
    "start": "1655480",
    "end": "1661159"
  },
  {
    "start": "1657000",
    "end": "1832000"
  },
  {
    "text": "is the how I can answer this question given a user space virtual address say you add how can I find the kernel space",
    "start": "1661159",
    "end": "1668159"
  },
  {
    "text": "address which which essentially Maps the same content now to do that we turn to the usual suspect the proofs file system",
    "start": "1668159",
    "end": "1675720"
  },
  {
    "text": "starting with the version 2625 5 um there's a new interface that was added",
    "start": "1675720",
    "end": "1681200"
  },
  {
    "text": "inside proc to allow page table examination from user space for debugging purposes so what you can do",
    "start": "1681200",
    "end": "1687559"
  },
  {
    "text": "with this thing is that you can go into proc P ID where P ID is the uh process ID of one particular process open the",
    "start": "1687559",
    "end": "1694919"
  },
  {
    "text": "file called page map and then this file is indexed by the virtual Page by virtual page number okay",
    "start": "1694919",
    "end": "1702519"
  },
  {
    "text": "so if I if I have a user address and get from that user address the virtual page",
    "start": "1702519",
    "end": "1708159"
  },
  {
    "text": "page number just by divide it by um the page size and seek into that file into",
    "start": "1708159",
    "end": "1715159"
  },
  {
    "text": "the appropriate uh location and read eight bytes what I'm going to have is",
    "start": "1715159",
    "end": "1720880"
  },
  {
    "text": "some Flags which tell me whether whether the page is present or not and stuff like that but the most important thing",
    "start": "1720880",
    "end": "1726200"
  },
  {
    "text": "is that I also have inside that that number um those eight bytes the page",
    "start": "1726200",
    "end": "1732120"
  },
  {
    "text": "frame number where this uh particular user space virtual address maps to okay",
    "start": "1732120",
    "end": "1738200"
  },
  {
    "text": "so in other words I can open this file and given a user space address I can get the page frame number of that virtual",
    "start": "1738200",
    "end": "1744720"
  },
  {
    "text": "address okay say it's page frame number 11 now given that I know that the fish",
    "start": "1744720",
    "end": "1751399"
  },
  {
    "text": "map maps physical memory in a onet to one manner if I have the page frame",
    "start": "1751399",
    "end": "1756919"
  },
  {
    "text": "number for a particular user address what I can do is that I can multiply that by the page size and add the fmap",
    "start": "1756919",
    "end": "1763240"
  },
  {
    "text": "offset which I know which I know that it's constant for different uh combinations of architectures and and",
    "start": "1763240",
    "end": "1770360"
  },
  {
    "text": "and um you know configurations and it's not affected bylr and then I can get K",
    "start": "1770360",
    "end": "1776480"
  },
  {
    "text": "other the thing that I want now in certain cases um the first page frame number happens to",
    "start": "1776480",
    "end": "1784159"
  },
  {
    "text": "be something different than zero so there I just have to do a small subtraction um I just subtract uh the",
    "start": "1784159",
    "end": "1792080"
  },
  {
    "text": "minimum page frame number from the one that I get and then I I multiply it by Page size and and I add the offset okay",
    "start": "1792080",
    "end": "1799360"
  },
  {
    "text": "so the way it works is the following I use U Adder to map something in physical memory then I do a lookup in page map I",
    "start": "1799360",
    "end": "1807200"
  },
  {
    "text": "get the page frame number I stick it into that formula and then I have K other and now what what I do is that I",
    "start": "1807200",
    "end": "1813080"
  },
  {
    "text": "go and corrupt Cod um kernel Cod or data pointers with K adder and now when the kernel is going",
    "start": "1813080",
    "end": "1819720"
  },
  {
    "text": "to trigger that thing it will never Branch to userspace but it will reference and execute or or reference",
    "start": "1819720",
    "end": "1825919"
  },
  {
    "text": "data uh that were controlled by me I put them there in in that physical memory",
    "start": "1825919",
    "end": "1832158"
  },
  {
    "start": "1832000",
    "end": "1868000"
  },
  {
    "text": "location okay um so this is how I I deal with the first problem let's see the second one um in 32-bit systems as I",
    "start": "1832240",
    "end": "1840039"
  },
  {
    "text": "said you have the problem that only part of the physical memory gets mapped inside fist map um as as I said many",
    "start": "1840039",
    "end": "1847320"
  },
  {
    "text": "times in the most typical setting you have only 800 megabytes okay so what happens in that case what what happens",
    "start": "1847320",
    "end": "1853880"
  },
  {
    "text": "is that you have there may be ca there actually there going to be many cases where particular where where certain",
    "start": "1853880",
    "end": "1860519"
  },
  {
    "text": "user space address don't have synonyms in FIS map why because they don't reside in the first 800 megabytes of the",
    "start": "1860519",
    "end": "1867799"
  },
  {
    "text": "ram okay so in order to deal with this um we have first to tell you how to tell",
    "start": "1867799",
    "end": "1873840"
  },
  {
    "start": "1868000",
    "end": "1933000"
  },
  {
    "text": "you how our solution works we need to talk a little bit about how Linux um",
    "start": "1873840",
    "end": "1879320"
  },
  {
    "text": "manages physical memory okay so physical memory is divided into certain regions",
    "start": "1879320",
    "end": "1884720"
  },
  {
    "text": "or zones and L we have a Zone called Zone dma this zone maps the first 16",
    "start": "1884720",
    "end": "1891960"
  },
  {
    "text": "megabytes of physical RAM so all the page frames of the first 16 megabytes fall into something which is called Zone",
    "start": "1891960",
    "end": "1898480"
  },
  {
    "text": "dma then we have Zone normal Zone normal contains all the page frames that start",
    "start": "1898480",
    "end": "1904080"
  },
  {
    "text": "after the first 16 megabytes and they go up either to the size of FIS map or the size of ram whichever is the minimum",
    "start": "1904080",
    "end": "1911159"
  },
  {
    "text": "here and then we have Zone himm okay Zone hm has all the other page frames so",
    "start": "1911159",
    "end": "1916840"
  },
  {
    "text": "if you have let's say system 32-bit system with 4 GB of RAM first 16 megab",
    "start": "1916840",
    "end": "1922039"
  },
  {
    "text": "of physical RAM go to Zone dma everything between 16 megabytes and 891",
    "start": "1922039",
    "end": "1927639"
  },
  {
    "text": "megabytes go into Zone normal and all the rest go to Zone High okay so also uh there is an",
    "start": "1927639",
    "end": "1936039"
  },
  {
    "start": "1933000",
    "end": "2244000"
  },
  {
    "text": "ordering there so whenever user space gets page frames it always gets the page",
    "start": "1936039",
    "end": "1941720"
  },
  {
    "text": "frames first from Zone him if all the page frames in zone him",
    "start": "1941720",
    "end": "1947159"
  },
  {
    "text": "are depleted then it tries Zone normal if all the page frames there are depleted then it tries Zone dma okay why",
    "start": "1947159",
    "end": "1954519"
  },
  {
    "text": "it does that because the first two zones they are they contain the the page frames that are you know those page",
    "start": "1954519",
    "end": "1962399"
  },
  {
    "text": "frames which are used for the kernel um to for the kernel itself when it needs a",
    "start": "1962399",
    "end": "1968559"
  },
  {
    "text": "dynamic memory right so the kernel tries to preserve that region for dynamic um",
    "start": "1968559",
    "end": "1973840"
  },
  {
    "text": "kernel memory requests from itself and first tries to give to serve user space",
    "start": "1973840",
    "end": "1979120"
  },
  {
    "text": "using him okay so the question here is whether we can force the allocator The Zone allocator which is a particular",
    "start": "1979120",
    "end": "1985720"
  },
  {
    "text": "piece inside the Kel that manages the page frames to provide uh something in user space from a page frame in user",
    "start": "1985720",
    "end": "1993320"
  },
  {
    "text": "space either from Zone normal or Zone dma if we do that then it means that",
    "start": "1993320",
    "end": "1998720"
  },
  {
    "text": "this page frame will have a synonym and we can use the previous technique to to get its uh syon address so how do we do",
    "start": "1998720",
    "end": "2005960"
  },
  {
    "text": "that um the way that the algorithm works is the following we allocate a big chug of",
    "start": "2005960",
    "end": "2012799"
  },
  {
    "text": "memory in user space okay we can take map shmat whatever and then for every",
    "start": "2012799",
    "end": "2019039"
  },
  {
    "text": "page there we trigger a right fold every time we trigger a right Fold It means that the page the the kernel will",
    "start": "2019039",
    "end": "2025200"
  },
  {
    "text": "allocate a physical page frame to this particular user space address that trigger the fault okay for every page",
    "start": "2025200",
    "end": "2032600"
  },
  {
    "text": "inside that region then we check the page frame number using um page map if",
    "start": "2032600",
    "end": "2039000"
  },
  {
    "text": "that page frame number is less than pfn Max where pfn Max is the maximum page frame number in the FIS map region um",
    "start": "2039000",
    "end": "2046720"
  },
  {
    "text": "what we found page frame which has a synonym okay in other words what I'm",
    "start": "2046720",
    "end": "2052280"
  },
  {
    "text": "saying here I'm I'm just using page map again to query and to to do a query and",
    "start": "2052280",
    "end": "2057760"
  },
  {
    "text": "get the page frame number and check if that page frame number Falls inside the first 891 megabytes if it does it means",
    "start": "2057760",
    "end": "2065320"
  },
  {
    "text": "that it's there is a syn for that thing inside the f map if not I keep doing the",
    "start": "2065320",
    "end": "2070679"
  },
  {
    "text": "same thing again and again and again why because as I'm doing that I'm allocating",
    "start": "2070679",
    "end": "2076040"
  },
  {
    "text": "more and more frames right depleting Zone him and then at some point where no",
    "start": "2076040",
    "end": "2081878"
  },
  {
    "text": "other frames are available in zone him I will trigger the kernel into give me giving me a page frame for the other two",
    "start": "2081879",
    "end": "2088240"
  },
  {
    "text": "from the other two zones which have synonyms okay now in 32-bit uh machines",
    "start": "2088240",
    "end": "2094599"
  },
  {
    "text": "you only have and depending on the configuration um that says how many uh",
    "start": "2094599",
    "end": "2099760"
  },
  {
    "text": "gigabytes of RAM you have for user space and how many you have in Kel space um you may need to do to spawn additional",
    "start": "2099760",
    "end": "2105960"
  },
  {
    "text": "processes to do that okay so in the most typical scenario you have as I said before 3 gbt of RAM available per",
    "start": "2105960",
    "end": "2112400"
  },
  {
    "text": "process for the user space part right so at most you can deplete 3 gabt of memory",
    "start": "2112400",
    "end": "2117800"
  },
  {
    "text": "if you have eight you may need to to spawn additional processes all of them are going to start doing this thing and",
    "start": "2117800",
    "end": "2123280"
  },
  {
    "text": "at some point one of them uh will get a page frame that falls inside the region that we want once we found that um",
    "start": "2123280",
    "end": "2130320"
  },
  {
    "text": "particular page frame we can kill every everything else we can do use mlock to",
    "start": "2130320",
    "end": "2135720"
  },
  {
    "text": "lock it in main memory and compute the kernel address using the previous formula okay now something to note here",
    "start": "2135720",
    "end": "2141920"
  },
  {
    "text": "is that memory pressure helps okay if you if other processes are running in the system and they are",
    "start": "2141920",
    "end": "2148560"
  },
  {
    "text": "um using memory and they use a lot of memory this is this helps us okay this",
    "start": "2148560",
    "end": "2154760"
  },
  {
    "text": "makes this word work easier because instead of having to spawn all these additional processes to waste that",
    "start": "2154760",
    "end": "2160720"
  },
  {
    "text": "memory somebody else has already done that for us now let's see the third problem the",
    "start": "2160720",
    "end": "2166480"
  },
  {
    "text": "third problem is to uh Force synonym pages to be contiguous inside Facebook",
    "start": "2166480",
    "end": "2172560"
  },
  {
    "text": "Okay um the way this the way we deal with this problem is similar to how we dealt with the previous one we allocate",
    "start": "2172560",
    "end": "2179440"
  },
  {
    "text": "a big chunk of memory in user space for every page we trigger a page fold and then what we do is that is that we try",
    "start": "2179440",
    "end": "2185640"
  },
  {
    "text": "to find two different pages whose page frame numbers differ by one okay so we do the query again using",
    "start": "2185640",
    "end": "2193800"
  },
  {
    "text": "page map and we try to see if I can find find pi and PJ Pages whose page frame",
    "start": "2193800",
    "end": "2199319"
  },
  {
    "text": "numbers are different by one if I find them then it means that the synonyms of those pages are contigous in FIS",
    "start": "2199319",
    "end": "2206640"
  },
  {
    "text": "map all right so to give you an example if I have the addresses fib and beff",
    "start": "2206640",
    "end": "2212640"
  },
  {
    "text": "okay and suppose that these um addresses um have page frame numbers that are",
    "start": "2212640",
    "end": "2218319"
  },
  {
    "text": "differ only by one although these V although the although these two different virtual pages are 64 megabytes",
    "start": "2218319",
    "end": "2225160"
  },
  {
    "text": "apart in user space their synonyms are contigous in F map so what I can do is that I can take my payload split it into",
    "start": "2225160",
    "end": "2232760"
  },
  {
    "text": "into two into these two pages and then reference it using their synonyms inside",
    "start": "2232760",
    "end": "2238160"
  },
  {
    "text": "FIS map their synonyms are going to be contiguous",
    "start": "2238160",
    "end": "2243800"
  },
  {
    "text": "um so next question what if page so all the the previous uh problems I solved",
    "start": "2243800",
    "end": "2249280"
  },
  {
    "start": "2244000",
    "end": "2269000"
  },
  {
    "text": "them by essentially leaking some information regarding page frame numbers from page map okay so what if page frame",
    "start": "2249280",
    "end": "2255839"
  },
  {
    "text": "information is not available so you can think that it's you know as as you already might assume it's very easy to",
    "start": "2255839",
    "end": "2262599"
  },
  {
    "text": "block access to this particular interface and not then the question is are all these attacks going to go away",
    "start": "2262599",
    "end": "2268880"
  },
  {
    "text": "well unfortunately the answer is no um the previous the previous techniques are",
    "start": "2268880",
    "end": "2274200"
  },
  {
    "start": "2269000",
    "end": "2349000"
  },
  {
    "text": "all deterministic okay so if you follow them for every user address you can find deterministically the kernel address",
    "start": "2274200",
    "end": "2280359"
  },
  {
    "text": "which is a synonym for a user space address and then do the attack that way if you don't have that information you",
    "start": "2280359",
    "end": "2286640"
  },
  {
    "text": "can still do the same thing but in a probabilistic way okay so we call this fish map spraying and it's very similar",
    "start": "2286640",
    "end": "2293560"
  },
  {
    "text": "to how hip spraying works so the idea here is to essentially take a pollute",
    "start": "2293560",
    "end": "2299839"
  },
  {
    "text": "fish map with aligned copies of the exploit payload so as to maximize the",
    "start": "2299839",
    "end": "2304960"
  },
  {
    "text": "footprint of user content inside fish map and then what we do is that we pick an arbitrary page aligned fish map",
    "start": "2304960",
    "end": "2311000"
  },
  {
    "text": "address and we use that uh in our exploit okay depending on how much um",
    "start": "2311000",
    "end": "2317359"
  },
  {
    "text": "how many pages we have managed to copy our payload inside fish map uh we increase our probability to reach one of",
    "start": "2317359",
    "end": "2323680"
  },
  {
    "text": "them uh that has the payload and not something else um so the way it works is by as I",
    "start": "2323680",
    "end": "2329920"
  },
  {
    "text": "said by copying the payload into n resident uh fmap resident pages okay and",
    "start": "2329920",
    "end": "2335240"
  },
  {
    "text": "the probability of succeeding is essentially n over the size of f map okay so what we try to do here is",
    "start": "2335240",
    "end": "2341319"
  },
  {
    "text": "essentially maximize this probability and to maximize it we either maximize n or minimize um the",
    "start": "2341319",
    "end": "2348520"
  },
  {
    "text": "denominator so to maximize n again it's more or less the same thing we allocate",
    "start": "2348520",
    "end": "2354760"
  },
  {
    "text": "memory in user space we trigger page folds and we copy the payload into the",
    "start": "2354760",
    "end": "2360319"
  },
  {
    "text": "memory that we acquired okay now here we cannot use mlock because mlock can only",
    "start": "2360319",
    "end": "2365680"
  },
  {
    "text": "can only lock in pinpoint in memory some kilobytes of ram here we want to you know more or less deplete the whole Ram",
    "start": "2365680",
    "end": "2372599"
  },
  {
    "text": "with aligned copies of our payload right so since we cannot do that what we do is that we can start a set of background",
    "start": "2372599",
    "end": "2378800"
  },
  {
    "text": "threads that repeatedly Mark Pages as dirty by writing let's say single bite",
    "start": "2378800",
    "end": "2384640"
  },
  {
    "text": "okay which will cause the kernel which will prevent the kernel from activating swapping it will think that these pages",
    "start": "2384640",
    "end": "2391119"
  },
  {
    "text": "are hot so it will say okay I'm not going to touch that and it will go to another process and find another victim",
    "start": "2391119",
    "end": "2397040"
  },
  {
    "text": "process to start doing the swapping from that one okay and as we do that we check",
    "start": "2397040",
    "end": "2402079"
  },
  {
    "text": "the resident set size which is essentially how many physical um how",
    "start": "2402079",
    "end": "2407319"
  },
  {
    "text": "many pages in in physical memory this process has and as we do that if that",
    "start": "2407319",
    "end": "2414079"
  },
  {
    "text": "value goes up it means that we acquire more and more physical memory so we maximize our Foo hole inside fish map at",
    "start": "2414079",
    "end": "2421920"
  },
  {
    "text": "the moment this thing will start going down it means that we reach the pick and from now on we cannot allocate anymore",
    "start": "2421920",
    "end": "2428640"
  },
  {
    "text": "because either we have depleted the whole Ram or swapping has started kicking in and swaps out our own stuff",
    "start": "2428640",
    "end": "2435520"
  },
  {
    "text": "so at this at this point we stop and we do the attack in a probabilistic way and we will succeed depending on how",
    "start": "2435520",
    "end": "2442319"
  },
  {
    "text": "depending on how many pages we've managed to copy our exploit payload inside the fisap region okay and as was",
    "start": "2442319",
    "end": "2448680"
  },
  {
    "text": "the case in the previous um scenario again here we may need to spawn additional processes to do that thing",
    "start": "2448680",
    "end": "2454640"
  },
  {
    "text": "okay if we are in 32-bit system and we can only um deplete like 3 GB of RAM of course we",
    "start": "2454640",
    "end": "2461319"
  },
  {
    "text": "we need to to use many processes to do that thing we cannot do it only with one um now the other clever thing that",
    "start": "2461319",
    "end": "2468720"
  },
  {
    "start": "2466000",
    "end": "2534000"
  },
  {
    "text": "we can do is that we can instead of considering all the pages inside FIS map as valid",
    "start": "2468720",
    "end": "2474240"
  },
  {
    "text": "targets what we can do is that we can have something which called which we call FIS map signatures essentially we",
    "start": "2474240",
    "end": "2480119"
  },
  {
    "text": "reduce the target Pages inside FIS map This Way um we know that certain regions",
    "start": "2480119",
    "end": "2486400"
  },
  {
    "text": "in physical memory have content that is never going to be allocate have content",
    "start": "2486400",
    "end": "2492119"
  },
  {
    "text": "and this means from for let's say for um used by from the BIOS or from the kernel",
    "start": "2492119",
    "end": "2498480"
  },
  {
    "text": "itself which means that the kernel will never you know Supply that page frame in user space okay so we we know all these",
    "start": "2498480",
    "end": "2506359"
  },
  {
    "text": "page frames so we can exclude them from our selection and essentially we can increase our probability into into",
    "start": "2506359",
    "end": "2511880"
  },
  {
    "text": "succeeding okay for instance we know where the kernel text is and or we know",
    "start": "2511880",
    "end": "2517119"
  },
  {
    "text": "that that the first page frame is used by bios so there is never you know it's it's it's never going to be the case",
    "start": "2517119",
    "end": "2523480"
  },
  {
    "text": "that the page frame zero is going to have content controlled by user space so we don't compute that when we do our um",
    "start": "2523480",
    "end": "2531640"
  },
  {
    "text": "you know random randomly select something so um to to give you an",
    "start": "2531640",
    "end": "2538599"
  },
  {
    "start": "2534000",
    "end": "2624000"
  },
  {
    "text": "overview of everything and how the whole attack works I'll try to do a walk",
    "start": "2538599",
    "end": "2543960"
  },
  {
    "text": "through using a uh real vulnerability here I'm using",
    "start": "2543960",
    "end": "2550119"
  },
  {
    "text": "um CV 2013 2094 it's a bug in the um",
    "start": "2550119",
    "end": "2556079"
  },
  {
    "text": "Linux perf events subsystem so as you can see here the vulnerable function is",
    "start": "2556079",
    "end": "2561680"
  },
  {
    "text": "perf s SW event in nit it's inside kernel event core and what it does is",
    "start": "2561680",
    "end": "2567520"
  },
  {
    "text": "that it takes a particular dat a pointer to a data structure and then it extracts",
    "start": "2567520",
    "end": "2574079"
  },
  {
    "text": "a particular field stores it into a local variable and so on so forth so the problem is that the local variable um",
    "start": "2574079",
    "end": "2582119"
  },
  {
    "text": "that the field gets stored to is an integer whereas the field is an unsigned 64-bit uh",
    "start": "2582119",
    "end": "2588800"
  },
  {
    "text": "field so this means that ah and the next um at some point later there is a check",
    "start": "2588800",
    "end": "2593880"
  },
  {
    "text": "to make sure that since this thing is going to be used as an index into an array there is a check to make sure that",
    "start": "2593880",
    "end": "2599960"
  },
  {
    "text": "we won't go over the bound of the array now the problem is that when config gets",
    "start": "2599960",
    "end": "2606800"
  },
  {
    "text": "conver converted into an integer right um we may end up with something that",
    "start": "2606800",
    "end": "2613040"
  },
  {
    "text": "it's a negative value and the check there only checks the upper bound not the lower bound right so that's the",
    "start": "2613040",
    "end": "2621040"
  },
  {
    "text": "that's a vulnerability so we'll we'll see how we can use this thing um this is the uh internal",
    "start": "2621040",
    "end": "2629280"
  },
  {
    "start": "2624000",
    "end": "2655000"
  },
  {
    "text": "structure of uh the perf event data structure it has three Fields um enabled",
    "start": "2629280",
    "end": "2637400"
  },
  {
    "text": "and two pointers the enabled one is essentially a counter um it's an atomic",
    "start": "2637400",
    "end": "2643559"
  },
  {
    "text": "um it's a value which gets increased atomically and the size of this data structure is 24 bytes in 64bit systems",
    "start": "2643559",
    "end": "2651160"
  },
  {
    "text": "and 12 bytes in 32 bit systems okay so and all um the all all that uh this",
    "start": "2651160",
    "end": "2658319"
  },
  {
    "start": "2655000",
    "end": "2674000"
  },
  {
    "text": "function does the slow key the static key slow ink does is that it takes the",
    "start": "2658319",
    "end": "2663480"
  },
  {
    "text": "first field enabled and increases that field by one okay so that's that's what this um this",
    "start": "2663480",
    "end": "2671280"
  },
  {
    "text": "part of the code does okay so let's see how we can we can abuse it um here I'm",
    "start": "2671280",
    "end": "2677800"
  },
  {
    "start": "2674000",
    "end": "2963000"
  },
  {
    "text": "going to talk by assuming that we have um we're running Ubuntu",
    "start": "2677800",
    "end": "2684160"
  },
  {
    "text": "12.04 um the LTS version and the kernel version is 3.8.0 um- 19- generic okay this thing",
    "start": "2684160",
    "end": "2692800"
  },
  {
    "text": "has been patched uh so it's not there anymore but you can always install thee previous version and you will see that",
    "start": "2692800",
    "end": "2698400"
  },
  {
    "text": "all these things are there and you can play with it um so what we have here is",
    "start": "2698400",
    "end": "2703800"
  },
  {
    "text": "that the address of the perf of our array the perf s SW event enabled array",
    "start": "2703800",
    "end": "2710119"
  },
  {
    "text": "is somewhere inside the kernel data and the kernel data are in the kernel image region okay after uh the kernel image of",
    "start": "2710119",
    "end": "2717960"
  },
  {
    "text": "course so our strategy here is that given the vulnerability we can go and",
    "start": "2717960",
    "end": "2724079"
  },
  {
    "text": "reference memory below the array right we can go we cannot go after the array because there is a check there uh that",
    "start": "2724079",
    "end": "2730839"
  },
  {
    "text": "checks the upper bound of the array but if we provide a negative value we can go to memory addresses before the array",
    "start": "2730839",
    "end": "2736319"
  },
  {
    "text": "into lower values okay so our strategy is to find a function pointer which",
    "start": "2736319",
    "end": "2742040"
  },
  {
    "text": "belongs into the kernel image and specifically to the data section because it needs to be writable so to overwrite",
    "start": "2742040",
    "end": "2747720"
  },
  {
    "text": "it with something and moreover the difference between the address of that",
    "start": "2747720",
    "end": "2753400"
  },
  {
    "text": "function pointer and the address of aray needs to be a multiple of 24 in that",
    "start": "2753400",
    "end": "2759720"
  },
  {
    "text": "particular case because it's a 64-bit system right and if you recall the size of the data structure",
    "start": "2759720",
    "end": "2766040"
  },
  {
    "text": "was 24 in 64 bits so we can only corrupt the first of the the first the first",
    "start": "2766040",
    "end": "2773040"
  },
  {
    "text": "eight we take the first eight bytes of the 24 bytes and we can only increase it by one so this is what this thing is",
    "start": "2773040",
    "end": "2779119"
  },
  {
    "text": "about um so if we do we do our um analysis in that kernel we can find out",
    "start": "2779119",
    "end": "2786559"
  },
  {
    "text": "that this particular function pointer um the function pointer shmore shmat is",
    "start": "2786559",
    "end": "2792119"
  },
  {
    "text": "located at this address which um which is um in a lower address from uh the",
    "start": "2792119",
    "end": "2799920"
  },
  {
    "text": "array and it's a multiple of 24 the difference of those two addresses is a multiple of 24 so this is the function",
    "start": "2799920",
    "end": "2806240"
  },
  {
    "text": "pointer that we're going to corrupt essentially okay so how we do that well",
    "start": "2806240",
    "end": "2811520"
  },
  {
    "text": "we provide this value negative value as index in the array okay and by doing",
    "start": "2811520",
    "end": "2817440"
  },
  {
    "text": "that we go from essentially from here down to this particular address here",
    "start": "2817440",
    "end": "2825040"
  },
  {
    "text": "which is the function pointer that we need to corrupt okay now this function pointer initially points into a function",
    "start": "2825040",
    "end": "2832720"
  },
  {
    "text": "called CAP shm shm at okay this is in inside the text uh region of the kle",
    "start": "2832720",
    "end": "2839559"
  },
  {
    "text": "okay this is it now every time we provide this",
    "start": "2839559",
    "end": "2844960"
  },
  {
    "text": "invalid index into the array and we call the static key slow ink we increase the",
    "start": "2844960",
    "end": "2851280"
  },
  {
    "text": "function pointer by one now the problem is that the cont if I do all all the",
    "start": "2851280",
    "end": "2858000"
  },
  {
    "text": "things that I said before the content that I manage to control is inside the FIS map region my cell code let's say",
    "start": "2858000",
    "end": "2864160"
  },
  {
    "text": "okay uh here it's a 64bit machine if you recall in this particular version F map is executable so I copy something in",
    "start": "2864160",
    "end": "2871119"
  },
  {
    "text": "user space it becomes executable code in kernel inside fish map okay but this thing is a lower addresses than where my",
    "start": "2871119",
    "end": "2879599"
  },
  {
    "text": "function pointer points at right every time I do the increment I go to higher",
    "start": "2879599",
    "end": "2886240"
  },
  {
    "text": "addresses I don't go back down here okay so this is a problem this is a problem right so how do we deal with it well by",
    "start": "2886240",
    "end": "2892599"
  },
  {
    "text": "doing a little bit of code reuse um if we see all the instructions",
    "start": "2892599",
    "end": "2899400"
  },
  {
    "text": "from starting from cap hmm Ma and upwards we can find an instruction",
    "start": "2899400",
    "end": "2904520"
  },
  {
    "text": "called call RSI okay and this instruction is that",
    "start": "2904520",
    "end": "2910720"
  },
  {
    "text": "many bytes like U uh 1,7 71",
    "start": "2910720",
    "end": "2917319"
  },
  {
    "text": "171,50 38 bytes ahead of the original function pointer um what's important for this why",
    "start": "2917319",
    "end": "2925400"
  },
  {
    "text": "the important thing of this gadget is that uh it calls into a location pointed",
    "start": "2925400",
    "end": "2930520"
  },
  {
    "text": "by the RSI register okay now when I call this system call here SA",
    "start": "2930520",
    "end": "2938440"
  },
  {
    "text": "what will happen is that the corrupted function pointer will get invoked okay",
    "start": "2938440",
    "end": "2944760"
  },
  {
    "text": "so up arm more shmat shmore shmat will get invoked and",
    "start": "2944760",
    "end": "2950680"
  },
  {
    "text": "then I also control the contents of the RSI register because RSI happens to have",
    "start": "2950680",
    "end": "2958160"
  },
  {
    "text": "the second argument of that call okay so how it works I map my pay load in",
    "start": "2958160",
    "end": "2967040"
  },
  {
    "start": "2963000",
    "end": "3038000"
  },
  {
    "text": "user space using the techniques that I said talked about in the beginning which will make them available in kernel space",
    "start": "2967040",
    "end": "2973280"
  },
  {
    "text": "as well okay so these two addresses essentially are synonyms right then what",
    "start": "2973280",
    "end": "2978799"
  },
  {
    "text": "I do is that I call the vulnerable system call with the negative index",
    "start": "2978799",
    "end": "2987000"
  },
  {
    "text": "here right that many times so to make sure that my function pointer will point",
    "start": "2987000",
    "end": "2994079"
  },
  {
    "text": "now from the original function to RSI and then I call shmat with the",
    "start": "2994079",
    "end": "3001119"
  },
  {
    "text": "synonym address of my payload in kernel space what will happen here is that not",
    "start": "3001119",
    "end": "3007520"
  },
  {
    "text": "game over yet so what will happen here is that shmat will Branch to callor SI",
    "start": "3007520",
    "end": "3013160"
  },
  {
    "text": "and caller SI will Branch to my cell code here and this is how I execute it",
    "start": "3013160",
    "end": "3018839"
  },
  {
    "text": "now keep in mind I never wrote something here that's the most important part I wrote it in the user space address which",
    "start": "3018839",
    "end": "3026400"
  },
  {
    "text": "was a synonym of that thing and then by using a little bit of code reuse I managed to Branch there and execute it",
    "start": "3026400",
    "end": "3033079"
  },
  {
    "text": "so this is how we this is how the attack works and this is how we do it now the next question and I'm going",
    "start": "3033079",
    "end": "3041119"
  },
  {
    "start": "3038000",
    "end": "3214000"
  },
  {
    "text": "to wrap up um is what happens if F map is not executable okay in 32-bit systems",
    "start": "3041119",
    "end": "3047160"
  },
  {
    "text": "F map is not executable and it's very easy in the latest kernels to fix that thing and have everything not executable",
    "start": "3047160",
    "end": "3053640"
  },
  {
    "text": "okay um here I'm using 32 bit um uh",
    "start": "3053640",
    "end": "3060040"
  },
  {
    "text": "Linux um we Bo to 12.04 LTS again different kernel um it's the same",
    "start": "3060040",
    "end": "3067839"
  },
  {
    "text": "vulnerability so the symbols that you see here are the same that I used before here we have the data structure that we",
    "start": "3067839",
    "end": "3074160"
  },
  {
    "text": "try to exploit has a has a size of 12 so again what we need to to find here is a",
    "start": "3074160",
    "end": "3079440"
  },
  {
    "text": "function pointer at the lower address from our array and the difference between that function pointer the",
    "start": "3079440",
    "end": "3085119"
  },
  {
    "text": "address of that function pointer and the original array should be a multiple of 12 here we find a different one default",
    "start": "3085119",
    "end": "3091160"
  },
  {
    "text": "security Ops shm shm at okay the layout as you can see is a little bit",
    "start": "3091160",
    "end": "3096400"
  },
  {
    "text": "different and what we do is that we do we're going to do the same attack using Pur op okay so what I'm trying to give",
    "start": "3096400",
    "end": "3104400"
  },
  {
    "text": "to show you here is that the same the r to is is a way to essentially make content available inside Kel space okay",
    "start": "3104400",
    "end": "3112160"
  },
  {
    "text": "depending on the vulnerability that you're exploiting and depending on the permission bits on the page tables of",
    "start": "3112160",
    "end": "3117839"
  },
  {
    "text": "fish map you can either inject something which is cell code or you can inject some something else which is a r payload",
    "start": "3117839",
    "end": "3124040"
  },
  {
    "text": "or tempered with data structures and whatever so the technique itself the only thing that allows you to do is to",
    "start": "3124040",
    "end": "3130520"
  },
  {
    "text": "make sure that user control content is inside kernel space how what Contex is going to be that and how you're going to",
    "start": "3130520",
    "end": "3136559"
  },
  {
    "text": "use it it depends on the exploit on the vulnerability that you're trying to exploit okay so here for instance it's",
    "start": "3136559",
    "end": "3142559"
  },
  {
    "text": "the same vulnerability but since it's not executable what we do is that we do the same thing the payload that we're",
    "start": "3142559",
    "end": "3149280"
  },
  {
    "text": "injecting it's not cell code it's a r payload okay um here again I'm using a",
    "start": "3149280",
    "end": "3156200"
  },
  {
    "text": "different uh negative index to corrupt it's more or less the same thing right we have the original function pointer",
    "start": "3156200",
    "end": "3162000"
  },
  {
    "text": "pointing here then I call I I use a different I just use a different uh",
    "start": "3162000",
    "end": "3167040"
  },
  {
    "text": "negative index I corrupt it many times and every time I corrupted it goes up one value until I reach a different",
    "start": "3167040",
    "end": "3173640"
  },
  {
    "text": "Gadget in this particular case the the gadget that I is this one okay and when",
    "start": "3173640",
    "end": "3179920"
  },
  {
    "text": "I call the system call then I'm going to control edx okay so as I said this time",
    "start": "3179920",
    "end": "3186799"
  },
  {
    "text": "I inject a r payload okay um the r payload let's say let's suppose that",
    "start": "3186799",
    "end": "3192680"
  },
  {
    "text": "it's up here this is not code it's only addresses of gadgets from inside the the",
    "start": "3192680",
    "end": "3199599"
  },
  {
    "text": "teex segment of the kernel so when I call it what's going to happen is that it's going to go to um this this",
    "start": "3199599",
    "end": "3206960"
  },
  {
    "text": "particular address here the first read the first Gadget and start the r",
    "start": "3206960",
    "end": "3213559"
  },
  {
    "text": "sequence so how it works is that again the same thing I use the technique to",
    "start": "3213559",
    "end": "3219599"
  },
  {
    "start": "3214000",
    "end": "3281000"
  },
  {
    "text": "map something in kernel space these are the synonyms in this particular scenario",
    "start": "3219599",
    "end": "3224680"
  },
  {
    "text": "okay this is the user space address this is the equivalent synonym inside kernel space I call the vulnerable system",
    "start": "3224680",
    "end": "3230359"
  },
  {
    "text": "called with the um with this argument that many times this means that at that",
    "start": "3230359",
    "end": "3235599"
  },
  {
    "text": "point I have corre update my function pointer to point into the gadget that I want and then by invoking the vulnerable",
    "start": "3235599",
    "end": "3243440"
  },
  {
    "text": "system call with the synonym address I will start my R chain and what the r",
    "start": "3243440",
    "end": "3248839"
  },
  {
    "text": "does is a little bit of Stu pivoting in the beginning um this will bring the stack up",
    "start": "3248839",
    "end": "3257040"
  },
  {
    "text": "here and then it will start executing those gadgets these are all addresses from the kernel text segment which will",
    "start": "3257040",
    "end": "3263319"
  },
  {
    "text": "essentially call commit creds with the address of init cred and at the Privileges of the running process to rout and then what we do is some clean",
    "start": "3263319",
    "end": "3271559"
  },
  {
    "text": "up to make sure that the whole thing is going to continue running and we won't cross the kernel okay and that's it so I also have",
    "start": "3271559",
    "end": "3282079"
  },
  {
    "start": "3281000",
    "end": "3377000"
  },
  {
    "text": "a demo before closing um I'm going to I'm going to show you how",
    "start": "3282079",
    "end": "3287119"
  },
  {
    "text": "the um uh first one first exploit works so it's",
    "start": "3287119",
    "end": "3293880"
  },
  {
    "text": "um as you can see it's a 64-bit system here um and it runs the vulnerable",
    "start": "3293920",
    "end": "3299520"
  },
  {
    "text": "kernel that I show to you before um the user that I'm using is good it's a",
    "start": "3299520",
    "end": "3305000"
  },
  {
    "text": "simple user doesn't have any PR you know special privileges um and this is the",
    "start": "3305000",
    "end": "3311880"
  },
  {
    "text": "exploit nothing Su ID or something you know weird here",
    "start": "3311880",
    "end": "3319558"
  },
  {
    "text": "so yeah let's start it so the way it works is that as I presented in the beginning it finds the addresses of",
    "start": "3320480",
    "end": "3326400"
  },
  {
    "text": "various symbols and then what it does is that it calls um the vulnerable system",
    "start": "3326400",
    "end": "3332640"
  },
  {
    "text": "call as many times as it wants that many times so as to be able to corrupt the uh",
    "start": "3332640",
    "end": "3338200"
  },
  {
    "text": "function pointer that I talked about the most important part is this one okay this is the user space address",
    "start": "3338200",
    "end": "3347079"
  },
  {
    "text": "which is also kernel mapped here so after corrupting everything I use this address to put the cell code and this",
    "start": "3347079",
    "end": "3353559"
  },
  {
    "text": "address to reference it this is happening in this part called cell code stitching then I'm just triggering it",
    "start": "3353559",
    "end": "3359839"
  },
  {
    "text": "and I elevated my privileges to route and that's",
    "start": "3359839",
    "end": "3366599"
  },
  {
    "text": "it um so we're running out of time so I'm going to be super super quick um we",
    "start": "3372119",
    "end": "3378079"
  },
  {
    "start": "3377000",
    "end": "3439000"
  },
  {
    "text": "did the same thing to other exploits as well what we did was that we go went to exploit AB took various exploits tested",
    "start": "3378079",
    "end": "3385359"
  },
  {
    "text": "those exploits into protected kernels um we checked that the all those exploits",
    "start": "3385359",
    "end": "3390480"
  },
  {
    "text": "got prevented and then we went and modified them using this technique and run them again and all cases we managed",
    "start": "3390480",
    "end": "3396799"
  },
  {
    "text": "to bypass the deployed protections a note here when I say bypassed it doesn't really mean that",
    "start": "3396799",
    "end": "3403839"
  },
  {
    "text": "these protections have something there's something bad with those protections okay these are good and we should have them there the problem is that the",
    "start": "3403839",
    "end": "3410520"
  },
  {
    "text": "kernel is having fist map regions okay it's a design issue the kernel has a region that Direct directly Maps memory",
    "start": "3410520",
    "end": "3417119"
  },
  {
    "text": "and create aliases and these aliases also um you know um REI rely to do",
    "start": "3417119",
    "end": "3423440"
  },
  {
    "text": "different protection domains user space and kernel space that's the most important uh problem here there's",
    "start": "3423440",
    "end": "3430520"
  },
  {
    "text": "nothing wrong with those protections it's just that the kernel has made a design choice that we can exploit it to",
    "start": "3430520",
    "end": "3436440"
  },
  {
    "text": "go around uh those protections um one final thing before closing if we do um you may wonder",
    "start": "3436440",
    "end": "3444599"
  },
  {
    "start": "3439000",
    "end": "3505000"
  },
  {
    "text": "what's the probability of succeeding when we don't do the you know deterministic attack but we do it",
    "start": "3444599",
    "end": "3450520"
  },
  {
    "text": "probabilistically what I have here is um in this graph we vary the physical",
    "start": "3450520",
    "end": "3456000"
  },
  {
    "text": "memory and on the x-axis on the y- axis you can find you can see the success probability for various um different",
    "start": "3456000",
    "end": "3463839"
  },
  {
    "text": "scenarios an idle system a system where we browse and a system where we do a kernel build as you can see even in the",
    "start": "3463839",
    "end": "3471960"
  },
  {
    "text": "when the the amount of memory is only 1 gab so there's a lot of contention between all processes we we run a kernel",
    "start": "3471960",
    "end": "3478480"
  },
  {
    "text": "build in the background when we do the attack we have 065 to 068 success",
    "start": "3478480",
    "end": "3484559"
  },
  {
    "text": "probability now as we move to higher uh to to systems with more physical memory",
    "start": "3484559",
    "end": "3490720"
  },
  {
    "text": "this can go up to 95 which means that in that case we have more or less managed to copy the payload",
    "start": "3490720",
    "end": "3497960"
  },
  {
    "text": "in every more or less every page frame so when we randomly select one we always",
    "start": "3497960",
    "end": "3504920"
  },
  {
    "text": "succeed um um if you go to this um before closing",
    "start": "3504920",
    "end": "3510480"
  },
  {
    "start": "3505000",
    "end": "3600000"
  },
  {
    "text": "if you go to this URL here we have prepared a bunch of VMS these VMS come ready with various kernels which are",
    "start": "3510480",
    "end": "3517319"
  },
  {
    "text": "vulnerable to um the exploits that I showed quickly before in my table and",
    "start": "3517319",
    "end": "3523039"
  },
  {
    "text": "the same VMS have protected kernels and they contain the source code of the original exploits and the modified ones",
    "start": "3523039",
    "end": "3530480"
  },
  {
    "text": "so you can go take them download them and you can try any combination you want you can get the original exploits see",
    "start": "3530480",
    "end": "3537319"
  },
  {
    "text": "that they are they don't work on a protected kernel then run our versions to see how we bypass them and so on so",
    "start": "3537319",
    "end": "3544000"
  },
  {
    "text": "forth and with that I can take",
    "start": "3544000",
    "end": "3549280"
  },
  {
    "text": "questions so",
    "start": "3550079",
    "end": "3557680"
  },
  {
    "text": "window so yeah you're right I mean I'm not 100% sure but I don't think that you",
    "start": "3560119",
    "end": "3566400"
  },
  {
    "text": "have exactly the same thing the thing is that you have other stuff that they result into more or less something",
    "start": "3566400",
    "end": "3572640"
  },
  {
    "text": "equivalent so all operating systems have the notion of a page C okay the page C",
    "start": "3572640",
    "end": "3577920"
  },
  {
    "text": "is a region that acts as a cast every time you do IO okay so you have a file when you execute it you do IO you bring",
    "start": "3577920",
    "end": "3584920"
  },
  {
    "text": "those pages somewhere in physical memory and then every time you need to access the same file again you don't need to do",
    "start": "3584920",
    "end": "3591200"
  },
  {
    "text": "the io again right the thing is that this thing essentially will result into a fisma PL region again because you have",
    "start": "3591200",
    "end": "3599079"
  },
  {
    "text": "content where you control and gets injected inside the K ladder space so instead of using FIS map as it is right",
    "start": "3599079",
    "end": "3606799"
  },
  {
    "text": "now you can use the page C in an operating system that doesn't have a FIS map",
    "start": "3606799",
    "end": "3612240"
  },
  {
    "text": "region yeah I don't know yeah we don't know",
    "start": "3618119",
    "end": "3626078"
  },
  {
    "text": "um you're say not",
    "start": "3626520",
    "end": "3634280"
  },
  {
    "text": "ex M so it depends on the situation right um red to Red to Deer can work",
    "start": "3638520",
    "end": "3646079"
  },
  {
    "text": "assuming that you have it's it's not it's not something that we bu will will allow you to exploit something that was",
    "start": "3646079",
    "end": "3652400"
  },
  {
    "text": "not exploitable in a red to user scenario okay so if you have a red to user scenario that has a way to go",
    "start": "3652400",
    "end": "3658559"
  },
  {
    "text": "around kslr if it has a memory disclosure vulnerability for example that it's abusing you will use the same",
    "start": "3658559",
    "end": "3664480"
  },
  {
    "text": "thing again to do this thing so you're saying based",
    "start": "3664480",
    "end": "3670359"
  },
  {
    "text": "onr no",
    "start": "3670359",
    "end": "3673558"
  },
  {
    "text": "way yeah",
    "start": "3680160",
    "end": "3684160"
  },
  {
    "text": "yeah actually I didn't say that there is no way but um yeah the thing is that the way it is designed it allows you to go",
    "start": "3686440",
    "end": "3693520"
  },
  {
    "text": "around a particular a particular set of mechanism that was deployed there to separate kernel and user space uh the",
    "start": "3693520",
    "end": "3699720"
  },
  {
    "text": "thing is that um we see that this thing is a is a design pattern it is also used in other",
    "start": "3699720",
    "end": "3706200"
  },
  {
    "text": "operating systems uh I haven't checked windows but Solaris has it uh the bsds",
    "start": "3706200",
    "end": "3711279"
  },
  {
    "text": "have it as well and I'm pretty sure that others um you know if we check others",
    "start": "3711279",
    "end": "3716400"
  },
  {
    "text": "we're going to find similar stuff there as well uh now if you check our white paper uh we have a defense for that um",
    "start": "3716400",
    "end": "3723720"
  },
  {
    "text": "it's not perfect but it's something that you can start you know if you're interested you can start with that and",
    "start": "3723720",
    "end": "3729160"
  },
  {
    "text": "then maybe somebody else can kick in and um you know join the effort and make it even",
    "start": "3729160",
    "end": "3735880"
  },
  {
    "text": "better any other question okay",
    "start": "3738119",
    "end": "3746359"
  }
]