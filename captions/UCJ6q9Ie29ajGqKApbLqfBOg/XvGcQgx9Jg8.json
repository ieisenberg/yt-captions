[
  {
    "start": "0",
    "end": "123000"
  },
  {
    "text": "[Music]",
    "start": "1130",
    "end": "14700"
  },
  {
    "text": "hello everyone my name is christopher wade and today we're going to be talking about breaking secure boot loaders the purpose of this talk is to outline",
    "start": "17279",
    "end": "23680"
  },
  {
    "text": "how signature protection mechanisms are used in smartphones to protect both the core firmware of the device and its peripheral hardware this is implemented",
    "start": "23680",
    "end": "30320"
  },
  {
    "text": "at the bootloader level which also provides facilities for firmware updates and other management tooling which can",
    "start": "30320",
    "end": "35600"
  },
  {
    "text": "allow you to interface with the device we're going to be outlining state two weaknesses in these update protocols in two different ships which can be used to",
    "start": "35600",
    "end": "41520"
  },
  {
    "text": "exploit uh be exploited to bypass these signature protection mechanisms a bit about me before we start my name",
    "start": "41520",
    "end": "47680"
  },
  {
    "text": "is christopher wade i'm a security consultant at penn test partners where i mainly work in hardware testing and iot testing",
    "start": "47680",
    "end": "54000"
  },
  {
    "text": "so the first project we'll be discussing is my attacks against the qualcomm sgm 660 android bootloader so i purchased an",
    "start": "54000",
    "end": "60239"
  },
  {
    "text": "android smartphone to do some mobile research with a similar chip to this and realized i needed root access in order to use all my testing tools",
    "start": "60239",
    "end": "66720"
  },
  {
    "text": "on this particular device it required unlocking the bootloader which disabled signature verification mechanism mechanisms on the device",
    "start": "66720",
    "end": "72880"
  },
  {
    "text": "but in this case it required an unlock tool from the manufacturer so some smartphone manufacturers often",
    "start": "72880",
    "end": "79840"
  },
  {
    "text": "uh modify the bootloader which is provided by qualcomm and node who add custom functionality which requires",
    "start": "79840",
    "end": "85040"
  },
  {
    "text": "custom tools from them in order to unlock their boot loader and other add other certain features um or sometimes to remove bootloader",
    "start": "85040",
    "end": "91759"
  },
  {
    "text": "unlocking entirely this often requires creating a user account on that manufacturer's website and waiting for a small period of time such as 7 days to",
    "start": "91759",
    "end": "98079"
  },
  {
    "text": "28 days a lot of them performed using custom usb commands which are usually done via fastboot on qualcomm devices and there",
    "start": "98079",
    "end": "104399"
  },
  {
    "text": "are a good few reasons why they would do this the first one is to prevent inexperienced users from being tricked into deliberately weaken their phone",
    "start": "104399",
    "end": "110399"
  },
  {
    "text": "security or to stop third parties from deploying malicious software to devices before sending them out to users",
    "start": "110399",
    "end": "116320"
  },
  {
    "text": "and lastly of course manufacturers can track who is unlocking their bootloaders in order to see what kind of research is being done",
    "start": "116320",
    "end": "123119"
  },
  {
    "start": "123000",
    "end": "123000"
  },
  {
    "text": "so on the particular device i was looking at i managed to um analyze a bootloader unlock so i waited the seven",
    "start": "123119",
    "end": "128160"
  },
  {
    "text": "days and decided to see what the functionality was of the custom tool that's provided by the manufacturer",
    "start": "128160",
    "end": "134239"
  },
  {
    "text": "using the usb keypad usb pcapp usb library i could analyze all of the data",
    "start": "134239",
    "end": "140080"
  },
  {
    "text": "going back and forth from the usb host of the usb device and found that during the unlock process it would send a 256",
    "start": "140080",
    "end": "145680"
  },
  {
    "text": "byte signature which was downloaded from the manufacturer's servers and sent to the phone using a small bit of data that was sent from the phone to the server",
    "start": "145680",
    "end": "153120"
  },
  {
    "text": "this is verified by the bootloader which then unlocked the locking restrictions and allowed you to root the device as needed i found this quite interesting so",
    "start": "153120",
    "end": "159760"
  },
  {
    "text": "i decided to use an older phone of mine which by the same manufacturer in order to analyze this functionality i also set myself a personal talent to try and",
    "start": "159760",
    "end": "166080"
  },
  {
    "text": "break this functionality on this new phone before the seven day waiting period",
    "start": "166080",
    "end": "171120"
  },
  {
    "text": "the device i was uh looking into was a mid-range phone released in 2017 which used the qualcomm snapdragon 660 chipset",
    "start": "171120",
    "end": "177280"
  },
  {
    "text": "which is an arm 64 architect chips that's quite common in smartphones i prefixed they unlocked the bootloader",
    "start": "177280",
    "end": "183120"
  },
  {
    "text": "on this particular phone for the same kinds of research but found that i could look at it again quite easily for this project using fastboot",
    "start": "183120",
    "end": "188720"
  },
  {
    "text": "and the bootloader itself has been modified to add further custom functionality on top of the bootloader unlocking restrictions",
    "start": "188720",
    "end": "194879"
  },
  {
    "text": "so fastboot is a command interface used for android boot loaders or most android boot loaders using a basic usb interface",
    "start": "194879",
    "end": "200800"
  },
  {
    "text": "commands and responses are sent in raw text in most circumstances apart from some very specific ones including",
    "start": "200800",
    "end": "206319"
  },
  {
    "text": "functionality like rebooting the device flashing certain partitions downloading data or getting device info from the",
    "start": "206319",
    "end": "211920"
  },
  {
    "text": "device and of course unlocking the bootloader this can be implemented using standard",
    "start": "211920",
    "end": "216959"
  },
  {
    "start": "215000",
    "end": "215000"
  },
  {
    "text": "usb library such as lib usb just by enumerating the usb device and then sending data over the bulk end point and",
    "start": "216959",
    "end": "222640"
  },
  {
    "text": "receiving data back asynchronously literally sending ascii data back and forth there are libraries that exist for",
    "start": "222640",
    "end": "227760"
  },
  {
    "text": "this purpose that are largely unnecessary for any standard functionality on the device",
    "start": "227760",
    "end": "233120"
  },
  {
    "text": "um the abl bootloader is the bootloader which provides um this boost usb interface it's actually a second stage",
    "start": "233120",
    "end": "238879"
  },
  {
    "text": "bootloader which is loaded into ram from the first bootloader which verifies the android operating system as well as",
    "start": "238879",
    "end": "244159"
  },
  {
    "text": "allows for all this management functionality and it can be accessed via adb or via button combinations on boot",
    "start": "244159",
    "end": "249760"
  },
  {
    "text": "on the phone it's stored in the abr partition on the device and is stored as a ua5 file system meaning it's a file system stored",
    "start": "249760",
    "end": "256639"
  },
  {
    "text": "within an l file in that partition this can be extracted with the tool uefi firmware password to find a portable",
    "start": "256639",
    "end": "262720"
  },
  {
    "text": "executable called linux loader and this can be loaded directly into wider the bass bootloader provided while qualcomm",
    "start": "262720",
    "end": "268960"
  },
  {
    "text": "has source code available but this is modified by vendors meaning i could use this source code as a reference for this project but it wouldn't give me all of",
    "start": "268960",
    "end": "274960"
  },
  {
    "text": "the functionality used by different users analysis of the bootloader being",
    "start": "274960",
    "end": "280000"
  },
  {
    "text": "performed quite easily all fastboot commands are stored in a table it's literally a ascii text and a function",
    "start": "280000",
    "end": "285199"
  },
  {
    "text": "callback which can be analyzed in turn along to see every function callback and every kind of ascii command that's can",
    "start": "285199",
    "end": "291120"
  },
  {
    "text": "be used on that particular bootloader this can aid in identifying non-standard commands or helps you in identifying",
    "start": "291120",
    "end": "297600"
  },
  {
    "text": "non-standard functionality within these commands there's a lot of locking strings in the firmware of the bootloader meaning that one can really",
    "start": "297600",
    "end": "304800"
  },
  {
    "text": "easily understand what's going on with each piece of code just by reading the strings that are coming out of it",
    "start": "304800",
    "end": "311360"
  },
  {
    "start": "310000",
    "end": "310000"
  },
  {
    "text": "um i decided to start looking at the flash command to start with because the flash command usually only flashes partitions on unlocked",
    "start": "311360",
    "end": "317440"
  },
  {
    "text": "bootloaders but what we really wanted to do was try and flash partitions while it was locked to start with this would",
    "start": "317440",
    "end": "323199"
  },
  {
    "text": "allow me to do things like modify the device info of the phone in order to set the unlock bit for instance",
    "start": "323199",
    "end": "328560"
  },
  {
    "text": "um the command had been modified by the manufacturer to allow for flashing of very specific custom partitions um which",
    "start": "328560",
    "end": "335199"
  },
  {
    "text": "instead of being flashed to the phone would be parsed by some extra processing which would do some string parsing in order to essentially pass out a list of",
    "start": "335199",
    "end": "342160"
  },
  {
    "text": "crcs that were used by the device as part of the firmware update process um there was potential for memory",
    "start": "342160",
    "end": "347840"
  },
  {
    "text": "corruption here because it was custom functionality and because it bypassed the locking restrictions that are usually on the flash command i thought",
    "start": "347840",
    "end": "353840"
  },
  {
    "text": "it'd be a good place to start um unfortunately during this process i made a mistake in my implementation",
    "start": "353840",
    "end": "359280"
  },
  {
    "text": "which is actually how i found the actual vulnerability we're going to exploit today i'd assumed that the way that this",
    "start": "359280",
    "end": "365039"
  },
  {
    "text": "process would work is i'd say i wanted to flash a partition and then send the payload of that partition to be flashed",
    "start": "365039",
    "end": "370800"
  },
  {
    "text": "however what you're supposed to do is send the download command or the payload size then save it send the payload of",
    "start": "370800",
    "end": "376240"
  },
  {
    "text": "the exact size of that payload size and then you say which partition you want to flash and that data is flashed from ram",
    "start": "376240",
    "end": "381840"
  },
  {
    "text": "into that partition i accidentally left an incorrect flash command after my first flash command as",
    "start": "381840",
    "end": "387199"
  },
  {
    "text": "well which meant that after sending that second flash command the bootloader would completely crash",
    "start": "387199",
    "end": "392880"
  },
  {
    "text": "the lack of a download command was my um assumed reason for this because that was the only thing different between what",
    "start": "392880",
    "end": "398000"
  },
  {
    "text": "you're meant to do and what you're not meant to do meaning that the device has probably not interpreted my commands correctly and has actually used my large",
    "start": "398000",
    "end": "404479"
  },
  {
    "text": "data payload as a command in of itself what i'd found is when i'd sent this",
    "start": "404479",
    "end": "409680"
  },
  {
    "text": "large payload um to start off with usb connectivity stopped functioning entirely and i had to do a hard reset on",
    "start": "409680",
    "end": "415120"
  },
  {
    "text": "the phone in order to get it back into a working state i'd hold down the volume down button on the power button for 10",
    "start": "415120",
    "end": "420160"
  },
  {
    "text": "seconds and then the phone would reboot and everything would start working again",
    "start": "420160",
    "end": "425360"
  },
  {
    "text": "i started with a smaller payload size to see if that would crash the phone and that didn't work so what i ended up doing was using a binary search approach",
    "start": "425360",
    "end": "431280"
  },
  {
    "text": "where i took a large size and a minimum size and went halfway between those and if the",
    "start": "431280",
    "end": "436960"
  },
  {
    "text": "phone crashed with the value halfway between those i could then have it again or double it again as needed",
    "start": "436960",
    "end": "442560"
  },
  {
    "text": "um by rebooting the phone and doing this so i could find the payload size that was uh of the maximum before it would",
    "start": "442560",
    "end": "447680"
  },
  {
    "text": "crash was 1 1 ba e 0. due to this unusual memory size i assume",
    "start": "447680",
    "end": "452880"
  },
  {
    "text": "this is going to be some kind of buffer overflow however with no debugging functionality functionality available on",
    "start": "452880",
    "end": "458479"
  },
  {
    "text": "the phone identifying how this memory corruption could be overwritten would be difficult especially due to the fact that the bootloader used stack canaries",
    "start": "458479",
    "end": "464479"
  },
  {
    "text": "on all functions meaning if i triggered the stat canary the phone would still crash and it could look like a valid um",
    "start": "464479",
    "end": "470080"
  },
  {
    "text": "exploit of some kind but wouldn't actually do anything so i decided to do was send the next byte in the sequence so 1 1 bae e1 bytes of data i'd modify",
    "start": "470080",
    "end": "477599"
  },
  {
    "text": "the last byte and increment that last byte value while rebooting the phone and if the phone didn't crash while sending",
    "start": "477599",
    "end": "483280"
  },
  {
    "text": "a certain value it was likely that i'd found the next byte in the uh sequence uh the next byte was identified to be",
    "start": "483280",
    "end": "488800"
  },
  {
    "text": "oxff meaning that it took me quite a long time to go through the entire 256 values that are available there",
    "start": "488800",
    "end": "495680"
  },
  {
    "text": "by constantly power cycling like this and incrementing the byte value finding a valid one and then moving to the next byte in the sequence i could probably",
    "start": "495680",
    "end": "501199"
  },
  {
    "text": "generate a reasonable facsimile of the memory that was in that place in the current memory going on it wouldn't be",
    "start": "501199",
    "end": "506879"
  },
  {
    "text": "the exact memory in use but it would be enough to not rush the bootloader and would possibly align would get some kind of code execution",
    "start": "506879",
    "end": "512399"
  },
  {
    "text": "once this was generated it could potentially be modified to gain code execution of course and then",
    "start": "512399",
    "end": "517839"
  },
  {
    "text": "i would be able to unlock the bootloader hopefully but what i really wanted was a way of automating this process to",
    "start": "517839",
    "end": "523518"
  },
  {
    "text": "receive more bikes than was required um it was suggested that removal of the",
    "start": "523519",
    "end": "529279"
  },
  {
    "text": "phone battery and usb relay bay could be used to automate this power cycling on the phone however this would require",
    "start": "529279",
    "end": "534320"
  },
  {
    "text": "moving removing uh glue from the case and uh removing the battery as well which was going to be quite intensive",
    "start": "534320",
    "end": "540080"
  },
  {
    "text": "and quite um damaging to the phone so what i did instead was wrap a hair tie around the volume down on power buttons",
    "start": "540080",
    "end": "545120"
  },
  {
    "text": "on the phone and what this did was cause the phone to go into a boot loop would restart into the bootloader constantly allow for usb",
    "start": "545120",
    "end": "551839"
  },
  {
    "text": "to be accessed for a very short amount of time about five seconds which was enough of time for me to try and test my buffer overflow",
    "start": "551839",
    "end": "558959"
  },
  {
    "text": "i modified my original fastboot tool that i was using to try and exploit this device to make it loop around and",
    "start": "558959",
    "end": "564000"
  },
  {
    "text": "constantly try this particular attack i'm going to verify two key things whether there was a string response",
    "start": "564000",
    "end": "569760"
  },
  {
    "text": "saying flashing fail to my invalid partition being written and whether the phone would crash afterwards each",
    "start": "569760",
    "end": "575200"
  },
  {
    "text": "iteration of this took 10 to 30 seconds however i left the phone overnight to perform",
    "start": "575200",
    "end": "580640"
  },
  {
    "text": "this loop and found that it generated 0x34 bytes of data which didn't crash the phone this was data that could be sent to the phone and then it wouldn't",
    "start": "580640",
    "end": "586640"
  },
  {
    "text": "crash straight away the repeated byte values um and lack of default stack canary which in this particular phone",
    "start": "586640",
    "end": "592480"
  },
  {
    "text": "before it'd be modified by the hardware randomizer with c-o-c-o-c-o-c-o meant that this was likely to not be the stack",
    "start": "592480",
    "end": "598160"
  },
  {
    "text": "it could be something even more interesting what i did note was all of the 32-bit words here were found to be",
    "start": "598160",
    "end": "603279"
  },
  {
    "text": "arm 64 op codes so most not codes while valid operations",
    "start": "603279",
    "end": "608880"
  },
  {
    "start": "606000",
    "end": "606000"
  },
  {
    "text": "wouldn't be the same as in the bootloader but they would be fairly similar things that handle the stack like pushing and popping and things that",
    "start": "608880",
    "end": "614320"
  },
  {
    "text": "branch to different function calls would have to be fairly accurate in order to work properly however things like just data general data management and things",
    "start": "614320",
    "end": "620800"
  },
  {
    "text": "that just move data around in a very basic way would not necessarily have to be accurate searching for the um stack management",
    "start": "620800",
    "end": "627680"
  },
  {
    "text": "from operations in the bootloader that i'd loaded into wider unfortunately didn't yield any useful results from this",
    "start": "627680",
    "end": "634880"
  },
  {
    "text": "arm64 operations can have a huge number of different uh quirks that mean they aren't exactly the same in two different",
    "start": "635680",
    "end": "641040"
  },
  {
    "text": "pieces of firmware so for one thing there's unused bits on some operations which um either don't change the",
    "start": "641040",
    "end": "646160"
  },
  {
    "text": "functionality or only change it superficially um registers in arm64 can be accessed as both 32-bit and 64-bit",
    "start": "646160",
    "end": "653040"
  },
  {
    "text": "values um which can sometimes cause issues but sometimes if the compiler is only compiling the 64-bit but treating",
    "start": "653040",
    "end": "659279"
  },
  {
    "text": "live 32-bit it will access it in the correct way um and also branch conditions can have",
    "start": "659279",
    "end": "664640"
  },
  {
    "text": "conditions for jumping which may have been met by my brute forcing of this dump these future features in general",
    "start": "664640",
    "end": "669920"
  },
  {
    "text": "would mean that i could change this code that i generated would work as needed but would not necessarily be 100",
    "start": "669920",
    "end": "675600"
  },
  {
    "text": "accurate um i decided to use the branch and link instruction which is the function",
    "start": "675600",
    "end": "680959"
  },
  {
    "text": "calling instruction and because it was one that was least likely to be common in the rest of the code the stack",
    "start": "680959",
    "end": "687279"
  },
  {
    "text": "pushing value value and operation would probably be similar throughout the firmware and probably be found in lots",
    "start": "687279",
    "end": "692800"
  },
  {
    "text": "of different places and to perform the text search remove the first nibble which um handles some",
    "start": "692800",
    "end": "698160"
  },
  {
    "text": "part of the relative addressing and i found that this would probably find um function jumps that was in a similar",
    "start": "698160",
    "end": "703600"
  },
  {
    "text": "relative address space to my dumped op code and this would mean for instance if there's a string comparison a secure",
    "start": "703600",
    "end": "708720"
  },
  {
    "text": "string comparison next to each other in the firmware and i'd actually accidentally jump to one on the other it would",
    "start": "708720",
    "end": "714000"
  },
  {
    "text": "behave appropriately this identified a single valid instruction in the crc list parser which",
    "start": "714000",
    "end": "719040"
  },
  {
    "text": "was the parser for the partition that i was flashing and the op codes were similar to what was in the memory dump",
    "start": "719040",
    "end": "724720"
  },
  {
    "text": "when i looked at them directly but not exactly the right so analysis of the offset showed that",
    "start": "724720",
    "end": "730800"
  },
  {
    "text": "the bootloader in its entirety is being overwritten over one zero one zero zero zero bytes of data",
    "start": "730800",
    "end": "736480"
  },
  {
    "text": "and because the bootloader is executed from ram demonstrated by this overflow um i could just completely overwrite it",
    "start": "736480",
    "end": "742160"
  },
  {
    "text": "with itself and the bootloader would continue to function normally wouldn't crash and nothing would go wrong",
    "start": "742160",
    "end": "747600"
  },
  {
    "text": "i got the original bootloader binary from the file system as i could before but i could have also got it from an ota update and i could fully overwrite it in",
    "start": "747600",
    "end": "754800"
  },
  {
    "text": "the uh using my tool to identify that this was accurate from here i could modify the bootloader to run any",
    "start": "754800",
    "end": "760320"
  },
  {
    "text": "unsigned code i wanted so knock out functions modify functionality in order to add what i wanted to",
    "start": "760320",
    "end": "766880"
  },
  {
    "start": "766000",
    "end": "766000"
  },
  {
    "text": "so to unlock the bootloader on this particular phone i needed to jump back past the rsa check which was used to",
    "start": "766880",
    "end": "772480"
  },
  {
    "text": "perform the bootleg odor unlocker was performed to verify whether unlocks were permitted",
    "start": "772480",
    "end": "777760"
  },
  {
    "text": "i could generate a simple branch instruction using uh the relative addresses between the functionality overflowed and the unlocked bootloader",
    "start": "777760",
    "end": "783519"
  },
  {
    "text": "functions so i could modify the exact function i was already using to change the functionality i use the shell storm online arm64",
    "start": "783519",
    "end": "790320"
  },
  {
    "text": "assembler for this as it's very quickly to allows you to very quickly uh generate um assembler code for this particular",
    "start": "790320",
    "end": "797279"
  },
  {
    "text": "purpose the process would be very difficult to debug but a successful um unlock would be very easy to identify by virtue of",
    "start": "797279",
    "end": "803760"
  },
  {
    "text": "the phone restarting itself erasing itself and being unlocked so here's a quick view of how this runs",
    "start": "803760",
    "end": "809920"
  },
  {
    "text": "so i run making rungs it's a c plus plus application and um",
    "start": "809920",
    "end": "814959"
  },
  {
    "text": "it would send my data try and flash crc list and when it sent flash the rc list it would actually jump to the bootloader",
    "start": "814959",
    "end": "820320"
  },
  {
    "text": "unlock command which would send an okay response and then because i'd messed up some of my stack handling in my",
    "start": "820320",
    "end": "825360"
  },
  {
    "text": "particular operation what would happen is it would then sign 512 bytes of corrupted data via usb i couldn't",
    "start": "825360",
    "end": "831199"
  },
  {
    "text": "ascertain the reason for this but this demonstrated that the buffer overflow had occurred the phone would crash and then it would start out",
    "start": "831199",
    "end": "837680"
  },
  {
    "text": "with an unlocked bootloader i was able to procure a second smartphone which also used the stm660 of",
    "start": "837680",
    "end": "844320"
  },
  {
    "text": "this purpose unfortunately the original phone i'd worked with um which was using stm665 before this whole project was not",
    "start": "844320",
    "end": "851279"
  },
  {
    "text": "vulnerable to this vulnerability in the same way so i couldn't really use it to continue this project this particular phone however had all",
    "start": "851279",
    "end": "857760"
  },
  {
    "text": "boot loader unlocking functionality disabled by the manufacturer meaning that if i wanted to unlock the bootloader it would be very helpful but",
    "start": "857760",
    "end": "863120"
  },
  {
    "text": "it would also bypass some protections on their end um it was identified to be using a similar signature verification approach",
    "start": "863120",
    "end": "869440"
  },
  {
    "text": "as the original phone i found this is a very common approach just because it's easy to implement and fairly secure",
    "start": "869440",
    "end": "876320"
  },
  {
    "text": "i took an ota image for the device um because unfortunately i couldn't dump the bootloader directly because if the bootloader the bootloader is locked",
    "start": "876320",
    "end": "883680"
  },
  {
    "text": "and it showed um the code which blocked the bootloader unlocked so you would run a bootloader unlock command uh or rather",
    "start": "883680",
    "end": "889839"
  },
  {
    "text": "an oem unlock command or a flashing unlock command and it would tell you it's not permitted because um the",
    "start": "889839",
    "end": "895839"
  },
  {
    "text": "signature didn't match um i also found there's no hidden bootloader commands here which would directly allow me to unlock the",
    "start": "895839",
    "end": "901199"
  },
  {
    "text": "bootloader initially i tried my old crash using the same amount of data size and the device",
    "start": "901199",
    "end": "906560"
  },
  {
    "text": "still functioned implying that the vulnerability may not still be present however i sent a much larger margin payload size of eight megabytes and this",
    "start": "906560",
    "end": "913519"
  },
  {
    "text": "crashed the phone implying that the memory layout was slightly different but the freeflow was still there",
    "start": "913519",
    "end": "918800"
  },
  {
    "text": "manual analysis demonstrated that the bootloader was overwritten after four zero three zero zero zero bytes instead",
    "start": "918800",
    "end": "924079"
  },
  {
    "text": "of the original one zero one zero zero on the first device and with this a bootloader unlock could be rapidly",
    "start": "924079",
    "end": "929600"
  },
  {
    "text": "developed a single branch instruction was identified which jumped past the bootloader unlock command if it couldn't",
    "start": "929600",
    "end": "935519"
  },
  {
    "start": "930000",
    "end": "930000"
  },
  {
    "text": "verify that signature and simply by writing a nop instruction over this using my buffer overflow i could unlock",
    "start": "935519",
    "end": "940959"
  },
  {
    "text": "the bootloader and allow the phone to be rooted i disclosed this vulnerability to qualcomm because it directly impacted",
    "start": "940959",
    "end": "946639"
  },
  {
    "text": "them because it was probably um available on all stm660 based phones",
    "start": "946639",
    "end": "953519"
  },
  {
    "text": "one thing i wanted to add to this was um bypassing the user data protection on qualcomm's phones now",
    "start": "953600",
    "end": "959040"
  },
  {
    "text": "qualcomm's chips encrypt the user data partition even if you don't use a pin or any kind of encryption because of um",
    "start": "959040",
    "end": "964800"
  },
  {
    "text": "internal security mechanisms on the chip itself this prevents forensic chip off analysis meaning that if someone removed",
    "start": "964800",
    "end": "970079"
  },
  {
    "text": "the emmc or the ufs from your phone they couldn't directly access your user data however and if an unlocked bootloader",
    "start": "970079",
    "end": "976079"
  },
  {
    "text": "tries to access this partition without erasing it on the bootloader unlock it's identified as being corrupted because the unlocked b loader can no longer",
    "start": "976079",
    "end": "982959"
  },
  {
    "text": "access the encryption keys for this however bypass of these protections could allow the user data to be accessed",
    "start": "982959",
    "end": "988240"
  },
  {
    "text": "for both um gaining access to sensitive user data but also some fun useful purposes that could be of value to",
    "start": "988240",
    "end": "994560"
  },
  {
    "text": "someone who wanted to root that phone in the first place so using qualcomm source code which was",
    "start": "994560",
    "end": "1000079"
  },
  {
    "text": "available the encryption process could be analyzed the encryption keys are intentionally inaccessible even with code execution because they're internal",
    "start": "1000079",
    "end": "1006560"
  },
  {
    "text": "to the chip and i found that the bootloader itself used an internal api to decrypt the partition which wasn't modifiable by my exploit this api",
    "start": "1006560",
    "end": "1013839"
  },
  {
    "text": "verifies whether it's unlocked and whether the firmware is signed before giving the appropriate encryption uh commands to",
    "start": "1013839",
    "end": "1019839"
  },
  {
    "text": "the user data partition the boot fabric command is a command in the bootloader which loads and executes",
    "start": "1019839",
    "end": "1026400"
  },
  {
    "text": "android uh android images deployed via usb from ram so you can send them and boot them temporarily this is for things",
    "start": "1026400",
    "end": "1032640"
  },
  {
    "text": "like deploying custom recovery partitions etc it was noted that the verification",
    "start": "1032640",
    "end": "1038079"
  },
  {
    "text": "execution of the image were two separate functions in this and in all other places in the um bootloader but here it was particularly prominent",
    "start": "1038079",
    "end": "1044240"
  },
  {
    "text": "and that there's a high likelihood that i could put some code in between these two function calls in order to",
    "start": "1044240",
    "end": "1050160"
  },
  {
    "text": "swap out a signed image with an unside image after verifying that the image was valid and decrypting the user data",
    "start": "1050160",
    "end": "1055919"
  },
  {
    "text": "partition uh the boot command receives the full android boot image which has a special",
    "start": "1055919",
    "end": "1061760"
  },
  {
    "text": "custom format via the fastboot download command which was outlined at the start of this talk which is loaded into ram",
    "start": "1061760",
    "end": "1066960"
  },
  {
    "text": "verified and executed so by patching the boot command the behavior could be altered for this time",
    "start": "1066960",
    "end": "1072559"
  },
  {
    "text": "time of check to time if you use that just outlined instead of sending one one image two could be sent and then swapped",
    "start": "1072559",
    "end": "1077840"
  },
  {
    "text": "after verification so what i did was create a tool which sent three pieces of data to achieve this a four byte offsite",
    "start": "1077840",
    "end": "1083440"
  },
  {
    "text": "to a unsigned image a signed image and then the unsigned malicious image containing my own code",
    "start": "1083440",
    "end": "1090080"
  },
  {
    "text": "uh the boot command itself doesn't function on locked boot loaders in the first place so the first thing i needed to do was modify that so what i did was",
    "start": "1090080",
    "end": "1097200"
  },
  {
    "text": "take the branch that says that there's uh commands are not allowed in lock states and made that change the pointer from to",
    "start": "1097200",
    "end": "1102960"
  },
  {
    "text": "be pointing at my offsets to be pointing at the signed image just by adding four to it this would allow the",
    "start": "1102960",
    "end": "1108720"
  },
  {
    "text": "thing to boot with my signed image and everything would start working again and also bypass this routing protection",
    "start": "1108720",
    "end": "1116080"
  },
  {
    "text": "um there were about four or five function calls between the verification and the booting at this point and they",
    "start": "1116160",
    "end": "1121440"
  },
  {
    "text": "used to be found to be largely unnecessary to boot android they're mainly just shopkeeping stuff to keep everything clean before booting into",
    "start": "1121440",
    "end": "1127039"
  },
  {
    "text": "android by removing these i could um overwrite them with five separate spare instructions to be patched in and this",
    "start": "1127039",
    "end": "1133039"
  },
  {
    "text": "would be sufficient for me to swap from my signed image to my unsigned image how this would occur was move my pointer",
    "start": "1133039",
    "end": "1139520"
  },
  {
    "text": "back to the start of my payload which was the offset read that offset value and then add that",
    "start": "1139520",
    "end": "1145120"
  },
  {
    "text": "offset value to my current pointer what this would do was go from the start of the point at the start of my original",
    "start": "1145120",
    "end": "1151280"
  },
  {
    "text": "pointer and jump it straight to my unsigned image and then what i need to do is point this new pointer into the data structure of the image buffer which",
    "start": "1151280",
    "end": "1158160"
  },
  {
    "text": "would then be executed from the boot linux function this would be sufficient to swap the signed image with the unsigned image and",
    "start": "1158160",
    "end": "1164400"
  },
  {
    "text": "patching this code and executing in this manner was effective meaning that i could bypass these user data protections",
    "start": "1164400",
    "end": "1171919"
  },
  {
    "text": "so there's a few cool things you can do with this such as tethered route so unlocking the bootloader on your phone",
    "start": "1171919",
    "end": "1177200"
  },
  {
    "text": "wipes all of the user data because you can't access obviously the encrypted partition anymore and to stop um",
    "start": "1177200",
    "end": "1182240"
  },
  {
    "text": "malicious users from accessing old data permanent routing as well exposes the device to a much greater risk which we",
    "start": "1182240",
    "end": "1188160"
  },
  {
    "text": "don't really want and really permanently rebooting the device isn't necessarily necessary for",
    "start": "1188160",
    "end": "1193919"
  },
  {
    "text": "most users in most cases so by deploying a rooted android image by this time we've checked to time a fuse attack",
    "start": "1193919",
    "end": "1199200"
  },
  {
    "text": "these problems could be resolved because rebooting would um stop executing that bootloader from ram and load the proper",
    "start": "1199200",
    "end": "1205440"
  },
  {
    "text": "signed bootloader again and a booler a android image of this type could be easily generated just using the amazing",
    "start": "1205440",
    "end": "1211440"
  },
  {
    "text": "magisk app um you could also use this to bypass a user's lock screen by loading into a",
    "start": "1211440",
    "end": "1218480"
  },
  {
    "text": "recovery partition like tw rp quickly or by um running an android image which uh didn't",
    "start": "1218480",
    "end": "1224880"
  },
  {
    "text": "have these protections or any other thing you could modify the entire functionality of the kernel and the low",
    "start": "1224880",
    "end": "1230640"
  },
  {
    "text": "level root file system using this attack um temporarily while the phone was booting",
    "start": "1230640",
    "end": "1236000"
  },
  {
    "text": "this allows you to bypass all of these lock screen protections the last thing you could do was bypass",
    "start": "1236000",
    "end": "1242640"
  },
  {
    "text": "the encryption on phones at a higher level so via developer functionality android phones can add further encryption requiring you to put in a pin",
    "start": "1242640",
    "end": "1248480"
  },
  {
    "text": "number or a password um on boots in order to access the user data partition so on top of the original",
    "start": "1248480",
    "end": "1254559"
  },
  {
    "text": "encryption it's already there as standard this ad this boot image can be modified still however",
    "start": "1254559",
    "end": "1260720"
  },
  {
    "text": "because it's not encrypted and you could then add your own back door for instance one could modify a boot image so that it",
    "start": "1260720",
    "end": "1266640"
  },
  {
    "text": "had a brother shell on it um deployed to the phone and then when the person unlocked their phone you would have",
    "start": "1266640",
    "end": "1272159"
  },
  {
    "text": "access to their user data via a shell just by uploading the image in the same way as before using this type of time",
    "start": "1272159",
    "end": "1278400"
  },
  {
    "text": "abuse attack but modifying one of the init shell scripts in the root file system to add an interpreter shell one",
    "start": "1278400",
    "end": "1284400"
  },
  {
    "text": "could just get a temperature this way obviously it's not entirely a viable attack but it is quite interesting",
    "start": "1284400",
    "end": "1291520"
  },
  {
    "text": "this time of checkered time of use attack was also disclosed to qualcomm but um we also discussed the fact that the attack was only possible with this",
    "start": "1291520",
    "end": "1297360"
  },
  {
    "text": "initial buffer overflow vulnerability so patching above realflow would mean this vulnerability would not be possible as",
    "start": "1297360",
    "end": "1302400"
  },
  {
    "text": "well um patching the phone to prevent this attack would also be difficult because it's uh using uh unmodifiable apis that",
    "start": "1302400",
    "end": "1309360"
  },
  {
    "text": "can't be changed by either part of the bootloader that i was modifying for this particular project",
    "start": "1309360",
    "end": "1314480"
  },
  {
    "text": "um these weaknesses however could allow an attack with physical access to get a huge amount of access to their phones which they didn't have before",
    "start": "1314480",
    "end": "1321919"
  },
  {
    "text": "so the second project i'm going to discuss today is the nxpn series which is a series of nfc chips used in both",
    "start": "1321919",
    "end": "1327840"
  },
  {
    "text": "smartphones and embedded electronics and by breaking the firmware protections on these chips one can add new nfc",
    "start": "1327840",
    "end": "1332880"
  },
  {
    "text": "capabilities to both their smartphone and their hobbyist product if they had um enough time and resources to do so",
    "start": "1332880",
    "end": "1340000"
  },
  {
    "text": "um the nxpc pen series is extremely popular it's used in millions of smartphones by bearing manufacturers and",
    "start": "1340000",
    "end": "1345760"
  },
  {
    "text": "any exploits that i would identify would probably be transferable across a large number of smartphones",
    "start": "1345760",
    "end": "1352159"
  },
  {
    "text": "so i focused on the nxpn553 which the nfc chip used solely in mobile devices",
    "start": "1352159",
    "end": "1358320"
  },
  {
    "text": "and was found to bear strong similarities between the piano five or seven p and five right p and five iphone and the piano five one eight zero they",
    "start": "1358320",
    "end": "1365039"
  },
  {
    "text": "all use similar firmware update files and protocols they all use the cortex architecture and they all had very",
    "start": "1365039",
    "end": "1370240"
  },
  {
    "text": "little republic research available there were other chips in the series like the pn544 which uh didn't have um arm",
    "start": "1370240",
    "end": "1377280"
  },
  {
    "text": "processors and used things like 8051 but i didn't focus on them for this partic particular project",
    "start": "1377280",
    "end": "1383440"
  },
  {
    "text": "so on smartphones these chips are confused communicated with by the itc in face at a dev nq nci um which uses um",
    "start": "1383440",
    "end": "1391600"
  },
  {
    "text": "standard i2c communication sent over this interface um by sending this standard nci protocol which is a",
    "start": "1391600",
    "end": "1397600"
  },
  {
    "text": "standard protocol used for nfc smartphone chips and other smartphone nfc chips or rather an embedded nfc",
    "start": "1397600",
    "end": "1404240"
  },
  {
    "text": "chips but then it also used a custom protocol for former firmware updates communication uh all these firmware",
    "start": "1404240",
    "end": "1410480"
  },
  {
    "text": "updates and communications could be performed using adb logcat just on a standard smartphone but i was using a rooted one for this process to access",
    "start": "1410480",
    "end": "1416559"
  },
  {
    "text": "the hardware um tracing the firmware updates can be very helpful in understanding the",
    "start": "1416559",
    "end": "1422240"
  },
  {
    "text": "protocol without having to read too much source code um and i found that the firmware updates would only occur if the two signed firmware versions on the",
    "start": "1422240",
    "end": "1429360"
  },
  {
    "text": "firmware updates differed and as there were two firmware updates in the file system of the phone i was using in the",
    "start": "1429360",
    "end": "1434640"
  },
  {
    "text": "pn553 firmware and rec so i could swap these in order to force a firmware update to occur and trace how it worked",
    "start": "1434640",
    "end": "1440880"
  },
  {
    "text": "i could also trace some of the functions and commands against the available source code",
    "start": "1440880",
    "end": "1446000"
  },
  {
    "start": "1445000",
    "end": "1445000"
  },
  {
    "text": "so the firmware update is quite unique to on xp chipset consists of a one byte status a one byte size a one byte",
    "start": "1446000",
    "end": "1451279"
  },
  {
    "text": "command um a variable length of parameters and a crc16 value and these can be encapsulated",
    "start": "1451279",
    "end": "1457840"
  },
  {
    "text": "oxfc byte chunks for large payloads meaning that the large payloads we'll be discussing later could be fit into those small sizes as just encapsulated data",
    "start": "1457840",
    "end": "1466480"
  },
  {
    "text": "reason writes the devnqci trans um were found to translate communication directly to i2c and io controls on the",
    "start": "1466480",
    "end": "1474799"
  },
  {
    "text": "chip would be used to swap between power modes from off on and boot loader mode",
    "start": "1474799",
    "end": "1481120"
  },
  {
    "text": "the firmware file format was found to be an l file but more of a library to be honest because the file only had one",
    "start": "1481120",
    "end": "1487360"
  },
  {
    "text": "sector which contained a lot of binary formatted data that wasn't executable and the data was actually the commands",
    "start": "1487360",
    "end": "1492960"
  },
  {
    "text": "that need to be run for a firmware update in sequence for firmware updates and these commands could be extracted to rebuild rebuild the firmware image as it",
    "start": "1492960",
    "end": "1499520"
  },
  {
    "text": "was unencrypted the co write command was found to be used throughout this process the first",
    "start": "1499520",
    "end": "1504640"
  },
  {
    "text": "command was uh found to contain unknown high entry data including a hash and a signature and all",
    "start": "1504640",
    "end": "1510640"
  },
  {
    "text": "subsequent commands were found to contain a 24-bit address a 16-bit size and the data payload followed by an",
    "start": "1510640",
    "end": "1516559"
  },
  {
    "text": "unknown hash these commands were found to be required to be performed in a very specific sequence which was the sequence",
    "start": "1516559",
    "end": "1522799"
  },
  {
    "text": "they were found in the file otherwise they wouldn't execute and the whole update process would fail",
    "start": "1522799",
    "end": "1528960"
  },
  {
    "text": "the memory dressers the twenty football bit ones at the start commands uh aided in reconstructing the firmware but i found that the firmware data was",
    "start": "1528960",
    "end": "1534640"
  },
  {
    "text": "extremely small not covering everything that would be required with an nfc chip there are also multiple code references",
    "start": "1534640",
    "end": "1540000"
  },
  {
    "text": "in there which were in an accessible memory regions that were likely to be in the bootloader as sort of like um core",
    "start": "1540000",
    "end": "1546080"
  },
  {
    "text": "libraries for the device to function uh two commands were found to read back memory from the chip a2 and e0 a2 was a",
    "start": "1546080",
    "end": "1553600"
  },
  {
    "text": "standard command which allowed you to read back arbitrary memory but only memory that was also allowed to be written to for firmware updates which is",
    "start": "1553600",
    "end": "1559279"
  },
  {
    "text": "limited to a very small address space and these area is found to calculate a checksum of memory and",
    "start": "1559279",
    "end": "1564480"
  },
  {
    "text": "provide a four byte um bit of configure pi piece of configuration data back which could be stitched together by",
    "start": "1564480",
    "end": "1570000"
  },
  {
    "text": "sending incrementing addresses to this command in order to generate the whole payload",
    "start": "1570000",
    "end": "1575679"
  },
  {
    "text": "this included a large block of random data in this memory dump over size oxc0",
    "start": "1575679",
    "end": "1581440"
  },
  {
    "text": "followed by the value one zero zero zero one which was um likely to be the rsa",
    "start": "1581440",
    "end": "1586559"
  },
  {
    "text": "exponent used by the rsa public key here so the large bit of uh high entropy data was likely to be the public key here",
    "start": "1586559",
    "end": "1593200"
  },
  {
    "text": "this size they did not identifying the signature algorithms that were probably used as part of the firmware update",
    "start": "1593200",
    "end": "1599440"
  },
  {
    "text": "um there was an unknown hash at the start end of every block that i couldn't work out um which i assumed to be sha-256 to start with but it didn't",
    "start": "1599440",
    "end": "1605840"
  },
  {
    "text": "match the contents of the packet that was being sent i tried multiple other hashing algorithms however these had no valid",
    "start": "1605840",
    "end": "1611840"
  },
  {
    "text": "results and it just wouldn't work if i um verified this against any of the data however i later identified that the hash",
    "start": "1611840",
    "end": "1617520"
  },
  {
    "text": "was for the next block in the sequence so um we'll be discussing how that works now",
    "start": "1617520",
    "end": "1622640"
  },
  {
    "text": "so the first co command consists of a version number a sha256 hash and then a signature of that hash and the version",
    "start": "1622640",
    "end": "1628799"
  },
  {
    "start": "1623000",
    "end": "1623000"
  },
  {
    "text": "number this is a hash of the next block which also contains a hash and this sort of cascades around the firmware update",
    "start": "1628799",
    "end": "1635440"
  },
  {
    "text": "so that all of the hashes has to match as it goes along for the next one in the sequence and",
    "start": "1635440",
    "end": "1640720"
  },
  {
    "text": "um meaning that you were forced to that only blocks a written device would be valid and they wouldn't write invalid",
    "start": "1640720",
    "end": "1647200"
  },
  {
    "text": "data blocks to the chip so as each sequence went along the sha-256 would be verified and it if it wasn't valid the",
    "start": "1647200",
    "end": "1653919"
  },
  {
    "text": "sequence would stop there however i did notice that the final black had no hash um because i had no subsequent block",
    "start": "1653919",
    "end": "1661039"
  },
  {
    "text": "i performed some targeted fuzzing during this process it was a much longer process than it sounds his trying to reverse engineer this chip",
    "start": "1661039",
    "end": "1666399"
  },
  {
    "text": "and i did this both on the firmware update protocol and the nci interfaces and i found that the chip itself in the",
    "start": "1666399",
    "end": "1671440"
  },
  {
    "text": "firmware side had a bunch of hidden vendor specific configurations which could be accessed via the nci config",
    "start": "1671440",
    "end": "1677279"
  },
  {
    "text": "right command by incrementing a bit wise value um to these configurations um",
    "start": "1677279",
    "end": "1682640"
  },
  {
    "text": "was uh performed in order to see how this would change how the chip functioned but what this ended up doing was bricking the core functionality of",
    "start": "1682640",
    "end": "1689200"
  },
  {
    "text": "the chip so the bootloader would still function but the core firmware would not and i couldn't overwrite the firmware",
    "start": "1689200",
    "end": "1695360"
  },
  {
    "text": "these particular configurations from the bootloader either however i decided to persevere with the",
    "start": "1695360",
    "end": "1701279"
  },
  {
    "text": "bootloader decide to see if i could break past this limitation it was noted that the last block of the firmware was um written multiple time able to be",
    "start": "1701279",
    "end": "1708320"
  },
  {
    "text": "written multiple times so i could send the last block which had no hash constantly and there'd be no problems with that meaning that it was likely",
    "start": "1708320",
    "end": "1713840"
  },
  {
    "text": "that the hash of the previous block which was used for verification of this block was remained in memory constantly",
    "start": "1713840",
    "end": "1719440"
  },
  {
    "text": "this meant that there's a potential opportunity for overwriting the hashing memory just by potentially sending corrupted commands that wasn't a right",
    "start": "1719440",
    "end": "1725919"
  },
  {
    "text": "sequence command um and this was attempted so i sent an invalid command of e0 the same size of",
    "start": "1725919",
    "end": "1731200"
  },
  {
    "text": "the firmware so a big empty block followed by a um corrupted sha-256 hash at the end and to see what would happen",
    "start": "1731200",
    "end": "1737760"
  },
  {
    "text": "at the end this prevented the last block from being written implying that over in the hash in memory",
    "start": "1737760",
    "end": "1743919"
  },
  {
    "start": "1744000",
    "end": "1744000"
  },
  {
    "text": "modified hashes could be written in the right portion of memory for this process in order to write",
    "start": "1744240",
    "end": "1750399"
  },
  {
    "text": "uh unverified and unsight dangerous this process as long as the shah 256 hash implemented in this militia this",
    "start": "1750399",
    "end": "1756799"
  },
  {
    "text": "modified packet was correct i could write into memory and then write the matching block to it no matter what",
    "start": "1756799",
    "end": "1763919"
  },
  {
    "text": "it was this essentially allowed me to write arbitrary memory blocks over the code that was already there and bypass all of",
    "start": "1763919",
    "end": "1768960"
  },
  {
    "text": "the signature verification mechanisms in firmware updates allowing me to overwrite the broken config as well",
    "start": "1768960",
    "end": "1775039"
  },
  {
    "start": "1775000",
    "end": "1775000"
  },
  {
    "text": "so using a dump of the working config which i got at the start of this whole reverse engineering process i could",
    "start": "1775039",
    "end": "1780399"
  },
  {
    "text": "generate a hash for the new config and overwrite it in the correct place this repaired the chip and it proved that arbitrary memory rights were",
    "start": "1780399",
    "end": "1786880"
  },
  {
    "text": "functioning as wanted but this was only the start and i wanted to dump the bootloader from the chip to get a full overview of how it worked",
    "start": "1786880",
    "end": "1794799"
  },
  {
    "text": "so all standard functions including mem copies and string compies and things like that were stored in the bootloader with limited functionality and natural",
    "start": "1794799",
    "end": "1800640"
  },
  {
    "text": "firmware update however the nci version number command which was part of the firmware update was found to be there",
    "start": "1800640",
    "end": "1806240"
  },
  {
    "text": "and jumped into from the core bootloader into this function as part of the main foot and we're running um this version",
    "start": "1806240",
    "end": "1813039"
  },
  {
    "text": "number was easy to identify memory just by buying research and save its function references that um accessed it",
    "start": "1813039",
    "end": "1818799"
  },
  {
    "text": "i found a function was called using this version number and the pointer um and i decided that this was likely to be a mem",
    "start": "1818799",
    "end": "1824799"
  },
  {
    "text": "copy function and if i wrote this i could identify how this worked",
    "start": "1824799",
    "end": "1830880"
  },
  {
    "text": "so the branch instructions this mem copy function can be overwritten to point to a custom function which i wanted to write in c so using c in the gcc-c flag",
    "start": "1830880",
    "end": "1838640"
  },
  {
    "text": "i could write a custom empty function which could be then modified as i went along the process in order to change how this functioned",
    "start": "1838640",
    "end": "1844559"
  },
  {
    "text": "its effect on the version number command could be observed after flashing and see what was going on and the lack of data",
    "start": "1844559",
    "end": "1849919"
  },
  {
    "text": "and response after sending this empty function implied that the mem copy was actually a mem copy for responses from",
    "start": "1849919",
    "end": "1855440"
  },
  {
    "text": "the nci version number command which i could then leverage further the location of ram was i um assumed to",
    "start": "1855440",
    "end": "1862159"
  },
  {
    "text": "be at one zero zero zero due to the firmware referencing this address space right reads and writes and the overhead",
    "start": "1862159",
    "end": "1867679"
  },
  {
    "text": "mem copy was changed to search for a new leak value in ram so when i sent the nci version number command i modified it to",
    "start": "1867679",
    "end": "1874480"
  },
  {
    "text": "contain the value f a c f a c this uh provided a global pointer in",
    "start": "1874480",
    "end": "1879760"
  },
  {
    "text": "memory at one zero zero zero seven so right to the start of this ram which i could then modify to um get that value",
    "start": "1879760",
    "end": "1887200"
  },
  {
    "text": "as an arbitrary point which i could then to use to dump arbitrary data from the chip allowing me to dump the bootloader",
    "start": "1887200",
    "end": "1893600"
  },
  {
    "text": "so with this and rebooting the chip while sending this nci command i could stitch the bootloader back together again and then disassemble it in either",
    "start": "1893600",
    "end": "1900320"
  },
  {
    "text": "demonstrating that this was a valid read this functionality could be extended further if i wanted to to modify the",
    "start": "1900320",
    "end": "1905679"
  },
  {
    "text": "core nfc functionality of the chip however at this point i would just want to disclose it because it's quite a high risk vulnerability for this chip",
    "start": "1905679",
    "end": "1913360"
  },
  {
    "text": "um i wanted to replicate it further as well including on the pn5180 which is a chip often used by hobbyists for nfc",
    "start": "1913360",
    "end": "1919200"
  },
  {
    "text": "connectivity it has a similar architecture to the pm503 in both the firmware updates",
    "start": "1919200",
    "end": "1925120"
  },
  {
    "text": "and the actual cpu architecture however it used a custom communication protocol for",
    "start": "1925120",
    "end": "1930799"
  },
  {
    "text": "communication over the spi interface provided and i connected it to a raspberry pi to mod uh modify its",
    "start": "1930799",
    "end": "1936399"
  },
  {
    "text": "functionality um the firmware update process was the same but it did have a buy to the start that was different which was used for",
    "start": "1936399",
    "end": "1942000"
  },
  {
    "text": "read and writes but that was largely superficial however this meant that i could um perform the entire signature",
    "start": "1942000",
    "end": "1947039"
  },
  {
    "text": "bypass again in the same way um i wanted to dump the bootloader from this chip as well so i",
    "start": "1947039",
    "end": "1953440"
  },
  {
    "text": "used a command in the chips communication protocol which read arbitrary memory from an eeprom pointer which was stored in the firmware and",
    "start": "1953440",
    "end": "1960159"
  },
  {
    "text": "modified this to point to different arbitrary memory in large blocks so by overwriting this and redeploying the",
    "start": "1960159",
    "end": "1965600"
  },
  {
    "text": "firmware after modifying this pointer i could then read that part of memory re-deploy the firmware and do this over and over again to stitch the",
    "start": "1965600",
    "end": "1971760"
  },
  {
    "text": "eeprom back together this would be a slow process but it would demonstrate that i could dump this bootloader and analyze it",
    "start": "1971760",
    "end": "1978320"
  },
  {
    "text": "um this vulnerability was likely to be also vulnerable and they are available on the pn547 pn548 and pn551",
    "start": "1978320",
    "end": "1985679"
  },
  {
    "text": "among others and this chip allows an attacker with access to firmware updates either by the",
    "start": "1985679",
    "end": "1990799"
  },
  {
    "text": "hobbyist project or via root access on their phone to completely take over the functionality of the chip",
    "start": "1990799",
    "end": "1996000"
  },
  {
    "text": "um this will provide some custom functionality but um not a huge amount of malicious stuff could be done with this apart from very specific spoofing",
    "start": "1996000",
    "end": "2003120"
  },
  {
    "text": "capabilities on the nfc chip um on smartphones this would require root access as stated um which would be quite",
    "start": "2003120",
    "end": "2010159"
  },
  {
    "text": "difficult to perform to perform any backdoor attacks on this particular chip and there'd be much better things you can do at that time however in hobbyist",
    "start": "2010159",
    "end": "2016799"
  },
  {
    "text": "projects this would expand the capabilities of the chip really far and give you a lot more control over how the",
    "start": "2016799",
    "end": "2022320"
  },
  {
    "text": "chip worked for you um the vulnerability was disclosed to nxp in june 2020 and they confirmed that",
    "start": "2022320",
    "end": "2028559"
  },
  {
    "text": "it affected multiple chips in their product line and they request a long remediation period up to august 2021",
    "start": "2028559",
    "end": "2034240"
  },
  {
    "text": "which i agreed to due to the fact that this would require alteration of the primary bootloader on a bunch of different chips which is a complex thing",
    "start": "2034240",
    "end": "2041200"
  },
  {
    "text": "when you're trying to replace the bootloader from the firmware on any kind of chip you're running the risk that",
    "start": "2041200",
    "end": "2046399"
  },
  {
    "text": "there'll be a power cut or something will go wrong and that chip will be irrevocably irrevocably broken so the phone will",
    "start": "2046399",
    "end": "2052878"
  },
  {
    "text": "never have nfc capabilities or again and because of this um they did it in phase rollouts which was",
    "start": "2052879",
    "end": "2059358"
  },
  {
    "text": "the right approach and as they went along the vulnerability was patched um the current generation of nxp",
    "start": "2059359",
    "end": "2066240"
  },
  {
    "text": "chips including the sn series are not affected due to the fact they have higher security and some of them implement encryption on top of the",
    "start": "2066240",
    "end": "2072480"
  },
  {
    "text": "signing which means that memory handling is just completely different and also i think the bootloader has been changed",
    "start": "2072480",
    "end": "2077919"
  },
  {
    "text": "sufficiently that this vulnerability is just no longer present on modern nxp nfc chips",
    "start": "2077919",
    "end": "2084000"
  },
  {
    "text": "special thanks to qualcomm and xp for remediating the findings and this being very verbose with me about how the",
    "start": "2084000",
    "end": "2089280"
  },
  {
    "text": "processes were going they were both extremely helpful in helping me understand what they were doing in order to read their uh the findings and they",
    "start": "2089280",
    "end": "2096720"
  },
  {
    "text": "were very communicative throughout the entire process um for my signature protections are only as good as their implementation so if",
    "start": "2096720",
    "end": "2103440"
  },
  {
    "text": "there's a small weakness such as the buffer overflow or even something smaller sometimes like a",
    "start": "2103440",
    "end": "2108720"
  },
  {
    "text": "cryptographic weakness these things can be bypassed in order to generate your own uh firmware payloads",
    "start": "2108720",
    "end": "2114800"
  },
  {
    "text": "common ships are still great targets for this as they have impact and some people assume that these are already um secure",
    "start": "2114800",
    "end": "2120400"
  },
  {
    "text": "because they've got so many eyes on them but this isn't always the case um bootloader vulnerabilities are common",
    "start": "2120400",
    "end": "2125440"
  },
  {
    "text": "even in popular hardware and that's the end thank you very much",
    "start": "2125440",
    "end": "2131800"
  }
]