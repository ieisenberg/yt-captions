[
  {
    "text": "[Music]",
    "start": "1130",
    "end": "14690"
  },
  {
    "text": "hello and thanks for joining this session um i'm brian and today i'll be talking about intel's houdini binary",
    "start": "15360",
    "end": "21279"
  },
  {
    "text": "translator before that quickly above myself um i studied electrical engineering at the",
    "start": "21279",
    "end": "26800"
  },
  {
    "text": "cooper union and currently working as a security consultant at with the ncc group",
    "start": "26800",
    "end": "32558"
  },
  {
    "text": "i like to build random bits of hardware and also like to reverse engineer",
    "start": "32559",
    "end": "37840"
  },
  {
    "text": "things other people built both hardware and software lately i've been doing a lot of android",
    "start": "37840",
    "end": "42960"
  },
  {
    "text": "testing and sometimes mandatory android malware analysis",
    "start": "42960",
    "end": "48399"
  },
  {
    "text": "so let's get right to android you guys probably know android is one of the largest operating systems for mobile",
    "start": "48399",
    "end": "54399"
  },
  {
    "text": "devices and you can write android apps in java and kotlin officially",
    "start": "54399",
    "end": "60079"
  },
  {
    "text": "and you could also write components of those apps in c and c plus plus using the native development kit",
    "start": "60079",
    "end": "68159"
  },
  {
    "text": "uh android was originally built around arm platforms armed devices and",
    "start": "68159",
    "end": "73920"
  },
  {
    "text": "later google has added support official support for x86 devices as well just to mention there there has been uh",
    "start": "73920",
    "end": "80960"
  },
  {
    "text": "out of out of tree support for android and x86 prior to that as well such as the android x86 project",
    "start": "80960",
    "end": "88240"
  },
  {
    "text": "so there are two main types of android devices that's on x86 now",
    "start": "88240",
    "end": "93520"
  },
  {
    "text": "those are x86 chromebooks and x86 hosts running commercial android emulators",
    "start": "93520",
    "end": "100759"
  },
  {
    "text": "however there is a general lack of support for x86 and apps and that's because again like i",
    "start": "100880",
    "end": "106320"
  },
  {
    "text": "mentioned andrew was originally built around arm so most of the devices are still armed",
    "start": "106320",
    "end": "111360"
  },
  {
    "text": "and if you are app developer and if you have native code they don't actually require the only only thing they require",
    "start": "111360",
    "end": "117040"
  },
  {
    "text": "is the arm builds and no other architectures are required so",
    "start": "117040",
    "end": "123200"
  },
  {
    "text": "yeah only a few developers end up shipping x86 binaries for the apks",
    "start": "123680",
    "end": "128879"
  },
  {
    "text": "but many of the apps actually contain native code so how do these x86 android devices",
    "start": "128879",
    "end": "135040"
  },
  {
    "text": "support running these arm native applications",
    "start": "135040",
    "end": "141200"
  },
  {
    "text": "the inter answer is the intel's proprietary houdini binary translator",
    "start": "141200",
    "end": "146959"
  },
  {
    "text": "it was co-designed by google to work with android and this is the key piece that enables",
    "start": "146959",
    "end": "153120"
  },
  {
    "text": "arm native applications to run on x86 devices it's a it's a little black box shattered",
    "start": "153120",
    "end": "159920"
  },
  {
    "text": "mystery there's barely any mention of it on their websites and there's no public documentation",
    "start": "159920",
    "end": "165920"
  },
  {
    "text": "and it seems like several vendors vendors may be obfuscating trying to use their",
    "start": "165920",
    "end": "171920"
  },
  {
    "text": "try to hide their usage of houdini and we notice there are three variants",
    "start": "171920",
    "end": "178239"
  },
  {
    "text": "that are around",
    "start": "178239",
    "end": "181680"
  },
  {
    "text": "so houdini is used in on x86 mobile phones phones which aren't really around",
    "start": "183280",
    "end": "189519"
  },
  {
    "text": "anymore and also x86 chromebooks and this is actually how we got it specifically the",
    "start": "189519",
    "end": "195280"
  },
  {
    "text": "32-bit x86 implementing the 32-bit arm",
    "start": "195280",
    "end": "201920"
  },
  {
    "text": "houdini is also found in commercial android emulators both bluestacks and knox",
    "start": "201920",
    "end": "207200"
  },
  {
    "text": "use or at least have the option to enable lipodini",
    "start": "207200",
    "end": "213280"
  },
  {
    "text": "and android x86 has it as well interestingly um from a",
    "start": "213280",
    "end": "220799"
  },
  {
    "text": "talk from defcon 26 a few years ago bluestacks you renamed the library from",
    "start": "220799",
    "end": "226799"
  },
  {
    "text": "le poudini to like something like lib3b trans.so for some unknown reason",
    "start": "226799",
    "end": "233200"
  },
  {
    "text": "i believe knox does something similar as well",
    "start": "233200",
    "end": "237040"
  },
  {
    "text": "so houdini is basically an interpreter for arm instructions",
    "start": "238560",
    "end": "243840"
  },
  {
    "text": "and it's essentially a while loop around a switch and it also keeps track of the",
    "start": "243840",
    "end": "249920"
  },
  {
    "text": "the emulator arm processor it reads um note that it does not do just-in-time",
    "start": "249920",
    "end": "256079"
  },
  {
    "text": "compilation um as there's no x86 constructions output to be run at a time",
    "start": "256079",
    "end": "261680"
  },
  {
    "text": "and houdini is mainly two components the first is houdini it's it's used to",
    "start": "261680",
    "end": "267440"
  },
  {
    "text": "run executable binaries and the second is lipodeny which is used to load shared",
    "start": "267440",
    "end": "273120"
  },
  {
    "text": "objects and other libraries so",
    "start": "273120",
    "end": "278960"
  },
  {
    "text": "yeah so houdini can run arm executable binaries both static and dynamic for dynamic",
    "start": "278960",
    "end": "284479"
  },
  {
    "text": "executables it actually has its own set of pre-compiled libraries for arm and",
    "start": "284479",
    "end": "290479"
  },
  {
    "text": "android that it uses from those pads",
    "start": "290479",
    "end": "296120"
  },
  {
    "text": "so you can see in the screenshot below the um the system i'm running on is x86",
    "start": "298639",
    "end": "304000"
  },
  {
    "text": "the file i'm trying to run is arm and it ran just fine now you might be wondering how where how",
    "start": "304000",
    "end": "310240"
  },
  {
    "text": "does houdini come in i've never invoked it and this is actually a feature of the linux kernel called bin format misc",
    "start": "310240",
    "end": "316639"
  },
  {
    "text": "and if you aren't familiar here's a quick intro whatever um",
    "start": "316639",
    "end": "324759"
  },
  {
    "text": "so bin format mist is a capability of the linux kernel or feature and it basically lets you",
    "start": "324960",
    "end": "331280"
  },
  {
    "text": "register customer interpreters for custom binary format it's very similar to how a shebang works for bash or",
    "start": "331280",
    "end": "337919"
  },
  {
    "text": "python scripts so you can see the uh",
    "start": "337919",
    "end": "343840"
  },
  {
    "text": "the see that houdini has registered interpreters for itself",
    "start": "343840",
    "end": "351199"
  },
  {
    "text": "and so what this basically does is if i type in hello and i call try to execute kernel",
    "start": "351199",
    "end": "357280"
  },
  {
    "text": "will see that and try to compare the magic bytes and if it matches it will convert it into system bin houdini",
    "start": "357280",
    "end": "363440"
  },
  {
    "text": "hello so the second component lipodynia so",
    "start": "363440",
    "end": "369280"
  },
  {
    "text": "is a shared object itself built for x86 but it can be used to load arm objects",
    "start": "369280",
    "end": "375120"
  },
  {
    "text": "shared objects and it was mainly designed to use android native bridge to run arm native code",
    "start": "375120",
    "end": "381199"
  },
  {
    "text": "so let's talk about android native bridge um it is the main interface that android uses to talk to librodini",
    "start": "381199",
    "end": "388000"
  },
  {
    "text": "and it's part of the android runtime and it's it's primary feature is to",
    "start": "388000",
    "end": "393120"
  },
  {
    "text": "support running native code in different architectures",
    "start": "393120",
    "end": "398560"
  },
  {
    "text": "so as it's part of android runtime it's initialized on boot and it reads that",
    "start": "400319",
    "end": "405600"
  },
  {
    "text": "system property to see what file has to load if it's set to zero it's disabled",
    "start": "405600",
    "end": "412240"
  },
  {
    "text": "um actually android x86 project uses their own version of uh called lib",
    "start": "412240",
    "end": "418400"
  },
  {
    "text": "own implementation called libmb.so but when you look at the source it's it's actually just a thin wrapper around le",
    "start": "418400",
    "end": "424639"
  },
  {
    "text": "perdini um also interestingly they if you go through the source trees um",
    "start": "424639",
    "end": "431759"
  },
  {
    "text": "throughout different tags they seem to have moved around the link and the code to download lippoudini and uses some dot",
    "start": "431759",
    "end": "438240"
  },
  {
    "text": "cn link shorteners and yeah",
    "start": "438240",
    "end": "443680"
  },
  {
    "text": "so this means that so native bridge is actually not specific to arm it just defines an interface for a translation layer",
    "start": "443680",
    "end": "451120"
  },
  {
    "text": "that also means if you implement a native bridge",
    "start": "451120",
    "end": "456800"
  },
  {
    "text": "you could write your own custom binary translation layer for different architectures such as mips on x86 and whatnot",
    "start": "456800",
    "end": "465599"
  },
  {
    "text": "and nativebridge defines interfaces with these callbacks that i'll be talking about but before that i want to talk to",
    "start": "465599",
    "end": "471440"
  },
  {
    "text": "you about uh java native interface so java native interface is basically interconnect that",
    "start": "471440",
    "end": "478639"
  },
  {
    "text": "connects the java side of our code with our native code um",
    "start": "478639",
    "end": "483680"
  },
  {
    "text": "and the struct shown on the right is the jni m struct which mostly consists",
    "start": "483680",
    "end": "490840"
  },
  {
    "text": "of it's a bag of function pointers and whenever the java side calls any",
    "start": "490840",
    "end": "496560"
  },
  {
    "text": "native code this the pointer to the struct is passed as the first argument",
    "start": "496560",
    "end": "502000"
  },
  {
    "text": "so that when our native code written in c wants to call interact with the java world it could use these functions such",
    "start": "502000",
    "end": "508639"
  },
  {
    "text": "as like find class alloc or call object methods and it would it's equivalent to a low",
    "start": "508639",
    "end": "514080"
  },
  {
    "text": "level reflection api for java in c",
    "start": "514080",
    "end": "520518"
  },
  {
    "text": "so going back to the callbacks the first them which is the native bridge runtime callbacks",
    "start": "522159",
    "end": "527920"
  },
  {
    "text": "as far as this talk is concerned this is not that important and it's these callbacks are provided from the native bridge to the houdini so liberty",
    "start": "527920",
    "end": "535680"
  },
  {
    "text": "could interact with native bridge native functions the more interesting callbacks are the",
    "start": "535680",
    "end": "542320"
  },
  {
    "text": "native bridge callbacks and this is how",
    "start": "542320",
    "end": "547519"
  },
  {
    "text": "our native bridge from the android side enter can call code into our houdini",
    "start": "547519",
    "end": "555360"
  },
  {
    "text": "so i cut out some of the functions on on the right",
    "start": "555360",
    "end": "561440"
  },
  {
    "text": "but some of the interesting ones are initialize probably guess what that does uh load library which acts similarly to",
    "start": "561440",
    "end": "567760"
  },
  {
    "text": "a dl open and get trampoline which acts similar to dlcent but we'll talk about why that's",
    "start": "567760",
    "end": "573360"
  },
  {
    "text": "interesting later and this struct is actually an exported symbol on liboudini.so via",
    "start": "573360",
    "end": "581040"
  },
  {
    "text": "the name nativebridge itf and you can see that here so",
    "start": "581040",
    "end": "586720"
  },
  {
    "text": "and that's the uh the picture is actually the [Music]",
    "start": "586720",
    "end": "591760"
  },
  {
    "text": "data the structure in the binary and you can see all the function pointers right there except for",
    "start": "591760",
    "end": "597279"
  },
  {
    "text": "the last one i guess that's unsupported",
    "start": "597279",
    "end": "601440"
  },
  {
    "text": "so to kind of put this all together this is how it works on on a normal arm on",
    "start": "602399",
    "end": "607760"
  },
  {
    "text": "arm app system so your",
    "start": "607760",
    "end": "613920"
  },
  {
    "text": "android code runs and android app runs and it wants to load a library",
    "start": "613920",
    "end": "619120"
  },
  {
    "text": "and then so the android runtime will call dl open on your native code libnative.so",
    "start": "619120",
    "end": "625200"
  },
  {
    "text": "and when you want to call a function the android runtime does a dlcim which returns a function pointer to our native function",
    "start": "625200",
    "end": "631200"
  },
  {
    "text": "and then you could jump to it and our native code could also interact",
    "start": "631200",
    "end": "636640"
  },
  {
    "text": "with the java world using the jnim function pointers that i mentioned before",
    "start": "636640",
    "end": "642240"
  },
  {
    "text": "so this is pretty simple under normal circumstances now when you have a cross architecture",
    "start": "642240",
    "end": "648240"
  },
  {
    "text": "app or not a cross architecture app but a arm native code running on x86 android",
    "start": "648240",
    "end": "656240"
  },
  {
    "text": "with native brits and lipodini loaded it looks something like this so",
    "start": "656240",
    "end": "661440"
  },
  {
    "text": "before anything happens before your app is loaded on boot native bridge is initialized and it reads that system",
    "start": "661440",
    "end": "667279"
  },
  {
    "text": "property from a few slides back and then dl opens the houdini.so",
    "start": "667279",
    "end": "672320"
  },
  {
    "text": "and liberating that iso is actually so you could just use dl open and dlc it gets the callbacks via the native bridge itf",
    "start": "672320",
    "end": "680320"
  },
  {
    "text": "symbol and then it calls initialize which isn't shown in the diagram",
    "start": "680320",
    "end": "685440"
  },
  {
    "text": "so this before the app happens when you launch the app and the app requests a",
    "start": "685440",
    "end": "691120"
  },
  {
    "text": "native library with something like system.load library um the native bridge does not do a dl",
    "start": "691120",
    "end": "697040"
  },
  {
    "text": "open because it's native bridge is enabled so instead does a load library library on the libradini binary through",
    "start": "697040",
    "end": "703839"
  },
  {
    "text": "the callbacks and that loads our arm native code",
    "start": "703839",
    "end": "709440"
  },
  {
    "text": "and then when our app code wants to call a function it calls get trampoline",
    "start": "710079",
    "end": "716480"
  },
  {
    "text": "so we can't actually use dlcm directly because one dl open would not open it because",
    "start": "716480",
    "end": "721600"
  },
  {
    "text": "it's a different architecture and two dlc will give you the pointer directly to the native code and",
    "start": "721600",
    "end": "727920"
  },
  {
    "text": "we can't call that from our android runtime because our native code is armed and our android runtime is running on",
    "start": "727920",
    "end": "733600"
  },
  {
    "text": "x86 processor so the function pointer that's returned by get trampoline and actually a stub",
    "start": "733600",
    "end": "739120"
  },
  {
    "text": "into the interpreter and when you call it the interpreter starts working",
    "start": "739120",
    "end": "745680"
  },
  {
    "text": "and it starts reading the native code and starts emulating these instructions",
    "start": "745680",
    "end": "750959"
  },
  {
    "text": "so i mentioned previously that um whenever you call native code the java side",
    "start": "750959",
    "end": "757360"
  },
  {
    "text": "gives the pointer to the jni instruct function pointers as the first argument",
    "start": "757360",
    "end": "763839"
  },
  {
    "text": "uh similar to how why we can't call dl sim on our native library we can pass our jni instruct directly from native",
    "start": "763839",
    "end": "771120"
  },
  {
    "text": "bridge into our native code because the function pointers you would get are",
    "start": "771120",
    "end": "777600"
  },
  {
    "text": "pointing to functions written in x86 so to handle this um lee houdini creates its own jni",
    "start": "777600",
    "end": "784720"
  },
  {
    "text": "instruct and it's filter function pointers that",
    "start": "784720",
    "end": "789920"
  },
  {
    "text": "it's for the function filter function pointers that lead to uh trap instructions",
    "start": "791040",
    "end": "796880"
  },
  {
    "text": "and when our native code wants to call a function in jnim it loads looks at that",
    "start": "796880",
    "end": "802639"
  },
  {
    "text": "and executes those trap instructions and our interpreter knows which trap instructions those are and it uses the",
    "start": "802639",
    "end": "810000"
  },
  {
    "text": "jni and struck cached when it was called and then",
    "start": "810000",
    "end": "815200"
  },
  {
    "text": "that's the blue line turning into red so basically our native code runs that trap",
    "start": "815200",
    "end": "821360"
  },
  {
    "text": "instruction and interpreter sees that and does the jnam call and returns back to native code and when native code is",
    "start": "821360",
    "end": "827120"
  },
  {
    "text": "done it turns back to the interpreter which turns back to wherever you called um the function pointer",
    "start": "827120",
    "end": "833440"
  },
  {
    "text": "initially from our java that was a",
    "start": "833440",
    "end": "839199"
  },
  {
    "text": "mouthful so now that we have a good uh somewhat understanding of how",
    "start": "839199",
    "end": "845440"
  },
  {
    "text": "liberdini and native bridge gets loaded together we could start delving",
    "start": "845440",
    "end": "851920"
  },
  {
    "text": "deeper into how it works internally starting starting with memory um",
    "start": "851920",
    "end": "859360"
  },
  {
    "text": "lipidini seems to load uh leave houdini loads all of the libraries in the same address space both arm and x86",
    "start": "859760",
    "end": "867360"
  },
  {
    "text": "and it also doesn't have any like special magic translation between arm memory addresses and x86 addresses which",
    "start": "867360",
    "end": "874800"
  },
  {
    "text": "means they're all accessible with each other um",
    "start": "874800",
    "end": "880079"
  },
  {
    "text": "and there but there is a separate allocation for arm stack and you can see",
    "start": "880079",
    "end": "885199"
  },
  {
    "text": "it here this is a snippet from the process memory map using self pid map",
    "start": "885199",
    "end": "892000"
  },
  {
    "text": "and you can see our native library and lipuidine loaded um these are the arm libraries that are",
    "start": "892000",
    "end": "899839"
  },
  {
    "text": "loaded and the ones on the bottom are x86 so they are in this in fact in the same address space",
    "start": "899839",
    "end": "906320"
  },
  {
    "text": "um and lift c is loaded for both the arm version and x86 version and we could",
    "start": "906320",
    "end": "912720"
  },
  {
    "text": "also see some anonymous memory mapped and our stack is somewhere in there",
    "start": "912720",
    "end": "919199"
  },
  {
    "text": "so let's go to the next part which is how the houdini actually executes the instructions",
    "start": "920320",
    "end": "925600"
  },
  {
    "text": "so i mentioned previously it's basically a switch inside a while loop plus a state machine to keep track of the",
    "start": "925600",
    "end": "931519"
  },
  {
    "text": "register states processor states and this portion shows the",
    "start": "931519",
    "end": "937279"
  },
  {
    "text": "kind of like the fetch decode and dispatch portion of it and i'm going to describe the",
    "start": "937279",
    "end": "944639"
  },
  {
    "text": "the comments in the next slide so what it does is it",
    "start": "944639",
    "end": "949839"
  },
  {
    "text": "basically reads the instruction from memory it checks in uh",
    "start": "949839",
    "end": "955199"
  },
  {
    "text": "checks the first four bits which in arm is the condition code field and if it's",
    "start": "955199",
    "end": "960240"
  },
  {
    "text": "your x0e which means always it continues and if it's not it jumps somewhere to what to",
    "start": "960240",
    "end": "966800"
  },
  {
    "text": "see whether they should continue running the instruction um",
    "start": "966800",
    "end": "971839"
  },
  {
    "text": "so when we get to that point it concatenates the bits 20 to 27 with bits four to seven",
    "start": "971839",
    "end": "978399"
  },
  {
    "text": "and then uses that as an index into the instruction table which is shown on the right",
    "start": "978399",
    "end": "985120"
  },
  {
    "text": "and you can see it's just filled with function pointers addresses",
    "start": "985120",
    "end": "992079"
  },
  {
    "text": "so for example our move r0r1 instruction and arm looks like that and when you do",
    "start": "992240",
    "end": "997279"
  },
  {
    "text": "the math you get an index of 0x181 and after you're doing some more calculation you find that the",
    "start": "997279",
    "end": "1004160"
  },
  {
    "text": "instruction handler for the move instruction is at 4bc004",
    "start": "1004160",
    "end": "1010480"
  },
  {
    "text": "and just to show you what it looks like at 4bc04 we have the function pointer to",
    "start": "1010480",
    "end": "1016399"
  },
  {
    "text": "instruction move 1 and on the right side is giga's",
    "start": "1016399",
    "end": "1021600"
  },
  {
    "text": "decompiled function um yeah so somewhere in there there is uh",
    "start": "1022160",
    "end": "1030079"
  },
  {
    "text": "there's some code that moves register values around around like line 22 and 27",
    "start": "1030079",
    "end": "1035678"
  },
  {
    "text": "but you also notice that each instruction handler takes two",
    "start": "1035679",
    "end": "1040880"
  },
  {
    "text": "parameters the first is the instruction itself so it could decode the rest of the fields from it",
    "start": "1040880",
    "end": "1046798"
  },
  {
    "text": "and the second argument is the processor state struct",
    "start": "1046799",
    "end": "1052559"
  },
  {
    "text": "and so yeah that's where all the register values are stored so let's talk about that",
    "start": "1052559",
    "end": "1058880"
  },
  {
    "text": "the processor state struct stores the arm registers as well as other important processor states",
    "start": "1058880",
    "end": "1064480"
  },
  {
    "text": "so that was what i was able to reverse from look looking at the labrudini binary but",
    "start": "1064480",
    "end": "1070000"
  },
  {
    "text": "you could see like the first 64 bytes are used to store the 16 registers of",
    "start": "1070000",
    "end": "1075520"
  },
  {
    "text": "arm there is also a field that tells it whether it's in thomas mode or not",
    "start": "1075520",
    "end": "1081520"
  },
  {
    "text": "and there's some other things that i don't really know what they do so",
    "start": "1081520",
    "end": "1088480"
  },
  {
    "text": "since this keeps track of the process state if we know where it is we would be able to",
    "start": "1089120",
    "end": "1094799"
  },
  {
    "text": "read and write to it and which means we could change register values or for example if we change r15 which is a",
    "start": "1094799",
    "end": "1101679"
  },
  {
    "text": "program counter for arm and if you change the value it would switch execution to a different location",
    "start": "1101679",
    "end": "1107039"
  },
  {
    "text": "so syscalls are up next um how does sys calls work um it works just like any other uh",
    "start": "1107039",
    "end": "1114640"
  },
  {
    "text": "instruction decoding so just like previously it sees a syscall instruction it will go to the instruction table and",
    "start": "1114640",
    "end": "1120720"
  },
  {
    "text": "jump to the right handler and this is actually where the system handlers begin",
    "start": "1120720",
    "end": "1127039"
  },
  {
    "text": "and they also follow the same form function prototype so it takes the instruction",
    "start": "1127039",
    "end": "1133039"
  },
  {
    "text": "the itself and the pointer to the processor state",
    "start": "1133039",
    "end": "1138880"
  },
  {
    "text": "but you might notice that it actually does not issue a x86 test call here directly",
    "start": "1138880",
    "end": "1145039"
  },
  {
    "text": "it only sets the svc number field with the syscall number and the actual syscall is made further",
    "start": "1145039",
    "end": "1151600"
  },
  {
    "text": "along the uh execution in the the while loop",
    "start": "1151600",
    "end": "1157280"
  },
  {
    "text": "um yeah so while most of the syscalls are simple",
    "start": "1157280",
    "end": "1163120"
  },
  {
    "text": "enough and they're just wrapped and re-performed in x86",
    "start": "1163120",
    "end": "1169120"
  },
  {
    "text": "we thought one specific syscall was of interest and that is the clones this call",
    "start": "1169120",
    "end": "1176320"
  },
  {
    "text": "and i also wrote a fork because nowadays you use fork it goes to lip c1 with",
    "start": "1176320",
    "end": "1181919"
  },
  {
    "text": "lipsy fork which does a clone syscall instead",
    "start": "1181919",
    "end": "1187840"
  },
  {
    "text": "so we want to see how that worked and as i mentioned like",
    "start": "1187840",
    "end": "1193120"
  },
  {
    "text": "uh arm syscalls are intercepted and handled by lipoutini in x86",
    "start": "1193120",
    "end": "1198559"
  },
  {
    "text": "so for clone it clones the process in x86 and then",
    "start": "1198559",
    "end": "1204799"
  },
  {
    "text": "each the child and the parent handles the logic to convert it you know back into",
    "start": "1204799",
    "end": "1211440"
  },
  {
    "text": "how the arm would see it and clone actually takes an argument",
    "start": "1211440",
    "end": "1217200"
  },
  {
    "text": "called child stack so you could give it a memory buffer memory pointer and tell the kernel to use this as a",
    "start": "1217200",
    "end": "1223840"
  },
  {
    "text": "child stack and this is actually not passed to kernel directly because",
    "start": "1223840",
    "end": "1229120"
  },
  {
    "text": "um the top of the dot child stack is the return address so if you if we if lipoedini gave the memory that arm",
    "start": "1229120",
    "end": "1236320"
  },
  {
    "text": "provided directly to the x86 kernel it would return to an arm address which it won't be able",
    "start": "1236320",
    "end": "1242640"
  },
  {
    "text": "to run so instead liputini creates an rwx page and passes that as a child stack",
    "start": "1242640",
    "end": "1251120"
  },
  {
    "text": "so now we have an insight somewhat inside of how the emulator works internally",
    "start": "1252320",
    "end": "1258320"
  },
  {
    "text": "we could try to do some fun things with it for example if we we could try to see if whether our code is running under the",
    "start": "1258320",
    "end": "1264480"
  },
  {
    "text": "houdini or not um and try to check that we could check for the host processor right because we'll be running in our",
    "start": "1264480",
    "end": "1270400"
  },
  {
    "text": "arm code but if we want to see if it's running under houdini you could check",
    "start": "1270400",
    "end": "1275760"
  },
  {
    "text": "the host processor architecture and you could do it from java using like osr to get property or by reading the",
    "start": "1275760",
    "end": "1282000"
  },
  {
    "text": "prox cpu info but this will actually not work because houdini hides this",
    "start": "1282000",
    "end": "1287360"
  },
  {
    "text": "and i'll albeit not very well and you actually might be able to tell because if you look carefully the os arch",
    "start": "1287360",
    "end": "1294159"
  },
  {
    "text": "properties has rnv7l which is not what the cpu info says which says it's rnv8 processor rev1",
    "start": "1294159",
    "end": "1302000"
  },
  {
    "text": "arc64 with the hardware serial number of or hardware version of placeholder",
    "start": "1302000",
    "end": "1307840"
  },
  {
    "text": "um great um [Music]",
    "start": "1307840",
    "end": "1313120"
  },
  {
    "text": "so another thing we could do is also uh check the memory maps",
    "start": "1313120",
    "end": "1318880"
  },
  {
    "text": "one to check if lipodenia is loaded and two to see if there's both arm and x86 binaries going on in there",
    "start": "1318880",
    "end": "1327200"
  },
  {
    "text": "however we think the best way to do this is quietly because all",
    "start": "1327360",
    "end": "1333600"
  },
  {
    "text": "the methods we mentioned above required use of some syscall like opening these files or doing some",
    "start": "1333600",
    "end": "1339520"
  },
  {
    "text": "memory mapping related assist calls so the best implementation is one that's",
    "start": "1339520",
    "end": "1346640"
  },
  {
    "text": "quiet and hard to detect and we came up with one way um and because i i mentioned previously",
    "start": "1346640",
    "end": "1354000"
  },
  {
    "text": "um lipodini provides a fake arm jni vamp",
    "start": "1354000",
    "end": "1359600"
  },
  {
    "text": "pointer which has trap instructions we could try to read that instruction and see if it's a valid arm instruction",
    "start": "1359600",
    "end": "1366400"
  },
  {
    "text": "or also valid but it's a trap instruction",
    "start": "1366400",
    "end": "1371200"
  },
  {
    "text": "another fun thing we could do with houdini is we could try to escape to x86 because it is a",
    "start": "1371440",
    "end": "1378080"
  },
  {
    "text": "fake virtual emulator right so",
    "start": "1378080",
    "end": "1383360"
  },
  {
    "text": "their now container break out is pretty popular so we could try to see if we could break",
    "start": "1383360",
    "end": "1388880"
  },
  {
    "text": "out of x86 and we could do it a few ways and one way would be calling and protect and overriding code",
    "start": "1388880",
    "end": "1396799"
  },
  {
    "text": "so we have an executable memory however this is not subtle again because",
    "start": "1396799",
    "end": "1402960"
  },
  {
    "text": "we're using a syscall and i mean if you're doing analysis on these apps some some process calls and protect",
    "start": "1402960",
    "end": "1409679"
  },
  {
    "text": "and you might be suspicious of it so without doing that we could also do x86 stack manipulations um we could try",
    "start": "1409679",
    "end": "1417600"
  },
  {
    "text": "to find the stack and clobber with raw payloads um we could try to overwrite the return",
    "start": "1417600",
    "end": "1422960"
  },
  {
    "text": "address function pointer but the hard part would be to you know getting the raw payload finding",
    "start": "1422960",
    "end": "1428880"
  },
  {
    "text": "the drop chains or finding our executable page to run in",
    "start": "1428880",
    "end": "1434320"
  },
  {
    "text": "this is not an issue because the houdini provides if you notice",
    "start": "1435279",
    "end": "1440880"
  },
  {
    "text": "if you were if you look carefully in the previous slide there were also there were actually multiple read write execute",
    "start": "1440880",
    "end": "1446720"
  },
  {
    "text": "pages um which means you could write code to it and just jump to it",
    "start": "1446720",
    "end": "1452000"
  },
  {
    "text": "um in x86 you would uh yeah just to show what some of these",
    "start": "1452000",
    "end": "1458480"
  },
  {
    "text": "other pages are being used for um this memory region contains our fake",
    "start": "1458480",
    "end": "1464960"
  },
  {
    "text": "arm jnim arm jni instruct",
    "start": "1464960",
    "end": "1470400"
  },
  {
    "text": "and this address is used for arm stack so going back to the read write execute",
    "start": "1470400",
    "end": "1476159"
  },
  {
    "text": "pages um we could write code too and jump to it and if you're in x86 you still have to",
    "start": "1476159",
    "end": "1481760"
  },
  {
    "text": "figure out how to get our program counter or instruction pointer to go to the actual address",
    "start": "1481760",
    "end": "1487520"
  },
  {
    "text": "but since we have executable pages but on arm we we're running arm code so we could just jump to it",
    "start": "1487520",
    "end": "1494559"
  },
  {
    "text": "um the harder problem might be trying to find the red drive execute pages",
    "start": "1494559",
    "end": "1500400"
  },
  {
    "text": "this is also not an issue because apparently houdini does not care about the execute",
    "start": "1500400",
    "end": "1507520"
  },
  {
    "text": "this makes sense as an interpreter because libridini's interpreter and",
    "start": "1508320",
    "end": "1514640"
  },
  {
    "text": "it treats the instructions as the or to it instructions are to the host just data",
    "start": "1514640",
    "end": "1520640"
  },
  {
    "text": "so as an interpreter if you can read the data it will read the instructions it will run them",
    "start": "1520640",
    "end": "1526320"
  },
  {
    "text": "so therefore the arm libraries themselves are not loaded with the execute bit set on their pages",
    "start": "1526320",
    "end": "1532640"
  },
  {
    "text": "so as you can imagine this is pretty trivial to abuse i just write code anywhere and jump to it",
    "start": "1532640",
    "end": "1539120"
  },
  {
    "text": "and here is my proof concept for running it on a the executable version of houdini",
    "start": "1539120",
    "end": "1545360"
  },
  {
    "text": "so in main i allocate some memory um actually the first version of this code i wrote it was not on stack it was on",
    "start": "1545360",
    "end": "1551840"
  },
  {
    "text": "the um and uninternalized is that on the heap or it was in an",
    "start": "1551840",
    "end": "1557840"
  },
  {
    "text": "an uninitialized data section and i write some instructions to it and",
    "start": "1557840",
    "end": "1564320"
  },
  {
    "text": "this specifically adds r0 1 to r0 and then returns",
    "start": "1564320",
    "end": "1569760"
  },
  {
    "text": "and then i cast it to function pointers and then call it so under on real armed devices",
    "start": "1569760",
    "end": "1576880"
  },
  {
    "text": "this would cause a set fall because you should not be able to execute from the stack or the heap",
    "start": "1576880",
    "end": "1582640"
  },
  {
    "text": "given that their proper protection is in place but if you run it through the houdini",
    "start": "1582640",
    "end": "1587840"
  },
  {
    "text": "you can see on the bottom they ran just fine and i for the lid houdini version",
    "start": "1587840",
    "end": "1595520"
  },
  {
    "text": "i have some demos including some of the things i talked about earlier so",
    "start": "1595520",
    "end": "1601440"
  },
  {
    "text": "this is on the chromebook and i built an app that's houdini tools",
    "start": "1601440",
    "end": "1606480"
  },
  {
    "text": "for both arm and x86 versions on it they're built off of the same code",
    "start": "1606480",
    "end": "1612400"
  },
  {
    "text": "um it just i set it so that it builds them separately for different architectures",
    "start": "1612400",
    "end": "1618000"
  },
  {
    "text": "so on the top is our x86 build and on the bottom is our arm build and on x86",
    "start": "1618000",
    "end": "1623360"
  },
  {
    "text": "we see the cpu info um the screen we saw or it reports normally",
    "start": "1623360",
    "end": "1630320"
  },
  {
    "text": "right we have our gender and intel and the top it says i-686 from system get property",
    "start": "1630320",
    "end": "1637039"
  },
  {
    "text": "now on the bottom we saw basically what we saw earlier osrt says armv7 and when we read prox",
    "start": "1637039",
    "end": "1644880"
  },
  {
    "text": "cpu info it says rv8 which is not rv7",
    "start": "1644880",
    "end": "1650320"
  },
  {
    "text": "and hardware placeholder so the second tab demonstrates the uh",
    "start": "1650799",
    "end": "1657840"
  },
  {
    "text": "detection method we could use one possible detection method we could use by using the jni m function pointers",
    "start": "1657840",
    "end": "1664159"
  },
  {
    "text": "so when i click fetch all it would actually from the native side return the addresses of n",
    "start": "1664159",
    "end": "1670000"
  },
  {
    "text": "and m get version function pointer and the bottom tool will dereference that function pointer as",
    "start": "1670000",
    "end": "1677679"
  },
  {
    "text": "double words so we see that on x86 um when we dereference the function",
    "start": "1678640",
    "end": "1684480"
  },
  {
    "text": "point nerd it looks like there are some push instructions",
    "start": "1684480",
    "end": "1689520"
  },
  {
    "text": "as you would often see in the beginning of a function but when we try this on",
    "start": "1689520",
    "end": "1697640"
  },
  {
    "text": "yeah when we try this on the arm version we actually get",
    "start": "1698240",
    "end": "1703760"
  },
  {
    "text": "we also get value instructions under get version and get call static and method but they're not they they're they are",
    "start": "1703760",
    "end": "1710320"
  },
  {
    "text": "the system system called trap instructions uh denoted by ef and the number follows it is the actual syscall",
    "start": "1710320",
    "end": "1717440"
  },
  {
    "text": "number",
    "start": "1717440",
    "end": "1719759"
  },
  {
    "text": "oops and the third tab is just a tool um utility that's useful and it reads",
    "start": "1722840",
    "end": "1729919"
  },
  {
    "text": "uh proc self maps to see what's loaded in there so x86 there is no like the",
    "start": "1729919",
    "end": "1735120"
  },
  {
    "text": "predini loaded this is filtered because there's way too much stuff in there but there's",
    "start": "1735120",
    "end": "1740640"
  },
  {
    "text": "no lip houdini loaded on and in if you read the maps you could see there's",
    "start": "1740640",
    "end": "1746240"
  },
  {
    "text": "lee houdini loaded in there as well as um a bunch of arm libraries",
    "start": "1746240",
    "end": "1752559"
  },
  {
    "text": "uh i'm having a little trouble finding it here uh right there's the arm library and then",
    "start": "1752559",
    "end": "1758799"
  },
  {
    "text": "i'm like where's lippidini and then i find it here right there",
    "start": "1758799",
    "end": "1764880"
  },
  {
    "text": "right so the last tab is our font tab",
    "start": "1764880",
    "end": "1770559"
  },
  {
    "text": "so i built this little layout um where the left side will be the instruction i want to run and the right",
    "start": "1770559",
    "end": "1776720"
  },
  {
    "text": "side will be the uh the result when you run the code and",
    "start": "1776720",
    "end": "1782480"
  },
  {
    "text": "all it does is it it it pushes the bytes on the left side",
    "start": "1782480",
    "end": "1788080"
  },
  {
    "text": "onto the stack or actually in in in on the heap on the native side and then jumps to it so",
    "start": "1788080",
    "end": "1795600"
  },
  {
    "text": "and i i didn't want to remember all the op codes so it's i put some buttons in there to fill it in",
    "start": "1795600",
    "end": "1801600"
  },
  {
    "text": "um so this would obviously not work because this does not have lip houdini loaded and it it's at and",
    "start": "1801600",
    "end": "1808399"
  },
  {
    "text": "x86 so it crashed and that is what would happen on real arm devices as well because it's going",
    "start": "1808399",
    "end": "1814159"
  },
  {
    "text": "to try to execute from the heap but when you have a system",
    "start": "1814159",
    "end": "1819440"
  },
  {
    "text": "running on x86 that's running arm native code with lip houdini",
    "start": "1819440",
    "end": "1825120"
  },
  {
    "text": "this works and when i click run um it incremented the five",
    "start": "1825120",
    "end": "1831679"
  },
  {
    "text": "um so yeah i you can see the actual bytes here e2 8 blah blah one which is arm for",
    "start": "1831679",
    "end": "1839840"
  },
  {
    "text": "add r0 or zero one so that increments one and returns which is why i named the increment",
    "start": "1839840",
    "end": "1846159"
  },
  {
    "text": "the second um and yeah i could change the the value i call the function with with r0 r1r2 and the second one adds the",
    "start": "1846159",
    "end": "1853919"
  },
  {
    "text": "two integers numbers together seven and two i get nine the second one is the third",
    "start": "1853919",
    "end": "1859519"
  },
  {
    "text": "tab third program is multiply so it multiplies r1 and r2 and adds it to r0",
    "start": "1859519",
    "end": "1866080"
  },
  {
    "text": "so in this case would be 20 90 97 right and the last program i prepared is the",
    "start": "1866080",
    "end": "1873360"
  },
  {
    "text": "get sp which would just return the stack pointer from the arm side",
    "start": "1873360",
    "end": "1878640"
  },
  {
    "text": "and takes no parameters so it doesn't really matter and that is the stack address of the arm",
    "start": "1878640",
    "end": "1886640"
  },
  {
    "text": "processor now just to show that this is actually you know um",
    "start": "1886640",
    "end": "1893200"
  },
  {
    "text": "being sent into the native code and written to the to memory and being executed you could just change it i i",
    "start": "1893200",
    "end": "1899440"
  },
  {
    "text": "wrote it so that you you could actually type in real bytes and it would pass it and write to memory and jump to it so if",
    "start": "1899440",
    "end": "1905200"
  },
  {
    "text": "i change it to f which should be the r15 which is the program counter for arm it would give me where the function",
    "start": "1905200",
    "end": "1911519"
  },
  {
    "text": "itself is located where it's executing so yeah it is changing around a little bit because",
    "start": "1911519",
    "end": "1916880"
  },
  {
    "text": "this is not on the stack this is actually on the heap so malloc and free so it's going to change around a little bit",
    "start": "1916880",
    "end": "1922640"
  },
  {
    "text": "but you can see that when i change the code it actually returns something i can show that here instead of incrementing",
    "start": "1922640",
    "end": "1928000"
  },
  {
    "text": "one i increment two and just happen to know that's the correct bit to change um it the r0 is seven and incremented by",
    "start": "1928000",
    "end": "1935519"
  },
  {
    "text": "two um and if i want to compare the incremented by three i could change the instruction to incremented three and we",
    "start": "1935519",
    "end": "1941519"
  },
  {
    "text": "get ten um you could do this multiple times as well just to really show that this is the",
    "start": "1941519",
    "end": "1947440"
  },
  {
    "text": "dynamic code execution that was a demo",
    "start": "1947440",
    "end": "1954240"
  },
  {
    "text": "so what can we do with these fun features of luputini well",
    "start": "1955919",
    "end": "1964240"
  },
  {
    "text": "we know that uh apps are often analyzed by security researchers and app stores and they",
    "start": "1964480",
    "end": "1970799"
  },
  {
    "text": "mostly do it in three ways when they run in sandbox environments they could do it in real arm devices or",
    "start": "1970799",
    "end": "1976880"
  },
  {
    "text": "fully virtualized device environment like chemu or x86 android emulators kind of like vms",
    "start": "1976880",
    "end": "1984159"
  },
  {
    "text": "so real arm devices will be the best because it will give you actual real behavior of how it would work",
    "start": "1984159",
    "end": "1990559"
  },
  {
    "text": "uh the thing is sometimes it's hard to instrument and it's it's hard to do at a larger scale",
    "start": "1990559",
    "end": "1997039"
  },
  {
    "text": "and the second best option would be fully virtualize our environments like chemu but this has a significant",
    "start": "1997039",
    "end": "2004000"
  },
  {
    "text": "performance hit because you're emulating the entire stack the hardware",
    "start": "2004000",
    "end": "2011278"
  },
  {
    "text": "the third option would be using commercial android emulators or like",
    "start": "2011440",
    "end": "2017440"
  },
  {
    "text": "the android sdks android emulators which run on x86",
    "start": "2017440",
    "end": "2022720"
  },
  {
    "text": "and these are these also have a performance hit but not as much as a fully virtualized",
    "start": "2022720",
    "end": "2028080"
  },
  {
    "text": "one and if you use liphoudini you could also analyze arm native code on this while",
    "start": "2028080",
    "end": "2034159"
  },
  {
    "text": "the android part is x86 so",
    "start": "2034159",
    "end": "2039760"
  },
  {
    "text": "also note if if an app expresses different behavior depending on which one of these environments it's running on that would",
    "start": "2039760",
    "end": "2046640"
  },
  {
    "text": "obviously one harder to detect and two it'd be hard to analyze because you have",
    "start": "2046640",
    "end": "2051679"
  },
  {
    "text": "inconsistent behavior so using this what if we could key in",
    "start": "2051679",
    "end": "2057200"
  },
  {
    "text": "this method so what if a malware were to detect whether",
    "start": "2057200",
    "end": "2063839"
  },
  {
    "text": "it's running on the lipoutini or not and say if there's no leproudini it comes to conclusion that it's not under analysis",
    "start": "2063839",
    "end": "2070320"
  },
  {
    "text": "and starts doing malicious behaviors and when there is lipidini it thinks that there is analysis and does not do",
    "start": "2070320",
    "end": "2077440"
  },
  {
    "text": "any malicious behaviors so another example is if you know for a",
    "start": "2077440",
    "end": "2082800"
  },
  {
    "text": "fact that a certain analysis or a certain app store or whatever is using one of",
    "start": "2082800",
    "end": "2088480"
  },
  {
    "text": "these methods to analyze the apps you can use that as fingerprinting",
    "start": "2088480",
    "end": "2095040"
  },
  {
    "text": "conversely on a malware could be could be running malicious",
    "start": "2096079",
    "end": "2104000"
  },
  {
    "text": "behaviors when it detects leboudini so that it could use",
    "start": "2104000",
    "end": "2109200"
  },
  {
    "text": "abuse the lebrodini to further obfuscate itself using the fun features that i demonstrated um so for example we don't",
    "start": "2109200",
    "end": "2116800"
  },
  {
    "text": "know what the play store uses nowadays but it does not seem like they're using um",
    "start": "2116800",
    "end": "2122320"
  },
  {
    "text": "it's it does not seem like it doesn't seem like they're uh running the arm apks on x836 devices",
    "start": "2122320",
    "end": "2128720"
  },
  {
    "text": "lip houdini so this would be a use case for something like that",
    "start": "2128720",
    "end": "2134560"
  },
  {
    "text": "yeah so with all these issues we have some recommendations to",
    "start": "2137680",
    "end": "2143119"
  },
  {
    "text": "vendors and platforms first of all drop the unnecessary rwx pages",
    "start": "2143119",
    "end": "2148560"
  },
  {
    "text": "because that would not itself give give it access to run code but it would",
    "start": "2148560",
    "end": "2154960"
  },
  {
    "text": "make it easier once you figure out how so if it's really necessary",
    "start": "2154960",
    "end": "2160640"
  },
  {
    "text": "perform a finer page permission control implement an efficient",
    "start": "2160640",
    "end": "2166320"
  },
  {
    "text": "nx slash userline page table implementation and",
    "start": "2166320",
    "end": "2171520"
  },
  {
    "text": "we understand checking the page table every time an instruction is loaded would incur a significant overhead so",
    "start": "2171520",
    "end": "2177760"
  },
  {
    "text": "instead what we recommend is you keep track of the page mappings in process in a data structure and perform checks only",
    "start": "2177760",
    "end": "2185040"
  },
  {
    "text": "if the instruction currently running is in a different page than the instruction that ran previously",
    "start": "2185040",
    "end": "2193200"
  },
  {
    "text": "and lastly if you're going to go through all this you might as well use virtualization which has all the",
    "start": "2193200",
    "end": "2198720"
  },
  {
    "text": "pretty efficient implementation of the nx bit and the page table implementation",
    "start": "2198720",
    "end": "2204800"
  },
  {
    "text": "so we'll actually discuss how actually we could actually implement the user land page table and the annex bit",
    "start": "2204800",
    "end": "2210720"
  },
  {
    "text": "implementation this could be done a couple ways one we",
    "start": "2210720",
    "end": "2215839"
  },
  {
    "text": "only trust the executable section on load um",
    "start": "2215839",
    "end": "2221200"
  },
  {
    "text": "fairly obvious two we whenever we load a new page we check",
    "start": "2221200",
    "end": "2227200"
  },
  {
    "text": "from uh or execute from a new page we check proc self maps and then",
    "start": "2227200",
    "end": "2232480"
  },
  {
    "text": "add that into the data structure for caching and three we could um",
    "start": "2232480",
    "end": "2237599"
  },
  {
    "text": "in libradini we could for example you could have functionality in map and",
    "start": "2237599",
    "end": "2243040"
  },
  {
    "text": "protect to track the syst permissions um so when a program calls map with",
    "start": "2243040",
    "end": "2248640"
  },
  {
    "text": "execute permission um it does the map but also keeps adds it to this data structure where it's",
    "start": "2248640",
    "end": "2254720"
  },
  {
    "text": "set as execute or not execute but the ideal solution combines",
    "start": "2254720",
    "end": "2261040"
  },
  {
    "text": "the number two and number three with the number two checked performed as a catch-all kind of and this also has",
    "start": "2261040",
    "end": "2268240"
  },
  {
    "text": "extra benefits which is it now it can now support dynamic straight object loading via dl open",
    "start": "2268240",
    "end": "2274880"
  },
  {
    "text": "um because dl open would do that and deal open would run and it would do all the",
    "start": "2274880",
    "end": "2279920"
  },
  {
    "text": "sys calls and though it's basically you've implemented a page table in user space and",
    "start": "2279920",
    "end": "2287040"
  },
  {
    "text": "uh yeah the second thing is because it also works normally now with",
    "start": "2287040",
    "end": "2293200"
  },
  {
    "text": "proper protection you could also you could now support legitimate just-in-time",
    "start": "2293200",
    "end": "2298560"
  },
  {
    "text": "compilation and obviously after it's done running the output code you should create and clear",
    "start": "2298560",
    "end": "2305760"
  },
  {
    "text": "it and so you can't to prevent page views attacks",
    "start": "2305760",
    "end": "2311119"
  },
  {
    "text": "uh so the data structure we're talking about that keeps track of the pages is basically our useland page table and",
    "start": "2311119",
    "end": "2318320"
  },
  {
    "text": "that and should be heavily heavily heavily protected",
    "start": "2318320",
    "end": "2323440"
  },
  {
    "text": "such as it should only be writable when being updated it could be surrounded by guard pages or",
    "start": "2323440",
    "end": "2329119"
  },
  {
    "text": "and it should definitely not be accessible to arm processor",
    "start": "2329119",
    "end": "2334079"
  },
  {
    "text": "um so for if anyone's doing analysis of these android application",
    "start": "2335040",
    "end": "2340720"
  },
  {
    "text": "um for dynamic glasses it's highly recommended to also run it under libertini environments to see if it does",
    "start": "2340720",
    "end": "2348240"
  },
  {
    "text": "any uh it shows any uh different behaviors and",
    "start": "2348240",
    "end": "2353440"
  },
  {
    "text": "if you're running static analysis um you should be looking for any access and weird red memory accesses to",
    "start": "2353440",
    "end": "2360000"
  },
  {
    "text": "the houdini pages and attempting to execute from non-executable pages",
    "start": "2360000",
    "end": "2366079"
  },
  {
    "text": "and scanning the jni function pointers because that's what i would be doing",
    "start": "2366079",
    "end": "2372720"
  },
  {
    "text": "and that brings us to the conclusion uh houdini introduces a number of security weaknesses into",
    "start": "2373599",
    "end": "2379839"
  },
  {
    "text": "things that use it and those impact the both the emulated",
    "start": "2379839",
    "end": "2384960"
  },
  {
    "text": "section emulated arm processor and the host x86 code",
    "start": "2384960",
    "end": "2391520"
  },
  {
    "text": "and these issues overall undermine coordinative code hardening",
    "start": "2391520",
    "end": "2396920"
  },
  {
    "text": "so we could have it's possible",
    "start": "2397040",
    "end": "2402880"
  },
  {
    "text": "that these issues could have been caught earlier had houdini been more public and",
    "start": "2402880",
    "end": "2408640"
  },
  {
    "text": "more easily accessible which would mean more people would have looked at it that's just what we think",
    "start": "2408640",
    "end": "2416318"
  },
  {
    "text": "um and that's the only presentation but i want to give a big special thanks to jeff for",
    "start": "2417440",
    "end": "2423359"
  },
  {
    "text": "mentoring this research and come developing the methodology",
    "start": "2423359",
    "end": "2428560"
  },
  {
    "text": "uh jennifer for great support with all the research and",
    "start": "2428560",
    "end": "2434079"
  },
  {
    "text": "feedback great feedback and effie for basically bootstrapping this research including the chromebook i was doing the",
    "start": "2434079",
    "end": "2439520"
  },
  {
    "text": "testing on and and thanks everyone for joining the session and we'll have q a",
    "start": "2439520",
    "end": "2448520"
  }
]