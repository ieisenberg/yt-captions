[
  {
    "start": "0",
    "end": "228000"
  },
  {
    "text": "hi everybody we have gathered on the other side of the channel to talk about",
    "start": "30",
    "end": "5250"
  },
  {
    "text": "the side channels my name is Andre and together with my partner in crime Dan",
    "start": "5250",
    "end": "10969"
  },
  {
    "text": "we're gonna talk about bypassing kpti using the speculative behavior of the subjects instruction as a short bio",
    "start": "10969",
    "end": "18600"
  },
  {
    "text": "about us my daily job is doing hypervisor based number introspection and then is working on developing anti",
    "start": "18600",
    "end": "27119"
  },
  {
    "text": "exploit technologies both work for B defender I've been with B defender for",
    "start": "27119",
    "end": "32578"
  },
  {
    "text": "11 years it's been like 15 14 14 years so yeah and when we join our powers we",
    "start": "32579",
    "end": "39000"
  },
  {
    "text": "do all kind of freaky stuff such as side channels and the other security research ok so we're gonna go through the",
    "start": "39000",
    "end": "47010"
  },
  {
    "text": "introduction we're gonna talk about how side channels works work short recap or",
    "start": "47010",
    "end": "52770"
  },
  {
    "text": "Danny's gonna talk about speculative segmentation I'm gonna dig into exploiting the sub GS instruction and",
    "start": "52770",
    "end": "60870"
  },
  {
    "text": "then we're gonna go through mitigations and recommendations in order to avoid this issue so what is the problem well",
    "start": "60870",
    "end": "68130"
  },
  {
    "text": "the problem in a nutshell is that the subjects instruction can be executed speculatively and this leads to two",
    "start": "68130",
    "end": "75090"
  },
  {
    "text": "potential issues the first one inside user space because subjects can be executed speculatively inside user space",
    "start": "75090",
    "end": "82140"
  },
  {
    "text": "as well leads to a variant of rock system register load which as the",
    "start": "82140",
    "end": "88409"
  },
  {
    "text": "traditional rock system register load allows for ksl or bypass and flicking",
    "start": "88409",
    "end": "93920"
  },
  {
    "text": "memory from areas which should be hidden by a row space layout randomization inside kernel space however there are",
    "start": "93920",
    "end": "101700"
  },
  {
    "text": "two variants type one when subjects is not getting executed speculatively even",
    "start": "101700",
    "end": "108750"
  },
  {
    "text": "if it should and type two where subjects get speculatively executed even if it",
    "start": "108750",
    "end": "114210"
  },
  {
    "text": "should and we have investigated the type two scenario inside kernel space because",
    "start": "114210",
    "end": "120869"
  },
  {
    "text": "as we will immediately see this allows for rather easy memory leaking from",
    "start": "120869",
    "end": "128190"
  },
  {
    "text": "inside the user space all right so swab",
    "start": "128190",
    "end": "133420"
  },
  {
    "text": "attack is basically a new variant of Spectre right and you can lick portions",
    "start": "133420",
    "end": "139989"
  },
  {
    "text": "of the kernel memory even if the system is patched again Spectre meltdown and 1tf MDS and so on",
    "start": "139989",
    "end": "147599"
  },
  {
    "text": "luckily a patch has been issued by Microsoft it was issued roughly a month before the problem was published and",
    "start": "147599",
    "end": "155790"
  },
  {
    "text": "Intel didn't address and I don't think they're planning to address this issue in silicon in the foreseeable future the",
    "start": "155790",
    "end": "165660"
  },
  {
    "text": "affected CPUs pretty much order 64-bit CPU starting with Ivy Bridge they must",
    "start": "165660",
    "end": "172330"
  },
  {
    "text": "support the suggest instruction of course and for a simple exploitation they also have to support the right to",
    "start": "172330",
    "end": "179049"
  },
  {
    "text": "GS based instruction AMD CPUs are also vulnerable but only to the subject",
    "start": "179049",
    "end": "185350"
  },
  {
    "text": "scenario or type 1 and as for the affected os's we've tested our exploit",
    "start": "185350",
    "end": "193420"
  },
  {
    "text": "on Windows 7 and newer so 7 8 8.1 Windows 10 and so on and from our",
    "start": "193420",
    "end": "199660"
  },
  {
    "text": "analysis it looks like the Linux OSS are pretty much impossible to exploit right",
    "start": "199660",
    "end": "206530"
  },
  {
    "text": "and this being said I'm gonna invite done to get the side channel going hello",
    "start": "206530",
    "end": "213280"
  },
  {
    "text": "so we'll describe next prerequisites and the building blocks needed for the attack detailing the workings of",
    "start": "213280",
    "end": "219970"
  },
  {
    "text": "spectral meltdown as they are related directly to our attacks so ok side",
    "start": "219970",
    "end": "229690"
  },
  {
    "start": "228000",
    "end": "610000"
  },
  {
    "text": "channel attack allows an attacker to infer information about victim by making",
    "start": "229690",
    "end": "234700"
  },
  {
    "text": "careful measurements the main cause is that both the attacker and the victim",
    "start": "234700",
    "end": "240130"
  },
  {
    "text": "code execute on the same hardware thread and victim execution makes cache modifications that are observable by the",
    "start": "240130",
    "end": "246730"
  },
  {
    "text": "not by the attacker so how this works first the attacker brings the cash to a",
    "start": "246730",
    "end": "252970"
  },
  {
    "text": "known state then executes victim code which will modify cash content and then",
    "start": "252970",
    "end": "258510"
  },
  {
    "text": "the attacker determines what was modified by performing cache access time",
    "start": "258510",
    "end": "263919"
  },
  {
    "text": "measurements for example let's see if as an attacker we want to check if a variable has been",
    "start": "263919",
    "end": "271160"
  },
  {
    "text": "previously accessed or not first the attacker flush is a test variable from the cache execute the victim code that",
    "start": "271160",
    "end": "278389"
  },
  {
    "text": "measures how long it takes to access that test variable again now if the access time is small it means that a",
    "start": "278389",
    "end": "284090"
  },
  {
    "text": "variable has been obsessed by the victim execution if the access time is high then the variable has not been accessed",
    "start": "284090",
    "end": "290440"
  },
  {
    "text": "such attacks are already demonstrated in the literature we have a fetcher text tsx attacks and so on there are many",
    "start": "290440",
    "end": "299750"
  },
  {
    "text": "measurement techniques such as flush and below to evict and time Prime and probe",
    "start": "299750",
    "end": "305389"
  },
  {
    "text": "each suitable for different attack scenarios each technique allow allows",
    "start": "305389",
    "end": "311300"
  },
  {
    "text": "the attacker to probe for memory accesses made by the victim in our attacks we use flash memory load for",
    "start": "311300",
    "end": "317300"
  },
  {
    "text": "example flushing a test variable executing the victim then reassessing the test variable and if the access time",
    "start": "317300",
    "end": "323270"
  },
  {
    "text": "is load and victim execution accessed part of the cache including our test variable or else it did not in early",
    "start": "323270",
    "end": "331900"
  },
  {
    "text": "2018 a new class of side channels speculative side channels emerged such",
    "start": "331900",
    "end": "337550"
  },
  {
    "text": "as spectrum meltdown or 1tf and so on they allow information disclosure across",
    "start": "337550",
    "end": "343639"
  },
  {
    "text": "across arbitrary security boundaries and cannot be detected by modern software",
    "start": "343639",
    "end": "349150"
  },
  {
    "text": "mitigations for this attacks involve microcode updates in the CPU or software",
    "start": "349150",
    "end": "354289"
  },
  {
    "text": "mitigations made by the operating system kernels or compilers will touch a bit on",
    "start": "354289",
    "end": "359810"
  },
  {
    "text": "spectral meltdown as they are directly related to our attack the main problem",
    "start": "359810",
    "end": "366919"
  },
  {
    "text": "with spectrum for performance reasons modern CPUs use branch prediction to",
    "start": "366919",
    "end": "372320"
  },
  {
    "text": "predict the outcome of a comparison in a conditional branch in an if statement before the actual outcome is computed",
    "start": "372320",
    "end": "379400"
  },
  {
    "text": "for example if one of the operands is in memory without using prediction the CPU",
    "start": "379400",
    "end": "385580"
  },
  {
    "text": "will have to wait for the memory access to happen which is slow and just wasting",
    "start": "385580",
    "end": "393090"
  },
  {
    "text": "precious computing cycles whenever it and if is encountered the CP will try to guess the correct branch direction",
    "start": "393090",
    "end": "399419"
  },
  {
    "text": "either taken or not taken if the guess is correct then the execution precedes normally if the guess is not correct",
    "start": "399419",
    "end": "405689"
  },
  {
    "text": "then the CPU has to discard all executed instructions and begin executing the correct branch we have a simple example",
    "start": "405689",
    "end": "414210"
  },
  {
    "text": "here a simple if condition and let's assume that for a given set of inputs the branch predictor meets predicts the",
    "start": "414210",
    "end": "421409"
  },
  {
    "text": "result so foo is executed speculatively now speculative execution does not",
    "start": "421409",
    "end": "426990"
  },
  {
    "text": "affect our detector or visible visible CPU state such as the registers however",
    "start": "426990",
    "end": "432449"
  },
  {
    "text": "instructions that access memory during speculative execution leave traces in the CPU caches and those traces can be",
    "start": "432449",
    "end": "440039"
  },
  {
    "text": "recovered by using the previously discussed cache size channels such as a flash memory load the CPU detects",
    "start": "440039",
    "end": "448909"
  },
  {
    "text": "mispredicted branch discards the result of the speculative execution of fool and",
    "start": "448909",
    "end": "456830"
  },
  {
    "text": "executes the false branch which is the correct path now for another set of",
    "start": "456830",
    "end": "462330"
  },
  {
    "text": "inputs the CPU still predicts that the branch will be taken so foo will execute speculatively and since the branch was",
    "start": "462330",
    "end": "470400"
  },
  {
    "text": "predicted correctly the results are committed to a architectural state and become visible to the programmer a bit",
    "start": "470400",
    "end": "479400"
  },
  {
    "text": "about meltdown modern operating systems use hardware mechanisms for preventing",
    "start": "479400",
    "end": "484800"
  },
  {
    "text": "user mode code access to kernel mode code and data now when accessing memory",
    "start": "484800",
    "end": "490979"
  },
  {
    "text": "the CPU translates a virtual address into a physical address by consulting the page tables which are under the",
    "start": "490979",
    "end": "497759"
  },
  {
    "text": "operating system control they cannot be modified by user mode code the operating",
    "start": "497759",
    "end": "503639"
  },
  {
    "text": "system configured page tables to isolate user mode code from accessing kernel",
    "start": "503639",
    "end": "509009"
  },
  {
    "text": "mode data for example a virtual address cannot be used in user mode to access physical memory if the page table",
    "start": "509009",
    "end": "515820"
  },
  {
    "text": "entries translating that virtual address don't have a special bit a special flag user supervisor flag set",
    "start": "515820",
    "end": "522840"
  },
  {
    "text": "now classical meltdown abuses the fact that ring three out of order execution",
    "start": "522840",
    "end": "528150"
  },
  {
    "text": "of memory load instructions can temporary access can allow data if a",
    "start": "528150",
    "end": "534779"
  },
  {
    "text": "virtual address translation exists in the process page tables for that kernel-mode address even if that user",
    "start": "534779",
    "end": "540990"
  },
  {
    "text": "supervisor beat in the PT is not set",
    "start": "540990",
    "end": "546050"
  },
  {
    "text": "mitigations for meltdown are either in hardware in newer CPUs or in software at",
    "start": "546050",
    "end": "551610"
  },
  {
    "text": "the operating system level now software mitigations such as kpti or KVA shadow",
    "start": "551610",
    "end": "556920"
  },
  {
    "text": "and map the colonel aerospace wireless CPU executes sin ring three they use a",
    "start": "556920",
    "end": "563190"
  },
  {
    "text": "split page table architecture they use two sets of page tables one set is used",
    "start": "563190",
    "end": "569070"
  },
  {
    "text": "when executing in ring three and that such doesn't contain any kernel mode virtual address translations and the",
    "start": "569070",
    "end": "576330"
  },
  {
    "text": "other set is used when executing in ring zero which contains kernel vehicle mode",
    "start": "576330",
    "end": "581880"
  },
  {
    "text": "virtual address translations and user mode virtual address translations if no",
    "start": "581880",
    "end": "587040"
  },
  {
    "text": "virtual address translations are present for a kernel mode address in the set",
    "start": "587040",
    "end": "592860"
  },
  {
    "text": "used in user mode then no leak can occur during out of outer loads so we consider meltdown solved while the",
    "start": "592860",
    "end": "601800"
  },
  {
    "text": "CPU executes in ring zero on Windows operating systems the kernel mode page table also Maps the user mount address",
    "start": "601800",
    "end": "608339"
  },
  {
    "text": "space so we saw that meltdown abuse these parts of the vitro fertilisation",
    "start": "608339",
    "end": "614880"
  },
  {
    "start": "610000",
    "end": "925000"
  },
  {
    "text": "mekinese mainly the page tables but the act of translating a virtual address to a physical address involves more than",
    "start": "614880",
    "end": "621420"
  },
  {
    "text": "just the page tables it involves an earlier Murli memory protection",
    "start": "621420",
    "end": "626430"
  },
  {
    "text": "mechanism used before page tables were invented called segmentation we",
    "start": "626430",
    "end": "631530"
  },
  {
    "text": "researched what happens when segmentation instructions are executed speculatively now segmentation is used",
    "start": "631530",
    "end": "639000"
  },
  {
    "text": "to compose a linear address from a logical address which is composed of a",
    "start": "639000",
    "end": "644250"
  },
  {
    "text": "segment selector and on offset into that segment the segment selector is used as an index into the gdt the global",
    "start": "644250",
    "end": "651390"
  },
  {
    "text": "descriptor table to select a segment descriptor which contains information about segments such as the break base address",
    "start": "651390",
    "end": "657269"
  },
  {
    "text": "and its access rights next that base address is added to the offset and is",
    "start": "657269",
    "end": "664229"
  },
  {
    "text": "used to form the linear address which will be further translated via the page tables now details of the segmentation",
    "start": "664229",
    "end": "671339"
  },
  {
    "text": "process are real are largely invisible to the programmer because x86",
    "start": "671339",
    "end": "676379"
  },
  {
    "text": "instructions use implicit segments when executed or during memory accesses for example when executing code the implicit",
    "start": "676379",
    "end": "682979"
  },
  {
    "text": "code segment is CS for an existing data the implicit data segment inside the DS",
    "start": "682979",
    "end": "690959"
  },
  {
    "text": "or stack SS however the X the x86",
    "start": "690959",
    "end": "696539"
  },
  {
    "text": "architecture allows the segment overwrite for most instructions forcing the forming of a linear address from a",
    "start": "696539",
    "end": "703649"
  },
  {
    "text": "user specified segment to speed up the",
    "start": "703649",
    "end": "709229"
  },
  {
    "text": "computation of the linear address special segment registers inside the CPU cache the segment base and access rights",
    "start": "709229",
    "end": "715649"
  },
  {
    "text": "into a hidden portion whenever a new segment descriptor is loaded to segments",
    "start": "715649",
    "end": "720659"
  },
  {
    "text": "FS and GS have their segment registers a basis physically mapped to model",
    "start": "720659",
    "end": "726479"
  },
  {
    "text": "specific registers the FS segment register is mapped to ia32 FS base m sr and the GS segment register base is",
    "start": "726479",
    "end": "734429"
  },
  {
    "text": "mapped to a I are 32 GS base a mess up now lagea space the GS segment has a",
    "start": "734429",
    "end": "740609"
  },
  {
    "text": "detect dedicated functionality on Windows on x64 platforms when executing",
    "start": "740609",
    "end": "746129"
  },
  {
    "text": "in user mode it is used to store",
    "start": "746129",
    "end": "751529"
  },
  {
    "text": "information about the currently executing thread when the CPU executes in ring zero the GS segment is used to",
    "start": "751529",
    "end": "757949"
  },
  {
    "text": "access per logical CPU information stored in the kernel processor control region this is a special structure",
    "start": "757949",
    "end": "763919"
  },
  {
    "text": "maintained by the operating system and also contains pointers inside int OS kernel",
    "start": "763919",
    "end": "771079"
  },
  {
    "text": "on user to Colonel transitions the colonel uses the swap GS instruction to exchange the contents of the IR 32 GS",
    "start": "773330",
    "end": "780500"
  },
  {
    "text": "base MSR with the eye of 30 to colonel GS base MSR so further memory access is",
    "start": "780500",
    "end": "786290"
  },
  {
    "text": "via the GS segment overrides will point into that kernel processor control region and on Colonel to user",
    "start": "786290",
    "end": "792350"
  },
  {
    "text": "transitions before returning control to user mode the killer again uses fob GS so further memory access is via the GS",
    "start": "792350",
    "end": "799490"
  },
  {
    "text": "segment overrides will point into a threat environment block in user mode we",
    "start": "799490",
    "end": "806570"
  },
  {
    "text": "study the security implications of speculatively executing segmentation related instructions on Intel CPUs on",
    "start": "806570",
    "end": "813410"
  },
  {
    "text": "x86 CPUs so we have two key technical findings the first one is that during",
    "start": "813410",
    "end": "819019"
  },
  {
    "text": "speculative execution after loading the GS or FS segment registers with an invalid segment selector and then",
    "start": "819019",
    "end": "826459"
  },
  {
    "text": "subsequently using that segment in further speculatively executed memory access instructions Intel CPUs use the",
    "start": "826459",
    "end": "833750"
  },
  {
    "text": "previously stored segment base address of the segment register to compute the linear address used for memory",
    "start": "833750",
    "end": "839390"
  },
  {
    "text": "addressing and the second technical finding is that a value of written speculatively to the base of a segment",
    "start": "839390",
    "end": "846470"
  },
  {
    "text": "register survives instruction retirement and can be later retrieved by loading by",
    "start": "846470",
    "end": "851480"
  },
  {
    "text": "loading an invalid segment selector into that segment register now these two",
    "start": "851480",
    "end": "857959"
  },
  {
    "text": "security these two technical findings give birth to five security implications",
    "start": "857959",
    "end": "866320"
  },
  {
    "text": "all these security implications were responsibly disclosed to Intel of course",
    "start": "866320",
    "end": "871600"
  },
  {
    "text": "the first one subverting KS LR has the biggest impact as it allows to define",
    "start": "871600",
    "end": "878029"
  },
  {
    "text": "demise the base address of the kernel and find its layout but not its content",
    "start": "878029",
    "end": "883660"
  },
  {
    "text": "bypassing SLR is often a prerequisite step in performing a local provide",
    "start": "883660",
    "end": "889010"
  },
  {
    "text": "escalation and this attack because it's using Hardware vulnerabilities it's largely invisible to current detection",
    "start": "889010",
    "end": "895010"
  },
  {
    "text": "mechanisms the rest of the security implications have minor impact on modern up-to-date operating systems both others",
    "start": "895010",
    "end": "902899"
  },
  {
    "text": "and Intel agreed that existing mitigations present in more in Windows and Linux such as maps",
    "start": "902899",
    "end": "910580"
  },
  {
    "text": "map and ours be stuffing are enough to protect against exploiting them now we",
    "start": "910580",
    "end": "916190"
  },
  {
    "text": "go we won't go into detail into each of these security implications detailed descriptions for all of those can be",
    "start": "916190",
    "end": "922640"
  },
  {
    "text": "found in the white paper which is available online will show however",
    "start": "922640",
    "end": "929230"
  },
  {
    "text": "walkthrough of supporting Windows cares allowed using this finding so first",
    "start": "929230",
    "end": "937550"
  },
  {
    "text": "we'll try to retrieve the eye of 30 to Colonel Diaz base MSR value from user",
    "start": "937550",
    "end": "943190"
  },
  {
    "text": "mode normally you can't read this MSR using 3 Thomas on instruction because",
    "start": "943190",
    "end": "949030"
  },
  {
    "text": "that would generate a general protection fault since it's not accessible in ring",
    "start": "949030",
    "end": "954500"
  },
  {
    "text": "3 if we get to this value of the ia32",
    "start": "954500",
    "end": "959720"
  },
  {
    "text": "cannot just base then will on windows this will give us the pointer to the KP",
    "start": "959720",
    "end": "966350"
  },
  {
    "text": "sphere to that kernel processor control region so let's assume we execute code in ring frame in an unprivileged process",
    "start": "966350",
    "end": "972560"
  },
  {
    "text": "on windows x64 we have the current GS base equals ir 32 GS base the MSR value",
    "start": "972560",
    "end": "980480"
  },
  {
    "text": "is a pointer to the threat environment block and the previous GS base equals ir",
    "start": "980480",
    "end": "986780"
  },
  {
    "text": "32 colonel GS base the MSR value pointing to the cannot processor control",
    "start": "986780",
    "end": "992810"
  },
  {
    "text": "region as a result from prior execution in kernel mode if we run the following",
    "start": "992810",
    "end": "1000070"
  },
  {
    "text": "code min user mode on Windows it will allow us to retrieve the value of the IR",
    "start": "1000070",
    "end": "1005950"
  },
  {
    "text": "32 kilo GS base in MSR so first we force",
    "start": "1005950",
    "end": "1011140"
  },
  {
    "text": "a page fault and force the CPU to speculatively execute all the next instructions next we load an invalid",
    "start": "1011140",
    "end": "1019450"
  },
  {
    "text": "segment selector into register internal r 9 that selector is way outside the GD",
    "start": "1019450",
    "end": "1026650"
  },
  {
    "text": "t limit we unload the invalid segment selector into the GS segment register",
    "start": "1026650",
    "end": "1032530"
  },
  {
    "text": "this would cause a fault since the descriptor points outside of the GD T limit",
    "start": "1032530",
    "end": "1038470"
  },
  {
    "text": "and next we use read GS base of valid instruction in ring frame to read the GS",
    "start": "1038470",
    "end": "1044798"
  },
  {
    "text": "base value now normally we would expect the destination register rocks to contain the value of the eye of 32 GS",
    "start": "1044799",
    "end": "1051759"
  },
  {
    "text": "base MSR since we are executing in user mode but it contains instead the value",
    "start": "1051759",
    "end": "1056799"
  },
  {
    "text": "of I are 32 colonel GS base MSR as a weird side effect of previously loading",
    "start": "1056799",
    "end": "1063220"
  },
  {
    "text": "an invalid sum and selector into the GS segment register next lines 5 to 8",
    "start": "1063220",
    "end": "1069370"
  },
  {
    "text": "represent a classical flash and reload the side channel we don't we won't go into details using the same approach the",
    "start": "1069370",
    "end": "1079750"
  },
  {
    "text": "same pattern we can leak direct values from k PT k pc are thus leaking pointers",
    "start": "1079750",
    "end": "1086740"
  },
  {
    "text": "from inside and us colonel",
    "start": "1086740",
    "end": "1091860"
  },
  {
    "text": "this time we love the valid segment selector into the GS segment register however its desired privilege level is",
    "start": "1092710",
    "end": "1099460"
  },
  {
    "text": "zero meaning that access is through memory through this selector is only possible if the CPU executes in ring",
    "start": "1099460",
    "end": "1106690"
  },
  {
    "text": "zero note that we execute this code in ring 3 so we expect that further access",
    "start": "1106690",
    "end": "1112299"
  },
  {
    "text": "is from ring 3 through GS will raise a general protection exception instead",
    "start": "1112299",
    "end": "1119980"
  },
  {
    "text": "when accessing memory through the invalid in ring freeze lecture because these instructions execute speculative",
    "start": "1119980",
    "end": "1126250"
  },
  {
    "text": "lim and access checking is delayed until instruction retirement and because a",
    "start": "1126250",
    "end": "1132129"
  },
  {
    "text": "valid translation exists in the process page tables for the K PCR on Windows the",
    "start": "1132129",
    "end": "1139000"
  },
  {
    "text": "value of the byte in the K PCR is moved into rocks and then further using a",
    "start": "1139000",
    "end": "1144220"
  },
  {
    "text": "classical flush and reload lines 5 and 10 so in conclusion treating arbitrary",
    "start": "1144220",
    "end": "1151570"
  },
  {
    "text": "values from K PCR allows us to retrieve pointers inside ng OS kernel thus supporting Windows key SLR",
    "start": "1151570",
    "end": "1159269"
  },
  {
    "text": "now all this segmentation instructions execute in speculative limb gave us some",
    "start": "1159269",
    "end": "1165909"
  },
  {
    "text": "insights some to two key insights the first one is since during",
    "start": "1165909",
    "end": "1171369"
  },
  {
    "text": "speculative the cushion and segmentation instructions in ring 3 we can access ms",
    "start": "1171369",
    "end": "1177040"
  },
  {
    "text": "arts in kernel mode and kernel data it follows that during speculative",
    "start": "1177040",
    "end": "1182200"
  },
  {
    "text": "execution of segmentation instructions in kernel mode we can force the kernel to access I are 32 GS base and user mode",
    "start": "1182200",
    "end": "1191290"
  },
  {
    "text": "data and the second insight is if we can for speculative execution of",
    "start": "1191290",
    "end": "1197380"
  },
  {
    "text": "segmentation instructions in ring 0 after the kernel move to its kernel page tables we may able to force it to access",
    "start": "1197380",
    "end": "1204370"
  },
  {
    "text": "arbitrary data in memory now that kernel memory is mapped so with each arm",
    "start": "1204370",
    "end": "1211660"
  },
  {
    "text": "research question is can we find instances of such instructions in modern operating system kernels and can we",
    "start": "1211660",
    "end": "1218170"
  },
  {
    "text": "identify speculatively executed gadgets around them that would leak arbitrary kernel memory fast defeating kpti and an",
    "start": "1218170",
    "end": "1228280"
  },
  {
    "start": "1227000",
    "end": "1681000"
  },
  {
    "text": "answer to this question will be given by entry yes there's all really only one",
    "start": "1228280",
    "end": "1234330"
  },
  {
    "text": "option for this question otherwise we wouldn't be here so yes we can and combining what we've",
    "start": "1234330",
    "end": "1241990"
  },
  {
    "text": "already seen about sub GS being executable speculatively and with 1 Dan",
    "start": "1241990",
    "end": "1247900"
  },
  {
    "text": "pointed I pointed out that the CPU curiously handles segments related",
    "start": "1247900",
    "end": "1253840"
  },
  {
    "text": "instructions we thought about ok what if swap just gets executed speculatively inside the kernel could define an",
    "start": "1253840",
    "end": "1260770"
  },
  {
    "text": "interesting gadget could you leak memory after the kernel page tables are loaded and so on so a quick introduction about",
    "start": "1260770",
    "end": "1268300"
  },
  {
    "text": "the subject instructions instruction for those of you who are unfamiliar with the",
    "start": "1268300",
    "end": "1273400"
  },
  {
    "text": "system programming subject is a system instruction which was introduced in the 64-bit x86 architecture segmentation is",
    "start": "1273400",
    "end": "1282280"
  },
  {
    "text": "mostly disabled in 64 bits so each segment is considered with the base of 0",
    "start": "1282280",
    "end": "1287500"
  },
  {
    "text": "and basically infinite limit but FS and GS segments are still usable",
    "start": "1287500",
    "end": "1293380"
  },
  {
    "text": "however they are treated somewhat differently in that instead of using the gdt to get their base addresses to a",
    "start": "1293380",
    "end": "1300610"
  },
  {
    "text": "mess herbs are used just like Dan pointed out the ia32 FS base and just be",
    "start": "1300610",
    "end": "1306220"
  },
  {
    "text": "the subject's instruction uses also a third such MSR which is the ia32 colonel",
    "start": "1306220",
    "end": "1313150"
  },
  {
    "text": "jazz bass and what it does it swaps the value of GS bass with the colonel jazz",
    "start": "1313150",
    "end": "1318400"
  },
  {
    "text": "bass and we also have the right half s bass and right jazz bass instructions",
    "start": "1318400",
    "end": "1323590"
  },
  {
    "text": "which can be executed inside ring three which is important for our exploitation",
    "start": "1323590",
    "end": "1330430"
  },
  {
    "text": "technique so the first scenario of the subject's attack in this scenario you",
    "start": "1330430",
    "end": "1337360"
  },
  {
    "text": "have code inside the kernel which would require subjects to be executed but instead do Tommy speculated branch the",
    "start": "1337360",
    "end": "1344710"
  },
  {
    "text": "subject never gets to be executed and this type of code is located at the",
    "start": "1344710",
    "end": "1350920"
  },
  {
    "text": "entry point of each exception handler of the Windows kernel right here we have clear example this is a piece of",
    "start": "1350920",
    "end": "1357730"
  },
  {
    "text": "assembly code taken directly from the page four shadow handler inside Windows",
    "start": "1357730",
    "end": "1362860"
  },
  {
    "text": "kernel and whenever a page for this is triggered either in user space or chrono",
    "start": "1362860",
    "end": "1368500"
  },
  {
    "text": "space these are the first instructions that get to be executed the first instruction is a test instruction",
    "start": "1368500",
    "end": "1374710"
  },
  {
    "text": "followed by a conditional branch which if the test instruction is true would be",
    "start": "1374710",
    "end": "1380590"
  },
  {
    "text": "taken and the label the instructions lying at the the following label would",
    "start": "1380590",
    "end": "1386380"
  },
  {
    "text": "be executed however if the branch is mispredicted and is not taken the",
    "start": "1386380",
    "end": "1392830"
  },
  {
    "text": "subject's instruction would not be executed and due to this the old GS the",
    "start": "1392830",
    "end": "1400360"
  },
  {
    "text": "GS that was loaded before the exception took place would still be used normally",
    "start": "1400360",
    "end": "1407230"
  },
  {
    "text": "the execution should continue other following label after the subjects has",
    "start": "1407230",
    "end": "1413230"
  },
  {
    "text": "been executed and the GS has been has been loaded this scenario is rather",
    "start": "1413230",
    "end": "1419830"
  },
  {
    "text": "hardly exploitable we didn't give it too much attention because there is a lower",
    "start": "1419830",
    "end": "1425590"
  },
  {
    "text": "hanging fruit in the scenario - which is when the subjects instruction gets to be",
    "start": "1425590",
    "end": "1431290"
  },
  {
    "text": "executed speculatively even if it shouldn't and this is rather easily exploitable because there are several",
    "start": "1431290",
    "end": "1438370"
  },
  {
    "text": "gadgets we make it very easy to to mount an attack",
    "start": "1438370",
    "end": "1443610"
  },
  {
    "text": "this is another piece of assembly code taken from the same page fault handler and this code again is present inside",
    "start": "1443610",
    "end": "1451480"
  },
  {
    "text": "all the exception and interrupt handlers inside the Windows kernel this is an",
    "start": "1451480",
    "end": "1457300"
  },
  {
    "text": "actual copy paste so the first instruction again a test instruction test of variable that's the first bit",
    "start": "1457300",
    "end": "1463810"
  },
  {
    "text": "inside the KVL shadow variable and it executes a conditional branch now",
    "start": "1463810",
    "end": "1470500"
  },
  {
    "text": "normally what happens is that the branch should be taken and the execution should",
    "start": "1470500",
    "end": "1476380"
  },
  {
    "text": "continue with the instruction following the subjects instruction so subjects should not be executed however if the",
    "start": "1476380",
    "end": "1484060"
  },
  {
    "text": "branch is amiss predicted subjects is executed speculatively and execution",
    "start": "1484060",
    "end": "1489130"
  },
  {
    "text": "continues with the following instructions which begin to reference GS based memory and GS based memory in this",
    "start": "1489130",
    "end": "1497110"
  },
  {
    "text": "scenario would basically be attacker controlled memory because once you execute subjects you make the user",
    "start": "1497110",
    "end": "1504190"
  },
  {
    "text": "control GS active okay so how many such",
    "start": "1504190",
    "end": "1510970"
  },
  {
    "text": "gadgets are there well before the issue was patched on an RS 5 x64 kernel we",
    "start": "1510970",
    "end": "1518350"
  },
  {
    "text": "countered exactly 38 such gadgets and most of them lie inside the exception",
    "start": "1518350",
    "end": "1524560"
  },
  {
    "text": "handlers which are easily executable by simply generating force inside user",
    "start": "1524560",
    "end": "1530650"
  },
  {
    "text": "space like simply triggering a page fault or executing an invalid instruction would eventually lead to the",
    "start": "1530650",
    "end": "1536980"
  },
  {
    "text": "execution of such gadget ok but how can",
    "start": "1536980",
    "end": "1542080"
  },
  {
    "text": "we leak values because as Dan pointed out you would need usually in order to",
    "start": "1542080",
    "end": "1548530"
  },
  {
    "text": "leak values you would use the bite value that you wish to leak as an offset inside attacker controlled memory ok",
    "start": "1548530",
    "end": "1556480"
  },
  {
    "text": "this is the regular scenario right you access a byte use it does not set inside attacker control memory and then you",
    "start": "1556480",
    "end": "1562690"
  },
  {
    "text": "probe the attacker controlled memory to see which which part of it has been cached and depending on which part has",
    "start": "1562690",
    "end": "1569530"
  },
  {
    "text": "been cast you can infer the value goodbye but our chunk of code doesn't",
    "start": "1569530",
    "end": "1574590"
  },
  {
    "text": "even remotely look like something that we could use to directly leak values but",
    "start": "1574590",
    "end": "1580830"
  },
  {
    "text": "what we have instead with these gadgets are a few instructions using GS based",
    "start": "1580830",
    "end": "1587580"
  },
  {
    "text": "addressing okay and let's take a closer look at this gadget this gadget makes",
    "start": "1587580",
    "end": "1595169"
  },
  {
    "text": "several just references okay the first axis the one that loads our CX from",
    "start": "1595169",
    "end": "1601530"
  },
  {
    "text": "offset 188 inside GS is then used for another D reference which loads into our",
    "start": "1601530",
    "end": "1608429"
  },
  {
    "text": "CX another value from the dress pointed by r CX plus 220 and then we have yet",
    "start": "1608429",
    "end": "1615240"
  },
  {
    "text": "another axis which yet again loads into our C X the value located at our CX plus",
    "start": "1615240",
    "end": "1621360"
  },
  {
    "text": "8:30 so we have several memory accesses in some somewhat of a chained manner and",
    "start": "1621360",
    "end": "1628549"
  },
  {
    "text": "we thought about it and we thought okay so let's say that inside GS segment at",
    "start": "1628549",
    "end": "1637140"
  },
  {
    "text": "offset 188 we have value 1000 and let us assume that we map address 1000 inside",
    "start": "1637140",
    "end": "1644640"
  },
  {
    "text": "user space right we trigger the gadget to be executed speculatively and once it",
    "start": "1644640",
    "end": "1650580"
  },
  {
    "text": "executes speculatively address 1000 plus 220 gets cached right because the value",
    "start": "1650580",
    "end": "1657480"
  },
  {
    "text": "that is located inside GS plus 188 resembles a valid user mode address so",
    "start": "1657480",
    "end": "1664740"
  },
  {
    "text": "what we actually do instead of using the kernel value to be leaked as an offset",
    "start": "1664740",
    "end": "1669870"
  },
  {
    "text": "inside the tacker controlled memory we use the kernel value to be leaked as a",
    "start": "1669870",
    "end": "1674940"
  },
  {
    "text": "user mode address and we leverage a direct access into it in order to infer",
    "start": "1674940",
    "end": "1680730"
  },
  {
    "text": "its value all right so digging into the second scenario where we exploit the",
    "start": "1680730",
    "end": "1687809"
  },
  {
    "start": "1681000",
    "end": "2316000"
  },
  {
    "text": "fact that the subject instruction gets executed speculatively even if it shouldn't we've identified two use cases",
    "start": "1687809",
    "end": "1694710"
  },
  {
    "text": "for this exploit the first one simply search for kernel values right this is",
    "start": "1694710",
    "end": "1702540"
  },
  {
    "text": "some sort of a brute force attack where you simply iterate the kernel-space",
    "start": "1702540",
    "end": "1707940"
  },
  {
    "text": "to see at wet addresses you can find a value of your choice and the way this",
    "start": "1707940",
    "end": "1715020"
  },
  {
    "text": "would work is we have the attacker process on the left hand side of the screen and we have the kernel space the",
    "start": "1715020",
    "end": "1721020"
  },
  {
    "text": "GS base normally points while inside user space - the thread information block and the inactive kernel just base",
    "start": "1721020",
    "end": "1728340"
  },
  {
    "text": "points the dark APCR let's assume that inside the kernel at a certain address",
    "start": "1728340",
    "end": "1734790"
  },
  {
    "text": "there is a value that we are searching for inside the kernel memory ok for",
    "start": "1734790",
    "end": "1741030"
  },
  {
    "text": "those of you who are somewhat familiar with reverse engineering and the p5",
    "start": "1741030",
    "end": "1746760"
  },
  {
    "text": "format you would immediately see that this is actually the MZ signature and",
    "start": "1746760",
    "end": "1751830"
  },
  {
    "text": "this particular keyword value is the actual value which is located in the",
    "start": "1751830",
    "end": "1757350"
  },
  {
    "text": "first eight bytes of the Windows NT kernel image all right so we map inside",
    "start": "1757350",
    "end": "1764130"
  },
  {
    "text": "user space memory we map an address which resembles the value to be leaked",
    "start": "1764130",
    "end": "1770040"
  },
  {
    "text": "and we fill it with whatever values we don't really care what right now what we",
    "start": "1770040",
    "end": "1777600"
  },
  {
    "text": "want to see if a particular offset inside this attacker controlled memory",
    "start": "1777600",
    "end": "1782730"
  },
  {
    "text": "inside user space gets cached in our particular use case we are interested",
    "start": "1782730",
    "end": "1788730"
  },
  {
    "text": "about offset a 40 plus 220 because this is the exact offset of the current value",
    "start": "1788730",
    "end": "1794880"
  },
  {
    "text": "inside the anti header plus the offset used by the just base by the instruction",
    "start": "1794880",
    "end": "1800429"
  },
  {
    "text": "following the just based addressing we show a user to kernel transition one of",
    "start": "1800429",
    "end": "1807270"
  },
  {
    "text": "the first we we use right just base first to make the jazz bass point to the",
    "start": "1807270",
    "end": "1813510"
  },
  {
    "text": "kernel memory - 180 and we issue a user to kernel transition now the one of the",
    "start": "1813510",
    "end": "1819630"
  },
  {
    "text": "first things that happens after user to kernel transition is swap gist is being executed and the GS base and the kernel",
    "start": "1819630",
    "end": "1826740"
  },
  {
    "text": "JS basis base are being swapped right now the jazz bass points the kpc are as",
    "start": "1826740",
    "end": "1832410"
  },
  {
    "text": "it should the regular kernel processor control region at the inactive kernel just bass boy",
    "start": "1832410",
    "end": "1838350"
  },
  {
    "text": "our attacker controlled memory which we wish to lick many instructions get to be",
    "start": "1838350",
    "end": "1845010"
  },
  {
    "text": "executed inside the kernel and eventually we hit the vulnerable gadget and in the best case scenario of course",
    "start": "1845010",
    "end": "1851460"
  },
  {
    "text": "the gadget gets mispredicted and subjects instruction is executed speculatively now the GS base points",
    "start": "1851460",
    "end": "1858870"
  },
  {
    "text": "again to the attacker controlled memory and the inactive kernel just base points back to the K PCR and we have the first",
    "start": "1858870",
    "end": "1865260"
  },
  {
    "text": "just base access which loads the secret value inside our ten we have another",
    "start": "1865260",
    "end": "1871440"
  },
  {
    "text": "access at the same address which loads the secret value inside our CX and then",
    "start": "1871440",
    "end": "1877409"
  },
  {
    "text": "we have an access which further dereferences our CX and load secured",
    "start": "1877409",
    "end": "1882480"
  },
  {
    "text": "from there and you would immediately see that since we have mapped the address",
    "start": "1882480",
    "end": "1888030"
  },
  {
    "text": "that equals the secret value we immediately can see that this offset",
    "start": "1888030",
    "end": "1894240"
  },
  {
    "text": "gets cached right so after the misprediction is detected everything is rolled back even the GS and kernel J's",
    "start": "1894240",
    "end": "1901650"
  },
  {
    "text": "bases are soft again to roll back to the original architectural state we get back",
    "start": "1901650",
    "end": "1908250"
  },
  {
    "text": "to user space and one thing has changed the offset to that we are after got",
    "start": "1908250",
    "end": "1914250"
  },
  {
    "text": "cached and this way we can infer that the value at that address inside the",
    "start": "1914250",
    "end": "1920460"
  },
  {
    "text": "kernel space is inside that we inside that range with a cache line bias",
    "start": "1920460",
    "end": "1925500"
  },
  {
    "text": "so basically aligned to 64 bytes and up to plus 64 bytes somewhere in between ok",
    "start": "1925500",
    "end": "1933390"
  },
  {
    "text": "this is pretty neat so we can probe a kernel address to see if the value",
    "start": "1933390",
    "end": "1939720"
  },
  {
    "text": "located there is of a particular fat right but this was not quite enough for",
    "start": "1939720",
    "end": "1946169"
  },
  {
    "text": "us we wanted to be able to leak more values we wanted to be able to leak arbitrary values from arbitrary",
    "start": "1946169",
    "end": "1953100"
  },
  {
    "text": "addresses not simply probing or searching for values inside kernel memory so we thought about it and we got",
    "start": "1953100",
    "end": "1960659"
  },
  {
    "text": "this extension of the first variant which allows the attacker to potentially",
    "start": "1960659",
    "end": "1967679"
  },
  {
    "text": "leak any other value from inside the kernel space as long as they resemble valid user mode addresses and the attack",
    "start": "1967679",
    "end": "1975360"
  },
  {
    "text": "is very similar to the first variant we have the user space the attacker process",
    "start": "1975360",
    "end": "1980850"
  },
  {
    "text": "and we have kernel space the GS base points the thread information block we have the inactive kernel just base",
    "start": "1980850",
    "end": "1987289"
  },
  {
    "text": "pointing to K PC R we have a secret value inside the kernel space and this",
    "start": "1987289",
    "end": "1993240"
  },
  {
    "text": "time we have no idea what that value is unlike the first scenario where we wanted to see if that value is located",
    "start": "1993240",
    "end": "2000799"
  },
  {
    "text": "at data rep at that address this time we don't know anything about this value so",
    "start": "2000799",
    "end": "2007250"
  },
  {
    "text": "what we do first of all we allocate a test variable right and then we start",
    "start": "2007250",
    "end": "2014090"
  },
  {
    "text": "ideally from address 0 and we allocate chunks of memory which we have deduced",
    "start": "2014090",
    "end": "2022510"
  },
  {
    "text": "by doing experiments that the optimum size is the last level cache in size so",
    "start": "2022510",
    "end": "2028100"
  },
  {
    "text": "if the last level cache size is 8 megabytes you would start by allocating on a 10 megabyte chunk at address 0 and",
    "start": "2028100",
    "end": "2035360"
  },
  {
    "text": "run the attack and then move on with 8 megabytes chunk address by address until",
    "start": "2035360",
    "end": "2041210"
  },
  {
    "text": "you see which chunk contains the range the potential range of the value located",
    "start": "2041210",
    "end": "2048858"
  },
  {
    "text": "inside the kernel and for simplicity of course we've skipped in the presentation directly to the target address and yeah",
    "start": "2048859",
    "end": "2057830"
  },
  {
    "text": "we can assume that we've already brute force 15 terabytes of memory this is not very relevant right now but let's assume",
    "start": "2057830",
    "end": "2065720"
  },
  {
    "text": "we directly mapped the exactly the value that we wish what's important right now",
    "start": "2065720",
    "end": "2071030"
  },
  {
    "text": "is that we spray that 8 megabytes chunk of memory with the address of our test",
    "start": "2071030",
    "end": "2077868"
  },
  {
    "text": "variable and this is important because as we will later see there are three in",
    "start": "2077869",
    "end": "2085638"
  },
  {
    "text": "directions using our CX as both the destination and the source for the load",
    "start": "2085639",
    "end": "2091100"
  },
  {
    "text": "right and we can use that as an indicator as a tag to see if the secret",
    "start": "2091100",
    "end": "2096590"
  },
  {
    "text": "kernel of value lies inside the particular range that we've mapped",
    "start": "2096590",
    "end": "2102020"
  },
  {
    "text": "inside user space so we sprayed the buffer with the resort is very variable",
    "start": "2102020",
    "end": "2108170"
  },
  {
    "text": "we use the righteous based instruction to make just base point to our target",
    "start": "2108170",
    "end": "2114620"
  },
  {
    "text": "Colonel address and then we issue a user to Colonel transition and everything",
    "start": "2114620",
    "end": "2121310"
  },
  {
    "text": "happens as before for now so objects gets executed the GS based on Colonel",
    "start": "2121310",
    "end": "2127610"
  },
  {
    "text": "just base get swapped just base now points the K PCR as it should Colonel just base points to the attacker",
    "start": "2127610",
    "end": "2135470"
  },
  {
    "text": "controlled memory and over novel gadget is hit again and the branches",
    "start": "2135470",
    "end": "2141800"
  },
  {
    "text": "mispredicted yet again Spector in action sob Jess gets executed speculatively",
    "start": "2141800",
    "end": "2147260"
  },
  {
    "text": "again GS base points to the attacker controlled memory and we begin to access",
    "start": "2147260",
    "end": "2153260"
  },
  {
    "text": "this attacker controlled memory so our CX is loaded with the secret value and",
    "start": "2153260",
    "end": "2158570"
  },
  {
    "text": "then our CX is loaded with a value located at that address plus the offset",
    "start": "2158570",
    "end": "2165410"
  },
  {
    "text": "to xx which in this case you can see that it the value that it loads inside",
    "start": "2165410",
    "end": "2171290"
  },
  {
    "text": "our CX is basically pointing to our test variable right and we use the following",
    "start": "2171290",
    "end": "2178790"
  },
  {
    "text": "instruction which is another indirection another axis using our CX to basically",
    "start": "2178790",
    "end": "2186400"
  },
  {
    "text": "force test variable to get cached so the test variable is basically used like",
    "start": "2186400",
    "end": "2193420"
  },
  {
    "text": "like a tag just to see if the secret kernel value is within the range that",
    "start": "2193420",
    "end": "2200360"
  },
  {
    "text": "we've mapped inside user space and dummy speculation is detected everything is",
    "start": "2200360",
    "end": "2207200"
  },
  {
    "text": "rolled back the GS bases are are switched again and all the modifications",
    "start": "2207200",
    "end": "2213530"
  },
  {
    "text": "to the microarchitecture or speculative state is being discarded but the test",
    "start": "2213530",
    "end": "2218660"
  },
  {
    "text": "variable remains cached and the reason why we use the test variable which can",
    "start": "2218660",
    "end": "2225350"
  },
  {
    "text": "be small in size is because it's way easier to see whether on one variable",
    "start": "2225350",
    "end": "2232040"
  },
  {
    "text": "got cached instead of checking on entire at 8 megabytes chunk of memory and see",
    "start": "2232040",
    "end": "2237260"
  },
  {
    "text": "which line got cached right because by the time you would iterate through the entire eight megabytes chunk you could potentially",
    "start": "2237260",
    "end": "2244490"
  },
  {
    "text": "evict the line that got cash right when the the gadget executed speculative so",
    "start": "2244490",
    "end": "2250400"
  },
  {
    "text": "we use this test variable as an indicator to see if the value is within our range we get back inside the user",
    "start": "2250400",
    "end": "2258050"
  },
  {
    "text": "space we measure the access time to the test variable and we see it's cached now",
    "start": "2258050",
    "end": "2263360"
  },
  {
    "text": "we know that the secret kernel value is within the range that we've mapped aside",
    "start": "2263360",
    "end": "2268820"
  },
  {
    "text": "user space and this only narrows it down to four now eight megabytes so what can",
    "start": "2268820",
    "end": "2275690"
  },
  {
    "text": "we do to further refine the search well we can basically split this interval in",
    "start": "2275690",
    "end": "2282140"
  },
  {
    "text": "half we can zoom in on this right we can do a binary search we repeat the attack",
    "start": "2282140",
    "end": "2287690"
  },
  {
    "text": "by having that memory range okay we repeat the attack we do the exact same",
    "start": "2287690",
    "end": "2294260"
  },
  {
    "text": "thing and we see initially that is not cached we repeat the attack on the other",
    "start": "2294260",
    "end": "2299690"
  },
  {
    "text": "half and we see it's cached we have it again and we do it again and again and again until we zoom into whatever",
    "start": "2299690",
    "end": "2307630"
  },
  {
    "text": "granularity we want which can usually be a cache line size right so within a 64",
    "start": "2307630",
    "end": "2313910"
  },
  {
    "text": "bytes range okay so this is the specials",
    "start": "2313910",
    "end": "2320180"
  },
  {
    "start": "2316000",
    "end": "2672000"
  },
  {
    "text": "of our attack the way that we used the kernel value as an address in order to",
    "start": "2320180",
    "end": "2325250"
  },
  {
    "text": "infer its bed but of course the attack involved more engineering vendek's",
    "start": "2325250",
    "end": "2330770"
  },
  {
    "text": "and the two most important aspects of successfully mounting such an attack are",
    "start": "2330770",
    "end": "2337130"
  },
  {
    "text": "that the branch before the subjects destruction must be mispredicted somehow",
    "start": "2337130",
    "end": "2342320"
  },
  {
    "text": "and that the kV a shadow variable which is tested before the branch must not be",
    "start": "2342320",
    "end": "2347420"
  },
  {
    "text": "cached we won't go into the details of of these because they have already been",
    "start": "2347420",
    "end": "2353300"
  },
  {
    "text": "demonstrated by an horn by all those smart guys who who pioneered the site channel stuff basically you could force",
    "start": "2353300",
    "end": "2361400"
  },
  {
    "text": "the branch misprediction by simply executing similar branches with different with opposite outcome of which",
    "start": "2361400",
    "end": "2366920"
  },
  {
    "text": "one you could evict the KVA shadow by trashing the cache there several ways we don't go into the",
    "start": "2366920",
    "end": "2374140"
  },
  {
    "text": "details of it another two issues that are of particular interest for us is the",
    "start": "2374140",
    "end": "2380589"
  },
  {
    "text": "test variable alignment and the cache line bias all right so what is the test",
    "start": "2380589",
    "end": "2387400"
  },
  {
    "text": "variable alignment the test variable we spray its address inside the user space",
    "start": "2387400",
    "end": "2394450"
  },
  {
    "text": "all right and the secret value may be aligned to zero may be aligned to one to",
    "start": "2394450",
    "end": "2402099"
  },
  {
    "text": "two to three and so on so we don't know how to spray the address of the test",
    "start": "2402099",
    "end": "2407680"
  },
  {
    "text": "variable inside our user space buffer right because if we spray the address",
    "start": "2407680",
    "end": "2412960"
  },
  {
    "text": "starting with address zero and the secret value and in three so it's not",
    "start": "2412960",
    "end": "2419830"
  },
  {
    "text": "cured aligned we wouldn't get a hit inside our test variable and what we",
    "start": "2419830",
    "end": "2425950"
  },
  {
    "text": "could simply do is basically attempt all the possible offsets which are just",
    "start": "2425950",
    "end": "2431290"
  },
  {
    "text": "eight and since most of the computers have plenty of course to choose from you",
    "start": "2431290",
    "end": "2437140"
  },
  {
    "text": "could yeah launch the attack on each core each one running a different offset",
    "start": "2437140",
    "end": "2443230"
  },
  {
    "text": "and you could you could check if the test variable got cached on any of them",
    "start": "2443230",
    "end": "2449339"
  },
  {
    "text": "right and this is the example where the test variable is sprayed at offset zero",
    "start": "2449339",
    "end": "2455560"
  },
  {
    "text": "but the secret value is aligned to one and we wouldn't get a hit the test variable wouldn't be properly accessed",
    "start": "2455560",
    "end": "2461800"
  },
  {
    "text": "and we wouldn't get the cash signal that we were after to confirm that the secret",
    "start": "2461800",
    "end": "2467830"
  },
  {
    "text": "value is within our range the second the second issue is the cache line bias",
    "start": "2467830",
    "end": "2473230"
  },
  {
    "text": "which basically simply states that the value that we detect could potentially",
    "start": "2473230",
    "end": "2478900"
  },
  {
    "text": "be within a 64 bytes range right because the the cache uses lines which are",
    "start": "2478900",
    "end": "2485710"
  },
  {
    "text": "regularly 64 bytes in size if the kernel value is 163 for example we wouldn't",
    "start": "2485710",
    "end": "2493570"
  },
  {
    "text": "know for sure we would just know that the secret value is somewhere in between 140 and 180 which is still pretty good",
    "start": "2493570",
    "end": "2500470"
  },
  {
    "text": "if you ask me all right so as for the speed the first very is very fast so in our test we could",
    "start": "2500470",
    "end": "2508410"
  },
  {
    "text": "trigger the speculative execution inside the kernel in less than one millisecond and it takes usually less than ten tries",
    "start": "2508410",
    "end": "2515279"
  },
  {
    "text": "then speculative executions of the gadget to get the cash signal that we",
    "start": "2515279",
    "end": "2521279"
  },
  {
    "text": "are after the second variant is obviously much slower because it has to",
    "start": "2521279",
    "end": "2527249"
  },
  {
    "text": "iterate through the entire address space the entire accessible user mode address space to see the range that the secret",
    "start": "2527249",
    "end": "2535559"
  },
  {
    "text": "kernel value is located in and there is also the issue of the lickable domain",
    "start": "2535559",
    "end": "2541259"
  },
  {
    "text": "because since we use the values as addresses and since the 64 bits",
    "start": "2541259",
    "end": "2548309"
  },
  {
    "text": "architecture is very restrictive in regard to addresses the value has to be",
    "start": "2548309",
    "end": "2555589"
  },
  {
    "text": "canonical so it has to resemble a very user mode address so the upper 16 bits",
    "start": "2555589",
    "end": "2561900"
  },
  {
    "text": "or have to be all zeros zeros or what and using regular paging which is for 48",
    "start": "2561900",
    "end": "2568529"
  },
  {
    "text": "bits the lickable domain doing a quick statistics on the windows rs.5 kernel is",
    "start": "2568529",
    "end": "2574710"
  },
  {
    "text": "at about 33 percent and since Intel is",
    "start": "2574710",
    "end": "2580279"
  },
  {
    "text": "very nice and this in extending the address base to 57 bits this only",
    "start": "2580279",
    "end": "2587130"
  },
  {
    "text": "extends the lickable domain to 51 percent all right so mitigations there",
    "start": "2587130",
    "end": "2593999"
  },
  {
    "text": "are several mitigations but the most obvious simple one is serialize or",
    "start": "2593999",
    "end": "2600529"
  },
  {
    "text": "branches which involves objects okay so if you have an if and subject is",
    "start": "2600529",
    "end": "2607049"
  },
  {
    "text": "involved you'd have to serialize both the the branch that is taken and the branch that is not taken okay because",
    "start": "2607049",
    "end": "2614700"
  },
  {
    "text": "once you see realize this basically inhibit speculative execution and instructions cannot start to randomly",
    "start": "2614700",
    "end": "2621690"
  },
  {
    "text": "speculatively access just based memory you could also use techniques such as",
    "start": "2621690",
    "end": "2627089"
  },
  {
    "text": "clobbering the user mode GS on context switches you could make use of supervisor mode access prevention if the",
    "start": "2627089",
    "end": "2633450"
  },
  {
    "text": "CPU has the meltdown patches or you could instrument the kernel yourself and serialize the subject",
    "start": "2633450",
    "end": "2640829"
  },
  {
    "text": "branches yourself so in conclusions we have presented the",
    "start": "2640829",
    "end": "2646589"
  },
  {
    "text": "new spectral variant which abuses the fact that subjects can be executed",
    "start": "2646589",
    "end": "2651660"
  },
  {
    "text": "speculatively and we presented what we hope it is an interesting technique of",
    "start": "2651660",
    "end": "2656930"
  },
  {
    "text": "leaking values by treating them as addresses and yes Microsoft published",
    "start": "2656930",
    "end": "2663630"
  },
  {
    "text": "the patches way back in july 2019 the vulnerability was made public in August",
    "start": "2663630",
    "end": "2670079"
  },
  {
    "text": "the sticks and thank you questions",
    "start": "2670079",
    "end": "2684800"
  },
  {
    "text": "so yeah so thank you for your talk I'll",
    "start": "2691750",
    "end": "2697060"
  },
  {
    "text": "be interested how did you start to research what was the starting point for this complex project well so what was",
    "start": "2697060",
    "end": "2705520"
  },
  {
    "text": "the starting point well initially the starting point was the revolutionary research of Google and Daniel Grusin",
    "start": "2705520",
    "end": "2713290"
  },
  {
    "text": "Busiek University in Amsterdam we just took a look at different stuff that we thought maybe no one took a look at them",
    "start": "2713290",
    "end": "2720460"
  },
  {
    "text": "because they weren't interesting and it started by seeing that subjects gets to",
    "start": "2720460",
    "end": "2725980"
  },
  {
    "text": "be executed speculatively we wanted to dance the curative segmentation and it",
    "start": "2725980",
    "end": "2731440"
  },
  {
    "text": "was a continuous process unfortunately there wasn't a moment of eureka we",
    "start": "2731440",
    "end": "2737220"
  },
  {
    "text": "discovered this is it was more like brick over brick over brick of building",
    "start": "2737220",
    "end": "2742720"
  },
  {
    "text": "this attack from scratch yes",
    "start": "2742720",
    "end": "2752760"
  },
  {
    "text": "so if armed has this kind of vulnerability is that correct so subject",
    "start": "2755070",
    "end": "2765300"
  },
  {
    "text": "is x86 specific so we don't expect arm to be vulnerable to something very",
    "start": "2765300",
    "end": "2773280"
  },
  {
    "text": "similar to this but we are not very arm savvy so we cannot exclude that",
    "start": "2773280",
    "end": "2780930"
  },
  {
    "text": "something similar with other instructions might exist on our so this",
    "start": "2780930",
    "end": "2788250"
  },
  {
    "text": "particular one no other similar to this maybe so this exploit can be made",
    "start": "2788250",
    "end": "2807270"
  },
  {
    "text": "exploitable with JavaScript well this is a good question we haven't thought about",
    "start": "2807270",
    "end": "2813450"
  },
  {
    "text": "this but we made use of the right jazz based",
    "start": "2813450",
    "end": "2819150"
  },
  {
    "text": "instruction to make the attacker controlled memory being pointed by jazz",
    "start": "2819150",
    "end": "2825150"
  },
  {
    "text": "base so it involves the use of instructions which you cannot normally",
    "start": "2825150",
    "end": "2830790"
  },
  {
    "text": "use inside JavaScript so I'd say no but well in InfoSec you can really say no so",
    "start": "2830790",
    "end": "2836520"
  },
  {
    "text": "I say probably not",
    "start": "2836520",
    "end": "2840080"
  },
  {
    "text": "first of all thanks for the great rock and presentation you presented some",
    "start": "2845790",
    "end": "2852120"
  },
  {
    "text": "medications and also the hypervisor",
    "start": "2852120",
    "end": "2857300"
  },
  {
    "text": "specific one for my or our point of view the architecture based specific",
    "start": "2857300",
    "end": "2863700"
  },
  {
    "text": "medications would be the best so my question would be when do you think what",
    "start": "2863700",
    "end": "2868920"
  },
  {
    "text": "what introduce something like the rumor base medications that were introduced",
    "start": "2868920",
    "end": "2874260"
  },
  {
    "text": "that seem to be bypassed also so when do",
    "start": "2874260",
    "end": "2881070"
  },
  {
    "text": "you think would be the first step to to introduce newer architecture that are resistant and first of all do you think",
    "start": "2881070",
    "end": "2887400"
  },
  {
    "text": "that this would be for long term medication yeah I mean I cannot",
    "start": "2887400",
    "end": "2896550"
  },
  {
    "text": "speculate of course so strictly talking",
    "start": "2896550",
    "end": "2901650"
  },
  {
    "text": "about the subjects or Intel specified that they are not intending to fix this",
    "start": "2901650",
    "end": "2906960"
  },
  {
    "text": "in silicon for now and the mitigation is strictly in software so just use facing",
    "start": "2906960",
    "end": "2913890"
  },
  {
    "text": "instructions to serialize this as for the bigger picture of fixing the silicon",
    "start": "2913890",
    "end": "2919520"
  },
  {
    "text": "they're already trying to fix what they can but you know you have performance",
    "start": "2919520",
    "end": "2924840"
  },
  {
    "text": "versus security and the regular users are not concerned about security as much",
    "start": "2924840",
    "end": "2930510"
  },
  {
    "text": "as they are about performance right because they don't really care that someone somewhere might exploit them",
    "start": "2930510",
    "end": "2936510"
  },
  {
    "text": "what they care about is their machine working flawlessly right so the",
    "start": "2936510",
    "end": "2942150"
  },
  {
    "text": "possibility of an attack versus the basically the reality of performance",
    "start": "2942150",
    "end": "2947730"
  },
  {
    "text": "which hits him each time uses its computer",
    "start": "2947730",
    "end": "2953240"
  },
  {
    "text": "all right thank you very much for attending",
    "start": "2956710",
    "end": "2962110"
  },
  {
    "text": "[Applause]",
    "start": "2962460",
    "end": "2965539"
  }
]