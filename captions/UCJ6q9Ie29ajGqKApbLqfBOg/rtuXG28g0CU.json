[
  {
    "start": "0",
    "end": "88000"
  },
  {
    "text": "good afternoon everybody you're in South Seas IJ this next presentation is",
    "start": "0",
    "end": "5879"
  },
  {
    "text": "breaking kernel address space layout randomization with Intel TSX our presenter is Jung Jin Jong I got a",
    "start": "5879",
    "end": "14009"
  },
  {
    "text": "couple of quick announcements before we get started there's a welcome reception in the business hall which is in Bayside",
    "start": "14009",
    "end": "19920"
  },
  {
    "text": "a B that's down on the first floor it's from 1730 to 1900 there's also the",
    "start": "19920",
    "end": "25830"
  },
  {
    "text": "blackhat Arsenal is on Paul Moyer on level three that's one we're on back over by the escalators a lot of neat",
    "start": "25830",
    "end": "31590"
  },
  {
    "text": "stuff there definitely want to check that out and also the pony Awards tonight in Mandalay Bay BC D that's on",
    "start": "31590",
    "end": "38070"
  },
  {
    "text": "level 2 that's at 18:30 so that's always a good time you want to enjoy that if you haven't already please",
    "start": "38070",
    "end": "44040"
  },
  {
    "text": "put your phone on vibrate or silent so that it doesn't interrupt the talk and with that I'll turn it over to a young",
    "start": "44040",
    "end": "49620"
  },
  {
    "text": "Jean good afternoon I'm Jung Jin from",
    "start": "49620",
    "end": "54750"
  },
  {
    "text": "Georgia Tech and today I have project our top title DRK breaking kernel ideas",
    "start": "54750",
    "end": "60000"
  },
  {
    "text": "are all with intel TSX and this is a joint work with my colleague dr. Sangolli and professor Tetsu Kim let's",
    "start": "60000",
    "end": "68790"
  },
  {
    "text": "start with the easy one what is kernel a as they're all so on the slide there are two news articles",
    "start": "68790",
    "end": "75750"
  },
  {
    "text": "and one is for iOS and the other is for generally for Windows and what they say",
    "start": "75750",
    "end": "81630"
  },
  {
    "text": "is bypassing areas are all is required for the successful attack let's take an",
    "start": "81630",
    "end": "89340"
  },
  {
    "start": "88000",
    "end": "88000"
  },
  {
    "text": "example on how kernel a is it all makes effective defense against the exploit in",
    "start": "89340",
    "end": "95900"
  },
  {
    "text": "Linux on launching privilege escalation attack through the kernel exploit the",
    "start": "95900",
    "end": "101640"
  },
  {
    "text": "attacker might try to call two functions one is prepare connect read with zero to",
    "start": "101640",
    "end": "107939"
  },
  {
    "text": "prepare root credential and the 11 one is called commit creat which is a making",
    "start": "107939",
    "end": "113729"
  },
  {
    "text": "current user as a root user the code in the figure is actually extracted from",
    "start": "113729",
    "end": "119969"
  },
  {
    "text": "the real colonel exploit in 2010 and 2013 and both of them calls those two",
    "start": "119969",
    "end": "127200"
  },
  {
    "text": "functions in the exploit that however the attacker is required to know",
    "start": "127200",
    "end": "133200"
  },
  {
    "text": "the exact a ders of those functions for the successful exploit previously those that",
    "start": "133200",
    "end": "140640"
  },
  {
    "text": "your addresses are fixed and by accessing prop file system at KL Sims it",
    "start": "140640",
    "end": "147269"
  },
  {
    "text": "will be easily to be retrieved however in the recent Linux distributions such as Ubuntu it is",
    "start": "147269",
    "end": "154590"
  },
  {
    "text": "prohibited to access that as a non root user so if you access that data location",
    "start": "154590",
    "end": "159780"
  },
  {
    "text": "Pro KL Sims with non root user what you get is just all 0 all the addresses",
    "start": "159780",
    "end": "165480"
  },
  {
    "text": "values are masked that's 0 so it is secret and if kernel a is there all is",
    "start": "165480",
    "end": "171450"
  },
  {
    "text": "enabled the address of the function is change it per each boot so for example",
    "start": "171450",
    "end": "177720"
  },
  {
    "text": "on first boot those functions are located at ffff a a 0 a and on the",
    "start": "177720",
    "end": "185220"
  },
  {
    "text": "second boot the addresses are completely change it like it is located at BD 0 a",
    "start": "185220",
    "end": "190980"
  },
  {
    "text": "something yeah so therefore the attacker need to find the way to get the address value before",
    "start": "190980",
    "end": "198889"
  },
  {
    "text": "actually launching the attack and there is another example that shows kernel a",
    "start": "198889",
    "end": "205380"
  },
  {
    "start": "203000",
    "end": "203000"
  },
  {
    "text": "SR all may kernel exploit hotter in 2015 in the last year there was a privilege",
    "start": "205380",
    "end": "212669"
  },
  {
    "text": "escalation attack in Mac OS 10 called T pound and for the successful attack the",
    "start": "212669",
    "end": "219389"
  },
  {
    "text": "attacker exploited three different variabilities and of course the first",
    "start": "219389",
    "end": "224940"
  },
  {
    "text": "one is information leak vulnerability which discloses the layout of kernel memory to bypass the kernel layers are",
    "start": "224940",
    "end": "231959"
  },
  {
    "text": "all as a first tab in fact kernel a yes",
    "start": "231959",
    "end": "237120"
  },
  {
    "start": "235000",
    "end": "235000"
  },
  {
    "text": "are all is a statistical mitigation for memory corruption vulnerabilities such as buffer overflow or use after free and",
    "start": "237120",
    "end": "243889"
  },
  {
    "text": "the mechanism is very simple it shuffles the address of the code and data for",
    "start": "243889",
    "end": "249900"
  },
  {
    "text": "each time a boot or pair each load of the module or drivers and since it",
    "start": "249900",
    "end": "256049"
  },
  {
    "text": "randomizes the location of the code and data so the attacker need to figure out",
    "start": "256049",
    "end": "261750"
  },
  {
    "text": "the where the code is or where the data is to launch the successful attack",
    "start": "261750",
    "end": "267780"
  },
  {
    "text": "and it is very effective mitigation for example in Windows there are 8,000 over",
    "start": "267780",
    "end": "274170"
  },
  {
    "text": "8,000 locations the kernel can be located so the attackers success chance",
    "start": "274170",
    "end": "279240"
  },
  {
    "text": "is less than like a 1 over 8,000 as",
    "start": "279240",
    "end": "285450"
  },
  {
    "text": "shown on those examples the kernel is are all introduces the additional power",
    "start": "285450",
    "end": "290460"
  },
  {
    "text": "to the exploits so without currently as they're all attackers are only required to find a",
    "start": "290460",
    "end": "297450"
  },
  {
    "text": "memory verse the memory corruption vulnerability and then exploit it but",
    "start": "297450",
    "end": "302730"
  },
  {
    "text": "now they first need to find an information leak vulnerability to get the address value correctly then they",
    "start": "302730",
    "end": "309360"
  },
  {
    "text": "can success to exploit in short then now",
    "start": "309360",
    "end": "314400"
  },
  {
    "text": "the attackers are seeking for the information leak vulnerability to the successful memory corruption exploit",
    "start": "314400",
    "end": "322430"
  },
  {
    "text": "because of its effectiveness the modern operating systems have adopted kernel layer all it was",
    "start": "322430",
    "end": "329760"
  },
  {
    "text": "Microsoft Windows which one is the first to adopt kernel user all in 2007",
    "start": "329760",
    "end": "334890"
  },
  {
    "text": "starting from Windows Vista and then both OS 10 and iOS adopted it in 2012",
    "start": "334890",
    "end": "341220"
  },
  {
    "text": "which make a jailbreak more hotter and finally is push it into mainline Linux",
    "start": "341220",
    "end": "347090"
  },
  {
    "text": "kernel starting from version 3.14 in 2014 however in 2013 funda Edel",
    "start": "347090",
    "end": "358020"
  },
  {
    "text": "presented a very interesting work called practical timing side channel attack against kernel areas are all in Oakland",
    "start": "358020",
    "end": "365820"
  },
  {
    "text": "and the attack is the side channel attack caused by TLB cache in the",
    "start": "365820",
    "end": "371880"
  },
  {
    "text": "processor an important thing is that it is a hardware there at level attack so",
    "start": "371880",
    "end": "378300"
  },
  {
    "text": "no information leak vulnerability in the software is required to break kernel a",
    "start": "378300",
    "end": "383460"
  },
  {
    "text": "setup so which makes a kernel a SRL ineffective in their attack they use TLB",
    "start": "383460",
    "end": "392039"
  },
  {
    "start": "389000",
    "end": "389000"
  },
  {
    "text": "hit miss as a size channel so let's learn about that how the attack works by",
    "start": "392039",
    "end": "397830"
  },
  {
    "text": "example yeah so for first if we access a kernel address at",
    "start": "397830",
    "end": "403979"
  },
  {
    "text": "the user space what you get is regardless of its mapping status for an",
    "start": "403979",
    "end": "409800"
  },
  {
    "text": "M mapped page we get segmentation fault which is caused by page fault at processor because it is invalid address",
    "start": "409800",
    "end": "416580"
  },
  {
    "text": "and even if it is a map the address because we are in the ring three that",
    "start": "416580",
    "end": "422460"
  },
  {
    "text": "the address privileges in ring 0 so we get page fault so it turns out as a",
    "start": "422460",
    "end": "427680"
  },
  {
    "text": "segmentation fault at the user level so as a reducer level we cannot distinguish",
    "start": "427680",
    "end": "432689"
  },
  {
    "text": "which one is different yeah which one is what but internally the processor traits",
    "start": "432689",
    "end": "439650"
  },
  {
    "text": "that fault differently if it is in a",
    "start": "439650",
    "end": "444840"
  },
  {
    "text": "meta address then the reason for the fault is that it is just an invalid address so to check that the processor",
    "start": "444840",
    "end": "453389"
  },
  {
    "text": "is required to walk through the page table and then there is no page table entry so it generates page fault on the",
    "start": "453389",
    "end": "462139"
  },
  {
    "text": "other hand for the map to address the reason is different there is a page",
    "start": "462139",
    "end": "468240"
  },
  {
    "text": "table entry but its privileges ring 0 but we are in ring 3 so its",
    "start": "468240",
    "end": "474330"
  },
  {
    "text": "access violation to check that the processor is required to do the same",
    "start": "474330",
    "end": "479490"
  },
  {
    "text": "thing with a map page go through the page table work but different thing here",
    "start": "479490",
    "end": "484830"
  },
  {
    "text": "is there is a page table entry at the end then the processor catch it first",
    "start": "484830",
    "end": "490770"
  },
  {
    "text": "then try to compare the privilege then it generates page fault",
    "start": "490770",
    "end": "496199"
  },
  {
    "text": "so the different thing is that now it is cache it into TLB the caching here",
    "start": "496199",
    "end": "503099"
  },
  {
    "text": "creates fast and slow path that can be exploited as a timing channel for",
    "start": "503099",
    "end": "509189"
  },
  {
    "text": "example if the mapped address generated page fault the processor translate the",
    "start": "509189",
    "end": "514560"
  },
  {
    "text": "address and cache it to the TLB first so on the second axis it will be TLB hit so",
    "start": "514560",
    "end": "522479"
  },
  {
    "text": "map their address get the page fault more quicker than the a map page so in",
    "start": "522479",
    "end": "528449"
  },
  {
    "text": "contrast for the a map 1 it must go through like TLB miss",
    "start": "528449",
    "end": "534120"
  },
  {
    "text": "and memory access through the page table work then the processor can figure out",
    "start": "534120",
    "end": "539520"
  },
  {
    "text": "it is page fault so the difference in path having five more memory accesses",
    "start": "539520",
    "end": "545580"
  },
  {
    "text": "through the page table creates a timing difference around 40 cycles internally",
    "start": "545580",
    "end": "551670"
  },
  {
    "text": "in the CPU and exploiting this timing",
    "start": "551670",
    "end": "556800"
  },
  {
    "text": "channel can be done as follows in the example code we prepare the try except",
    "start": "556800",
    "end": "562710"
  },
  {
    "text": "block and exception handler in Microsoft Windows to catch the segmentation fault which is a page fault from the CPU and",
    "start": "562710",
    "end": "571310"
  },
  {
    "text": "inside a try clouds we mark timestamp first then intentionally generate page",
    "start": "571310",
    "end": "578130"
  },
  {
    "text": "fault by accessing kernel address inside there then the kernel the processor will",
    "start": "578130",
    "end": "585300"
  },
  {
    "text": "generate page fault them operating system will handle this fault then",
    "start": "585300",
    "end": "591029"
  },
  {
    "text": "finally it will call back our exception handler so at the exception handler we",
    "start": "591029",
    "end": "597600"
  },
  {
    "text": "mark timestamp again then we can measure the timing between the before accessing",
    "start": "597600",
    "end": "603000"
  },
  {
    "text": "the kernel address and then after the page fault happens by using this method",
    "start": "603000",
    "end": "610500"
  },
  {
    "text": "whom they ll result of that for a specific processor if a page fault -",
    "start": "610500",
    "end": "617010"
  },
  {
    "text": "less than certain threshold like a 4050 cycles then it will be a mapped address",
    "start": "617010",
    "end": "624650"
  },
  {
    "text": "so the figure on the right side is a graph from their paper and it seems",
    "start": "624650",
    "end": "631020"
  },
  {
    "text": "there is a tendency of lesser timing on the map pages on the bottom yeah however",
    "start": "631020",
    "end": "638730"
  },
  {
    "text": "we can see that the channel is quite noisy we can see lots of dots around the",
    "start": "638730",
    "end": "645240"
  },
  {
    "text": "4050 cycles so it is very hard to be clearly distinguishable",
    "start": "645240",
    "end": "650270"
  },
  {
    "text": "then why does this channel has much noise like that and let me break down",
    "start": "650270",
    "end": "657510"
  },
  {
    "text": "the timings about the current configuration so to measure with the",
    "start": "657510",
    "end": "664079"
  },
  {
    "text": "try-catch class try accept clouds we measure the timing on the user to the processor and there",
    "start": "664079",
    "end": "671490"
  },
  {
    "text": "will be TLB hit miss I channel and then there will be operating system exemption",
    "start": "671490",
    "end": "677010"
  },
  {
    "text": "handling routine and then it gets back to the users exception editor while we",
    "start": "677010",
    "end": "684000"
  },
  {
    "text": "measure the cycles around 4000 cycles the most of time is consumed by",
    "start": "684000",
    "end": "689070"
  },
  {
    "text": "operating system side and the lengthy execution on the operating system part",
    "start": "689070",
    "end": "695310"
  },
  {
    "text": "could suffer lots of noise because there could be like a scheduling interrupt or",
    "start": "695310",
    "end": "701040"
  },
  {
    "text": "other exceptions etc so it could suffer lots of noise and compared to the origin",
    "start": "701040",
    "end": "708750"
  },
  {
    "text": "of the decide channel while TLB hit miss just goes like a 440 cycles this noise",
    "start": "708750",
    "end": "716520"
  },
  {
    "text": "at the operating system is much more than that so it generates that it makes",
    "start": "716520",
    "end": "722250"
  },
  {
    "text": "the channel to be much noisy so there is a research question we come up with if",
    "start": "722250",
    "end": "730200"
  },
  {
    "text": "we can eliminate the noise from the operating system then the channel will be more stable and more accurate so can",
    "start": "730200",
    "end": "737970"
  },
  {
    "text": "you do that so on the next I will",
    "start": "737970",
    "end": "743040"
  },
  {
    "text": "present an attack core called DRK comes from d randomizing kernel a srl which",
    "start": "743040",
    "end": "749580"
  },
  {
    "text": "made a prior timing side channel attack to be more practical so in summary",
    "start": "749580",
    "end": "755520"
  },
  {
    "text": "Trk overcomes the noise of the prior attack and has better speed like a 5",
    "start": "755520",
    "end": "761460"
  },
  {
    "text": "seconds in Windows and 0.1 seconds in Linux with 100% accuracy and it's",
    "start": "761460",
    "end": "767940"
  },
  {
    "text": "covered because there's no operating system handling routine involved and it's precision is much better like it we",
    "start": "767940",
    "end": "775020"
  },
  {
    "text": "can also detect executable or non-executable page while the other the",
    "start": "775020",
    "end": "780090"
  },
  {
    "text": "prior attack cannot do and we make it like a very practical so we apply the",
    "start": "780090",
    "end": "785190"
  },
  {
    "text": "attack to all of the commodity operating system like Linux Windows and OS 10 and",
    "start": "785190",
    "end": "792380"
  },
  {
    "text": "the story of this attack begins in 2014 on surfing the web",
    "start": "792380",
    "end": "798990"
  },
  {
    "text": "we found the blog article written by famous hacker proper voice check that",
    "start": "798990",
    "end": "804570"
  },
  {
    "text": "says that until TSX can make this TLB size channel of Colonel a s are all less",
    "start": "804570",
    "end": "811020"
  },
  {
    "text": "noisy yeah and in the article it says with the P xx the access to the match",
    "start": "811020",
    "end": "820200"
  },
  {
    "start": "815000",
    "end": "815000"
  },
  {
    "text": "address returns fault in 1/72 cycle while the mapped address returns in 200",
    "start": "820200",
    "end": "827280"
  },
  {
    "text": "cycle so there's a 28 cycles of the timing channel but important thing is",
    "start": "827280",
    "end": "833340"
  },
  {
    "text": "that their standard deviation is only 0 to 2 which means if it is depicted there",
    "start": "833340",
    "end": "841500"
  },
  {
    "text": "is a channel with like a 28 cycles but the noise is like a zero to two cycles",
    "start": "841500",
    "end": "847680"
  },
  {
    "text": "so the noise is very small so it could be like it clearly can be clearly distinguishable like this in contrast",
    "start": "847680",
    "end": "856100"
  },
  {
    "text": "using a try except clouds it is measured right around 2000 cycles and channel",
    "start": "856100",
    "end": "863070"
  },
  {
    "text": "width is around 20 cycle but its standard deviation of the measuring time",
    "start": "863070",
    "end": "868350"
  },
  {
    "text": "is around thirty five to fifty seven cycles and it looks like while the",
    "start": "868350",
    "end": "874830"
  },
  {
    "text": "channel width is just 20 cycle its standard deviation is much more than that",
    "start": "874830",
    "end": "879960"
  },
  {
    "text": "so it suffers noise then what makes the",
    "start": "879960",
    "end": "885570"
  },
  {
    "text": "timing channel stable in tsx before",
    "start": "885570",
    "end": "890760"
  },
  {
    "start": "890000",
    "end": "890000"
  },
  {
    "text": "getting to the tsx directly let's cover the background on the Intel TSX TSX a",
    "start": "890760",
    "end": "898130"
  },
  {
    "text": "transactional synchronization extension is a new instruction set that helps",
    "start": "898130",
    "end": "903540"
  },
  {
    "text": "accessing data atomically without having traditional locks and for the audience",
    "start": "903540",
    "end": "910080"
  },
  {
    "text": "who might don't know about what is the traditional lock let's cover that first so in traditional lock to create an",
    "start": "910080",
    "end": "918390"
  },
  {
    "text": "atomic region the user need to acquire the thread acquire the lock and this",
    "start": "918390",
    "end": "925140"
  },
  {
    "text": "acquiring operation may be blocked if the other thread holds the same lock at",
    "start": "925140",
    "end": "930780"
  },
  {
    "text": "the same time yeah so thread will be waited until it the lock and after that if require is",
    "start": "930780",
    "end": "939170"
  },
  {
    "text": "successful then the atomic region can be executed and if log is successfully",
    "start": "939170",
    "end": "944750"
  },
  {
    "text": "acquired this atomic operation is guaranteed to be executed and then to to",
    "start": "944750",
    "end": "952160"
  },
  {
    "text": "let the other thread use the same mutex the thread need to release a lock after the atomic region has been finished good",
    "start": "952160",
    "end": "962480"
  },
  {
    "text": "thing after this lock is that it is guaranteed to be executed for the its atomic region however draw a drawback of",
    "start": "962480",
    "end": "970790"
  },
  {
    "text": "this approach is it is slow because a threat need to be blocked and wait for",
    "start": "970790",
    "end": "977420"
  },
  {
    "text": "dia the other thread release the lock and it creates problem like deadlock if",
    "start": "977420",
    "end": "983510"
  },
  {
    "text": "the programmer did not carefully use your login lock correctly so TSX",
    "start": "983510",
    "end": "991250"
  },
  {
    "text": "is introduced to resolve such drawback of the traditional locks its usage is",
    "start": "991250",
    "end": "997310"
  },
  {
    "text": "very similar but yeah it's quite different so so calling X begin is",
    "start": "997310",
    "end": "1004510"
  },
  {
    "text": "actually similar to like a acquiring lock but at this time there is no lock",
    "start": "1004510",
    "end": "1010000"
  },
  {
    "text": "at all so it does not wait then it tries to execute atomic region so it just try but",
    "start": "1010000",
    "end": "1019090"
  },
  {
    "text": "it could fail if there's another thread on working on the same data or if there",
    "start": "1019090",
    "end": "1024160"
  },
  {
    "text": "is another exception it could fail so it has an exception handler at the end so",
    "start": "1024160",
    "end": "1030160"
  },
  {
    "text": "if the atomic region successfully committed then it lets through the",
    "start": "1030160",
    "end": "1035170"
  },
  {
    "text": "thread runs but if it failed it let the programmer to handle that in different",
    "start": "1035170",
    "end": "1040630"
  },
  {
    "text": "way so in that case programmer get back to guaranteed execution with the traditional log or they can try the tsx",
    "start": "1040630",
    "end": "1048550"
  },
  {
    "text": "again to after resolving the data threat races or something and there are several",
    "start": "1048550",
    "end": "1056980"
  },
  {
    "text": "reasons that TSX can fail of course the definite reason is that if there is a",
    "start": "1056980",
    "end": "1062830"
  },
  {
    "text": "thread races it will fail and in addition to that if there is a cache",
    "start": "1062830",
    "end": "1067840"
  },
  {
    "text": "eviction or in trap it will be fail and more importantly it will fail if there's a",
    "start": "1067840",
    "end": "1075010"
  },
  {
    "text": "page bolt happens and we are very interested in page fold because in the",
    "start": "1075010",
    "end": "1081040"
  },
  {
    "text": "timing side channel attack we are looking for that and another important",
    "start": "1081040",
    "end": "1087670"
  },
  {
    "start": "1086000",
    "end": "1086000"
  },
  {
    "text": "part of tsx support is if an exception like page fold happens in the TX s",
    "start": "1087670",
    "end": "1093520"
  },
  {
    "text": "region the processor suppress all the exception it does not send the exception",
    "start": "1093520",
    "end": "1099280"
  },
  {
    "text": "to the operating system instead it directly calls the abort emulator in the",
    "start": "1099280",
    "end": "1104410"
  },
  {
    "text": "user level so this makes the exception have to be differ with the try except in",
    "start": "1104410",
    "end": "1112240"
  },
  {
    "text": "case of try except the processor generated exception and it goes to the",
    "start": "1112240",
    "end": "1117340"
  },
  {
    "text": "operating system then it gets back to the user code however with TS x the",
    "start": "1117340",
    "end": "1123940"
  },
  {
    "text": "processor directly calls the of our tender so there will be no exception",
    "start": "1123940",
    "end": "1129520"
  },
  {
    "text": "delivery to the operating system it returns quicker and do not suffer noise from the operating system and",
    "start": "1129520",
    "end": "1138090"
  },
  {
    "text": "using TS x to catch this timing is very similar to the using try except so we",
    "start": "1138090",
    "end": "1145480"
  },
  {
    "text": "can use following code to check the timing so before invoking TS x region we",
    "start": "1145480",
    "end": "1152440"
  },
  {
    "text": "can get the timestamp by calling our DTS CP and then we try to access a kernel",
    "start": "1152440",
    "end": "1159100"
  },
  {
    "text": "address inside of TS x region which will be always fail then the processor will",
    "start": "1159100",
    "end": "1165670"
  },
  {
    "text": "call the abort handler so we measure the timing before getting into TS x region",
    "start": "1165670",
    "end": "1171280"
  },
  {
    "text": "and at the abort handler to measure the timing for the page fault and the timing",
    "start": "1171280",
    "end": "1178720"
  },
  {
    "start": "1178000",
    "end": "1178000"
  },
  {
    "text": "breakdown will be like following so previously we measure the timing like a 4000 cycles including operating system",
    "start": "1178720",
    "end": "1185830"
  },
  {
    "text": "exception handling but in PS x there is no operating system involved in the path so it'll be much",
    "start": "1185830",
    "end": "1193180"
  },
  {
    "text": "faster so what we measure it is around 180 cycles while the timing side channel",
    "start": "1193180",
    "end": "1199180"
  },
  {
    "text": "is 40 cycles and also there is no operating system noise at all and with using this",
    "start": "1199180",
    "end": "1208840"
  },
  {
    "start": "1207000",
    "end": "1207000"
  },
  {
    "text": "method we try to measure the timings of Paige folder map and the map kernel address and what if scene is like for",
    "start": "1208840",
    "end": "1216340"
  },
  {
    "text": "having a read access to a kernel address the mapped address always returns in",
    "start": "1216340",
    "end": "1221620"
  },
  {
    "text": "fast in the CPU cycles and in addition",
    "start": "1221620",
    "end": "1227290"
  },
  {
    "text": "we try to attempt to jump into the kernel address which means the execution axis it definitely failed because we",
    "start": "1227290",
    "end": "1235810"
  },
  {
    "text": "have no privilege but what we measure that for the timing is that executable",
    "start": "1235810",
    "end": "1240910"
  },
  {
    "text": "address is always written faster than the non-executable one and for the next",
    "start": "1240910",
    "end": "1247780"
  },
  {
    "text": "I will show you the live demo on how this attack works on the linux and let's",
    "start": "1247780",
    "end": "1255790"
  },
  {
    "text": "get into terminal excuse me",
    "start": "1255790",
    "end": "1264060"
  },
  {
    "text": "this problem with the internet connection so yes",
    "start": "1271950",
    "end": "1278299"
  },
  {
    "text": "I can try again",
    "start": "1284290",
    "end": "1287460"
  },
  {
    "text": "yeah it works yeah",
    "start": "1296030",
    "end": "1301150"
  },
  {
    "text": "first let's check the system status so try to do you name - a to check the",
    "start": "1301669",
    "end": "1308179"
  },
  {
    "text": "Linux version so it runs Linux for point 4.0 kernel and in its boot argument Kas",
    "start": "1308179",
    "end": "1316070"
  },
  {
    "text": "are all the kernel a srl is enabled and for the processor information it runs",
    "start": "1316070",
    "end": "1322609"
  },
  {
    "text": "with the Intel Core i5 6300 HQ processor which is skylake the latest one and in",
    "start": "1322609",
    "end": "1330349"
  },
  {
    "text": "the CPU ID there is a flag RT M which indicates that is enabled with TSX and",
    "start": "1330349",
    "end": "1338559"
  },
  {
    "text": "let's measure the timing so first we will try to read on the map address and",
    "start": "1338559",
    "end": "1345679"
  },
  {
    "text": "I just pick the just arbitrary address that it is always a map one in Linux and",
    "start": "1345679",
    "end": "1352419"
  },
  {
    "text": "try to read on this address returns like 190 or 188 cycles and then let's measure",
    "start": "1352419",
    "end": "1362899"
  },
  {
    "text": "the mapped address so to get a ground truth information we use a root",
    "start": "1362899",
    "end": "1368359"
  },
  {
    "text": "permission to get the kernel symbol from string tab which is read on the address and measuring this map and map the",
    "start": "1368359",
    "end": "1375320"
  },
  {
    "text": "address returns right 166 so you can",
    "start": "1375320",
    "end": "1381079"
  },
  {
    "text": "easily see that the forum mapped address it took like 166 to 170 while foreign",
    "start": "1381079",
    "end": "1388099"
  },
  {
    "text": "for the unmapped address and always take like a 188 or 190 so we can see that",
    "start": "1388099",
    "end": "1393979"
  },
  {
    "text": "exact timing difference and then next is trying to launch execution access to the",
    "start": "1393979",
    "end": "1402320"
  },
  {
    "text": "address for the a mapped one it took like 178 cycles or 176 cycles and for",
    "start": "1402320",
    "end": "1412190"
  },
  {
    "text": "the map but non-executable address it tooks same like 176 but for the",
    "start": "1412190",
    "end": "1420829"
  },
  {
    "text": "executable address so I just get the address of the commit crate which is a kernel function and measuring the",
    "start": "1420829",
    "end": "1428629"
  },
  {
    "text": "execution page fault on this it turns like 140 to one for",
    "start": "1428629",
    "end": "1434060"
  },
  {
    "text": "six so we can easily distinguish executable page from the others by",
    "start": "1434060",
    "end": "1440870"
  },
  {
    "text": "measuring timing like if it is a 140 something then it definitely uh excu",
    "start": "1440870",
    "end": "1446660"
  },
  {
    "text": "table pages and we conducted this",
    "start": "1446660",
    "end": "1457100"
  },
  {
    "text": "experiment on four different processors across three different architectures",
    "start": "1457100",
    "end": "1462320"
  },
  {
    "text": "Intel's Haswell Broadwell and skylight and from all of the processor we can see",
    "start": "1462320",
    "end": "1469490"
  },
  {
    "text": "that clear timing difference it's always mapped page returns fault faster than a",
    "start": "1469490",
    "end": "1474830"
  },
  {
    "text": "map one and on accessing executable and",
    "start": "1474830",
    "end": "1480050"
  },
  {
    "text": "non-executable address we can also see that executable address always returns faster than non-executable one and this",
    "start": "1480050",
    "end": "1491030"
  },
  {
    "text": "is a graph of the what we get from the attacking the linux kernel module space and we measure the timing per each page",
    "start": "1491030",
    "end": "1498470"
  },
  {
    "text": "and it shows that the it clearly separates out mapped in a map page and",
    "start": "1498470",
    "end": "1506210"
  },
  {
    "text": "executable and non-executable page and there is a clusters and between the",
    "start": "1506210",
    "end": "1512420"
  },
  {
    "text": "clusters we cannot even see any dots it means it's noise is very small and we",
    "start": "1512420",
    "end": "1519140"
  },
  {
    "text": "can easily distinguish page mappings by the timings and let's compare this with",
    "start": "1519140",
    "end": "1525860"
  },
  {
    "text": "prior attacks the prior textures lots of noise in the in the threshold area but",
    "start": "1525860",
    "end": "1532130"
  },
  {
    "text": "DRK does not suffer that kind of noise and we launched it DRK attack to the",
    "start": "1532130",
    "end": "1541280"
  },
  {
    "text": "various operating systems since DRK is a hardware level attack it is naturally",
    "start": "1541280",
    "end": "1548090"
  },
  {
    "text": "operating system independent so we target all popular operating systems",
    "start": "1548090",
    "end": "1553220"
  },
  {
    "text": "like Linux Windows and OS 10 and for the operating systems we launched two types",
    "start": "1553220",
    "end": "1559520"
  },
  {
    "text": "of the data of the attack so the first attack is that try to find",
    "start": "1559520",
    "end": "1566060"
  },
  {
    "text": "the kernel and module area and try to measure the permission of the each page so whether you do on the tag",
    "start": "1566060",
    "end": "1574519"
  },
  {
    "text": "is first to find the kernel ASRs slide then try to measure that all the pages",
    "start": "1574519",
    "end": "1580519"
  },
  {
    "text": "of the kernel then move to the modules area and do the same thing then we will",
    "start": "1580519",
    "end": "1588769"
  },
  {
    "text": "get the map like this like a four address range we can determine that it",
    "start": "1588769",
    "end": "1593960"
  },
  {
    "text": "is a map executable or not excusable which is what page table has and then we",
    "start": "1593960",
    "end": "1602240"
  },
  {
    "text": "will get the ground truth information extracted by a kernel page table and try",
    "start": "1602240",
    "end": "1607490"
  },
  {
    "text": "to compare to calculate the accuracy of the attack and after having this kind of",
    "start": "1607490",
    "end": "1615019"
  },
  {
    "text": "the page table information then we will do the like a type two attack it is",
    "start": "1615019",
    "end": "1622130"
  },
  {
    "text": "detecting the modules exact locations and an interesting observation is that",
    "start": "1622130",
    "end": "1628429"
  },
  {
    "text": "on both Linux and Windows a module and Driver are always allocated with the",
    "start": "1628429",
    "end": "1634820"
  },
  {
    "text": "fixed size of the sections for the sum of the sections in the binary so if we can get the binary and take a look into",
    "start": "1634820",
    "end": "1642559"
  },
  {
    "text": "their non-executable executable sections then we can easily create the size based",
    "start": "1642559",
    "end": "1647809"
  },
  {
    "text": "signatures so for example in the first entry leap ahci",
    "start": "1647809",
    "end": "1654110"
  },
  {
    "text": "has four thousand size for the executable and four thousand sides for the non-excludable area so if if some of",
    "start": "1654110",
    "end": "1662690"
  },
  {
    "text": "the module has like a four thousand on x four thousand and NX then it will be leap ahci",
    "start": "1662690",
    "end": "1668720"
  },
  {
    "text": "so we also run this kind of attack to figure out where they look the location",
    "start": "1668720",
    "end": "1675380"
  },
  {
    "text": "of the kernel module so for attacking Linux we target the same processor I",
    "start": "1675380",
    "end": "1682460"
  },
  {
    "text": "just show the demo the core i5 and running Linux kernel for point four and",
    "start": "1682460",
    "end": "1688929"
  },
  {
    "text": "let's see the full attack demo on the Linux",
    "start": "1688929",
    "end": "1694330"
  },
  {
    "start": "1689000",
    "end": "1689000"
  },
  {
    "text": "so the attack is really quick so please be careful so attack is finish it and",
    "start": "1702410",
    "end": "1709730"
  },
  {
    "text": "let's take a look into the reserve so what it first do is that try to measure",
    "start": "1709730",
    "end": "1715820"
  },
  {
    "text": "the threshold for the map the address and executable address and to do that at",
    "start": "1715820",
    "end": "1721220"
  },
  {
    "text": "this time we don't have any knowledge we assumes that we have no knowledge about the kernel so we just use null page for",
    "start": "1721220",
    "end": "1728840"
  },
  {
    "text": "the simulating unmapped one and having a read-only page and try to do write",
    "start": "1728840",
    "end": "1734060"
  },
  {
    "text": "access to generate page fold and simulate the map page and for having",
    "start": "1734060",
    "end": "1740450"
  },
  {
    "text": "threshold for the executable one we map the non-excludable page on the user space and try to jump it to measure the",
    "start": "1740450",
    "end": "1747050"
  },
  {
    "text": "timing and also jumps into the executable but invalid instructions to",
    "start": "1747050",
    "end": "1753380"
  },
  {
    "text": "generate the page fold internally to measure the timing for excusable pages and then we try to scan all the kernel",
    "start": "1753380",
    "end": "1762560"
  },
  {
    "text": "layer address to find the kernel ASRs slide and finding that region just to",
    "start": "1762560",
    "end": "1769340"
  },
  {
    "text": "like a seven millisecond is very fast and do the same thing on the modular",
    "start": "1769340",
    "end": "1774590"
  },
  {
    "text": "area it tooks like eleven second milliseconds and then go through the all",
    "start": "1774590",
    "end": "1780170"
  },
  {
    "text": "each page like each four kilobyte page to measure the permission of the each page and we measured like around over",
    "start": "1780170",
    "end": "1788960"
  },
  {
    "text": "six thousand pages and it only takes 92 milliseconds which is less than 0.1",
    "start": "1788960",
    "end": "1795530"
  },
  {
    "text": "second to break kernel layers are all in the linux and then we try to grab the",
    "start": "1795530",
    "end": "1802280"
  },
  {
    "text": "ground truth information from the page table and try to compare the permissions and for the all pages we achieve the",
    "start": "1802280",
    "end": "1810040"
  },
  {
    "text": "100% accuracy so yet the reserves from DRK is actually exactly match it with",
    "start": "1810040",
    "end": "1816230"
  },
  {
    "text": "the reserves from the page table and for the type to attack we successfully",
    "start": "1816230",
    "end": "1822200"
  },
  {
    "text": "detected 38 unique size signature yeah and then we can identify that the 38",
    "start": "1822200",
    "end": "1829670"
  },
  {
    "text": "modules on the module space and for the details",
    "start": "1829670",
    "end": "1835820"
  },
  {
    "text": "take a look into the actual mappings so on the left side the result is generated",
    "start": "1835820",
    "end": "1843410"
  },
  {
    "text": "by dr k and on the right side it is from the information is extracted from the",
    "start": "1843410",
    "end": "1848570"
  },
  {
    "text": "kernel page table and it is just a beam diff so if it is something is marketing",
    "start": "1848570",
    "end": "1854090"
  },
  {
    "text": "in red that means it is different so and please focus on to this address and",
    "start": "1854090",
    "end": "1861280"
  },
  {
    "text": "permission part so I will move down you cannot see any kind of red mark on the",
    "start": "1861280",
    "end": "1868250"
  },
  {
    "text": "address or permissions so Trk can get exact mappings and exact",
    "start": "1868250",
    "end": "1873530"
  },
  {
    "text": "address information as same as page table through the attack and another",
    "start": "1873530",
    "end": "1879590"
  },
  {
    "text": "interesting point is that we can detect that address of the module correctly and",
    "start": "1879590",
    "end": "1885340"
  },
  {
    "text": "for some of the modules like for this a ACP iPad and mem stick there sighs",
    "start": "1885340",
    "end": "1892970"
  },
  {
    "text": "signature is not unique so we could find there are two more or two or more but at",
    "start": "1892970",
    "end": "1898400"
  },
  {
    "text": "least we can reduce down the candidates into two yeah so we can successfully",
    "start": "1898400",
    "end": "1905000"
  },
  {
    "text": "detect the exact location of the modules",
    "start": "1905000",
    "end": "1909580"
  },
  {
    "text": "so the attack in Linux we achieved 100% accuracy for across three different",
    "start": "1916950",
    "end": "1922989"
  },
  {
    "text": "processors and it took around 0.1 or 0.6 seconds for probing over 6,000 pages and",
    "start": "1922989",
    "end": "1931139"
  },
  {
    "text": "for detecting modules we can uniquely detect like a thirty eight modules among",
    "start": "1931139",
    "end": "1937089"
  },
  {
    "text": "the 105 modules by the size signature and we also did attack on the windows",
    "start": "1937089",
    "end": "1944649"
  },
  {
    "start": "1942000",
    "end": "1942000"
  },
  {
    "text": "for the latest version of the Windows 10 and the result is that we could achieve",
    "start": "1944649",
    "end": "1950729"
  },
  {
    "text": "100% accuracy for the kernel and 100% accuracy for detecting map and a map for",
    "start": "1950729",
    "end": "1958119"
  },
  {
    "text": "the drivers address space but we cannot achieve 100% for the drivers it was",
    "start": "1958119",
    "end": "1965529"
  },
  {
    "text": "ninety point ninety nine point twenty eight a close to the one hundred percent and the reason behind here is that in",
    "start": "1965529",
    "end": "1972309"
  },
  {
    "text": "the windows drivers has some of the memory area that can be dynamically D",
    "start": "1972309",
    "end": "1978549"
  },
  {
    "text": "allocated or changed permission so at the time of attack we correctly measure",
    "start": "1978549",
    "end": "1984219"
  },
  {
    "text": "the timing but later it could be changed by the driver works something else so",
    "start": "1984219",
    "end": "1990159"
  },
  {
    "text": "and in addition tsx has inherited a limitation that if the page is marked as",
    "start": "1990159",
    "end": "1996580"
  },
  {
    "text": "an inactive we cannot measure the timings yeah so we miss some of them but",
    "start": "1996580",
    "end": "2001979"
  },
  {
    "text": "still it is over 99% and for detecting modules we could detect much more than",
    "start": "2001979",
    "end": "2008849"
  },
  {
    "text": "Linux because sighs various variants in the windows is a much more than Linux so",
    "start": "2008849",
    "end": "2014309"
  },
  {
    "text": "we could detect 97 drivers among the 141 drivers and for OS 10 we",
    "start": "2014309",
    "end": "2021659"
  },
  {
    "start": "2019000",
    "end": "2019000"
  },
  {
    "text": "launched it on the elcapitan and we just did like a finding a srl slide on the OS",
    "start": "2021659",
    "end": "2028229"
  },
  {
    "text": "10 and we do it for 10 times and average speed is like 31 milliseconds which will",
    "start": "2028229",
    "end": "2035999"
  },
  {
    "text": "be very practical to be used in the kernel exploit and another interesting",
    "start": "2035999",
    "end": "2041789"
  },
  {
    "start": "2040000",
    "end": "2040000"
  },
  {
    "text": "point is that if DRK also works on the cloud environment recently amazon ec2",
    "start": "2041789",
    "end": "2049260"
  },
  {
    "text": "launched the new instance called x1 which support Intel TSX so we do the same attack on",
    "start": "2049260",
    "end": "2057389"
  },
  {
    "text": "the Linux by having an instance with Ubuntu 1404 and the result is that it",
    "start": "2057390",
    "end": "2063179"
  },
  {
    "text": "was same like getting 100% accuracy but little bit more time yeah so the summary",
    "start": "2063179",
    "end": "2071610"
  },
  {
    "start": "2070000",
    "end": "2070000"
  },
  {
    "text": "of research is like in the Linux Windows and OS 10 we all get 100% accuracy of",
    "start": "2071610",
    "end": "2077970"
  },
  {
    "text": "the page mappings and it is very fast to be applied to like a breaking kernel",
    "start": "2077970",
    "end": "2085020"
  },
  {
    "text": "layer all for the real exploits excuse me",
    "start": "2085020",
    "end": "2091039"
  },
  {
    "start": "2095000",
    "end": "2095000"
  },
  {
    "text": "nexus analysis let's figure out why this timing channel happens and where is the",
    "start": "2095820",
    "end": "2102690"
  },
  {
    "text": "origin of the timing channel the first part is that the analyzing map and then",
    "start": "2102690",
    "end": "2108360"
  },
  {
    "text": "math address so whom do L previously hypothesized that the origin of this",
    "start": "2108360",
    "end": "2114930"
  },
  {
    "text": "Simon channel is TLB to figure out that the best way is take a look into the",
    "start": "2114930",
    "end": "2122280"
  },
  {
    "text": "processor but it is very hard so in the Intel CPU it is marked as an Intel",
    "start": "2122280",
    "end": "2127440"
  },
  {
    "text": "confidential so we cannot take a look into that but although it is somewhat",
    "start": "2127440",
    "end": "2134010"
  },
  {
    "text": "black box we ran the experiment that indirectly let us know the internals of",
    "start": "2134010",
    "end": "2140160"
  },
  {
    "text": "the processor so we probe the both mapped and a map",
    "start": "2140160",
    "end": "2145560"
  },
  {
    "text": "page and at the same for 1 million times and at the same time we measure the",
    "start": "2145560",
    "end": "2151770"
  },
  {
    "text": "performance counter up data TLB hit miss and result is shown on the screen and",
    "start": "2151770",
    "end": "2158750"
  },
  {
    "text": "interesting thing is that D TLB miss happens only 84 times for the mapped one",
    "start": "2158750",
    "end": "2166080"
  },
  {
    "text": "while a map one has a 2 million T TLB miss so it looks like the D TLB is",
    "start": "2166080",
    "end": "2173160"
  },
  {
    "text": "definitely the reason for the side channel and following is a diagram that",
    "start": "2173160",
    "end": "2179370"
  },
  {
    "start": "2177000",
    "end": "2177000"
  },
  {
    "text": "shows the size channel how size channel works internal internally in the processor",
    "start": "2179370",
    "end": "2184470"
  },
  {
    "text": "on the first access of the map page it will be TLB miss and go through the page",
    "start": "2184470",
    "end": "2191609"
  },
  {
    "text": "table then it will generate page fault and even for the second axis there is no",
    "start": "2191609",
    "end": "2199230"
  },
  {
    "text": "entry to be cache so it goes through the page table again get page fault so it",
    "start": "2199230",
    "end": "2205380"
  },
  {
    "text": "always goes to the page fault so it is slow and for a map the address path for",
    "start": "2205380",
    "end": "2213900"
  },
  {
    "text": "matters is differs on the second axis for the first access it miss on TLB goes",
    "start": "2213900",
    "end": "2222089"
  },
  {
    "text": "through the page table then cache TLB here then generate page fault so on the",
    "start": "2222089",
    "end": "2229109"
  },
  {
    "text": "first it took slow path on the subsequent axis now D TLB hits and",
    "start": "2229109",
    "end": "2237380"
  },
  {
    "text": "generate page fault so there is no page table walk on the second axis so it",
    "start": "2237380",
    "end": "2244230"
  },
  {
    "text": "returns faster yeah and in summary D TLB",
    "start": "2244230",
    "end": "2250170"
  },
  {
    "text": "hit miss determines that whether the page table walk is required or not so",
    "start": "2250170",
    "end": "2255510"
  },
  {
    "text": "that generates a side channel so it always faster on written map the address",
    "start": "2255510",
    "end": "2261300"
  },
  {
    "text": "for the measuring the page fault and next is the size channel for executable",
    "start": "2261300",
    "end": "2268920"
  },
  {
    "text": "and non-executable address and at this time we measure the hit miss counter of",
    "start": "2268920",
    "end": "2275010"
  },
  {
    "text": "the itlp because is a we try to execute so we measure the instruction TLB for 1",
    "start": "2275010",
    "end": "2282630"
  },
  {
    "text": "million time of probing and the first point take a look is I TLB hits on the",
    "start": "2282630",
    "end": "2291300"
  },
  {
    "text": "map page so there is only 12 misses on 1 million prov so I TLB actually hits but",
    "start": "2291300",
    "end": "2299970"
  },
  {
    "text": "the weird thing is that the timing for the map page is actually same with the",
    "start": "2299970",
    "end": "2305430"
  },
  {
    "text": "Matt one so it does not took the fast path why yeah it's quite weird so we",
    "start": "2305430",
    "end": "2313829"
  },
  {
    "text": "think that I TLB is the not the origin of this I channel in the executable and non-executable",
    "start": "2313829",
    "end": "2319500"
  },
  {
    "text": "addresses and the second point to focus is there is not even TLB hit on",
    "start": "2319500",
    "end": "2328130"
  },
  {
    "text": "accessing executable address so TLB hit count is around 590 among the 101",
    "start": "2328130",
    "end": "2336900"
  },
  {
    "text": "million prof so there will be no Tina so the TLB is not even access it on",
    "start": "2336900",
    "end": "2343280"
  },
  {
    "text": "accessing kernel address as a executable way so we think that I TLB is not even",
    "start": "2343280",
    "end": "2352230"
  },
  {
    "text": "involved in the fast path then what will",
    "start": "2352230",
    "end": "2357720"
  },
  {
    "text": "be the reason and we try to find several documents and informations on the",
    "start": "2357720",
    "end": "2364650"
  },
  {
    "start": "2360000",
    "end": "2360000"
  },
  {
    "text": "internals of inter architecture and luckily we found a patent that is",
    "start": "2364650",
    "end": "2370320"
  },
  {
    "text": "registered by Intel Corporation in 2010 that could be a hint for the dis",
    "start": "2370320",
    "end": "2375690"
  },
  {
    "text": "phenomena for the instruction cache there will be two caches in the",
    "start": "2375690",
    "end": "2381300"
  },
  {
    "text": "processor one is l1 I cache and it is virtually indexed and physically tagged",
    "start": "2381300",
    "end": "2387810"
  },
  {
    "text": "which means it requires address translation to retrieve the cache so in",
    "start": "2387810",
    "end": "2394350"
  },
  {
    "text": "the figure there is a TLB and this at the center yeah so it requires TLB translations to",
    "start": "2394350",
    "end": "2400860"
  },
  {
    "text": "access the cache and another one is called decoded I cache also known as my",
    "start": "2400860",
    "end": "2408450"
  },
  {
    "text": "crop cache while l1 instruction cache just towards the opcode of x86 or AMD 64",
    "start": "2408450",
    "end": "2415980"
  },
  {
    "text": "instructions this micro co-op cache stores decoded this instruction",
    "start": "2415980",
    "end": "2422520"
  },
  {
    "text": "something like RISC like instructions an important thing is that it is virtually",
    "start": "2422520",
    "end": "2429870"
  },
  {
    "text": "indexed virtually tagged cache so it does not require accessing to the TLB",
    "start": "2429870",
    "end": "2436910"
  },
  {
    "text": "now and I will describe how this creates timings I channel in the following for",
    "start": "2436910",
    "end": "2445920"
  },
  {
    "text": "the map page it will do the same thing like I TLB miss go to the page table",
    "start": "2445920",
    "end": "2451500"
  },
  {
    "text": "work H fold so it always takes slow path it is slow and for the executable page",
    "start": "2451500",
    "end": "2459590"
  },
  {
    "start": "2458000",
    "end": "2458000"
  },
  {
    "text": "first it miss on decoded I cache miss on TLB go through the page table cache on",
    "start": "2459590",
    "end": "2467760"
  },
  {
    "text": "i.t LV and also cache it on the decoded I cache then fault",
    "start": "2467760",
    "end": "2473430"
  },
  {
    "text": "and on the subsequent access now it hits",
    "start": "2473430",
    "end": "2478980"
  },
  {
    "text": "on the decoded I cache so it falls faster then let's take a look for the",
    "start": "2478980",
    "end": "2487430"
  },
  {
    "text": "since there's no TLB access no page table work so it is on the fast path and",
    "start": "2487430",
    "end": "2495020"
  },
  {
    "text": "next is analyzing how the non-executable but map page works with this type of",
    "start": "2495020",
    "end": "2502200"
  },
  {
    "start": "2496000",
    "end": "2496000"
  },
  {
    "text": "access so it will miss on the decoded I cache miss on the TLB first then page",
    "start": "2502200",
    "end": "2509820"
  },
  {
    "text": "fault a cache on the itlp then page fold on the first axis and on",
    "start": "2509820",
    "end": "2515970"
  },
  {
    "text": "the second access now miss on the decoded I cache but hit on i.t LV but",
    "start": "2515970",
    "end": "2523580"
  },
  {
    "text": "would the processor generate fault adhere if it is it should manifest",
    "start": "2523580",
    "end": "2530310"
  },
  {
    "text": "faster timing than the matte one so it is not and we can find the reason from",
    "start": "2530310",
    "end": "2539490"
  },
  {
    "text": "the reason of the this why it cannot return page fault at the TLB hit from",
    "start": "2539490",
    "end": "2546240"
  },
  {
    "start": "2546000",
    "end": "2546000"
  },
  {
    "text": "cache coherence mechanism in TLB in the Intel Architecture TLB is not a coherent",
    "start": "2546240",
    "end": "2553680"
  },
  {
    "text": "cache what it means is that there is no mechanism to synchronize the cache among",
    "start": "2553680",
    "end": "2560340"
  },
  {
    "text": "the multiple cores in the processor and let's take an example let's say there's",
    "start": "2560340",
    "end": "2567030"
  },
  {
    "text": "a one core and it sets some address as an onyx cutable and then in the meantime",
    "start": "2567030",
    "end": "2573620"
  },
  {
    "text": "core to can set the same address as an executable so in the page table it was",
    "start": "2573620",
    "end": "2580800"
  },
  {
    "text": "marked as executable but there's no coherency so",
    "start": "2580800",
    "end": "2585930"
  },
  {
    "text": "no information will be delivered to the core one so core one do not update or invalidate their TLB entry and next when",
    "start": "2585930",
    "end": "2595980"
  },
  {
    "text": "core 1 try to execute that address it says TLV says it is non-excludable but",
    "start": "2595980",
    "end": "2603359"
  },
  {
    "text": "there is a possibility that core 2 has updated the page table so in such case",
    "start": "2603359",
    "end": "2609930"
  },
  {
    "text": "core 1 is required to walk through the page table and identify that what is the",
    "start": "2609930",
    "end": "2616829"
  },
  {
    "text": "correct permission then determine default so the correct path will be like",
    "start": "2616829",
    "end": "2623819"
  },
  {
    "text": "following on the subsequent axis TLB will hit but it says it is",
    "start": "2623819",
    "end": "2630240"
  },
  {
    "text": "non-excludable so the processor need to go through the page table work then retrieve the entry",
    "start": "2630240",
    "end": "2637470"
  },
  {
    "text": "and it is still non-excludable then finally it will generate page fault in",
    "start": "2637470",
    "end": "2645800"
  },
  {
    "text": "summary for the executable address it hits on the I decoded I cache so it'll",
    "start": "2645800",
    "end": "2652859"
  },
  {
    "text": "always gets the fast path but for the non-executable page even if I TLB got",
    "start": "2652859",
    "end": "2659430"
  },
  {
    "text": "hit in it need to go through the page table walk again then it can get the",
    "start": "2659430",
    "end": "2664589"
  },
  {
    "text": "page fault and for the a map 1 it always go to the page fault up a page table",
    "start": "2664589",
    "end": "2670559"
  },
  {
    "text": "work to determine the fault so for the slow path this day requires a page table",
    "start": "2670559",
    "end": "2677010"
  },
  {
    "text": "so they returns so all the time then executable address and next is",
    "start": "2677010",
    "end": "2685200"
  },
  {
    "start": "2683000",
    "end": "2683000"
  },
  {
    "text": "discussions of this attack so the attack with tsx is not 100% noise free so there",
    "start": "2685200",
    "end": "2693299"
  },
  {
    "text": "is a some of the tweaks that make a noise lesser than the noise lesser so",
    "start": "2693299",
    "end": "2699540"
  },
  {
    "text": "and one point is that since we measure the clock cycles so the dynamic",
    "start": "2699540",
    "end": "2705480"
  },
  {
    "text": "frequency scaling such as speed step and turbo boost can change the timing of the",
    "start": "2705480",
    "end": "2711109"
  },
  {
    "text": "decide channel and to the successful attack we need to make that that",
    "start": "2711109",
    "end": "2717569"
  },
  {
    "text": "processors frequency to be stable and won the easy way to achieve",
    "start": "2717569",
    "end": "2722910"
  },
  {
    "text": "this is that just run a while loop and with like one or two wire loops the it",
    "start": "2722910",
    "end": "2729780"
  },
  {
    "text": "makes the processor runs as a full speed and we can get the stable clock as a max",
    "start": "2729780",
    "end": "2734970"
  },
  {
    "text": "speed in that case we can easily get the timing correctly and another thing that",
    "start": "2734970",
    "end": "2741329"
  },
  {
    "text": "affects on the tsx is that some of the hardware interrupts like a timer interrupts or i/o interrupts can abort",
    "start": "2741329",
    "end": "2748619"
  },
  {
    "text": "the TXS other than the page fold if it happens we could get some more timings",
    "start": "2748619",
    "end": "2753960"
  },
  {
    "text": "even if it is on the fast path and to avoid that what it can do is like",
    "start": "2753960",
    "end": "2759750"
  },
  {
    "text": "theoretically side-channel cache side-channel works on two products but we can enlarge the number of the",
    "start": "2759750",
    "end": "2766260"
  },
  {
    "text": "iterations like having a multiple probe like 100 times it makes the attack more stable and",
    "start": "2766260",
    "end": "2773480"
  },
  {
    "text": "another thing is that benefits of DRK attack so it has less noise and also all",
    "start": "2773480",
    "end": "2781770"
  },
  {
    "text": "the exceptions are suppressed so operating system never see the default so it is very hard to detect and there",
    "start": "2781770",
    "end": "2790380"
  },
  {
    "text": "is a possible way of detecting this attack and as we did like measuring the",
    "start": "2790380",
    "end": "2795720"
  },
  {
    "text": "itlp hit miss or DTL behind miss it could be a traces or there is a TX award",
    "start": "2795720",
    "end": "2802589"
  },
  {
    "text": "counter in the performance counter would be the trace of this attack but if the",
    "start": "2802589",
    "end": "2808280"
  },
  {
    "text": "but if the attackers slow down the attack speed or like a probing just 1000",
    "start": "2808280",
    "end": "2814560"
  },
  {
    "text": "pages in a second or something then it is really hard to distinguish from the normal execution and next is about",
    "start": "2814560",
    "end": "2824310"
  },
  {
    "start": "2823000",
    "end": "2823000"
  },
  {
    "text": "discussion about countermeasures we thought about some of the potential countermeasures and one direct thing is",
    "start": "2824310",
    "end": "2831569"
  },
  {
    "text": "that to multiply processors to not to cache TLB or decoded I cache if the",
    "start": "2831569",
    "end": "2837329"
  },
  {
    "text": "privilege is not matched but this is difficult to be realized because it",
    "start": "2837329",
    "end": "2842400"
  },
  {
    "text": "requires hardware modification so it is very hard to deploy to patch on the deployed processors and another way is",
    "start": "2842400",
    "end": "2850380"
  },
  {
    "text": "that like turning up the tsx to secure the system but in the software",
    "start": "2850380",
    "end": "2857619"
  },
  {
    "text": "manner there's a no way to turn off the tsx neither from the MSR the model",
    "start": "2857619",
    "end": "2864759"
  },
  {
    "text": "specific registers nor from the BIOS setup so it might be disable build",
    "start": "2864759",
    "end": "2870190"
  },
  {
    "text": "through the micro code update Intel actually did that for the there's a in",
    "start": "2870190",
    "end": "2876190"
  },
  {
    "text": "the Haswell processor there's a some of the bug in the implementation of the TSX so until release the microcode update to",
    "start": "2876190",
    "end": "2883119"
  },
  {
    "text": "update but yeah it's hard to be done for in this case and another way is that we",
    "start": "2883119",
    "end": "2890559"
  },
  {
    "text": "rely on the very high resolution timer like by one or two clocks yeah in and it",
    "start": "2890559",
    "end": "2898989"
  },
  {
    "text": "is always suggested to that reduce the resolution of their this timing but",
    "start": "2898989",
    "end": "2904769"
  },
  {
    "text": "nobody adopts it because there's a lots of legitimate use of the your digital",
    "start": "2904769",
    "end": "2910479"
  },
  {
    "text": "resolution timers and for the software countermeasures a possible waste like",
    "start": "2910479",
    "end": "2916660"
  },
  {
    "text": "remove kernel page tables from the user space actually oh it's 10 has adopted",
    "start": "2916660",
    "end": "2923259"
  },
  {
    "text": "these options for the sake of security but the problem of this approach is that it encrusts like too much overhead like",
    "start": "2923259",
    "end": "2930219"
  },
  {
    "text": "a 30% on every time of the word switch it requires context switch so it is hard",
    "start": "2930219",
    "end": "2936789"
  },
  {
    "text": "to be applied to the operating system and another one instead that doing more",
    "start": "2936789",
    "end": "2942369"
  },
  {
    "text": "finer grained randomization not like a page level it could be like a the inside",
    "start": "2942369",
    "end": "2948039"
  },
  {
    "text": "of the page or something but it could be it could be helpful that it will be very",
    "start": "2948039",
    "end": "2953619"
  },
  {
    "text": "hard to implement implement it because of the compatibility issues or other technical issues and another easy one",
    "start": "2953619",
    "end": "2961089"
  },
  {
    "text": "will be like inserting some of the fake page mappings like a sum up for the some of the mapped page we can say we can",
    "start": "2961089",
    "end": "2967959"
  },
  {
    "text": "make it as a map one to fool the arcadia tab and in conclusion with Intel TSX",
    "start": "2967959",
    "end": "2977049"
  },
  {
    "start": "2974000",
    "end": "2974000"
  },
  {
    "text": "we can break currently as they're all a popular operating system with 100% accuracy and within one point 0.1",
    "start": "2977049",
    "end": "2985569"
  },
  {
    "text": "seconds without having we're venerability and the timing side channel attack is by hardware in d TLB",
    "start": "2985569",
    "end": "2993580"
  },
  {
    "text": "for map in a map and decoded I cash for executable and non-executable addresses",
    "start": "2993580",
    "end": "2999060"
  },
  {
    "text": "so we think that current K as AES are all is not as secure as expected so some",
    "start": "2999060",
    "end": "3006810"
  },
  {
    "text": "other some more research is required to make it more secure yeah thank you and",
    "start": "3006810",
    "end": "3020190"
  },
  {
    "start": "3017000",
    "end": "3017000"
  },
  {
    "text": "for the next I'm happy to answer any questions so please come up and if you have any questions",
    "start": "3020190",
    "end": "3027770"
  }
]