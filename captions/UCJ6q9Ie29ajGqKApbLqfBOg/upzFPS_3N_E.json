[
  {
    "text": "i work at internet security systems and um today i'll be talking about one of my fun side projects",
    "start": "44800",
    "end": "51440"
  },
  {
    "text": "the stuff i do on friday nights you know in my spare time i'll be talking about elf runtime binary",
    "start": "51440",
    "end": "58079"
  },
  {
    "text": "encryption specifically about shiva which is a tool that sean close a good",
    "start": "58079",
    "end": "63680"
  },
  {
    "text": "friend of mine and myself have written sean works for secure reality in",
    "start": "63680",
    "end": "68880"
  },
  {
    "text": "australia and he wasn't actually able to make it here for blackout this year but um",
    "start": "68880",
    "end": "75439"
  },
  {
    "text": "everything i'm talking about has been done by both of us um",
    "start": "75439",
    "end": "80560"
  },
  {
    "text": "the first thing that some of you might be wondering most of you probably know what exactly is runtime binary encryption",
    "start": "82080",
    "end": "88560"
  },
  {
    "text": "and it's very simply uh encrypting an executable such that it's",
    "start": "88560",
    "end": "94159"
  },
  {
    "text": "encrypted on disk and anyone who goes to look at it is going to see that it's encrypted on disk but it executes as it normally would",
    "start": "94159",
    "end": "101040"
  },
  {
    "text": "within memory so it's resistant to analysis and modification",
    "start": "101040",
    "end": "108240"
  },
  {
    "text": "and hopefully it's resistant to analysis and modification while executing as well as on disk so it's resistant to static",
    "start": "108240",
    "end": "113840"
  },
  {
    "text": "analysis as well as runtime analysis",
    "start": "113840",
    "end": "119360"
  },
  {
    "text": "um about elf or alph uh it stands for executable and linking format it's a",
    "start": "120320",
    "end": "126880"
  },
  {
    "text": "standard executable format on most unix platforms and",
    "start": "126880",
    "end": "132239"
  },
  {
    "text": "i won't go into great details about elf because i don't want to bore everyone here but it consists of",
    "start": "132239",
    "end": "139440"
  },
  {
    "text": "the standard components of most executable formats such as a header which contains",
    "start": "139440",
    "end": "144800"
  },
  {
    "text": "generic information about the executable itself and then there are section and segment",
    "start": "144800",
    "end": "151040"
  },
  {
    "text": "headers which contain specific information about different parts of the executable",
    "start": "151040",
    "end": "157840"
  },
  {
    "text": "other portions of an elf executable include symbols string tables",
    "start": "157920",
    "end": "164000"
  },
  {
    "text": "and relocations which all function in different ways to make the executable",
    "start": "164000",
    "end": "169840"
  },
  {
    "text": "execute i'll also give a very very brief and",
    "start": "169840",
    "end": "175440"
  },
  {
    "text": "quite incomplete history of runtime binary encryption just to give you an idea of the context in which shiva fits",
    "start": "175440",
    "end": "183120"
  },
  {
    "text": "up until quite recently in the last year or two",
    "start": "183120",
    "end": "188480"
  },
  {
    "text": "runtime binary encryption has been pretty much confined to microsoft platforms so",
    "start": "188480",
    "end": "194319"
  },
  {
    "text": "dos windows and anything other than that has been",
    "start": "194319",
    "end": "199519"
  },
  {
    "text": "pretty much ignored by people who've been writing runtime binary encryption tools",
    "start": "199519",
    "end": "204640"
  },
  {
    "text": "um going back really far to before i even use computers",
    "start": "204640",
    "end": "210640"
  },
  {
    "text": "the first runtime binary encryptors actually encrypted.com files um",
    "start": "210640",
    "end": "216159"
  },
  {
    "text": "and honestly there really is no format to a com file it's just executable code",
    "start": "216159",
    "end": "221519"
  },
  {
    "text": "um and there's no header there's nothing it loads at a static address and has a",
    "start": "221519",
    "end": "227440"
  },
  {
    "text": "limited amount of space and it just runs and um so it's would be very easy to write a",
    "start": "227440",
    "end": "233360"
  },
  {
    "text": "binary encrypter that encrypts dot com files because all you have to do is actually encrypt the data and decrypt it",
    "start": "233360",
    "end": "239040"
  },
  {
    "text": "but they also start at a uh they always begin execution at a static address of zero by one zero zero",
    "start": "239040",
    "end": "246159"
  },
  {
    "text": "so um quite often you'd see uh generic decrypters for these common crafters",
    "start": "246159",
    "end": "251519"
  },
  {
    "text": "because uh after the the runtime encrypter is finished decrypting the file it goes",
    "start": "251519",
    "end": "256959"
  },
  {
    "text": "back to fp this same address every single time 0x100 so you just sit there and wait till it executes that address",
    "start": "256959",
    "end": "262960"
  },
  {
    "text": "at which point the uh the file is actually decrypted in memory and you can dump it and run it as normal so these",
    "start": "262960",
    "end": "268880"
  },
  {
    "text": "weren't very successful um there there are obviously one or two ways around that but",
    "start": "268880",
    "end": "274960"
  },
  {
    "text": "common cryptos weren't really important and they weren't really a significant part of runtime binary encryption",
    "start": "274960",
    "end": "280960"
  },
  {
    "text": "onto windows with the uh the portable executable file format pe there's a lot more stuff that you can do",
    "start": "281280",
    "end": "287360"
  },
  {
    "text": "to make an executable hard to decrypt hard to analyze and um hard to modify",
    "start": "287360",
    "end": "293120"
  },
  {
    "text": "um i would say that the uh the pioneer in windows uh pe encryption would be p",
    "start": "293120",
    "end": "299840"
  },
  {
    "text": "crypt which came out around 1998 and was written by three guys who are part of the reverse engineering scene",
    "start": "299840",
    "end": "306560"
  },
  {
    "text": "and it was kind of an eye on for people they hadn't really seen anything that uh modified and executable to the the depth",
    "start": "306560",
    "end": "312960"
  },
  {
    "text": "that it did and it was kind of a um a guide or a uh a pioneer for future uh",
    "start": "312960",
    "end": "320000"
  },
  {
    "text": "pe encrypters and uh today you'll see that i'm sure quite a few are familiar with azpac or",
    "start": "320000",
    "end": "326000"
  },
  {
    "text": "upx and uh they really dominate the encrypt runtime binary encryption field on",
    "start": "326000",
    "end": "332080"
  },
  {
    "text": "windows and as part of my job i do a lot of malware analysis viruses worms and",
    "start": "332080",
    "end": "339120"
  },
  {
    "text": "pretty much every windows worm or virus that i look at is encrypted with aspac or upx or something similar",
    "start": "339120",
    "end": "345919"
  },
  {
    "text": "and so it's very very significant to anyone looking at",
    "start": "345919",
    "end": "351680"
  },
  {
    "text": "any type of malware out there honestly it doesn't really do much to make it hard to analyze i'm sure people unwrap",
    "start": "351680",
    "end": "358160"
  },
  {
    "text": "them in seconds or minutes but people use them anyways and",
    "start": "358160",
    "end": "363680"
  },
  {
    "text": "they're definitely out there on unix the first",
    "start": "363680",
    "end": "369199"
  },
  {
    "text": "unix runtime binary encryption tool that was of any significance was burn eye that",
    "start": "369199",
    "end": "374240"
  },
  {
    "text": "was released in 2001 by scott i believe his real name is sebastian",
    "start": "374240",
    "end": "381360"
  },
  {
    "text": "and um it was a i guess the the pe crypt of uh unix runtime binary encryption it was a",
    "start": "381360",
    "end": "388080"
  },
  {
    "text": "a pioneer and it offered some uh reverse engineers a chance to actually",
    "start": "388080",
    "end": "394479"
  },
  {
    "text": "look at runtime encryption on on linux and on elf files and um i believe now that upx also",
    "start": "394479",
    "end": "401680"
  },
  {
    "text": "supports linux um but up until up until uh 2001 there really wasn't anything and since then",
    "start": "401680",
    "end": "408880"
  },
  {
    "text": "there have been a few small encryptors here and there but um nothing extremely significant that is",
    "start": "408880",
    "end": "415840"
  },
  {
    "text": "not nothing that anyone's put a lot of work into to create so those are the two right now um up until",
    "start": "415840",
    "end": "422560"
  },
  {
    "text": "this year um where sean close and myself released shiva and um",
    "start": "422560",
    "end": "428720"
  },
  {
    "text": "shiva is a runtime binary capture encrypter for linux x86 executables we",
    "start": "428720",
    "end": "433919"
  },
  {
    "text": "haven't really expanded beyond that although we do have plans in the future to do that and it's",
    "start": "433919",
    "end": "440080"
  },
  {
    "text": "designed to bring a lot of the techniques that have been used in windows as well as new techniques to the linux",
    "start": "440080",
    "end": "446240"
  },
  {
    "text": "platform a little bit about",
    "start": "446240",
    "end": "451520"
  },
  {
    "text": "the difficulties involved with runtime binary encryption uh the encryptor's dilemma is what i call it um",
    "start": "451520",
    "end": "457919"
  },
  {
    "text": "to be able to actually execute the executable the code has to be there um it actually it must be able to",
    "start": "457919",
    "end": "463759"
  },
  {
    "text": "eventually be decrypted if it's going to be run and so no matter how hard you try",
    "start": "463759",
    "end": "470240"
  },
  {
    "text": "or no matter all the steps you go through you still have to end up executing that code so it must physically be there in memory",
    "start": "470240",
    "end": "475680"
  },
  {
    "text": "for you to be able to execute it and so that being said",
    "start": "475680",
    "end": "481520"
  },
  {
    "text": "binary encryption itself turns into an arms race um it's really who has more time to put",
    "start": "481520",
    "end": "486720"
  },
  {
    "text": "into uh creating the crypto or breaking it um and i'll be honest with you there are",
    "start": "486720",
    "end": "492160"
  },
  {
    "text": "probably a lot more people out there with more time than me to do it but um",
    "start": "492160",
    "end": "497440"
  },
  {
    "text": "it's essentially someone will create an encrypter and then someone will break it and then you're gonna fix your encrypter and then i'll break it again and it goes on and",
    "start": "497840",
    "end": "504400"
  },
  {
    "text": "on and on and be quite tedious at times but honestly the in the end the encrypters",
    "start": "504400",
    "end": "511120"
  },
  {
    "text": "cannot win and simply because you don't know if someone is breaking a broken urine crypto out there you have no idea what",
    "start": "511120",
    "end": "518159"
  },
  {
    "text": "attacks are being used unless people tell you about them or make them public so",
    "start": "518159",
    "end": "524159"
  },
  {
    "text": "because of the fact that the executive has to execute the code has to be there and unless someone is nice enough to tell",
    "start": "524560",
    "end": "530240"
  },
  {
    "text": "you you don't know what attacks are being used to attack your encrypter um you really cannot win in the end you can",
    "start": "530240",
    "end": "536080"
  },
  {
    "text": "make life really hard for a determined attacker but it is it's really a losing game",
    "start": "536080",
    "end": "543519"
  },
  {
    "text": "but it's not a pointless game and quite often people who are novice",
    "start": "543519",
    "end": "549680"
  },
  {
    "text": "reverse engineers or people without very much experience or people who really don't care about reversing your encrypter or your executable that's",
    "start": "549680",
    "end": "555440"
  },
  {
    "text": "encrypted with it won't put the effort into doing it so there's that part to it um",
    "start": "555440",
    "end": "561200"
  },
  {
    "text": "i think i quickly touched on this before um if the encrypted executable has access",
    "start": "561200",
    "end": "566800"
  },
  {
    "text": "to the encryption keys um then an attacker could potentially have",
    "start": "566800",
    "end": "572880"
  },
  {
    "text": "access to those encryption keys too so a uh a solid attack would have to be able to",
    "start": "572880",
    "end": "578399"
  },
  {
    "text": "achieve those keys and then use them to decrypt the program so uh once again you can only really",
    "start": "578399",
    "end": "583519"
  },
  {
    "text": "slow a determined attacker but there's a lot that you can do to make their life really really hard um",
    "start": "583519",
    "end": "590000"
  },
  {
    "text": "our aim shawn and myself our aim was to introduce some new techniques and advance the state of the art um",
    "start": "590000",
    "end": "598160"
  },
  {
    "text": "as i mentioned before unix executable encryption was a neglected field um the the technology",
    "start": "598160",
    "end": "605519"
  },
  {
    "text": "out there was pretty easy to get around anyone who knew what they were doing could uh decrypt um",
    "start": "605519",
    "end": "611680"
  },
  {
    "text": "any executable encrypted with the previously released encrypters so uh we wanted to make it a little bit hard and also kind of as being part of a",
    "start": "611680",
    "end": "619120"
  },
  {
    "text": "reverse engineering community we wanted to promote interest in reverse engineering on unix platforms",
    "start": "619120",
    "end": "624320"
  },
  {
    "text": "so those are some of our goals um uh what's really the point of runtime",
    "start": "624320",
    "end": "630800"
  },
  {
    "text": "binary encryption it's good for several things you can prevent the trivial reverse engineering",
    "start": "630800",
    "end": "636959"
  },
  {
    "text": "of algorithms in your programs or the actual the content of the program so",
    "start": "636959",
    "end": "643760"
  },
  {
    "text": "if you have some really really great piece of software and you're releasing it to the public but you don't want the",
    "start": "643920",
    "end": "650240"
  },
  {
    "text": "internal details of that software to show up in other programs or people steal them you can use a runtime binary",
    "start": "650240",
    "end": "656160"
  },
  {
    "text": "encrypted to go ahead and obfuscate the code within your program from an administration standpoint you",
    "start": "656160",
    "end": "662560"
  },
  {
    "text": "can protect set uid programs with uh passwords so it's just an extra layer of security there and uh yeah hide",
    "start": "662560",
    "end": "669839"
  },
  {
    "text": "sensitive data or code in your programs there are some very common attacks that",
    "start": "669839",
    "end": "675839"
  },
  {
    "text": "are used against binary encrypters on unix and uh there's a big list of them right",
    "start": "675839",
    "end": "681760"
  },
  {
    "text": "there but um s-trace or l-trace is um",
    "start": "681760",
    "end": "688320"
  },
  {
    "text": "they what they do is they monitor system calls or library calls and um",
    "start": "688320",
    "end": "694079"
  },
  {
    "text": "they're quite useful to get a quick idea of what a binary is doing when you're executing it",
    "start": "694079",
    "end": "700560"
  },
  {
    "text": "they're very useful i use them quite often and um a good encryptor will have to be able to",
    "start": "700560",
    "end": "706399"
  },
  {
    "text": "uh deter these standard attacks fenris is a execution path tracing tool it was",
    "start": "706399",
    "end": "712399"
  },
  {
    "text": "written by michael zalewski and s trace l trace and fenris are all based on the uh",
    "start": "712399",
    "end": "718480"
  },
  {
    "text": "the p trace api uh gdb is a the standard unix debugger",
    "start": "718480",
    "end": "724560"
  },
  {
    "text": "and once again it uses a p trace on linux the proc fs",
    "start": "724560",
    "end": "731680"
  },
  {
    "text": "file system on on linux actually can allow you to dump memory of executables that are running",
    "start": "731680",
    "end": "736880"
  },
  {
    "text": "so if you're going to deter uh attacks based on procfs the encryptor",
    "start": "736880",
    "end": "742399"
  },
  {
    "text": "should be able to do something about that and then uh everyone's favorite tool strings which",
    "start": "742399",
    "end": "748160"
  },
  {
    "text": "is uh the tool of every good reverse engineer i'm just being facetious but uh",
    "start": "748160",
    "end": "754160"
  },
  {
    "text": "any encryption of any sort should deal with strings so um if you encrypt the binary in any",
    "start": "754160",
    "end": "759760"
  },
  {
    "text": "matter whatsoever the strings won't be there people won't be able to guess based upon the data within your executable um",
    "start": "759760",
    "end": "767519"
  },
  {
    "text": "l chase s trace fenris gdb they're all based around p-trace so making that api",
    "start": "767519",
    "end": "773200"
  },
  {
    "text": "ineffective would be a big step towards uh making a binary crypto difficult to attack",
    "start": "773200",
    "end": "778560"
  },
  {
    "text": "um and i'll go into how we do this later",
    "start": "778560",
    "end": "783519"
  },
  {
    "text": "the proc fs file system is uh attacks based on that will be memory",
    "start": "785200",
    "end": "790639"
  },
  {
    "text": "dumping attacks and those attacks would be based on the assumption that",
    "start": "790639",
    "end": "795920"
  },
  {
    "text": "uh all or a good portion of the executable is decrypted in memory when you go to",
    "start": "795920",
    "end": "800959"
  },
  {
    "text": "flash proc and try to dump the memory and that's not necessarily true",
    "start": "800959",
    "end": "806320"
  },
  {
    "text": "and a good encryptor will do something to invalidate that so i'll go into how that works later",
    "start": "806320",
    "end": "812959"
  },
  {
    "text": "so uh the all that aside there are still um static analysis attacks",
    "start": "812959",
    "end": "819920"
  },
  {
    "text": "and um if you leave static analysis as one thing that we're not gonna think",
    "start": "819920",
    "end": "825920"
  },
  {
    "text": "about right now all these active attacks can be detected by an encrypter and the encrypter can do",
    "start": "825920",
    "end": "831680"
  },
  {
    "text": "something to prevent them and uh maybe something even a little bit worse such as killing the debugger or",
    "start": "831680",
    "end": "838320"
  },
  {
    "text": "you can go beyond that shiva doesn't do anything like that but there's a lot of stuff you can do to detect these active attacks",
    "start": "838320",
    "end": "845680"
  },
  {
    "text": "but static analysis is always a concern and if someone truly",
    "start": "845839",
    "end": "851199"
  },
  {
    "text": "understands your your encrypter they can go ahead and exactly replicate the decryption process",
    "start": "851199",
    "end": "856560"
  },
  {
    "text": "and there's nothing you can do about it um if they understand it to that depth um",
    "start": "856560",
    "end": "861680"
  },
  {
    "text": "then you're the game is up and there's absolutely nothing you can do about it because you can't detect it if they've completely reverse engineered every part",
    "start": "861680",
    "end": "867600"
  },
  {
    "text": "of your encrypter but to make that harder you can take a layered approach",
    "start": "867600",
    "end": "873440"
  },
  {
    "text": "to runtime binary encryption by adding not just one layer or two layers but many layers",
    "start": "873440",
    "end": "880240"
  },
  {
    "text": "there's a really bad metaphor in there like an onion skin where you just peel away one skin and there's another one under it and so on so",
    "start": "880240",
    "end": "888480"
  },
  {
    "text": "making it more difficult by taking a layered approach is something that shiva does another thing that",
    "start": "888480",
    "end": "895760"
  },
  {
    "text": "most encrypters don't take into account is uh how predictable their behavior is",
    "start": "895760",
    "end": "900800"
  },
  {
    "text": "uh most encrypters encrypt and executable the same way every single time so if you run the same encryptor",
    "start": "900800",
    "end": "906560"
  },
  {
    "text": "against the same executable five times you get the same output and it will behave the same way do the same things",
    "start": "906560",
    "end": "912399"
  },
  {
    "text": "and so if you understand the way it works on one exactly well you can understand the way it works on every single executable",
    "start": "912399",
    "end": "918320"
  },
  {
    "text": "every single time and this is why you see a lot of generic",
    "start": "918320",
    "end": "923600"
  },
  {
    "text": "unpackers out there for upx or aspac because they their behavior is very predictable and",
    "start": "923600",
    "end": "929920"
  },
  {
    "text": "if you understand how it works once you understand how it works every time so any",
    "start": "929920",
    "end": "935120"
  },
  {
    "text": "step that you could take to uh make an exact or the encryptor behave differently from one example to",
    "start": "935120",
    "end": "940480"
  },
  {
    "text": "the next or one encryption instance to the next would make it harder for an attacker so",
    "start": "940480",
    "end": "946079"
  },
  {
    "text": "the less generic the methodology it is the harder it is to create a generic unwrapper",
    "start": "946079",
    "end": "951440"
  },
  {
    "text": "so yeah i'm not just talking about those things for no reason shiva tries to do all of these um and uh",
    "start": "952000",
    "end": "957839"
  },
  {
    "text": "it tries to implement all the defenses i've talked about um we didn't quite make it up to shiva",
    "start": "957839",
    "end": "963199"
  },
  {
    "text": "version 0.99 i guess we're at 0.96 which is on your conference cds",
    "start": "963199",
    "end": "968800"
  },
  {
    "text": "0.97 should be out very shortly which includes some pretty interesting changes",
    "start": "968800",
    "end": "974000"
  },
  {
    "text": "um not at quite at a full release version of 1.0 at least not what i would think would be so",
    "start": "974000",
    "end": "982000"
  },
  {
    "text": "we'll see that sometime in the near future what it does is it encrypts dynamic or static linux elf insect tools",
    "start": "982000",
    "end": "987440"
  },
  {
    "text": "but it doesn't handle shared libraries yet so that's a future product for us to look at",
    "start": "987440",
    "end": "993519"
  },
  {
    "text": "a little bit about developing an encrypter uh and encrypter itself is really two",
    "start": "994800",
    "end": "1000399"
  },
  {
    "text": "completely separate programs um you have the program that does the encryption and outputs the executable file and then you",
    "start": "1000399",
    "end": "1006720"
  },
  {
    "text": "have the decrypter which is embedded in the output file and behaves in a symmetrical way to the",
    "start": "1006720",
    "end": "1013839"
  },
  {
    "text": "encrypter so that it actually allows the program to run",
    "start": "1013839",
    "end": "1019120"
  },
  {
    "text": "the encrypter for shiva is a normal executable it's just a regular elf executable it does the encryption process it wraps the executable and",
    "start": "1019120",
    "end": "1025438"
  },
  {
    "text": "gives you a nice output file and the decrypter itself is a statically",
    "start": "1025439",
    "end": "1031678"
  },
  {
    "text": "linked executable so it contains all of the libraries that",
    "start": "1031679",
    "end": "1037280"
  },
  {
    "text": "it needs to use actually doesn't use libraries but and it performs the decryption and all the runtime processing",
    "start": "1037280",
    "end": "1043438"
  },
  {
    "text": "so it's a little bit more complex than the encrypter itself and it has to be embedded with the encrypted within the encrypted",
    "start": "1043439",
    "end": "1049440"
  },
  {
    "text": "executable has to be self-contained for size concerns we don't link it with lipsy because",
    "start": "1049440",
    "end": "1054480"
  },
  {
    "text": "you don't want to encrypt a 20k exactly we'll end up with something that's five megabytes or something so",
    "start": "1054480",
    "end": "1059679"
  },
  {
    "text": "uh it doesn't use libsy which is a little bit of a pain to start but um",
    "start": "1059679",
    "end": "1066799"
  },
  {
    "text": "it's a lot more efficient one thing that we ran into when starting",
    "start": "1066799",
    "end": "1072400"
  },
  {
    "text": "to develop shiva was dealing with the elf format and",
    "start": "1072400",
    "end": "1077679"
  },
  {
    "text": "what's the best way to do it and it's a reasonably complex file format",
    "start": "1077679",
    "end": "1082799"
  },
  {
    "text": "there are a lot of different fields within the headers and i honestly got very tired of",
    "start": "1082799",
    "end": "1089280"
  },
  {
    "text": "using static offsets into headers to go ahead and look at the data in the",
    "start": "1089280",
    "end": "1094720"
  },
  {
    "text": "headers so um we developed an extraction api which will read any elf executable into",
    "start": "1094720",
    "end": "1101200"
  },
  {
    "text": "a well-defined structure in memory allow us to manipulate that structure and at that point",
    "start": "1101200",
    "end": "1107520"
  },
  {
    "text": "at any point i guess write that structure back to a working executable so uh it made our lives a lot easier",
    "start": "1107520",
    "end": "1113440"
  },
  {
    "text": "when developing shiva to have this in place at any time you can go ahead and modify",
    "start": "1113440",
    "end": "1119280"
  },
  {
    "text": "the size of the image within the header or you can modify uh go ahead and change some of the",
    "start": "1119280",
    "end": "1124799"
  },
  {
    "text": "different segments and expand them and it was a little bit of overhead to actually develop this but it's not that",
    "start": "1124799",
    "end": "1131520"
  },
  {
    "text": "revolutionary but it did make developing the encrypter a lot easier and it took away a lot of the headache",
    "start": "1131520",
    "end": "1137280"
  },
  {
    "text": "headaches involved with doing it shiva itself",
    "start": "1137280",
    "end": "1143280"
  },
  {
    "text": "has a what we call a dual process module where it uh",
    "start": "1143280",
    "end": "1148559"
  },
  {
    "text": "there when any shiva encrypt executable runs there are actually two main processes that run and uh they interact and they",
    "start": "1148559",
    "end": "1156320"
  },
  {
    "text": "um they're dependent on each other and uh i call it the evil clone um but",
    "start": "1156320",
    "end": "1162320"
  },
  {
    "text": "there's a slave process which is actually the main executable thread and it uh it runs and it runs the code that",
    "start": "1162320",
    "end": "1168960"
  },
  {
    "text": "was intended to be run by the executable and then it's a controller process which is the clone and what they do is they",
    "start": "1168960",
    "end": "1174720"
  },
  {
    "text": "peach race each other so um if you're familiar with the ptrace api on unix you'll know that there's a",
    "start": "1174720",
    "end": "1182559"
  },
  {
    "text": "there's a hard limit of one p-trace instance per process so any process can only be p-traced once",
    "start": "1182559",
    "end": "1189360"
  },
  {
    "text": "so this p-trace is functional and it also serves an anti-debugging feature",
    "start": "1189360",
    "end": "1195520"
  },
  {
    "text": "because if they p-trace each other and that link is established successfully then supposedly without",
    "start": "1195520",
    "end": "1202400"
  },
  {
    "text": "kernel modification no other executable can actually try and petrace either of them",
    "start": "1202400",
    "end": "1207840"
  },
  {
    "text": "and of course you can go and modify the kernel and get around that but",
    "start": "1207840",
    "end": "1213039"
  },
  {
    "text": "it's a fairly significant part of shiva",
    "start": "1213360",
    "end": "1217520"
  },
  {
    "text": "another part of shiva that we implemented was run time generation of x86 assembly",
    "start": "1218799",
    "end": "1224960"
  },
  {
    "text": "bytecode and we do we do that from within c so we implemented a very basic assembler",
    "start": "1224960",
    "end": "1230799"
  },
  {
    "text": "that creates this code on demand and it allows us to do pseudo-random code generation or",
    "start": "1230799",
    "end": "1237280"
  },
  {
    "text": "basically make the encryptor behave differently each time it's run a little bit differently anyways it's",
    "start": "1237280",
    "end": "1243679"
  },
  {
    "text": "pretty challenging to make it behave completely differently from time to time but there is some pseudo-random code",
    "start": "1243679",
    "end": "1248720"
  },
  {
    "text": "generation and each time you uh run it against an executable you get different output and you'll get",
    "start": "1248720",
    "end": "1253840"
  },
  {
    "text": "a code that behaves slightly differently and as time goes on we'll make it more different for each instance",
    "start": "1253840",
    "end": "1260640"
  },
  {
    "text": "and a lot more challenging to look at but this functionality",
    "start": "1260640",
    "end": "1266080"
  },
  {
    "text": "makes it harder to write a generic unwrapper and it also was a fairly",
    "start": "1266080",
    "end": "1273039"
  },
  {
    "text": "well i wouldn't say it was hard to develop but it was a fair amount of work to do but i think it's worthwhile doing in the end",
    "start": "1273039",
    "end": "1279840"
  },
  {
    "text": "okay i just lost everything",
    "start": "1281120",
    "end": "1284840"
  },
  {
    "text": "all right so um as for the layout approach um shiva starts out with a very very basic",
    "start": "1291440",
    "end": "1298240"
  },
  {
    "text": "observation layer which is uh generated by the uh on on-demand byte code generation and it",
    "start": "1298240",
    "end": "1305840"
  },
  {
    "text": "all it does is it does a very simple encryption of all the data in the executable and all the data in the um",
    "start": "1305840",
    "end": "1313440"
  },
  {
    "text": "in the decrypter itself so if you think about it in layers you have",
    "start": "1313440",
    "end": "1318480"
  },
  {
    "text": "your observation layer and you have all the obfuscated data below it and um the only real purpose of this is",
    "start": "1318480",
    "end": "1324720"
  },
  {
    "text": "to um make it difficult to uh reverse engineer the decrypter itself um",
    "start": "1324720",
    "end": "1332960"
  },
  {
    "text": "and uh it serves its purpose it's very easy it's very quick and if you wanted to get around it you could but it's definitely",
    "start": "1332960",
    "end": "1339520"
  },
  {
    "text": "not the only defense it's intended to evade simple static analysis and",
    "start": "1339520",
    "end": "1346000"
  },
  {
    "text": "yeah as i said it's somewhat random and it's generated by the inline asm generation code",
    "start": "1346000",
    "end": "1351520"
  },
  {
    "text": "beyond the authentication layer there's a password layer and if you choose to use a password you don't have to but if",
    "start": "1351520",
    "end": "1356559"
  },
  {
    "text": "you choose to use a password the password layer is there and everything",
    "start": "1356559",
    "end": "1362080"
  },
  {
    "text": "other than the password layer and the observation layer are encrypted with aes so if you choose to add a password to an",
    "start": "1362080",
    "end": "1368159"
  },
  {
    "text": "executable um and provided your password is strong there is a uh",
    "start": "1368159",
    "end": "1375039"
  },
  {
    "text": "a very significant obstacle to um any reverse engineer if they can break",
    "start": "1375039",
    "end": "1380320"
  },
  {
    "text": "128 bit aes they can go ahead and decrypt the rest of the executable if they can break your",
    "start": "1380320",
    "end": "1385600"
  },
  {
    "text": "password which is more likely then they can decrypt the executable but if they can't do either of those then",
    "start": "1385600",
    "end": "1391120"
  },
  {
    "text": "they're stop dead in their tracks and there's nothing more they can do the key for the decryption is just a",
    "start": "1391120",
    "end": "1396640"
  },
  {
    "text": "sha-1 password hash so it's only as strong as your password but i think everyone knows how to create",
    "start": "1396640",
    "end": "1402159"
  },
  {
    "text": "a reasonably strong password and the password layer itself is a very significant obstacle to",
    "start": "1402159",
    "end": "1407600"
  },
  {
    "text": "anyone if you add it the third layer is the uh",
    "start": "1407600",
    "end": "1414240"
  },
  {
    "text": "the crypt block layer and the way this works is uh",
    "start": "1414240",
    "end": "1422240"
  },
  {
    "text": "the executable is divided up into hundreds and hundreds of different blocks of data or blocks of code",
    "start": "1422240",
    "end": "1428480"
  },
  {
    "text": "and um these are encrypted and decrypted uh",
    "start": "1428480",
    "end": "1434320"
  },
  {
    "text": "at different points within execution there are two different important types of locks ones that are immediately",
    "start": "1434320",
    "end": "1439440"
  },
  {
    "text": "mapped and ones that are mapped on demand so um for simplicity's sake we map all data",
    "start": "1439440",
    "end": "1446559"
  },
  {
    "text": "immediately because you don't know when the data might be accessed you don't know what part of the code might access the data",
    "start": "1446559",
    "end": "1451840"
  },
  {
    "text": "so you have to map the data immediately to make sure it's there and the program can execute properly",
    "start": "1451840",
    "end": "1457919"
  },
  {
    "text": "but as for code for most if not all executables code is not important unless it's actually being",
    "start": "1457919",
    "end": "1463679"
  },
  {
    "text": "executed so it doesn't have to be there unless you're actually running it so",
    "start": "1463679",
    "end": "1469840"
  },
  {
    "text": "a small only achievement can leave a certain percentage of the code encrypted and only a small percentage decrypted at",
    "start": "1470320",
    "end": "1475919"
  },
  {
    "text": "any given time um and the controller process the uh the clone handles mapping and unmapping the",
    "start": "1475919",
    "end": "1483840"
  },
  {
    "text": "different crypt blocks at any given time so um if you if you are um",
    "start": "1483840",
    "end": "1491360"
  },
  {
    "text": "if you're actually running the executable and you're in within a decrypted lock you start with an interconnected log and say execution",
    "start": "1492000",
    "end": "1499600"
  },
  {
    "text": "flow brings you to a block that is that is actually encrypted it will generate a fault which is caught by the controller",
    "start": "1499600",
    "end": "1505679"
  },
  {
    "text": "process and the controller process goes ahead and then decrypts that and when it does",
    "start": "1505679",
    "end": "1510720"
  },
  {
    "text": "that it also randomly unmaps some other blocks out there so that as the executable runs you don't have",
    "start": "1510720",
    "end": "1517039"
  },
  {
    "text": "the problem of having more and more of the data or the code unencrypted as time goes on",
    "start": "1517039",
    "end": "1522159"
  },
  {
    "text": "so there's a random on that feature also to create these locks you have to",
    "start": "1522159",
    "end": "1528320"
  },
  {
    "text": "be able to parse x86 instruction lengths um it's not",
    "start": "1528320",
    "end": "1533360"
  },
  {
    "text": "trivial to do that but it can be done with a little bit of work and uh i really wish x86 was a fixed length",
    "start": "1533360",
    "end": "1539919"
  },
  {
    "text": "instruction set but it's not so you have instructions that are one byte two bytes long",
    "start": "1539919",
    "end": "1544960"
  },
  {
    "text": "uh eight bytes long and you have to be able to understand that to",
    "start": "1544960",
    "end": "1550400"
  },
  {
    "text": "have your make sure that your locks don't end up on or with in the middle of any instruction",
    "start": "1550400",
    "end": "1556480"
  },
  {
    "text": "boundaries so um that's part of shiva too um",
    "start": "1556480",
    "end": "1562159"
  },
  {
    "text": "so as you move from a cleared block to a decrypted lock the block becomes",
    "start": "1562159",
    "end": "1567440"
  },
  {
    "text": "decrypted other another one becomes unmapped and",
    "start": "1567440",
    "end": "1572880"
  },
  {
    "text": "the block content itself is encrypted with a strong algorithm so it's a it's a reasonably simple and",
    "start": "1572880",
    "end": "1579200"
  },
  {
    "text": "reasonably efficient algorithm but it's strong i'm not going to tell you what it is but if you take the time to reverse engineer shiva you can go ahead and",
    "start": "1579200",
    "end": "1585279"
  },
  {
    "text": "probably guess what it is pretty quickly the keys aren't stored",
    "start": "1585279",
    "end": "1591679"
  },
  {
    "text": "as data within the executable because that would just make it too easy so they're never stored in plain text",
    "start": "1591679",
    "end": "1598080"
  },
  {
    "text": "there's code that generates the keys on the fly and it's uh it's made pseudorandomly by the asm bytecode generator again",
    "start": "1598080",
    "end": "1605520"
  },
  {
    "text": "and to take it to the next step",
    "start": "1605520",
    "end": "1610960"
  },
  {
    "text": "this code itself tries to bind it to a specific location in memory so in a specific location of memory so",
    "start": "1610960",
    "end": "1616880"
  },
  {
    "text": "um you couldn't just rip the code out and run it within the context of another process",
    "start": "1616880",
    "end": "1622240"
  },
  {
    "text": "uh you'd have to do significant modification on the code to make it work so it tries to make it very hard to take",
    "start": "1622240",
    "end": "1627520"
  },
  {
    "text": "this code out of the context of the shield process and it makes it a little bit harder to find",
    "start": "1627520",
    "end": "1632960"
  },
  {
    "text": "the keys",
    "start": "1632960",
    "end": "1635440"
  },
  {
    "text": "the dynamically linked elf executables pretty much every executable on your linux system is dynamically linked",
    "start": "1638159",
    "end": "1644799"
  },
  {
    "text": "and they interact with the system's dynamic linker to resolve references to libraries",
    "start": "1644799",
    "end": "1650000"
  },
  {
    "text": "and resolve references to any external symbols and",
    "start": "1650000",
    "end": "1655200"
  },
  {
    "text": "it's quite a complex process and when we developed shiva we chose not to try and replicate that because",
    "start": "1655200",
    "end": "1661760"
  },
  {
    "text": "that itself would be an incredible amount of work to do so",
    "start": "1661760",
    "end": "1667039"
  },
  {
    "text": "the decrypter itself has to map in the system's dynamic linker and um it passes off control to the",
    "start": "1667039",
    "end": "1673600"
  },
  {
    "text": "dynamic linker the dynamic link goes ahead and does all the uh the horrible mess that is resolving all",
    "start": "1673600",
    "end": "1679520"
  },
  {
    "text": "those symbols and um and shiva has to regain control again after the linker is done",
    "start": "1679520",
    "end": "1686159"
  },
  {
    "text": "and uh that's that's done by setting a uh setting a certain member of a structure",
    "start": "1686159",
    "end": "1692080"
  },
  {
    "text": "which you pass to the dynamic linker to one of the shiva routines which does that",
    "start": "1692080",
    "end": "1697520"
  },
  {
    "text": "another part of shiva is anti-debugging or disassembly and it's a pretty important part of shiva",
    "start": "1697520",
    "end": "1705440"
  },
  {
    "text": "if it was easy to debug it it'd be easy to figure out what it did and i know i'm telling you what it does here",
    "start": "1705440",
    "end": "1712080"
  },
  {
    "text": "but still we didn't want to make it too easy to debug or too easy to uh disassemble",
    "start": "1712080",
    "end": "1718080"
  },
  {
    "text": "so there's a as i mentioned before there's a inherent protection offered by the dual p trace approach",
    "start": "1718080",
    "end": "1724640"
  },
  {
    "text": "and um it's not just a a a link there for this like a p trace",
    "start": "1724640",
    "end": "1730000"
  },
  {
    "text": "link there just for the sake of being there it actually serves a purpose so if you get in between that or you break that link somehow you p p trace one of",
    "start": "1730000",
    "end": "1737120"
  },
  {
    "text": "the processes or the other um shiva a shiva encrypted executive will",
    "start": "1737120",
    "end": "1742240"
  },
  {
    "text": "just stop working so that itself makes it a little bit more difficult to uh break shiva",
    "start": "1742240",
    "end": "1749120"
  },
  {
    "text": "but of course you can do modifications to your kernel and try and get around that",
    "start": "1749120",
    "end": "1755120"
  },
  {
    "text": "so there are a lot of other anti-debugging things that we put in there shiva checks the the flags register",
    "start": "1755279",
    "end": "1762320"
  },
  {
    "text": "which can be accessed via procfs and if someone has tried a single step through a program",
    "start": "1762320",
    "end": "1769279"
  },
  {
    "text": "the trap flag will be set in the flag's register and that tells the the cpu to generate interrupt at the",
    "start": "1769279",
    "end": "1777200"
  },
  {
    "text": "when every single instruction is executed so it allows a single stepper to gain control of the process",
    "start": "1777200",
    "end": "1782320"
  },
  {
    "text": "and go ahead and analyze what it's doing on an",
    "start": "1782320",
    "end": "1788640"
  },
  {
    "text": "instruction by instruction basis so by looking for that we can try and invalidate that attack",
    "start": "1788640",
    "end": "1795279"
  },
  {
    "text": "um also by checking um proc self stat you can tell if your",
    "start": "1795279",
    "end": "1801679"
  },
  {
    "text": "executive was being peach raced by another process so that's just a small step that can be taken to um",
    "start": "1801679",
    "end": "1808080"
  },
  {
    "text": "determine if someone is trying to reverse engineer a shiva encrypted executable",
    "start": "1808080",
    "end": "1814158"
  },
  {
    "text": "there's some other stuff in here there's something to do with timing and sig trap and i didn't write this code so i",
    "start": "1814559",
    "end": "1820320"
  },
  {
    "text": "honestly can't remember how it worked i tried to look at the source code today and figure out what sean was doing there but his comment",
    "start": "1820320",
    "end": "1826960"
  },
  {
    "text": "said uh i'm gonna quote him here it said i'm not sure why this works but it does so",
    "start": "1826960",
    "end": "1833279"
  },
  {
    "text": "um i don't really i can't remember specifically why that works or what it does but it's uh",
    "start": "1833279",
    "end": "1839200"
  },
  {
    "text": "there's also a simple sig trap cache within shiva which plays havoc with a lot of debuggers and allows you to detect them",
    "start": "1839200",
    "end": "1845360"
  },
  {
    "text": "as for anti-disassembly um this is a really old trick and it's been around for years but and it's been",
    "start": "1845360",
    "end": "1851279"
  },
  {
    "text": "used by a lot of people but on x86 or a lot of",
    "start": "1851279",
    "end": "1856799"
  },
  {
    "text": "cpus that don't require a fixed instruction length and don't require any alignment for those instructions",
    "start": "1856799",
    "end": "1862880"
  },
  {
    "text": "you can do a trick which i call jumping into instructions which is",
    "start": "1862880",
    "end": "1869120"
  },
  {
    "text": "if you have an instruction that should be eight bytes long the first two bytes could be uh whatever valid data it is and the",
    "start": "1869120",
    "end": "1875840"
  },
  {
    "text": "last six could be a code that continues on so you if you were to jump two bytes into that",
    "start": "1875840",
    "end": "1881600"
  },
  {
    "text": "instruction and um and have the real code there",
    "start": "1881600",
    "end": "1886720"
  },
  {
    "text": "a disassembler looking at that will think that's an eight byte instruction and it will parse it as an eight byte instruction and",
    "start": "1886720",
    "end": "1893840"
  },
  {
    "text": "the code won't make very much sense when you're looking at it from a disassembler so i'll show you that a little bit later",
    "start": "1894080",
    "end": "1899120"
  },
  {
    "text": "within ida how that looks and how it plays havoc with anyone trying to read the assembly code",
    "start": "1899120",
    "end": "1905279"
  },
  {
    "text": "um another thing that we do within chiva is um byte code manipulation and this is a",
    "start": "1905279",
    "end": "1912480"
  },
  {
    "text": "another layer beyond elf um this is going beyond the elf file format",
    "start": "1912480",
    "end": "1918960"
  },
  {
    "text": "and it's going actually to the x86 byte code it's currently x86 specific as is the rest of shiva",
    "start": "1918960",
    "end": "1925360"
  },
  {
    "text": "but what we're doing is we're looking and parsing the executable code and looking for specific code constructs",
    "start": "1925360",
    "end": "1930799"
  },
  {
    "text": "that we understand and um we process each instruction and when we",
    "start": "1930799",
    "end": "1936399"
  },
  {
    "text": "find stuff that we understand we go ahead and we can make modifications",
    "start": "1936399",
    "end": "1942000"
  },
  {
    "text": "to those specific instructions doing this requires a lot of code analysis and it was a reasonable uh",
    "start": "1942000",
    "end": "1948399"
  },
  {
    "text": "reasonably large amount of code to put into shiva because you have to recognize uh code",
    "start": "1948399",
    "end": "1954320"
  },
  {
    "text": "flow within the executable so that you don't get it wrong you don't change something that you think is a push or",
    "start": "1954320",
    "end": "1960240"
  },
  {
    "text": "for example a uh i don't know an xor instruction when it's actually a um a mob instruction",
    "start": "1960240",
    "end": "1965840"
  },
  {
    "text": "then you just got the instruction boundaries wrong so to get it right and to do it reliably requires a lot of",
    "start": "1965840",
    "end": "1971600"
  },
  {
    "text": "processing and a lot of code and a very well designed framework to do",
    "start": "1971600",
    "end": "1976799"
  },
  {
    "text": "it um and we've implemented something within shiva that works reasonably well to do this",
    "start": "1976799",
    "end": "1984480"
  },
  {
    "text": "there's some easy things that you can do when you're manipulating by code an obvious one would be to redirect",
    "start": "1985039",
    "end": "1990640"
  },
  {
    "text": "calls so uh let's say someone is a a pretty good",
    "start": "1990640",
    "end": "1996640"
  },
  {
    "text": "reverse engineer and they've gone and broken the uh the first they've they've removed the observation layer on a shiva executable",
    "start": "1996640",
    "end": "2003760"
  },
  {
    "text": "and they've gone beyond that and they've cracked your password on the shiva executable and um",
    "start": "2003760",
    "end": "2009760"
  },
  {
    "text": "they've gone even beyond that and they've found out and figured out a way to decrypt all the locks so they have all the data encrypted are",
    "start": "2009760",
    "end": "2016159"
  },
  {
    "text": "decrypted and they have access to all of it and they go ahead and try to run it and it crashes at some random place and",
    "start": "2016159",
    "end": "2021679"
  },
  {
    "text": "the reason why it crashes is because you've changed the call instruction and it points to the wrong place within the",
    "start": "2021679",
    "end": "2026720"
  },
  {
    "text": "executable and so it's just an extra layer that makes it harder to",
    "start": "2026720",
    "end": "2032640"
  },
  {
    "text": "completely decrypt an executable you could redirect calls to anywhere in memory as long as it's the wrong place a",
    "start": "2032640",
    "end": "2038960"
  },
  {
    "text": "little bit trickier thing to do would be to redirect to somewhere that looks legitimate but actually isn't so it'd be harder to recognize",
    "start": "2038960",
    "end": "2046080"
  },
  {
    "text": "jumps are the same thing you can redirect them anywhere and achieve a place with those a little bit",
    "start": "2046080",
    "end": "2052878"
  },
  {
    "text": "jump tables are constructs that are created by the compiler that they're usually created to handle switch",
    "start": "2052879",
    "end": "2058158"
  },
  {
    "text": "statements and so if you have a switch statement with 20 different",
    "start": "2058159",
    "end": "2063679"
  },
  {
    "text": "cases within it the compiler will create a jump table that points to each of those cases so by",
    "start": "2063679",
    "end": "2069919"
  },
  {
    "text": "modifying these jump tables you can make a little bit harder to decrypt the executable fully also",
    "start": "2069919",
    "end": "2076398"
  },
  {
    "text": "these are usually stored in the read-only data section of elf executables",
    "start": "2076399",
    "end": "2081679"
  },
  {
    "text": "i know on windows platforms they're stored within the code which makes it harder to analyze them a little bit",
    "start": "2081679",
    "end": "2088320"
  },
  {
    "text": "and there are a lot of other constructs that you can deal with also like uh handling simple instructions like uh",
    "start": "2088320",
    "end": "2094960"
  },
  {
    "text": "common instructions associated with function calls like push instructions push eax for example if you change it to",
    "start": "2094960",
    "end": "2100160"
  },
  {
    "text": "something uh change it to something that the uh changes to an n3 let's say that shiva",
    "start": "2100160",
    "end": "2105359"
  },
  {
    "text": "can intercept um an attacker will have no idea what was",
    "start": "2105359",
    "end": "2110800"
  },
  {
    "text": "previously there unless they understand uh what shiva has done to it so this is",
    "start": "2110800",
    "end": "2116480"
  },
  {
    "text": "just one extra nasty layer on top of everything else to make it an attacker's life harder",
    "start": "2116480",
    "end": "2124480"
  },
  {
    "text": "and the way shiva deals with it right now is it emulates the instructions that it replaces or takes out",
    "start": "2124880",
    "end": "2130640"
  },
  {
    "text": "and this is done by uh shiva has access to the the p trace",
    "start": "2130640",
    "end": "2136800"
  },
  {
    "text": "register structures uh because when it replaces an instruction it puts an n3 in that place",
    "start": "2136800",
    "end": "2143200"
  },
  {
    "text": "and the controller process actually when it takes control of uh execution",
    "start": "2143200",
    "end": "2149920"
  },
  {
    "text": "has access to a structure which contains information on every single register",
    "start": "2149920",
    "end": "2155520"
  },
  {
    "text": "so it can modify the stack pointer i can modify the frame pointer it can change any of the general purpose",
    "start": "2155520",
    "end": "2162880"
  },
  {
    "text": "registers and because it executes in the same address space as the",
    "start": "2162880",
    "end": "2168240"
  },
  {
    "text": "as the main the main thread it can go ahead and access memory and change memory very easily too",
    "start": "2168240",
    "end": "2174079"
  },
  {
    "text": "so virtually any instruction that you can think of can be emulated by this approach if the decrypter or the",
    "start": "2174079",
    "end": "2180960"
  },
  {
    "text": "encrypter understands what that instruction is doing so if you had a i don't know",
    "start": "2180960",
    "end": "2186560"
  },
  {
    "text": "an instruction that does law of eax um from edx times four plus some static address",
    "start": "2186560",
    "end": "2194800"
  },
  {
    "text": "if um if the by code analysis engine of shiva understands that instruction",
    "start": "2194800",
    "end": "2200640"
  },
  {
    "text": "and replaces it it can emulate it by looking at the register structure finding edx",
    "start": "2200640",
    "end": "2205760"
  },
  {
    "text": "multiplying it by four adding the static address to it and then dereferencing that address to get the value to put an",
    "start": "2205760",
    "end": "2211359"
  },
  {
    "text": "eax so um there are routines within shiva which do this and um",
    "start": "2211359",
    "end": "2218079"
  },
  {
    "text": "i think it's a fairly effective way to uh to make it harder to go ahead and",
    "start": "2218079",
    "end": "2223680"
  },
  {
    "text": "decrypt the shiva executable we encountered quite a few problems when trying to create shiva um",
    "start": "2223680",
    "end": "2231680"
  },
  {
    "text": "establishing the p trace link is a quite a hard thing to do or at least it's not very intuitive as to what it is",
    "start": "2231680",
    "end": "2238079"
  },
  {
    "text": "you need to do because when one process p traces another um there's",
    "start": "2238079",
    "end": "2244560"
  },
  {
    "text": "an exchange of signals between the two um and if two processes are trying to",
    "start": "2244560",
    "end": "2250079"
  },
  {
    "text": "p-trace each other um the signals being sent back and forth caused the uh the process to go into an",
    "start": "2250079",
    "end": "2256720"
  },
  {
    "text": "endless uh signal delivery loop because um the p trace api communicates the signals",
    "start": "2256720",
    "end": "2263040"
  },
  {
    "text": "that are sent uh to the tracing process so to establish this link you have to block",
    "start": "2263040",
    "end": "2269440"
  },
  {
    "text": "pretty much every signal and and then enable them after the link is",
    "start": "2269440",
    "end": "2274480"
  },
  {
    "text": "established another challenge that we encountered was how do you handle fork",
    "start": "2274480",
    "end": "2282560"
  },
  {
    "text": "because for a shiva executable to run you have to have uh the p-trace link",
    "start": "2282839",
    "end": "2288640"
  },
  {
    "text": "there and you have to have both threads running and if they're not there it's going to crash very very quickly so when a fork is encountered um",
    "start": "2288640",
    "end": "2298079"
  },
  {
    "text": "it has to be intercepted by shiva and the uh the cloning process has to be uh reestablished",
    "start": "2298079",
    "end": "2304160"
  },
  {
    "text": "so what shiva does is it um it patches into uh",
    "start": "2304160",
    "end": "2309680"
  },
  {
    "text": "the the fork uh routine within libsy and it intercepts any uh execution of",
    "start": "2309680",
    "end": "2316880"
  },
  {
    "text": "the fork system call and uh what it does is it runs the system call and then after that it",
    "start": "2316880",
    "end": "2322640"
  },
  {
    "text": "establishes the ptrace link in the clone process again",
    "start": "2322640",
    "end": "2327680"
  },
  {
    "text": "and once that's done the the forked the child can continue to execute without",
    "start": "2327680",
    "end": "2333280"
  },
  {
    "text": "any problems exec is a little bit different but it",
    "start": "2333280",
    "end": "2338800"
  },
  {
    "text": "also has to be handled if",
    "start": "2338800",
    "end": "2343280"
  },
  {
    "text": "if a program tries to execute another there's no need for shiva to be there in memory at all anymore so",
    "start": "2344079",
    "end": "2350000"
  },
  {
    "text": "when we encounter exec all we do is we undo the ptrace length get out of the",
    "start": "2350000",
    "end": "2355760"
  },
  {
    "text": "way of it and allow the exact to occur so that there's um no longer anything to the shiva within",
    "start": "2355760",
    "end": "2362320"
  },
  {
    "text": "the child process i mentioned this a little before also lipsy",
    "start": "2362320",
    "end": "2368000"
  },
  {
    "text": "lipsy makes programming a lot easier and if you're trying to do a lot of stuff without lipsy you have to rewrite a lot of those",
    "start": "2368000",
    "end": "2373599"
  },
  {
    "text": "routines for example trying to write a complex program without a malloc",
    "start": "2373599",
    "end": "2380160"
  },
  {
    "text": "is a major pain and what we ended up doing was implementing a small and very simple implementation",
    "start": "2380160",
    "end": "2386560"
  },
  {
    "text": "of malloc um which allows us to uh allocate dynamically sized buffers",
    "start": "2386560",
    "end": "2394320"
  },
  {
    "text": "and you can imagine trying to write a decrypter without having this available to you it's very very hard and almost impossible um",
    "start": "2394320",
    "end": "2401359"
  },
  {
    "text": "and of course we we replicate a lot of the simple routines within libsy that you use on a day-to-day basis too",
    "start": "2401359",
    "end": "2407119"
  },
  {
    "text": "so that was another challenge that we encountered um there are some limitations to shiva",
    "start": "2407119",
    "end": "2415839"
  },
  {
    "text": "first thing is it can't handle v4 and it definitely doesn't handle threads very well",
    "start": "2415839",
    "end": "2422720"
  },
  {
    "text": "v fork is just something we haven't taken the time to add and i'm sure we could add it very easily",
    "start": "2422720",
    "end": "2429920"
  },
  {
    "text": "and multi-threaded programs on unix are quite rare so i haven't really",
    "start": "2429920",
    "end": "2435119"
  },
  {
    "text": "seen a need to implement any support for threaded programs yet but that may change and we may have to",
    "start": "2435119",
    "end": "2441040"
  },
  {
    "text": "do that in the future i believe that apache can run multi-threaded although it definitely",
    "start": "2441040",
    "end": "2446560"
  },
  {
    "text": "doesn't by default i'm not sure what else can",
    "start": "2446560",
    "end": "2451599"
  },
  {
    "text": "and there's some very serious problems with uh p threads on linux so i don't really want to go there but we",
    "start": "2451599",
    "end": "2457920"
  },
  {
    "text": "may have to in the future on linux",
    "start": "2457920",
    "end": "2463599"
  },
  {
    "text": "exact fails if a shiva encrypted program tries to execute a set uid program",
    "start": "2463599",
    "end": "2469680"
  },
  {
    "text": "and this is because of the uh the p trace link this once again can be",
    "start": "2469680",
    "end": "2475839"
  },
  {
    "text": "bypassed but we haven't taken the time to do it yet um another limitation of",
    "start": "2475839",
    "end": "2480960"
  },
  {
    "text": "shiva right now is section headers it relies on suction headers and um",
    "start": "2480960",
    "end": "2486720"
  },
  {
    "text": "section headers are nice information to have an elf executable but they're not necessary all the necessary information",
    "start": "2486720",
    "end": "2492000"
  },
  {
    "text": "is in the program the program headers which which tell you which segments to map and load so you",
    "start": "2492000",
    "end": "2497200"
  },
  {
    "text": "don't need the section headers but shiva relies on them just because it's an easy way of getting information about the executable so in the future we'd like to",
    "start": "2497200",
    "end": "2504880"
  },
  {
    "text": "remove that dependency on section headers and make it work on virtually every",
    "start": "2504880",
    "end": "2510800"
  },
  {
    "text": "possible elf executable out there and this isn't really a big limitation",
    "start": "2510800",
    "end": "2517599"
  },
  {
    "text": "because any executable that you compile is going to have suction headers unless you take the",
    "start": "2517599",
    "end": "2523119"
  },
  {
    "text": "time to take them out uh every every executable on your linux distributions will have section headers",
    "start": "2523119",
    "end": "2529520"
  },
  {
    "text": "too so it's not a major problem but it's something that we'd uh like to uh eventually remove",
    "start": "2529520",
    "end": "2536240"
  },
  {
    "text": "we did plan to remove them by the next release that was a few months ago and we still haven't done it but we might get",
    "start": "2536240",
    "end": "2541359"
  },
  {
    "text": "around to doing these things i'll go into a demo right now",
    "start": "2541359",
    "end": "2547760"
  },
  {
    "text": "show you how shiva works and a little bit about how",
    "start": "2547839",
    "end": "2552640"
  },
  {
    "text": "a little bit about shiva in action here",
    "start": "2554079",
    "end": "2558599"
  },
  {
    "text": "okay um so what i have here is i have uh the binary release of shiva the one that",
    "start": "2567119",
    "end": "2573520"
  },
  {
    "text": "you have on your conference cd um actually the one you have in your conferences uh a copy of shiva that's",
    "start": "2573520",
    "end": "2579920"
  },
  {
    "text": "encrypted with itself so the first thing i'll do is just show you uh it's kind of neat that it can encrypt itself here um",
    "start": "2579920",
    "end": "2588400"
  },
  {
    "text": "just specify the executable to encrypt and let it go do its thing and um",
    "start": "2589040",
    "end": "2595280"
  },
  {
    "text": "we have a copy of shiva that's encrypted with itself there and let's see if it still runs",
    "start": "2595280",
    "end": "2601839"
  },
  {
    "text": "and yes it still does so um i thought it was kind of cool that an",
    "start": "2601839",
    "end": "2607200"
  },
  {
    "text": "executable can encrypt itself um when it comes to runtime binary encryption a lot of executables can be",
    "start": "2607200",
    "end": "2613280"
  },
  {
    "text": "used to or a lot of different runtime binary encryptions can be used on the same executable so you can chain one on top of another",
    "start": "2613280",
    "end": "2619520"
  },
  {
    "text": "and have i don't know five different binary encrypted used on the same exact table and a lot of them work that way",
    "start": "2619520",
    "end": "2626880"
  },
  {
    "text": "shiva is less likely to work that way because of all the anti-debugging stuff that it does and the dual ptrace link",
    "start": "2626880",
    "end": "2633280"
  },
  {
    "text": "and everything if you're looking to apply more than one binary encrypter on any given executable",
    "start": "2633280",
    "end": "2639280"
  },
  {
    "text": "you're probably best off trying to apply shiva last it's most likely to work there than anywhere else",
    "start": "2639280",
    "end": "2646560"
  },
  {
    "text": "but we can use shiva now to uh encrypt",
    "start": "2647280",
    "end": "2652800"
  },
  {
    "text": "does anyone have a request for a program um",
    "start": "2653200",
    "end": "2658079"
  },
  {
    "text": "lilo bash um i'll try uh something small first bin ls",
    "start": "2660319",
    "end": "2668640"
  },
  {
    "text": "um so it's created a encrypted encrypted version of ls here i don't know why",
    "start": "2668720",
    "end": "2674240"
  },
  {
    "text": "you'd want to do that but you can if you want that's the original version so it's",
    "start": "2674240",
    "end": "2679920"
  },
  {
    "text": "about 20 to 23k bigger so it's not significantly bigger",
    "start": "2679920",
    "end": "2686640"
  },
  {
    "text": "and it works as the original executable did if you want to try and",
    "start": "2689680",
    "end": "2696000"
  },
  {
    "text": "look at try some strings on it here",
    "start": "2696000",
    "end": "2700880"
  },
  {
    "text": "it's all garbage um there's nothing useful there so um",
    "start": "2702319",
    "end": "2707440"
  },
  {
    "text": "i know there are a lot of reverse engineers out there people think that they're reverse engineers because they use strings on binary so they get from",
    "start": "2707440",
    "end": "2713760"
  },
  {
    "text": "the wild and they see that it tries to open etsy password and they think they know what it does and",
    "start": "2713760",
    "end": "2721520"
  },
  {
    "text": "as you can see there's no useful information that you can obtain from strings here if you want to try and debug it with gdb",
    "start": "2722319",
    "end": "2730800"
  },
  {
    "text": "um",
    "start": "2730800",
    "end": "2733800"
  },
  {
    "text": "when she sees the sig trap and it just exits so um the anti-debugging picks up gdp very",
    "start": "2736160",
    "end": "2742240"
  },
  {
    "text": "well and makes it quite difficult to use gdp against this we can try s trace",
    "start": "2742240",
    "end": "2749520"
  },
  {
    "text": "and as you can see it dies right away too l trace would be exactly the same",
    "start": "2750960",
    "end": "2758079"
  },
  {
    "text": "um we can try adding a password to an executable maybe um",
    "start": "2758079",
    "end": "2765200"
  },
  {
    "text": "you can encrypt your shell",
    "start": "2767280",
    "end": "2770240"
  },
  {
    "text": "hold on one second here this laptop is horribly slow i had to",
    "start": "2773280",
    "end": "2779119"
  },
  {
    "text": "grab one out the door yesterday literally so uh bear with me here but the um",
    "start": "2779119",
    "end": "2785359"
  },
  {
    "text": "i don't know let's use my favorite password abc abc123 you can check my email with that if you",
    "start": "2785359",
    "end": "2790720"
  },
  {
    "text": "want and if um",
    "start": "2790720",
    "end": "2796400"
  },
  {
    "text": "you don't have the password i'll just type in something random here it just exits um",
    "start": "2796400",
    "end": "2803200"
  },
  {
    "text": "uh if you have that actual password",
    "start": "2803200",
    "end": "2807040"
  },
  {
    "text": "let's actually run a shell here you can't really tell but if i exit you'll see my uh my",
    "start": "2811520",
    "end": "2817599"
  },
  {
    "text": "terminal doesn't die so um that was kind of a bad thing to demo but",
    "start": "2817599",
    "end": "2823599"
  },
  {
    "text": "uh without a password um there's very little you can do to get around shiva um",
    "start": "2823599",
    "end": "2831520"
  },
  {
    "text": "i guess i can also show you what a uh an encrypted version of shiva",
    "start": "2831520",
    "end": "2836560"
  },
  {
    "text": "looks like when you try to disassemble it",
    "start": "2836560",
    "end": "2840078"
  },
  {
    "text": "i can get out of this here",
    "start": "2843280",
    "end": "2846319"
  },
  {
    "text": "i use ida which is pretty much the standard on uh for by our binary analysis um",
    "start": "2851359",
    "end": "2859200"
  },
  {
    "text": "first thing it tells you is the file contains meaningless or illegal section declarations oh you can't even see this",
    "start": "2859200",
    "end": "2865040"
  },
  {
    "text": "i'm sorry switch it back here",
    "start": "2865040",
    "end": "2871400"
  },
  {
    "text": "so uh that's the first thing it tells you right there um and it",
    "start": "2873280",
    "end": "2878319"
  },
  {
    "text": "older versions of ida used to just tell you that and it would just exit uh which i thought was pretty cool but",
    "start": "2878319",
    "end": "2883359"
  },
  {
    "text": "they fixed it since then and it goes ahead and it tries to disassemble the binary",
    "start": "2883359",
    "end": "2891119"
  },
  {
    "text": "and this is what you end up with you end up with three instructions a couple more down here",
    "start": "2892000",
    "end": "2899760"
  },
  {
    "text": "that looks like code and uh a whole bunch of junk data",
    "start": "2899760",
    "end": "2906000"
  },
  {
    "text": "this goes on forever um well let me show you the uh the jump into the instruction trick here um",
    "start": "2906000",
    "end": "2915520"
  },
  {
    "text": "if you look at i don't know if you can read this but at this point here the one that i've the instructions that i've highlighted in",
    "start": "2915520",
    "end": "2921119"
  },
  {
    "text": "yellow there it's jumping to uh that address plus one",
    "start": "2921119",
    "end": "2926160"
  },
  {
    "text": "and uh the following instruction is a five byte instruction mob eax uh some value",
    "start": "2926160",
    "end": "2932640"
  },
  {
    "text": "so that so ida interprets that instruction as being five bytes long",
    "start": "2932640",
    "end": "2937760"
  },
  {
    "text": "when in actuality uh you're jumping past the first byte which is insignificant into real code after that",
    "start": "2937760",
    "end": "2944079"
  },
  {
    "text": "so if you want to take the time to manually go and fix that you can try and do that",
    "start": "2944079",
    "end": "2949599"
  },
  {
    "text": "the next instruction is pop eax but to do this for an entire program is",
    "start": "2949599",
    "end": "2956319"
  },
  {
    "text": "very very tedious and not very feasible to do so",
    "start": "2956319",
    "end": "2963280"
  },
  {
    "text": "as you can see there's very little information you can gain from doing simple static analysis on a sheet of executable also um",
    "start": "2963280",
    "end": "2971720"
  },
  {
    "text": "i don't know what else i can show you about this here um",
    "start": "2972480",
    "end": "2976640"
  },
  {
    "text": "this i think this is code here that uh that passes off um control through the dynamic linker so that's the one part",
    "start": "2977599",
    "end": "2983119"
  },
  {
    "text": "that is decrypted but other than that there's very little information that you can actually gain",
    "start": "2983119",
    "end": "2988319"
  },
  {
    "text": "from looking at the file itself",
    "start": "2988319",
    "end": "2991680"
  },
  {
    "text": "so i'd like to take any questions if anyone has them right now",
    "start": "2993440",
    "end": "2999000"
  },
  {
    "text": "the question is does chiva modified libsy it does modify the the fork routine but",
    "start": "3006559",
    "end": "3013599"
  },
  {
    "text": "it does it within memory so it create places a jump instruction that points to a shiva routine within libsy fork",
    "start": "3013599",
    "end": "3020880"
  },
  {
    "text": "so um the modifications obviously i'm permanent but they have to be there for us to gain control",
    "start": "3020880",
    "end": "3027119"
  },
  {
    "text": "at any four yes sir",
    "start": "3027119",
    "end": "3030880"
  },
  {
    "text": "yes uh well not any formal analysis but just uh very qualitatively they do run slower",
    "start": "3035760",
    "end": "3042960"
  },
  {
    "text": "because uh it would be obvious i guess but um",
    "start": "3042960",
    "end": "3048880"
  },
  {
    "text": "as as you transition from one decrypted block to an encrypted lock and and so forth uh",
    "start": "3048880",
    "end": "3055119"
  },
  {
    "text": "there's a little bit of processing that has to be done plus there's an interrupt every time you do that so that slows it down you're not going to want to encrypt",
    "start": "3055119",
    "end": "3061280"
  },
  {
    "text": "your web server with shiva and run it because uh there would probably be a significant performance hit at that",
    "start": "3061280",
    "end": "3067200"
  },
  {
    "text": "level but for simple programs or programs that you're going to run at the console",
    "start": "3067200",
    "end": "3072800"
  },
  {
    "text": "it's not noticeable um and uh actually the more recent version of",
    "start": "3072800",
    "end": "3078079"
  },
  {
    "text": "shiva has a little bit more of a performance hit than previous versions because you can interrupt when you encounter a",
    "start": "3078079",
    "end": "3085040"
  },
  {
    "text": "crypt lock you also get an interrupt when you encounter an emulated instruction so there's a little bit",
    "start": "3085040",
    "end": "3090480"
  },
  {
    "text": "a little bit more of an overhead in the newer version of shiva and i do plan to add",
    "start": "3090480",
    "end": "3097680"
  },
  {
    "text": "um some sort of more intelligent way of picking the instructions that we emulate so that you don't end up with a",
    "start": "3097680",
    "end": "3105440"
  },
  {
    "text": "an instruction emulated within a loop that's executed over and over again generating an interrupt because that can cause a significant slowdown",
    "start": "3105440",
    "end": "3111839"
  },
  {
    "text": "and i think that we have the framework in place with the type of",
    "start": "3111839",
    "end": "3117520"
  },
  {
    "text": "code analysis that we're doing right now to detect those loops and detect those situations and not actually replace",
    "start": "3117520",
    "end": "3123680"
  },
  {
    "text": "those instructions but you can run into the rare case where uh",
    "start": "3123680",
    "end": "3129359"
  },
  {
    "text": "shiva has bad luck and happens to pick one of those when encrypting your executable and you can just run chief",
    "start": "3129359",
    "end": "3134800"
  },
  {
    "text": "against it again it'll pick something different and you won't have that problem yes",
    "start": "3134800",
    "end": "3141359"
  },
  {
    "text": "what is the process that it goes through when you enter the incorrect password",
    "start": "3142880",
    "end": "3149040"
  },
  {
    "text": "okay the question is what is the process that shiva goes through when you enter an uh an incorrect password um",
    "start": "3149040",
    "end": "3156480"
  },
  {
    "text": "we used to just let it crash and not go through any process and that's probably the safest thing to do but what it tries",
    "start": "3156480",
    "end": "3162480"
  },
  {
    "text": "to do is it decrypts a certain section of memory and tries to verify a tag that's there",
    "start": "3162480",
    "end": "3168000"
  },
  {
    "text": "so it encrypts a large block of uh itself and if a tag isn't at a certain location",
    "start": "3168000",
    "end": "3173920"
  },
  {
    "text": "a specific string that should be there then it knows that it's been decrypted wrong and it exits",
    "start": "3173920",
    "end": "3180319"
  },
  {
    "text": "and i guess that opens it up to certain attacks but i don't think it's really that significant and",
    "start": "3180319",
    "end": "3186720"
  },
  {
    "text": "you're not going to be using shiva for anything that sensitive i think so it's not really a big concern",
    "start": "3186720",
    "end": "3192160"
  },
  {
    "text": "yes um",
    "start": "3192160",
    "end": "3197680"
  },
  {
    "text": "they're not actually stored as data within the executable the there are routines that generate them and return",
    "start": "3197680",
    "end": "3203760"
  },
  {
    "text": "so these routines are called by shiva and they return a key which shiva uses to decrypt that lock",
    "start": "3203760",
    "end": "3209760"
  },
  {
    "text": "um so the thing we were trying to avoid was just leaving the keys there out there in",
    "start": "3209760",
    "end": "3214880"
  },
  {
    "text": "memory for anyone to grab and go ahead and decrypt the entire executable that would just be the worst thing so we tried to make it a little bit harder by",
    "start": "3214880",
    "end": "3220720"
  },
  {
    "text": "making these routines generate them at runtime and the routines themselves um",
    "start": "3220720",
    "end": "3226880"
  },
  {
    "text": "as i mentioned before try to bind themselves to a certain address so they might try to bind to address zero by eight zero eight one two three",
    "start": "3226880",
    "end": "3233760"
  },
  {
    "text": "four or something right within the exact world and they might look for data at i don't know a thousand bytes beyond",
    "start": "3233760",
    "end": "3239440"
  },
  {
    "text": "their location and use that and look like a thousand bytes back and use that and",
    "start": "3239440",
    "end": "3244960"
  },
  {
    "text": "the reason for that is to make it hard to take these routines out of the context of shiva and just generate the",
    "start": "3244960",
    "end": "3250480"
  },
  {
    "text": "the keys in another executable so um we've tried to make it harder to get that the keys but",
    "start": "3250480",
    "end": "3257280"
  },
  {
    "text": "i suppose it is possible to do yes",
    "start": "3257280",
    "end": "3263800"
  },
  {
    "text": "is",
    "start": "3268720",
    "end": "3271720"
  },
  {
    "text": "all right the question for those who didn't hear it was uh there's there's an inherent structure to yell off executables and",
    "start": "3286480",
    "end": "3295040"
  },
  {
    "text": "there's plaintext that you know will be at a certain location in memory and it will always be there and uh",
    "start": "3295040",
    "end": "3300400"
  },
  {
    "text": "that could be a weakness honestly plain text attacks weren't our biggest",
    "start": "3300400",
    "end": "3305440"
  },
  {
    "text": "worries and we haven't really done very much to try and uh discourage that um",
    "start": "3305440",
    "end": "3311520"
  },
  {
    "text": "simply because uh the key space is pretty large it's 128",
    "start": "3311520",
    "end": "3316559"
  },
  {
    "text": "bit and it's not going to be used or at least we don't think it's going to use for anything that's sensitive but uh i have used that",
    "start": "3316559",
    "end": "3324640"
  },
  {
    "text": "that specific thing to break some very weak elf encrypters out there like you know the entry point of a linux",
    "start": "3324640",
    "end": "3332240"
  },
  {
    "text": "x86 elf executable might have these four instructions to start",
    "start": "3332240",
    "end": "3337839"
  },
  {
    "text": "and if you know what the entry point is you can break some very weak elf encryptors out there",
    "start": "3337839",
    "end": "3344000"
  },
  {
    "text": "the encryption within shiva is not that weak and it's not something it's not like a simple xo or something stupid that you",
    "start": "3344000",
    "end": "3350079"
  },
  {
    "text": "could use to immediately break uh based on plain text yes",
    "start": "3350079",
    "end": "3356599"
  },
  {
    "text": "it shiva actually has nothing to do with iss other than the fact that i work at iss",
    "start": "3365119",
    "end": "3370960"
  },
  {
    "text": "you can get shiva off the uh sean was nice enough to host it on the secure reality website you can download it from there",
    "start": "3370960",
    "end": "3377920"
  },
  {
    "text": "so i'm not sure what the export restrictions are on it but it's downloaded downloadable from australia",
    "start": "3377920",
    "end": "3383119"
  },
  {
    "text": "so hopefully that doesn't affect us it's also on your conference cd so if",
    "start": "3383119",
    "end": "3390559"
  },
  {
    "text": "you want to get it from there that's fine and we should be putting up a new version on the secure reality website",
    "start": "3390559",
    "end": "3397680"
  },
  {
    "text": "within the next couple days that influence a couple new ideas so if you're interested look out for that",
    "start": "3397680",
    "end": "3405839"
  },
  {
    "text": "yes uh",
    "start": "3405839",
    "end": "3411359"
  },
  {
    "text": "i've had originally sean and i had originally promised to release the source code three months after the initial release",
    "start": "3411359",
    "end": "3416720"
  },
  {
    "text": "of shiva and we didn't do it",
    "start": "3416720",
    "end": "3421599"
  },
  {
    "text": "because i don't know that releasing the source code really",
    "start": "3422000",
    "end": "3427760"
  },
  {
    "text": "i mean it's a good educational experience for people who want to read it but it kind of invalidates all the work",
    "start": "3427760",
    "end": "3432960"
  },
  {
    "text": "that we've put into shiva and i'm doing a good enough job of doing that right now by talking about it and",
    "start": "3432960",
    "end": "3438960"
  },
  {
    "text": "outlining everything that it does the source code would make it even a lot easier",
    "start": "3438960",
    "end": "3444079"
  },
  {
    "text": "also uh uh i mean we may choose to release a source code in the future",
    "start": "3444079",
    "end": "3449839"
  },
  {
    "text": "i we haven't set like a clear date for that or anything i do want to clean up parts of it before we do any release because you know",
    "start": "3449839",
    "end": "3456079"
  },
  {
    "text": "everyone writes messy code sometimes but um we may in the future i don't know if we",
    "start": "3456079",
    "end": "3461839"
  },
  {
    "text": "will yet yes",
    "start": "3461839",
    "end": "3469480"
  },
  {
    "text": "yeah um we don't actually deal with anything at the kernel level because there's no",
    "start": "3486319",
    "end": "3493280"
  },
  {
    "text": "guarantee that you're running this route there's no guarantee you can actually verify any of that um using ld preload to load a library would",
    "start": "3493280",
    "end": "3500319"
  },
  {
    "text": "be a good way to start attacking chiva because we don't verify that yet either",
    "start": "3500319",
    "end": "3506319"
  },
  {
    "text": "but i think that maybe the next release i'm not sure if sean has added it yet or not",
    "start": "3506319",
    "end": "3512240"
  },
  {
    "text": "but if you want to attack it right now do that and it's a very good way to do it",
    "start": "3512240",
    "end": "3517440"
  },
  {
    "text": "sure yes",
    "start": "3517440",
    "end": "3522520"
  },
  {
    "text": "do you uh what do you mean by pre and post conditions on a specific function",
    "start": "3531040",
    "end": "3536318"
  },
  {
    "text": "oh i see um i hadn't thought about that um but the code analysis engine within",
    "start": "3536640",
    "end": "3542640"
  },
  {
    "text": "shiva can understand to within a with a lot of detail the",
    "start": "3542640",
    "end": "3549200"
  },
  {
    "text": "structure of executable and how it executes where this routine is called from and so on so you could potentially",
    "start": "3549200",
    "end": "3554640"
  },
  {
    "text": "insert code into an example that does that i hadn't really thought about that but it's a pretty interesting idea",
    "start": "3554640",
    "end": "3561119"
  },
  {
    "text": "any other questions yes",
    "start": "3563599",
    "end": "3567400"
  },
  {
    "text": "um the uh we the question is do we use any uh",
    "start": "3572160",
    "end": "3578319"
  },
  {
    "text": "anti-reverse engineering or anti-debugging methods on the controller code right um we try to use anti-debugging as early in",
    "start": "3578319",
    "end": "3585760"
  },
  {
    "text": "the decryption process as possible um we don't want to decrypt half the executable and then start running the anti-debugging to figure out something's",
    "start": "3585760",
    "end": "3591760"
  },
  {
    "text": "wrong so uh i think that there's there's anti-debugging in the very initial obfuscation layer which is the very",
    "start": "3591760",
    "end": "3597520"
  },
  {
    "text": "first thing and then there's more of it placed throughout the decrypter itself so um",
    "start": "3597520",
    "end": "3603280"
  },
  {
    "text": "there's no one specific specific place where you might look to go ahead and disable the anti-debugging we try to",
    "start": "3603280",
    "end": "3608319"
  },
  {
    "text": "make it a little bit harder by placing it throughout the execution process but we try to verify as early as possible",
    "start": "3608319",
    "end": "3613359"
  },
  {
    "text": "that it's not being p-traced and and someone hasn't attached a debugger",
    "start": "3613359",
    "end": "3618559"
  },
  {
    "text": "to it",
    "start": "3618559",
    "end": "3620880"
  },
  {
    "text": "the controller code itself isn't modified in any great detail so it's basically a static executable that we",
    "start": "3626799",
    "end": "3632880"
  },
  {
    "text": "put in there the only steps we take obfuscated are the the first initial obfuscation layer",
    "start": "3632880",
    "end": "3639040"
  },
  {
    "text": "but the version that's going to be released very soon version 0.97 in fact it might",
    "start": "3639040",
    "end": "3644400"
  },
  {
    "text": "actually be released now i'm not sure i haven't had a chance to actually get on the internet and check it but uh the",
    "start": "3644400",
    "end": "3649680"
  },
  {
    "text": "version that will be released uh adds some more steps to the the decrypter itself",
    "start": "3649680",
    "end": "3654880"
  },
  {
    "text": "such as removing uh removing static function calls",
    "start": "3654880",
    "end": "3661119"
  },
  {
    "text": "so if you wanted to reverse engineer and you wanted to see where a function call goes it goes through this complex and",
    "start": "3661119",
    "end": "3666640"
  },
  {
    "text": "obfuscated table that makes it very difficult to figure out um",
    "start": "3666640",
    "end": "3672880"
  },
  {
    "text": "exactly where the call is going so uh for example a call going through this function table itself will modify that",
    "start": "3672880",
    "end": "3679680"
  },
  {
    "text": "table so it changes on on a call by call basis and that requires some understanding of",
    "start": "3679680",
    "end": "3686720"
  },
  {
    "text": "uh how the decryptor works and the state of the script at any point but that should go a certain way to make the",
    "start": "3686720",
    "end": "3692960"
  },
  {
    "text": "decrypter hard to reverse engineer",
    "start": "3692960",
    "end": "3696920"
  },
  {
    "text": "any other questions i can answer okay thank you for your time",
    "start": "3698400",
    "end": "3706759"
  },
  {
    "text": "you",
    "start": "6155679",
    "end": "6157760"
  }
]