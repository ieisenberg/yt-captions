[
  {
    "text": "[Music]",
    "start": "2230",
    "end": "5310"
  },
  {
    "text": "all right thanks for coming out here listening to me talk today I'm going to be talking about a mitigation that we",
    "start": "7820",
    "end": "14759"
  },
  {
    "text": "built at Microsoft and are now rolling out called castguard uh before I talk about",
    "start": "14759",
    "end": "20880"
  },
  {
    "text": "exactly how castguard works oh great my clicker won't work now um",
    "start": "20880",
    "end": "27320"
  },
  {
    "text": "okay uh yeah I just want to talk a little bit about the the problem space that we're working in because when you",
    "start": "30240",
    "end": "35520"
  },
  {
    "text": "hear people talk about building mitigations oftentimes they're talking about one of two things they're either talking about building mitigations that",
    "start": "35520",
    "end": "42239"
  },
  {
    "text": "kill exploit techniques or they're talking about building mitigations that kill bugs and at Microsoft we've",
    "start": "42239",
    "end": "48239"
  },
  {
    "text": "certainly spent a lot of time working on both of these but in recent years we've",
    "start": "48239",
    "end": "53340"
  },
  {
    "text": "not been quite as excited about building mitigations to kill exploit techniques primarily because there's very ambiguous",
    "start": "53340",
    "end": "59399"
  },
  {
    "text": "long-term value these sort of mitigations are typically far enough away from the bugs themselves that you",
    "start": "59399",
    "end": "66420"
  },
  {
    "text": "can work around the mitigations and the the trade-offs that you end up",
    "start": "66420",
    "end": "71820"
  },
  {
    "text": "making with these sorts of mitigations are just getting increasingly uglier and uglier there's lots of performance",
    "start": "71820",
    "end": "77640"
  },
  {
    "text": "concerns compatibility concerns um and so it's it's kind of unclear how",
    "start": "77640",
    "end": "82920"
  },
  {
    "text": "many more opportunities there are to really build meaningful impactful exploit mitigations",
    "start": "82920",
    "end": "89180"
  },
  {
    "text": "uh and that's why we've been working a lot more recently on killing bugs and",
    "start": "89520",
    "end": "94860"
  },
  {
    "text": "we've been working on killing bugs in a number of different ways sandboxing removing attack surface eliminating",
    "start": "94860",
    "end": "101579"
  },
  {
    "text": "vulnerability classes which is one of the things I'm going to be talking about today or just investigating safer uh you",
    "start": "101579",
    "end": "108299"
  },
  {
    "text": "know safer programming languages things like rust c-sharp Etc um",
    "start": "108299",
    "end": "115159"
  },
  {
    "text": "foreign but even though we're investigating all this stuff we realize that we are still",
    "start": "115680",
    "end": "121200"
  },
  {
    "text": "going to have lots of privileged CNC plus plus code for quite a while and so",
    "start": "121200",
    "end": "128399"
  },
  {
    "text": "we need something to do for that code because we don't want to just uh leave it out there unprotected",
    "start": "128399",
    "end": "134400"
  },
  {
    "text": "and when it comes to memory safety vulnerability specifically in CNC plus plus there's four big buckets that are",
    "start": "134400",
    "end": "141540"
  },
  {
    "text": "responsible for most of the bugs we end up seeing there are spatial safety issues like buffer overflows there's not",
    "start": "141540",
    "end": "147360"
  },
  {
    "text": "initialized memory there is type confusion and there's use after free bugs and uh this this graph here is really",
    "start": "147360",
    "end": "154620"
  },
  {
    "text": "just to illustrate that um type confusion is a predominant bug category",
    "start": "154620",
    "end": "160379"
  },
  {
    "text": "for us I kind of highlighted it in uh in red here but it's this big blue category here in the past couple past year or two",
    "start": "160379",
    "end": "168000"
  },
  {
    "text": "we haven't seen quite as many of those bugs but um but in general we do see quite a few",
    "start": "168000",
    "end": "173400"
  },
  {
    "text": "type confusion issues uh come through year after year now I'm not endorsing uh necessarily any",
    "start": "173400",
    "end": "181019"
  },
  {
    "text": "of the Technologies on this slide but I just want to illustrate that for some of these different bug classes there are",
    "start": "181019",
    "end": "187260"
  },
  {
    "text": "solutions out there you know maybe those Solutions aren't necessarily easy to deploy or even possible to deploy but",
    "start": "187260",
    "end": "193500"
  },
  {
    "text": "there is a lot of research being done for how we can deterministically mitigate a lot of",
    "start": "193500",
    "end": "199800"
  },
  {
    "text": "these bug classes but type confusion is one where there is not a whole lot of",
    "start": "199800",
    "end": "205080"
  },
  {
    "text": "research into or or practical solutions from my perspective into how do you deterministically mitigate this bug",
    "start": "205080",
    "end": "211140"
  },
  {
    "text": "class uh in a way that you can just broadly roll out the the mitigation across large amounts of code",
    "start": "211140",
    "end": "219620"
  },
  {
    "text": "and the issue with type confusion is really that it comes in so many different flavors and unlike a lot of",
    "start": "220260",
    "end": "226799"
  },
  {
    "text": "other types of memory safety issues where there's a clear contract that's being violated like in the case of use",
    "start": "226799",
    "end": "232379"
  },
  {
    "text": "after freeze you're using an object after it has been deallocated so there's a contract you're breaking in the case",
    "start": "232379",
    "end": "239519"
  },
  {
    "text": "of type confusion you're not really breaking any clear contract you're really just misinterpreting data Maybe",
    "start": "239519",
    "end": "246959"
  },
  {
    "text": "you downcast something incorrectly and then you you know use fields of a validly allocated and inbounds object",
    "start": "246959",
    "end": "253980"
  },
  {
    "text": "but you're just using fields that aren't actually what you think they are similar thing with unions you might use the",
    "start": "253980",
    "end": "260459"
  },
  {
    "text": "wrong field of a union but it is live memory it is an inbounds memory access you're just interpreting it wrong",
    "start": "260459",
    "end": "266940"
  },
  {
    "text": "so it's hard to generically solve type confusion because it really comes down to understanding the programmer intent",
    "start": "266940",
    "end": "273540"
  },
  {
    "text": "if you want to mitigate it you need to understand is is the developer actually actually accessing data in the correct",
    "start": "273540",
    "end": "279780"
  },
  {
    "text": "way or not and that's that's very difficult and and memory type confusion is",
    "start": "279780",
    "end": "285540"
  },
  {
    "text": "particularly concerning because it gives really strong Primitives to attackers and it allows you to bypass some of the",
    "start": "285540",
    "end": "292560"
  },
  {
    "text": "mitigations like memory tagging for example that I mentioned on the previous slide also could you know potentially",
    "start": "292560",
    "end": "298560"
  },
  {
    "text": "allow you to work around Sherry or other Hardware solutions that people are working on and so it is a fairly",
    "start": "298560",
    "end": "304080"
  },
  {
    "text": "important bug class to do research into so what I'm going to talk today about is",
    "start": "304080",
    "end": "309780"
  },
  {
    "text": "castguard and casguard aims at solving a legal static downcasts and so I thought",
    "start": "309780",
    "end": "314880"
  },
  {
    "text": "maybe we should just make sure everyone's on the same page about what is an illegal static downcast so in C",
    "start": "314880",
    "end": "320460"
  },
  {
    "text": "plus plus you can build class hierarchies that have inheritance and in this example here you might create a dog",
    "start": "320460",
    "end": "327600"
  },
  {
    "text": "object and you up cast it to be the point of that dog object is stored in an",
    "start": "327600",
    "end": "333180"
  },
  {
    "text": "animal pointer and then you downcast it to be a cat but a cat is not a dog so",
    "start": "333180",
    "end": "339419"
  },
  {
    "text": "that's an illegal static downcast you you casted this base pointer down to the wrong derived type",
    "start": "339419",
    "end": "347360"
  },
  {
    "text": "and some of you that are familiar with C plus plus might be thinking well hey you know you don't even need to give this",
    "start": "348539",
    "end": "353880"
  },
  {
    "text": "talk because there's already a solution for this problem just use Dynamic cast it's part of the C plus plus language and that will do uh checking for you",
    "start": "353880",
    "end": "362340"
  },
  {
    "text": "when you do downcasts but the issue is that Dynamic cast is a very hard thing",
    "start": "362340",
    "end": "367380"
  },
  {
    "text": "to just generically apply to a huge code base because in order for dynamic cast",
    "start": "367380",
    "end": "372900"
  },
  {
    "text": "to work the code that creates the object needs to enable runtime type information or rtti",
    "start": "372900",
    "end": "379259"
  },
  {
    "text": "and on an operating system like Windows we have no control over large amounts of",
    "start": "379259",
    "end": "385560"
  },
  {
    "text": "the code that runs on the platform and so we can't enforce that they turned rtti on and if you try to Dynamic cast",
    "start": "385560",
    "end": "391740"
  },
  {
    "text": "an object that was created without our TTI your program ends up crashing",
    "start": "391740",
    "end": "397500"
  },
  {
    "text": "and so Dynamic cast is very difficult or really impossible to just deploy at",
    "start": "397500",
    "end": "402900"
  },
  {
    "text": "skill across a huge code base rtt rtti itself is not used by many people",
    "start": "402900",
    "end": "409620"
  },
  {
    "text": "because it causes lots of binary sized bloat like in one of our dlls for example uh turning rtti on is over an 80",
    "start": "409620",
    "end": "417780"
  },
  {
    "text": "binary size regression that's huge you're almost doubling the size of your binaries by turning this on",
    "start": "417780",
    "end": "423960"
  },
  {
    "text": "and dynamic cast checks themselves also have a lot of overhead and when we're",
    "start": "423960",
    "end": "429120"
  },
  {
    "text": "talking about doing downcasts in C plus plus this is an operation that is typically free there is no code",
    "start": "429120",
    "end": "435240"
  },
  {
    "text": "generation that happens when you do a downcast it just changes how the compiler allows you to interpret that",
    "start": "435240",
    "end": "441360"
  },
  {
    "text": "data and so Dynamic cast having a lot of overhead can be kind of problematic",
    "start": "441360",
    "end": "447660"
  },
  {
    "text": "and just as an example there's a lot of assembly here obviously we can't actually read this assembly it's way too",
    "start": "447660",
    "end": "453300"
  },
  {
    "text": "small but I just did a test to see what actually gets executed when you do a",
    "start": "453300",
    "end": "458520"
  },
  {
    "text": "dynamic cast on a very simple class hierarchy single inheritance class hierarchy you have 12 stores 30 loads 12",
    "start": "458520",
    "end": "467400"
  },
  {
    "text": "jumps and two calls that end up being made and that's that's in the happy path where the cast is going to succeed so",
    "start": "467400",
    "end": "474000"
  },
  {
    "text": "this is a tremendous amount of code that ends up running and it might be possible for us to do some work on the dynamic",
    "start": "474000",
    "end": "479819"
  },
  {
    "text": "cast implementation and optimize some of it away but you still end up with this dependency on rtti that you can't get",
    "start": "479819",
    "end": "486240"
  },
  {
    "text": "out of so that brings us to cascard and I I",
    "start": "486240",
    "end": "492660"
  },
  {
    "text": "just want to call out that this is actually inspired from a clang feature that F sanitized CFI derived cast",
    "start": "492660",
    "end": "499199"
  },
  {
    "text": "feature um we we took that feature as inspiration and just really optimized it",
    "start": "499199",
    "end": "504900"
  },
  {
    "text": "like crazy and and that's what I'm here to talk about so here's the concept if you want to",
    "start": "504900",
    "end": "511440"
  },
  {
    "text": "protect against illegal static downcasting you need some way to identify what the type of the object is",
    "start": "511440",
    "end": "516479"
  },
  {
    "text": "that is being downcasted you don't know what it is statically at compile time so you need to be able to check at runtime",
    "start": "516479",
    "end": "521940"
  },
  {
    "text": "but we can't add identifiers into objects generically",
    "start": "521940",
    "end": "527240"
  },
  {
    "text": "because that breaks that that changes the object layout and so it's an ABI breaking change it's it's similar to",
    "start": "527240",
    "end": "533880"
  },
  {
    "text": "requiring rtti uh but for objects that already have virtual functions those",
    "start": "533880",
    "end": "539100"
  },
  {
    "text": "objects already have an identifier which is the V table pointer that the object contains we can actually use that to",
    "start": "539100",
    "end": "545279"
  },
  {
    "text": "uniquely identify objects and so now that we have an identifier that is just already baked into objects",
    "start": "545279",
    "end": "552060"
  },
  {
    "text": "that actually gives us a way that we could do checks on downcasts to see if",
    "start": "552060",
    "end": "557580"
  },
  {
    "text": "they're legal or not without breaking the Abi and so that allows us to just",
    "start": "557580",
    "end": "562800"
  },
  {
    "text": "automatically convert all of the existing static downcasts that we have in our code into cascard protected",
    "start": "562800",
    "end": "569100"
  },
  {
    "text": "downcasts foreign so I am not like a C plus plus language",
    "start": "569100",
    "end": "576240"
  },
  {
    "text": "lawyer or anything I don't know how C plus plus people necessarily talk about some of this terminology but for the",
    "start": "576240",
    "end": "582839"
  },
  {
    "text": "sake of this presentation I want to tell you how I talk about the the code that we're going to be looking at so I call",
    "start": "582839",
    "end": "590339"
  },
  {
    "text": "the type that you are downcasting to the left hand side type and I call it",
    "start": "590339",
    "end": "595980"
  },
  {
    "text": "the left hand side type because it's on the left hand side of the expression very creative right and I call the right",
    "start": "595980",
    "end": "603300"
  },
  {
    "text": "hand side type the type that you statically declare the",
    "start": "603300",
    "end": "609360"
  },
  {
    "text": "right hand type of right hand side of the expression to B so in this case we're downcasting something that is",
    "start": "609360",
    "end": "616200"
  },
  {
    "text": "statically declared as an animal to be a cat so I would say the right hand side type is animal",
    "start": "616200",
    "end": "622620"
  },
  {
    "text": "and then the underlying type is the the actual type of the object that you're casting and we don't know that",
    "start": "622620",
    "end": "628740"
  },
  {
    "text": "statically at compile time we can only know that at runtime",
    "start": "628740",
    "end": "633260"
  },
  {
    "text": "so castguard has a few requirements that it's it's useful to discuss before we talk about how the mitigation works just",
    "start": "635519",
    "end": "641160"
  },
  {
    "text": "so you aren't left wondering code needs to be compiled with link time code generation because we need a full world",
    "start": "641160",
    "end": "647519"
  },
  {
    "text": "view of all the code in the binary to actually understand all the different objects in play and all the different",
    "start": "647519",
    "end": "652620"
  },
  {
    "text": "casts that are going on the objects obviously need to have a v table because that's the identifier that",
    "start": "652620",
    "end": "657959"
  },
  {
    "text": "we're using we also assume that the object itself is valid so if you have another memory",
    "start": "657959",
    "end": "664920"
  },
  {
    "text": "safety vulnerability like you have a buffer overflow and you're able to use that to corrupt an object cascard isn't",
    "start": "664920",
    "end": "670260"
  },
  {
    "text": "going to provide you protection anymore because cascard isn't the first vulnerability in play cascard is really",
    "start": "670260",
    "end": "676019"
  },
  {
    "text": "just designed to protect against vulnerabilities where the issue itself is that you're just doing a bad downcast",
    "start": "676019",
    "end": "683880"
  },
  {
    "text": "so if you're able to corrupt memory in other ways before you get to a cast all bets are off",
    "start": "683880",
    "end": "690139"
  },
  {
    "text": "all right so let's talk about let's talk about how castguard works and the best way to the the best way to explain how",
    "start": "690839",
    "end": "696600"
  },
  {
    "text": "cascard works I think is just to look at examples of what we actually do so what does the compiler know if you",
    "start": "696600",
    "end": "704040"
  },
  {
    "text": "look at a piece of code like this the compiler knows that it's a static downcast and even if you didn't actually",
    "start": "704040",
    "end": "709079"
  },
  {
    "text": "use static cast you just did a c style cast where you just you know used parentheses and put the type that you",
    "start": "709079",
    "end": "714660"
  },
  {
    "text": "want to cast to the compiler actually still knows that it's a static downcast um",
    "start": "714660",
    "end": "720120"
  },
  {
    "text": "so we track that we know where the V table pointer in the object is and we",
    "start": "720120",
    "end": "725880"
  },
  {
    "text": "know where the V tables themselves are going to get laid out in the binary so we know that cat's V table is at offset",
    "start": "725880",
    "end": "731519"
  },
  {
    "text": "500 into the binary or you know dogs V table is an offset a thousand to the binary we know where everything is",
    "start": "731519",
    "end": "738920"
  },
  {
    "text": "and if you look at how an object is laid out in C plus what you end up seeing here is that um",
    "start": "739800",
    "end": "747779"
  },
  {
    "text": "in in the case of the the base object here in this diagram a the way that an a",
    "start": "747779",
    "end": "753180"
  },
  {
    "text": "object is laid out is you'll have the AV table pointer at the beginning of the object and then you have A's member",
    "start": "753180",
    "end": "758519"
  },
  {
    "text": "variables that come after that V table pointer and very important to C plus plus having",
    "start": "758519",
    "end": "763620"
  },
  {
    "text": "good performance is that when you inherit from a really all that happens is that the next object down the chain B",
    "start": "763620",
    "end": "771240"
  },
  {
    "text": "for example just has a copy of a right at the beginning of it and then any new member variables that b",
    "start": "771240",
    "end": "778200"
  },
  {
    "text": "introduces just get tacked onto the end and if you look at the V table itself for object B it will start with all of",
    "start": "778200",
    "end": "786300"
  },
  {
    "text": "the virtual functions that a introduced and this is what allows you to do up",
    "start": "786300",
    "end": "791639"
  },
  {
    "text": "casts and downcasts in C plus plus without actually requiring code like new",
    "start": "791639",
    "end": "797760"
  },
  {
    "text": "code generation to be added to the binary you can take that same pointer and interpret it as an A or as a b",
    "start": "797760",
    "end": "804839"
  },
  {
    "text": "because the layout is is structured so that um so that that sort of thing works if you have a b pointer the a member",
    "start": "804839",
    "end": "812160"
  },
  {
    "text": "variables are you know at a fixed offset in that pointer",
    "start": "812160",
    "end": "816620"
  },
  {
    "text": "so with castguard since we're using V tables as a way to identify the object you really need to think about things in",
    "start": "818279",
    "end": "824639"
  },
  {
    "text": "terms of the V table view of the world this was like one of the biggest uh like cognitive shifts for me to wrap my head",
    "start": "824639",
    "end": "831300"
  },
  {
    "text": "around I kept trying to think about checking for the validity of casts just in terms of the classes that were in",
    "start": "831300",
    "end": "838019"
  },
  {
    "text": "play but I really needed to be thinking about what are the V tables in play and",
    "start": "838019",
    "end": "843240"
  },
  {
    "text": "so if you have a class hierarchy like the one on the left here the V table hierarchy would be on the right and I",
    "start": "843240",
    "end": "850019"
  },
  {
    "text": "have the the mangled names that the compiler uses but this hierarchy effectively looks",
    "start": "850019",
    "end": "856380"
  },
  {
    "text": "identical to the the normal class hierarchy because this is a very simple single inheritance case but the compiler",
    "start": "856380",
    "end": "862740"
  },
  {
    "text": "does track V tables just like classes so the compiler knows this is the the base V table this BV table inherits from a",
    "start": "862740",
    "end": "870120"
  },
  {
    "text": "the CV table inherits from B the compiler tracks all these relationships",
    "start": "870120",
    "end": "875959"
  },
  {
    "text": "and so conceptually if you want to do a a cast check it's actually not extremely",
    "start": "877200",
    "end": "883920"
  },
  {
    "text": "complicated you end up building a table kind of in your head about hey if I want to downcast to something of type c",
    "start": "883920",
    "end": "891540"
  },
  {
    "text": "what would the what V tables would a type c be allowed to have and the V tables that a type c would be",
    "start": "891540",
    "end": "898920"
  },
  {
    "text": "allowed to have our C's V table and then anything that inherits from C and in this example and",
    "start": "898920",
    "end": "905699"
  },
  {
    "text": "this is the example that I'm going to use going for for all the rest of the slides is I'm going to be downcasting to it to something of type c the the V",
    "start": "905699",
    "end": "913440"
  },
  {
    "text": "tables that are allowed are c e and f so there's three V tables that an object of",
    "start": "913440",
    "end": "919440"
  },
  {
    "text": "type c would be allowed to have foreign",
    "start": "919440",
    "end": "925860"
  },
  {
    "text": "so you can build a check pretty easily for this if the compiler sees a static",
    "start": "925860",
    "end": "931199"
  },
  {
    "text": "cast and it's a downcast to something of type c all you're really doing is you're going to read the V table out of that",
    "start": "931199",
    "end": "937320"
  },
  {
    "text": "object first you need to check if the object is null you're allowed to always static",
    "start": "937320",
    "end": "942600"
  },
  {
    "text": "downcast to null pointer so if the object is null you let the cast happen if the object isn't null you read the V",
    "start": "942600",
    "end": "947760"
  },
  {
    "text": "table pointer out of it and then you check is this V table pointer the CV table the EV table or the Fe table and",
    "start": "947760",
    "end": "954899"
  },
  {
    "text": "if it is then the cast is allowed to succeed but you probably look at this and you think okay this would be an absolute",
    "start": "954899",
    "end": "962160"
  },
  {
    "text": "performance disaster right what if you had a class hierarchy with like a thousand different classes in it and you",
    "start": "962160",
    "end": "967560"
  },
  {
    "text": "have to sit there just chugging along through every different V table that that might be allowed this would be way",
    "start": "967560",
    "end": "973380"
  },
  {
    "text": "worse than Dynamic cast so clearly this isn't actually a scalable solution it's",
    "start": "973380",
    "end": "978480"
  },
  {
    "text": "just to help us understand the concept so if we want to build a scalable",
    "start": "978480",
    "end": "983820"
  },
  {
    "text": "solution we need to get a little bit trickier so the first thing that we're going to do is we're going to lay out all the V tables that might be used in",
    "start": "983820",
    "end": "990420"
  },
  {
    "text": "one of these cast checks together and I put them inside of a region in the binary that I just call the cascard V",
    "start": "990420",
    "end": "996180"
  },
  {
    "text": "table region very creative naming um one thing that I would like to call out is that the cascard V table region",
    "start": "996180",
    "end": "1003800"
  },
  {
    "text": "starts with a global variable and ends with a global variable so there's a global variable called cascard V table",
    "start": "1003800",
    "end": "1009019"
  },
  {
    "text": "start and a global variable called cascard V table end and those will be important a couple slides later but just",
    "start": "1009019",
    "end": "1015380"
  },
  {
    "text": "remember that for now so we don't give any particular ordering to these V tables we just kind of shove them all together in this region",
    "start": "1015380",
    "end": "1022459"
  },
  {
    "text": "and then we're going to create some bitmaps so this is the same diagram that I had before it's just on it it just",
    "start": "1022459",
    "end": "1029780"
  },
  {
    "text": "illustrates you know on the left hand side of the diagram is the type that you're casting to and then you get a",
    "start": "1029780",
    "end": "1036199"
  },
  {
    "text": "check mark for any V table that's allowed for that type and then on on the the left hand side of",
    "start": "1036199",
    "end": "1041480"
  },
  {
    "text": "the slide I have the order that these different V tables are laid out so a b c d e f g h that's",
    "start": "1041480",
    "end": "1047540"
  },
  {
    "text": "the order that we decided to lay the V tables out in but once we know what",
    "start": "1047540",
    "end": "1053960"
  },
  {
    "text": "uh V tables are allowed for any particular type we go and we start building bitmaps and you build one bitmap for every type that you might",
    "start": "1053960",
    "end": "1060799"
  },
  {
    "text": "downcast to and the way that you create the bitmap is first you need to choose what I call",
    "start": "1060799",
    "end": "1066380"
  },
  {
    "text": "the base V table and the base V table is just going to be the V table that is",
    "start": "1066380",
    "end": "1072620"
  },
  {
    "text": "closest to the beginning of the binary that is allowed for that particular cast",
    "start": "1072620",
    "end": "1078679"
  },
  {
    "text": "so in this example that that I've been using where we're downcasting to something of type c",
    "start": "1078679",
    "end": "1084320"
  },
  {
    "text": "the the V table that is closest to the beginning of the binary is the CV table so that will be our base",
    "start": "1084320",
    "end": "1091100"
  },
  {
    "text": "and then you compute the offset between That Base V table and all the other V tables that are allowed for the cast so",
    "start": "1091100",
    "end": "1097700"
  },
  {
    "text": "one offset will be zero because the CV table is is allowed for the cast right but any other V tables so E and F you",
    "start": "1097700",
    "end": "1105559"
  },
  {
    "text": "compute the offsets and then you end up constructing a bitmap and here's what the bitmap ends",
    "start": "1105559",
    "end": "1111860"
  },
  {
    "text": "up looking like for for the CV table is every index in that bitmap in this case",
    "start": "1111860",
    "end": "1119059"
  },
  {
    "text": "represents an eight byte offset from the base and you put a 1 in there if",
    "start": "1119059",
    "end": "1125480"
  },
  {
    "text": "that particular offset is legal to cast and you put a zero if that particular offset is illegal to cast",
    "start": "1125480",
    "end": "1132380"
  },
  {
    "text": "and so when you want to use this bitmap what you end up doing at runtime",
    "start": "1132380",
    "end": "1137780"
  },
  {
    "text": "is you compute the difference the delta between That Base V table which we know",
    "start": "1137780",
    "end": "1143360"
  },
  {
    "text": "statically at compile time the base V table will be the CV table you can be the Delta between that and",
    "start": "1143360",
    "end": "1150020"
  },
  {
    "text": "the objects V table that you read at runtime and you figure out how many bytes apart are these things",
    "start": "1150020",
    "end": "1155780"
  },
  {
    "text": "and then depending on the the alignment of the bitmap in this case the bitmap every every index in the bitmap",
    "start": "1155780",
    "end": "1162020"
  },
  {
    "text": "represents eight bytes so we shift out some of the low bits of that Delta and now we have an offset or an ordinal",
    "start": "1162020",
    "end": "1170360"
  },
  {
    "text": "and you can use that to go and look up in the bitmap to see hey is this bit a one or a zero",
    "start": "1170360",
    "end": "1177760"
  },
  {
    "text": "and you end up doing this for all of the different types that you might downcast to so you don't need to create a bitmap if",
    "start": "1177799",
    "end": "1184460"
  },
  {
    "text": "some particular type is never downcast to there's no reason because the bitmap will never be referenced it's just going",
    "start": "1184460",
    "end": "1189740"
  },
  {
    "text": "to take up space in the binary um another thing worth noting is that in this in these examples I have each bit",
    "start": "1189740",
    "end": "1196400"
  },
  {
    "text": "in the bitmap representing an eight byte offset but it doesn't need to be an 8 byte offset if your V tables are really",
    "start": "1196400",
    "end": "1202700"
  },
  {
    "text": "big then we can go and make the um you know each each bit in the bitmap",
    "start": "1202700",
    "end": "1207740"
  },
  {
    "text": "represents 64 bytes or 128 bytes or however many bytes we want to so it's totally flexible",
    "start": "1207740",
    "end": "1214899"
  },
  {
    "text": "okay so there's a lot of code here now but but basically this is just the improved check where rather than having",
    "start": "1216080",
    "end": "1222740"
  },
  {
    "text": "a big if statement that kind of Loops through every single possible V table to check for validity instead what we're",
    "start": "1222740",
    "end": "1228679"
  },
  {
    "text": "doing is we just we compute the Delta between the base V table and the objects V table at runtime",
    "start": "1228679",
    "end": "1235460"
  },
  {
    "text": "shift out some bits to compute an index we do a range check to make sure that",
    "start": "1235460",
    "end": "1240500"
  },
  {
    "text": "index is actually in balance of the bitmap if the index is so big that it's not even imbalance of the bitmap then",
    "start": "1240500",
    "end": "1246320"
  },
  {
    "text": "you know the cast is illegal and if it is in Balance then you do the bit test and if the bid is a one the",
    "start": "1246320",
    "end": "1252620"
  },
  {
    "text": "cast is allowed if it's a zero the cast isn't allowed so this is a lot better this this cash check ends up scaling pretty well it",
    "start": "1252620",
    "end": "1260240"
  },
  {
    "text": "doesn't matter how many V tables you have really it still is a pretty",
    "start": "1260240",
    "end": "1265460"
  },
  {
    "text": "constant time operation that you're doing but it turns out we can actually do even better than this",
    "start": "1265460",
    "end": "1271520"
  },
  {
    "text": "the bitmap is still not perfect because bitmap requires an extra memory load",
    "start": "1271520",
    "end": "1277100"
  },
  {
    "text": "that you're doing and it's a Memory load that might be in memory that isn't super hot so it could take time",
    "start": "1277100",
    "end": "1284000"
  },
  {
    "text": "okay so if we want to do better then instead of laying the V tables out using just a random ordering we're actually",
    "start": "1284000",
    "end": "1291260"
  },
  {
    "text": "going to lay the V tables out using a depth first ordering so it's kind of like a depth first search I guess but",
    "start": "1291260",
    "end": "1297080"
  },
  {
    "text": "we're not actually searching for anything but you lay out the AV table and then the BV table c e go back up F",
    "start": "1297080",
    "end": "1304280"
  },
  {
    "text": "go back up to B DV table G and then H so we lay the V",
    "start": "1304280",
    "end": "1309559"
  },
  {
    "text": "tables out in this order and you might have a bunch of different V table hierarchies in your binary and the order",
    "start": "1309559",
    "end": "1315140"
  },
  {
    "text": "that different hierarchies are laid out relative to one another doesn't matter it just matters how the V tables in any",
    "start": "1315140",
    "end": "1321980"
  },
  {
    "text": "particular hierarchy are laid out relative to the other view tables in that hierarchy",
    "start": "1321980",
    "end": "1327940"
  },
  {
    "text": "okay so then once again you might go ahead and just kind of intuitively you create bitmaps but one of the things",
    "start": "1328159",
    "end": "1335000"
  },
  {
    "text": "that you end up noticing when we create the bitmaps this time is that when you lay the V tables out using this depth",
    "start": "1335000",
    "end": "1340940"
  },
  {
    "text": "first ordering you never have a situation where you have two V tables",
    "start": "1340940",
    "end": "1347000"
  },
  {
    "text": "that are legal for a cast and a v table that's not legal for the cast in between them all the tables that are legal for any",
    "start": "1347000",
    "end": "1354080"
  },
  {
    "text": "particular cast are laid out linearly next to one another",
    "start": "1354080",
    "end": "1360500"
  },
  {
    "text": "and because they're laid out next to one another you don't actually need to look up in the bitmap to see if the bitmap is",
    "start": "1360500",
    "end": "1367760"
  },
  {
    "text": "a one or a zero if the range check passed in that example then you would",
    "start": "1367760",
    "end": "1373460"
  },
  {
    "text": "know that the bitmap itself contains a one right so you don't even need to look at the bitmap",
    "start": "1373460",
    "end": "1378559"
  },
  {
    "text": "and you can actually take this even further and you can say you don't even need to compute the ordinal you don't need to do that shift operation on the",
    "start": "1378559",
    "end": "1386840"
  },
  {
    "text": "the offset between the base fee table and the objects V table um",
    "start": "1386840",
    "end": "1391940"
  },
  {
    "text": "you can just do a range check so so in the example that I've been using where we're downcasting to an object of type c",
    "start": "1391940",
    "end": "1397340"
  },
  {
    "text": "you can see so we have the CV table here E and F and so we can just say if",
    "start": "1397340",
    "end": "1404720"
  },
  {
    "text": "the Delta between the the base V table C and the object c table is 16 bytes or",
    "start": "1404720",
    "end": "1411080"
  },
  {
    "text": "less then that would mean that you must have either an e a c an e or an f and so the",
    "start": "1411080",
    "end": "1417799"
  },
  {
    "text": "cast is allowed to succeed and this is what this ends up looking like in in C sudo code you you read the",
    "start": "1417799",
    "end": "1424880"
  },
  {
    "text": "V table pointer you compute the offset and then you just compare is this offset greater than 16 if it is then fail",
    "start": "1424880",
    "end": "1430340"
  },
  {
    "text": "otherwise succeed very very very simple check here and we don't introduce any",
    "start": "1430340",
    "end": "1436520"
  },
  {
    "text": "real extra memory loads the only memory load that we're doing in this check is just reading the V table pointer but",
    "start": "1436520",
    "end": "1441620"
  },
  {
    "text": "given that you're using an object that has a v table that cache line is probably hot anyways",
    "start": "1441620",
    "end": "1447320"
  },
  {
    "text": "so it doesn't really cost us much to read it now some of you might be thinking wait a",
    "start": "1447320",
    "end": "1453320"
  },
  {
    "text": "second what if somebody had corrupted this object already and and they made it so that you know the V table that the",
    "start": "1453320",
    "end": "1460100"
  },
  {
    "text": "offset that you compute is like nine bytes you know it passes your range check even",
    "start": "1460100",
    "end": "1465440"
  },
  {
    "text": "though it's not even pointing at the start of any V table in that region it's like pointing into the middle of one of",
    "start": "1465440",
    "end": "1470480"
  },
  {
    "text": "the V tables but you got to remember that our threat model is that no memory corruption has happened at this point we're assuming",
    "start": "1470480",
    "end": "1476720"
  },
  {
    "text": "that the object is valid and if the object is valid then you would never compute an offset of nine bytes because",
    "start": "1476720",
    "end": "1483200"
  },
  {
    "text": "that's just nonsense so we don't actually need to worry about this the range check is a completely legal",
    "start": "1483200",
    "end": "1489380"
  },
  {
    "text": "optimization for us to do another thing that you might be wondering is well what happens if this",
    "start": "1489380",
    "end": "1496220"
  },
  {
    "text": "object was created in a completely different binary and then you're casting it when you go",
    "start": "1496220",
    "end": "1501559"
  },
  {
    "text": "and you do this this check to say hey what's the offset between the base fee table in my current binary and the V",
    "start": "1501559",
    "end": "1507799"
  },
  {
    "text": "table that this object has that offset is going to be huge it could be millions of bytes because the object is in a",
    "start": "1507799",
    "end": "1512960"
  },
  {
    "text": "completely different binary and so this is where those global variables that I talked out talked about",
    "start": "1512960",
    "end": "1519080"
  },
  {
    "text": "before come into play what we actually end up doing is we say if you pass the range or if you fail the range check",
    "start": "1519080",
    "end": "1525620"
  },
  {
    "text": "your offset is too big then we do a second check to to see is",
    "start": "1525620",
    "end": "1531620"
  },
  {
    "text": "the V table pointer that the object uh contains is that within our binaries",
    "start": "1531620",
    "end": "1536659"
  },
  {
    "text": "cast guard region and if it isn't within our binaries cast guard region then we assume oh so this V table must be from a",
    "start": "1536659",
    "end": "1543320"
  },
  {
    "text": "different binary and we can't check that we we can't do a security check on that because it's from a different binary and",
    "start": "1543320",
    "end": "1550039"
  },
  {
    "text": "so we just fail open in that case but in Windows most of the objects that our binaries are using are not really",
    "start": "1550039",
    "end": "1556220"
  },
  {
    "text": "getting crossed across binary boundaries like this or even in the case of com",
    "start": "1556220",
    "end": "1561440"
  },
  {
    "text": "objects they might get passed across binary boundaries but you're not really supposed to static cast com objects",
    "start": "1561440",
    "end": "1568100"
  },
  {
    "text": "yourself you're supposed to use Query interface and the query interface code lives in the binary that created the object",
    "start": "1568100",
    "end": "1574279"
  },
  {
    "text": "um so it's it's pretty uncommon for us to have casts happening on an object that was not actually created inside of",
    "start": "1574279",
    "end": "1580640"
  },
  {
    "text": "your binary so for the for most cases that we see uh we can correctly uh do we like we can",
    "start": "1580640",
    "end": "1588140"
  },
  {
    "text": "we can do secure cast checks we don't need to worry about the object coming from another binary so this fail open",
    "start": "1588140",
    "end": "1594340"
  },
  {
    "text": "application compatibility check is not a big deal for us",
    "start": "1594340",
    "end": "1599500"
  },
  {
    "text": "uh and you know I I included the the final assembly that this compiles down",
    "start": "1599740",
    "end": "1604820"
  },
  {
    "text": "to just so you can see how minimal this really is it's seven instructions total to do a a cast check here there's one",
    "start": "1604820",
    "end": "1610940"
  },
  {
    "text": "memory load a couple branches the code speculates very well the app compat check is not contained in this assembly",
    "start": "1610940",
    "end": "1617480"
  },
  {
    "text": "because we don't expect it to be hit very often so we actually put that out of line we don't put it in the hot path",
    "start": "1617480",
    "end": "1623779"
  },
  {
    "text": "of a function we'll just jump to it if it actually is needed",
    "start": "1623779",
    "end": "1629260"
  },
  {
    "text": "okay what about multiple inheritance so multiple inheritance seems really scary at first because you have a second",
    "start": "1629960",
    "end": "1636980"
  },
  {
    "text": "parent but the thing that you have to remember is the V table view of the world so when",
    "start": "1636980",
    "end": "1642320"
  },
  {
    "text": "you have multiple inheritance you actually have two completely separate V table hierarchies you have a v table",
    "start": "1642320",
    "end": "1647539"
  },
  {
    "text": "hierarchy that chains back to each of your base classes and if you look at how the objects",
    "start": "1647539",
    "end": "1653480"
  },
  {
    "text": "themselves are laid out you'll see that the two base classes A and Z they're laid out effectively How We Do how you",
    "start": "1653480",
    "end": "1659960"
  },
  {
    "text": "would expect they have their V table they have their member variables and anything that inherits from both of them",
    "start": "1659960",
    "end": "1665600"
  },
  {
    "text": "once again it has a copy of both the A and Z object so object B for example it has an A and",
    "start": "1665600",
    "end": "1674900"
  },
  {
    "text": "Z object which means it has two different V tables one chaining to the a hierarchy one chaining to the Z hierarchy",
    "start": "1674900",
    "end": "1682039"
  },
  {
    "text": "and so when you encounter multiple inheritance really the only question that you need to ask yourself is which V",
    "start": "1682039",
    "end": "1688159"
  },
  {
    "text": "table hierarchy should I use here if your right hand side type is an a object",
    "start": "1688159",
    "end": "1694640"
  },
  {
    "text": "then it's only guaranteed to have one V table and so that's the V table that you need to do your cast checks with and if",
    "start": "1694640",
    "end": "1700279"
  },
  {
    "text": "the right hand side type is a z object again it's only guaranteed to have one V table it might have more than one V",
    "start": "1700279",
    "end": "1706100"
  },
  {
    "text": "table but it's only guaranteed to have one because it's a z",
    "start": "1706100",
    "end": "1711760"
  },
  {
    "text": "uh and if it is anything else if it's a b or a c or a d or any of these objects",
    "start": "1711760",
    "end": "1718159"
  },
  {
    "text": "that do have multiple view tables then you can use either V table it doesn't matter which one you use for the cast check what we do is we use the V table",
    "start": "1718159",
    "end": "1725659"
  },
  {
    "text": "that is closest to the beginning of the binary just because it minimizes code size you don't need to do math on the",
    "start": "1725659",
    "end": "1732380"
  },
  {
    "text": "pointer in order to read the V table out of the object",
    "start": "1732380",
    "end": "1738820"
  },
  {
    "text": "so I mean the point here though is really that multiple inheritance it seems scary but it's actually effectively identical to single",
    "start": "1740960",
    "end": "1747380"
  },
  {
    "text": "inheritance we still do range checks it still optimizes extremely well you just",
    "start": "1747380",
    "end": "1752840"
  },
  {
    "text": "need to be diligent about which V table am I going to use or which V table hierarchy am I going to use for the cash",
    "start": "1752840",
    "end": "1759440"
  },
  {
    "text": "check um there's one final thing which is virtual based inheritance but I don't",
    "start": "1759440",
    "end": "1765919"
  },
  {
    "text": "have time to talk about it because it is very complicated C plus feature what I",
    "start": "1765919",
    "end": "1771140"
  },
  {
    "text": "will say though is that virtual base inheritance is the one case where we actually need to use bitmap checks",
    "start": "1771140",
    "end": "1776960"
  },
  {
    "text": "sometimes you can't always handle them with range checks so that's why I spent the first part of this talk talking",
    "start": "1776960",
    "end": "1782419"
  },
  {
    "text": "about how the bitmap checks were I've included a bunch of information on this in the appendix of this slide so you can",
    "start": "1782419",
    "end": "1787880"
  },
  {
    "text": "check it out uh once the slides go online okay so I had a few interesting things",
    "start": "1787880",
    "end": "1793760"
  },
  {
    "text": "that I I think they're interesting uh that I that I discovered when we were working on castguard so the first thing",
    "start": "1793760",
    "end": "1798980"
  },
  {
    "text": "is that cascar does not play Super nicely with every single optimization that there is out there uh one",
    "start": "1798980",
    "end": "1805520"
  },
  {
    "text": "optimization that the Linker has is called identical comdat folding or ICF and really all that the Linker is doing",
    "start": "1805520",
    "end": "1811520"
  },
  {
    "text": "here is it's saying hey you have two read-only pieces of data that are the same I don't need to include two read-only pieces of data that are the",
    "start": "1811520",
    "end": "1817880"
  },
  {
    "text": "same in the binary I'm just going to include it one time and everyone can reference that single copy but with cascard that's kind of a",
    "start": "1817880",
    "end": "1824059"
  },
  {
    "text": "problem because we're using the V tables as a way to uniquely identify objects and so we don't want all the V tables to",
    "start": "1824059",
    "end": "1830179"
  },
  {
    "text": "be merged into like one single copy because then we can't uniquely identify objects anymore and so any V table that",
    "start": "1830179",
    "end": "1837080"
  },
  {
    "text": "is laid out in the cascard region we turn ICF off for if the V table is not",
    "start": "1837080",
    "end": "1842179"
  },
  {
    "text": "going to be used in a cast check then it can it can still be icf'd by the Linker we don't care about it but if it is",
    "start": "1842179",
    "end": "1847279"
  },
  {
    "text": "going to be used in a cash check no ICF and that actually brings me to this",
    "start": "1847279",
    "end": "1853520"
  },
  {
    "text": "really interesting programming pattern called crtp or the curiously recurring template pattern this is a pattern that",
    "start": "1853520",
    "end": "1860059"
  },
  {
    "text": "is used a lot in some windows binaries and the gist of this programming pattern really is just that you might have a",
    "start": "1860059",
    "end": "1866840"
  },
  {
    "text": "base class and it has a virtual function and then you have a class in the middle and I call it Class B in this example",
    "start": "1866840",
    "end": "1873740"
  },
  {
    "text": "and the the interesting thing about class B is that it takes a template parameter and the template parameter is",
    "start": "1873740",
    "end": "1880039"
  },
  {
    "text": "a Class Type and anything that inherits from class B such as C in this example passes its own",
    "start": "1880039",
    "end": "1888440"
  },
  {
    "text": "type as that template parameter so you're inheriting from your parent but you're actually passing your own type as",
    "start": "1888440",
    "end": "1894740"
  },
  {
    "text": "the template parameter your parent it's kind of weird and what class B ends up doing is it will do things like static",
    "start": "1894740",
    "end": "1901159"
  },
  {
    "text": "cast to that type it was passed which ends up being a static downcast it will static downcast to the thing that",
    "start": "1901159",
    "end": "1906799"
  },
  {
    "text": "derived from it important thing to realize with this programming pattern is that if you look",
    "start": "1906799",
    "end": "1913159"
  },
  {
    "text": "at the class or the the class diagram in source code it looks like there's only one class B but if you look at it from",
    "start": "1913159",
    "end": "1920179"
  },
  {
    "text": "the compiler's perspective each of those specialized versions of B is actually a",
    "start": "1920179",
    "end": "1926000"
  },
  {
    "text": "unique class and it has a unique V table",
    "start": "1926000",
    "end": "1930580"
  },
  {
    "text": "so why does cascard have issues with this well it really comes down to the identical combat folding stuff that I",
    "start": "1932200",
    "end": "1938659"
  },
  {
    "text": "was talking about before so without castguard enabled you might have functions like there's this do stuff",
    "start": "1938659",
    "end": "1945140"
  },
  {
    "text": "function here and I realize it's hard to leave hard to read but all the do stuff function does effectively is it does a",
    "start": "1945140",
    "end": "1951620"
  },
  {
    "text": "static downcast and static downcasts normally have no code generation and so",
    "start": "1951620",
    "end": "1957679"
  },
  {
    "text": "all of these different do stuff functions for each specialized version of Class B they compile to the exact",
    "start": "1957679",
    "end": "1963799"
  },
  {
    "text": "same assembly and so the Linker looks at that and merges it all into one but when",
    "start": "1963799",
    "end": "1969440"
  },
  {
    "text": "you put cast guard checks on these downcasts suddenly you have type specific downcast checks in all of the",
    "start": "1969440",
    "end": "1976340"
  },
  {
    "text": "different functions and those functions can now no longer be merged together because one version is",
    "start": "1976340",
    "end": "1982159"
  },
  {
    "text": "doing a cast check for downcasting to see one of them is doing a check for D Etc",
    "start": "1982159",
    "end": "1987980"
  },
  {
    "text": "so you get more code and then the other the other reason this caused an issue is because these most",
    "start": "1987980",
    "end": "1993980"
  },
  {
    "text": "derived classes C and D for example they do not change any of the virtual",
    "start": "1993980",
    "end": "1999380"
  },
  {
    "text": "functions which means that their virtual function tables are identical to their parents virtual function table and so",
    "start": "1999380",
    "end": "2006100"
  },
  {
    "text": "again the Linker would merge those but with cast guard on those V tables are used in cash checks so we do not allow",
    "start": "2006100",
    "end": "2013179"
  },
  {
    "text": "identical combat folding to happen and so some of our winrt binaries when we compiled with castguard ended up getting",
    "start": "2013179",
    "end": "2019240"
  },
  {
    "text": "20 bigger which is unacceptable for us we're calling that out explicitly but we can",
    "start": "2019240",
    "end": "2026620"
  },
  {
    "text": "actually optimize this away really well because what we realized was that these different specialized versions of B",
    "start": "2026620",
    "end": "2033220"
  },
  {
    "text": "they're never actually created directly you only create the most derived types in source code",
    "start": "2033220",
    "end": "2039580"
  },
  {
    "text": "and because those different B classes are never created directly there's no",
    "start": "2039580",
    "end": "2045760"
  },
  {
    "text": "reason to include their V tables in the cast checks at all because you know that no one would ever have that V table the",
    "start": "2045760",
    "end": "2051460"
  },
  {
    "text": "object's never created so if we're doing a downcast and we",
    "start": "2051460",
    "end": "2056858"
  },
  {
    "text": "currently have something that's a b specialized by C and we're downcasting it to just be a c the most derived type",
    "start": "2056859",
    "end": "2064419"
  },
  {
    "text": "well we know that if you currently have a pointer that's a b specialized by C there's only two different classes that",
    "start": "2064419",
    "end": "2069700"
  },
  {
    "text": "it could be it could be that b specialized by C-Class or it could be the most derived class the C-Class",
    "start": "2069700",
    "end": "2076780"
  },
  {
    "text": "but as I just mentioned we actually know that it it couldn't actually be a b specialized by C the compiler knows that",
    "start": "2076780",
    "end": "2082540"
  },
  {
    "text": "class was never created at all so the only thing that that could actually be is a c",
    "start": "2082540",
    "end": "2088240"
  },
  {
    "text": "and you're down casting to a c and so we could just statically prove that the cast is safe we know that the",
    "start": "2088240",
    "end": "2094118"
  },
  {
    "text": "only underlying object you could have as a c in your casting to a c so you're good to go cascard cannot provide",
    "start": "2094119",
    "end": "2100440"
  },
  {
    "text": "there's there's nothing for cascard to do there so there's no reason to put a check in place and because we don't have to put a cast",
    "start": "2100440",
    "end": "2106720"
  },
  {
    "text": "card check in place we can now uh continue doing the",
    "start": "2106720",
    "end": "2112060"
  },
  {
    "text": "identical comdat folding on all of those do stuff functions and the V tables",
    "start": "2112060",
    "end": "2117099"
  },
  {
    "text": "themselves aren't referenced by cascard checks anymore so they can be optimized Away by the Linker as well",
    "start": "2117099",
    "end": "2123099"
  },
  {
    "text": "in the case of these winrt binaries that we have in Windows that heavily use the crtp programming pattern we're actually",
    "start": "2123099",
    "end": "2129880"
  },
  {
    "text": "able to statically prove away every single cash check in the binary so we went from a 20 binary size regression to",
    "start": "2129880",
    "end": "2136300"
  },
  {
    "text": "zero percent there's no more cast checks at all it's just statically proven safe and something else that was interesting",
    "start": "2136300",
    "end": "2143079"
  },
  {
    "text": "is that clang CFI and xfg which is a",
    "start": "2143079",
    "end": "2148300"
  },
  {
    "text": "technology that Microsoft has been working on that's similar to clang CFI they also caused really big optimization",
    "start": "2148300",
    "end": "2154960"
  },
  {
    "text": "issues with the crtp programming pattern on the same binary that had a 20 regression with cascard xfg had a 43",
    "start": "2154960",
    "end": "2163300"
  },
  {
    "text": "binary size regression and so we went made some changes to xfg to make it uh",
    "start": "2163300",
    "end": "2168940"
  },
  {
    "text": "not care about these template parameters to classes um so we kind of weaken the security of",
    "start": "2168940",
    "end": "2174220"
  },
  {
    "text": "it so that we could eliminate this 43 binary size regression um claims I I don't think the the clang",
    "start": "2174220",
    "end": "2180400"
  },
  {
    "text": "folks are aware of this programming pattern so if you use clang CFI on crtp you'll probably get a lot of binary size",
    "start": "2180400",
    "end": "2186820"
  },
  {
    "text": "bloat uh so at the end of the day performance",
    "start": "2186820",
    "end": "2191920"
  },
  {
    "text": "with cast guard is great um the spec benchmarks show no regression it's a super super minimal",
    "start": "2191920",
    "end": "2197320"
  },
  {
    "text": "amount of instructions that we're adding to binaries it optimizes Well it speculates Well uh so we're really not",
    "start": "2197320",
    "end": "2204579"
  },
  {
    "text": "concerned about the performance uh binary size impact is Tiny it's under one percent typically uh if your",
    "start": "2204579",
    "end": "2210640"
  },
  {
    "text": "component doesn't do casting static down casting then you won't have any binary size regression",
    "start": "2210640",
    "end": "2216880"
  },
  {
    "text": "um so very easy for us to roll out future possibilities that you could use",
    "start": "2216880",
    "end": "2222700"
  },
  {
    "text": "for this sort of technology and I'm not committing to anything these are just ideas that we have we could possibly",
    "start": "2222700",
    "end": "2229119"
  },
  {
    "text": "introduce a strict mode for casguard where we could say we're not doing app compat checks we only expect this object",
    "start": "2229119",
    "end": "2235540"
  },
  {
    "text": "to be created in the binary and so it better have been created in the binary if it was created by a different binary we just crash",
    "start": "2235540",
    "end": "2241960"
  },
  {
    "text": "we could also have a strict mode if we wanted that always does bitmap checks and and if you always do bitmap checks",
    "start": "2241960",
    "end": "2248079"
  },
  {
    "text": "then you might be able to be more resilient even if someone corrupts your object Maybe",
    "start": "2248079",
    "end": "2254880"
  },
  {
    "text": "you could also potentially use cascard as a way to accelerate Dynamic cast right now Dynamic cast is a huge amount",
    "start": "2254980",
    "end": "2261400"
  },
  {
    "text": "of code but you could potentially just use cascard checks for these these downcasts and then if the cast guard",
    "start": "2261400",
    "end": "2268000"
  },
  {
    "text": "check fails then you could just go and do a full Dynamic cash check and decide you know is should Dynamic cast really",
    "start": "2268000",
    "end": "2274720"
  },
  {
    "text": "check this really fail this or not but again these are just ideas",
    "start": "2274720",
    "end": "2281920"
  },
  {
    "text": "um nothing that we're committing to doing what I do want you all to take away from this though is that it is possible to do",
    "start": "2281920",
    "end": "2289780"
  },
  {
    "text": "really really performant checks on downcasts like the the state of the art with Dynamic cast is it doesn't need to",
    "start": "2289780",
    "end": "2297099"
  },
  {
    "text": "go that slow we can go way faster and have better type safety and C plus plus and this stuff matters because type",
    "start": "2297099",
    "end": "2303099"
  },
  {
    "text": "confusion is a super important bug class and especially in the face of Hardware mitigations that a number of different",
    "start": "2303099",
    "end": "2309220"
  },
  {
    "text": "companies are working on uh type confusion vulnerabilities are going to be a lot more important going forward",
    "start": "2309220",
    "end": "2316960"
  },
  {
    "text": "uh for people that are interested hyper-v is currently flighting in the windsider windows Insider preview builds",
    "start": "2316960",
    "end": "2323260"
  },
  {
    "text": "with castguard enabled it is currently enabled in uh what we call Telemetry",
    "start": "2323260",
    "end": "2329859"
  },
  {
    "text": "mode so it won't actually fast fill the process it just uh logs Telemetry for us",
    "start": "2329859",
    "end": "2335200"
  },
  {
    "text": "but cascard is such a compatible technology that we actually have had zero Telemetry",
    "start": "2335200",
    "end": "2340839"
  },
  {
    "text": "mode failures with it and so we have switched it on to enforcement mode it just that hasn't reached the flighting",
    "start": "2340839",
    "end": "2346119"
  },
  {
    "text": "yet and we are working on rolling this out to additional Windows components in the future and so you know you can keep your",
    "start": "2346119",
    "end": "2352660"
  },
  {
    "text": "eyes open if you're interested in it hyperview was the first one but there will be more to come and uh finally I just want to",
    "start": "2352660",
    "end": "2358720"
  },
  {
    "text": "acknowledge that I'm up here talking about this technology and I certainly did a lot of work on this technology but I am not the only one that worked on",
    "start": "2358720",
    "end": "2364839"
  },
  {
    "text": "this technology we had a lot of people contribute to this project from Windows visual studio and msrc and of course we",
    "start": "2364839",
    "end": "2373119"
  },
  {
    "text": "were inspired by uh the the clang at sanitized CFI derived cast so none of this stuff would be possible without the",
    "start": "2373119",
    "end": "2379480"
  },
  {
    "text": "help from everyone who is involved in the project and everyone who inspired the project",
    "start": "2379480",
    "end": "2384579"
  },
  {
    "text": "I am out of time so I do not have time for questions here but I do have time for questions in the side room that",
    "start": "2384579",
    "end": "2392260"
  },
  {
    "text": "they'll be setting up so if you'd like to chat more uh let's let's just take it over there thanks for your time",
    "start": "2392260",
    "end": "2398860"
  },
  {
    "text": "[Music]",
    "start": "2398860",
    "end": "2401969"
  },
  {
    "text": "[Music]",
    "start": "2405820",
    "end": "2408919"
  }
]