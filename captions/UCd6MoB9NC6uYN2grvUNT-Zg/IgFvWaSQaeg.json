[
  {
    "start": "0",
    "end": "80000"
  },
  {
    "text": "hi everybody welcome to the session about DynamoDB transactions my name is Ellen Sulak I'm a specialist I say",
    "start": "60",
    "end": "7740"
  },
  {
    "text": "focusing on a sequel and dynamodb I also really enjoy transactions well in",
    "start": "7740",
    "end": "15330"
  },
  {
    "text": "dynamodb not that they're out but I also like server less platform at AWS and and",
    "start": "15330",
    "end": "23340"
  },
  {
    "text": "I'm very interested in how some of the databases and dynamodb in particular work with server less components of the",
    "start": "23340",
    "end": "32070"
  },
  {
    "text": "platform and how we can use those to create service architectures and I'm",
    "start": "32070",
    "end": "39090"
  },
  {
    "text": "interested in solving problems that have to do with micro services in that context as well anyway today the agenda",
    "start": "39090",
    "end": "47039"
  },
  {
    "text": "is we're going to start with the with an introduction to the new transactional API in DynamoDB we're also going to talk",
    "start": "47039",
    "end": "54210"
  },
  {
    "text": "about acid in DynamoDB then I'd like to focus a bit part of this talk",
    "start": "54210",
    "end": "60390"
  },
  {
    "text": "to use cases for which transactions make really good sense and then some of the",
    "start": "60390",
    "end": "67049"
  },
  {
    "text": "use cases maybe add use cases where transactions API might not be the best",
    "start": "67049",
    "end": "72299"
  },
  {
    "text": "choice and finally we're gonna talk about things that I think you should know about transaction see yeah so let's",
    "start": "72299",
    "end": "79229"
  },
  {
    "text": "kick it off with an overview of transactional API at a glance so transactional API is request response",
    "start": "79229",
    "end": "88380"
  },
  {
    "start": "80000",
    "end": "80000"
  },
  {
    "text": "it's a non conversational API there is no begin and transaction you simply",
    "start": "88380",
    "end": "94530"
  },
  {
    "text": "create a transactional request to either right or get items out of dynamodb now",
    "start": "94530",
    "end": "100920"
  },
  {
    "text": "these requests can be customized with appropriate conditions that you want",
    "start": "100920",
    "end": "107310"
  },
  {
    "text": "your state of the database to meet before you transition to a new state",
    "start": "107310",
    "end": "112640"
  },
  {
    "text": "transactionally right so transactional API for writing includes API for",
    "start": "112640",
    "end": "119460"
  },
  {
    "text": "condition checks and that's that's actually new so what that means is you can create conditional checks on items",
    "start": "119460",
    "end": "126149"
  },
  {
    "text": "that you need to check but you might but you you're not going to transactionally update and then you can also have",
    "start": "126149",
    "end": "133230"
  },
  {
    "text": "on the same old put item update item operations as part of that transaction",
    "start": "133230",
    "end": "140819"
  },
  {
    "text": "so it's it's really versatile and flexible and allows you to put together a transactional request send a request",
    "start": "140819",
    "end": "148590"
  },
  {
    "text": "as a synchronous separation get a response back that's basically a success or a failure for transaction get items",
    "start": "148590",
    "end": "156569"
  },
  {
    "text": "works much the same way you can get up to ten items back same as for transaction right items API the scope of",
    "start": "156569",
    "end": "164310"
  },
  {
    "text": "these operations is any table multiple tables in the same account within the",
    "start": "164310",
    "end": "169440"
  },
  {
    "text": "same region and I should also mention if you're wondering why is this request",
    "start": "169440",
    "end": "174540"
  },
  {
    "text": "response style as opposed to the very common begin end transaction in the",
    "start": "174540",
    "end": "181440"
  },
  {
    "text": "world of know sequel where we care about scale and performance at scale this",
    "start": "181440",
    "end": "186569"
  },
  {
    "text": "makes a lot more sense right this is in keeping with the spirit of DynamoDB is a very scalable database that performs",
    "start": "186569",
    "end": "194700"
  },
  {
    "text": "well at scale and and that's kind of one of the reasons why we have the limitation on 10 items per transaction",
    "start": "194700",
    "end": "201030"
  },
  {
    "text": "we feel that that's sufficient for most use cases out there and also I take that",
    "start": "201030",
    "end": "206400"
  },
  {
    "text": "as a clue if I'm thinking about transactional behavior I know that the API is designed to only take ten items",
    "start": "206400",
    "end": "212670"
  },
  {
    "text": "at a time and so if I'm looking at something that might go beyond that that",
    "start": "212670",
    "end": "219570"
  },
  {
    "text": "might not be a great use case either so let's talk a little bit about acid in",
    "start": "219570",
    "end": "225109"
  },
  {
    "start": "223000",
    "end": "223000"
  },
  {
    "text": "dynamodb before transactional api is we've had obviously this batch API is",
    "start": "225109",
    "end": "231600"
  },
  {
    "text": "also single item API for a long time and if you might be wondering so single item",
    "start": "231600",
    "end": "237630"
  },
  {
    "text": "operations have always been transactional if you're doing a put item or update item delete item these",
    "start": "237630",
    "end": "244920"
  },
  {
    "text": "operations are always all-or-nothing you can't have partial updates to",
    "start": "244920",
    "end": "250500"
  },
  {
    "text": "dynamodb item by way of any of these operations right and so transactional",
    "start": "250500",
    "end": "256530"
  },
  {
    "text": "api extends this capability to multiple items and if need be across multiple",
    "start": "256530",
    "end": "262650"
  },
  {
    "text": "tables and then again if you watch some of the Raymond talks especially from Rick",
    "start": "262650",
    "end": "268020"
  },
  {
    "text": "Houlihan right on advanced design patterns he was the first one to point out you know the transactional API",
    "start": "268020",
    "end": "273780"
  },
  {
    "text": "supports multiple tables but you probably shouldn't be using it for four",
    "start": "273780",
    "end": "279330"
  },
  {
    "text": "transactions over multiple tables there might be exceptional cases but as a general rule you should stay away from",
    "start": "279330",
    "end": "285260"
  },
  {
    "text": "doing transactions across multiple tables we'll talk about some of those use cases so back to this sort of little",
    "start": "285260",
    "end": "293130"
  },
  {
    "text": "comparison of new transactional and the existing non-transactional transactional api's so the new api is extend the",
    "start": "293130",
    "end": "302970"
  },
  {
    "text": "transactional capabilities to multiple items so by contrast the existing",
    "start": "302970",
    "end": "308130"
  },
  {
    "text": "non-transactional api's and I think batch API is in particular do not have",
    "start": "308130",
    "end": "313590"
  },
  {
    "text": "transactional semantics they exist for a different purpose they simply exist to make your",
    "start": "313590",
    "end": "319800"
  },
  {
    "text": "interaction with the service more efficient so you're loading data into table maybe you're migrating to DynamoDB",
    "start": "319800",
    "end": "327660"
  },
  {
    "text": "or what-have-you use the batch API s they're also limited in the sense that",
    "start": "327660",
    "end": "332700"
  },
  {
    "text": "you can't can't have conditions and those rights or updates right there to just write designed to be right only in",
    "start": "332700",
    "end": "341070"
  },
  {
    "text": "batches so when the service receives a batch it applies all those operations as",
    "start": "341070",
    "end": "346950"
  },
  {
    "text": "individual operations and that's one of the main points of difference between the transactional api's and the existing",
    "start": "346950",
    "end": "353729"
  },
  {
    "text": "batch API is worth noting that for also query and scan API when you're doing a",
    "start": "353729",
    "end": "359729"
  },
  {
    "text": "query data that you're getting from DynamoDB might be updated by what what",
    "start": "359729",
    "end": "366690"
  },
  {
    "text": "what else might be going on single item operations or transactions right the thing to remember though you will always",
    "start": "366690",
    "end": "373410"
  },
  {
    "text": "be getting committed read state right you will never be getting data that's",
    "start": "373410",
    "end": "378930"
  },
  {
    "text": "not committed and that's what we call read committed right you can rest assured that your scan or query",
    "start": "378930",
    "end": "384690"
  },
  {
    "text": "operations will always be returning committed state however that query as a",
    "start": "384690",
    "end": "389699"
  },
  {
    "text": "whole the results that isn't going to be serialized with respect to other operations that might be taking place",
    "start": "389699",
    "end": "395960"
  },
  {
    "text": "what what that means is that the way I really think about that is when I execute a query that's",
    "start": "395960",
    "end": "402479"
  },
  {
    "text": "not just oh this is the state and at a single point in time because query execution might take some time you might",
    "start": "402479",
    "end": "409020"
  },
  {
    "text": "be paginating through multiple pages of result sets well dynamodb does all that",
    "start": "409020",
    "end": "415229"
  },
  {
    "text": "sort of undemanding real-time and so something else other threads might be",
    "start": "415229",
    "end": "421289"
  },
  {
    "text": "updating data as you're also reading them but the key thing to remember is you will be always getting committed",
    "start": "421289",
    "end": "427760"
  },
  {
    "text": "committed state of your of your data so quick overview of acid support in",
    "start": "427760",
    "end": "434520"
  },
  {
    "start": "432000",
    "end": "432000"
  },
  {
    "text": "DynamoDB atomicity right isolation serializable with respect to other",
    "start": "434520",
    "end": "439800"
  },
  {
    "text": "operations single item or transactional operations and then we'll talk a little",
    "start": "439800",
    "end": "445409"
  },
  {
    "text": "bit more about that in a second durability the same as always right very",
    "start": "445409",
    "end": "451710"
  },
  {
    "text": "durable DynamoDB there is a support for idempotency and that's that's a really helpful new",
    "start": "451710",
    "end": "457620"
  },
  {
    "text": "feature we'll talk a little bit about that in the coming slides",
    "start": "457620",
    "end": "463039"
  },
  {
    "text": "synchronous as I said API is right they do not there is no blocking in other",
    "start": "463039",
    "end": "469320"
  },
  {
    "text": "words there is no possibility of deadlocks with these either and we'll get into that a little bit more as well",
    "start": "469320",
    "end": "474770"
  },
  {
    "text": "condition checks are supported right these api's are subject to the same availability of four nines within a",
    "start": "474770",
    "end": "481800"
  },
  {
    "text": "region as as everything else right they're designed for predictable performance and also to be scalable",
    "start": "481800",
    "end": "490759"
  },
  {
    "text": "isolation between operations you will see that between all any and all",
    "start": "490820",
    "end": "496979"
  },
  {
    "text": "transactional api is isolation is serializable right there's no interleaving possible these operations",
    "start": "496979",
    "end": "503419"
  },
  {
    "text": "happen occur as if they've been executed in a sequence however if you're looking",
    "start": "503419",
    "end": "510630"
  },
  {
    "text": "at batch operations especially batch right item right these are not",
    "start": "510630",
    "end": "515940"
  },
  {
    "text": "serializable but if you take each individual operation outside of the batch those",
    "start": "515940",
    "end": "521219"
  },
  {
    "text": "individual rights will be will have serializable isolation with everything",
    "start": "521219",
    "end": "527220"
  },
  {
    "text": "else because they're just like any single operation or transactional operation in",
    "start": "527220",
    "end": "532410"
  },
  {
    "text": "DB query and scan as I mentioned earlier read committed isolation right and then",
    "start": "532410",
    "end": "539639"
  },
  {
    "text": "same for batch get item so as far as",
    "start": "539639",
    "end": "545069"
  },
  {
    "start": "544000",
    "end": "544000"
  },
  {
    "text": "durability in dynamo DB you you probably know this already but when you write to dynamo DB here's an example order and",
    "start": "545069",
    "end": "552959"
  },
  {
    "text": "I'm obviously writing this tooth table what happens is that under the hood this",
    "start": "552959",
    "end": "558480"
  },
  {
    "text": "stable might have many many partitions right there also split across three availability zones and so when that put",
    "start": "558480",
    "end": "566819"
  },
  {
    "text": "comes in DynamoDB takes the partition key creates a hash and figures out which partitions will be will be written to",
    "start": "566819",
    "end": "574379"
  },
  {
    "text": "and makes basically three copies of your data and that's true whether whether you",
    "start": "574379",
    "end": "580949"
  },
  {
    "text": "use single or multi item transactions right every time you write this is what",
    "start": "580949",
    "end": "586560"
  },
  {
    "text": "happens a minor detail to point out two of these copies are done synchronously",
    "start": "586560",
    "end": "592290"
  },
  {
    "text": "and then you get acknowledgment of your right so you're highly available right",
    "start": "592290",
    "end": "597480"
  },
  {
    "text": "and then the third one for performance reason reasons is done asynchronously now the the beautiful thing about this",
    "start": "597480",
    "end": "605220"
  },
  {
    "text": "isn't just the the durability because you have three copies and three solid state disks it's also that the service",
    "start": "605220",
    "end": "612899"
  },
  {
    "text": "actually runs in three availability zones so even if the whole availability",
    "start": "612899",
    "end": "619319"
  },
  {
    "text": "zone becomes unavailable you probably won't even notice because the service will seamlessly basically just continue",
    "start": "619319",
    "end": "626970"
  },
  {
    "text": "to run in the remaining two availability zones let's talk about use cases I",
    "start": "626970",
    "end": "633180"
  },
  {
    "text": "really wanted to get a to use cases for transactions as quickly as possible and so here's a sort of a sweet spot use",
    "start": "633180",
    "end": "641610"
  },
  {
    "start": "639000",
    "end": "639000"
  },
  {
    "text": "case for transactional API in gaming industry our customers use dynamodb to",
    "start": "641610",
    "end": "647309"
  },
  {
    "text": "store game State for gamers right this is an example we have partition key that's gamertag you know user ID and",
    "start": "647309",
    "end": "655139"
  },
  {
    "text": "then gamers state is essentially stored as a collection of items that's not",
    "start": "655139",
    "end": "663089"
  },
  {
    "text": "necessarily the only way right you store the game the state for each user as a single item and some people do this",
    "start": "663089",
    "end": "670660"
  },
  {
    "text": "the difference between the two if you use multiple items gives you the ability",
    "start": "670660",
    "end": "676060"
  },
  {
    "text": "to access and write on and with a finer granularity right for example in this",
    "start": "676060",
    "end": "681880"
  },
  {
    "text": "case this application allows you to spend some of your assets assets coins",
    "start": "681880",
    "end": "688209"
  },
  {
    "text": "to acquire more health right and I don't need to retrieve the entire state the",
    "start": "688209",
    "end": "694240"
  },
  {
    "text": "entire game gamer state basically which might be fairly large right I mean in",
    "start": "694240",
    "end": "699279"
  },
  {
    "text": "some cases we're talking dozens hundreds of kilobytes I don't necessarily want to",
    "start": "699279",
    "end": "704399"
  },
  {
    "text": "do reads and writes of so much data right with every operation that I need",
    "start": "704399",
    "end": "710230"
  },
  {
    "text": "to perform so I can simply read the assets and status for this gamer and and",
    "start": "710230",
    "end": "716020"
  },
  {
    "text": "of course this is naturally a transactional operation this gamer wants to buy more health I need to",
    "start": "716020",
    "end": "721950"
  },
  {
    "text": "transactionally essentially reduce the number of assets coins that's sufficient",
    "start": "721950",
    "end": "728830"
  },
  {
    "text": "to acquire the amount of health that the gamer wants to do so transactions is really provides you a good way of doing",
    "start": "728830",
    "end": "736060"
  },
  {
    "text": "that so this is sort of what the transact items looks like we have two",
    "start": "736060",
    "end": "742360"
  },
  {
    "text": "items we have a condition right you have to have enough sufficient amount of coins assets to do that and then if",
    "start": "742360",
    "end": "749620"
  },
  {
    "text": "these conditions are met if they're all true the transaction succeeds and it's done all in an all-or-nothing",
    "start": "749620",
    "end": "756910"
  },
  {
    "text": "manner it's acid right and that's it that's a really you're basically typical",
    "start": "756910",
    "end": "765279"
  },
  {
    "text": "example right a transactional API makes this much easier to do without",
    "start": "765279",
    "end": "770380"
  },
  {
    "text": "transactional API as well we have to either use client transaction library or",
    "start": "770380",
    "end": "775570"
  },
  {
    "text": "we have to have some kind of a lock mechanism of our own but then we have to",
    "start": "775570",
    "end": "781120"
  },
  {
    "text": "worry about all the edge conditions ourselves so another example let's say",
    "start": "781120",
    "end": "786610"
  },
  {
    "start": "784000",
    "end": "784000"
  },
  {
    "text": "we're managing product inventory with a with the changelog as well right so every time we let's say reduce the stock",
    "start": "786610",
    "end": "795640"
  },
  {
    "text": "of a given product we need to well first of all in store the changelog subtract the amount but",
    "start": "795640",
    "end": "801779"
  },
  {
    "text": "also change the quantity on the top item which has the sort key event idea of",
    "start": "801779",
    "end": "807300"
  },
  {
    "text": "zero that's a kind of a symbolic value it represents that the main state item",
    "start": "807300",
    "end": "814560"
  },
  {
    "text": "record of this product right and so we see a list of change records and so",
    "start": "814560",
    "end": "821160"
  },
  {
    "text": "whether I'm subtracting or adding more stock to to to this product I need to",
    "start": "821160",
    "end": "827580"
  },
  {
    "text": "basically do that and update the stock level transactionally right and so",
    "start": "827580",
    "end": "833250"
  },
  {
    "text": "transaction API is a really good way to do that not only that but in a lot of cases idempotency right is is going to",
    "start": "833250",
    "end": "840779"
  },
  {
    "text": "be a concern I don't I don't want to execute the same transaction twice and the transaction api's give me basically",
    "start": "840779",
    "end": "848880"
  },
  {
    "text": "an option to do that as well so that if the same transaction is for whatever",
    "start": "848880",
    "end": "854550"
  },
  {
    "text": "reason executed more than once it's not really going to be applied more than once right the service will recognize",
    "start": "854550",
    "end": "861060"
  },
  {
    "text": "that oh this is just another attempt using the same madam potency token so it'll read the the record but people",
    "start": "861060",
    "end": "869940"
  },
  {
    "text": "won't basically apply changes another example it's very different is you know",
    "start": "869940",
    "end": "875570"
  },
  {
    "start": "871000",
    "end": "871000"
  },
  {
    "text": "people actually do migrate from relational database to DynamoDB this is",
    "start": "875570",
    "end": "880950"
  },
  {
    "text": "one example in fact it's from the Denver DB users guide we're not going to go into too much detail of this example but",
    "start": "880950",
    "end": "887700"
  },
  {
    "text": "in this case it's an order entry system that has the number of entities write",
    "start": "887700",
    "end": "893250"
  },
  {
    "text": "orders customers products also employees that work with these orders are part of",
    "start": "893250",
    "end": "898529"
  },
  {
    "text": "that system and so several different updates in the system have to be made in",
    "start": "898529",
    "end": "905279"
  },
  {
    "text": "a transactional manner and so first though how do we design this a dynamodb",
    "start": "905279",
    "end": "910680"
  },
  {
    "start": "908000",
    "end": "908000"
  },
  {
    "text": "all those entities relationships and so on the the basic design pattern if you",
    "start": "910680",
    "end": "916500"
  },
  {
    "text": "if you heard Ricola him speak write either a tree inventor or else where he talks about the jason see list it's a",
    "start": "916500",
    "end": "922800"
  },
  {
    "text": "now well-documented pattern a dynamodb documentation as well but it's about",
    "start": "922800",
    "end": "928800"
  },
  {
    "text": "really modeling simple graphs of entity and relationships as an adjacency list",
    "start": "928800",
    "end": "934620"
  },
  {
    "text": "so in DynamoDB what it means entity will become a partition so we'll use a",
    "start": "934620",
    "end": "940170"
  },
  {
    "text": "partition key to basically store different entities and the best part",
    "start": "940170",
    "end": "946080"
  },
  {
    "text": "about it is they can all go into the same table and then relationships to other entities are stored as using the",
    "start": "946080",
    "end": "953220"
  },
  {
    "text": "sort key as the target basically edge for for the relationship so in this case",
    "start": "953220",
    "end": "960390"
  },
  {
    "text": "to support all these different access patterns how do we look up an employee how do we look up an order in in various",
    "start": "960390",
    "end": "967590"
  },
  {
    "text": "ways the data model ends up looking like this and how do we get to this model we",
    "start": "967590",
    "end": "974190"
  },
  {
    "start": "968000",
    "end": "968000"
  },
  {
    "text": "look at those query and access patterns and we make sure that we have a way of",
    "start": "974190",
    "end": "980790"
  },
  {
    "text": "modeling each access pattern using the data model so that this table is one-way",
    "start": "980790",
    "end": "986850"
  },
  {
    "text": "it's going to model one side of each many-to-many relationship but then in",
    "start": "986850",
    "end": "992190"
  },
  {
    "text": "addition to this we would end up creating global secondary indexes in order to model the reverse side of",
    "start": "992190",
    "end": "998540"
  },
  {
    "text": "many-to-many relationship we're not going to go into all the details of this but I want to point out the use case for",
    "start": "998540",
    "end": "1005630"
  },
  {
    "text": "a transactional API here we have orders and we have to enter all the order",
    "start": "1005630",
    "end": "1013550"
  },
  {
    "text": "details transactionally right at the same time we need to update the employee",
    "start": "1013550",
    "end": "1018770"
  },
  {
    "text": "record who's working on that order because that employee carries a quota the order changes the quota and all that",
    "start": "1018770",
    "end": "1025490"
  },
  {
    "text": "is a single transaction just naturally and now we can do that using the transactional api's another example that",
    "start": "1025490",
    "end": "1034400"
  },
  {
    "start": "1033000",
    "end": "1033000"
  },
  {
    "text": "I wanted to talk about use case that I think we're going to see sort of more",
    "start": "1034400",
    "end": "1040970"
  },
  {
    "text": "and more of is modeling transactions in in micro services let's consider an",
    "start": "1040970",
    "end": "1048380"
  },
  {
    "text": "e-commerce application probably has a lot more micro services than this but this this will do for the purposes of",
    "start": "1048380",
    "end": "1054560"
  },
  {
    "text": "this example here we're dealing with shopping cart service product inventory",
    "start": "1054560",
    "end": "1060320"
  },
  {
    "text": "service there's account service one basic thing about micro services",
    "start": "1060320",
    "end": "1065450"
  },
  {
    "text": "is that they're isolated from each other they're decoupled from each other right what that means is each one is bounded",
    "start": "1065450",
    "end": "1072799"
  },
  {
    "text": "by its business context and that applies to data each micro-service owns its data",
    "start": "1072799",
    "end": "1078470"
  },
  {
    "text": "other micro-services should not be accessing the data that belongs to other micro-services directly only by invoking",
    "start": "1078470",
    "end": "1086179"
  },
  {
    "text": "api's right so you can imagine in this kind of application that we obviously",
    "start": "1086179",
    "end": "1092570"
  },
  {
    "text": "need to make transactional changes to the shopping cart we need to make",
    "start": "1092570",
    "end": "1097850"
  },
  {
    "text": "transactional changes to the product inventory much like in a one of the previous examples but we also might need",
    "start": "1097850",
    "end": "1105230"
  },
  {
    "text": "to make transactions transactional updates that span these micro services let's start with just a and before that",
    "start": "1105230",
    "end": "1113720"
  },
  {
    "text": "in fact I wanted to just point out and and and you know a sidebar this is",
    "start": "1113720",
    "end": "1121429"
  },
  {
    "text": "something that that you can actually implement using server less platform at AWS right if you're talking",
    "start": "1121429",
    "end": "1127960"
  },
  {
    "text": "micro-services api gateway becomes a natural place to define your micro",
    "start": "1127960",
    "end": "1133370"
  },
  {
    "text": "service api's lambda provides a obviously the ability to implement your",
    "start": "1133370",
    "end": "1138529"
  },
  {
    "text": "compute all the functions that that basically you need for your micro service in a single place and then",
    "start": "1138529",
    "end": "1147730"
  },
  {
    "text": "dynamodb in fact if you didn't know is the only database that's part a servlet",
    "start": "1147730",
    "end": "1152899"
  },
  {
    "text": "platform that's that's essentially eligible for both PII and HIPAA HIPAA",
    "start": "1152899",
    "end": "1160399"
  },
  {
    "text": "data right so these services make a compelling case for looking at how to",
    "start": "1160399",
    "end": "1167059"
  },
  {
    "text": "develop your applications Greenfield applications as let's say server lies",
    "start": "1167059",
    "end": "1172519"
  },
  {
    "text": "micro services right using the service platform so anyway the the first thing we want to",
    "start": "1172519",
    "end": "1180889"
  },
  {
    "start": "1179000",
    "end": "1179000"
  },
  {
    "text": "look at is shopping cart service and and how we represent data in the shopping",
    "start": "1180889",
    "end": "1185899"
  },
  {
    "text": "cart in a relational world we could imagine couple of tables card table card item and then you know we have to do",
    "start": "1185899",
    "end": "1194779"
  },
  {
    "text": "joins and so on in the non-relational world we we want to think in aggregates a shopping",
    "start": "1194779",
    "end": "1200680"
  },
  {
    "text": "cart is a collection of related objects that we always write and read together because that's that's what makes sense",
    "start": "1200680",
    "end": "1208060"
  },
  {
    "text": "for for our application I can model that using a single table very easily I can model that as a single item in a table",
    "start": "1208060",
    "end": "1215680"
  },
  {
    "text": "I can also model that as multiple items I can see for example how someone might design this data model such that you",
    "start": "1215680",
    "end": "1223630"
  },
  {
    "text": "have a separate DynamoDB item for each product in a shopping cart and that would give you the kind of granularity",
    "start": "1223630",
    "end": "1230020"
  },
  {
    "text": "that allows you to access each item individually whether you want to remove it from the cart or update the quantity",
    "start": "1230020",
    "end": "1237040"
  },
  {
    "text": "and so on both options are perfectly valid and and which one you go for may",
    "start": "1237040",
    "end": "1245890"
  },
  {
    "text": "depend on other requirements that you that you have in your application right so the main point of difference that in",
    "start": "1245890",
    "end": "1253810"
  },
  {
    "text": "a relational world we would have a fully normalized schema in the non relational",
    "start": "1253810",
    "end": "1259360"
  },
  {
    "text": "world with DynamoDB in particular we would want the normalized schema right using a single table to store to store",
    "start": "1259360",
    "end": "1267130"
  },
  {
    "text": "the data and so how do we do updates to this cart in a way that's consistent and",
    "start": "1267130",
    "end": "1274660"
  },
  {
    "start": "1270000",
    "end": "1270000"
  },
  {
    "text": "by the way there are consistency in this context does not mean strong consistency",
    "start": "1274660",
    "end": "1280240"
  },
  {
    "text": "eventual consistency it means logical consistency of your data it means I start with an empty cart",
    "start": "1280240",
    "end": "1286480"
  },
  {
    "text": "I put a TV in it and when I view I see a TV in it I don't I don't see a",
    "start": "1286480",
    "end": "1292090"
  },
  {
    "text": "refrigerator in it right or or I don't see an empty cart right and sure you",
    "start": "1292090",
    "end": "1297190"
  },
  {
    "text": "know in this kind of use case it's normal that each user would have their",
    "start": "1297190",
    "end": "1302650"
  },
  {
    "text": "own account their own shopping cart and so on but we all know people who you know have an Amazon account and they",
    "start": "1302650",
    "end": "1309040"
  },
  {
    "text": "share it with family members right so I'm going shopping and I happen to share",
    "start": "1309040",
    "end": "1314080"
  },
  {
    "text": "my account with Uncle Bob and he's buying a refrigerator I'm buying a TV right and so if I don't have data",
    "start": "1314080",
    "end": "1321400"
  },
  {
    "text": "consistency we might be seeing weird things right Uncle Bob might end up",
    "start": "1321400",
    "end": "1327070"
  },
  {
    "text": "seeing my TV in the shop car but not his refrigerator and and so on so how do we implement these updates",
    "start": "1327070",
    "end": "1334660"
  },
  {
    "text": "in a way that are that are consistent right and those state transitions happen",
    "start": "1334660",
    "end": "1340179"
  },
  {
    "text": "but they always end end up in a consistent state so we do have to read",
    "start": "1340179",
    "end": "1346150"
  },
  {
    "text": "the card data and so we use getitem api now you might want you might be",
    "start": "1346150",
    "end": "1351910"
  },
  {
    "text": "wondering should this be eventually consistent or a strongly consistent call and let's I'm going to let you kind of",
    "start": "1351910",
    "end": "1358570"
  },
  {
    "text": "sit on that thought and think about it for a moment as we step through the process here so we make changes in the",
    "start": "1358570",
    "end": "1366610"
  },
  {
    "text": "shopping cart service right we add our TV set now we need to update the cart and what do we do well it's it's the",
    "start": "1366610",
    "end": "1373840"
  },
  {
    "text": "conditional put item it's the conditional expression that gives us the ability to do this in a way that's going",
    "start": "1373840",
    "end": "1379750"
  },
  {
    "text": "to ensure that consistency if we start with a cart and we have a let's say version attribute we're gonna read that",
    "start": "1379750",
    "end": "1386860"
  },
  {
    "text": "version attribute and we're only going to update the cart if that version attribute matches what we read if it",
    "start": "1386860",
    "end": "1393429"
  },
  {
    "text": "doesn't match means that something else is updated a cart and we need to abort and what do we do if we abort we",
    "start": "1393429",
    "end": "1399940"
  },
  {
    "text": "basically need to reread the item we need to get the current most current state so this is the this is the",
    "start": "1399940",
    "end": "1406660"
  },
  {
    "text": "optimistic concurrency control and and so but you'll notice that whether we do",
    "start": "1406660",
    "end": "1412809"
  },
  {
    "text": "that get item in an eventually or strongly consistent way does not really matter in terms of correctness if I if I",
    "start": "1412809",
    "end": "1421090"
  },
  {
    "text": "do a strongly consistent read on that get item call yeah okay I'm going to get",
    "start": "1421090",
    "end": "1427150"
  },
  {
    "text": "that consistent state and I know that you know that will be the state at the time of the read eventually consistent",
    "start": "1427150",
    "end": "1434260"
  },
  {
    "text": "call might result in a stale state but what's the worst thing that can happen",
    "start": "1434260",
    "end": "1439299"
  },
  {
    "text": "my conditional update will fail and I will have to reread the state and redo",
    "start": "1439299",
    "end": "1445090"
  },
  {
    "text": "it but there's nothing wrong with with the logic or the algorithm itself right",
    "start": "1445090",
    "end": "1451090"
  },
  {
    "text": "I might have an extra read and an operation to do but that's about it so the point is we use conditions to",
    "start": "1451090",
    "end": "1458950"
  },
  {
    "text": "implement optimistic concurrency control and as you I'm not using transactional new transactional API why because the single",
    "start": "1458950",
    "end": "1466510"
  },
  {
    "text": "item API is just as transactional when I'm working with a single item if this were a multi item collection I would",
    "start": "1466510",
    "end": "1473950"
  },
  {
    "text": "have to use the new transactional API so I just kind of wanted to point that basically out and so sort of compare the",
    "start": "1473950",
    "end": "1481240"
  },
  {
    "text": "two for this use case it's perfectly in fact you you do want to use a single",
    "start": "1481240",
    "end": "1486850"
  },
  {
    "text": "item API because it's also cheaper I mean sure you could end up using you could choose to use the new transaction",
    "start": "1486850",
    "end": "1492880"
  },
  {
    "text": "API but you really don't don't need to now the question that we need to answer",
    "start": "1492880",
    "end": "1498220"
  },
  {
    "start": "1496000",
    "end": "1496000"
  },
  {
    "text": "next is how do we do transactions that span micro-services right so imagine a",
    "start": "1498220",
    "end": "1505480"
  },
  {
    "text": "situation where shopping cart is ready to be checked out the customer clicks the check checkout button but now we",
    "start": "1505480",
    "end": "1512590"
  },
  {
    "text": "have to update the product inventory and and we should actually do that in a transactional way right we need to make",
    "start": "1512590",
    "end": "1519850"
  },
  {
    "text": "sure that that that cart and items that are in the cart are available in the",
    "start": "1519850",
    "end": "1527529"
  },
  {
    "text": "product inventory so the traditional approaches have a big-old transaction and I have some kind of transaction",
    "start": "1527529",
    "end": "1533830"
  },
  {
    "text": "manager and I just do that transaction Li between the two but that breaks you",
    "start": "1533830",
    "end": "1539830"
  },
  {
    "text": "know that violates the one of the basic microservices design tenets right that",
    "start": "1539830",
    "end": "1545559"
  },
  {
    "text": "these micro services should be decoupled if I do that they're not decoupled anymore and so this is one of those",
    "start": "1545559",
    "end": "1552880"
  },
  {
    "text": "cases you know where new transaction API could easily do this right but should",
    "start": "1552880",
    "end": "1559299"
  },
  {
    "text": "you really do it using the new transaction API well the problem is again coupling of those two micro",
    "start": "1559299",
    "end": "1567130"
  },
  {
    "text": "services using that transactional API so this is where we really want to apply caution and think about this twice and",
    "start": "1567130",
    "end": "1574690"
  },
  {
    "text": "if we're compelled to say well heck but it's a lot easier to do this through the new transactional API which by the way",
    "start": "1574690",
    "end": "1581110"
  },
  {
    "text": "it is right then we have to make the case of combining these two micro services into single micro service right",
    "start": "1581110",
    "end": "1588669"
  },
  {
    "text": "and so that's that's the sort of you know I I think the process there",
    "start": "1588669",
    "end": "1595000"
  },
  {
    "text": "so what can we do differently alternatively right we could implement",
    "start": "1595000",
    "end": "1600130"
  },
  {
    "text": "this as an eventually consistent sequence of transactional events so that",
    "start": "1600130",
    "end": "1605920"
  },
  {
    "text": "in the end we have a consistent state between two between the two or more micro-services right how do we do that",
    "start": "1605920",
    "end": "1612220"
  },
  {
    "text": "well if we're using DynamoDB for this and and especially if we're building",
    "start": "1612220",
    "end": "1617740"
  },
  {
    "text": "this as a server less application so now we have lambda in the game where our business logic lives we can take",
    "start": "1617740",
    "end": "1625150"
  },
  {
    "text": "advantage of the tool the tool represent a very powerful building block for",
    "start": "1625150",
    "end": "1631020"
  },
  {
    "text": "reliable event delivery of of events right so if I have DynamoDB strings I'm going",
    "start": "1631020",
    "end": "1637570"
  },
  {
    "text": "to take take it that you're all familiar with DynamoDB streams and I turned that on for my card table all the updates to",
    "start": "1637570",
    "end": "1645970"
  },
  {
    "text": "the card table are now reliably delivered by the DynamoDB stream I can have a lambda function in this case it",
    "start": "1645970",
    "end": "1652960"
  },
  {
    "text": "could be your own application right that subscribes to the to the stream updates as well but server list is a lot easier",
    "start": "1652960",
    "end": "1659740"
  },
  {
    "text": "and more fun lambda really integrates well with DynamoDB streams and so what I",
    "start": "1659740",
    "end": "1667030"
  },
  {
    "text": "have now is a reliable event delivery mechanism DynamoDB streams will deliver",
    "start": "1667030",
    "end": "1672280"
  },
  {
    "text": "events exactly once however lambda a lambda function could",
    "start": "1672280",
    "end": "1677530"
  },
  {
    "text": "be executed more than once on the same event so this becomes a reliable at least once event delivery mechanism so",
    "start": "1677530",
    "end": "1685840"
  },
  {
    "text": "what does that mean so in case of lambda and potency becomes very very important",
    "start": "1685840",
    "end": "1691300"
  },
  {
    "text": "when you hook up lambda to dynamodb stream or Kinesis stream and so this is",
    "start": "1691300",
    "end": "1696910"
  },
  {
    "text": "now where we can take advantage of the new transactional API that provides idempotency features to do this much",
    "start": "1696910",
    "end": "1705130"
  },
  {
    "text": "easier in fact than before right so in this case I can imagine a checkout event",
    "start": "1705130",
    "end": "1710860"
  },
  {
    "text": "it's just an attribute on my shopping cart table coming through down the stream in my function I basically see",
    "start": "1710860",
    "end": "1719080"
  },
  {
    "text": "that Oh check out is true I need to update my product inventory table I need to make sure that I have inventory for",
    "start": "1719080",
    "end": "1726790"
  },
  {
    "text": "the items that are in the table and if that's true I can actually use",
    "start": "1726790",
    "end": "1733600"
  },
  {
    "text": "transactional API to do that because it gives me added potency it also it also",
    "start": "1733600",
    "end": "1740550"
  },
  {
    "text": "you know because I have multiple items in Indy in the shopping cart I have to",
    "start": "1740550",
    "end": "1745720"
  },
  {
    "text": "use the transactional API so but but it's a it's a win-win situation right I",
    "start": "1745720",
    "end": "1751690"
  },
  {
    "text": "have idempotency feature that that's really helpful and I can use the",
    "start": "1751690",
    "end": "1757060"
  },
  {
    "text": "transactional API to update the product inventory if it all goes well I just need to invoke commit API on my shopping",
    "start": "1757060",
    "end": "1764890"
  },
  {
    "text": "cart servicing and finish it off and or move on to the next step charge the customer account or what have",
    "start": "1764890",
    "end": "1770950"
  },
  {
    "text": "you so this pattern is a correct if it's a saga pattern right so a saga pattern",
    "start": "1770950",
    "end": "1776620"
  },
  {
    "text": "is an eventually consistent sequence of events that amount to a distributed",
    "start": "1776620",
    "end": "1783070"
  },
  {
    "text": "transaction and and we really use and",
    "start": "1783070",
    "end": "1788260"
  },
  {
    "text": "depend on dynamodb streams and lambda to do that here so the table product",
    "start": "1788260",
    "end": "1793480"
  },
  {
    "start": "1792000",
    "end": "1792000"
  },
  {
    "text": "inventory table it's basically that same example that I showed earlier but we can",
    "start": "1793480",
    "end": "1799000"
  },
  {
    "text": "update the state for each product of course in this case we might have multiple products and this can all be",
    "start": "1799000",
    "end": "1804400"
  },
  {
    "text": "done as a single transaction we can use the idempotency feature and and take",
    "start": "1804400",
    "end": "1811180"
  },
  {
    "text": "care of that so finally let's not forget",
    "start": "1811180",
    "end": "1817680"
  },
  {
    "start": "1816000",
    "end": "1816000"
  },
  {
    "text": "one other thing that we need to do we need to provide a rollback API right for",
    "start": "1817680",
    "end": "1823630"
  },
  {
    "text": "these distributed choreographed transactions right because should there",
    "start": "1823630",
    "end": "1828700"
  },
  {
    "text": "be a failure to checkout or to basically find sufficient inventory for our",
    "start": "1828700",
    "end": "1834610"
  },
  {
    "text": "transaction I need to invoke the rollback mechanism on my checkout table and basically get it canceled the",
    "start": "1834610",
    "end": "1842170"
  },
  {
    "text": "distributed transaction if you will so all that means is that I need to",
    "start": "1842170",
    "end": "1847720"
  },
  {
    "text": "basically change that state of the of my cart back to before checkout maybe there",
    "start": "1847720",
    "end": "1853750"
  },
  {
    "text": "is a failure message that I need to somehow display to the customer as well so there are benefits and drawbacks to",
    "start": "1853750",
    "end": "1861550"
  },
  {
    "text": "this the the the the key benefit is that we're keeping our micro services still decoupled separate from each other one",
    "start": "1861550",
    "end": "1868659"
  },
  {
    "text": "of the main drawbacks is it does kind of complicate how we do transactions between multiple micro services but one",
    "start": "1868659",
    "end": "1876580"
  },
  {
    "text": "really nice thing about it is you can take advantage DynamoDB streams and AWS lamda to help you with with this and",
    "start": "1876580",
    "end": "1885719"
  },
  {
    "text": "yeah something else I wanted to say but anyway it escapes me right now it",
    "start": "1887340",
    "end": "1892869"
  },
  {
    "text": "doesn't matter so all these features basically are",
    "start": "1892869",
    "end": "1899589"
  },
  {
    "text": "designed to support use cases that we just talked about idempotency token right so conditional checks right we",
    "start": "1899589",
    "end": "1909190"
  },
  {
    "text": "need these things to effectively implement transactional behavior and as it turns out you really don't need that",
    "start": "1909190",
    "end": "1916529"
  },
  {
    "text": "conversational semantics of a session begin and we can we can do this more",
    "start": "1916529",
    "end": "1923529"
  },
  {
    "text": "effectively using request response api's next I'd like to talk about things to",
    "start": "1923529",
    "end": "1930789"
  },
  {
    "text": "know concurrency control cost how do we deal with failures with with transactional api's so first we're in a",
    "start": "1930789",
    "end": "1938049"
  },
  {
    "start": "1937000",
    "end": "1937000"
  },
  {
    "text": "single transaction the condition check is a is also part of that new API that",
    "start": "1938049",
    "end": "1944679"
  },
  {
    "text": "that's completely new which means transaction API and and implies in the",
    "start": "1944679",
    "end": "1950200"
  },
  {
    "text": "context of transact write items right you can have condition checks you can have operations that update items in all",
    "start": "1950200",
    "end": "1957789"
  },
  {
    "text": "in all you can have up to ten operations between condition checks and update operations one limitation is you can't",
    "start": "1957789",
    "end": "1965769"
  },
  {
    "text": "update the same item you can't have the same item in multiple operations",
    "start": "1965769",
    "end": "1972009"
  },
  {
    "text": "including condition checks so the idea behind the condition check is I need to",
    "start": "1972009",
    "end": "1977379"
  },
  {
    "text": "check some some part of State that's separate from the items that I need to",
    "start": "1977379",
    "end": "1982629"
  },
  {
    "text": "update but then if if that check succeeds I'm going to update different",
    "start": "1982629",
    "end": "1987969"
  },
  {
    "text": "items right if the check is related to the items that I need to update you can just use existing condition",
    "start": "1987969",
    "end": "1994380"
  },
  {
    "text": "expressions and so again point of difference with batch right item which",
    "start": "1994380",
    "end": "2000500"
  },
  {
    "text": "do not allow conditioned expressions concurrency control is optimistic right",
    "start": "2000500",
    "end": "2006049"
  },
  {
    "start": "2003000",
    "end": "2003000"
  },
  {
    "text": "so we also saw concrete optimistic concurrency control in the shopping cart example that's the world of no sequel",
    "start": "2006049",
    "end": "2013820"
  },
  {
    "text": "these are the sweet spot sort of type types of use cases I can have a huge",
    "start": "2013820",
    "end": "2021559"
  },
  {
    "text": "number of concurrent users but chances are they're all operating on their own",
    "start": "2021559",
    "end": "2027049"
  },
  {
    "text": "data so all these transactions updates can go basically in parallel without",
    "start": "2027049",
    "end": "2033799"
  },
  {
    "text": "stepping on each other right because you know in case of a shopping cart every",
    "start": "2033799",
    "end": "2039530"
  },
  {
    "text": "user I can have millions of users on prime day cyber monday Black Friday what-have-you and they're all using",
    "start": "2039530",
    "end": "2046100"
  },
  {
    "text": "their own shopping carts there's no contention of right on right and that's where we're optimistic concurrency",
    "start": "2046100",
    "end": "2052220"
  },
  {
    "text": "control makes a lot of sense in addition the transactional api's are implemented",
    "start": "2052220",
    "end": "2057888"
  },
  {
    "text": "in a way that deadlocks are not possible however there is one problem that you",
    "start": "2057889",
    "end": "2062960"
  },
  {
    "text": "can run into and that's if your contention of rights goes goes up right",
    "start": "2062960",
    "end": "2069378"
  },
  {
    "text": "so if conflicts become possible then you could have failing transactions due to",
    "start": "2069379",
    "end": "2074929"
  },
  {
    "text": "conflicts right and and transactions could be canceled if you end up executing multiple transactions on on",
    "start": "2074929",
    "end": "2082700"
  },
  {
    "text": "the same data basically right and so that's that's another reason to keep",
    "start": "2082700",
    "end": "2087710"
  },
  {
    "text": "those transactions small avoid unnecessary conflicts designed for scale-out by limiting the scope of your",
    "start": "2087710",
    "end": "2094398"
  },
  {
    "text": "of your transactions to the basically scope that's required that's that's",
    "start": "2094399",
    "end": "2100130"
  },
  {
    "text": "needed but nothing more so and this really goes back with the",
    "start": "2100130",
    "end": "2106850"
  },
  {
    "text": "design principles of dynamodb that have to do with low latency and and the",
    "start": "2106850",
    "end": "2111890"
  },
  {
    "text": "ability to scale out cost metering so when you perform transactions the cost",
    "start": "2111890",
    "end": "2118340"
  },
  {
    "text": "if you're if you're doing transact write items and let's say you have 10 items 10 writes you add up all the right capacity",
    "start": "2118340",
    "end": "2125839"
  },
  {
    "text": "and it's and then going to be times two there is an additional there's a right basically to",
    "start": "2125839",
    "end": "2131359"
  },
  {
    "text": "prepare and then another right to to commit a transaction that the service needs to do on your behalf right the",
    "start": "2131359",
    "end": "2138020"
  },
  {
    "text": "good news is you have to worry about it but the service still has to go through these steps it's all automatic but you",
    "start": "2138020",
    "end": "2144290"
  },
  {
    "text": "will see an increased cost double the cost right that's also which now by the way supports transactions since you",
    "start": "2144290",
    "end": "2151160"
  },
  {
    "text": "invent that's a that's a new feature right will incur additional read costs",
    "start": "2151160",
    "end": "2157119"
  },
  {
    "text": "because it'll it'll use trends that get items to read items from DynamoDB before",
    "start": "2157119",
    "end": "2163010"
  },
  {
    "text": "it updates the cash so you know just pay attention to that right failure",
    "start": "2163010",
    "end": "2168200"
  },
  {
    "start": "2167000",
    "end": "2167000"
  },
  {
    "text": "conditions things things can fail things can fail for the same old reason that",
    "start": "2168200",
    "end": "2173690"
  },
  {
    "text": "the other operations can fail but also transaction key transactions can fail",
    "start": "2173690",
    "end": "2178730"
  },
  {
    "text": "due to transactional conflicts right and those conflicts can be with other",
    "start": "2178730",
    "end": "2185270"
  },
  {
    "text": "concurrent transactions they can also be with other single item operations which",
    "start": "2185270",
    "end": "2191119"
  },
  {
    "text": "are transactional with respect to a single item and in fact in that context",
    "start": "2191119",
    "end": "2197560"
  },
  {
    "text": "single item operations now also have a new exception transaction conflict",
    "start": "2197560",
    "end": "2203839"
  },
  {
    "text": "exception right so if you're adding transactions to your existing",
    "start": "2203839",
    "end": "2208940"
  },
  {
    "text": "application there is a new exception that you might basically get with your",
    "start": "2208940",
    "end": "2214790"
  },
  {
    "text": "existing single operations and that's a transaction conflict exception if there",
    "start": "2214790",
    "end": "2219950"
  },
  {
    "text": "is a transaction in progress that's updating let's say item X and another",
    "start": "2219950",
    "end": "2226010"
  },
  {
    "text": "single item operations tries to update the same item while the transaction is updating and updating it the single item",
    "start": "2226010",
    "end": "2233780"
  },
  {
    "text": "operation will fail with the transaction conflict conflict exception so a quick",
    "start": "2233780",
    "end": "2240890"
  },
  {
    "start": "2239000",
    "end": "2239000"
  },
  {
    "text": "note about client requests token idempotency right SDKs provide this option automatically you can also",
    "start": "2240890",
    "end": "2247369"
  },
  {
    "text": "customize it in other words provide your own idempotency token and so idempotency",
    "start": "2247369",
    "end": "2253339"
  },
  {
    "text": "token is good for ten minutes during which if the same transaction is repeat",
    "start": "2253339",
    "end": "2258549"
  },
  {
    "text": "it will not be executed the service will recognize based on the idempotency token",
    "start": "2258549",
    "end": "2263680"
  },
  {
    "text": "it's the same transaction however if you do change any part of that transaction",
    "start": "2263680",
    "end": "2268989"
  },
  {
    "text": "you're going to get a different failure you're going to get a idempotency parameter mismatch failure which will",
    "start": "2268989",
    "end": "2274989"
  },
  {
    "text": "tell you oh hey look you you use the same amount potency token but this is now the contents of this transaction is",
    "start": "2274989",
    "end": "2281529"
  },
  {
    "text": "different so it's a different failure and so in in case of failure right so",
    "start": "2281529",
    "end": "2290979"
  },
  {
    "start": "2287000",
    "end": "2287000"
  },
  {
    "text": "there are retries that the SDK will do for you for example for idempotency transaction",
    "start": "2290979",
    "end": "2298329"
  },
  {
    "text": "in progress but but then there will be failures that you have to handle transactional conflicts right and so",
    "start": "2298329",
    "end": "2304959"
  },
  {
    "text": "what do you do much like with the single item transaction you have to reread",
    "start": "2304959",
    "end": "2311459"
  },
  {
    "text": "reread the state right and then there's a two or three ways but you can do that",
    "start": "2311459",
    "end": "2318400"
  },
  {
    "text": "right you can you can set the option return values and condition check failure all old so that on the failure",
    "start": "2318400",
    "end": "2325569"
  },
  {
    "text": "you actually get the current state that's that's committed and you can use that to rebuild your your transaction or",
    "start": "2325569",
    "end": "2334150"
  },
  {
    "text": "you could do you could carry out any number of read operations right that are available to reread the state and",
    "start": "2334150",
    "end": "2340959"
  },
  {
    "text": "recreate that transaction and execute it again access control same same as always one",
    "start": "2340959",
    "end": "2349959"
  },
  {
    "start": "2346000",
    "end": "2346000"
  },
  {
    "text": "addition is new control for condition check but other than that you have to",
    "start": "2349959",
    "end": "2355089"
  },
  {
    "text": "you have to have permissions to form all the operations that party transaction in order for that transaction to succeed",
    "start": "2355089",
    "end": "2361170"
  },
  {
    "text": "and as far as interaction with other DynamoDB features first of all and",
    "start": "2361170",
    "end": "2367930"
  },
  {
    "start": "2362000",
    "end": "2362000"
  },
  {
    "text": "you've heard me say this earlier in the talk as well you can only at any point",
    "start": "2367930",
    "end": "2373119"
  },
  {
    "text": "in time read committed state from dynamodb right so you're safe you're not gonna get some wacko state that that",
    "start": "2373119",
    "end": "2379119"
  },
  {
    "text": "just isn't committed or that's some kind of hodgepodge right the the you know",
    "start": "2379119",
    "end": "2384849"
  },
  {
    "text": "that the state is always recommitted right but",
    "start": "2384849",
    "end": "2390050"
  },
  {
    "text": "Ibiza is a distributed system right and so the scope of transactions is limited",
    "start": "2390050",
    "end": "2396290"
  },
  {
    "text": "to two basically some of these features so does not extend to streams what it",
    "start": "2396290",
    "end": "2402680"
  },
  {
    "text": "means the day that it's coming down the stream you could see committed data but not necessarily entire transactional set",
    "start": "2402680",
    "end": "2410680"
  },
  {
    "text": "so and again you will always be getting committed data so same with",
    "start": "2410680",
    "end": "2417380"
  },
  {
    "text": "backup/restore GSIS right these are all updated in the same old fashion as the",
    "start": "2417380",
    "end": "2422900"
  },
  {
    "text": "data is committed those updates are propagated global tables in fact very",
    "start": "2422900",
    "end": "2428420"
  },
  {
    "text": "important to know that when you create a double global table transactions are automatically disabled just because",
    "start": "2428420",
    "end": "2436060"
  },
  {
    "text": "replication for global tables is not it's not transactional same as you know",
    "start": "2436060",
    "end": "2441950"
  },
  {
    "text": "these these other features so you can opt to request basically to have global",
    "start": "2441950",
    "end": "2450290"
  },
  {
    "text": "tables and transactions coexist but you still cannot basically get transactional",
    "start": "2450290",
    "end": "2455450"
  },
  {
    "text": "behavior across global tables and finally that support that's now supports",
    "start": "2455450",
    "end": "2461630"
  },
  {
    "start": "2458000",
    "end": "2458000"
  },
  {
    "text": "transactions that's new since reinvent transact right items will write through",
    "start": "2461630",
    "end": "2467300"
  },
  {
    "text": "Dax transit get items will simply also pass through forward the get request to",
    "start": "2467300",
    "end": "2475580"
  },
  {
    "text": "dynamodb the support is implemented in Java node and and go SDKs soon to Pam is",
    "start": "2475580",
    "end": "2484430"
  },
  {
    "text": "the support in Python and dotnet that's the plan again not the promise but",
    "start": "2484430",
    "end": "2489950"
  },
  {
    "text": "that's the plan there is a note about additional reads as I mentioned earlier",
    "start": "2489950",
    "end": "2496610"
  },
  {
    "text": "right when we talked about metering and cost with Dax when you do transact write",
    "start": "2496610",
    "end": "2502460"
  },
  {
    "text": "items Dax will also invoked R and trans that get item for each item separately that's",
    "start": "2502460",
    "end": "2509930"
  },
  {
    "text": "part of that transact write item in order to update its own populate the",
    "start": "2509930",
    "end": "2514940"
  },
  {
    "text": "cash right so that'll that'll incur extra reads right to",
    "start": "2514940",
    "end": "2522580"
  },
  {
    "text": "of reeds for each basically item right that that was in the right transaction so this is also well documented",
    "start": "2522810",
    "end": "2530100"
  },
  {
    "text": "if you know this doesn't make sense or if you need a reminder I will actually",
    "start": "2530100",
    "end": "2535290"
  },
  {
    "text": "have links to to the documentation at the end so to wrap it all up best",
    "start": "2535290",
    "end": "2542370"
  },
  {
    "start": "2540000",
    "end": "2540000"
  },
  {
    "text": "practices right as always follow the the good design practices right design for",
    "start": "2542370",
    "end": "2549150"
  },
  {
    "text": "scale make sure you don't have hot keys hot spots a lot of times not possible",
    "start": "2549150",
    "end": "2555120"
  },
  {
    "text": "but it's important that the even if you know well I might I might have hot keys",
    "start": "2555120",
    "end": "2560310"
  },
  {
    "text": "hot spots that you identify those use cases and then you have a design option",
    "start": "2560310",
    "end": "2565500"
  },
  {
    "text": "to to support that right and avoiding",
    "start": "2565500",
    "end": "2570540"
  },
  {
    "text": "contention of rights is is also you know one of the key tenets with scalable",
    "start": "2570540",
    "end": "2575550"
  },
  {
    "text": "design for for no sequel databases but that said you have to deal with",
    "start": "2575550",
    "end": "2581910"
  },
  {
    "text": "conflicts right with exceptions and and those edge cases avoiding multi table",
    "start": "2581910",
    "end": "2587430"
  },
  {
    "text": "transactions the support is there and there are cases in which it might make sense and but as a general rule right if",
    "start": "2587430",
    "end": "2594750"
  },
  {
    "text": "you're if you're looking at a design that involves transactions across multiple tables step back and reconsider",
    "start": "2594750",
    "end": "2602910"
  },
  {
    "text": "right is this a good design or is this a design smell an anti-pattern and",
    "start": "2602910",
    "end": "2610250"
  },
  {
    "text": "limiting transaction scope right for liveliness you reduce the chances of",
    "start": "2610250",
    "end": "2615420"
  },
  {
    "text": "transactional conflicts you reduce the latency and you increase the throughput as well check out some of these links",
    "start": "2615420",
    "end": "2623490"
  },
  {
    "start": "2621000",
    "end": "2621000"
  },
  {
    "text": "for those of you who are here you you will have the ability to get the the",
    "start": "2623490",
    "end": "2629010"
  },
  {
    "text": "decks after you complete the surveys and that's why I have these links we do have",
    "start": "2629010",
    "end": "2634440"
  },
  {
    "text": "a few minutes for for questions okay requests to go back to this slide so",
    "start": "2634440",
    "end": "2642720"
  },
  {
    "text": "please any questions and I know it's",
    "start": "2642720",
    "end": "2648330"
  },
  {
    "text": "close to lunchtime so I perfectly understand if you we can we can wrap it up a few minutes early so that you can",
    "start": "2648330",
    "end": "2654690"
  },
  {
    "text": "go go get your food but I will hang out here for a few minutes as well if anybody",
    "start": "2654690",
    "end": "2661980"
  },
  {
    "text": "would like to talk about any of these things that we covered in this talk oh",
    "start": "2661980",
    "end": "2668810"
  },
  {
    "text": "here's a question okay so the question",
    "start": "2673310",
    "end": "2683760"
  },
  {
    "text": "is what is the reason you don't recommend multi-table multi-table transactions right it's the same reason",
    "start": "2683760",
    "end": "2689160"
  },
  {
    "text": "why we don't recommend multi-table design in the first place right and that's simply because in multi table",
    "start": "2689160",
    "end": "2695340"
  },
  {
    "text": "design you you're just not as efficient right when you when you read or write",
    "start": "2695340",
    "end": "2701850"
  },
  {
    "text": "you're actually making requests to multiple nodes in a single table design",
    "start": "2701850",
    "end": "2707040"
  },
  {
    "text": "when you have a petition key you'll notice DynamoDB api if you want to do a query operation you know get item put",
    "start": "2707040",
    "end": "2713790"
  },
  {
    "text": "item operation you have to provide a petition key you know what that means is that you're interacting with a single",
    "start": "2713790",
    "end": "2719880"
  },
  {
    "text": "node in in the back hand which is an efficient way to do it go ahead yes so",
    "start": "2719880",
    "end": "2735810"
  },
  {
    "text": "the question is once you add global secondary indexes you're effectively now interacting with yes butBut you know the",
    "start": "2735810",
    "end": "2743850"
  },
  {
    "text": "way to think about that is a global secondary index is just a another materialized view that you need one two",
    "start": "2743850",
    "end": "2751200"
  },
  {
    "text": "the way we want to interact with the global secondary index is that when we",
    "start": "2751200",
    "end": "2756860"
  },
  {
    "text": "when we request when we query we ideally only query the global secondary index so",
    "start": "2756860",
    "end": "2764400"
  },
  {
    "text": "we're still interacting with it with a single node if we do this right right",
    "start": "2764400",
    "end": "2769590"
  },
  {
    "text": "because we're projecting values that we want to query on so unlike relational",
    "start": "2769590",
    "end": "2776130"
  },
  {
    "text": "indexes that are only they only contain essentially reference back to the main",
    "start": "2776130",
    "end": "2783030"
  },
  {
    "text": "table with dynamodb if you query a GSI you shouldn't need to query the main",
    "start": "2783030",
    "end": "2789120"
  },
  {
    "text": "table right because with dynamodb you can project all the attributes that you need so if you look at a query and you",
    "start": "2789120",
    "end": "2796830"
  },
  {
    "text": "say you know I need to project everything because I'm going to essentially query everything one of the",
    "start": "2796830",
    "end": "2804330"
  },
  {
    "text": "principles and no sequel is we make multiple copies of data and that's okay",
    "start": "2804330",
    "end": "2809640"
  },
  {
    "text": "that part of the normalization is you know we're gonna have denormalized",
    "start": "2809640",
    "end": "2814650"
  },
  {
    "text": "schema multiple copies and we're going to project what we need to that GSI so",
    "start": "2814650",
    "end": "2821310"
  },
  {
    "text": "that we only need to query the GSI itself and not the table yeah so you're",
    "start": "2821310",
    "end": "2828990"
  },
  {
    "text": "right rights will have to basically be be duplicated but they're also",
    "start": "2828990",
    "end": "2834120"
  },
  {
    "text": "duplicated for you right you don't have to do it there and that's not a synchronously as well right and that's",
    "start": "2834120",
    "end": "2840210"
  },
  {
    "text": "kind of the the the main reason to have it basically done in an asynchronous",
    "start": "2840210",
    "end": "2846690"
  },
  {
    "text": "manner is to protect that low latency of your rights you know to the main table",
    "start": "2846690",
    "end": "2855410"
  },
  {
    "text": "all right and it might be just time to have lunch right thank you all so much they care",
    "start": "2855410",
    "end": "2866120"
  }
]