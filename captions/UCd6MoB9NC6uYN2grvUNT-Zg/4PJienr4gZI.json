[
  {
    "text": "- [Matt] Hello and welcome to part two of the IAM Policy Evaluation video series. My name is Matt Luttrell,",
    "start": "810",
    "end": "6840"
  },
  {
    "text": "and today we're going to\ntalk about conditions. We'll start with the review\nof the condition element",
    "start": "6840",
    "end": "13830"
  },
  {
    "text": "from part one of this series. We'll do a deep dive of\ndifferent condition operators.",
    "start": "13830",
    "end": "19323"
  },
  {
    "text": "We'll then go through the difference between multi-valued and\nsingle-valued condition keys,",
    "start": "20370",
    "end": "25233"
  },
  {
    "text": "and then we'll take a look at\npatterns used to make requests and how that impacts what condition keys",
    "start": "26490",
    "end": "32520"
  },
  {
    "text": "you should use in your policies. Let's start with our review\nof the condition element.",
    "start": "32520",
    "end": "39340"
  },
  {
    "text": "As we saw in part one of this series, the condition element\nis an optional element that lets you specify when\na policy is in effect.",
    "start": "41460",
    "end": "49829"
  },
  {
    "text": "This policy statement\nallows an s3:GetObject or s3:PutObject request to\nthe example bucket resource,",
    "start": "49830",
    "end": "57300"
  },
  {
    "text": "but only if the request is made using TLS.",
    "start": "57300",
    "end": "60962"
  },
  {
    "text": "Let's also review what the\nauthorization context is. When you make a request to AWS,",
    "start": "63526",
    "end": "69720"
  },
  {
    "text": "we build information about that request and put that information\nin a big property bag.",
    "start": "69720",
    "end": "75299"
  },
  {
    "text": "This includes information about\nwho is making the request, the target of the request,\nand even some values",
    "start": "75300",
    "end": "81149"
  },
  {
    "text": "that you supply like tag keys and values. IAM then compares this\nauthorization context",
    "start": "81150",
    "end": "88650"
  },
  {
    "text": "to your IAM policies to determine which policy statements match and in the end if a request\nis allowed or denied.",
    "start": "88650",
    "end": "96123"
  },
  {
    "text": "The authorization context\nshown here is just an example and not a complete replica",
    "start": "97290",
    "end": "101710"
  },
  {
    "text": "of what the full authorization\ncontext will look like for a request. The important piece here\nas it relates to conditions",
    "start": "102998",
    "end": "108344"
  },
  {
    "text": "are the context keys and values that are present in the\nauthorization context.",
    "start": "108344",
    "end": "114060"
  },
  {
    "text": "You write conditions in your policies to match against these context values.",
    "start": "114060",
    "end": "118653"
  },
  {
    "text": "I also wanna quickly review definitions of the different elements\nthat make up a condition.",
    "start": "121830",
    "end": "127260"
  },
  {
    "text": "The operator defines the comparison that IAM should perform against\nthe authorization context.",
    "start": "127260",
    "end": "134069"
  },
  {
    "text": "The key defines which value\nin the authorization context IAM should look at for that comparison,",
    "start": "134070",
    "end": "140793"
  },
  {
    "text": "and the values are what must match the value in the authorization context for a statement to match.",
    "start": "142200",
    "end": "148683"
  },
  {
    "text": "There are a number of\ndifferent condition operators, and we will be going deeper\ninto some of them in this video.",
    "start": "152040",
    "end": "157769"
  },
  {
    "text": "You can also use different\nsuffixes on an operator such as equals and like\nto do exact matching",
    "start": "157770",
    "end": "163319"
  },
  {
    "text": "and wild card matching respectively. You can also add things like not to many of these operators to invert them.",
    "start": "163320",
    "end": "169830"
  },
  {
    "text": "On the right side you\ncan see what are called multi-valued qualifiers. For now, just know that these exist.",
    "start": "171000",
    "end": "178440"
  },
  {
    "text": "We will go much more\ndepth later in this video on the use of these qualifiers.",
    "start": "178440",
    "end": "183362"
  },
  {
    "text": "Now some condition keys are\nnot present in every request, which also means that\nthey are not available",
    "start": "187710",
    "end": "192780"
  },
  {
    "text": "in every authorization context. So how do you figure out which\ncondition keys can be used",
    "start": "192780",
    "end": "198209"
  },
  {
    "text": "with which actions and which resources? That's where the service\nauthorization reference comes in.",
    "start": "198210",
    "end": "204630"
  },
  {
    "text": "The service authorization reference is an IAM documentation\npage that documents our particular service's\nauthorization design.",
    "start": "204630",
    "end": "213000"
  },
  {
    "text": "The page you see here is the documentation for AWS Lambda's authorization design.",
    "start": "213000",
    "end": "218040"
  },
  {
    "text": "You can see that the particular\nLambda condition keys are associated with a particular action",
    "start": "218040",
    "end": "223170"
  },
  {
    "text": "and resource combination.",
    "start": "223170",
    "end": "224972"
  },
  {
    "text": "There's also a section\nelsewhere on each page of the service authorization reference, which contains a complete list",
    "start": "228990",
    "end": "234750"
  },
  {
    "text": "of what we call service\nspecific condition keys and their types. The types here tell you\nwhich operator you should use",
    "start": "234750",
    "end": "241860"
  },
  {
    "text": "to perform the comparison. A condition key that has a type that starts with array of",
    "start": "241860",
    "end": "247470"
  },
  {
    "text": "indicates that the condition\nkey can have multiple values in the authorization context",
    "start": "247470",
    "end": "252600"
  },
  {
    "text": "and that you should use\na multi-valued qualifier to compare it. So either for all values or for any value.",
    "start": "252600",
    "end": "259079"
  },
  {
    "text": "We'll come back to this later. There are also condition keys that work across all AWS services.",
    "start": "259080",
    "end": "265320"
  },
  {
    "text": "These condition keys are\ncalled global condition keys.",
    "start": "265320",
    "end": "268263"
  },
  {
    "text": "Global condition keys and their types are documented on a separate\npage which describes each key",
    "start": "270690",
    "end": "275730"
  },
  {
    "text": "and when you can expect to see each key in the authorization context.",
    "start": "275730",
    "end": "279783"
  },
  {
    "text": "These are two great pages to bookmark for anyone that has to write IAM policies.",
    "start": "280860",
    "end": "285363"
  },
  {
    "text": "Now getting back to our\npolicies, let's do a quick review on how the Boolean logic\nworks for conditions.",
    "start": "288780",
    "end": "293910"
  },
  {
    "text": "Before I get started, you're going to see a lot of policy examples in this video. Don't get too caught up\non the specific policies.",
    "start": "293910",
    "end": "301860"
  },
  {
    "text": "The focus on this video\nis to review the concepts and not to provide you with policies that you should copy and\npaste into your environment.",
    "start": "301860",
    "end": "309240"
  },
  {
    "text": "Okay with that values for\ncondition keys are or-ed. This means that this policy\nmatches an authorization context",
    "start": "309240",
    "end": "317580"
  },
  {
    "text": "for the IAM create role action if the tag in the request\nwith a key of team",
    "start": "317580",
    "end": "324180"
  },
  {
    "text": "has a value of team A or team B or team C.",
    "start": "324180",
    "end": "329180"
  },
  {
    "text": "If the operator is\nnegated like you see here with string not equals,\nthe values are nor-ed.",
    "start": "334590",
    "end": "341103"
  },
  {
    "text": "This policy denies the\ncreation of an IAM role if the tag in the request with key team",
    "start": "341970",
    "end": "348060"
  },
  {
    "text": "does not have a value of\nteam A nor team B nor team C.",
    "start": "348060",
    "end": "353060"
  },
  {
    "text": "And this is your way to\nadd a list of exceptions in a deny statement.",
    "start": "355410",
    "end": "359043"
  },
  {
    "text": "All condition keys in a request are logically and-ed together. This is true even if the\noperators have different names",
    "start": "364770",
    "end": "372630"
  },
  {
    "text": "as shown in this example with\nstring equals and string like. All condition keys must\nevaluate to true independently",
    "start": "372630",
    "end": "380190"
  },
  {
    "text": "for the policy statement to match.",
    "start": "380190",
    "end": "382173"
  },
  {
    "text": "Condition keys that contain an effective deny indicated operators like string not equals\nare still and-ed together",
    "start": "388170",
    "end": "394646"
  },
  {
    "text": "though they can be a\nbit trickier to follow. This pattern of multiple\nnegated condition keys",
    "start": "394646",
    "end": "400800"
  },
  {
    "text": "and a deny statement is also one that's commonly seen used when implementing an exception list.",
    "start": "400800",
    "end": "406530"
  },
  {
    "text": "This statement reads everything is denied when\ncalling the create bucket action except for the values\nlisted in these conditions.",
    "start": "406530",
    "end": "414392"
  },
  {
    "text": "All right, with that review aside, let's dive deeper into some\nof our condition operators, starting with the ARN\nand string operators.",
    "start": "417780",
    "end": "424623"
  },
  {
    "text": "Let's start by stating what\nseems like the obvious. You should use ARN operators\nfor ARN condition values",
    "start": "427620",
    "end": "432900"
  },
  {
    "text": "and use string operators\nfor string condition values, but this is for more\nthan just feeling good",
    "start": "432900",
    "end": "438210"
  },
  {
    "text": "about making our policies\nneat and readable. Let's take a look at an actual example that illustrates why this is important.",
    "start": "438210",
    "end": "444693"
  },
  {
    "text": "Adding the like suffix to the\nend of the condition operator tells the authorization engine that it should do a wild card\nmatch and not an exact match.",
    "start": "448200",
    "end": "456810"
  },
  {
    "text": "You can use the asterisk as\nyou see in these examples for a multi-character wild card match",
    "start": "456810",
    "end": "462600"
  },
  {
    "text": "or you can use a question mark for a single character wild card match. You would use the equals suffix",
    "start": "462600",
    "end": "469050"
  },
  {
    "text": "if you wanted an exact match. What I'm showing here are two statements with a condition that\ncompares the exact same value",
    "start": "469050",
    "end": "476790"
  },
  {
    "text": "for the source ARN condition key. The only difference between\nthese two statements is the condition operator.",
    "start": "476790",
    "end": "483750"
  },
  {
    "text": "The top condition uses ArnLike, and the bottom condition\nincorrectly uses StringLike.",
    "start": "483750",
    "end": "490159"
  },
  {
    "text": "Now let's say we had a request with this sample authorization context. The fictitious source Arn in\nthis example is a valid Arn,",
    "start": "492360",
    "end": "500520"
  },
  {
    "text": "and we're using an Arn operator\nto compare it in our policy.",
    "start": "500520",
    "end": "503673"
  },
  {
    "text": "Remember from part one in this series, the policy evaluation is\njust a matching exercise between the policy and\nthe authorization context.",
    "start": "508020",
    "end": "516329"
  },
  {
    "text": "So when IAM's authorization engine does this ArnLike comparison, it starts by splitting the\nArn into six distinct pieces",
    "start": "516330",
    "end": "523949"
  },
  {
    "text": "and then compares each\npiece individually like so.",
    "start": "523950",
    "end": "527163"
  },
  {
    "text": "Everything matches until we\nget to the account ID portion of the Arn, which does not match,",
    "start": "532050",
    "end": "537690"
  },
  {
    "text": "and therefore we can say that this overall condition\ncomparison does not match",
    "start": "537690",
    "end": "543060"
  },
  {
    "text": "as we would expect. Now let's take the same example",
    "start": "543060",
    "end": "549840"
  },
  {
    "text": "and use the StringLike operator. We're using the same sample\nauthorization context",
    "start": "549840",
    "end": "554880"
  },
  {
    "text": "and the same source Arn\nvalue in our condition. The only difference from\nthe previous example",
    "start": "554880",
    "end": "560339"
  },
  {
    "text": "is the StringLike operator\ninstead of the ArnLike operator.",
    "start": "560340",
    "end": "563913"
  },
  {
    "text": "This time when IAM's authorization engine does the string like comparison. It doesn't split the Arn into pieces.",
    "start": "565920",
    "end": "573000"
  },
  {
    "text": "Instead it does a raw string comparison which ends up looking something like this.",
    "start": "573000",
    "end": "577709"
  },
  {
    "text": "The first part looks good\nand matches our expectations, but then we get to the\nwild card in the condition,",
    "start": "578940",
    "end": "586290"
  },
  {
    "text": "and the wild card is\ngoing to end up matching more of the Arn than we expected,",
    "start": "586290",
    "end": "590853"
  },
  {
    "text": "and this means that the rest\nof the Arn also matches, so with the same exact\ncondition key, condition value",
    "start": "593430",
    "end": "600510"
  },
  {
    "text": "and authorization context, but using a different condition operator,",
    "start": "600510",
    "end": "605642"
  },
  {
    "text": "we produce two different results for this particular evaluation. Now this won't be the\ncase for every evaluation,",
    "start": "605642",
    "end": "613290"
  },
  {
    "text": "but save yourself a possible headache here and make sure you're using\nArn operators for Arns and string operators for strings.",
    "start": "613290",
    "end": "620133"
  },
  {
    "text": "One last unrelated note\nabout Arn comparisons before we move on. The behavior of ArnLike and ArnEquals",
    "start": "622980",
    "end": "628860"
  },
  {
    "text": "are actually equivalent, meaning that ArnEquals also\ndoes wild card matching,",
    "start": "628860",
    "end": "633870"
  },
  {
    "text": "and this works this way\nmostly for historical reasons. This equivalence also applies\nto the negated versions",
    "start": "633870",
    "end": "639840"
  },
  {
    "text": "of these operators so are not like and are not equals are also equivalent.",
    "start": "639840",
    "end": "644193"
  },
  {
    "text": "So again, use the Arn operators for Arns, and use the string operators for strings.",
    "start": "647490",
    "end": "653010"
  },
  {
    "text": "This will help you avoid the possibility of the behavior you saw in this example.",
    "start": "653010",
    "end": "657363"
  },
  {
    "text": "Now moving on to two\nother types of operators, IfExists and Null.",
    "start": "661230",
    "end": "665534"
  },
  {
    "text": "The null condition operator checks to see if the condition key is absent from the authorization context.",
    "start": "669614",
    "end": "675390"
  },
  {
    "text": "The null operator evaluates\nto true when a key is absent. This can be useful if you want\nto just check for the absence",
    "start": "675390",
    "end": "682620"
  },
  {
    "text": "or existence of a condition key, but you don't care what the\nactual value of the key is.",
    "start": "682620",
    "end": "687630"
  },
  {
    "text": "In the example you see here, we deny the creation and\nmodification of a lambda function",
    "start": "687630",
    "end": "693060"
  },
  {
    "text": "unless the function is\nattached to any VPC. Here we don't care what\nVPC it's attached to.",
    "start": "693060",
    "end": "699540"
  },
  {
    "text": "Just the fact that it has an attachment is good enough for us.",
    "start": "699540",
    "end": "702903"
  },
  {
    "text": "If we look at this sample\nauthorization context, you can see that there's no Lambda\nVpcIds Context key present,",
    "start": "706050",
    "end": "712918"
  },
  {
    "text": "meaning that our null condition operator from the policy we just\nsaw would evaluate to true.",
    "start": "712918",
    "end": "718143"
  },
  {
    "text": "The IfExists operator\nworks in a similar way, but it also allows us to effectively include another comparison.",
    "start": "723374",
    "end": "729870"
  },
  {
    "text": "You can attach the IfExists\noperator as a suffix to the end of any other condition operator",
    "start": "729870",
    "end": "734970"
  },
  {
    "text": "except for the null operator. Now this policy looks similar\nto the one we just saw,",
    "start": "734970",
    "end": "740280"
  },
  {
    "text": "and the string equals IfExists operator says that this condition will match if either the VpcIds key is absent",
    "start": "740280",
    "end": "747828"
  },
  {
    "text": "from the authorization\ncontext or the key is present and equal to the ID specified.",
    "start": "747828",
    "end": "754652"
  },
  {
    "text": "Now again, don't get too caught up in the actual details of these policies. We are just worried\nabout the concepts here.",
    "start": "755940",
    "end": "761560"
  },
  {
    "text": "If you think about IfExists\nin terms of the null operator, the string equals IfExists example",
    "start": "766080",
    "end": "771630"
  },
  {
    "text": "that we just saw is shorthand\nthat roughly translates to these two separate statements.",
    "start": "771630",
    "end": "777450"
  },
  {
    "text": "On the left you have deny\nlambda function creation or modification for the specified VPC,",
    "start": "777450",
    "end": "783243"
  },
  {
    "text": "and on the right you have\ndeny creation or modification if no VPC is specified.",
    "start": "784110",
    "end": "788793"
  },
  {
    "text": "Now what happens if we\nuse the IfExists operator with an effective allow? The author of this policy wants\nto say that only principles",
    "start": "795000",
    "end": "802710"
  },
  {
    "text": "with a job title tag of developer should be able to run an EC2 instance,",
    "start": "802710",
    "end": "808410"
  },
  {
    "text": "but the problem here is that this policy also allows principles without any job title tag at\nall to run an EC2 instance.",
    "start": "808410",
    "end": "815673"
  },
  {
    "text": "Be careful when using\nIfExists and allow statement and make sure that you understand what the behavior of your policy is",
    "start": "816510",
    "end": "823140"
  },
  {
    "text": "if a context key is not present in the authorization context.",
    "start": "823140",
    "end": "826803"
  },
  {
    "text": "One last note before we move on. If exists has no impact on the evaluation when used with a negated\ncondition operator",
    "start": "831570",
    "end": "838410"
  },
  {
    "text": "as seen on the left. These two policies are equivalent, and the IfExists is unnecessary.",
    "start": "838410",
    "end": "843933"
  },
  {
    "text": "Now that said, if you're\nwriting guardrails like service control policies,\nit can sometimes be useful",
    "start": "844950",
    "end": "850350"
  },
  {
    "text": "to just include IfExists at the end of your condition operators as a bit of a safety net,",
    "start": "850350",
    "end": "854853"
  },
  {
    "text": "and that's because these\npolicies typically have an effective deny, and\nwhen you write guardrails like service control policies,\nyou often want to deny",
    "start": "855720",
    "end": "863670"
  },
  {
    "text": "if the context key is not present. Adding IfExists by default just saves you from having to reason",
    "start": "863670",
    "end": "869550"
  },
  {
    "text": "about this type of\nbehavior for each operator in a deny policy.",
    "start": "869550",
    "end": "873693"
  },
  {
    "text": "Okay, onto what might be\nthe most important concept in this video, multi-valued\ncondition keys.",
    "start": "877830",
    "end": "884220"
  },
  {
    "text": "Now the examples I'm going\nto use in this section primarily deal with tags. There's no significance to that",
    "start": "884220",
    "end": "889649"
  },
  {
    "text": "other than the tagging condition\nkeys tend to make it easier to explain some of these concepts.",
    "start": "889650",
    "end": "894363"
  },
  {
    "text": "Pause the video, take\na look at this policy, and see if you can figure\nout what's wrong with it.",
    "start": "897330",
    "end": "902250"
  },
  {
    "text": "Okay, hold your thought. I'm going to give you the answer in a bit, but I want to walk you through\nhow this behaves first.",
    "start": "907710",
    "end": "914943"
  },
  {
    "text": "Now back to our sample\nauthorization context, and if you take away nothing\nelse from this section,",
    "start": "918120",
    "end": "923730"
  },
  {
    "text": "remember that when we\nsay multi-valued keys, it means that the context key is capable of having multiple values",
    "start": "923730",
    "end": "931140"
  },
  {
    "text": "in the authorization context. The only multi-valued key in this sample authorization\ncontext is AWS tag keys,",
    "start": "931140",
    "end": "940290"
  },
  {
    "text": "which has three independent\nvalues in this example. Every other context key that you see here",
    "start": "940290",
    "end": "946889"
  },
  {
    "text": "is a single valued key and can only ever have a single value in the authorization context.",
    "start": "946890",
    "end": "953493"
  },
  {
    "text": "When you have a multi-valued key, you should use a multi-valued qualifier with your condition operator",
    "start": "956970",
    "end": "963030"
  },
  {
    "text": "either for any value or for all values. The statement on the\nleft uses for any value",
    "start": "963030",
    "end": "969660"
  },
  {
    "text": "and allows the creation of an IAM role if any one value for tag\nkeys in the auth context",
    "start": "969660",
    "end": "976860"
  },
  {
    "text": "appears in this possible list of values, so either team A or team B.",
    "start": "976860",
    "end": "981963"
  },
  {
    "text": "There can be other tag keys\nvalues in the auth context, but one of them must be team A or team B.",
    "start": "982860",
    "end": "988923"
  },
  {
    "text": "The statement on the\nright uses for all values and allows the creation of an IAM role",
    "start": "989970",
    "end": "995100"
  },
  {
    "text": "if all values for tag\nkeys in the auth context are found in the list\nspecified in this statement.",
    "start": "995100",
    "end": "1001760"
  },
  {
    "text": "So for the statement on\nthe right side to match, all of the tag keys\nvalues in the auth context",
    "start": "1001760",
    "end": "1006830"
  },
  {
    "text": "must be team A or team B. You don't have to have both, but you can't have a value like\nteam C in the auth context.",
    "start": "1006830",
    "end": "1014453"
  },
  {
    "text": "Importantly, multi value does not refer to the number of values\nin your IAM policy.",
    "start": "1018140",
    "end": "1024410"
  },
  {
    "text": "It refers to the number of values in the authorization context. The operator you see here, principle tag",
    "start": "1024410",
    "end": "1031970"
  },
  {
    "text": "is not a multi-valued key even though this statement is written to have multiple values in the IAM policy.",
    "start": "1031970",
    "end": "1039412"
  },
  {
    "text": "You should not use for any value or for all values for\nstatements like this.",
    "start": "1040400",
    "end": "1045233"
  },
  {
    "text": "So let's test our understanding\nwith a matching example. Feel free to pause the video and try to determine if this statement",
    "start": "1048620",
    "end": "1055429"
  },
  {
    "text": "should allow or deny the request.",
    "start": "1055430",
    "end": "1057533"
  },
  {
    "text": "The way to go about evaluating\nthis statement in your head is to start with the\nvalues in the auth context.",
    "start": "1061580",
    "end": "1066860"
  },
  {
    "text": "Go through each value and see if it's allowed by the statement. Remember that every\nvalue in the auth context",
    "start": "1066860",
    "end": "1072860"
  },
  {
    "text": "must be allowed by the statement because we're using for all values here. Let's look at the tag keys context key",
    "start": "1072860",
    "end": "1079940"
  },
  {
    "text": "and start with team A. We see that team A is\nallowed by the statement, so we move on to the next value.",
    "start": "1079940",
    "end": "1087080"
  },
  {
    "text": "Team B is also allowed by the statement. When we get to team C, we\nsee that there's no team C",
    "start": "1087080",
    "end": "1092990"
  },
  {
    "text": "in our statement, so we can say that this statement does not match and access would not be\nallowed by this statement.",
    "start": "1092990",
    "end": "1099593"
  },
  {
    "text": "Now what happens if there\nare no tags in the request, and tag keys is not present\nat all in the auth context?",
    "start": "1103490",
    "end": "1110033"
  },
  {
    "text": "The statement here actually\nmatches and would be allowed. This might be surprising to you,",
    "start": "1113990",
    "end": "1119420"
  },
  {
    "text": "and it's definitely something\nthat you should be aware of. A condition operator using\nthe for all values qualifier",
    "start": "1119420",
    "end": "1125180"
  },
  {
    "text": "will evaluate to true if the context key is not present in the auth context.",
    "start": "1125180",
    "end": "1130643"
  },
  {
    "text": "Let's look a little closer\nat how this evaluation works for a single condition key.",
    "start": "1134000",
    "end": "1138053"
  },
  {
    "text": "We start with true before\nany comparisons are done. We loop through each\nvalue in the auth context,",
    "start": "1139640",
    "end": "1147800"
  },
  {
    "text": "not the policy. If the value is not present\nin the auth context, there's nothing to loop\nthrough, and we stop here",
    "start": "1147800",
    "end": "1154280"
  },
  {
    "text": "and return true. If it is present, we look at\neach value in the auth context",
    "start": "1154280",
    "end": "1160760"
  },
  {
    "text": "and ask the question, does this value match\na value in the policy?",
    "start": "1160760",
    "end": "1165770"
  },
  {
    "text": "Here we're looking for\na string equals match with this statement on the right.",
    "start": "1165770",
    "end": "1169580"
  },
  {
    "text": "If yes, we continue and\nlook at the next value in the auth context. If there's no match, this\nevaluation returns false",
    "start": "1171350",
    "end": "1179180"
  },
  {
    "text": "as every value in the\nauth context must match when we're using for all values.",
    "start": "1179180",
    "end": "1183862"
  },
  {
    "text": "So knowing what we know now, if we go back to that original statement, the problem with this policy",
    "start": "1188330",
    "end": "1193879"
  },
  {
    "text": "is that not only does it allow a principal with a team infrastructure\ntag to run instances,",
    "start": "1193880",
    "end": "1200540"
  },
  {
    "text": "but it also allows principles\nthat have no team tag at all to run instances,",
    "start": "1200540",
    "end": "1205850"
  },
  {
    "text": "and this is due to the\nbehavior of for all values when the context key is not present in the authorization context.",
    "start": "1205850",
    "end": "1212693"
  },
  {
    "text": "Here's what the statement should look like with no for all values for the single value and\nprincipal tag condition key.",
    "start": "1216140",
    "end": "1222360"
  },
  {
    "text": "Now even if you correctly\nuse for all values with a multi-valued condition key as seen here in this example statement,",
    "start": "1227900",
    "end": "1233810"
  },
  {
    "text": "you probably want to be explicit about whether you expect the key to be present in the auth context or not,",
    "start": "1233810",
    "end": "1240679"
  },
  {
    "text": "especially when used in a\nstatement with an effect of allow as you see here.",
    "start": "1240680",
    "end": "1245123"
  },
  {
    "text": "The addition of this null\ncheck ensures that tag keys must be present in the auth\ncontext and eliminates the need",
    "start": "1246290",
    "end": "1253190"
  },
  {
    "text": "to worry about for all\nvalues evaluating to true when the key is not present\nin the auth context.",
    "start": "1253190",
    "end": "1259340"
  },
  {
    "text": "Without the null check you see here, this statement would evaluate to true when there is no tag keys\npresent in the auth context.",
    "start": "1259340",
    "end": "1267743"
  },
  {
    "text": "Moving on to the other\nqualifier, for any value. The for any value qualifier\nshould also only be used",
    "start": "1271850",
    "end": "1278929"
  },
  {
    "text": "with multi-valued keys. This statement shows an incorrect use of the for any value condition key.",
    "start": "1278930",
    "end": "1284700"
  },
  {
    "text": "Let's look at how that statement behaves for a request made by a\nprincipal without a team tag.",
    "start": "1289070",
    "end": "1293513"
  },
  {
    "text": "A for any value evaluation\nstarts with false.",
    "start": "1296081",
    "end": "1298453"
  },
  {
    "text": "Similar to what we did\nwith for all values, we loop through each\nvalue in the off context.",
    "start": "1301190",
    "end": "1306803"
  },
  {
    "text": "For each of the values,\nwe apply the operator to the value in the auth context.",
    "start": "1308390",
    "end": "1313640"
  },
  {
    "text": "As soon as we get one match, we can evaluate the condition to true. If the value in the auth\ncontext is not a match,",
    "start": "1313640",
    "end": "1320779"
  },
  {
    "text": "we continue onto the next value until we've exhausted all\nvalues in the auth context.",
    "start": "1320780",
    "end": "1325433"
  },
  {
    "text": "So if we look at this algorithm, if there are no values\nin the auth context, we can ignore steps two and three,",
    "start": "1327080",
    "end": "1333440"
  },
  {
    "text": "and this condition just\nevaluates to false, and this statement does not match, meaning access is not denied\nwith this example statement.",
    "start": "1333440",
    "end": "1341693"
  },
  {
    "text": "Now this is contrary to\nwhat you probably wanted if you authored this statement, expected if the team\nprinciple tag was not team A,",
    "start": "1342530",
    "end": "1350360"
  },
  {
    "text": "then access would be denied.",
    "start": "1350360",
    "end": "1351893"
  },
  {
    "text": "You probably wanted something like this which correctly denies the request unless the team principle\ntag has a value of admin.",
    "start": "1356960",
    "end": "1364193"
  },
  {
    "text": "So it's also important to ensure that you only use for any value with multi-valued keys as well.",
    "start": "1365270",
    "end": "1371033"
  },
  {
    "text": "Now is a good time to remind you that the actual policy statements here are for illustrative purposes only,",
    "start": "1372800",
    "end": "1378560"
  },
  {
    "text": "and we are just focused on the concepts.",
    "start": "1378560",
    "end": "1380693"
  },
  {
    "text": "Remember from earlier\nthat you can determine if a condition key is\nmulti-valued or single-valued by looking at the service\nauthorization reference",
    "start": "1386210",
    "end": "1393679"
  },
  {
    "text": "or the global condition keys page. A condition key is multi\nvalued if it has a type",
    "start": "1393680",
    "end": "1398960"
  },
  {
    "text": "that starts with array of. Every other condition\nkey that you see here is single valued.",
    "start": "1398960",
    "end": "1405023"
  },
  {
    "text": "Okay, at the risk of repeating\nmyself too many times, do not use multi-valued operators\nwith single-valued keys,",
    "start": "1409160",
    "end": "1416690"
  },
  {
    "text": "and make sure you understand\nwhat the behavior is when a context key does not\nexist in the auth context",
    "start": "1416690",
    "end": "1422630"
  },
  {
    "text": "for both of the multi-valued qualifiers, and be extra careful\nwhen using for all values",
    "start": "1422630",
    "end": "1427970"
  },
  {
    "text": "with an effective allow. Make sure you add that null check.",
    "start": "1427970",
    "end": "1431543"
  },
  {
    "text": "Let's move on to a brief\nlook at policy variables.",
    "start": "1436040",
    "end": "1438737"
  },
  {
    "text": "Policy variables can be\nused to substitute values from the auth context into\nyour policy at evaluation time.",
    "start": "1442357",
    "end": "1448880"
  },
  {
    "text": "You can substitute any\nvalue from the auth context. The policy shown here only\nallows role assumption",
    "start": "1448880",
    "end": "1455900"
  },
  {
    "text": "when the account of the resource is equal to the account of the principle, and it does so without having to hard code",
    "start": "1455900",
    "end": "1462350"
  },
  {
    "text": "any account ID in the policy. One thing to call out\nis that you need to use",
    "start": "1462350",
    "end": "1469010"
  },
  {
    "text": "the 2012 policy version in your policies to use policy variables.",
    "start": "1469010",
    "end": "1473573"
  },
  {
    "text": "So when this policy with\npolicy variables is evaluated, the evaluation engine will\npull both the principal account",
    "start": "1478070",
    "end": "1484250"
  },
  {
    "text": "and the resource account values from the auth context and compare them. Now this can be a useful\nway to write a policy once",
    "start": "1484250",
    "end": "1491120"
  },
  {
    "text": "and scale it across your organization.",
    "start": "1491120",
    "end": "1493043"
  },
  {
    "text": "You can also use policy\nvariables and resources, and they work in the same way. The value is substituted\nat evaluation time.",
    "start": "1497900",
    "end": "1505160"
  },
  {
    "text": "So this policy could be used\nto grant put object access to a specific S3 bucket prefix",
    "start": "1505160",
    "end": "1510950"
  },
  {
    "text": "that's based on a principal's tags,",
    "start": "1510950",
    "end": "1512992"
  },
  {
    "text": "but you can only use policy\nvariables in the resource name, which is the rightmost portion of the arn.",
    "start": "1517640",
    "end": "1523880"
  },
  {
    "text": "You can't use them elsewhere\nas this policy attempts to do. This is not a valid policy.",
    "start": "1523880",
    "end": "1528683"
  },
  {
    "text": "What if the policy variable isn't present in the authorization context? Well, it effectively resolves\nto a null value in that case,",
    "start": "1534740",
    "end": "1542600"
  },
  {
    "text": "so the statement listed here that tries to compare to\na non-existent team tag in the request would not match.",
    "start": "1542600",
    "end": "1548753"
  },
  {
    "text": "Okay, that was a quick\nlook at policy variables. In addition to a requirement\nto use the 2012 policy version,",
    "start": "1554930",
    "end": "1561020"
  },
  {
    "text": "there are a few other\nthings to keep in mind. Multi-valued condition keys cannot be used",
    "start": "1561020",
    "end": "1566540"
  },
  {
    "text": "in policy variables, and policy\nvariables can only be used with string, bool and\nARN condition operators,",
    "start": "1566540",
    "end": "1574190"
  },
  {
    "text": "and as I already mentioned, they can also be used with resources but only in the resource name\nportion of the resource ARN.",
    "start": "1574190",
    "end": "1582053"
  },
  {
    "text": "Okay, so it's one thing to know how condition keys are evaluated and how the different\ncondition operators work,",
    "start": "1585688",
    "end": "1591890"
  },
  {
    "text": "but you also need to\nunderstand when it makes sense to use a given condition\nkey in your policies.",
    "start": "1591890",
    "end": "1597200"
  },
  {
    "text": "And in this section we're\ngoing to walk through the different patterns\nused to make AWS requests",
    "start": "1597200",
    "end": "1602450"
  },
  {
    "text": "and see what condition keys you can use for each type of pattern. Let's get into it.",
    "start": "1602450",
    "end": "1607583"
  },
  {
    "text": "There are two main categories of patterns used to make a request. The first category of patterns\nincludes the different ways",
    "start": "1611060",
    "end": "1618680"
  },
  {
    "text": "AWS services make requests on your behalf or to your resources. We call these service impersonation\nand delegation patterns,",
    "start": "1618680",
    "end": "1627140"
  },
  {
    "text": "and those are service\nroles, service linked roles, forward access sessions\nand service principles.",
    "start": "1627140",
    "end": "1635003"
  },
  {
    "text": "The second category is what I'm calling direct requests made by you and more or less contains requests",
    "start": "1636080",
    "end": "1641720"
  },
  {
    "text": "that don't fall in the first category. These are requests that you make using credentials that\nyou have direct access to.",
    "start": "1641720",
    "end": "1648800"
  },
  {
    "text": "An example here could be\nrequests that are made from outside of AWS using the CLI or SDK",
    "start": "1648800",
    "end": "1654470"
  },
  {
    "text": "or by humans accessing the\nconsole just to name a few. Let's talk more about the\nsignificance of these patterns.",
    "start": "1654470",
    "end": "1661700"
  },
  {
    "text": "Requests made directly are\nthe most straightforward. This is simply when you\nassume a role on your own",
    "start": "1664670",
    "end": "1670340"
  },
  {
    "text": "and make requests to an AWS service. Role assumption here can be either through\nsome type of federation",
    "start": "1670340",
    "end": "1676936"
  },
  {
    "text": "or by calling STS assume role directly. Now you can substitute\nIAM users for IAM roles for most of this conversation,",
    "start": "1676937",
    "end": "1683330"
  },
  {
    "text": "but I'm going to keep\nthe focus on IAM roles since IAM roles and their\nshort term credentials are the recommended way\nto make direct requests.",
    "start": "1683330",
    "end": "1690563"
  },
  {
    "text": "Now requests made with\nservice roles are similar, but the difference with the service role is that an AWS service assumes your role",
    "start": "1694667",
    "end": "1702001"
  },
  {
    "text": "and then makes calls on your behalf.",
    "start": "1702001",
    "end": "1705353"
  },
  {
    "text": "Oftentimes these calls will originate from the account and network\nthat the AWS service lives in",
    "start": "1708380",
    "end": "1714679"
  },
  {
    "text": "and will therefore impact\nwhat values are set for networking specific context keys",
    "start": "1714680",
    "end": "1720140"
  },
  {
    "text": "in the authorization context.",
    "start": "1720140",
    "end": "1722213"
  },
  {
    "text": "Requests made by service roles\nand requests made directly behave similarly. Because the principles that\nmake both types of requests",
    "start": "1727070",
    "end": "1734570"
  },
  {
    "text": "belong to you, both of\nthese request patterns can be controlled by\npolicies on the identity,",
    "start": "1734570",
    "end": "1740120"
  },
  {
    "text": "meaning policies such\nas identity policies, permissions boundaries, and service control policies or SCPs.",
    "start": "1740120",
    "end": "1747320"
  },
  {
    "text": "They can also be controlled by policies that are attached to a resource like resource-based policies.",
    "start": "1747320",
    "end": "1752273"
  },
  {
    "text": "You can expect condition key values in the authorization context\nfor these two request patterns to be the same or similar.",
    "start": "1755210",
    "end": "1762140"
  },
  {
    "text": "The one exception that we talked about is that requests from service roles may come from the account and network",
    "start": "1762140",
    "end": "1768350"
  },
  {
    "text": "that the AWS service lives in, and you'll need to account for that in policies that reference\nnetworking condition keys.",
    "start": "1768350",
    "end": "1775343"
  },
  {
    "text": "Service linked roles look and feel similar to service roles. A service assumes a service linked role",
    "start": "1779300",
    "end": "1786120"
  },
  {
    "text": "and makes a call on your behalf. There's one major difference here, and that's the fact that you can't modify",
    "start": "1787910",
    "end": "1794510"
  },
  {
    "text": "a service linked role directly. The AWS service associated\nwith that service linked role",
    "start": "1794510",
    "end": "1799910"
  },
  {
    "text": "owns and manages the creation\nand modification of the role.",
    "start": "1799910",
    "end": "1802973"
  },
  {
    "text": "The fact that a service linked role is managed by an AWS service means that you cannot control\nthe policies on the identity,",
    "start": "1806510",
    "end": "1813500"
  },
  {
    "text": "meaning you can't modify\nthe identity based policy or do something like attach\na permissions boundary to a service linked role.",
    "start": "1813500",
    "end": "1820610"
  },
  {
    "text": "Service linked roles are also not subject to your service control policies.",
    "start": "1820610",
    "end": "1824873"
  },
  {
    "text": "You can however control\nservice linked roles through policies on your resources using something like a\nresource-based policy",
    "start": "1825980",
    "end": "1833120"
  },
  {
    "text": "to allow or deny access\nto service linked roles. And these roles are always created",
    "start": "1833120",
    "end": "1839330"
  },
  {
    "text": "in a specific reserved role\npath with a specific prefix on the role's name.",
    "start": "1839330",
    "end": "1844493"
  },
  {
    "text": "Knowing this helps you speak generally about service linked roles when you write policies that impact them.",
    "start": "1845450",
    "end": "1850470"
  },
  {
    "text": "Here's some but not all\nof the condition keys that can be helpful to use\nwhen referencing requests",
    "start": "1855050",
    "end": "1860060"
  },
  {
    "text": "made by the patterns that\nwe've talked about so far in your IAM policies. These keys allow you to authorize requests",
    "start": "1860060",
    "end": "1866659"
  },
  {
    "text": "based on different\nproperties of the principals. These keys are all set\nin a similar fashion",
    "start": "1866660",
    "end": "1872120"
  },
  {
    "text": "for the three patterns of requests that we've talked about so\nfar, and all of these keys are what we call global condition keys.",
    "start": "1872120",
    "end": "1878873"
  },
  {
    "text": "Now let's talk about forward\naccess sessions or FAS. FAS is a technology that's\nused by AWS services",
    "start": "1883760",
    "end": "1890900"
  },
  {
    "text": "to allow a service to make\na request to another service on your behalf.",
    "start": "1890900",
    "end": "1896419"
  },
  {
    "text": "The request appears to\nthe downstream service as if it was made by your principal, my role in the image you see here.",
    "start": "1896420",
    "end": "1903473"
  },
  {
    "text": "Let's see how this works. The process starts when\nyour role makes a request",
    "start": "1903473",
    "end": "1909530"
  },
  {
    "text": "to a service, in this case\na create stack request to the cloud formation service.",
    "start": "1909530",
    "end": "1915680"
  },
  {
    "text": "Notice the via AWS service\ncondition key here, which is set to false\nfor this initial call",
    "start": "1915680",
    "end": "1921679"
  },
  {
    "text": "and all calls that do\nnot use this FAS pattern.",
    "start": "1921680",
    "end": "1925193"
  },
  {
    "text": "The cloud formation service\nthen makes a request on your behalf to another\nservice, in this case to DynamoDB",
    "start": "1928190",
    "end": "1935270"
  },
  {
    "text": "to create a table. This is the request that's made using FAS.",
    "start": "1935270",
    "end": "1940133"
  },
  {
    "text": "It sets the via AWS service\ncondition key value to true and attaches some additional context keys",
    "start": "1941240",
    "end": "1947747"
  },
  {
    "text": "including the called Via context key, which indicates which service\nthis request originated from",
    "start": "1947748",
    "end": "1955700"
  },
  {
    "text": "on your behalf. And finally, DynamoDB\nmakes a request to KMS",
    "start": "1955700",
    "end": "1962780"
  },
  {
    "text": "to create a grant, and it also does so using FAS. You can see that the DynamoDB service",
    "start": "1962780",
    "end": "1969230"
  },
  {
    "text": "gets appended to the value of\nthe called Via condition key, which is a multi-valued\ncondition key showing KMS",
    "start": "1969230",
    "end": "1976370"
  },
  {
    "text": "that this request also\npassed through DynamoDB.",
    "start": "1976370",
    "end": "1979313"
  },
  {
    "text": "FAS requests can also be controlled by policies on the identity\nand policies on the resource, and this includes\nservice control policies.",
    "start": "1984890",
    "end": "1992153"
  },
  {
    "text": "FAS requests are also going to have similar condition key values\nto the other request patterns that we've seen thus far.",
    "start": "1994490",
    "end": "2000073"
  },
  {
    "text": "Since FAS requests are actually\nmade by an AWS service, the networking context key\nvalues for those requests",
    "start": "2000940",
    "end": "2008110"
  },
  {
    "text": "may belong to networks\nthat AWS services own and not networks that you own,",
    "start": "2008110",
    "end": "2013900"
  },
  {
    "text": "and you'll need to take that into account when building network-based IAM policies.",
    "start": "2013900",
    "end": "2019030"
  },
  {
    "text": "As mentioned, FAS requests also add some additional context keys and values",
    "start": "2019030",
    "end": "2024640"
  },
  {
    "text": "that express what path the request took through various AWS services.",
    "start": "2024640",
    "end": "2029803"
  },
  {
    "text": "The important takeaway\nabout FAS in general though is that the request appears to come",
    "start": "2032080",
    "end": "2037180"
  },
  {
    "text": "from the original principal\nto each service in the chain, but each service attaches additional data",
    "start": "2037180",
    "end": "2043090"
  },
  {
    "text": "to the auth context as the request traverses the chain. And this allows you to do\nthings like write policies",
    "start": "2043090",
    "end": "2050139"
  },
  {
    "text": "that only allow actions when they are called through a service but not allow them when\nthey are called directly.",
    "start": "2050140",
    "end": "2056250"
  },
  {
    "text": "If we look at the list\nof helpful condition keys for FAS requests, you can see that the same principal-centric\ncondition keys",
    "start": "2060070",
    "end": "2066879"
  },
  {
    "text": "here on the left that were useful for the other request patterns\nthat we've talked about remain useful for FAS requests.",
    "start": "2066880",
    "end": "2073510"
  },
  {
    "text": "In addition, we've talked\nabout the via AWS service and called Via Condition keys",
    "start": "2073510",
    "end": "2078879"
  },
  {
    "text": "that are added when a\nrequest is made using FAS. Here you can see there's\nalso condition keys",
    "start": "2078880",
    "end": "2084309"
  },
  {
    "text": "whose values specify the first service in that chain that we saw and the last service in that chain.",
    "start": "2084310",
    "end": "2090793"
  },
  {
    "text": "Okay, and lastly, let's talk\nabout service principals. A service principal is more or less",
    "start": "2096250",
    "end": "2102220"
  },
  {
    "text": "just a collection of AWS accounts that all belong to a particular service.",
    "start": "2102220",
    "end": "2107320"
  },
  {
    "text": "The concept of a service principal lets you allow or deny access to requests coming from AWS\nservices without having to know",
    "start": "2107320",
    "end": "2114609"
  },
  {
    "text": "their account IDs or role names. It also identifies these requests\nas coming from a principal",
    "start": "2114610",
    "end": "2120730"
  },
  {
    "text": "belonging to an AWS service.",
    "start": "2120730",
    "end": "2122623"
  },
  {
    "text": "When a service principal makes\na request to your resource, similar to what we saw with forward access sessions or FAS,",
    "start": "2126520",
    "end": "2133180"
  },
  {
    "text": "we attach additional\nmetadata to the request. This time you can see\ntwo new additional sets",
    "start": "2133180",
    "end": "2139360"
  },
  {
    "text": "of context keys and\nvalues in the requests.",
    "start": "2139360",
    "end": "2141583"
  },
  {
    "text": "The first set of context keys identifies that the request is indeed made by a service principal as well as which service principal",
    "start": "2144501",
    "end": "2151270"
  },
  {
    "text": "actually made the request. We're going to go into more detail",
    "start": "2151270",
    "end": "2156760"
  },
  {
    "text": "about the second set of\ncontext keys in a second, but these are the context keys that allow you to implement\nconfused deputy protection",
    "start": "2156760",
    "end": "2163270"
  },
  {
    "text": "on your resources. This set of context keys specify\ndetails about the resource",
    "start": "2163270",
    "end": "2168580"
  },
  {
    "text": "that originated the request\nmade by the service principal. For now, just know that\nthese keys are populated",
    "start": "2168580",
    "end": "2175060"
  },
  {
    "text": "when a service principal makes a request.",
    "start": "2175060",
    "end": "2177193"
  },
  {
    "text": "Like service linked roles, service principals can only be controlled by policies on your resources.",
    "start": "2180940",
    "end": "2186369"
  },
  {
    "text": "They're not principals that\nbelong to your organization, so your service control policies and other policies on\nidentities do not apply to them.",
    "start": "2186370",
    "end": "2193362"
  },
  {
    "text": "When you write a policy on a resource that allows access to a service principal, you should include one\nof the condition keys",
    "start": "2194530",
    "end": "2200680"
  },
  {
    "text": "from the source family of\ncondition keys that you see here.",
    "start": "2200680",
    "end": "2203630"
  },
  {
    "text": "Now let's talk about\nwhy you should do that, and to do so, we'll take\na look at an example with a bucket policy",
    "start": "2207790",
    "end": "2214060"
  },
  {
    "text": "that allows the Cloud\nTrail Service principal to write logs to an S3 bucket.",
    "start": "2214060",
    "end": "2218383"
  },
  {
    "text": "If you're not familiar\nwith a bucket policy, a bucket policy is a form\nof resource-based policy.",
    "start": "2219250",
    "end": "2223603"
  },
  {
    "text": "The problem with this\npolicy here on the right however, is that it says\nnothing about the account or organization where the\nCloudTrail event originated from.",
    "start": "2225220",
    "end": "2233863"
  },
  {
    "text": "What this means is that if\nI have a policy like this on my bucket, an account\nthat does not belong to me,",
    "start": "2234899",
    "end": "2241870"
  },
  {
    "text": "like the one you see here,\ncould write CloudTrail events to my S3 bucket.",
    "start": "2241870",
    "end": "2246523"
  },
  {
    "text": "So what should you do? Now this is where you want to use one of the confused deputy\nkeys that I mentioned earlier.",
    "start": "2247690",
    "end": "2255130"
  },
  {
    "text": "Here we use AWS source org ID to say that this request must\noriginate from a resource",
    "start": "2255130",
    "end": "2261910"
  },
  {
    "text": "within our organization. If you want to be more fine grained, you can choose to specify\nthe OU Path, account",
    "start": "2261910",
    "end": "2269500"
  },
  {
    "text": "or specific resource ARN as well, using that source family\nof condition keys.",
    "start": "2269500",
    "end": "2274783"
  },
  {
    "text": "But you should include at least\none of these condition keys when you allow a service\nprincipal to make a request",
    "start": "2276100",
    "end": "2282400"
  },
  {
    "text": "in a resource-based policy.",
    "start": "2282400",
    "end": "2284172"
  },
  {
    "text": "One final note on SourceArn is that this is not the\nsame value as PrincipalArn.",
    "start": "2289000",
    "end": "2294220"
  },
  {
    "text": "The SourceArn context key\ncontains the arn of the resource that originated a request\nmade by a service principal.",
    "start": "2294220",
    "end": "2301480"
  },
  {
    "text": "The PrincipalArn condition\nkey contains the arm of the principal that\nactually makes the request.",
    "start": "2301480",
    "end": "2308020"
  },
  {
    "text": "These values are not the same. SourceArn is the arn of a resource. PrincipalArn is the arn of a principal.",
    "start": "2308020",
    "end": "2314923"
  },
  {
    "text": "To summarize, understanding\nhow the request is made can help you figure out what\ncondition keys and values",
    "start": "2319330",
    "end": "2325420"
  },
  {
    "text": "to use in your policies. It also helps you reason about\nwhich policies you can use",
    "start": "2325420",
    "end": "2330580"
  },
  {
    "text": "to control which requests. Some request patterns\nlike service linked roles and service principals\ncan only be controlled",
    "start": "2330580",
    "end": "2337690"
  },
  {
    "text": "by policies on your resources and not policies on your identities like service control policies.",
    "start": "2337690",
    "end": "2343993"
  },
  {
    "text": "Okay, another video where we talked about quite a few concepts. We reviewed our condition definitions",
    "start": "2349360",
    "end": "2355150"
  },
  {
    "text": "and how they are populated\nin the authorization context. We reviewed some different\ncondition operators",
    "start": "2355150",
    "end": "2360760"
  },
  {
    "text": "and interesting behavior\nof those operators. We talked about the difference\nbetween multi-valued",
    "start": "2360760",
    "end": "2365770"
  },
  {
    "text": "and single-valued condition keys, and that multi-valued refers\nto the number of values in the authorization context",
    "start": "2365770",
    "end": "2372340"
  },
  {
    "text": "and not the number of\nvalues in your IAM policy. We said that you can use policy variables",
    "start": "2372340",
    "end": "2377860"
  },
  {
    "text": "to do runtime substitutions\nin your IAM policies, and we talked about a number of different AWS request patterns to understand",
    "start": "2377860",
    "end": "2385210"
  },
  {
    "text": "that can help you write\nbetter IAM policies.",
    "start": "2385210",
    "end": "2387643"
  },
  {
    "text": "Next up, we have part three where we deep dive on\nthe principal element. We'll also introduce\npolicy evaluation chains,",
    "start": "2390700",
    "end": "2398020"
  },
  {
    "text": "which will help you understand how the different IAM policies factor into the authorization result.",
    "start": "2398020",
    "end": "2404020"
  },
  {
    "text": "In part four, we'll put\neverything together, and we'll walk through\nan authorization request start to finish.",
    "start": "2404020",
    "end": "2409003"
  },
  {
    "text": "And with that, thank you, and I hope to see you in the next video.",
    "start": "2411130",
    "end": "2414510"
  }
]