[
  {
    "start": "0",
    "end": "95000"
  },
  {
    "text": "hi there my name is vlad hribach and i am a senior partner solutions architect at aws",
    "start": "320",
    "end": "5839"
  },
  {
    "text": "today we will look at how to leverage aws app mesh to control network traffic and to ensure consistent visibility of",
    "start": "5839",
    "end": "12160"
  },
  {
    "text": "dotnet core applications my own background is mostly in.net development and architecture so this",
    "start": "12160",
    "end": "17760"
  },
  {
    "text": "video will showcase tools like visual studio visual studio code and powershell together with several tools originating",
    "start": "17760",
    "end": "24000"
  },
  {
    "text": "in non-dotnet or windows technology stack this video should be useful for non-windows folds just as much because",
    "start": "24000",
    "end": "30320"
  },
  {
    "text": "we will be running our sample applications in linux containers and use cross platform tools most of the time since we",
    "start": "30320",
    "end": "37280"
  },
  {
    "text": "cover a fair amount of ground in this video in case you're familiar with some of the material here please take a look at this",
    "start": "37280",
    "end": "42960"
  },
  {
    "text": "video description that has shortcut links to specific topics for example if you know how to build a",
    "start": "42960",
    "end": "48320"
  },
  {
    "text": "container image and push it to aws then you may want to skip a few sections using the shortcut links in this video",
    "start": "48320",
    "end": "55039"
  },
  {
    "text": "description since this video was prepared the name of alb ingress controller component",
    "start": "55039",
    "end": "60239"
  },
  {
    "text": "was changed and it is now known as aws load balancer controller please make a note of that as you follow",
    "start": "60239",
    "end": "66720"
  },
  {
    "text": "this video a major part of this video will be a live coding demo showing how typical devops challenges like building",
    "start": "66720",
    "end": "73680"
  },
  {
    "text": "a canary deployment can be addressed using app mesh network controls features and how app matches consistent",
    "start": "73680",
    "end": "80080"
  },
  {
    "text": "visibility features make it possible to transform request tracing data captured by app mesh",
    "start": "80080",
    "end": "85439"
  },
  {
    "text": "into aws x-ray service map in a transparent and low maintenance manner that and quite a bit more is on today's",
    "start": "85439",
    "end": "92240"
  },
  {
    "text": "menu let's check it out here a few more details about what we'll do today",
    "start": "92240",
    "end": "98320"
  },
  {
    "start": "95000",
    "end": "95000"
  },
  {
    "text": "i will give a brief introduction to the service mesh concept we will review tools components and sample applications comprising the",
    "start": "98320",
    "end": "104880"
  },
  {
    "text": "solution which we will build today but as i mentioned the main chunk of this video is a live coding demo",
    "start": "104880",
    "end": "110960"
  },
  {
    "text": "where we'll do everything from scratch starting with building an eks cluster with fargate then we'll",
    "start": "110960",
    "end": "116560"
  },
  {
    "text": "install aws kubernetes integration components and create the mesh we will package sample applications for installing them",
    "start": "116560",
    "end": "123520"
  },
  {
    "text": "on eks with app mesh then we will install our sample application parts using canary rollout",
    "start": "123520",
    "end": "129119"
  },
  {
    "text": "model we will test the entire solution to ensure that the request chain works as designed and",
    "start": "129119",
    "end": "136480"
  },
  {
    "text": "finally we will see the data about our services on the aws x-ray",
    "start": "136480",
    "end": "141760"
  },
  {
    "text": "service map after we are done with this demo i will suggest practical hands-on",
    "start": "141760",
    "end": "147200"
  },
  {
    "text": "exercises that should make app mesh knowledge stick better and to make the knowledge more tangible let's go ahead and talk",
    "start": "147200",
    "end": "155519"
  },
  {
    "start": "153000",
    "end": "153000"
  },
  {
    "text": "for a moment what aws app mesh is here is the app mesh textbook definition",
    "start": "155519",
    "end": "161840"
  },
  {
    "text": "aws app mesh is a service mesh that makes it easy to monitor and control services appmesh standardizes how your services",
    "start": "161840",
    "end": "169680"
  },
  {
    "text": "communicate giving you end-to-end visibility and helping to ensure higher availability for your applications app mesh gives you",
    "start": "169680",
    "end": "177200"
  },
  {
    "text": "consistent visibility and network traffic controls for every service in an application i think and hear some",
    "start": "177200",
    "end": "184400"
  },
  {
    "text": "of you saying yeah what i got is that aws app mesh is a service mesh but i'm not that familiar",
    "start": "184400",
    "end": "190720"
  },
  {
    "text": "with a service mesh either if we look up a service mesh definition we find the following",
    "start": "190720",
    "end": "197440"
  },
  {
    "text": "a service mesh is the logical boundary for network traffic between the services that reside within it well before i lose",
    "start": "197440",
    "end": "206080"
  },
  {
    "text": "your attention with all these textbook definitions let me try to give you a more practical",
    "start": "206080",
    "end": "212000"
  },
  {
    "text": "description of a service mesh effectively service meshes are like logical clusters where service",
    "start": "212000",
    "end": "218879"
  },
  {
    "text": "discovery is easy but unlike kubernetes specific service mesh aws app mesh lets you build meshes that",
    "start": "218879",
    "end": "226400"
  },
  {
    "text": "include linux containers running on different container orchestrators like amazon elastic kubernetes service",
    "start": "226400",
    "end": "232879"
  },
  {
    "text": "eks and amazon elastic container service ecs as well as on containers running on",
    "start": "232879",
    "end": "238959"
  },
  {
    "text": "amazon ec2 vms service meshes in general and aws app mesh in particular let us",
    "start": "238959",
    "end": "246000"
  },
  {
    "text": "see graphical representation of microservice relationships see where errors originate which are",
    "start": "246000",
    "end": "252640"
  },
  {
    "text": "hard to trace otherwise enable easy service discovery with simple service addresses that are not",
    "start": "252640",
    "end": "258720"
  },
  {
    "text": "localized to physical clusters give us easy to use tools for implementing blue green and canary",
    "start": "258720",
    "end": "264639"
  },
  {
    "text": "application version rollouts and rollbacks plus quite a few more features that we won't have time to cover in one video",
    "start": "264639",
    "end": "272960"
  },
  {
    "start": "273000",
    "end": "273000"
  },
  {
    "text": "regardless whether you are using aws app mesh or a commonly used open source service mesh you're likely",
    "start": "273280",
    "end": "279840"
  },
  {
    "text": "to learn that the main part of either of them is an open source component called invoice proxy so what's in why and what does it proxy",
    "start": "279840",
    "end": "287520"
  },
  {
    "text": "envoy is technically a network traffic proxy both regular proxy and reverse proxy",
    "start": "287520",
    "end": "292880"
  },
  {
    "text": "and for the kubernetes case it's living in so called sidecar container what this means in",
    "start": "292880",
    "end": "298560"
  },
  {
    "text": "practice is that envoy is an interceptor of inbound and outbound network traffic for",
    "start": "298560",
    "end": "304000"
  },
  {
    "text": "your container that's a proxy part and it also means that envoy owned container is",
    "start": "304000",
    "end": "309120"
  },
  {
    "text": "transparently injected into the kubernetes pod where your application container runs",
    "start": "309120",
    "end": "314160"
  },
  {
    "text": "you may remember that kubernetes pods may have multiple containers being a network traffic interceptor",
    "start": "314160",
    "end": "319919"
  },
  {
    "text": "enables envoy to do a lot of things that software developers often do in application code",
    "start": "319919",
    "end": "325039"
  },
  {
    "text": "to instrument their business logic things like logging performance monitoring tracing retrying on failures",
    "start": "325039",
    "end": "330880"
  },
  {
    "text": "sending error notifications etc commonly known in software development as cross-cutting concerns",
    "start": "330880",
    "end": "336560"
  },
  {
    "text": "well-written software typically uses aspect-oriented programming frameworks to deal with cross-cutting concerns",
    "start": "336560",
    "end": "342960"
  },
  {
    "text": "while using aspect-oriented programming is a very good approach and void takes this idea to the next level",
    "start": "342960",
    "end": "348320"
  },
  {
    "text": "it is like an aspect-oriented framework living outside of your application just like aop frameworks it intercepts",
    "start": "348320",
    "end": "354800"
  },
  {
    "text": "your service calls and uses content of intercepted requests and responses to let you deal with cross-cutting",
    "start": "354800",
    "end": "360880"
  },
  {
    "text": "concerns by using envoy configuration settings rather than writing application code",
    "start": "360880",
    "end": "366160"
  },
  {
    "text": "which take us to the next point here most app mesh resources names have virtual prefix virtual nodes",
    "start": "366160",
    "end": "372800"
  },
  {
    "text": "virtual services virtual routers and so on all those virtual resources don't really exist",
    "start": "372800",
    "end": "378479"
  },
  {
    "text": "instead virtual things get transformed into android proxy configuration settings",
    "start": "378479",
    "end": "383520"
  },
  {
    "text": "which gets sent to relevant and voip proxies on the need to know basis as an example an in-mesh client",
    "start": "383520",
    "end": "390720"
  },
  {
    "text": "application calling a service sphere an app mesh virtual service and a virtual router",
    "start": "390720",
    "end": "396720"
  },
  {
    "text": "will get its sidekick and voice configured by the app mesh to receive configuration settings matching data about the virtual service",
    "start": "396720",
    "end": "403680"
  },
  {
    "text": "and virtual router and then client applications and voi will do all the necessary work of",
    "start": "403680",
    "end": "409199"
  },
  {
    "text": "finding and calling actual service container this way all virtual mesh resources get",
    "start": "409199",
    "end": "414880"
  },
  {
    "text": "transformed into tangible configuration settings and rules sent down to appropriate invoice proxies",
    "start": "414880",
    "end": "420479"
  },
  {
    "text": "which then do all the actual work of routing listening calling outputting telemetry data and so on",
    "start": "420479",
    "end": "426880"
  },
  {
    "text": "just as an aspect-oriented framework interceptors in your application might have done it to complete similar tasks",
    "start": "426880",
    "end": "432880"
  },
  {
    "text": "as you can see all those virtual resources is just a convenient abstraction to configure and void",
    "start": "432880",
    "end": "438160"
  },
  {
    "text": "proxies without having to write configuration manually for each and every one of envoys in the mesh",
    "start": "438160",
    "end": "445039"
  },
  {
    "start": "445000",
    "end": "445000"
  },
  {
    "text": "before we dive into the demo let me start with giving you a little bit of the context",
    "start": "445039",
    "end": "450240"
  },
  {
    "text": "the sample solution that we'll use today comprises two asp.net core mvc applications",
    "start": "450240",
    "end": "455919"
  },
  {
    "text": "array service shown on the right returns the caller name as a string and on the left side of the screen is a",
    "start": "455919",
    "end": "461759"
  },
  {
    "text": "screenshot of the client web ui application that calls the service and shows the color when linked",
    "start": "461759",
    "end": "467039"
  },
  {
    "text": "on the page is clicked both applications have configuration settings defined in their respective app settings.json files",
    "start": "467039",
    "end": "474560"
  },
  {
    "text": "for the service the color to return is configurable and for the client the address of the service to call is",
    "start": "474560",
    "end": "480319"
  },
  {
    "text": "configurable in a few minutes during the live demo we will build and run these applications",
    "start": "480319",
    "end": "486319"
  },
  {
    "start": "486000",
    "end": "486000"
  },
  {
    "text": "here is a list of what we will need to complete our work today an aws account visual studio 2019",
    "start": "486319",
    "end": "494240"
  },
  {
    "text": "community edition will be sufficient for our goals today visual studio code which is optional but",
    "start": "494240",
    "end": "499360"
  },
  {
    "text": "is really handy especially with its excellent docker and kubernetes extensions we will also employ following command",
    "start": "499360",
    "end": "505599"
  },
  {
    "text": "line tools git so we could use several open source scripts and templates aws the command line interface for",
    "start": "505599",
    "end": "512479"
  },
  {
    "text": "managing aws resources cube cattle the cli for managing kubernetes resources",
    "start": "512479",
    "end": "517919"
  },
  {
    "text": "eks cuddle a really handy convenience utility for working with amazon eks",
    "start": "517919",
    "end": "523120"
  },
  {
    "text": "helm the package manager for kubernetes letting us create kubernetes and stores for our applications",
    "start": "523120",
    "end": "529040"
  },
  {
    "text": "powershell 7 and aws tools for powershell for cross-platform scripting of aws resources",
    "start": "529040",
    "end": "535040"
  },
  {
    "text": "regarding skills that will be important to have today here is a quick refresher of a few fundamentals",
    "start": "535040",
    "end": "540480"
  },
  {
    "text": "container is a way of packaging your application binaries in such a way that it includes all application dependencies down to the",
    "start": "540480",
    "end": "547680"
  },
  {
    "text": "operating system and then running your app in a highly isolated sandbox manner in a very",
    "start": "547680",
    "end": "552800"
  },
  {
    "text": "consistent runtime environment you may think of a container as a binary package that behaves in exactly the same",
    "start": "552800",
    "end": "558480"
  },
  {
    "text": "way regardless where it runs on your development laptop or at scale on a cloud",
    "start": "558480",
    "end": "563760"
  },
  {
    "text": "container's killer use case is to eliminate works on my box problem well if a container is like an",
    "start": "563760",
    "end": "570959"
  },
  {
    "text": "exe that never falls victim to the dll health problem kubernetes is more like a cluster of iis",
    "start": "570959",
    "end": "576800"
  },
  {
    "text": "servers it's a compute service for running containers at scale meaning it will schedule containers to",
    "start": "576800",
    "end": "582560"
  },
  {
    "text": "run on cluster node computers or vms it will restart containers as they crash and it will maintain stable network",
    "start": "582560",
    "end": "589040"
  },
  {
    "text": "addresses for containers that go in and out of existence kubernetes defining trait is a declarative nature of its infrastructure",
    "start": "589040",
    "end": "596000"
  },
  {
    "text": "is code manifest files that describe desired final state of resources running on a cluster",
    "start": "596000",
    "end": "602000"
  },
  {
    "text": "helm is a package manager for kubernetes or you may think of it as a tool for creating and running application",
    "start": "602000",
    "end": "607040"
  },
  {
    "text": "installers for kubernetes sort of like msi in store for windows applications",
    "start": "607040",
    "end": "612480"
  },
  {
    "text": "one thing that may not be self-evident is that aws app mesh is compatible with linux",
    "start": "612480",
    "end": "617600"
  },
  {
    "text": "containers only and not with windows containers the reason is that invoice proxy is for linux only and",
    "start": "617600",
    "end": "624560"
  },
  {
    "text": "therefore cannot be injected into windows kubernetes pods or run otherwise on windows hosts let's have a",
    "start": "624560",
    "end": "631680"
  },
  {
    "text": "quick look at aws services that will be involved in building today's solution",
    "start": "631680",
    "end": "636800"
  },
  {
    "text": "although aws app match is the start of today's show we will need to employ a few other services and components to build a",
    "start": "636800",
    "end": "643279"
  },
  {
    "text": "solution that represents a real-life use case to the decent level of fidelity we will use amazon elastic kubernetes",
    "start": "643279",
    "end": "650800"
  },
  {
    "text": "service eks to run our asp.net core applications as linux containers",
    "start": "650800",
    "end": "655920"
  },
  {
    "text": "aws far gate to make our kubernetes cluster serverless meaning not exposing us to headaches of",
    "start": "655920",
    "end": "661760"
  },
  {
    "text": "cluster node virtual machine management amazon elastic container registry ecr",
    "start": "661760",
    "end": "667440"
  },
  {
    "text": "which is a container image storage where we'll stage our application container images to make them available for the",
    "start": "667440",
    "end": "673600"
  },
  {
    "text": "kubernetes cluster amazon app mesh itself of course the nicer gentler and less limiting kind of",
    "start": "673600",
    "end": "680079"
  },
  {
    "text": "logical cluster application load balancer alb for managing inbound traffic before it",
    "start": "680079",
    "end": "686560"
  },
  {
    "text": "reaches the cluster and aws x-ray to see application traffic traces",
    "start": "686560",
    "end": "692079"
  },
  {
    "text": "and to see graphical visualization of service maps we will also use integration components",
    "start": "692079",
    "end": "697760"
  },
  {
    "text": "that are not services in their own right but are necessary for building an end-to-end solution",
    "start": "697760",
    "end": "703760"
  },
  {
    "text": "app mesh controller and aws kubernetes integration letting kubernetes resources to be a",
    "start": "703760",
    "end": "709120"
  },
  {
    "text": "part of an app mesh alb in grass controller making amazon",
    "start": "709120",
    "end": "714160"
  },
  {
    "text": "application load balancer to be a known entity in the kubernetes cluster ingress gateway",
    "start": "714160",
    "end": "719440"
  },
  {
    "text": "an intermediary between the inbound traffic arriving from the load balancer and the rest of the mesh resources",
    "start": "719440",
    "end": "726320"
  },
  {
    "text": "ingress gateway is the first point where the inbound traffic becomes visible to and managed by the app mesh",
    "start": "726320",
    "end": "733120"
  },
  {
    "text": "okay we are done with appetizers and about to start the main course building things what are we going to",
    "start": "733120",
    "end": "739360"
  },
  {
    "text": "build today just looked at this scary busy infrastructure diagram with lots of",
    "start": "739360",
    "end": "744560"
  },
  {
    "text": "boxes and arrows it is our target solution architecture for today my promise to you",
    "start": "744560",
    "end": "750000"
  },
  {
    "text": "is that if you stick with me it will make sense at the end of the video we're going to start small though with",
    "start": "750000",
    "end": "756560"
  },
  {
    "text": "this nearly empty page and add components one after another by deploying aws services and kubernetes resources",
    "start": "756560",
    "end": "763120"
  },
  {
    "text": "step by step still let me quickly go back and discuss our target solution again in a nutshell",
    "start": "763120",
    "end": "768880"
  },
  {
    "start": "768000",
    "end": "768000"
  },
  {
    "text": "we will deploy our client server application to the kubernetes cluster and make front-end client app",
    "start": "768880",
    "end": "774720"
  },
  {
    "text": "accessible from the internet while keeping the back-end service locked down and inaccessible from the",
    "start": "774720",
    "end": "779839"
  },
  {
    "text": "outside we will also showcase the canary reload pattern where a new version",
    "start": "779839",
    "end": "785040"
  },
  {
    "text": "of an application is seamlessly added as a partial handler of inbound requests with gradual shifting of traffic from",
    "start": "785040",
    "end": "791680"
  },
  {
    "text": "the old version of the application to the new as far as infrastructure goes at the",
    "start": "791680",
    "end": "797120"
  },
  {
    "text": "high level we will have an aws account",
    "start": "797120",
    "end": "802160"
  },
  {
    "text": "with several aws services that live outside of either app mesh or the kubernetes cluster specifically",
    "start": "802240",
    "end": "809120"
  },
  {
    "text": "we will use elastic container registry ecr application load balancer alb",
    "start": "809120",
    "end": "816959"
  },
  {
    "text": "and aws x-ray that will render our service dependency maps and let us see service call traces we'll",
    "start": "816959",
    "end": "824800"
  },
  {
    "text": "have a single kubernetes cluster running on amazon elastic kubernetes service eks represented by a gray box with the icon",
    "start": "824800",
    "end": "832160"
  },
  {
    "text": "having letter k in the top left corner the app mesh that in our simplified solution will cover",
    "start": "832160",
    "end": "838959"
  },
  {
    "text": "only one kubernetes namespace we'll have two versions of the color application running on kubernetes as",
    "start": "838959",
    "end": "846000"
  },
  {
    "text": "containers and fronted by a virtual service named",
    "start": "846000",
    "end": "851360"
  },
  {
    "text": "color canary which also will have a virtual router",
    "start": "851360",
    "end": "859199"
  },
  {
    "text": "to split the traffic between version one and two of the color service there will be a color client",
    "start": "859199",
    "end": "865839"
  },
  {
    "text": "application container and finally an ingress gateway",
    "start": "865839",
    "end": "871519"
  },
  {
    "text": "linked to amazon application load balancer that together led internet traffic in everything pink",
    "start": "871519",
    "end": "881440"
  },
  {
    "text": "is part of the app mesh and as we just discussed any resource on the diagram having word virtual in",
    "start": "882240",
    "end": "889360"
  },
  {
    "text": "its name does not really exist as a tangible entity but rather is just a configuration item",
    "start": "889360",
    "end": "894720"
  },
  {
    "text": "for an android proxy while we're here in case you are not familiar with different types of app",
    "start": "894720",
    "end": "900160"
  },
  {
    "text": "mesh resources let me introduce a few resource types that we will rely on today",
    "start": "900160",
    "end": "905600"
  },
  {
    "text": "virtual nodes represent sets of running containers which in kubernetes",
    "start": "905600",
    "end": "911120"
  },
  {
    "text": "translates to sets of pods similar to how kubernetes deployment represents a set of pods",
    "start": "911120",
    "end": "916560"
  },
  {
    "text": "virtual services create an abstraction layer over virtual nodes and serve",
    "start": "916560",
    "end": "922079"
  },
  {
    "text": "roughly the same purpose as kubernetes services virtual routers are resources for",
    "start": "922079",
    "end": "929839"
  },
  {
    "text": "routing and traffic shifting and are usually referenced by virtual services and gateway routes",
    "start": "929839",
    "end": "936959"
  },
  {
    "text": "gateway routes our resources for routing external traffic from an ingress",
    "start": "936959",
    "end": "942880"
  },
  {
    "text": "gateway to virtual services the final note before we get our hands dirty and start building things",
    "start": "942880",
    "end": "948800"
  },
  {
    "text": "is that for meshes using dns mode of service address resolution regular kubernetes services",
    "start": "948800",
    "end": "956240"
  },
  {
    "text": "need to be created for the purpose of domain name resolution even though kubernetes services are not",
    "start": "956240",
    "end": "962240"
  },
  {
    "text": "really used for traffic handling when mesh is in charge and now we start",
    "start": "962240",
    "end": "967519"
  },
  {
    "text": "our walkthrough i will be using command line tools with powershell but i will occasionally switch to aws",
    "start": "967519",
    "end": "973519"
  },
  {
    "text": "web console to see results of our labor there as well for time consuming operations i will",
    "start": "973519",
    "end": "978959"
  },
  {
    "text": "edit out way delays to skip forward the video and i will let you know when i've done that",
    "start": "978959",
    "end": "984399"
  },
  {
    "text": "okay let's get started first thing we create is an amazon elastic kubernetes service cluster named app mesh demo",
    "start": "984399",
    "end": "991199"
  },
  {
    "text": "i will be using powershell variables so it would be easier to reuse these commands with your own values if you choose to do",
    "start": "991199",
    "end": "997199"
  },
  {
    "text": "so this command will create kubernetes clusters that will use fargate server compute nodes meaning",
    "start": "997199",
    "end": "1003279"
  },
  {
    "text": "virtual machine instances running our kubernetes pods will not show up in the list of ec2 instances in aws web",
    "start": "1003279",
    "end": "1010480"
  },
  {
    "text": "console the new cluster will have a standard predefined system namespace",
    "start": "1010480",
    "end": "1015519"
  },
  {
    "text": "named cubesystem where we will install some of the components hence the namespace is here on the",
    "start": "1015519",
    "end": "1021440"
  },
  {
    "text": "diagram provisioning the cluster will take a few minutes so i am going to edit out the",
    "start": "1021440",
    "end": "1026480"
  },
  {
    "text": "wait time to skip forward to the completion of the process",
    "start": "1026480",
    "end": "1031280"
  },
  {
    "text": "let's take a look at the eks cluster in aws console",
    "start": "1032640",
    "end": "1039839"
  },
  {
    "text": "it has a fargate profile telling eks control plane to schedule all pods in",
    "start": "1040640",
    "end": "1046000"
  },
  {
    "text": "the default and cube system kubernetes namespaces to run on serverless fargate now let's",
    "start": "1046000",
    "end": "1051840"
  },
  {
    "text": "authorize cube cuddle command line tool to talk to the kubernetes cluster we just created",
    "start": "1051840",
    "end": "1058559"
  },
  {
    "text": "we can now run cubecaddle cli commands like get cubecaddlegetpods or we can use",
    "start": "1061120",
    "end": "1067520"
  },
  {
    "text": "vs code and its kubernetes extension to view and manage our kubernetes cluster",
    "start": "1067520",
    "end": "1074639"
  },
  {
    "text": "there we can see kubernetes namespaces nodes deployments",
    "start": "1074799",
    "end": "1084720"
  },
  {
    "text": "and their pods services you get the idea vs code",
    "start": "1084720",
    "end": "1091360"
  },
  {
    "text": "kubernetes plugin might be an easy option for those accustomed to gui operating systems",
    "start": "1091360",
    "end": "1096559"
  },
  {
    "text": "we will use both command line and vs code pretty extensively today our sample project is on github let's",
    "start": "1096559",
    "end": "1103520"
  },
  {
    "text": "clone and run it we'll create a directory for all our open source assets first",
    "start": "1103520",
    "end": "1109120"
  },
  {
    "text": "next we clone the sample application github repository and simplify sample folder name",
    "start": "1109120",
    "end": "1116480"
  },
  {
    "text": "now let's switch to the correct branch and open the solution in visual studio",
    "start": "1116480",
    "end": "1123840"
  },
  {
    "text": "there we have two projects a service and the client each project has",
    "start": "1128400",
    "end": "1135200"
  },
  {
    "text": "configuration settings defined in their respective appsettings.json files service application has a setting",
    "start": "1135200",
    "end": "1141760"
  },
  {
    "text": "telling which color to return to the client and the client application has address of the service in its configuration file",
    "start": "1141760",
    "end": "1148880"
  },
  {
    "text": "now let me run both applications from visual studio i'm starting with service application first",
    "start": "1148880",
    "end": "1156000"
  },
  {
    "text": "its landing page shows us a rest service open api specification and by changing url in the browser by",
    "start": "1157919",
    "end": "1164480"
  },
  {
    "text": "appending slash color i can get back the color defined in the service applications configuration",
    "start": "1164480",
    "end": "1170880"
  },
  {
    "text": "settings next i will start the client application",
    "start": "1170880",
    "end": "1179840"
  },
  {
    "text": "if we configure it correctly when i click this invoke service link we should see a message with the",
    "start": "1183360",
    "end": "1188559"
  },
  {
    "text": "background color returned by the caller service all right both applications look good now now let me run both applications as",
    "start": "1188559",
    "end": "1195280"
  },
  {
    "text": "docker containers i will build service application docker image first",
    "start": "1195280",
    "end": "1206320"
  },
  {
    "text": "if this docker build command looks a bit unusual to you that's because docker files generated by the visual studio",
    "start": "1206320",
    "end": "1212480"
  },
  {
    "text": "have this cork where docker context should be one folder level above the location of",
    "start": "1212480",
    "end": "1217679"
  },
  {
    "text": "the docker file hence we're specifying both the context and the dockerfile location",
    "start": "1217679",
    "end": "1223039"
  },
  {
    "text": "explicitly",
    "start": "1223039",
    "end": "1225759"
  },
  {
    "text": "and let's check that the image has built successfully",
    "start": "1233120",
    "end": "1237840"
  },
  {
    "text": "let's run our color service container and make it accessible on port 6001 you may have noticed that i did",
    "start": "1238640",
    "end": "1245679"
  },
  {
    "text": "override the color configuration setting via environment variable i have configured the service to return magenta",
    "start": "1245679",
    "end": "1252640"
  },
  {
    "text": "as a caller when the caller service is called and make sure that our service is running in the container well",
    "start": "1252640",
    "end": "1263840"
  },
  {
    "text": "good next step is to build client application container image",
    "start": "1266720",
    "end": "1277840"
  },
  {
    "text": "let's run the client in such a way that we'll let the client find the service the link command line parameter will",
    "start": "1284480",
    "end": "1291919"
  },
  {
    "text": "make color service host name http color dash service resolvable on the client container",
    "start": "1291919",
    "end": "1297679"
  },
  {
    "text": "and the dash e-parameter configures client application settings so that the client will call the service at that",
    "start": "1297679",
    "end": "1303360"
  },
  {
    "text": "http address and open containerized client application in the browser and see whether everything works as",
    "start": "1303360",
    "end": "1309840"
  },
  {
    "text": "expected now that we've made sure our application can run in containers",
    "start": "1309840",
    "end": "1315200"
  },
  {
    "text": "let's upload their images to aws to make images available to kubernetes",
    "start": "1315200",
    "end": "1320240"
  },
  {
    "text": "we'll start this with creating two elastic container register repositories one for service images and one for",
    "start": "1320240",
    "end": "1326720"
  },
  {
    "text": "client images let's take a look at these repositories",
    "start": "1326720",
    "end": "1332720"
  },
  {
    "text": "in aws web console",
    "start": "1332720",
    "end": "1336320"
  },
  {
    "text": "and let's copy eci uri so we could push application images to aws repositories",
    "start": "1338960",
    "end": "1346080"
  },
  {
    "text": "now let's authorize docker to push images to our ecr repositories",
    "start": "1346080",
    "end": "1351840"
  },
  {
    "text": "and let us tag and push our application container images to aws",
    "start": "1353840",
    "end": "1361840"
  },
  {
    "text": "the final step here is to ensure our images are up in the repository",
    "start": "1402640",
    "end": "1408080"
  },
  {
    "text": "at this point we have tested the sample application and staged our application container images",
    "start": "1408080",
    "end": "1413440"
  },
  {
    "text": "by the way if you decide to run through the flow yourself you could do this container related part of the build",
    "start": "1413440",
    "end": "1419200"
  },
  {
    "text": "while kubernetes cluster is getting provisioned instead of waiting for provisioning to complete",
    "start": "1419200",
    "end": "1424240"
  },
  {
    "text": "okay we are done with this part and can get to the task of building the mesh",
    "start": "1424240",
    "end": "1429840"
  },
  {
    "text": "before creating the mesh though we need to install a couple of integration components in our kubernetes cluster",
    "start": "1429840",
    "end": "1435840"
  },
  {
    "start": "1430000",
    "end": "1430000"
  },
  {
    "text": "one to support app mesh and another to support aws application load balancer as a point of external traffic in grass",
    "start": "1435840",
    "end": "1443760"
  },
  {
    "text": "extensions and integration components are typically implemented as kubernetes controllers so we'll install app mesh controller and",
    "start": "1443760",
    "end": "1451919"
  },
  {
    "text": "alb ingress controller to get us to the point where our architecture will match this picture",
    "start": "1451919",
    "end": "1457600"
  },
  {
    "text": "typically steps of installing app mesh and alb ingress controller are kind of a chore so to streamline the",
    "start": "1457600",
    "end": "1463840"
  },
  {
    "text": "process i have created a few fairly generic parameterized powershell scripts that will reduce the number of steps",
    "start": "1463840",
    "end": "1470080"
  },
  {
    "text": "and make the process simpler these scripts are available on github and you are",
    "start": "1470080",
    "end": "1475520"
  },
  {
    "text": "welcome to use them if you so choose okay here we go i will prepare a directory for the script",
    "start": "1475520",
    "end": "1482320"
  },
  {
    "text": "clone the github repository with scripts and simplify the directory name",
    "start": "1482320",
    "end": "1489600"
  },
  {
    "text": "our scripts are here let's install the app mesh controller using app mesh controller eks installer",
    "start": "1490080",
    "end": "1496799"
  },
  {
    "text": "powershell script command above installs app mesh with aws",
    "start": "1496799",
    "end": "1502320"
  },
  {
    "text": "x-ray tracing integration and assigns app mesh controller kubernetes namespace to serverless fargate nodes",
    "start": "1502320",
    "end": "1509200"
  },
  {
    "text": "let's run it it will take a minute or two to complete so i will fast forward the video",
    "start": "1509200",
    "end": "1514960"
  },
  {
    "text": "we can install lb in grass control in parallel in another powershell window i will need to copy a couple of",
    "start": "1514960",
    "end": "1520880"
  },
  {
    "text": "powershell variables first and start installation by running alb ingress controller installer script",
    "start": "1520880",
    "end": "1527279"
  },
  {
    "text": "let it run",
    "start": "1527279",
    "end": "1529840"
  },
  {
    "text": "i will use the following command to wait for lb ingress controller readiness and in another window similar command to",
    "start": "1533360",
    "end": "1540080"
  },
  {
    "text": "wait for the app mesh controller readiness i will edit out the weight so we could just cut to the completion of the",
    "start": "1540080",
    "end": "1546480"
  },
  {
    "text": "installation of both integration components now after we have installed necessary",
    "start": "1546480",
    "end": "1551840"
  },
  {
    "start": "1550000",
    "end": "1550000"
  },
  {
    "text": "aws kubernetes integration components next we will create and configure kubernetes namespace",
    "start": "1551840",
    "end": "1557360"
  },
  {
    "text": "for our sample applications we will make the namespace eligible to join the app",
    "start": "1557360",
    "end": "1562799"
  },
  {
    "text": "mesh which will create shortly afterwards and we will also ensure that kubernetes container pods located in this namespace",
    "start": "1562799",
    "end": "1570240"
  },
  {
    "text": "will run on serverless fargate cluster nodes also we will create a kubernetes service",
    "start": "1570240",
    "end": "1575600"
  },
  {
    "text": "account with sufficient aws access rights for pods to receive envoy",
    "start": "1575600",
    "end": "1580640"
  },
  {
    "text": "proxy configuration data while running on serverlessfargate cluster nodes but let's do one thing at",
    "start": "1580640",
    "end": "1586240"
  },
  {
    "text": "a time first we create kubernetes namespace called colorspace",
    "start": "1586240",
    "end": "1592480"
  },
  {
    "text": "now we will label the namespace with values telling appmeshcontroller to treat our new",
    "start": "1592480",
    "end": "1597760"
  },
  {
    "text": "kubernetes namespace as a member of the app mesh first label is to tell the app mesh controller to",
    "start": "1597760",
    "end": "1604480"
  },
  {
    "text": "inject sidecar in void containers into pods running in this namespace",
    "start": "1604480",
    "end": "1610480"
  },
  {
    "text": "next we will assign this nukernet's namespace to fargate nodes by creating ets for gate profile",
    "start": "1610480",
    "end": "1616400"
  },
  {
    "text": "for the color space namespace it will take a minute or two to complete so i will skip ahead",
    "start": "1616400",
    "end": "1623360"
  },
  {
    "text": "and now we'll tell the appmesh controller which mesh the namespace will be a part of",
    "start": "1623360",
    "end": "1628480"
  },
  {
    "text": "we will name our mesh color mesh and label the namespace with the mesh name",
    "start": "1628480",
    "end": "1635600"
  },
  {
    "text": "let's see our new namespace labels in vs code",
    "start": "1636240",
    "end": "1641840"
  },
  {
    "text": "and the last sub step here is to create kubernetes service account that will grant kubernetes spots running",
    "start": "1646480",
    "end": "1651919"
  },
  {
    "text": "on fargate cred access rights to receive android configuration data for that we will use service account for",
    "start": "1651919",
    "end": "1658320"
  },
  {
    "text": "envoy on eks fargate powershell script which we have cloned from the github a",
    "start": "1658320",
    "end": "1663520"
  },
  {
    "text": "few minutes ago the script has created a variable storing the service account name",
    "start": "1663520",
    "end": "1670000"
  },
  {
    "text": "since visual studio code kubernetes plugin lacks the ability to show service accounts we will use command line to verify that",
    "start": "1670000",
    "end": "1676559"
  },
  {
    "text": "service account is indeed created okay service account is there and",
    "start": "1676559",
    "end": "1683840"
  },
  {
    "text": "this means we are done with configuring our namespace and are ready to go to the next step",
    "start": "1683840",
    "end": "1691200"
  },
  {
    "start": "1691000",
    "end": "1691000"
  },
  {
    "text": "now it's time to create the app mesh itself the name of the mesh is already set in a",
    "start": "1691279",
    "end": "1697679"
  },
  {
    "text": "powershell variable it's color mesh to simplify this step of",
    "start": "1697679",
    "end": "1702960"
  },
  {
    "text": "creating an aws app mesh i have created a super simple help chart which takes mesh name as an installation",
    "start": "1702960",
    "end": "1709840"
  },
  {
    "text": "parameter so let's get the chart from the github now let's have a dry run of our mesh installation to see kubernetes manifest",
    "start": "1709840",
    "end": "1716720"
  },
  {
    "text": "that will be applied if we run installation for real this is the kubernetes manifest that",
    "start": "1716720",
    "end": "1721919"
  },
  {
    "text": "will create the app mesh in both aws and as a custom kubernetes resource",
    "start": "1721919",
    "end": "1727919"
  },
  {
    "text": "let's apply the manifest and see the app mesh created on aws",
    "start": "1727919",
    "end": "1739840"
  },
  {
    "text": "we are now only one step short of installing our applications creating an ab mashing grass gateway",
    "start": "1741360",
    "end": "1749279"
  },
  {
    "start": "1745000",
    "end": "1745000"
  },
  {
    "text": "together with alb based kubernetes ingress resource is going to be our last one-time",
    "start": "1749279",
    "end": "1754799"
  },
  {
    "text": "infrastructure component installation step after this step our kubernetes cluster and all other required infrastructure",
    "start": "1754799",
    "end": "1760799"
  },
  {
    "text": "components are going to be fully configured ingress gateway is an app mesh resource that receives requests from outside of",
    "start": "1760799",
    "end": "1767679"
  },
  {
    "text": "the app mesh and routes them to app mesh virtual services using gateway route resources",
    "start": "1767679",
    "end": "1773360"
  },
  {
    "text": "in dress gateway being essentially a standalone invoice pod ensures that request traceability starts",
    "start": "1773360",
    "end": "1779760"
  },
  {
    "text": "as soon as request enters the mesh ingress gateway supports different ways of ingesting traffic from the outside",
    "start": "1779760",
    "end": "1787039"
  },
  {
    "text": "we have prepared for that at our previous step by installing alb and grass controller under the hood",
    "start": "1787039",
    "end": "1794240"
  },
  {
    "text": "ingress gateway is a standalone envoy proxy and to install it on kubernetes we'll run the helm chart i created which",
    "start": "1794240",
    "end": "1800640"
  },
  {
    "text": "simplifies this step the chart is in the same github repository which we have used a minute",
    "start": "1800640",
    "end": "1806000"
  },
  {
    "text": "ago to create app mesh itself okay let's do it we'll need to come up with a unique name for the ingress",
    "start": "1806000",
    "end": "1811919"
  },
  {
    "text": "gateway for example we could do it with the powershell like so",
    "start": "1811919",
    "end": "1817679"
  },
  {
    "text": "that will be our ingress gateway name every kubernetes namespace that is a part of an",
    "start": "1817840",
    "end": "1823039"
  },
  {
    "text": "app mesh should have one ingress gateway now we are ready for the dry run of the installation of the ingress gateway",
    "start": "1823039",
    "end": "1829679"
  },
  {
    "text": "command above specifies following helm chart installation parameters a kubernetes namespace an installation",
    "start": "1829679",
    "end": "1837360"
  },
  {
    "text": "release name a helm chart folder location and aws region",
    "start": "1837360",
    "end": "1842799"
  },
  {
    "text": "the appmatch.fargatepod service account which specifies kubernetes service account for running android proxies on",
    "start": "1842799",
    "end": "1849200"
  },
  {
    "text": "fargate ingress.enabled equals true lets external traffic enter the kubernetes",
    "start": "1849200",
    "end": "1854240"
  },
  {
    "text": "cluster and ingress.alb equals true says that we'll be using alb for our ingress",
    "start": "1854240",
    "end": "1860480"
  },
  {
    "text": "and not nlb let's run the command",
    "start": "1860480",
    "end": "1865600"
  },
  {
    "text": "as you can see we will have multiple kubernetes resources created for the ingress gateway",
    "start": "1865600",
    "end": "1870799"
  },
  {
    "text": "specifics are outside the scope of this video but feel free to explore these manifests on your own",
    "start": "1870799",
    "end": "1876480"
  },
  {
    "text": "let's run the installation for real now",
    "start": "1876480",
    "end": "1880398"
  },
  {
    "text": "all right but we also need to bind our new ingress gateway to the kubernetes namespace by labeling the namespace with",
    "start": "1885039",
    "end": "1891760"
  },
  {
    "text": "the name of the gateway now we can set up weight for the ingress gateway readiness",
    "start": "1891760",
    "end": "1896799"
  },
  {
    "text": "like so alright we are done installing res",
    "start": "1896799",
    "end": "1902240"
  },
  {
    "text": "gateway that was the first component we have added to the mesh let's take a look at the app mesh resource in aws web",
    "start": "1902240",
    "end": "1909679"
  },
  {
    "text": "console we see the virtual gateway resource there",
    "start": "1909679",
    "end": "1915519"
  },
  {
    "text": "and we can see its kubernetes counterpart in the vs code among kubernetes custom resources",
    "start": "1917120",
    "end": "1924559"
  },
  {
    "text": "let's quickly recap results of this step kubernetes namespace where we will install our applications",
    "start": "1926799",
    "end": "1932799"
  },
  {
    "text": "now has a label with the name of the ingress gateway there it is we also have ingress gateway",
    "start": "1932799",
    "end": "1938640"
  },
  {
    "text": "kubernetes pod up and running please know the name of the gateway pod we'll need it in a moment",
    "start": "1938640",
    "end": "1946799"
  },
  {
    "text": "and we have the aws application load balancer alb which we can see in aws console",
    "start": "1947440",
    "end": "1954399"
  },
  {
    "text": "here the listeners",
    "start": "1954399",
    "end": "1957360"
  },
  {
    "text": "and here's the targets as you can see the load balancer is forwarding traffic to the ingress gateway pod",
    "start": "1960159",
    "end": "1966399"
  },
  {
    "text": "i will also copy the dns name of the load balancer and paste it in the browser i hit enter",
    "start": "1966399",
    "end": "1973600"
  },
  {
    "text": "and i get bad gateway response which is expected because ingress gateway has nothing",
    "start": "1973600",
    "end": "1978720"
  },
  {
    "text": "downstream from it okay we have prepared our target infrastructure now it's time to create",
    "start": "1978720",
    "end": "1984320"
  },
  {
    "start": "1981000",
    "end": "1981000"
  },
  {
    "text": "kubernetes installation packages helm charts for each of our two sample applications color service will be first we will make",
    "start": "1984320",
    "end": "1991200"
  },
  {
    "text": "service return color green and that will be version one of the service also for demo purposes i will",
    "start": "1991200",
    "end": "1997039"
  },
  {
    "text": "temporarily expose the service on the internet so we could test our entire infrastructure by ensuring we can flow a",
    "start": "1997039",
    "end": "2003120"
  },
  {
    "text": "request starting from the internet to the service inside the mesh and see request trace data in",
    "start": "2003120",
    "end": "2008480"
  },
  {
    "text": "aws x-ray service map and after we are done with the test i will remove the gateway route which is",
    "start": "2008480",
    "end": "2014559"
  },
  {
    "text": "the virtual resource exposing the service on the internet to lock down our service inside the mesh an important",
    "start": "2014559",
    "end": "2020240"
  },
  {
    "text": "thing to note is that once a kubernetes namespace is made to be a part of an app mesh",
    "start": "2020240",
    "end": "2026399"
  },
  {
    "text": "we can't use regular kubernetes deployment to run a pod in that namespace without that pod also having a",
    "start": "2026399",
    "end": "2032640"
  },
  {
    "text": "corresponding virtual mode i need to stress this again we can't use regular kubernetes manifests to install",
    "start": "2032640",
    "end": "2039200"
  },
  {
    "text": "application in a mesh namespace only mesh aware installations can do that this means",
    "start": "2039200",
    "end": "2044960"
  },
  {
    "text": "app mesh is not really a drop in type of component once you decided to use app mesh that's a commitment to build your helm",
    "start": "2044960",
    "end": "2051679"
  },
  {
    "text": "charts that will include creation of app mesh resources that's why the helm charts i have created for this",
    "start": "2051679",
    "end": "2057599"
  },
  {
    "text": "video let you deploy your application to both regular eks cluster namespaces",
    "start": "2057599",
    "end": "2062960"
  },
  {
    "text": "as well as to name spaces that are a part of an app mesh to switch the helm chart between regular",
    "start": "2062960",
    "end": "2069358"
  },
  {
    "text": "eks and app mesh enabled installations all you need to do is to change a few installation parameters in the",
    "start": "2069359",
    "end": "2075040"
  },
  {
    "text": "values.yaml file of the helm chart in this demo i am focusing solely on installation parameters targeting app",
    "start": "2075040",
    "end": "2082079"
  },
  {
    "text": "mesh we start with cloning github repository containing general purpose helm charts",
    "start": "2082079",
    "end": "2087520"
  },
  {
    "text": "that require very minimal changes in order to accommodate typical web applications when they are installed on kubernetes",
    "start": "2087520",
    "end": "2094320"
  },
  {
    "text": "whether the target is a regular eks cluster or an app mesh then we will tweak these helm chart",
    "start": "2094320",
    "end": "2100480"
  },
  {
    "text": "installation parameters for each of our two sample projects the service and the client",
    "start": "2100480",
    "end": "2105920"
  },
  {
    "text": "first thing first though let's clone the github repository with app mesh aware general purpose application installation",
    "start": "2105920",
    "end": "2111839"
  },
  {
    "text": "helm charts i will rename the folder with charts and name it helm",
    "start": "2111839",
    "end": "2118480"
  },
  {
    "text": "and remove git repo data from the folder now let's copy our generic helm chart",
    "start": "2118480",
    "end": "2123520"
  },
  {
    "text": "installation templates to both service and client virtual studio projects",
    "start": "2123520",
    "end": "2131838"
  },
  {
    "text": "templates making up the chart don't need to be changed so i will not stop to explain what's inside",
    "start": "2133040",
    "end": "2138640"
  },
  {
    "text": "all the changes that we need to make will be limited to installation parameters therefore i would like to show you only",
    "start": "2138640",
    "end": "2144640"
  },
  {
    "text": "char.yaml and values.tml files where default installation parameter",
    "start": "2144640",
    "end": "2149920"
  },
  {
    "text": "values are set we will change a few of these parameter values and will be on our way",
    "start": "2149920",
    "end": "2155359"
  },
  {
    "text": "if you have ever created an installer for a windows application using install shielder similar tool",
    "start": "2155359",
    "end": "2160560"
  },
  {
    "text": "the flow basically consists of packaging your application binaries and setting default installation parameters",
    "start": "2160560",
    "end": "2165760"
  },
  {
    "text": "like destination installation path and so on with helm chart similar logic applies",
    "start": "2165760",
    "end": "2170800"
  },
  {
    "text": "you tell the location of your installation binaries namely the location of the container image",
    "start": "2170800",
    "end": "2176000"
  },
  {
    "text": "and then you also set parameter values for the installer let's do that it will only take a minute",
    "start": "2176000",
    "end": "2182320"
  },
  {
    "text": "let's set the name and the description of the application as you might have for an msi installer in install shelld",
    "start": "2182320",
    "end": "2190720"
  },
  {
    "text": "most of installation parameters are in the values.yaml file though the most important parameter of the",
    "start": "2193440",
    "end": "2199839"
  },
  {
    "text": "installation is the location of the container image we'll retrieve it using command line",
    "start": "2199839",
    "end": "2206079"
  },
  {
    "text": "and paste it in the values.yaml",
    "start": "2209359",
    "end": "2215838"
  },
  {
    "text": "now we'll tell the chart we'll be installing the app in an app mesh",
    "start": "2216000",
    "end": "2221200"
  },
  {
    "text": "next we'll supply the kubernetes service account name for far gate pods having android proxy",
    "start": "2221440",
    "end": "2229839"
  },
  {
    "text": "and for the color service application we need to change the default health check path because default path of the caller",
    "start": "2230240",
    "end": "2235839"
  },
  {
    "text": "service the forward slash does the direction and that 302 http response status is treated as",
    "start": "2235839",
    "end": "2242160"
  },
  {
    "text": "a non-success by the system hence we set the health check path so it would return to 100 when all is",
    "start": "2242160",
    "end": "2248720"
  },
  {
    "text": "good that's all the default values we needed to change for the service application",
    "start": "2248720",
    "end": "2254720"
  },
  {
    "text": "helm chart believe it or not we'll also change some installation values from the command line when we will be installing the service",
    "start": "2254720",
    "end": "2261280"
  },
  {
    "text": "but that approach is for parameters changing with each installation okay we are ready to validate our",
    "start": "2261280",
    "end": "2266800"
  },
  {
    "text": "installation command line above will generate kubernetes manifest that will be applied in real installation",
    "start": "2266800",
    "end": "2273520"
  },
  {
    "text": "helm install command install the package located in the chart sub directory",
    "start": "2273520",
    "end": "2279520"
  },
  {
    "text": "and creates installation release named color service v1 also the installation command overrides",
    "start": "2279520",
    "end": "2286320"
  },
  {
    "text": "a couple of default installation parameters we set application container environment variable that will override color",
    "start": "2286320",
    "end": "2292560"
  },
  {
    "text": "configuration value from applicationsappsettings.json to return color green and another",
    "start": "2292560",
    "end": "2298560"
  },
  {
    "text": "installation parameter will expose our color service to the internet we do that only temporarily to",
    "start": "2298560",
    "end": "2304400"
  },
  {
    "text": "test our environment and ensure we have set everything up correctly let's run the command we can see",
    "start": "2304400",
    "end": "2311359"
  },
  {
    "text": "kubernetes resources that will be created when we run installation for real we get customer kubernetes deployment",
    "start": "2311359",
    "end": "2317280"
  },
  {
    "text": "and service resources but we also get app mesh resources like virtual node",
    "start": "2317280",
    "end": "2322480"
  },
  {
    "text": "virtual service and a gateway route let's install the application for real by rerunning the previous command",
    "start": "2322480",
    "end": "2329040"
  },
  {
    "text": "without the dry run flag",
    "start": "2329040",
    "end": "2332560"
  },
  {
    "text": "great next command will list packages installed in a current namespace on current kubernetes cluster",
    "start": "2334240",
    "end": "2340480"
  },
  {
    "text": "we can see all packages we have installed so far in the current namespace using helm",
    "start": "2340480",
    "end": "2345680"
  },
  {
    "text": "app mesh package ingress gateway package and color service v1 package we have",
    "start": "2345680",
    "end": "2352720"
  },
  {
    "text": "just installed to be precise this list contains named releases rather than packages",
    "start": "2352720",
    "end": "2358000"
  },
  {
    "text": "because unlike msi the windows installer any helm package can be easily installed more than once",
    "start": "2358000",
    "end": "2363599"
  },
  {
    "text": "in the same kubernetes namespace as long as each installation gets a unique release name and the chart is designed to",
    "start": "2363599",
    "end": "2370000"
  },
  {
    "text": "generate unique kubernetes resource names our chart does generate unique resource names based on the release name so",
    "start": "2370000",
    "end": "2376560"
  },
  {
    "text": "this will let us install another version of color service application later without changing any properties of the",
    "start": "2376560",
    "end": "2382079"
  },
  {
    "text": "installation package now let's wait for service application pod readiness all right everything is ready",
    "start": "2382079",
    "end": "2388880"
  },
  {
    "text": "and the ultimate test for our deployed application is to browse to our service and see what",
    "start": "2388880",
    "end": "2394839"
  },
  {
    "text": "happens",
    "start": "2394839",
    "end": "2397839"
  },
  {
    "text": "and we've got green as a response that is great all our infrastructure installations",
    "start": "2404480",
    "end": "2410400"
  },
  {
    "text": "and application installation have worked together successfully to deploy our first application to the",
    "start": "2410400",
    "end": "2415760"
  },
  {
    "text": "app mesh but functionally it is not different from regular application container deployment to eks",
    "start": "2415760",
    "end": "2422079"
  },
  {
    "text": "what is different here is that if we go to the aws x-ray page in the aws console we should",
    "start": "2422079",
    "end": "2428160"
  },
  {
    "text": "see graphical representation of our service map let me send a few more requests through and then go to the x-ray page",
    "start": "2428160",
    "end": "2439838"
  },
  {
    "text": "on the x-ray service map we can see the traffic pattern going from the client to the ingress gateway",
    "start": "2440160",
    "end": "2445599"
  },
  {
    "text": "to the service we can also see trace information if we click on service map elements",
    "start": "2445599",
    "end": "2450640"
  },
  {
    "text": "and see performance and success error data about requests flying through the mesh",
    "start": "2450640",
    "end": "2456240"
  },
  {
    "text": "this is one of the most valuable features of aws app mesh in action easy integration with aws x-ray and",
    "start": "2456240",
    "end": "2463119"
  },
  {
    "text": "supplying rich traffic metadata to enable x-ray service map functionality",
    "start": "2463119",
    "end": "2469920"
  },
  {
    "text": "let's also examine app measure sources we have created for our application as they are presented in",
    "start": "2472319",
    "end": "2477359"
  },
  {
    "text": "aws console our application virtual node a virtual service and a temporary",
    "start": "2477359",
    "end": "2485200"
  },
  {
    "text": "gateway route that we are about to remove to lock our backend service down inside the app mesh",
    "start": "2485200",
    "end": "2491119"
  },
  {
    "text": "now that we have tested the environment end-to-end i will remove the gateway route",
    "start": "2491119",
    "end": "2496319"
  },
  {
    "text": "and that will make the service inaccessible from outside the mesh a bit later we will install the front-end client web application",
    "start": "2496319",
    "end": "2503280"
  },
  {
    "text": "and will make it accessible from outside the cluster",
    "start": "2503280",
    "end": "2509599"
  },
  {
    "text": "okay let's go back to the browser and make sure that the service is no longer accessible on the web",
    "start": "2509599",
    "end": "2515359"
  },
  {
    "text": "okay we are done with the version one of the color service and with verifying that all other components we have installed so far are",
    "start": "2515359",
    "end": "2521839"
  },
  {
    "text": "working as expected next we will start using another important feature of aws",
    "start": "2521839",
    "end": "2526960"
  },
  {
    "start": "2524000",
    "end": "2524000"
  },
  {
    "text": "app mesh virtual router which enables blue green and canary roll outs and roll backs of new application versions",
    "start": "2526960",
    "end": "2533839"
  },
  {
    "text": "at this step we will put the canary enable endpoint in front of our color service",
    "start": "2533839",
    "end": "2538960"
  },
  {
    "text": "the key to creating a canary enabled endpoint in an app mesh is identical to creating a regular",
    "start": "2538960",
    "end": "2544000"
  },
  {
    "text": "kubernetes canary endpoint we need to tell the system about what label or labels define the set",
    "start": "2544000",
    "end": "2549359"
  },
  {
    "text": "of kubernetes pods that the canary endpoint will be fronting let's see which labels our color service",
    "start": "2549359",
    "end": "2555359"
  },
  {
    "text": "v1 has color service pods have multiple labels but there are two relevant to our",
    "start": "2555359",
    "end": "2560560"
  },
  {
    "text": "current task app label with a value of colored service and the release label with the value of",
    "start": "2560560",
    "end": "2567520"
  },
  {
    "text": "color service v1 as you can see the app label is version agnostic and the release label is",
    "start": "2567520",
    "end": "2573359"
  },
  {
    "text": "version dependent canary needs to send requests to any version of the application it serves so in order to define our canary",
    "start": "2573359",
    "end": "2580000"
  },
  {
    "text": "correctly we will need to keep in mind that it needs to send requests to any kubernetes pod",
    "start": "2580000",
    "end": "2585200"
  },
  {
    "text": "that has app label value set to color service canary endpoints lifecycle is quite",
    "start": "2585200",
    "end": "2590319"
  },
  {
    "text": "different from the life cycles of application resources because of this difference in life cycles and scopes our application",
    "start": "2590319",
    "end": "2597119"
  },
  {
    "text": "projects have second helm chart the canary chart in addition to the chart we used at the previous step",
    "start": "2597119",
    "end": "2602480"
  },
  {
    "text": "for installing the application itself canary chart creates a virtual service that serves as a virtual agnostic",
    "start": "2602480",
    "end": "2608400"
  },
  {
    "text": "network endpoint and a virtual router responsible for sending traffic to different versions of the application",
    "start": "2608400",
    "end": "2614000"
  },
  {
    "text": "we'll modify slightly our general purpose canary helm chart that is already part of our application project",
    "start": "2614000",
    "end": "2619520"
  },
  {
    "text": "let's open visual studio and modify the chart.yaml file of the canary helm chart",
    "start": "2619520",
    "end": "2625280"
  },
  {
    "text": "here as before we set application name and application description",
    "start": "2625280",
    "end": "2632160"
  },
  {
    "text": "we save the file now we'll edit the values.yaml file here we specify the label that every",
    "start": "2632160",
    "end": "2638640"
  },
  {
    "text": "color service pod will have regardless of application version and we also specify that the canary is",
    "start": "2638640",
    "end": "2645760"
  },
  {
    "text": "to be created by using app mesh virtual resources rather than with a regular kubernetes service",
    "start": "2645760",
    "end": "2652079"
  },
  {
    "text": "that's all the changes we needed to make in canary values.yaml file so we save the file and we are ready to",
    "start": "2652079",
    "end": "2658079"
  },
  {
    "text": "install the colorconair virtual service let's do the dry run of our canary installation first",
    "start": "2658079",
    "end": "2664079"
  },
  {
    "text": "let's review this command it tells helm to install the content of the folder name chart and to name installation release",
    "start": "2664079",
    "end": "2671280"
  },
  {
    "text": "as color dash canary we also do set a few installation parameters from the command line",
    "start": "2671280",
    "end": "2677599"
  },
  {
    "text": "we temporarily expose the color canary endpoint on the internet for testing purposes and the last two lines of the command",
    "start": "2677599",
    "end": "2684480"
  },
  {
    "text": "tell canary to send traffic only to the color service v1 virtual node let's run",
    "start": "2684480",
    "end": "2689599"
  },
  {
    "text": "the command to see resources that will be created when we run the installation for real we can see a gateway route that will",
    "start": "2689599",
    "end": "2695920"
  },
  {
    "text": "make color canary temporarily accessible on the web for testing a virtual service by which clients will",
    "start": "2695920",
    "end": "2702640"
  },
  {
    "text": "call the color service application and a virtual router that is responsible",
    "start": "2702640",
    "end": "2707920"
  },
  {
    "text": "for sending traffic down to specific application pods everything is looking good so let's run",
    "start": "2707920",
    "end": "2713280"
  },
  {
    "text": "the installation for real since the resources we create here are",
    "start": "2713280",
    "end": "2718720"
  },
  {
    "text": "virtual and the only actual outcome here will be updating android proxy configuration of the ingress gateway",
    "start": "2718720",
    "end": "2725200"
  },
  {
    "text": "we should be able to go to the browser and reach our canary endpoint right away at the forward slash color",
    "start": "2725200",
    "end": "2730560"
  },
  {
    "text": "dash canary path let me run a few requests through to make sure everything is working",
    "start": "2730560",
    "end": "2735599"
  },
  {
    "text": "okay our testing looks good so i can drop the gateway route for the color canary as it is a backend service that",
    "start": "2735599",
    "end": "2741760"
  },
  {
    "text": "does not need to be accessible on the web to do that i am removing the outside traffic allowed parameter which will",
    "start": "2741760",
    "end": "2747200"
  },
  {
    "text": "revert to the default value set in the values.yaml file of the canary helm chart let us run it",
    "start": "2747200",
    "end": "2753280"
  },
  {
    "text": "and make sure the color canary is no longer accessible on the web alright everything is working as",
    "start": "2753280",
    "end": "2758480"
  },
  {
    "text": "expected it's worth noting that the net result of this step and the previous one where we didn't have a canary and routed",
    "start": "2758480",
    "end": "2765440"
  },
  {
    "text": "requests from the ingress gateway directly to the caller service we want is the same both configurations resulted",
    "start": "2765440",
    "end": "2771760"
  },
  {
    "text": "in envoy proxy running at the ingress gateway getting configuration settings that told it to direct requests to the color",
    "start": "2771760",
    "end": "2778079"
  },
  {
    "text": "service v1 pods the benefit of the virtual canary service is that we have an easy way of",
    "start": "2778079",
    "end": "2783359"
  },
  {
    "text": "modifying it by installing the canary helm shot with different parameter values",
    "start": "2783359",
    "end": "2788960"
  },
  {
    "text": "next step is deploying client application and ensuring it can call the color service at the canary endpoint and the client is",
    "start": "2788960",
    "end": "2796000"
  },
  {
    "start": "2789000",
    "end": "2789000"
  },
  {
    "text": "accessible on a web as with a color service application we have already added the same general",
    "start": "2796000",
    "end": "2802560"
  },
  {
    "text": "purpose helm chart to our client application project now we just need to edit the chart a",
    "start": "2802560",
    "end": "2807760"
  },
  {
    "text": "little bit before we start using it we'll start with editing chart.yaml file of the application chart in visual",
    "start": "2807760",
    "end": "2814839"
  },
  {
    "text": "studio we change the chart name which serves as an application name",
    "start": "2814839",
    "end": "2822480"
  },
  {
    "text": "and will also provide the relevant application description no other changes are needed in the",
    "start": "2823200",
    "end": "2828960"
  },
  {
    "text": "chart.yaml file we can save it now next step is editing values.yaml file",
    "start": "2828960",
    "end": "2834240"
  },
  {
    "text": "the place for installer's default parameter values again the first thing to specify is the",
    "start": "2834240",
    "end": "2840079"
  },
  {
    "text": "location of the application container image this command will copy client application image location uri to the",
    "start": "2840079",
    "end": "2846720"
  },
  {
    "text": "clipboard we can paste it as the value of the repository parameter",
    "start": "2846720",
    "end": "2854240"
  },
  {
    "text": "next we set the value of the color service address pointing to the color canary virtual",
    "start": "2854960",
    "end": "2860240"
  },
  {
    "text": "service and edit the values of the app mesh",
    "start": "2860240",
    "end": "2866079"
  },
  {
    "text": "section enabled set to true to generate app mesh based installation instead of pure",
    "start": "2866079",
    "end": "2872160"
  },
  {
    "text": "kubernetes installation again we need to set the fargate pod",
    "start": "2872160",
    "end": "2877520"
  },
  {
    "text": "service account value to let client applications and web proxy run on fargate we can get the value from the fargatepod",
    "start": "2877520",
    "end": "2884240"
  },
  {
    "text": "account name powershell variable just a reminder fargate pod service",
    "start": "2884240",
    "end": "2890079"
  },
  {
    "text": "account parameter should point to the kubernetes service account mapped to an iim role that has",
    "start": "2890079",
    "end": "2895200"
  },
  {
    "text": "permissions to let and voip proxy get its configuration settings we have already used it twice once for",
    "start": "2895200",
    "end": "2900400"
  },
  {
    "text": "the ingress gateway and once for the color service outside traffic allowed",
    "start": "2900400",
    "end": "2905680"
  },
  {
    "text": "set to true we do it to let outside traffic to flow to the client application",
    "start": "2905680",
    "end": "2911680"
  },
  {
    "text": "gateway route match prefix forward slash will ensure that requests to the root",
    "start": "2911680",
    "end": "2916720"
  },
  {
    "text": "path of the application load balancer will be sent to the caller client application we can now do the dry run of",
    "start": "2916720",
    "end": "2923760"
  },
  {
    "text": "the client application installation let's use visual studio to copy the path of the application folder",
    "start": "2923760",
    "end": "2929359"
  },
  {
    "text": "and cd there and run the command that should be pretty familiar to you by now",
    "start": "2929359",
    "end": "2936319"
  },
  {
    "text": "as with the color service application we see kubernetes deployment in the service",
    "start": "2936319",
    "end": "2941839"
  },
  {
    "text": "as well as app mesh resources a virtual node a virtual service and a gateway route",
    "start": "2941839",
    "end": "2947440"
  },
  {
    "text": "everything looks good so let's run the installation for real",
    "start": "2947440",
    "end": "2952318"
  },
  {
    "text": "let's set up the wait for application pod readiness i will skip forward the video here okay",
    "start": "2953920",
    "end": "2959440"
  },
  {
    "text": "everything the client the service and the canary enabled endpoint are in place so if i",
    "start": "2959440",
    "end": "2964480"
  },
  {
    "text": "test the client in the browser everything should work great we're getting green color returned by",
    "start": "2964480",
    "end": "2971040"
  },
  {
    "text": "the service and it is shown by the client it meant our canary is sending 100 of the traffic to the color service v1",
    "start": "2971040",
    "end": "2978000"
  },
  {
    "text": "which is our current production version of the color service application now let's take a look at the aws x-ray",
    "start": "2978000",
    "end": "2984079"
  },
  {
    "text": "service map notice we now have multiple traffic segments here including hops between the",
    "start": "2984079",
    "end": "2990079"
  },
  {
    "text": "ingress gateway and the client application and then between the client and the color service v1",
    "start": "2990079",
    "end": "2997839"
  },
  {
    "text": "also let's see what we got in the aws app mesh page of the console",
    "start": "2997839",
    "end": "3003520"
  },
  {
    "text": "we got virtual gateway which is the ingress gateway we have created a few steps ago",
    "start": "3003520",
    "end": "3009359"
  },
  {
    "text": "which points to the color client virtual service",
    "start": "3009359",
    "end": "3013838"
  },
  {
    "text": "which in turn has a virtual node the virtual node points to the color",
    "start": "3014400",
    "end": "3019839"
  },
  {
    "text": "canary back-end service which has a virtual router",
    "start": "3019839",
    "end": "3027520"
  },
  {
    "text": "currently pointing to the color service v1 virtual node",
    "start": "3027520",
    "end": "3032400"
  },
  {
    "text": "at this point we are done with the prototype of the end to end solution that has only version 1 of the color service",
    "start": "3033200",
    "end": "3041280"
  },
  {
    "text": "next we'll see how rolling out version 2 of the color service will look like in our example color service v2 will",
    "start": "3041280",
    "end": "3048240"
  },
  {
    "text": "play a role of the new version of the application which after baking period should replace previous",
    "start": "3048240",
    "end": "3053359"
  },
  {
    "text": "production version we need to change our current directory to point to the application folder of the color service",
    "start": "3053359",
    "end": "3059599"
  },
  {
    "text": "application helm chart and now we can install another release",
    "start": "3059599",
    "end": "3064800"
  },
  {
    "text": "of the color service this command will install color service application again",
    "start": "3064800",
    "end": "3070240"
  },
  {
    "text": "this time as the color service v2 release and will set application color configuration setting",
    "start": "3070240",
    "end": "3075440"
  },
  {
    "text": "value to blue in real world instead of just changing application configuration setting you will modify application source code",
    "start": "3075440",
    "end": "3082160"
  },
  {
    "text": "build and push new container image and specify new image location as an installation parameter",
    "start": "3082160",
    "end": "3087440"
  },
  {
    "text": "either by modifying values.yellow file or using helm install command line parameter let's run the command",
    "start": "3087440",
    "end": "3097280"
  },
  {
    "text": "and now let's use another way of reviewing kubernetes manifest creating as part of the installation",
    "start": "3097280",
    "end": "3103920"
  },
  {
    "text": "we can see kubernetes resources a deployment and a service as well as app mesh resources a virtual",
    "start": "3104000",
    "end": "3110480"
  },
  {
    "text": "node and virtual service there is no gateway route this time because instead of connecting ingress",
    "start": "3110480",
    "end": "3115920"
  },
  {
    "text": "gateway to the application pods directly we will make color service v2 a part of the canary traffic split",
    "start": "3115920",
    "end": "3122319"
  },
  {
    "text": "let's go back to the canary helm chart directory and upgrade our color canary",
    "start": "3122319",
    "end": "3128559"
  },
  {
    "text": "installation by creating two virtual routes instead of just one we have right now one route will stay",
    "start": "3128559",
    "end": "3134640"
  },
  {
    "text": "pointing to the color source v1 and another new route we'll be sending traffic to the color source v2",
    "start": "3134640",
    "end": "3140800"
  },
  {
    "text": "we will also create color service v1 as a stable but all production version of the application by directing 80",
    "start": "3140800",
    "end": "3147359"
  },
  {
    "text": "of the traffic to it and color service v2 will be treated as an unproven new version",
    "start": "3147359",
    "end": "3152640"
  },
  {
    "text": "this configuration should result in our client showing green color approximately four times more frequently than blue",
    "start": "3152640",
    "end": "3158240"
  },
  {
    "text": "color here's the command that will update the color canary to the configuration we want",
    "start": "3158240",
    "end": "3163599"
  },
  {
    "text": "the command will update existing color canary application installation by supplying parameters creating two",
    "start": "3163599",
    "end": "3168960"
  },
  {
    "text": "virtual routes with 2080 traffic split expressed as target weight parameter values 1",
    "start": "3168960",
    "end": "3174720"
  },
  {
    "text": "and 4. let's run the command okay and let's check whether all pods of",
    "start": "3174720",
    "end": "3180559"
  },
  {
    "text": "the service color 2 are already up and running looks like everything is",
    "start": "3180559",
    "end": "3186559"
  },
  {
    "text": "in place so let's go to the color client browser page and run a few requests through",
    "start": "3186559",
    "end": "3192720"
  },
  {
    "text": "i am clicking and getting both blue and green with color green popping up more frequently than the blue which",
    "start": "3192720",
    "end": "3198880"
  },
  {
    "text": "means our canary is in place and performing as expected you have probably guessed that by",
    "start": "3198880",
    "end": "3204480"
  },
  {
    "text": "repeatedly running helm upgrade command with different values of target weights we can keep shifting traffic",
    "start": "3204480",
    "end": "3210400"
  },
  {
    "text": "incrementally or roll back 100 percent of the traffic to the old version in seconds if the new",
    "start": "3210400",
    "end": "3215440"
  },
  {
    "text": "version turns out to be problematic one could write a script that could watch service error rate and other",
    "start": "3215440",
    "end": "3221359"
  },
  {
    "text": "performance metrics of both new and old versions and if version 2 remains stable after each incremental traffic shift",
    "start": "3221359",
    "end": "3228319"
  },
  {
    "text": "automatically finish shifting 100 percent of traffic to the new version 2.",
    "start": "3228319",
    "end": "3233520"
  },
  {
    "text": "ok let's take another look at the aws x-ray service map now",
    "start": "3233520",
    "end": "3239359"
  },
  {
    "text": "here it is we see color client application calling both color service v1 and color service v2 and the number of",
    "start": "3239359",
    "end": "3246160"
  },
  {
    "text": "calls is roughly 1 to 4. if we click on service map elements we can see trace data",
    "start": "3246160",
    "end": "3251280"
  },
  {
    "text": "related to that map element",
    "start": "3251280",
    "end": "3254960"
  },
  {
    "text": "finally let's see our app mesh page in the aws console and see how color canary virtual router",
    "start": "3258000",
    "end": "3264480"
  },
  {
    "text": "is configured as you see it has two routes now",
    "start": "3264480",
    "end": "3269760"
  },
  {
    "text": "pointing to two different virtual nodes representing old and new versions of the color service",
    "start": "3269760",
    "end": "3276880"
  },
  {
    "text": "the final step of our solution build out is to fully switch traffic to color service v2 without causing any",
    "start": "3276880",
    "end": "3282799"
  },
  {
    "start": "3277000",
    "end": "3277000"
  },
  {
    "text": "disruption to clients we'll do that in two steps first we will use color service canary endpoint",
    "start": "3282799",
    "end": "3289119"
  },
  {
    "text": "installer to shift hundred percent of color service traffic to color service v2 and if everything keeps working well",
    "start": "3289119",
    "end": "3295119"
  },
  {
    "text": "we'll uninstall color service v1 release to shift the traffic from the color service v2 we'll run this command",
    "start": "3295119",
    "end": "3302319"
  },
  {
    "text": "this command updates color canary virtual router settings to send all traffic to color source v2",
    "start": "3302319",
    "end": "3309760"
  },
  {
    "text": "let's run the command and test our client as you can see we started getting only",
    "start": "3309760",
    "end": "3315280"
  },
  {
    "text": "blue color in just a matter of seconds at this point we could still switch everything back to version 1",
    "start": "3315280",
    "end": "3321119"
  },
  {
    "text": "if something went wrong with version 2. but we have tested version 2 and are confident it is stable so we can",
    "start": "3321119",
    "end": "3327359"
  },
  {
    "text": "now go ahead and uninstall color service v1 let's go to vs code to make sure color",
    "start": "3327359",
    "end": "3333440"
  },
  {
    "text": "service v1 is gone all right color service v1 is no longer",
    "start": "3333440",
    "end": "3339200"
  },
  {
    "text": "there meaning we have completed the process of replacing version one of the service application with version two without",
    "start": "3339200",
    "end": "3344799"
  },
  {
    "text": "disrupting the client at all let's take one final look at the aws app mesh page",
    "start": "3344799",
    "end": "3352000"
  },
  {
    "text": "where we can no longer see color series we want no virtual service",
    "start": "3352640",
    "end": "3358559"
  },
  {
    "text": "and no color series we wonder out at the canary virtual router",
    "start": "3359280",
    "end": "3364480"
  },
  {
    "text": "and let's also check out aws x-ray service map we see now that all recent traffic went",
    "start": "3364880",
    "end": "3371680"
  },
  {
    "text": "to the color source v2 so here we are we have two asp.net core",
    "start": "3371680",
    "end": "3378319"
  },
  {
    "text": "applications absolutely unaware of aws kubernetes or any other infrastructure or compute service",
    "start": "3378319",
    "end": "3384400"
  },
  {
    "text": "outside of just being compatible with docker we used open source tools to simplify provisioning of amazon",
    "start": "3384400",
    "end": "3391280"
  },
  {
    "text": "eks cluster aws app mesh and to install required integration components",
    "start": "3391280",
    "end": "3396480"
  },
  {
    "text": "and then we use general purpose helm charts compatible with both regular kubernetes and with aws app mesh to install client",
    "start": "3396480",
    "end": "3403839"
  },
  {
    "text": "and service applications and to create a canary enabled router endpoint for the service application finally we",
    "start": "3403839",
    "end": "3411040"
  },
  {
    "text": "were able to use aws x-ray to see application trace data and the service map",
    "start": "3411040",
    "end": "3416319"
  },
  {
    "text": "and that is how aws app mesh enables network controls and consistent visibility",
    "start": "3416319",
    "end": "3421599"
  },
  {
    "text": "for your container workloads if you have used your own aws account to build",
    "start": "3421599",
    "end": "3426960"
  },
  {
    "text": "solution described in this video following commands will let you remove most of aws resources created",
    "start": "3426960",
    "end": "3432000"
  },
  {
    "text": "here you may treat this video as a lab",
    "start": "3432000",
    "end": "3438160"
  },
  {
    "text": "walkthrough all parts necessary to build this solution are accessible on the web so you could practice building the solution yourself",
    "start": "3438160",
    "end": "3445599"
  },
  {
    "start": "3440000",
    "end": "3440000"
  },
  {
    "text": "on top of that you could improve it by adding canary enabled endpoint to the client application",
    "start": "3445599",
    "end": "3450640"
  },
  {
    "text": "we have not done that in this video but all ingredients are in place please write the comment if you",
    "start": "3450640",
    "end": "3455680"
  },
  {
    "text": "completed this challenge we would like to know if you succeeded to help with implementing this little",
    "start": "3455680",
    "end": "3460720"
  },
  {
    "text": "homework task here is a brief overview of the steps you may take to solve the problem",
    "start": "3460720",
    "end": "3467039"
  },
  {
    "text": "well this is it thank you very much for watching this video please post a comment and rate it to let",
    "start": "3471920",
    "end": "3477680"
  },
  {
    "text": "us know whether this video was useful thanks again and please be sure to explore other aws videos",
    "start": "3477680",
    "end": "3489040"
  },
  {
    "text": "you",
    "start": "3489040",
    "end": "3491119"
  }
]