[
  {
    "start": "0",
    "end": "61000"
  },
  {
    "text": "my name is Toni Gibbs I'm a data warehousing solution architect with Amazon Web Services and today we're",
    "start": "30",
    "end": "5640"
  },
  {
    "text": "gonna be going through best practices on Amazon redshift so let's get started",
    "start": "5640",
    "end": "11219"
  },
  {
    "text": "here I always like to ask this one just to kind of get a feel for where you guys are all at how many people here use",
    "start": "11219",
    "end": "17160"
  },
  {
    "text": "Amazon redshift on a regular basis oh wow that's awesome how many of you are",
    "start": "17160",
    "end": "24320"
  },
  {
    "text": "evaluating redshift you don't actually use it today but you're maybe looking at it ok this is perfect this is exactly",
    "start": "24320",
    "end": "31410"
  },
  {
    "text": "what I was hoping I'd see how many people have never used redshift you're just interested in it maybe something of",
    "start": "31410",
    "end": "37079"
  },
  {
    "text": "interest okay a couple of you so this talk is mostly geared for the first you",
    "start": "37079",
    "end": "44430"
  },
  {
    "text": "know a couple people are as asking about the rest of you I have tried to make it",
    "start": "44430",
    "end": "50100"
  },
  {
    "text": "in such a way that if you're familiar with data warehousing databases you should be able to get something from",
    "start": "50100",
    "end": "56129"
  },
  {
    "text": "this enough to at least get you started on redshift so let's get started here we're gonna quickly start out I'm gonna",
    "start": "56129",
    "end": "63149"
  },
  {
    "start": "61000",
    "end": "61000"
  },
  {
    "text": "move through this first part you know it's the history and development of redshift where it came from our history",
    "start": "63149",
    "end": "68549"
  },
  {
    "text": "you know the last four years of development that we've done then we're going to move into concepts table",
    "start": "68549",
    "end": "74729"
  },
  {
    "text": "designs so some of the concepts are mainly to make you aware of you know some of the just how we talk about redshift then we'll go through table",
    "start": "74729",
    "end": "81930"
  },
  {
    "text": "design and the next part is best practices on ingestion and data loading",
    "start": "81930",
    "end": "88799"
  },
  {
    "text": "and elt and that sort of thing and then we're gonna wrap up the last part will be on cluster sizing so this one will be",
    "start": "88799",
    "end": "97079"
  },
  {
    "text": "fantastic for the few of you guys who are never used redshift and maybe you're going to give it a try this or if you're",
    "start": "97079",
    "end": "103770"
  },
  {
    "text": "working on a migration or something like that that section will be good for you and then we're gonna finish with",
    "start": "103770",
    "end": "109829"
  },
  {
    "text": "whatever QA time is left and you guys can you know ask me all sorts of stuff I will also hang out after the",
    "start": "109829",
    "end": "116399"
  },
  {
    "text": "presentation you know outside or wherever and you guys can continue to ask me questions and I'll stay for as",
    "start": "116399",
    "end": "122579"
  },
  {
    "text": "long as you guys continue to you know have questions so let's get moving on",
    "start": "122579",
    "end": "128489"
  },
  {
    "text": "with the history of redshift really kind of starts out with Postgres if you",
    "start": "128489",
    "end": "133500"
  },
  {
    "text": "to redshift for the first time or for all of you guys who have used it you will notice that it returns back a",
    "start": "133500",
    "end": "138900"
  },
  {
    "text": "Postgres connection string we obviously rewrote the entire storage engine it's a column or storage engine",
    "start": "138900",
    "end": "145320"
  },
  {
    "text": "and we made the system MPP which is why you can scale it horizontally up to 128",
    "start": "145320",
    "end": "151650"
  },
  {
    "text": "nodes then we added a lot of analytics functions proximate count distinct",
    "start": "151650",
    "end": "157380"
  },
  {
    "text": "functions approximate you know percentiles and all these other kinds of",
    "start": "157380",
    "end": "162990"
  },
  {
    "text": "functions that you typically use in an analytics data warehouse we wrapped all",
    "start": "162990",
    "end": "168930"
  },
  {
    "text": "of it up in AWS this is integration with s3 for backups and restores and loading all kind of stuff kms for encryption I",
    "start": "168930",
    "end": "176239"
  },
  {
    "text": "am which is you know for authentication and connecting to s3 and such and it",
    "start": "176239",
    "end": "183239"
  },
  {
    "text": "really is the combination of all of these components that make redshift what",
    "start": "183239",
    "end": "188790"
  },
  {
    "text": "it is we launched redshift almost five years ago when GA on Valentine's Day",
    "start": "188790",
    "end": "196470"
  },
  {
    "text": "February 2013 and since that time we have added a lot of features and",
    "start": "196470",
    "end": "202380"
  },
  {
    "text": "functionality we've really been innovating and adding to the product we do patches typically on a two-week",
    "start": "202380",
    "end": "209160"
  },
  {
    "text": "cadence it is a fully managed service so that means you set a 30-minute maintenance window and we roll out those",
    "start": "209160",
    "end": "215670"
  },
  {
    "text": "patches continuously security updates and all that kind of stuff and it's not something you really actually have to",
    "start": "215670",
    "end": "221250"
  },
  {
    "text": "worry about just check the patch notes and you get some new cool features and such so let's move on to the concepts",
    "start": "221250",
    "end": "229680"
  },
  {
    "text": "and table design I'm going to just start out with the architecture of redshift the top part up here that's kind of",
    "start": "229680",
    "end": "236730"
  },
  {
    "start": "231000",
    "end": "231000"
  },
  {
    "text": "where you connect from the sequel clients and BI tools redshift supports",
    "start": "236730",
    "end": "243030"
  },
  {
    "text": "we actually supply JDBC ODBC drivers but it does support the use of also Postgres",
    "start": "243030",
    "end": "250079"
  },
  {
    "text": "drivers as well so say you're wanting to connect from Python for example you can use psycho PG tool too which is the",
    "start": "250079",
    "end": "257310"
  },
  {
    "text": "Postgres Python driver and you can connect to redshift with that your",
    "start": "257310",
    "end": "263310"
  },
  {
    "text": "connection connects to that top blue box there which we the leader node the leader node does all",
    "start": "263310",
    "end": "269960"
  },
  {
    "text": "of the query parsing it does query coordination and all of that kind of",
    "start": "269960",
    "end": "275540"
  },
  {
    "text": "stuff it also stores this PG catalog so",
    "start": "275540",
    "end": "280730"
  },
  {
    "text": "if you actually are familiar with Postgres you'll see that the PG catalog in redshift is intact behind the leader",
    "start": "280730",
    "end": "289130"
  },
  {
    "text": "node sits up to 128 compute nodes this is just this example has three compute",
    "start": "289130",
    "end": "295010"
  },
  {
    "text": "notes you can go from two to 128 of those that's where the data actually resides in redshift and that's also",
    "start": "295010",
    "end": "302800"
  },
  {
    "text": "there what do all of the heavy processing and heavy lifting of the data",
    "start": "302800",
    "end": "308979"
  },
  {
    "text": "the one thing to take away is is that they do everything in parallel all of",
    "start": "308979",
    "end": "315139"
  },
  {
    "text": "them together and that's something what we call a massively parallel architecture so every compute node works",
    "start": "315139",
    "end": "322580"
  },
  {
    "text": "on a single query all at the same time these compute nodes also talk directly",
    "start": "322580",
    "end": "328850"
  },
  {
    "text": "to s3 so this is typically how you load data in and out of redshift will go much",
    "start": "328850",
    "end": "334190"
  },
  {
    "text": "deeper into that they also the backups and restores also go directly from the",
    "start": "334190",
    "end": "339260"
  },
  {
    "text": "compute nodes to s3 earlier this year we released what we call Amazon redshift",
    "start": "339260",
    "end": "346150"
  },
  {
    "text": "spectrum this gives redshift the ability to query",
    "start": "346150",
    "end": "351229"
  },
  {
    "text": "s3 directly and we do this by provisioning extra there's actually",
    "start": "351229",
    "end": "358940"
  },
  {
    "text": "another layer of compute that sits between it's an elastic layer and that's",
    "start": "358940",
    "end": "365450"
  },
  {
    "text": "what actually does the query unit of s3 and passes the data back up to your redshift compute nodes and then",
    "start": "365450",
    "end": "371840"
  },
  {
    "text": "obviously up through the leader node into you you can also load data through",
    "start": "371840",
    "end": "377539"
  },
  {
    "text": "the spectrum layer and we'll talk about that in the ingestion section as well so",
    "start": "377539",
    "end": "386030"
  },
  {
    "start": "385000",
    "end": "385000"
  },
  {
    "text": "the first terminology are dimension it column ER redshift is a column or data",
    "start": "386030",
    "end": "391340"
  },
  {
    "text": "warehouse so what that means is we store data on disk column by column rather than row by row and the reason we do",
    "start": "391340",
    "end": "398960"
  },
  {
    "text": "this is because the queries that you typically run against against a data warehouse like you know sums and",
    "start": "398960",
    "end": "404969"
  },
  {
    "text": "averages and various other aggregate functions typically only operate on a subset of the columns so when you're",
    "start": "404969",
    "end": "412449"
  },
  {
    "text": "only querying some of the columns and across millions or billions of rows a column or architecture greatly reduces",
    "start": "412449",
    "end": "420069"
  },
  {
    "text": "IO on those sorts of operations just to illustrate that suppose we have this",
    "start": "420069",
    "end": "425710"
  },
  {
    "text": "deep dive table very simple we only have four rows in it and we have a sequel query which we're going to select the",
    "start": "425710",
    "end": "431379"
  },
  {
    "text": "minimum date out of that table in a row based database like say Postgres for",
    "start": "431379",
    "end": "436809"
  },
  {
    "text": "example assuming there's no indexes or anything like that you would end up having to scan through the entire table",
    "start": "436809",
    "end": "443439"
  },
  {
    "text": "to find that minimum date whereas in a column ER data warehouse like redshift",
    "start": "443439",
    "end": "450039"
  },
  {
    "text": "what happens is is we only need to read the data for that date and thus we",
    "start": "450039",
    "end": "455439"
  },
  {
    "text": "reduce io the next piece is compression",
    "start": "455439",
    "end": "461909"
  },
  {
    "start": "458000",
    "end": "458000"
  },
  {
    "text": "compression does two things in redshift one it allows you to store significantly",
    "start": "461909",
    "end": "468279"
  },
  {
    "text": "more data in your cluster up to about four times more data it also improves",
    "start": "468279",
    "end": "476050"
  },
  {
    "text": "the performance of redshift as well and the reason why is we actually reduce IO",
    "start": "476050",
    "end": "481779"
  },
  {
    "text": "we've stopped more data into our data blocks and we're able to read more off",
    "start": "481779",
    "end": "486789"
  },
  {
    "text": "disk quickly a lot of CPU and i/o is still the bottleneck so that's why it improves performance we do our best in",
    "start": "486789",
    "end": "495430"
  },
  {
    "text": "redshift to figure out the optimal compression for you so the first time you load data",
    "start": "495430",
    "end": "500529"
  },
  {
    "text": "into a redshift table we will try to figure out that compression we also have",
    "start": "500529",
    "end": "506169"
  },
  {
    "text": "a utility or command built-in to redshift called analyze compression that",
    "start": "506169",
    "end": "511539"
  },
  {
    "text": "will find the optimal compression for you just to quickly give an example of",
    "start": "511539",
    "end": "518500"
  },
  {
    "start": "516000",
    "end": "516000"
  },
  {
    "text": "how compression works in redshift same table same data if we modify the DDL",
    "start": "518500",
    "end": "524790"
  },
  {
    "text": "with these encode statements here that's how compression is applied to",
    "start": "524790",
    "end": "529899"
  },
  {
    "text": "redshift so we're going to add you zyy standard which is a new compression type we added earlier this year in the",
    "start": "529899",
    "end": "537330"
  },
  {
    "text": "first example byte dict and run-length are just a couple of the examples that we have for our encoding or compression",
    "start": "537330",
    "end": "543960"
  },
  {
    "text": "types so the best practices on compression and redshift the first is",
    "start": "543960",
    "end": "551190"
  },
  {
    "start": "546000",
    "end": "546000"
  },
  {
    "text": "try to apply compression to all tables if you run the analyze compression",
    "start": "551190",
    "end": "557190"
  },
  {
    "text": "command you may notice sometimes you get raw which means no compression for some",
    "start": "557190",
    "end": "564300"
  },
  {
    "text": "columns or maybe for all of them if that's coming back that's because the table is so small that there's not",
    "start": "564300",
    "end": "570630"
  },
  {
    "text": "really a benefit to adding compression to it so don't be alarmed if you see that we also have this is a github link",
    "start": "570630",
    "end": "577500"
  },
  {
    "text": "we have a lot of ton of scripts on github and you're going to see these links throughout the presentation but this is the first one this utility here",
    "start": "577500",
    "end": "584250"
  },
  {
    "text": "on github is one that we built and posted that will help you migrate tables",
    "start": "584250",
    "end": "591240"
  },
  {
    "text": "that maybe don't have optimal compression in your redshift cluster and they'll rewrite the table and copy the",
    "start": "591240",
    "end": "597720"
  },
  {
    "text": "data over that's sequel query there that's one of the PG tables that we've",
    "start": "597720",
    "end": "603390"
  },
  {
    "text": "actually added into the PG catalog table catalog schema and that would be an",
    "start": "603390",
    "end": "609360"
  },
  {
    "text": "example of how you'd find the compression on an existing table so the",
    "start": "609360",
    "end": "616080"
  },
  {
    "start": "615000",
    "end": "615000"
  },
  {
    "text": "next concept to talk about is what we call blocks in redshift this is basically how the columns are",
    "start": "616080",
    "end": "622920"
  },
  {
    "text": "constructed they're one Meg immutable chunks that we store on disk for aunt",
    "start": "622920",
    "end": "629730"
  },
  {
    "text": "for each column every block will have one of eleven different encodings with",
    "start": "629730",
    "end": "634890"
  },
  {
    "text": "one of those encoding x' being raw which means uncompressed when you factor compression in one of our data blocks we",
    "start": "634890",
    "end": "642630"
  },
  {
    "text": "can store millions of values so when you think about that that means that a single block in redshift holds the",
    "start": "642630",
    "end": "650490"
  },
  {
    "text": "values for millions of rows for that one column the next concept is zone maps and",
    "start": "650490",
    "end": "657810"
  },
  {
    "start": "655000",
    "end": "655000"
  },
  {
    "text": "this really does relate to blocks because this what they are is it's metadata about the blocks so",
    "start": "657810",
    "end": "665680"
  },
  {
    "text": "the main piece of metadata that we have here is we store the minimum and the maximum values within each of those 1",
    "start": "665680",
    "end": "673210"
  },
  {
    "text": "Meg blocks and the reason we do this is when a sequel query comes in we can",
    "start": "673210",
    "end": "679120"
  },
  {
    "text": "check this in memory data structure and we can prune data out the next concept",
    "start": "679120",
    "end": "685959"
  },
  {
    "start": "685000",
    "end": "685000"
  },
  {
    "text": "is data sorting this is physically sorting data on disk in redshift so this",
    "start": "685959",
    "end": "693670"
  },
  {
    "text": "is you basically picking one or more columns and sorting the table by those and the point of this is to make the",
    "start": "693670",
    "end": "701500"
  },
  {
    "text": "zone maps on the previous slide more effective that is the primary purpose of",
    "start": "701500",
    "end": "706959"
  },
  {
    "text": "a sort key typically they're put on the columns that you're filtering on so if",
    "start": "706959",
    "end": "713709"
  },
  {
    "text": "you have a where clause or like a predicate essentially and you're doing you know where this date is between",
    "start": "713709",
    "end": "719830"
  },
  {
    "text": "these values for example that's an example of where you'd want to place your sort key obviously sort keys depend",
    "start": "719830",
    "end": "726970"
  },
  {
    "text": "on your query patterns and your business requirements and that sort of thing but a lot of times it will land on the",
    "start": "726970",
    "end": "733750"
  },
  {
    "text": "columns that you primarily are filtering on in your sequel queries just to give a",
    "start": "733750",
    "end": "739480"
  },
  {
    "start": "738000",
    "end": "738000"
  },
  {
    "text": "quick example of how sorting is done in redshift the same table same data been",
    "start": "739480",
    "end": "745870"
  },
  {
    "text": "already already working with we modify the DDL here and in this example I'm",
    "start": "745870",
    "end": "751390"
  },
  {
    "text": "adding a sort key to first the date column and then the location if I were",
    "start": "751390",
    "end": "756700"
  },
  {
    "text": "to sort this table now the data would end up like this sorted first by the date and then by the",
    "start": "756700",
    "end": "764320"
  },
  {
    "text": "location and the point here is to make the zone Maps more effective to",
    "start": "764320",
    "end": "769390"
  },
  {
    "text": "illustrate the two working together suppose we have four data blocks here we",
    "start": "769390",
    "end": "774700"
  },
  {
    "start": "770000",
    "end": "770000"
  },
  {
    "text": "have the zone maps which are the metadata there which is held in memory and redshift and we have a sequel query",
    "start": "774700",
    "end": "780760"
  },
  {
    "text": "where we're just going to basically count the number of Records on a certain day what redshift is going to do is it's",
    "start": "780760",
    "end": "788140"
  },
  {
    "text": "going to check the zone Maps first and go I only need to read these three data blocks off disk I can skip reading this",
    "start": "788140",
    "end": "794440"
  },
  {
    "text": "one which reduces i/o and that's exactly what the zone maps do",
    "start": "794440",
    "end": "799760"
  },
  {
    "text": "if we take that same table and we sort it by the date now what happens is those",
    "start": "799760",
    "end": "804889"
  },
  {
    "text": "own maps are in a more optimal condition for the sequel query and we can read we",
    "start": "804889",
    "end": "811639"
  },
  {
    "text": "reduce i/o further so the main point is",
    "start": "811639",
    "end": "816860"
  },
  {
    "start": "816000",
    "end": "816000"
  },
  {
    "text": "is that sort keys are primarily making the zone Maps more effective usually it",
    "start": "816860",
    "end": "826670"
  },
  {
    "text": "will end up being on a timestamp and that's because in data warehousing you guys end up having some sort of temporal",
    "start": "826670",
    "end": "834050"
  },
  {
    "text": "column that you're searching or filtering between but so not always the",
    "start": "834050",
    "end": "839149"
  },
  {
    "text": "case if you have many columns or more than one column in your sort key ideally",
    "start": "839149",
    "end": "845180"
  },
  {
    "text": "you want to have the lower cardinality columns first so this might be maybe",
    "start": "845180",
    "end": "850339"
  },
  {
    "text": "there was an organization ID and then a timestamp for example and that organization ID maybe only had a dozen",
    "start": "850339",
    "end": "856519"
  },
  {
    "text": "values that would be an example of where you would you know place the change the",
    "start": "856519",
    "end": "863209"
  },
  {
    "text": "order of those and not have your date column first we do have a couple of",
    "start": "863209",
    "end": "870199"
  },
  {
    "text": "github scripts if you have an existing workload that you can run against your redshift cluster what these scripts will",
    "start": "870199",
    "end": "877190"
  },
  {
    "text": "do is is based on the logs in your cluster and what you're typically running queries against those tables on",
    "start": "877190",
    "end": "883670"
  },
  {
    "text": "they will look at that and return back what what you're usually filtering on",
    "start": "883670",
    "end": "890230"
  },
  {
    "text": "one thing to make a note of is sort keys on really small tables they're not really necessary so if you have a table",
    "start": "891130",
    "end": "897260"
  },
  {
    "text": "of like say 10,000 rows you don't really need to sort it because chances are the table only has one block anyways and",
    "start": "897260",
    "end": "904160"
  },
  {
    "text": "there's not really anything to optimize in his own Maps",
    "start": "904160",
    "end": "908980"
  },
  {
    "start": "910000",
    "end": "910000"
  },
  {
    "text": "the next concept is slices which is a really important concept in redshift so",
    "start": "910540",
    "end": "916880"
  },
  {
    "text": "this is how we get parallelism within a redshift cluster so every single one of",
    "start": "916880",
    "end": "923120"
  },
  {
    "text": "our compute nodes is divvied up into two 16 or 32 slices we store the data",
    "start": "923120",
    "end": "931149"
  },
  {
    "text": "physically per slice and each individual slice will only operate on the data that",
    "start": "931149",
    "end": "937910"
  },
  {
    "text": "belongs to it so again it's to get parallelism it's how redshift gets its",
    "start": "937910",
    "end": "942920"
  },
  {
    "text": "parallelism within a single node so how",
    "start": "942920",
    "end": "948170"
  },
  {
    "text": "do we distribute the data amongst these slices this is what the distribution Keys come where they come in the first",
    "start": "948170",
    "end": "955190"
  },
  {
    "text": "one is what we call dis style key what",
    "start": "955190",
    "end": "960230"
  },
  {
    "text": "we're essentially doing with when you pick a column this is what happens is you pick a column and you sign it when",
    "start": "960230",
    "end": "966949"
  },
  {
    "text": "you use this distribution style what will happen is is the value for that row",
    "start": "966949",
    "end": "972170"
  },
  {
    "text": "in that column we hash it and that hash corresponds to one of the slices in your",
    "start": "972170",
    "end": "978139"
  },
  {
    "text": "cluster and that's where the data ends up landed the next distribution style we",
    "start": "978139",
    "end": "983630"
  },
  {
    "text": "have is even what even essentially is is we're just going to round-robin the data",
    "start": "983630",
    "end": "988940"
  },
  {
    "text": "for you on your behalf it's the default choice in redshift the last choice is",
    "start": "988940",
    "end": "995389"
  },
  {
    "text": "distribution style all and what that essentially means is we take an entire",
    "start": "995389",
    "end": "1000399"
  },
  {
    "text": "copy of the table and we write it out onto each node in the cluster so the",
    "start": "1000399",
    "end": "1005680"
  },
  {
    "text": "whole table exists on every single note the reason for that is typically",
    "start": "1005680",
    "end": "1011260"
  },
  {
    "text": "dimension tables small tables that you're joining to and you're trying to reduce the network broadcast when you do",
    "start": "1011260",
    "end": "1017740"
  },
  {
    "text": "joints on those tables so going to illustrate how each of these",
    "start": "1017740",
    "end": "1023709"
  },
  {
    "text": "distribution Styles work now I'm gonna start out with even so the same deep dive table I've been talking about this",
    "start": "1023709",
    "end": "1030579"
  },
  {
    "text": "whole night and there's we're gonna insert these four rows into the table we're gonna start out by inserting the",
    "start": "1030579",
    "end": "1038260"
  },
  {
    "text": "first one there SFO and it's going land on the first compute node here on",
    "start": "1038260",
    "end": "1043819"
  },
  {
    "text": "the first slice the second-row JFK is going to land on the second slice in",
    "start": "1043819",
    "end": "1049909"
  },
  {
    "text": "that first compute node the third one and the fourth one so it's just",
    "start": "1049909",
    "end": "1055130"
  },
  {
    "text": "round-robin E and the data through the cluster pretty simple so let's pick a key here let's use this style key in our",
    "start": "1055130",
    "end": "1062539"
  },
  {
    "text": "second example and I'm picking the location column here which corresponds",
    "start": "1062539",
    "end": "1068030"
  },
  {
    "text": "to those values SFO JFK SFO and JFK there so if I take that first row and",
    "start": "1068030",
    "end": "1074530"
  },
  {
    "text": "maybe it lands here on this slice and the second row lands on that slice",
    "start": "1074530",
    "end": "1080780"
  },
  {
    "text": "what's going to happen is is SFO is gonna hash back to that first slice and",
    "start": "1080780",
    "end": "1086570"
  },
  {
    "text": "JFK is gonna land on that second slice makes sense however this is an example",
    "start": "1086570",
    "end": "1092840"
  },
  {
    "text": "of a bad distribution in redshift remember I talked about MPP massive",
    "start": "1092840",
    "end": "1098090"
  },
  {
    "text": "parallel processing well what's gonna happen here is if you execute a query against this cluster your second compute",
    "start": "1098090",
    "end": "1106100"
  },
  {
    "text": "node doesn't have any data in it at all and it actually does absolutely nothing and so you have one node doing all of",
    "start": "1106100",
    "end": "1112549"
  },
  {
    "text": "the work so that's what we call rows Q so what let's pick a better column to",
    "start": "1112549",
    "end": "1119960"
  },
  {
    "text": "distribute by now I'm gonna pick the a ID or audience ID here which is looks",
    "start": "1119960",
    "end": "1125030"
  },
  {
    "text": "like a primary key that first row might end up hashing out to that slice the",
    "start": "1125030",
    "end": "1130520"
  },
  {
    "text": "second one over there third one there and fourth one over there now I obviously bake this example so it worked",
    "start": "1130520",
    "end": "1137510"
  },
  {
    "text": "out perfect statistically if you have a large amount of rows it will work out",
    "start": "1137510",
    "end": "1143330"
  },
  {
    "text": "fairly well so that's the event that's the idea of how distribution style key works so",
    "start": "1143330",
    "end": "1150980"
  },
  {
    "text": "let's talk about distribution style all what we do here is as each row comes in",
    "start": "1150980",
    "end": "1156710"
  },
  {
    "text": "we write it to the first slice on each note so that there is an entire copy of",
    "start": "1156710",
    "end": "1164330"
  },
  {
    "text": "it existing on each slice in the club or on each node in the cluster so that's",
    "start": "1164330",
    "end": "1171470"
  },
  {
    "text": "how dis style all works so what are the best practices the best",
    "start": "1171470",
    "end": "1176850"
  },
  {
    "start": "1174000",
    "end": "1174000"
  },
  {
    "text": "practices are to use distribution style key primarily for optimizing joint",
    "start": "1176850",
    "end": "1184110"
  },
  {
    "text": "performance so this is if you have two tables for example which you join and",
    "start": "1184110",
    "end": "1190410"
  },
  {
    "text": "there's the on clause and that on Clause has the two columns that you know you're joining on ideally you want to make that",
    "start": "1190410",
    "end": "1199350"
  },
  {
    "text": "the distribution style for both of those tables the other primary reason for",
    "start": "1199350",
    "end": "1206580"
  },
  {
    "text": "using distribution style key is if you're copying data from one table into",
    "start": "1206580",
    "end": "1212160"
  },
  {
    "text": "another using an insert into and a select from the other table if those two tables share the same distribution key",
    "start": "1212160",
    "end": "1218820"
  },
  {
    "text": "you're gonna find that that insert is significantly faster as well those are the primary reasons for it now there is",
    "start": "1218820",
    "end": "1227790"
  },
  {
    "text": "one thing that you do I mentioned obviously the skew how do you figure that out that's skew this is the query in the",
    "start": "1227790",
    "end": "1235590"
  },
  {
    "text": "system table svv underscore table underscore info and it's called skew",
    "start": "1235590",
    "end": "1241230"
  },
  {
    "text": "rows ideally that value should be somewhat close to one what it means is",
    "start": "1241230",
    "end": "1246960"
  },
  {
    "text": "is if we took a take a look at the slices and we take the slice with the least amount of data and the slice with",
    "start": "1246960",
    "end": "1253590"
  },
  {
    "text": "the most data that number is the ratio between those so ideally we want it to",
    "start": "1253590",
    "end": "1259740"
  },
  {
    "text": "be something you know 1 1.1 1.2 those are totally fine but once you start",
    "start": "1259740",
    "end": "1264870"
  },
  {
    "text": "getting you know off in the twos and threes that's a big difference in data and your query performance will slow",
    "start": "1264870",
    "end": "1270240"
  },
  {
    "text": "down so that's where you want to check distribution style all that is for",
    "start": "1270240",
    "end": "1277850"
  },
  {
    "text": "optimizing joint performance between your tables your usually your fact",
    "start": "1277850",
    "end": "1283950"
  },
  {
    "text": "tables and your dimension tables and as a rule of thumb it's safe to pick or to",
    "start": "1283950",
    "end": "1290970"
  },
  {
    "text": "set that distribution style on a table if it has three million rows or less there are cases when it can be more but",
    "start": "1290970",
    "end": "1298470"
  },
  {
    "text": "as a general rule of thumb three million rows or less is a good number as long as you're not there is one Cal",
    "start": "1298470",
    "end": "1305790"
  },
  {
    "text": "soak other thing is you're also not reading or writing frequently to that table because",
    "start": "1305790",
    "end": "1311920"
  },
  {
    "text": "obviously a right to that table means every note in the cluster is rewriting the same data if the two distribution",
    "start": "1311920",
    "end": "1319150"
  },
  {
    "text": "styles above don't apply key and all just use distribution style even or if",
    "start": "1319150",
    "end": "1324670"
  },
  {
    "text": "you're really not sure uses distribution style even as well it won't really do",
    "start": "1324670",
    "end": "1330340"
  },
  {
    "text": "the wrong thing it won't mock performance up you will get good performance using distribution style even think of the other two as ways to",
    "start": "1330340",
    "end": "1337480"
  },
  {
    "text": "optimize and make things better so this",
    "start": "1337480",
    "end": "1342790"
  },
  {
    "start": "1341000",
    "end": "1341000"
  },
  {
    "text": "is a sort of a summary a summary plus a few extra points the first point is to",
    "start": "1342790",
    "end": "1349840"
  },
  {
    "text": "materialise frequently queried columns into your fact table and what I mean by",
    "start": "1349840",
    "end": "1357400"
  },
  {
    "text": "this is a lot of times will end up having a dimension table and we join it",
    "start": "1357400",
    "end": "1362920"
  },
  {
    "text": "to the fact table and we end up filtering on that dimension table primarily and using the join to filter",
    "start": "1362920",
    "end": "1369640"
  },
  {
    "text": "on in our fact table this is typically done sometimes with time dimension",
    "start": "1369640",
    "end": "1375100"
  },
  {
    "text": "tables and the reason this I mean it works in redshift the reason it doesn't",
    "start": "1375100",
    "end": "1381640"
  },
  {
    "text": "perform as well is is that we're not able to leverage the zone maps as effectively on in your fact table and",
    "start": "1381640",
    "end": "1388900"
  },
  {
    "text": "reduce the i/o and your fact table so if you can if there is a column that you're typically filtering on materialize it",
    "start": "1388900",
    "end": "1396280"
  },
  {
    "text": "into your fact table and filter on it there it's a column or data warehouse so",
    "start": "1396280",
    "end": "1402550"
  },
  {
    "text": "adding a couple extra columns you know isn't going to reduce performance the next is is calculated values these are",
    "start": "1402550",
    "end": "1410320"
  },
  {
    "text": "ones where maybe you have a where clause and you're wrapping a column and a function you're extracting a value out",
    "start": "1410320",
    "end": "1415630"
  },
  {
    "text": "and then you that's part of your where clause if you can instead take that value and extract it out and write it",
    "start": "1415630",
    "end": "1422710"
  },
  {
    "text": "out into a column and actually query off that and then the zone maps can actually be used one that I do see that we",
    "start": "1422710",
    "end": "1433570"
  },
  {
    "text": "sometimes and unfortunately seen in some customer clusters when I'm helping customers troubleshoot performance",
    "start": "1433570",
    "end": "1439540"
  },
  {
    "text": "issues is temporal columns as a distribution key so think of these as like dates and",
    "start": "1439540",
    "end": "1446400"
  },
  {
    "text": "maybe the number of months in a year is a really bad example for again well it's a good example of how not to do this but",
    "start": "1446400",
    "end": "1454090"
  },
  {
    "text": "yeah say you know you only have 12 values for the months of the year that does not make a very good distribution",
    "start": "1454090",
    "end": "1459880"
  },
  {
    "text": "key because there's only 12 unique values to distribute the data across the cluster so as a rule of thumb I usually",
    "start": "1459880",
    "end": "1467170"
  },
  {
    "text": "just say simply avoid temporal values for distribution varchars chars numeric",
    "start": "1467170",
    "end": "1475990"
  },
  {
    "text": "they are you know data types where you can actually set the length of keep them as narrow as you can read shift does a",
    "start": "1475990",
    "end": "1483940"
  },
  {
    "text": "great job it will store them as efficiently if you declared a varchar' 1000 or varchar' 2 it's going to take up",
    "start": "1483940",
    "end": "1490120"
  },
  {
    "text": "the same amount of space however there's a little bit of query overhead we use up more memory in redshift if you make",
    "start": "1490120",
    "end": "1496690"
  },
  {
    "text": "those really large so if you have you know you're storing an abbreviation that's only a couple characters don't",
    "start": "1496690",
    "end": "1503740"
  },
  {
    "text": "declare it as a bar chart 1,000 declare it you know bar chart 2 or 5 or 10 or something small and you'll save memory",
    "start": "1503740",
    "end": "1511240"
  },
  {
    "text": "and your redshift cluster at query execution time the last two I did talk about that was the analyzed compression",
    "start": "1511240",
    "end": "1518560"
  },
  {
    "text": "command definitely run that and then also make sure sort keys are on the columns you primarily filter on so let's",
    "start": "1518560",
    "end": "1527260"
  },
  {
    "text": "move into data ingestion so the first",
    "start": "1527260",
    "end": "1532600"
  },
  {
    "start": "1530000",
    "end": "1530000"
  },
  {
    "text": "piece we're going to talk about is discs and redshift one thing that a lot of people don't realize is that we actually",
    "start": "1532600",
    "end": "1539500"
  },
  {
    "text": "are the discs are actually much bigger than what we give you they're actually two and a half to three times the size",
    "start": "1539500",
    "end": "1546640"
  },
  {
    "text": "and that's because the advertised space that we put on you know the pricing",
    "start": "1546640",
    "end": "1552220"
  },
  {
    "text": "pages and all that stuff is the space that you get to use to write your data",
    "start": "1552220",
    "end": "1558150"
  },
  {
    "text": "obviously we need a lot of other space we store mere redundant copies of data",
    "start": "1558150",
    "end": "1563650"
  },
  {
    "text": "which I'll talk about in another slide there's an operating system there's scratch space there's all sorts of stuff",
    "start": "1563650",
    "end": "1570430"
  },
  {
    "text": "like that and that's why the disks are significantly large the important thing is I guess if you're",
    "start": "1570430",
    "end": "1576940"
  },
  {
    "text": "comparing it maybe to an on-premise system and you have a data warehouse on site you know that's why our disks might seem",
    "start": "1576940",
    "end": "1584590"
  },
  {
    "text": "smaller than they are but they actually are quite large so moving on a data",
    "start": "1584590",
    "end": "1590320"
  },
  {
    "start": "1589000",
    "end": "1589000"
  },
  {
    "text": "redundancy which I I've talked a little bit about or mentioned we store two copies of the data in a redshift cluster",
    "start": "1590320",
    "end": "1597280"
  },
  {
    "text": "we typically call this the local and the remote but when a commit is it happens",
    "start": "1597280",
    "end": "1604450"
  },
  {
    "text": "or finishes in redshift your data has been safely written to two of the compute nodes with the exception of if",
    "start": "1604450",
    "end": "1612220"
  },
  {
    "text": "you're using temporary tables so temporary tables are very important to",
    "start": "1612220",
    "end": "1618130"
  },
  {
    "text": "use because they write twice as fast because they're skipping that second",
    "start": "1618130",
    "end": "1623530"
  },
  {
    "text": "copy so if you are doing things that are scratch space in nature and you don't",
    "start": "1623530",
    "end": "1629380"
  },
  {
    "text": "need to persist them use a temporary table they do write twice as fast also",
    "start": "1629380",
    "end": "1634870"
  },
  {
    "text": "we back data up asynchronously in redshift so this kicks off every five gigs of",
    "start": "1634870",
    "end": "1642160"
  },
  {
    "text": "changed data or eight hours which ever happens first you can also take a backup",
    "start": "1642160",
    "end": "1647890"
  },
  {
    "text": "at any time a manual snapshot as well which is a good thing to do if you're going to be making some drastic schema",
    "start": "1647890",
    "end": "1654670"
  },
  {
    "text": "changes for example you can also disable backups those backups test three on a",
    "start": "1654670",
    "end": "1661030"
  },
  {
    "text": "specific table there are some cases for that for transient tables that do need to be permanent and can't be temporary",
    "start": "1661030",
    "end": "1667810"
  },
  {
    "text": "tables so redshift is an acid compliant",
    "start": "1667810",
    "end": "1674110"
  },
  {
    "start": "1670000",
    "end": "1670000"
  },
  {
    "text": "it's fully transactional data warehouse the isolation level we use in redshift is serializable you can try to change it",
    "start": "1674110",
    "end": "1682180"
  },
  {
    "text": "it'll say it did but it won't every transaction is serializable and redshift the there are two phases to our commit",
    "start": "1682180",
    "end": "1690370"
  },
  {
    "text": "there is a local commit which happens at the slice level and then there is a global commit that is basically the",
    "start": "1690370",
    "end": "1695830"
  },
  {
    "text": "coordination of all the slices in the cluster to make sure that everything is finished we commit statistics can",
    "start": "1695830",
    "end": "1704260"
  },
  {
    "text": "sometimes be important to take a look at this is a github script for the and that's because their redshift isn't",
    "start": "1704260",
    "end": "1711160"
  },
  {
    "text": "a transactional database it's meant for data warehousing not high-throughput of",
    "start": "1711160",
    "end": "1716170"
  },
  {
    "text": "transactions the one design consideration I'll sometimes or issue",
    "start": "1716170",
    "end": "1721540"
  },
  {
    "text": "I'll see some customers kind of do is they'll have a workflow that's creating a ton of tables and maybe loading little",
    "start": "1721540",
    "end": "1728770"
  },
  {
    "text": "things and they don't wrap that workflow in a transaction and what ends up",
    "start": "1728770",
    "end": "1735610"
  },
  {
    "text": "happening is is a lot of times you'll be running with implicit transactions turned on or something like that with you know your client tools and you'll",
    "start": "1735610",
    "end": "1742900"
  },
  {
    "text": "end up having a ton of transactions and it's a really easy fix just wrap the workflow in a transaction chances are",
    "start": "1742900",
    "end": "1749440"
  },
  {
    "text": "you probably want it in a transaction anyways because if it fails halfway through you don't want it half done so",
    "start": "1749440",
    "end": "1756100"
  },
  {
    "text": "pretty easy fix and it's probably the right thing to do so let's talk about",
    "start": "1756100",
    "end": "1762490"
  },
  {
    "start": "1761000",
    "end": "1761000"
  },
  {
    "text": "how you actually get data into a redshift cluster the primary way of doing that is with a copy statement the",
    "start": "1762490",
    "end": "1769210"
  },
  {
    "text": "copy statement works primarily against s3 that's how most customers will load data and in this example here I have one",
    "start": "1769210",
    "end": "1777700"
  },
  {
    "text": "of our dense compute it to eight Excel clusters it has 16 slices and we have a",
    "start": "1777700",
    "end": "1783490"
  },
  {
    "text": "single file we'll just say that file is one gig file and what would happen is is if we executed a copy statement and",
    "start": "1783490",
    "end": "1791350"
  },
  {
    "text": "loaded just that single file in a redshift what's going to end up happening is the first slice in the",
    "start": "1791350",
    "end": "1797260"
  },
  {
    "text": "cluster is going to reach out grab that file download it's gonna you know parse it and do all the work it needs to to",
    "start": "1797260",
    "end": "1803620"
  },
  {
    "text": "get it to the rest of the slices and it's not really going to run that fast if however we took that same 1 gig file",
    "start": "1803620",
    "end": "1810940"
  },
  {
    "text": "and we split it into 16 chunks because we have 16 slices what's gonna happen",
    "start": "1810940",
    "end": "1816880"
  },
  {
    "text": "here is this is gonna run 16 times faster and that's because every single slice in the cluster reached out to s3",
    "start": "1816880",
    "end": "1824200"
  },
  {
    "text": "all in parallel because there's a you know MPP share nothing architecture everything works on everything they're",
    "start": "1824200",
    "end": "1830260"
  },
  {
    "text": "all going to download that they're all going to parse that they're all going to distribute it and they're all going to write it across you know all the slices",
    "start": "1830260",
    "end": "1836590"
  },
  {
    "text": "in the cluster our recommendation here on these files is ID they should hopefully be one Meg in size",
    "start": "1836590",
    "end": "1844150"
  },
  {
    "text": "or larger no larger than one gig after gzip compression few more best practices",
    "start": "1844150",
    "end": "1854770"
  },
  {
    "start": "1853000",
    "end": "1853000"
  },
  {
    "text": "on copying data I recommend using delimited files yes we support Avro yes",
    "start": "1854770",
    "end": "1861640"
  },
  {
    "text": "we support JSON and fixed-width format",
    "start": "1861640",
    "end": "1867270"
  },
  {
    "text": "delimited files are easy to work with they're also very fast in redshift they were pretty much the fastest file type",
    "start": "1867270",
    "end": "1874270"
  },
  {
    "text": "we have to load I always recommend picking a simple delimiter you know pipe or comma or whatever tabs don't pick",
    "start": "1874270",
    "end": "1882550"
  },
  {
    "text": "some crazy utf-8 character seeing that happen it UK you can make it work but",
    "start": "1882550",
    "end": "1888640"
  },
  {
    "text": "it's it'll make your life a little bit more difficult pick a simple null character use a carriage return as your",
    "start": "1888640",
    "end": "1896080"
  },
  {
    "text": "end of line character things like that few copy options that if you haven't",
    "start": "1896080",
    "end": "1902620"
  },
  {
    "text": "used redshift before and this is you know for the few of you that put up your hands the max errors can be a useful",
    "start": "1902620",
    "end": "1909520"
  },
  {
    "text": "option if you're just getting POC data in it'll drop records except in varchars",
    "start": "1909520",
    "end": "1914620"
  },
  {
    "text": "if you have invalid utf-8 characters in your CSVs so just a couple of handful of",
    "start": "1914620",
    "end": "1920740"
  },
  {
    "text": "useful options so what about with spectrum so spectrum allows you to",
    "start": "1920740",
    "end": "1929670"
  },
  {
    "start": "1923000",
    "end": "1923000"
  },
  {
    "text": "create an external table against s3 so",
    "start": "1929670",
    "end": "1935860"
  },
  {
    "text": "you can query that external table with a select statement you can also do an",
    "start": "1935860",
    "end": "1941710"
  },
  {
    "text": "insert into and a select from those external tables this if you say have a",
    "start": "1941710",
    "end": "1947350"
  },
  {
    "text": "data Lake and you have you know files in your data Lake which will probably be in Parque ror see you can load those",
    "start": "1947350",
    "end": "1954690"
  },
  {
    "text": "directly into redshift threw spectrum another cool thing you can do is you can",
    "start": "1954690",
    "end": "1961360"
  },
  {
    "text": "aggregate data as it's coming in you can select a sub set of columns or transform",
    "start": "1961360",
    "end": "1967270"
  },
  {
    "text": "the data with scalars and various other things so you get a little bit more flexibility on the incoming data that's",
    "start": "1967270",
    "end": "1974110"
  },
  {
    "text": "coming into your cluster if you you spectrum another thing that spectrum",
    "start": "1974110",
    "end": "1979359"
  },
  {
    "text": "does is you it also offloads some of the workload out of your",
    "start": "1979359",
    "end": "1984609"
  },
  {
    "text": "redshift cluster so typically you want your cluster available for querying",
    "start": "1984609",
    "end": "1990009"
  },
  {
    "text": "servicing reports and such if you use spectrum for this you have more",
    "start": "1990009",
    "end": "1996489"
  },
  {
    "text": "resources available because that you're employing that second cluster so",
    "start": "1996489",
    "end": "2004369"
  },
  {
    "start": "2003000",
    "end": "2003000"
  },
  {
    "text": "redshift is you know it's petabyte scale data warehouse it is designed for large",
    "start": "2004369",
    "end": "2010710"
  },
  {
    "text": "writes we talked about those one Meg chunks which I mentioned were immutable",
    "start": "2010710",
    "end": "2017809"
  },
  {
    "text": "if for example you come along and you write some insert statement just a single line and I do it all the time you",
    "start": "2017809",
    "end": "2024210"
  },
  {
    "text": "know I'll be in my client and I'll be writing test data in and I add some row to a table we don't ever want to",
    "start": "2024210",
    "end": "2030989"
  },
  {
    "text": "fragment the blocks those one Meg chunks and redshift so what we actually do is",
    "start": "2030989",
    "end": "2036330"
  },
  {
    "text": "is we pick up the last block in each column we clone it we read it we then",
    "start": "2036330",
    "end": "2042330"
  },
  {
    "text": "stuff that new record into that block we rewrite it back to disk we throw away",
    "start": "2042330",
    "end": "2048059"
  },
  {
    "text": "the last block that was at the end of the column and that becomes the new block if you think about it that's a lot",
    "start": "2048059",
    "end": "2054628"
  },
  {
    "text": "of work 1 Meg reading a 1 Meg chunk and rewriting a 1 Meg chunk for every single column in the cluster for that that's",
    "start": "2054629",
    "end": "2062010"
  },
  {
    "text": "just not you know a red shift can do it it will work but it's not what it's optimized for and that's why I will",
    "start": "2062010",
    "end": "2067829"
  },
  {
    "text": "sometimes say that a small write will cost roughly the same expense is writing",
    "start": "2067829",
    "end": "2073319"
  },
  {
    "text": "a hundred thousand or more rows to redshift so redshift really is designed",
    "start": "2073319",
    "end": "2078720"
  },
  {
    "text": "around kind of batch bulk loading updates and deletes a delete we just",
    "start": "2078720",
    "end": "2087089"
  },
  {
    "text": "mark the data as deleted we don't actually delete it when you actually execute a delete statement so that's why",
    "start": "2087089",
    "end": "2093329"
  },
  {
    "text": "it deletes kind of seemed fast that's also redshift uses MVCC which is",
    "start": "2093329",
    "end": "2099420"
  },
  {
    "text": "multi-version concurrency control and that's why if you have a transaction running you will continue to see data",
    "start": "2099420",
    "end": "2104940"
  },
  {
    "text": "exactly how it was when your transaction started",
    "start": "2104940",
    "end": "2109520"
  },
  {
    "text": "updates are essentially just a delete in an insert and redshift so let's talk a",
    "start": "2110180",
    "end": "2118350"
  },
  {
    "start": "2117000",
    "end": "2117000"
  },
  {
    "text": "little bit about a workflow it's very common and I get this this is one of the",
    "start": "2118350",
    "end": "2124020"
  },
  {
    "text": "most commonly asked things that I have customers ask me so I really want to make sure to get this in here and that's",
    "start": "2124020",
    "end": "2129360"
  },
  {
    "text": "how do you do an up cert and logic are in redshift here how's this logic work so we have those four rows for say and",
    "start": "2129360",
    "end": "2136260"
  },
  {
    "text": "four rows have been working all night and we have a CSV table here our CSV",
    "start": "2136260",
    "end": "2142320"
  },
  {
    "text": "file sitting on s3 and we have these four rows in it and we want to update that one we want to update that one and",
    "start": "2142320",
    "end": "2148740"
  },
  {
    "text": "we have two more rows that we want to add to the end of the table how do you do that in redshift so the workflow is",
    "start": "2148740",
    "end": "2157500"
  },
  {
    "text": "we want to load that data that CSV file into a staging table and then what we",
    "start": "2157500",
    "end": "2163110"
  },
  {
    "text": "want to do is is we want to delete from the production table all of the data",
    "start": "2163110",
    "end": "2168570"
  },
  {
    "text": "that matches the staging table and then what we're going to do is we're going to insert all of the data over into the",
    "start": "2168570",
    "end": "2176760"
  },
  {
    "text": "production table so how does that work the first thing we're going to do is we're going to create a transaction the",
    "start": "2176760",
    "end": "2185100"
  },
  {
    "text": "reason why is we want to reduce the number of transactions and redshift we talked about that but is very important the next is we're gonna create the",
    "start": "2185100",
    "end": "2192900"
  },
  {
    "text": "staging table and it's going to be a temporary table the next is is the like",
    "start": "2192900",
    "end": "2198120"
  },
  {
    "text": "clause or the like statement or keyword is going to pull over the distribution",
    "start": "2198120",
    "end": "2203220"
  },
  {
    "text": "key from the production table to make the right copy faster from the one table",
    "start": "2203220",
    "end": "2209760"
  },
  {
    "text": "to the other it also has the consequence of pulling over or the good consequence",
    "start": "2209760",
    "end": "2214800"
  },
  {
    "text": "is none of the consequence of getting the compression settings from the production table as well which is really",
    "start": "2214800",
    "end": "2221610"
  },
  {
    "text": "important and that's because when we execute this copy statement we load the",
    "start": "2221610",
    "end": "2227370"
  },
  {
    "text": "data in you'll notice I have comp update off there what'll happen here is is",
    "start": "2227370",
    "end": "2233280"
  },
  {
    "text": "we're telling redshift hey don't try and do the right thing in this particular case which is figure out the compression",
    "start": "2233280",
    "end": "2238410"
  },
  {
    "text": "for me I know this you know I don't want you to do that and the reason why is typically",
    "start": "2238410",
    "end": "2246130"
  },
  {
    "text": "this is going to be run repeatedly over and over again maybe every 5-10 minutes and we don't want to have red ship figuring out the compression over and",
    "start": "2246130",
    "end": "2253090"
  },
  {
    "text": "over again every five minutes on the exact same table so that's why we copied it over then what we're going to do is",
    "start": "2253090",
    "end": "2262450"
  },
  {
    "text": "we are going to delete from the deep dive table all of the rows that match",
    "start": "2262450",
    "end": "2267940"
  },
  {
    "text": "that staging table and then we can just safely insert all the rows over drop the",
    "start": "2267940",
    "end": "2273370"
  },
  {
    "text": "staging table and commit the transaction so this is the best way to do this logic",
    "start": "2273370",
    "end": "2283050"
  },
  {
    "start": "2285000",
    "end": "2285000"
  },
  {
    "text": "so to kind of summarize the best practices on yell tea make sure you wrap",
    "start": "2286500",
    "end": "2291580"
  },
  {
    "text": "your workflows all in a commit or a transaction explicitly create a transaction if you are going to be doing",
    "start": "2291580",
    "end": "2299980"
  },
  {
    "text": "deletes try to use drop tables or truncates instead they won't leave",
    "start": "2299980",
    "end": "2305440"
  },
  {
    "text": "behind kind of ghost rows phantom rows which need to be vacuumed up which we'll talk about in the next slide if you're",
    "start": "2305440",
    "end": "2312040"
  },
  {
    "text": "using staging tables which at some point I'm sure you will be try to use a temporary table if you can't they write",
    "start": "2312040",
    "end": "2317260"
  },
  {
    "text": "twice as fast if you do need to use a permanent table consider turning off backups so that the data is not being",
    "start": "2317260",
    "end": "2323980"
  },
  {
    "text": "synced to s3 keep the same disk keys on both tables for faster performance the",
    "start": "2323980",
    "end": "2330670"
  },
  {
    "text": "compression setting the compression to off or making sure your table actually",
    "start": "2330670",
    "end": "2335860"
  },
  {
    "text": "has compression settings baked in the symptom you will see in your redshift cluster if you are figuring out the",
    "start": "2335860",
    "end": "2343510"
  },
  {
    "text": "compression over and over again and I have a lot of customers who you know I'll be talking and they'll be like yeah my cluster runs at 80% CPU usage all the",
    "start": "2343510",
    "end": "2351400"
  },
  {
    "text": "time and it's because their clusters figuring out compression for all these tables over and over again that's the",
    "start": "2351400",
    "end": "2357130"
  },
  {
    "text": "symptom you'll see is really high CPU usage that you know it doesn't really make sense you just have a couple of",
    "start": "2357130",
    "end": "2362350"
  },
  {
    "text": "copy statements running and the last one",
    "start": "2362350",
    "end": "2367450"
  },
  {
    "text": "yeah make sure you move all the rows over we do also have a command called",
    "start": "2367450",
    "end": "2372640"
  },
  {
    "text": "alter table append it essentially a moove operation it's a little-known feature in redshift not too",
    "start": "2372640",
    "end": "2378650"
  },
  {
    "text": "many people know about it and it essentially moves data from one table to another it's a really good operation to",
    "start": "2378650",
    "end": "2387679"
  },
  {
    "text": "use if you're moving large amounts of records if you're not moving a large number of records it's just like a small",
    "start": "2387679",
    "end": "2393799"
  },
  {
    "text": "small number meant like low millions just do an insert select so let's talk",
    "start": "2393799",
    "end": "2401809"
  },
  {
    "start": "2400000",
    "end": "2400000"
  },
  {
    "text": "about vacuum and analyze vacuum serves two functions in redshift one is to",
    "start": "2401809",
    "end": "2409099"
  },
  {
    "text": "remove the ghost records or the deleted records out of redshift that's the first thing that it does the second thing it",
    "start": "2409099",
    "end": "2416179"
  },
  {
    "text": "also does is it globally sorts the table in redshift so when a copy or any insert",
    "start": "2416179",
    "end": "2424099"
  },
  {
    "text": "select statement for that matter execute sin redshift and that batch of new rows comes in we will sort that batch of",
    "start": "2424099",
    "end": "2431900"
  },
  {
    "text": "incoming rows locally to that batch and it's written to the end of the table but",
    "start": "2431900",
    "end": "2438289"
  },
  {
    "text": "that doesn't mean the table is globally sorted so that's when vacuum needs to run that's also why sometimes customers",
    "start": "2438289",
    "end": "2445039"
  },
  {
    "text": "will maybe their tables maybe say that they're unsorted if you have a single sort key and that happens to be a",
    "start": "2445039",
    "end": "2450920"
  },
  {
    "text": "timestamp for example you probably don't need to run vacuum if you're loading data essentially in sorted order and",
    "start": "2450920",
    "end": "2457819"
  },
  {
    "text": "that's because we're locally sorting and the table kind of ends up being globally sorted as a result the next piece is the",
    "start": "2457819",
    "end": "2465289"
  },
  {
    "text": "analyze command also very important what that does is or what it's for is is for",
    "start": "2465289",
    "end": "2470599"
  },
  {
    "text": "collecting statistics on the tables in your redshift cluster so this is for the",
    "start": "2470599",
    "end": "2477650"
  },
  {
    "text": "query planner so it can pick optimal plans I'd say most customers run vacuum or and",
    "start": "2477650",
    "end": "2485900"
  },
  {
    "text": "analyze nightly is kind of a typical thing it really only needs to be run as frequently as it needs to be but that is",
    "start": "2485900",
    "end": "2492769"
  },
  {
    "text": "pretty common especially if you have a little bit of downtime in the evening some customers only run it vacuum",
    "start": "2492769",
    "end": "2499279"
  },
  {
    "text": "particularly weekly for example and we do have a really good utility here on",
    "start": "2499279",
    "end": "2505489"
  },
  {
    "text": "github a lot of customers take utility it's a Python script essentially and it will vacuum and analyze your",
    "start": "2505489",
    "end": "2511710"
  },
  {
    "text": "entire table so that's usually what I recommend doing grab that utility and vacuum and analyze on a you know some",
    "start": "2511710",
    "end": "2519240"
  },
  {
    "text": "sort of cadence that make sense if you are changing and you have a table that's changing very frequently and maybe your",
    "start": "2519240",
    "end": "2527430"
  },
  {
    "text": "query plans aren't always coming out the way you want one thing that we will recommend is also to run the analyze",
    "start": "2527430",
    "end": "2533970"
  },
  {
    "text": "command just on the columns that your predicate sauron so if you're filtering on a column you can run analyze all the",
    "start": "2533970",
    "end": "2541710"
  },
  {
    "text": "way down to just a subset of columns and so some of our some customers will end up at recommending for them to put that",
    "start": "2541710",
    "end": "2548670"
  },
  {
    "text": "into their load cycle so if say you're loading on like a five-minute cadence or something and the data is continually",
    "start": "2548670",
    "end": "2555180"
  },
  {
    "text": "changing and thrashing about run analyze after that load just on those columns so",
    "start": "2555180",
    "end": "2564000"
  },
  {
    "text": "let's move into node types cluster sizing we have two different node types",
    "start": "2564000",
    "end": "2569370"
  },
  {
    "start": "2567000",
    "end": "2567000"
  },
  {
    "text": "in red shift our dense compute two and our dense storage two technically there was obviously a first generation of both",
    "start": "2569370",
    "end": "2576000"
  },
  {
    "text": "of those but we are on to the new generation of both of those the main",
    "start": "2576000",
    "end": "2581070"
  },
  {
    "text": "difference between these two platforms is one is solid state and one is magnetic disks so they obviously",
    "start": "2581070",
    "end": "2589140"
  },
  {
    "text": "slightly different pricing profiles the dense compute obviously perform quicker",
    "start": "2589140",
    "end": "2594450"
  },
  {
    "text": "and like I mentioned the dc2 we actually just released like two months ago so new",
    "start": "2594450",
    "end": "2600840"
  },
  {
    "text": "platform so cluster sizing production",
    "start": "2600840",
    "end": "2605910"
  },
  {
    "start": "2602000",
    "end": "2602000"
  },
  {
    "text": "workloads should ideally be run on a multi node cluster two nodes or more it",
    "start": "2605910",
    "end": "2613140"
  },
  {
    "text": "is we do allow what we call single node clusters and redshift those are",
    "start": "2613140",
    "end": "2618420"
  },
  {
    "text": "fantastic for POC playing around dev work QA work all that sort of stuff I",
    "start": "2618420",
    "end": "2624090"
  },
  {
    "text": "mean I run a single node cluster myself but you know if you're have a production",
    "start": "2624090",
    "end": "2629730"
  },
  {
    "text": "workload use a multi node cluster and that's because you get that mirrored",
    "start": "2629730",
    "end": "2634830"
  },
  {
    "text": "copy of the data for safety the other thing is is we give you the leader node",
    "start": "2634830",
    "end": "2641850"
  },
  {
    "text": "no additional cost so as soon as you hit a two node cluster you technically get a",
    "start": "2641850",
    "end": "2647220"
  },
  {
    "text": "third node for no extra cost and that extra node actually does do you know",
    "start": "2647220",
    "end": "2653760"
  },
  {
    "text": "some of the work it does all that query coordinating and final aggregation and such the other I really hope that",
    "start": "2653760",
    "end": "2660570"
  },
  {
    "text": "there's no one here but if that has this but if you have a redshift cluster that is still running an ec2 classic please",
    "start": "2660570",
    "end": "2668430"
  },
  {
    "text": "move it out into a V PC there is no downside to doing this and we're",
    "start": "2668430",
    "end": "2673650"
  },
  {
    "text": "typically seen around a 2x across-the-board improvement on queries",
    "start": "2673650",
    "end": "2678840"
  },
  {
    "text": "just by moving from ec2 classic to V PC one customer I had they had a workload",
    "start": "2678840",
    "end": "2686070"
  },
  {
    "text": "that was it was their nightly ETL workload and they called and we're talking and they were like yeah our",
    "start": "2686070",
    "end": "2692280"
  },
  {
    "text": "nightly load is now a 17 and a half our nightly load which was unacceptable then",
    "start": "2692280",
    "end": "2698160"
  },
  {
    "text": "because it was rolling into their daytime business hours and querying and we looked at their cluster I was like",
    "start": "2698160",
    "end": "2703470"
  },
  {
    "text": "you know you're running an ec2 classic can you switch out to a V PC and they're not just that change alone their nightly",
    "start": "2703470",
    "end": "2710580"
  },
  {
    "text": "load one from 17 1/2 hours down to 4 so if you happen to be a straggler running",
    "start": "2710580",
    "end": "2716490"
  },
  {
    "text": "on ec2 classic definitely move to a V PC now the sizing piece in redshift really",
    "start": "2716490",
    "end": "2724140"
  },
  {
    "text": "how we recommend or how every customer when I first have a conversation with them and they ask how many nodes should I use",
    "start": "2724140",
    "end": "2732570"
  },
  {
    "text": "we look at how much data they have usually uncompressed we assume about a",
    "start": "2732570",
    "end": "2738750"
  },
  {
    "text": "three times compression ratio that's you know safe rule of thumb or you know generalization if you're applying",
    "start": "2738750",
    "end": "2744420"
  },
  {
    "text": "compression correctly and we obviously you know usually customers will know am",
    "start": "2744420",
    "end": "2749550"
  },
  {
    "text": "I going to go solid-state am I going to go magnetic disk and we size it for home",
    "start": "2749550",
    "end": "2756030"
  },
  {
    "text": "for the amount of data that they have you also want to obviously you want to leave maintain at least 20 percent of",
    "start": "2756030",
    "end": "2763230"
  },
  {
    "text": "free space or two and a half to three times the size of the largest table in",
    "start": "2763230",
    "end": "2769440"
  },
  {
    "text": "your cluster so for example if the largest table in the cluster is going to take up 10% of the cluster you",
    "start": "2769440",
    "end": "2775280"
  },
  {
    "text": "leave about 30% free space and that's so that that table can be properly vacuumed",
    "start": "2775280",
    "end": "2782500"
  },
  {
    "text": "the next piece is the DC one - DC - like",
    "start": "2783880",
    "end": "2789050"
  },
  {
    "text": "I said we just recently released DC - DC - most customers especially if you're",
    "start": "2789050",
    "end": "2795590"
  },
  {
    "text": "running on the 8 XL are seen around a 2x performance increase it's the same price",
    "start": "2795590",
    "end": "2801500"
  },
  {
    "text": "as the DC one so if you're not on our eyes you can move over very easily just",
    "start": "2801500",
    "end": "2809840"
  },
  {
    "text": "do a simple resize it's a few clicks in the console move from DC 1 to DC to get",
    "start": "2809840",
    "end": "2815390"
  },
  {
    "text": "the performance boost there's no cost if you have our eyes please contact us we",
    "start": "2815390",
    "end": "2821570"
  },
  {
    "text": "will work with you there are things we can do if you are looking to maybe potentially migrate your our eyes over",
    "start": "2821570",
    "end": "2828740"
  },
  {
    "text": "from DC 1 to DC - it's not a straight over migration but there are things that",
    "start": "2828740",
    "end": "2834260"
  },
  {
    "text": "we can do so you know reach out for with me after the presentation or contact support the last point is is that",
    "start": "2834260",
    "end": "2842050"
  },
  {
    "text": "spectrum queries if you are doing a POC and you're working with spectrum and this one kind of comes up a bit is",
    "start": "2842050",
    "end": "2848900"
  },
  {
    "text": "customers assume that you know spectrum performance will be exactly the same on a single node cluster a little tiny DC",
    "start": "2848900",
    "end": "2855710"
  },
  {
    "text": "one large as it will be on a large cluster it won't be performance in spectrum scales depending on how large",
    "start": "2855710",
    "end": "2863570"
  },
  {
    "text": "your redshift cluster is so we will provision up to 10 spectrum nodes per",
    "start": "2863570",
    "end": "2871580"
  },
  {
    "text": "slice in your redshift cluster for each query so there is a correlation between",
    "start": "2871580",
    "end": "2877040"
  },
  {
    "text": "the performance you get in spectrum and your redshift cluster so additional",
    "start": "2877040",
    "end": "2884090"
  },
  {
    "text": "resources I've talked lots about these github scripts that all of this stuff is on",
    "start": "2884090",
    "end": "2889190"
  },
  {
    "text": "github I'll just kind of walk through them quickly the admin's those are scripts that are solution",
    "start": "2889190",
    "end": "2896900"
  },
  {
    "text": "architect team the team that I'm on our database engineering team which is a part of the redshift team they're the",
    "start": "2896900",
    "end": "2902180"
  },
  {
    "text": "ones that you may interact with these are scripts that we've all found really useful when we're working with customers",
    "start": "2902180",
    "end": "2908530"
  },
  {
    "text": "diagnosing issues and that sort of thing and we put all those on github the same",
    "start": "2908530",
    "end": "2913630"
  },
  {
    "text": "with the administer very similar to the amends scripts but they end up being in views I've talked about the vacuum",
    "start": "2913630",
    "end": "2920110"
  },
  {
    "text": "utility and the column and coding utility those are also like I said on github you saw the links earlier so those",
    "start": "2920110",
    "end": "2926950"
  },
  {
    "text": "you'll find those there as well highly recommend checking those out a couple of",
    "start": "2926950",
    "end": "2932770"
  },
  {
    "text": "blog posts worth calling out these are I think are kind of the three are three top blog posts the top one there was",
    "start": "2932770",
    "end": "2939670"
  },
  {
    "text": "written by one of our database engineers it's a series of five blog posts that",
    "start": "2939670",
    "end": "2944860"
  },
  {
    "text": "goes through table design and how a lot of like sort keys and distribution keys",
    "start": "2944860",
    "end": "2950050"
  },
  {
    "text": "work I highly recommend checking that one out if you understand everything that he's written you should be in good",
    "start": "2950050",
    "end": "2956260"
  },
  {
    "text": "shape with red shift and then the top ten performance tuning techniques was kind of the theme for that was what are",
    "start": "2956260",
    "end": "2963640"
  },
  {
    "text": "the top ten things that we see kind of customers get hung up on when configuring a red shift cluster so that",
    "start": "2963640",
    "end": "2970570"
  },
  {
    "text": "one is totally work worth checking out and then the same kind of theme on the spectrum one I think we have about ten",
    "start": "2970570",
    "end": "2979870"
  },
  {
    "text": "minutes left so we can do Q&A",
    "start": "2979870",
    "end": "2984660"
  }
]