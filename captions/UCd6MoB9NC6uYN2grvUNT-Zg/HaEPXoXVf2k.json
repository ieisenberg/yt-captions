[
  {
    "start": "0",
    "end": "40000"
  },
  {
    "text": "my name is Rick Houlihan I am a principal technologist for no SQL at AWS that means I do a lot of dynamodb work",
    "start": "30",
    "end": "7379"
  },
  {
    "text": "although I work across technology stacks I do a lot of MongoDB and Cassandra as well most the design patterns I'm gonna",
    "start": "7379",
    "end": "13500"
  },
  {
    "text": "be talking to you about today actually apply to all no SQL databases they're going to be presented in the form of a",
    "start": "13500",
    "end": "19320"
  },
  {
    "text": "wide column key value store which is what DynamoDB is if anyone's interested in figuring out how to apply those",
    "start": "19320",
    "end": "24900"
  },
  {
    "text": "design patterns to MongoDB track me down after the session I'll show you how to do this in the document store as well",
    "start": "24900",
    "end": "30060"
  },
  {
    "text": "I've idea that's a lot and one of the big messages I like people take away is there's really not a lot of difference",
    "start": "30060",
    "end": "35489"
  },
  {
    "text": "between the various technology platforms and the design patterns pretty much apply across the board so we're going to",
    "start": "35489",
    "end": "42780"
  },
  {
    "start": "40000",
    "end": "161000"
  },
  {
    "text": "talk about today I always like to talk about brief history of data processing to kind of set the tone the mindset for why why are we even looking at no SQL",
    "start": "42780",
    "end": "49559"
  },
  {
    "text": "and it's pretty important that we understand this because we've had this great technology for many decades this relational database it seems to do",
    "start": "49559",
    "end": "55860"
  },
  {
    "text": "everything so why would I spend my time learning this new technology which is so",
    "start": "55860",
    "end": "60930"
  },
  {
    "text": "seems to be so alien compared to what I know already we'll talk a little bit about that well getting into an overview",
    "start": "60930",
    "end": "66780"
  },
  {
    "text": "of DynamoDB I'm not gonna spend a lot of time on this is a 300 level session so it's going to be you know a very brief",
    "start": "66780",
    "end": "72900"
  },
  {
    "text": "overview of the no SQL a service offering we call dynamodb and then we'll",
    "start": "72900",
    "end": "78930"
  },
  {
    "text": "get really into the meat of the discussion today is gonna be about no SQL data modeling and we'll talk about",
    "start": "78930",
    "end": "85229"
  },
  {
    "text": "normalized versus D normalized schema and what that really means and how do we build data structures into a no SQL",
    "start": "85229",
    "end": "92009"
  },
  {
    "text": "database like dynamodb and then I'm gonna get into some of the common design patterns now historically or in",
    "start": "92009",
    "end": "98130"
  },
  {
    "text": "throughout the last couple years I've really focused on basic use case design patterns with this time we're really",
    "start": "98130",
    "end": "103290"
  },
  {
    "text": "gonna go deep into relational modeling I'm going to focus on composite key structures for the most part we'll talk",
    "start": "103290",
    "end": "108630"
  },
  {
    "text": "about how to translate hierarchical data models how to translate relational data models into no SQL so this is really",
    "start": "108630",
    "end": "116040"
  },
  {
    "text": "going to be they represented a lot of the work that my team does which has been you know working with global",
    "start": "116040",
    "end": "121950"
  },
  {
    "text": "strategic accounts as well as our internal Amazon retail teams to migrate from",
    "start": "121950",
    "end": "127229"
  },
  {
    "text": "relational database application services into no SQL databases and we'll close",
    "start": "127229",
    "end": "133140"
  },
  {
    "text": "out with a real a quick discussion or about service and and and talk some about modeling real",
    "start": "133140",
    "end": "139470"
  },
  {
    "text": "applications and I'll give you an example of a real Amazon service as a service that we did with very complex",
    "start": "139470",
    "end": "145260"
  },
  {
    "text": "and a long list of access patterns so again first thing I like to talk about",
    "start": "145260",
    "end": "151320"
  },
  {
    "text": "is a history of data processing and I love this quote I don't know who said it but you know listen to and look at what",
    "start": "151320",
    "end": "159060"
  },
  {
    "text": "happened in the past so that we don't repeat the mistakes of the past and that's a lot of what this message is about so if you look at the timeline of",
    "start": "159060",
    "end": "165510"
  },
  {
    "start": "161000",
    "end": "350000"
  },
  {
    "text": "database technology it's really great comes down to a series of what I call peaks and valleys being data pressure",
    "start": "165510",
    "end": "170910"
  },
  {
    "text": "and data pressure is the ability of the system to process the amount of data that I'm asking it to process in a",
    "start": "170910",
    "end": "176430"
  },
  {
    "text": "reasonable cost or a reasonable time when one of those dimensions is broken that's a technology trigger and we",
    "start": "176430",
    "end": "182430"
  },
  {
    "text": "invent things and we've done a lot of that invention over the years so the first database we had was a really good one we're all born with it stuck between",
    "start": "182430",
    "end": "189209"
  },
  {
    "text": "your ears and highly available right when my eyes are open it's it's online",
    "start": "189209",
    "end": "194330"
  },
  {
    "text": "you know but maybe questionable durability about zero fault tolerance it's a single user system so pretty soon",
    "start": "194330",
    "end": "201390"
  },
  {
    "text": "we figured out that we actually need to do something better than that and so we started writing things down and we",
    "start": "201390",
    "end": "206400"
  },
  {
    "text": "developed a system of ledger accounting which is our first structured data store that we had and that ran public and",
    "start": "206400",
    "end": "213120"
  },
  {
    "text": "private sector applications for several millennia until 1880 u.s. census came",
    "start": "213120",
    "end": "218220"
  },
  {
    "text": "along and a guy named Herman Hollerith was tasked with collating and processing all the data that was collected now if",
    "start": "218220",
    "end": "224579"
  },
  {
    "text": "you're familiar with the US Census it runs every 10 years and it took mr. Hollerith and his team about eight of those ten years to process that data in",
    "start": "224579",
    "end": "230910"
  },
  {
    "text": "1880 and he figured out you needed to do something different so he invented the machine readable punch card in the punch card sorting machine and the era of",
    "start": "230910",
    "end": "237600"
  },
  {
    "text": "modern data processing was born as well as a small little company called IBM which has a large and long and storied",
    "start": "237600",
    "end": "243690"
  },
  {
    "text": "history on database technology so rapidly we developed many technologies as public and private sector",
    "start": "243690",
    "end": "250799"
  },
  {
    "text": "applications started to consume these new technologies and and produce applications that required more and more",
    "start": "250799",
    "end": "256739"
  },
  {
    "text": "and more data so paper tape magnetic tape distributed block storage random access file systems and Along Came 1970",
    "start": "256739",
    "end": "264240"
  },
  {
    "text": "or so the relational database and it's important to understand why we built the relational database and we did",
    "start": "264240",
    "end": "269719"
  },
  {
    "text": "it because storage was expensive extremely expensive in the mid-80s I was at Macworld in Moscone Center in San",
    "start": "269719",
    "end": "276590"
  },
  {
    "text": "Francisco I was walking through the Convention Center and I saw in the middle of the conference room floor there was a truck transmission and I was",
    "start": "276590",
    "end": "282889"
  },
  {
    "text": "like why is there a truck transmission in the middle of maybe there was an RV show or something they couldn't get it out of there and I walked over to look at it really",
    "start": "282889",
    "end": "288590"
  },
  {
    "text": "wasn't a truck transmission it was a hard drive from 1974 it was cross section it was really cool-looking but",
    "start": "288590",
    "end": "294620"
  },
  {
    "text": "it had a sticker on it said four megabytes and MSRP $250,000 that's",
    "start": "294620",
    "end": "301279"
  },
  {
    "text": "that's pretty expensive and now obviously we didn't use a lot magnetic disk in 1974 but the point is that",
    "start": "301279",
    "end": "307340"
  },
  {
    "text": "storage was extremely expensive so normalizing the data right reducing the footprint of that data on disk was",
    "start": "307340",
    "end": "313129"
  },
  {
    "text": "extremely important and that's what we did then the relational data store is a wonderful way to reduce the storage cost",
    "start": "313129",
    "end": "320180"
  },
  {
    "text": "of your application and what does it do it increases the CPU costs because the complex queries it must execute to",
    "start": "320180",
    "end": "326659"
  },
  {
    "text": "produce the denormalized views of data that your application consumes right joining tables it's extremely expensive",
    "start": "326659",
    "end": "332240"
  },
  {
    "text": "so now fast-forward 30 40 years and the most expensive resource in the data center is actually the CPU right it's",
    "start": "332240",
    "end": "338569"
  },
  {
    "text": "not the storage so why would I want to use the technology that's optimizing the least expensive resource in the data",
    "start": "338569",
    "end": "343909"
  },
  {
    "text": "center and this is really why we're looking at no SQL today right because we want to do things more cost-effectively",
    "start": "343909",
    "end": "350389"
  },
  {
    "start": "350000",
    "end": "462000"
  },
  {
    "text": "and and more easier on the wallet so to speak so when we use new technologies",
    "start": "350389",
    "end": "357400"
  },
  {
    "text": "it's important to understand how to use them before we use them most of the teams that I work with actually kind of",
    "start": "357400",
    "end": "364669"
  },
  {
    "text": "fail this test they they kind of take their relational design patterns they deploy multi tables you know",
    "start": "364669",
    "end": "370520"
  },
  {
    "text": "implementations normalized data models in know SQL and then they wonder why is it not working it's it's so terrible and",
    "start": "370520",
    "end": "376189"
  },
  {
    "text": "it's really due to this effect so if you look at the bottom this is the technology adoption curve we're all very",
    "start": "376189",
    "end": "382189"
  },
  {
    "text": "familiar with this in the beginning we have innovators running around solving a problem a technology trigger has",
    "start": "382189",
    "end": "388490"
  },
  {
    "text": "occurred right the data pressure is too high in the system we need something that's going to be able to process this",
    "start": "388490",
    "end": "393500"
  },
  {
    "text": "data a little bit more efficiently they land on a solution in this case we're talking about no sq technology they have that a few people",
    "start": "393500",
    "end": "400120"
  },
  {
    "text": "have some really good results and the rest of the market starts to move there and as people start to deploy the new",
    "start": "400120",
    "end": "405580"
  },
  {
    "text": "technology they realize it doesn't work right not for them their use case is different the other people must be doing",
    "start": "405580",
    "end": "411820"
  },
  {
    "text": "something or having a different application the reality is no that you're probably just using the",
    "start": "411820",
    "end": "416860"
  },
  {
    "text": "technology the same way you use the old technology and typically new technology doesn't work the same way so if you actually learn how to use it first",
    "start": "416860",
    "end": "423370"
  },
  {
    "text": "you'll have a better result and so if you look at the bottom chart the relational technology that's way out on",
    "start": "423370",
    "end": "428979"
  },
  {
    "text": "the right-hand side the laggards right if you don't understand what a join is today then you've been living in a cave",
    "start": "428979",
    "end": "434229"
  },
  {
    "text": "for thirty years and I can't help you right but if you don't know how to build a denormalized data model well that's",
    "start": "434229",
    "end": "440500"
  },
  {
    "text": "fully understandable because no SQL technology is over on the left-hand side right that's where the innovators are",
    "start": "440500",
    "end": "446440"
  },
  {
    "text": "still operating we're still in that technology gap people are still trying to understand this new technology so if",
    "start": "446440",
    "end": "451750"
  },
  {
    "text": "you take the time to actually learn how to model your data correctly in a no SQL",
    "start": "451750",
    "end": "457000"
  },
  {
    "text": "database you're gonna have a much better result and so that's what we're gonna talk about today how do I actually model the data before we get there it's",
    "start": "457000",
    "end": "464229"
  },
  {
    "text": "important to understand that you know this relational database that we've been using for 30 or 40 years well it still has a very good place in the modern",
    "start": "464229",
    "end": "470949"
  },
  {
    "text": "application you know development environment and that really comes down to what types of access patterns are we",
    "start": "470949",
    "end": "477460"
  },
  {
    "text": "trying to deal with with this application service are they well-known and well-understood then maybe that's a perfect database or",
    "start": "477460",
    "end": "485740"
  },
  {
    "text": "a perfect application for a no SQL database right where I have I have to",
    "start": "485740",
    "end": "491889"
  },
  {
    "text": "actually structure the data specifically to support the given access pattern and that's how come no SQL data is if",
    "start": "491889",
    "end": "497710"
  },
  {
    "text": "databases can be more efficient but if I have the need to support ad-hoc queries all right maybe a bi analytics use case",
    "start": "497710",
    "end": "503919"
  },
  {
    "text": "an OLAP style application that might not be the best application for no SQL because no SQL databases aren't really",
    "start": "503919",
    "end": "510190"
  },
  {
    "text": "good at reshaping the data right they like simple query select star from they don't like complex queries you know",
    "start": "510190",
    "end": "516070"
  },
  {
    "text": "inner joins and calculate values and these types of things know SQL databases are not very good at that so if you",
    "start": "516070",
    "end": "522669"
  },
  {
    "text": "that's when it really breaks down to the OLTP application is a excellent application for no SQL databases and",
    "start": "522669",
    "end": "529480"
  },
  {
    "text": "good for us that's 90 percent applications we build because they represent very common business processes I want to go to amazon.com and I order",
    "start": "529480",
    "end": "537290"
  },
  {
    "text": "you know and I hit the order button the same thing happens every time and that's really the crux of when it when it when",
    "start": "537290",
    "end": "544410"
  },
  {
    "text": "is it a good decision to use a no SQL database if I understand the access patterns very well they're repeatable",
    "start": "544410",
    "end": "550410"
  },
  {
    "text": "they're consistent then that's when we go to know SQL if not then let's look at the SQL database right so it's not",
    "start": "550410",
    "end": "556560"
  },
  {
    "text": "obsolete and it's just now we have a different choice the Amazon DynamoDB is",
    "start": "556560",
    "end": "563069"
  },
  {
    "start": "560000",
    "end": "741000"
  },
  {
    "text": "a fully managed NoSQL database how many people in the room have actually run no SQL databases at scale I'm talking like",
    "start": "563069",
    "end": "569279"
  },
  {
    "text": "50 or more nodes yeah not very many right when you get there you will",
    "start": "569279",
    "end": "576629"
  },
  {
    "text": "realize that managed services are really cool and most of the customers I work",
    "start": "576629",
    "end": "581939"
  },
  {
    "text": "with have scaled out the Cassandra clusters they scaled out their MongoDB clusters and oftentimes I'll work with",
    "start": "581939",
    "end": "588329"
  },
  {
    "text": "them to kind of correct whatever mistakes they made in their data models to get a little bit more life out of that cluster but sooner or later they're",
    "start": "588329",
    "end": "594720"
  },
  {
    "text": "gonna say you know it's too expensive it's hard to run this I don't want to manage it anymore I have a 724 knock",
    "start": "594720",
    "end": "601350"
  },
  {
    "text": "that I'm staffing you know 365 days a year to manage all of these this infrastructure whether it's running on",
    "start": "601350",
    "end": "607769"
  },
  {
    "text": "ec2 or on-premise irrelevant it's the same cost right server updates patching operating systems and and and and",
    "start": "607769",
    "end": "614610"
  },
  {
    "text": "software rebuilding storage devices failed nodes all these things nobody wants to do this that's not core to your",
    "start": "614610",
    "end": "620970"
  },
  {
    "text": "business so the fully managed aspect of no SQL database services is really the most powerful feature that you can you",
    "start": "620970",
    "end": "628680"
  },
  {
    "text": "can have it's a document or key value store what we really mean is it's kind of a wide column key value store that",
    "start": "628680",
    "end": "635040"
  },
  {
    "text": "supports a a document attribute type I'm going to talk a little bit about that later on and and really scales to any",
    "start": "635040",
    "end": "641370"
  },
  {
    "text": "workload is fast and consistent at any scale dynamodb has tables single tables running upwards of 4 million",
    "start": "641370",
    "end": "647550"
  },
  {
    "text": "transactions per second with low single-digit millisecond latency as a matter of fact one of the most",
    "start": "647550",
    "end": "653189"
  },
  {
    "text": "interesting characteristics of dynamo DB is the busier it gets the more consistent the low latency responses",
    "start": "653189",
    "end": "659279"
  },
  {
    "text": "become is because and that's because we have a fully distributed request router and as you start to hammer the request",
    "start": "659279",
    "end": "665160"
  },
  {
    "text": "for a dirty or more and more the the partition information of your know SQL table starts to get cached across the",
    "start": "665160",
    "end": "670710"
  },
  {
    "text": "front-end there's no more lookups on that configuration table so if you look at the services like snapchat when the",
    "start": "670710",
    "end": "678450"
  },
  {
    "text": "when the White Sox won the World Series they were peeking out at 3.5 million transactions per second or so and the",
    "start": "678450",
    "end": "684570"
  },
  {
    "text": "graph is just really interesting because the latency drops to a very flat low one to three millisecond range as they",
    "start": "684570",
    "end": "691140"
  },
  {
    "text": "approach their peak and fully fine-grained access control in DynamoDB",
    "start": "691140",
    "end": "696840"
  },
  {
    "text": "we can restrict the access to the items on the table to the table itself and to",
    "start": "696840",
    "end": "702750"
  },
  {
    "text": "the attributes within the item so if I have an application process that's running against a datastore that might have items that contain information I",
    "start": "702750",
    "end": "709680"
  },
  {
    "text": "don't want to have visible to my order entry clerks but maybe they have annotated data that's interesting like maybe sales",
    "start": "709680",
    "end": "715620"
  },
  {
    "text": "persons Commission data and whatnot that I want to have access to sales managers I can have those access patterns hit the",
    "start": "715620",
    "end": "723210"
  },
  {
    "text": "table with different I am security permissions which gives me a fine-grained access control over the",
    "start": "723210",
    "end": "728640"
  },
  {
    "text": "data and what people can read and then it's a backplane service which is really great when you talk about serverless",
    "start": "728640",
    "end": "734340"
  },
  {
    "text": "programming we're going to talk about that at the end of this and why is that really a big value to customers today so",
    "start": "734340",
    "end": "742500"
  },
  {
    "start": "741000",
    "end": "764000"
  },
  {
    "text": "dynamodb has tables like all databases the table and DynamoDB is more like a catalog in a relational database you're",
    "start": "742500",
    "end": "748590"
  },
  {
    "text": "going to put many many items into the table and the items in the table don't always have to have the same attributes",
    "start": "748590",
    "end": "753600"
  },
  {
    "text": "but they do have to have one attribute that uniquely identifies the item and that's the partition key so every",
    "start": "753600",
    "end": "759090"
  },
  {
    "text": "attribute I inserted into DynamoDB tea table must at least have a partition key attribute I can also contain I include",
    "start": "759090",
    "end": "764850"
  },
  {
    "start": "764000",
    "end": "829000"
  },
  {
    "text": "an optional sort key attribute and when I do this it gives me the ability to execute complex range queries against",
    "start": "764850",
    "end": "771390"
  },
  {
    "text": "the items that are in those partitions so you can think of the partition as now a folder or a bucket that contains items",
    "start": "771390",
    "end": "777660"
  },
  {
    "text": "and the sort key orders the items within that folder and so when I query those those partitions or those folders I can",
    "start": "777660",
    "end": "784680"
  },
  {
    "text": "execute those queries with complex range operators so in this example let's say I have a partition key might be a customer",
    "start": "784680",
    "end": "790710"
  },
  {
    "text": "ID and the store key might be the order date and I want the customer and the primary access pattern the app",
    "start": "790710",
    "end": "796110"
  },
  {
    "text": "give me all of the customer's orders in the last 24 hours and so I can say query the table where the partition key equals",
    "start": "796110",
    "end": "802649"
  },
  {
    "text": "customer ID X and the SAR key is greater than 24 hours ago that gives me a nice",
    "start": "802649",
    "end": "808880"
  },
  {
    "text": "filtered list of orders by customer over the last 24 hours so that's a really good way to maintain",
    "start": "808880",
    "end": "813899"
  },
  {
    "text": "that one-to-many relationship and you typically want to model the table to support one of your primary access",
    "start": "813899",
    "end": "819779"
  },
  {
    "text": "patterns and we get into the actual data modeling you'll see what I mean by that you always want that table to be able to",
    "start": "819779",
    "end": "826110"
  },
  {
    "text": "query something that is interesting to the application partition keys are used",
    "start": "826110",
    "end": "832380"
  },
  {
    "start": "829000",
    "end": "880000"
  },
  {
    "text": "to uniquely identify the item they're also used to distribute the items across the key space so every table in DynamoDB",
    "start": "832380",
    "end": "837660"
  },
  {
    "text": "represents a unique logical key space and we're going to distribute those items by taking that partition key",
    "start": "837660",
    "end": "843690"
  },
  {
    "text": "attribute and creating an unordered hash index and laying these items out across this virtual key space this is the way",
    "start": "843690",
    "end": "850079"
  },
  {
    "text": "all no SQL database is actually work and when we scale the database we're just gonna chop that key space up and spread",
    "start": "850079",
    "end": "856019"
  },
  {
    "text": "those items out across multiple physical storage devices so now when I query the system I'm going",
    "start": "856019",
    "end": "861990"
  },
  {
    "text": "to always provide that partition key is that equality condition so the system knows exactly which store is node to get",
    "start": "861990",
    "end": "867720"
  },
  {
    "text": "to to go read that data this is what makes all no SQL databases fast and consistent at any scale they there's",
    "start": "867720",
    "end": "874320"
  },
  {
    "text": "there's automatic routing of the query to the exact storage node that needs to be served to serve as the request when I",
    "start": "874320",
    "end": "880800"
  },
  {
    "start": "880000",
    "end": "908000"
  },
  {
    "text": "include the range key or the sort key in the table schema now when I query it",
    "start": "880800",
    "end": "887610"
  },
  {
    "text": "provide that a sort key condition I'm going to go into the partition selectively read the items that are",
    "start": "887610",
    "end": "893160"
  },
  {
    "text": "co-located on the same storage node and sorted using that sort key attribute and this is again this is how no SQL",
    "start": "893160",
    "end": "900000"
  },
  {
    "text": "databases maintain that fast consistent behavior this is not unique to DynamoDB all no SQL databases have this construct",
    "start": "900000",
    "end": "908300"
  },
  {
    "start": "908000",
    "end": "974000"
  },
  {
    "text": "partitions in DynamoDB are automatically 3-way replicated so I write two dynamodb you're going to get an acknowledgement",
    "start": "908300",
    "end": "914640"
  },
  {
    "text": "from the client when two of the replicas have received that right when you read",
    "start": "914640",
    "end": "921990"
  },
  {
    "text": "from DynamoDB then you have a choice between eventual consistency consistent reads and",
    "start": "921990",
    "end": "927459"
  },
  {
    "text": "typically it's up to you how to do that we recommend that you use the eventual consistent read because that three-way",
    "start": "927459",
    "end": "933009"
  },
  {
    "text": "replication the primary node to secondary is sub one millisecond so you're not all that eventually",
    "start": "933009",
    "end": "939939"
  },
  {
    "text": "consistent it's pretty much by the time your round trip back from the client the data is going to have replicated the secondaries eventually consistent reads",
    "start": "939939",
    "end": "945939"
  },
  {
    "text": "are half the costs of a strongly consistent read because we have more nodes to choose from when you make that",
    "start": "945939",
    "end": "951189"
  },
  {
    "text": "eventually consistent read I'm gonna randomly read from one of those three partitions if you make a strongly consistent read I'm gonna read from the",
    "start": "951189",
    "end": "957069"
  },
  {
    "text": "primary node primary node always accepts the right so you're gonna get a very consistent read on guaranteed strongly",
    "start": "957069",
    "end": "963040"
  },
  {
    "text": "consistent read off in the primary but it is twice the cost so a cheap way to double the capacity of your application",
    "start": "963040",
    "end": "969160"
  },
  {
    "text": "is to use EC reads they are on on by default so unless you change that parameter that's what's gonna happen",
    "start": "969160",
    "end": "975839"
  },
  {
    "start": "974000",
    "end": "1083000"
  },
  {
    "text": "local secondary indexes well we have two types of indexes in DynamoDB we have local secondary indexes and we have",
    "start": "975839",
    "end": "981579"
  },
  {
    "text": "global secondary indexes local secondary indexes allow you to resort the data in the partitions right so let's say in",
    "start": "981579",
    "end": "988059"
  },
  {
    "text": "this case I have a need to get all the backordered you know items for a customer my primary use case is the",
    "start": "988059",
    "end": "994990"
  },
  {
    "text": "primary table say order ID is the partition key sort key is the date but",
    "start": "994990",
    "end": "1000089"
  },
  {
    "text": "on my GSI or my LSI I'm going to create a partition key which is the same as the table which it must be which is the",
    "start": "1000089",
    "end": "1006839"
  },
  {
    "text": "customer ID and I'm going to resort the data using maybe order state right so now I can query the LSI and say give me",
    "start": "1006839",
    "end": "1013049"
  },
  {
    "text": "all the back ordered items for a customer and I can query the table and say give me all the orders for a",
    "start": "1013049",
    "end": "1018689"
  },
  {
    "text": "customer in the last 24 hours right so it's a different access pattern I'm gonna restore the data to support that access pattern but local secondary",
    "start": "1018689",
    "end": "1025980"
  },
  {
    "text": "indexes must always use the same partition key as the table so it's a way to resort the data but not regroup the",
    "start": "1025980",
    "end": "1031829"
  },
  {
    "text": "data the alternative is to use a GSI or global secondary index and global",
    "start": "1031829",
    "end": "1037409"
  },
  {
    "text": "secondary indexes allow me to create a completely new aggregation of the data so in the primary table which might",
    "start": "1037409",
    "end": "1042839"
  },
  {
    "text": "group the orders by customer maybe my global secondary index groups the orders by warehouse and I could say that my",
    "start": "1042839",
    "end": "1048990"
  },
  {
    "text": "partition key on the global secondary index would be warehouse ID and the store key would be order date now if I",
    "start": "1048990",
    "end": "1055980"
  },
  {
    "text": "need to get the orders for a given warehouse in the last hour I can query the yes I buy warehouse ID and with a sort",
    "start": "1055980",
    "end": "1061590"
  },
  {
    "text": "key operator saying greater than one hour ago that would give me everything for a given warehouse in last hours so",
    "start": "1061590",
    "end": "1067260"
  },
  {
    "text": "you're getting the idea what we're gonna end up doing as we model the data is we're gonna start to use these indexes",
    "start": "1067260",
    "end": "1072720"
  },
  {
    "text": "to regroup resource re-aggravate the data to support secondary access patterns right but using the same types",
    "start": "1072720",
    "end": "1078750"
  },
  {
    "text": "of key structures so be interesting when we get into the modeling we'll see some real worlds examples of how this works",
    "start": "1078750",
    "end": "1085040"
  },
  {
    "start": "1083000",
    "end": "1136000"
  },
  {
    "text": "GSI updates are eventually consistent l sis are strongly consistent so something",
    "start": "1085040",
    "end": "1091110"
  },
  {
    "text": "to remember when you're working with these GSI scan when you make the update to the GSI you're going to be get the",
    "start": "1091110",
    "end": "1097410"
  },
  {
    "text": "acknowledgement back to the client asynchronous process will kick off to update the global secondary index is very important to know that the GSIS",
    "start": "1097410",
    "end": "1104700"
  },
  {
    "text": "have to have enough capacity allocated or the table could end up being throttled because we need to maintain",
    "start": "1104700",
    "end": "1111090"
  },
  {
    "text": "the consistency between the indexes and the table so if you're writing data into the table faster then the GSIS can",
    "start": "1111090",
    "end": "1117690"
  },
  {
    "text": "replicate eventually they're going to back up there's a small buffer between the GSI and the table but if that buffer",
    "start": "1117690",
    "end": "1123720"
  },
  {
    "text": "overruns we're gonna shut down writes to the table until the GSI can actually catch up so important to know that",
    "start": "1123720",
    "end": "1129990"
  },
  {
    "text": "you're provisioning on the GSIS must match the throughput of the table",
    "start": "1129990",
    "end": "1136640"
  },
  {
    "start": "1136000",
    "end": "1146000"
  },
  {
    "text": "all right scaling no SQL technology does work you just have to know how it works",
    "start": "1136640",
    "end": "1142500"
  },
  {
    "text": "but I like Douglas Adams so I put this quote up there but this is what bad no",
    "start": "1142500",
    "end": "1147690"
  },
  {
    "start": "1146000",
    "end": "1204000"
  },
  {
    "text": "SQL looks like and this is what usually happens when people kind of don't understand how to use the new technology if you look at this is a heat map and",
    "start": "1147690",
    "end": "1154200"
  },
  {
    "text": "we'll run this for customers I don't necessarily need to see this I can look at a tables you know cloud watch and say okay you're",
    "start": "1154200",
    "end": "1159960"
  },
  {
    "text": "throttling and you're well below your provision capacity that probably means you have a hot key in this particular case we have a partition count on the",
    "start": "1159960",
    "end": "1167340"
  },
  {
    "text": "y-axis we have time on the x-axis and you can see by that big red line all of",
    "start": "1167340",
    "end": "1172530"
  },
  {
    "text": "our access is hitting a single storage node so you remember I said key space we chopped up that key space in this",
    "start": "1172530",
    "end": "1177780"
  },
  {
    "text": "example you have 16 different partitions but something in the application layer is causing a high velocity access",
    "start": "1177780",
    "end": "1183390"
  },
  {
    "text": "pattern to a small number of keys or a single key and it's causing one storage node to light up",
    "start": "1183390",
    "end": "1189580"
  },
  {
    "text": "and that is an anti-pattern NoSQL in all no SQL databases we can force this condition in Cassandra",
    "start": "1189580",
    "end": "1195460"
  },
  {
    "text": "MongoDB dynamodb it doesn't matter we want to distribute the access patterns",
    "start": "1195460",
    "end": "1200980"
  },
  {
    "text": "right this is what no SQL is about is a fully distributed database so getting the most out of Amazon DynamoDB",
    "start": "1200980",
    "end": "1207070"
  },
  {
    "start": "1204000",
    "end": "1260000"
  },
  {
    "text": "throughput it it's oftentimes about using partitioned key elements with",
    "start": "1207070",
    "end": "1212919"
  },
  {
    "text": "large number of distinct values right high cardinality sets we don't want",
    "start": "1212919",
    "end": "1217950"
  },
  {
    "text": "binary partition keys right too or false in or out these are bad partition keys",
    "start": "1217950",
    "end": "1224109"
  },
  {
    "text": "because it's going to allocate so it's going to a granade so much of the data into a small number of partitions what",
    "start": "1224109",
    "end": "1230649"
  },
  {
    "text": "we really want all right things like uu IDs right we want large numbers of distinct values and we want to access those values",
    "start": "1230649",
    "end": "1236999"
  },
  {
    "text": "evenly over time so let's say let's get all of our customers to line up and take",
    "start": "1236999",
    "end": "1243190"
  },
  {
    "text": "a number right so we can get them to come in in a nice orderly fashion we all know that doesn't happen right",
    "start": "1243190",
    "end": "1248919"
  },
  {
    "text": "there's thundering herd's all kinds of high demand access patterns but if we can get that data spread out and get",
    "start": "1248919",
    "end": "1255940"
  },
  {
    "text": "those requests arrive more evenly spaced over time and oftentimes this is about distributing the data will have a much",
    "start": "1255940",
    "end": "1261639"
  },
  {
    "start": "1260000",
    "end": "1280000"
  },
  {
    "text": "better picture when we look at that heat map in this particular example I would probably tell this customer to D",
    "start": "1261639",
    "end": "1267100"
  },
  {
    "text": "provision the table because it's not really doing too much it's very much underutilized I usually like to see a little bit more color I just like to see",
    "start": "1267100",
    "end": "1273190"
  },
  {
    "text": "things evenly distributed across that key space I don't see those big red lines we want pepperoni pizzas on these",
    "start": "1273190",
    "end": "1278950"
  },
  {
    "text": "heat charts right so one thing to mention when we get into dynamodb is the biggest value one of the biggest values",
    "start": "1278950",
    "end": "1285340"
  },
  {
    "start": "1280000",
    "end": "1362000"
  },
  {
    "text": "of dynamo is the elasticity right when I when I manage a no SQL cluster like a MongoDB or Cassandra I have to provision",
    "start": "1285340",
    "end": "1292179"
  },
  {
    "text": "it for peak load and it doesn't go away because I can't take those shards away I can't take those those those nodes off",
    "start": "1292179",
    "end": "1298330"
  },
  {
    "text": "of the ring I have to actually continue to replicate data and run those and manage that infrastructure whether or",
    "start": "1298330",
    "end": "1303850"
  },
  {
    "text": "not it's doing something with DynamoDB we give you a really neat technology to deal with the elastic demand of your",
    "start": "1303850",
    "end": "1309730"
  },
  {
    "text": "application this is a real application service it runs in one of our fulfillment centers you can see like",
    "start": "1309730",
    "end": "1315669"
  },
  {
    "text": "before without auto scaling there was this high bar of provision throughput everything under that want that",
    "start": "1315669",
    "end": "1321100"
  },
  {
    "text": "line and above the blue curve is wasted dollars now with auto-scaling what happens is as your commands the demand",
    "start": "1321100",
    "end": "1326919"
  },
  {
    "text": "for your application increases in flows and ebbs you'll see the auto scaling adjust that capacity on demand to meet",
    "start": "1326919",
    "end": "1334419"
  },
  {
    "text": "the applications access requirements so",
    "start": "1334419",
    "end": "1339789"
  },
  {
    "text": "this is a really good way to manage the cost of your database now no SQL",
    "start": "1339789",
    "end": "1345850"
  },
  {
    "text": "databases in general can't do this so these managed services are really a valuable a managed service like dynamo DB is really valuable because it",
    "start": "1345850",
    "end": "1351820"
  },
  {
    "text": "provides the elasticity which is a huge cost savings over time in the middle of the night when your application is not doing anything you don't really want to",
    "start": "1351820",
    "end": "1358480"
  },
  {
    "text": "be paying for all of those services to be running and so that's one of the nice things about dynamo all right it's",
    "start": "1358480",
    "end": "1364360"
  },
  {
    "start": "1362000",
    "end": "1387000"
  },
  {
    "text": "getting the no SQL data modeling and it's not for the faint of heart right but it wasn't really designed to be it",
    "start": "1364360",
    "end": "1369610"
  },
  {
    "text": "was designed to be to maximize the efficiency of your access patterns and this is one of the things that as",
    "start": "1369610",
    "end": "1375039"
  },
  {
    "text": "developers we're really going to have to understand and embrace because we're so used to developing with relational technology and when you look at the data",
    "start": "1375039",
    "end": "1381100"
  },
  {
    "text": "modeling in no SQL it's different it's hard ok there's a lot of differences between how I model data NoSQL and how I",
    "start": "1381100",
    "end": "1388510"
  },
  {
    "start": "1387000",
    "end": "1431000"
  },
  {
    "text": "model data in relational databases but the bottom line is the data is relational it doesn't stop being relational just",
    "start": "1388510",
    "end": "1395200"
  },
  {
    "text": "because I'm using a different database it's the same entity relationship model",
    "start": "1395200",
    "end": "1400419"
  },
  {
    "text": "that we're going to build and that we're going to manage and that we're gonna have to support with the application service and it doesn't matter what type",
    "start": "1400419",
    "end": "1406030"
  },
  {
    "text": "of application that we're we're building it's all the same is social networking document management IT monitoring you",
    "start": "1406030",
    "end": "1412630"
  },
  {
    "text": "know process control every single application you can think of has some sort of data model that is relational in",
    "start": "1412630",
    "end": "1418450"
  },
  {
    "text": "nature so how do I deal with relational data in NoSQL database a lot of people call no SQL they call it non-relational",
    "start": "1418450",
    "end": "1425200"
  },
  {
    "text": "I won't even you'll notice I don't even use the word on relational because the data is relational it has to be or we wouldn't care about it so we get into",
    "start": "1425200",
    "end": "1432520"
  },
  {
    "start": "1431000",
    "end": "1517000"
  },
  {
    "text": "how we've done that in the past we've used this normalized model and this is a example of a product catalog where I",
    "start": "1432520",
    "end": "1439450"
  },
  {
    "text": "have you know products of three types at books I have albums I have videos and you can see all the common relationships",
    "start": "1439450",
    "end": "1446080"
  },
  {
    "text": "that we track and we manage with the relational database in this structure we have one-to-one between products and",
    "start": "1446080",
    "end": "1451510"
  },
  {
    "text": "books albums and and videos I have a one-to-many between and tracks I have a many-to-many that goes through a lookup table to get you",
    "start": "1451510",
    "end": "1458480"
  },
  {
    "text": "know videos and actors because actors can be in many videos so this is a complex set of queries that need to be",
    "start": "1458480",
    "end": "1464269"
  },
  {
    "text": "executed right to get a list of all my products three different queries joining",
    "start": "1464269",
    "end": "1469669"
  },
  {
    "text": "up to four tables and this is why relational databases cannot scale because that CPU is going nuts hopping",
    "start": "1469669",
    "end": "1476659"
  },
  {
    "text": "all over the disk pulling data off of all these tables sticking it together in a denormalized view and serving it up to",
    "start": "1476659",
    "end": "1482179"
  },
  {
    "text": "the application layer and on the flip side when I need to update that data because what I'm really doing when I",
    "start": "1482179",
    "end": "1487190"
  },
  {
    "text": "execute those queries is I'm populating application layer entities when I need up they update the application layer",
    "start": "1487190",
    "end": "1492740"
  },
  {
    "text": "entity well what happens the data lives in multiple places so now I need acid transactions all right so a lot of the",
    "start": "1492740",
    "end": "1499730"
  },
  {
    "text": "need for acid transactions is really the reason for that is because of the data",
    "start": "1499730",
    "end": "1505700"
  },
  {
    "text": "model that we're using with relational databases sorry I'm losing my voice booth I've been a long week already so",
    "start": "1505700",
    "end": "1515779"
  },
  {
    "text": "maybe a better approach to this is to not do that we don't want to burn that CPU like that we want to take those",
    "start": "1515779",
    "end": "1521629"
  },
  {
    "text": "hierarchical data structures we want to collapse those things and build documents or collections of items within single partitions that represent these",
    "start": "1521629",
    "end": "1528110"
  },
  {
    "text": "data hierarchies and now instead of having to execute three queries with various degrees of complexity I'm",
    "start": "1528110",
    "end": "1533840"
  },
  {
    "text": "executing one simple query that says select star from products if I want to get all my books select star from",
    "start": "1533840",
    "end": "1538970"
  },
  {
    "text": "products where type equals book right these are much simpler queries much simpler access patterns you can see",
    "start": "1538970",
    "end": "1544610"
  },
  {
    "text": "immediately why does the system scale better when I use this type of hierarchical data model right then this",
    "start": "1544610",
    "end": "1550940"
  },
  {
    "text": "relational data model is because I'm not executing as complex an operation to assemble the view I'm just going in",
    "start": "1550940",
    "end": "1556999"
  },
  {
    "text": "getting documents or collections of items out of single partitions I don't have to go in and join data and create",
    "start": "1556999",
    "end": "1562190"
  },
  {
    "start": "1562000",
    "end": "1643000"
  },
  {
    "text": "these views so when it comes down to it there's really just a few concepts we need to understand when we get into data",
    "start": "1562190",
    "end": "1568700"
  },
  {
    "text": "modeling and dynamodb the key concepts are really about selecting the partition key in the sort key as we talked about",
    "start": "1568700",
    "end": "1574490"
  },
  {
    "text": "this is the partition key is about large numbers of distinct values we want things to be uniformly requested over",
    "start": "1574490",
    "end": "1580669"
  },
  {
    "text": "time so maybe some bad examples would be status and gender good examples might be customer ID",
    "start": "1580669",
    "end": "1585670"
  },
  {
    "text": "vici D things that allow me to kind of distribute that data selecting the sort key is about modeling those one-to-many",
    "start": "1585670",
    "end": "1592780"
  },
  {
    "text": "and many-to-many relationships that we need to support within the in the data model and and building a sort key that",
    "start": "1592780",
    "end": "1599590"
  },
  {
    "text": "allows me to execute very efficient selected patterns this is what we're gonna get into we start talking about composite key modeling in a few minutes",
    "start": "1599590",
    "end": "1606310"
  },
  {
    "text": "but it's about querying across entities with a single trip to the database I",
    "start": "1606310",
    "end": "1611410"
  },
  {
    "text": "want to get all of the items that I need to support that access pattern I don't want to have to go back multiple times",
    "start": "1611410",
    "end": "1617110"
  },
  {
    "text": "go get my customer item now go get all the order items for that customer that's a relational pattern and I see",
    "start": "1617110",
    "end": "1623050"
  },
  {
    "text": "this all the time when I work with developers because they're used to modeling data relationally so they do it that way and then their access patterns",
    "start": "1623050",
    "end": "1629590"
  },
  {
    "text": "become very inefficient because I'm really managing that joint at the application layer as soon as I do that right so what we want is you know make",
    "start": "1629590",
    "end": "1637420"
  },
  {
    "text": "good examples of this we talk about orders and order items hierarchical relationships which we'll get into in a",
    "start": "1637420",
    "end": "1643120"
  },
  {
    "text": "few minutes as we walk through the process and it's important to understand",
    "start": "1643120",
    "end": "1648640"
  },
  {
    "text": "the differences in the process between modeling and application and no SQL and relational database as a relational",
    "start": "1648640",
    "end": "1654760"
  },
  {
    "text": "database all I need to do is normalize the data right we have this neat things called third normal form I could probably talk to in almost anybody in",
    "start": "1654760",
    "end": "1661030"
  },
  {
    "text": "this room right now who's listening to this presentation and say here's my business problem here's my entity",
    "start": "1661030",
    "end": "1666190"
  },
  {
    "text": "relationship model can you give me a data model for my relational database and everybody be able to sit down and build that third normal form right and",
    "start": "1666190",
    "end": "1673360"
  },
  {
    "text": "then we can argue about what queries are more efficient at an index or to you after the fact but the reality is with with no SQL it's the opposite I need to",
    "start": "1673360",
    "end": "1679960"
  },
  {
    "text": "understand every access pattern I need to know exactly what the application is doing because if I don't then I can't I",
    "start": "1679960",
    "end": "1685990"
  },
  {
    "text": "can't model the data in a way that's going to be efficient for that particular application service so the first thing we want to do is understand",
    "start": "1685990",
    "end": "1692080"
  },
  {
    "start": "1690000",
    "end": "1726000"
  },
  {
    "text": "that use case what is the nature of your application is this an OLTP app is this an OLAP app is this a decision support",
    "start": "1692080",
    "end": "1698860"
  },
  {
    "text": "system there's a very different requirements for those applications and and really there's one of them that",
    "start": "1698860",
    "end": "1704800"
  },
  {
    "text": "doesn't fit right that OLAP application is does not fit with a no SQL back in you know define that entity relationship",
    "start": "1704800",
    "end": "1711160"
  },
  {
    "text": "model know what it is what is what is the data that I'm working with what is the nature of that data and how is it related",
    "start": "1711160",
    "end": "1716760"
  },
  {
    "text": "and then identify what the data lifecycle is right what's my archive backup do I need to TTL this data how",
    "start": "1716760",
    "end": "1723780"
  },
  {
    "text": "what is the lifecycle of the data on the table the next thing we're gonna do is identify all of the access patterns of",
    "start": "1723780",
    "end": "1729840"
  },
  {
    "start": "1726000",
    "end": "1840000"
  },
  {
    "text": "your applications this is what I'll do when I sit down I do my design reviews with customers you know how are we read the data how do you write the data",
    "start": "1729840",
    "end": "1736140"
  },
  {
    "text": "what's the right pattern what's the read pattern you know what are the aggregations that we're trying to",
    "start": "1736140",
    "end": "1741150"
  },
  {
    "text": "support with the acclimate with this particular application service and we want to document all of the workflows",
    "start": "1741150",
    "end": "1746220"
  },
  {
    "text": "upfront and yet why because I'm actually designing a data model that's gonna be very specifically tuned to those access",
    "start": "1746220",
    "end": "1751470"
  },
  {
    "text": "patterns and if I don't identify all those patterns and I could be in a lot of trouble when I go out and try and",
    "start": "1751470",
    "end": "1757590"
  },
  {
    "text": "deploy this thing I might do a lot of work and have to unwind a lot of things I've done so one of the things I hear a",
    "start": "1757590",
    "end": "1762720"
  },
  {
    "text": "lot is use no SQL because it's very flexible I've done a thousand no SQL applications I can tell you nothing",
    "start": "1762720",
    "end": "1768540"
  },
  {
    "text": "could be further from the truth now as Gil has not a flexible database it's an efficient database right but the",
    "start": "1768540",
    "end": "1775200"
  },
  {
    "text": "data model is very much not not not flexible because again because I'm building the app and you'll see when we get into the actual modeling of this and",
    "start": "1775200",
    "end": "1781290"
  },
  {
    "text": "how you actually build real services on no SQL with complex actually access patterns the more that I tune that data",
    "start": "1781290",
    "end": "1787200"
  },
  {
    "text": "to the access pattern the more tightly coupled to that service I am so it's not really a flexible service but it is a",
    "start": "1787200",
    "end": "1792990"
  },
  {
    "text": "very efficient database to use at scale then the next thing where you do is",
    "start": "1792990",
    "end": "1798330"
  },
  {
    "text": "going to actually model the data and this is where we get into the common mistake everybody makes when they work",
    "start": "1798330",
    "end": "1803490"
  },
  {
    "text": "with no SQL application they start building multiple tables and they start building you know relational design",
    "start": "1803490",
    "end": "1808799"
  },
  {
    "text": "models it's about one application service requiring one table right and",
    "start": "1808799",
    "end": "1814860"
  },
  {
    "text": "we're going to get into that we talked about the data modeling in a minute we'll show you some pretty complex services that have been modeled down to",
    "start": "1814860",
    "end": "1820230"
  },
  {
    "text": "a single table identifying those keys and how we're going to access the data and what are the actual queries that",
    "start": "1820230",
    "end": "1825900"
  },
  {
    "text": "we're going to execute define your indexes for your secondary access patterns and then it's just an iterative",
    "start": "1825900",
    "end": "1831330"
  },
  {
    "text": "process right just like any development process we're gonna review we're going to repeat we're gonna review and we're",
    "start": "1831330",
    "end": "1837870"
  },
  {
    "text": "gonna get this thing down to a science sooner or later all right so complex",
    "start": "1837870",
    "end": "1843120"
  },
  {
    "start": "1840000",
    "end": "1850000"
  },
  {
    "text": "queries it's all about the questions computers give you answers but we have to we have to ask the right questions so",
    "start": "1843120",
    "end": "1848460"
  },
  {
    "text": "not always useless but you know some people have thought so one of the things that no SQL databases",
    "start": "1848460",
    "end": "1854720"
  },
  {
    "start": "1850000",
    "end": "1965000"
  },
  {
    "text": "aren't so good at is actually answering those complex questions right I mean I need to know what is the count the average the sum the maximum the minimum",
    "start": "1854720",
    "end": "1861920"
  },
  {
    "text": "in a given set all kinds of complex computed aggregations things that may be stored procedures one of the things",
    "start": "1861920",
    "end": "1868580"
  },
  {
    "text": "about DynamoDB is really neat is this thing called DynamoDB streams and lambda it's like the best stored procedure engine in the business because it's",
    "start": "1868580",
    "end": "1874850"
  },
  {
    "text": "completely disconnected from the tablespace one of the things that we did with Amazon's retail organization and",
    "start": "1874850",
    "end": "1881000"
  },
  {
    "text": "one of the reasons that we migrated off of Oracle was because we had a problem with with the with service teams",
    "start": "1881000",
    "end": "1886400"
  },
  {
    "text": "deploying stored procedures into an Oracle server it was shared across multiple teams and maybe somebody would",
    "start": "1886400",
    "end": "1891680"
  },
  {
    "text": "deploy some bad code and all of a sudden we'd have three or four services or more going belly-up because you know the the",
    "start": "1891680",
    "end": "1898070"
  },
  {
    "text": "processing space of the head node of the database server got knocked sideways one of the nice things about streams and",
    "start": "1898070",
    "end": "1903950"
  },
  {
    "text": "lambda is all of the processing and of the data occurs in a different processing space than the table so you",
    "start": "1903950",
    "end": "1909680"
  },
  {
    "text": "don't have to worry about impacting the availability of your dynamodb table so we can deploy really bad code to lambda",
    "start": "1909680",
    "end": "1915020"
  },
  {
    "text": "and it's not gonna really kill us we don't I do that obviously so the way lambda works is you know it works in",
    "start": "1915020",
    "end": "1921530"
  },
  {
    "text": "conjunction with the dynamodb stream stream is the change log for the dynamodb table it takes all right operations will appear on the stream",
    "start": "1921530",
    "end": "1928690"
  },
  {
    "text": "once the data is on the stream you can invoke a lambda function that lambda function has two iam roles we talked",
    "start": "1928690",
    "end": "1934310"
  },
  {
    "text": "about you know the security fine-grained access control lambda has an invocation role which defines what it can see or",
    "start": "1934310",
    "end": "1941060"
  },
  {
    "text": "what it can read off of the stream which items can it see which attributes in those items can the land of process",
    "start": "1941060",
    "end": "1946550"
  },
  {
    "text": "actually read and then it has an execution role which defines what it can do what other services within your AWS",
    "start": "1946550",
    "end": "1952880"
  },
  {
    "text": "account space does it have access to you and what permissions does it have on those services to to work with this data",
    "start": "1952880",
    "end": "1958310"
  },
  {
    "text": "so what do people do with this in this example not very much it's just dumping those attributes out to the console but",
    "start": "1958310",
    "end": "1963860"
  },
  {
    "text": "it's code and code can do anything people do lots of things with it one of the most common things we do with",
    "start": "1963860",
    "end": "1969500"
  },
  {
    "start": "1965000",
    "end": "2090000"
  },
  {
    "text": "streams and lambda is computed aggregations right people need to understand what are the averages the",
    "start": "1969500",
    "end": "1975890"
  },
  {
    "text": "counts the sums one of the nice things about MongoDB when you're working with small data is",
    "start": "1975890",
    "end": "1980920"
  },
  {
    "text": "Asian framework how many people have used aggregation framework for MongoDB a few okay I loved aggregation framework when I was",
    "start": "1980920",
    "end": "1987580"
  },
  {
    "text": "in MongoDB until I had to scale it they doesn't scale too well one of the nice",
    "start": "1987580",
    "end": "1993520"
  },
  {
    "text": "things about this particularly design pattern is as we read data off of the stream we can compute these running",
    "start": "1993520",
    "end": "1999310"
  },
  {
    "text": "aggregations these these counts sums averages or complex computed metrics that we need to maintain at the",
    "start": "1999310",
    "end": "2005280"
  },
  {
    "text": "application layer and then write that data back into the table as a metadata item so for things like time series data",
    "start": "2005280",
    "end": "2011700"
  },
  {
    "text": "maybe I have time based partitions as I load those time series the time based partitions I can execute my my",
    "start": "2011700",
    "end": "2017940"
  },
  {
    "text": "aggregation functions and produce all those time-series metrics and write that metadata item right back into that",
    "start": "2017940",
    "end": "2022950"
  },
  {
    "text": "partition a really neat thing about time series data is once it's loaded it don't change right so we don't have to worry",
    "start": "2022950",
    "end": "2028890"
  },
  {
    "text": "about that metric having to be calculated a thousand times a second the data gets loaded the metric is calculated now it can be read a million",
    "start": "2028890",
    "end": "2035550"
  },
  {
    "text": "times and I don't have to recalculate it every time this is what we want to do with no SQL we want to offload the CPU",
    "start": "2035550",
    "end": "2041970"
  },
  {
    "text": "we don't want to have to compute things we want things to be pre computed so this is a really neat design pattern for",
    "start": "2041970",
    "end": "2048570"
  },
  {
    "text": "that we have lots and lots of customers that use that plenty of other things we can do with lambda update cloud search",
    "start": "2048570",
    "end": "2054389"
  },
  {
    "text": "or elastic search or other indexing systems pushing the data into Kinesis firehose for stream processing interact",
    "start": "2054390",
    "end": "2062070"
  },
  {
    "text": "with external systems again lambda is just code and it can do anything and the other thing you can do is doesn't have",
    "start": "2062070",
    "end": "2067889"
  },
  {
    "text": "to always be lambda that reads the stream if you have a high velocity work flow then maybe lambda is not the most cost efficient thing to use maybe I'll",
    "start": "2067890",
    "end": "2073919"
  },
  {
    "text": "stand up an ec2 instance and create a static stream reader service and that's perfectly acceptable as well we have",
    "start": "2073919",
    "end": "2079860"
  },
  {
    "text": "lots of customers doing that so realize that streams and lambda is there for you to execute those stored procedure type",
    "start": "2079860",
    "end": "2086220"
  },
  {
    "text": "operations or complex compute it up aggregations certainly a valuable service for doing that alright let's get",
    "start": "2086220",
    "end": "2094080"
  },
  {
    "start": "2090000",
    "end": "2108000"
  },
  {
    "text": "into what we deal with composite keys and I love this quote because it's",
    "start": "2094080",
    "end": "2099090"
  },
  {
    "text": "perfect right most people use no SQL as a key value store that's not the way that no SQL is the most efficient way to",
    "start": "2099090",
    "end": "2105270"
  },
  {
    "text": "be used right we wanted to actually store our hierarchical data in in the table so to speak so how do we do that",
    "start": "2105270",
    "end": "2111900"
  },
  {
    "text": "in this case let's talk a little bit about you know composite keys and in the use case here we have maybe players for a",
    "start": "2111900",
    "end": "2118970"
  },
  {
    "text": "particular game they have sessions sessions have state what I'm interested in is all the Givens sessions for a",
    "start": "2118970",
    "end": "2125030"
  },
  {
    "text": "given user that have a state of pending so game invites but not in this picture",
    "start": "2125030",
    "end": "2130820"
  },
  {
    "text": "case I might have a table that is partitioned on the opponent that is sorted by the date and if I want to get",
    "start": "2130820",
    "end": "2137450"
  },
  {
    "text": "all of the sessions for a user Bob sorted by date and and and filtered on",
    "start": "2137450",
    "end": "2144230"
  },
  {
    "text": "pending a dynamodb can support this because we give you two key conditions that you can actually evaluate to range",
    "start": "2144230",
    "end": "2150980"
  },
  {
    "text": "queries the first one applies to the sort key that's the sort condition that's the date condition so in this",
    "start": "2150980",
    "end": "2157310"
  },
  {
    "text": "case I'm saying there is really no sort filter I understand give me everything ordered by date since the sort key is the date all the items going to be",
    "start": "2157310",
    "end": "2163700"
  },
  {
    "text": "returned sorted by date that's great but I really only interested in the pending items so I'm gonna say filter on pending that's the filter condition so",
    "start": "2163700",
    "end": "2170870"
  },
  {
    "text": "the sort condition applies before the read so it'll it'll give me a nice selective read the filter condition",
    "start": "2170870",
    "end": "2176900"
  },
  {
    "text": "applies after the read so it'll knock out the items that I'm sending back across the wire but I'm still paying to",
    "start": "2176900",
    "end": "2181940"
  },
  {
    "text": "read those items so the cost of that read is the same as whatever the sort key dictates this is okay in this",
    "start": "2181940",
    "end": "2189230"
  },
  {
    "text": "particular example because I really only have three items only one of them is being filtered out all three of those items really less than one RCU so the",
    "start": "2189230",
    "end": "2195620"
  },
  {
    "text": "cost of that query is the equivalent right whether it was more more selective or not but let's say there was 10,000",
    "start": "2195620",
    "end": "2202400"
  },
  {
    "text": "items in this particular users partition and only two of them were pending maybe I don't want to read 9,998 items just to",
    "start": "2202400",
    "end": "2209870"
  },
  {
    "text": "return to so one of the ways that I could do that and the only way to do that is to create a composite key composite keys are how we create",
    "start": "2209870",
    "end": "2215990"
  },
  {
    "start": "2210000",
    "end": "2227000"
  },
  {
    "text": "hierarchies on this using the sort key structure so if you think of what we're gonna do here is we're gonna take the",
    "start": "2215990",
    "end": "2221930"
  },
  {
    "text": "status and the date we're going to concatenate those things together where you create one key called status date",
    "start": "2221930",
    "end": "2227060"
  },
  {
    "start": "2227000",
    "end": "2258000"
  },
  {
    "text": "when we push back to the table now you can see what that view looks like it's like a faceted search I can say give me",
    "start": "2227060",
    "end": "2232880"
  },
  {
    "text": "everything for this particular user that starts with pending it's gonna give me only the items are pending it's gonna be",
    "start": "2232880",
    "end": "2238820"
  },
  {
    "text": "a nice selective read I could say starts with pending underbar timestamp 1 or",
    "start": "2238820",
    "end": "2244340"
  },
  {
    "text": "between pending underbar time stamp one impending underbar time stamp 2 and I getting a range of items",
    "start": "2244340",
    "end": "2249650"
  },
  {
    "text": "within a given state and they gonna get a query across state so think of this like a faceted search type and what I'm",
    "start": "2249650",
    "end": "2255770"
  },
  {
    "text": "really doing is creating a hierarchy and we'll show you how to do that when get into the advanced data modeling here an",
    "start": "2255770",
    "end": "2260960"
  },
  {
    "start": "2258000",
    "end": "2295000"
  },
  {
    "text": "advanced data modeling is about thinking about the data right nothing does itself",
    "start": "2260960",
    "end": "2266170"
  },
  {
    "text": "the way the OLTP apps use data again is about hierarchical structures that use entity driven workflows the data gets",
    "start": "2266170",
    "end": "2272510"
  },
  {
    "text": "spread out across tables and requires complex queries to be able to populate these application layer entities",
    "start": "2272510",
    "end": "2278420"
  },
  {
    "text": "requires multiple queries to be able to update the entities as a primary driver for acid when we get into no SQL",
    "start": "2278420",
    "end": "2285200"
  },
  {
    "text": "databases however so when we do normalize the data and we create hierarchical data items then maybe I",
    "start": "2285200",
    "end": "2291590"
  },
  {
    "text": "don't need much more than atomic updates there's still a there's still times when we might need acid transactions I'm one",
    "start": "2291590",
    "end": "2298880"
  },
  {
    "text": "of the really good one of the good ones is in maintaining the version history or creating new items that actually get",
    "start": "2298880",
    "end": "2304040"
  },
  {
    "text": "created in multiple passes and committed all at once so in this particular example let's talk about we have items",
    "start": "2304040",
    "end": "2309740"
  },
  {
    "text": "on a table these items have maybe a first item that we put into the table as the v-0 item you know it's copy of the",
    "start": "2309740",
    "end": "2316340"
  },
  {
    "text": "v1 item and that main take contains the current data for this particular partition so when a customer wants to",
    "start": "2316340",
    "end": "2323180"
  },
  {
    "text": "come in and get the most current version of that particular item he says select star from table where the item ID equals 1 and the sort key starts with v-0",
    "start": "2323180",
    "end": "2330200"
  },
  {
    "text": "he's always going to get a copy of the current version so if we look at the state of this given partition it looks like somebody came along they created",
    "start": "2330200",
    "end": "2336890"
  },
  {
    "text": "item 1 initially it was version 1 and there was a copy of version 1 in v-0 somebody came along they created version 2 they",
    "start": "2336890",
    "end": "2343280"
  },
  {
    "text": "committed version 2 they updated the version 0 item they just clobbered it with a copy of v2 and they updated the",
    "start": "2343280",
    "end": "2348470"
  },
  {
    "text": "current version attribute to indicate that it's now version 2 so when the when the reader comes along says select start",
    "start": "2348470",
    "end": "2354140"
  },
  {
    "text": "where it starts with v-0 he's gonna actually get that item but he'll see that it's really version 2 and now",
    "start": "2354140",
    "end": "2360500"
  },
  {
    "text": "somebody's come along and they've created version 3 but version 3 is not committed version 3 is just sitting in that partition you know some works being",
    "start": "2360500",
    "end": "2367340"
  },
  {
    "text": "done on version 3 will execute multiple updates we'll build this item in multiple passes eventually we're ready",
    "start": "2367340",
    "end": "2372590"
  },
  {
    "text": "to commit version 3 so what do we do we clobber v-0 we update the current version attribute to version",
    "start": "2372590",
    "end": "2379410"
  },
  {
    "text": "three and now any reader that comes into this partition and looks and says give me the item that starts with v zero is",
    "start": "2379410",
    "end": "2384660"
  },
  {
    "text": "actually going to get V three so neat things about this particular pattern I have an audit trail write everything to",
    "start": "2384660",
    "end": "2390510"
  },
  {
    "text": "changed what version has changed across you can decorate those items with the you know the who changed it so all kinds",
    "start": "2390510",
    "end": "2396750"
  },
  {
    "text": "of night the nice things you can do I get the same type of visibility I'm used to with acid transactions read committed",
    "start": "2396750",
    "end": "2402060"
  },
  {
    "text": "read uncommitted I can read committed starts with v-0 read uncommitted scanned",
    "start": "2402060",
    "end": "2407610"
  },
  {
    "text": "forward index false limit one gives me the item that might be being worked on it so on and so forth so it's a neat way",
    "start": "2407610",
    "end": "2414720"
  },
  {
    "text": "to be able to maintain version history and and have some sort of transactional workflow against a single item now we",
    "start": "2414720",
    "end": "2420810"
  },
  {
    "text": "get into multiple items we're going to talk about started getting into some real data modeling here in this example",
    "start": "2420810",
    "end": "2426780"
  },
  {
    "start": "2421000",
    "end": "2488000"
  },
  {
    "text": "I'm gonna use a pretty simple this is an internal service that we have at Amazon so it's a resolver service for",
    "start": "2426780",
    "end": "2431850"
  },
  {
    "text": "configuration items configuration item we create the resolver groups we associate the configuration items to",
    "start": "2431850",
    "end": "2437370"
  },
  {
    "text": "those resolver groups and then we have contacts for those resolver groups when new configuration items come in we email",
    "start": "2437370",
    "end": "2443010"
  },
  {
    "text": "all the contacts are associated to given resolver group and so the data model looks something like this we have a read",
    "start": "2443010",
    "end": "2448380"
  },
  {
    "text": "a resolver Group entity there's a many to many relationship between contacts and resolver groups in between",
    "start": "2448380",
    "end": "2453390"
  },
  {
    "text": "configuration items and resolver groups and there's a couple of transactional workflows that we have to execute right",
    "start": "2453390",
    "end": "2458940"
  },
  {
    "text": "we want to add configuration items to the resolver groups all at once or not at all and the reason and a commanded",
    "start": "2458940",
    "end": "2464820"
  },
  {
    "text": "configuration item can belong to multiple resolver groups so and multiple configuration items might come in",
    "start": "2464820",
    "end": "2469890"
  },
  {
    "text": "together and we want these things to be committed to the resolver groups all at once or not at all and then maybe",
    "start": "2469890",
    "end": "2476040"
  },
  {
    "text": "contacts might need to be added to resolve our groups as well transactionally we might want to update the configuration item data",
    "start": "2476040",
    "end": "2481710"
  },
  {
    "text": "transactionally there's a lot of workflows around here that require some transactional you know kin interactions",
    "start": "2481710",
    "end": "2488790"
  },
  {
    "start": "2488000",
    "end": "2558000"
  },
  {
    "text": "with the data and DynamoDB if you're up to speed this morning or this afternoon we announced a really cool new feature",
    "start": "2488790",
    "end": "2495210"
  },
  {
    "text": "which is transactions API we have now a transact right items transact read items",
    "start": "2495210",
    "end": "2500400"
  },
  {
    "text": "API where we can actually support synchronous updates puts deletes across multiple items full at full acid",
    "start": "2500400",
    "end": "2507420"
  },
  {
    "text": "compliance with automated role backs up to ten items within a transaction and supports multiple tables",
    "start": "2507420",
    "end": "2512960"
  },
  {
    "text": "although you should not have multiple tables I didn't want them to do that",
    "start": "2512960",
    "end": "2519620"
  },
  {
    "text": "that they did that it's okay there's actually there are use cases for multiple tables it's it's not I try to",
    "start": "2519620",
    "end": "2526040"
  },
  {
    "text": "drive things to a single table but even myself I'll get into the point where now let's split the data but generally",
    "start": "2526040",
    "end": "2531440"
  },
  {
    "text": "speaking it's a single table so good use cases for this commit changes across items absolutely love it conditional",
    "start": "2531440",
    "end": "2537530"
  },
  {
    "text": "batch inserts and updates right we can have multiple conditions defined within a transaction if any of those conditions",
    "start": "2537530",
    "end": "2542660"
  },
  {
    "text": "fail none of those items will get written that's a great use case really bad use case maintaining normalized data",
    "start": "2542660",
    "end": "2549320"
  },
  {
    "text": "models please don't do that so transactions is here for you but it's not a crutch to make your relational",
    "start": "2549320",
    "end": "2555320"
  },
  {
    "text": "models work all right that's actually going to be a real bad pattern for you so how does this work in DynamoDB with",
    "start": "2555320",
    "end": "2561080"
  },
  {
    "start": "2558000",
    "end": "2674000"
  },
  {
    "text": "the single table in this particular case we have resolved or group partitions and contact partitions what we've done is created a pretty simple adjacency list",
    "start": "2561080",
    "end": "2567580"
  },
  {
    "text": "adjacency list is a simple graph as we denormalize the contacts across the resolver groups what I'm really going to",
    "start": "2567580",
    "end": "2573890"
  },
  {
    "text": "do is create a copy of that contact and reinsert it into the table with a different sort key and that sort key is",
    "start": "2573890",
    "end": "2580190"
  },
  {
    "text": "the actual resolved or group ID so now what I've done in my contact partitions is I have a copy of the contact for each",
    "start": "2580190",
    "end": "2585920"
  },
  {
    "text": "resolver group it belongs to if I need to add resolver metadata into the",
    "start": "2585920",
    "end": "2592040"
  },
  {
    "text": "resolver group partitions and I'm going to add configuration items into those resolver Group partitions as well now",
    "start": "2592040",
    "end": "2597920"
  },
  {
    "text": "when I get into the transactional updates here what's going to end up happening is maybe I have a",
    "start": "2597920",
    "end": "2602930"
  },
  {
    "text": "configuration item I need to add to multiple resolver groups transact write API gives me the ability to execute that",
    "start": "2602930",
    "end": "2609590"
  },
  {
    "text": "insert to both of those partitions and and guarantee that both those inserts will commit or not commit right it's up",
    "start": "2609590",
    "end": "2616850"
  },
  {
    "text": "to you know when the transaction you know API to manage that process not the application layer anymore maybe I need",
    "start": "2616850",
    "end": "2623270"
  },
  {
    "text": "to update the transaction status maybe I want to cancel an item and I can add multiple conditional checks I can say",
    "start": "2623270",
    "end": "2628790"
  },
  {
    "text": "you know cancel this configuration item across all resolver groups as long as none of them are in progress that's a",
    "start": "2628790",
    "end": "2634910"
  },
  {
    "text": "really valid use case for us right because sometimes configuration items get pushed into the system somebody goes",
    "start": "2634910",
    "end": "2639950"
  },
  {
    "text": "oops we don't want to do that so pull it back right I need to I need to call that configuration item back",
    "start": "2639950",
    "end": "2645160"
  },
  {
    "text": "maybe I need to update the contacts email right across multiple resolver groups and I don't really want to do",
    "start": "2645160",
    "end": "2651369"
  },
  {
    "text": "that outside of a transactional envelope again so multiple ways that we can execute transactional writes in this",
    "start": "2651369",
    "end": "2658300"
  },
  {
    "text": "particular use case and this is a really good example of a single table design pattern it maintains a complex entity",
    "start": "2658300",
    "end": "2664300"
  },
  {
    "text": "relationship model right cond we have configuration items we've got contacts",
    "start": "2664300",
    "end": "2669369"
  },
  {
    "text": "we've got resolver groups they all live on the same table the metadata for all of that lives on the same table and just",
    "start": "2669369",
    "end": "2674410"
  },
  {
    "start": "2674000",
    "end": "2741000"
  },
  {
    "text": "to kind of show you how that you know is we add one GSI to do our reverse lookup right I can look up contacts by resolver",
    "start": "2674410",
    "end": "2681369"
  },
  {
    "text": "group on the GSI and we've member we denormalized our contacts across the resolver group so if I want to go back",
    "start": "2681369",
    "end": "2686829"
  },
  {
    "text": "to the to the reverse lookup GSI I can partition I can read the partition key",
    "start": "2686829",
    "end": "2691960"
  },
  {
    "text": "for the with the resolver group idea get all of the contacts forgiving resolver group or I'd get all of the resolver",
    "start": "2691960",
    "end": "2698650"
  },
  {
    "text": "groups for a given configuration item right again so all I've done is I've taken that tape that primary table and",
    "start": "2698650",
    "end": "2704770"
  },
  {
    "text": "I've created a reverse look-up on the prod on the partition and sort key so now the sort key is the partition key",
    "start": "2704770",
    "end": "2710079"
  },
  {
    "text": "and the and the partition key is the store key for the GSI it gives you that kind of reverse lookup so this is a way",
    "start": "2710079",
    "end": "2716049"
  },
  {
    "text": "to be able to maintain many-to-many relationships I mean if you look back to the erd here we had we've got a",
    "start": "2716049",
    "end": "2724030"
  },
  {
    "text": "many-to-many between resolver groups and contacts many-many between configuration",
    "start": "2724030",
    "end": "2729099"
  },
  {
    "text": "items and resolver groups and you know in this particular data model now I've maintained that many many relationship",
    "start": "2729099",
    "end": "2735309"
  },
  {
    "text": "across all of those entities using the primary table and the reverse lookup GSI",
    "start": "2735309",
    "end": "2741270"
  },
  {
    "start": "2741000",
    "end": "2748000"
  },
  {
    "text": "alright getting into hierarchical data that was a little bit of a some data",
    "start": "2741270",
    "end": "2746589"
  },
  {
    "text": "hierarchies we work with there but this is another service we use internally at Amazon this is for getting office",
    "start": "2746589",
    "end": "2751660"
  },
  {
    "start": "2748000",
    "end": "2844000"
  },
  {
    "text": "information if we go to our wiki page and we click on a particular office building whatnot this is the service",
    "start": "2751660",
    "end": "2756940"
  },
  {
    "text": "that it's going back to research for offices in this given in this particular example we have pretty straightforward",
    "start": "2756940",
    "end": "2761980"
  },
  {
    "text": "linear hierarchy country state city office on the table where partitioned on the country ID were sorted on a",
    "start": "2761980",
    "end": "2768220"
  },
  {
    "text": "composite key which is the state city office ID so now the access patterns here might be say give me everything in",
    "start": "2768220",
    "end": "2774040"
  },
  {
    "text": "u.s. in the United States query the table where the partition key equals USA I'll get every office in the United States I",
    "start": "2774040",
    "end": "2780350"
  },
  {
    "text": "want every office in New York ok country ID equals US city start",
    "start": "2780350",
    "end": "2785580"
  },
  {
    "text": "source or key starts with NY excuse me everything in New York state everything in New York City starts with NY hash NYC",
    "start": "2785580",
    "end": "2792270"
  },
  {
    "text": "gives me everything in New York City it's a really nice way to be able to take a linear hierarchy like this and just slice it up into a composite sort",
    "start": "2792270",
    "end": "2798540"
  },
  {
    "text": "key and be able to support multiple access patterns multiple groups multiple aggregations I don't need multiple tables yeah and if",
    "start": "2798540",
    "end": "2805320"
  },
  {
    "text": "I tried to do this with multiple tables just think of the access that I'd have to execute at the application layer ok",
    "start": "2805320",
    "end": "2811020"
  },
  {
    "text": "let me get the country ID let me go back to the state and get me the states you know in that country oh right ok this",
    "start": "2811020",
    "end": "2816780"
  },
  {
    "text": "this state is New York let me go back and get all the cities in New York now let me go back and get all the offices in those cities that's a lot of round",
    "start": "2816780",
    "end": "2822780"
  },
  {
    "text": "trips that's a lot of that's a high latency and a very expensive operation that you're gonna be executing if you",
    "start": "2822780",
    "end": "2828240"
  },
  {
    "text": "implement this in a relational pattern and no SQL why because there's no joins in no SQL because joins are expensive",
    "start": "2828240",
    "end": "2833820"
  },
  {
    "text": "and that's why relational databases don't scale so when you hear people say that no it feels missing joins well you",
    "start": "2833820",
    "end": "2839970"
  },
  {
    "text": "say you're missing the point",
    "start": "2839970",
    "end": "2842930"
  },
  {
    "start": "2844000",
    "end": "2855000"
  },
  {
    "text": "all right so complex relational data we had a little bit of a picture of that when we're looking at that configuration",
    "start": "2845150",
    "end": "2852030"
  },
  {
    "text": "management service this is more of a that's going to a theoretical delivery",
    "start": "2852030",
    "end": "2857040"
  },
  {
    "start": "2855000",
    "end": "2874000"
  },
  {
    "text": "service right so I'm gonna create a fictitional delivery service that's called get me that get me that gets",
    "start": "2857040",
    "end": "2862500"
  },
  {
    "text": "people things right people are busy they need stuff you write download get me",
    "start": "2862500",
    "end": "2868500"
  },
  {
    "text": "that brow stuff get stuff tell us where to put your stuff that's what this does so it's very simple service but it's not",
    "start": "2868500",
    "end": "2874440"
  },
  {
    "start": "2874000",
    "end": "2897000"
  },
  {
    "text": "a very simple into the relationship model when we look at this we have customers vendors orders items drivers",
    "start": "2874440",
    "end": "2880380"
  },
  {
    "text": "right customers place orders vendors accept items from those orders drivers",
    "start": "2880380",
    "end": "2885780"
  },
  {
    "text": "deliver those items drivers have status current status they have 5-minute status they have 10-minute status because we",
    "start": "2885780",
    "end": "2891690"
  },
  {
    "text": "want to kind of schedule things efficiently right so let's see what that actually looks like you know when we",
    "start": "2891690",
    "end": "2897870"
  },
  {
    "start": "2897000",
    "end": "2921000"
  },
  {
    "text": "were getting the access patterns we're talking about 10 or 12 different access patterns to this application right I want to get customers by date",
    "start": "2897870",
    "end": "2904250"
  },
  {
    "text": "vendors by date orders by customer by date and vendor by vendor by date order details order items status delivery you",
    "start": "2904250",
    "end": "2912530"
  },
  {
    "text": "know deliveries by drivers drivers status for scheduling so it's a very complex set of access patterns about ten",
    "start": "2912530",
    "end": "2918050"
  },
  {
    "text": "or ten or eleven access patterns we need to support in this given application pretty straightforward thing to do with",
    "start": "2918050",
    "end": "2923990"
  },
  {
    "start": "2921000",
    "end": "2962000"
  },
  {
    "text": "the relational database I'm just going to create this you know normalized view of the data execute a bunch of queries",
    "start": "2923990",
    "end": "2929810"
  },
  {
    "text": "across here but again as we talked about the joins are gonna be very expensive especially as we scale the data set",
    "start": "2929810",
    "end": "2935420"
  },
  {
    "text": "right and I've really noticed a trend I used to say that no SQL is for OLTP at scale if you're not dealing with big",
    "start": "2935420",
    "end": "2941780"
  },
  {
    "text": "data then maybe you should be looking at other technologies and what I'm really finding these days more and more is that",
    "start": "2941780",
    "end": "2947030"
  },
  {
    "text": "the common app is becoming a Big Data app so it's not so much I really do believe these days that no SQL is the",
    "start": "2947030",
    "end": "2953540"
  },
  {
    "text": "future for the vast majority of workloads just simply because of the scale of the data and these relational models break with when I try to execute",
    "start": "2953540",
    "end": "2960680"
  },
  {
    "text": "those complex queries so the no SQL approach here this is a little bit of an eye chart but we're gonna walk through",
    "start": "2960680",
    "end": "2966590"
  },
  {
    "start": "2962000",
    "end": "3016000"
  },
  {
    "text": "it this is all of that entity all those entities stored on the same table the first query I might get is say get me",
    "start": "2966590",
    "end": "2972320"
  },
  {
    "text": "the customers information and I would I would query the table by customer email that's gonna use as the partition key",
    "start": "2972320",
    "end": "2978260"
  },
  {
    "text": "and I would my sort key value would be customer give me the customer item for this customer for this email that gives",
    "start": "2978260",
    "end": "2984920"
  },
  {
    "text": "me nice nice selective query I that customers partition give me the customers orders in the last hour and the last day in the last week I'm just",
    "start": "2984920",
    "end": "2992089"
  },
  {
    "text": "going to timestamp all those orders I'm gonna insert those orders into the customers partition by email now when I",
    "start": "2992089",
    "end": "2997400"
  },
  {
    "text": "query the customers partition by email I used to give me the date range as the as the as the store key condition I'm gonna",
    "start": "2997400",
    "end": "3003490"
  },
  {
    "text": "get a different set of items I'm not going to get the customers metadata I'm gonna get the orders that the customer gave over that time period that I've",
    "start": "3003490",
    "end": "3009250"
  },
  {
    "text": "specified so again I'm slicing the data into these partitions a you know out of these partitions to support the specific",
    "start": "3009250",
    "end": "3015010"
  },
  {
    "text": "access patterns of the application I want to get the vendor data anyone from Austin Austin to there you go you should",
    "start": "3015010",
    "end": "3022660"
  },
  {
    "start": "3016000",
    "end": "3069000"
  },
  {
    "text": "recognize these vendors so my favorite restaurants if you're ever in Austin go to Torchy's",
    "start": "3022660",
    "end": "3028750"
  },
  {
    "text": "tacos look the best barbecue in Austin in Salt Lake anyway so I get the vendors",
    "start": "3028750",
    "end": "3033849"
  },
  {
    "text": "data I just select by the vendor ID and I want to get the driver data I'm going to select by the drivers email I'm",
    "start": "3033849",
    "end": "3041900"
  },
  {
    "text": "gonna don't want the driver item in this particular example the drivers are drivers and the customers are customers",
    "start": "3041900",
    "end": "3047180"
  },
  {
    "text": "but nothing prevents me from using the same email for a driver and a customer I would have different metadata or different items in those partitions they",
    "start": "3047180",
    "end": "3053780"
  },
  {
    "text": "would all be they would still support the same selective access patterns as we even go further I want the drivers",
    "start": "3053780",
    "end": "3059930"
  },
  {
    "text": "status by five-minute ten-minute status 5 minute 10 minute status I can get that by driver just saying select by driver",
    "start": "3059930",
    "end": "3067310"
  },
  {
    "text": "starts with GPS we go oh and then we go into the indexing so the indexing is",
    "start": "3067310",
    "end": "3072770"
  },
  {
    "start": "3069000",
    "end": "3120000"
  },
  {
    "text": "about overloading the key so if you look at the key attributes on these items the order items are going to be sorted on",
    "start": "3072770",
    "end": "3078260"
  },
  {
    "text": "the indexes by email and by order ID and email by vendor ID and and date across",
    "start": "3078260",
    "end": "3085760"
  },
  {
    "text": "gsi 1 and GSI 2 then as we get into the drivers GSI one is totally different it's not using the same key values but",
    "start": "3085760",
    "end": "3092900"
  },
  {
    "text": "it's overloaded using the same name for the attribute so we'll see when we get to the index these eyes actually show up",
    "start": "3092900",
    "end": "3098030"
  },
  {
    "text": "but I'm indexing the drivers GPS coordinates by sector because when a vendors order comes in he's in a",
    "start": "3098030",
    "end": "3104000"
  },
  {
    "text": "particular sector I'm gonna want to know who what driver is gonna be available currently five minutes from now ten is from now whenever that order should be",
    "start": "3104000",
    "end": "3109940"
  },
  {
    "text": "done so I can do my scheduling and then I'm gonna I'm gonna index the order items across those GSIS as well by",
    "start": "3109940",
    "end": "3116810"
  },
  {
    "text": "timestamp and by customer and by timestamp and by vendors so when you look at the GSIS now it's kind of neat",
    "start": "3116810",
    "end": "3123470"
  },
  {
    "start": "3120000",
    "end": "3181000"
  },
  {
    "text": "when I go I could query the GSI one I say query by order ID it's going to give me all the items for the given order",
    "start": "3123470",
    "end": "3128570"
  },
  {
    "text": "it's going to give me the the customer that ordered it that's a nice query I don't have to go back and you know",
    "start": "3128570",
    "end": "3134270"
  },
  {
    "text": "several times to the database to get multi if I have an order I can get all of the metadata that's interesting",
    "start": "3134270",
    "end": "3139370"
  },
  {
    "text": "that's the you know all the details for that or just by querying the GSI by order ID single round-trip this is what",
    "start": "3139370",
    "end": "3144860"
  },
  {
    "text": "we want to do with no SQL data modeling we want single queries to deliver multiple entities in this case the orders that the order that the items for",
    "start": "3144860",
    "end": "3151190"
  },
  {
    "text": "the order and the end the customers information delivered in one query I can query by sector and I can get drivers",
    "start": "3151190",
    "end": "3158630"
  },
  {
    "text": "that are in a given sector and what their current status is in five minute or ten minute intervals using the",
    "start": "3158630",
    "end": "3164120"
  },
  {
    "text": "appropriate sort key conditions right current status five minutes - ten minutes times by sector",
    "start": "3164120",
    "end": "3169250"
  },
  {
    "text": "right so a nice way to be able to solve the Traveling Salesman problem if anyone's familiar with that one that's a tough one this actually is a good way to",
    "start": "3169250",
    "end": "3175850"
  },
  {
    "text": "do that this comes out of a customer you know design review that I had with them",
    "start": "3175850",
    "end": "3180980"
  },
  {
    "text": "that was a problem they were trying to solve I go back to GSI to now I can query a GSI to buy vendor ID and created",
    "start": "3180980",
    "end": "3187370"
  },
  {
    "start": "3181000",
    "end": "3225000"
  },
  {
    "text": "GSI to buy driver ID and get the orders by vendor by date or orders by driver by",
    "start": "3187370",
    "end": "3194150"
  },
  {
    "text": "date what's the driver delivering what did he deliver in the last hour was my vendor delivering what's he delivered in the",
    "start": "3194150",
    "end": "3200210"
  },
  {
    "text": "last hour right so these are the access patterns the application they give me the ability to support all of those you",
    "start": "3200210",
    "end": "3207110"
  },
  {
    "text": "know complex access patterns I've got the entire entity relationship model stored in a single table I have only two",
    "start": "3207110",
    "end": "3213380"
  },
  {
    "text": "gs eyes so the other thing I hear a lot with DynamoDB is you know you only have five GSI is we can't we can't use",
    "start": "3213380",
    "end": "3219890"
  },
  {
    "text": "DynamoDB because we only have five GSI is I just showed you either support 12 access patterns with with this three-d-- with just two GSI the table now let's",
    "start": "3219890",
    "end": "3226550"
  },
  {
    "start": "3225000",
    "end": "3232000"
  },
  {
    "text": "get into a real-world example which is even a lot more complex and when we talk about this service this is the audible",
    "start": "3226550",
    "end": "3233150"
  },
  {
    "start": "3232000",
    "end": "3295000"
  },
  {
    "text": "eBook sync service this is how many people have a Kindle ok quite a few if",
    "start": "3233150",
    "end": "3238940"
  },
  {
    "text": "you have Kindle you have and every ebook you buy there's a you have access if you have a Prime membership if you have",
    "start": "3238940",
    "end": "3244190"
  },
  {
    "text": "access to the audible ebook version and the audible ebook is obviously just you",
    "start": "3244190",
    "end": "3250220"
  },
  {
    "text": "know when you play on your Kindle device you play on other devices there's a lot of different relationships in this",
    "start": "3250220",
    "end": "3256070"
  },
  {
    "text": "service that need to be supported so given a book and have multiple audio products associated to it because it",
    "start": "3256070",
    "end": "3261800"
  },
  {
    "text": "depends on the device that's being played on the format of the audio files that need to be to played an audio product can have many audio audio files",
    "start": "3261800",
    "end": "3268930"
  },
  {
    "text": "so there's a many to many mapping between ebooks audio products audio and",
    "start": "3268930",
    "end": "3274310"
  },
  {
    "text": "and and then the ACR info table is the sync file information so if I pull into the driveway listening to it on my Alexa",
    "start": "3274310",
    "end": "3280160"
  },
  {
    "text": "in my car and I walkie and I start listening to it on my laptop or my Kindle I'm gonna want it to start at the",
    "start": "3280160",
    "end": "3285560"
  },
  {
    "text": "same place that there that ACR info file has a many to many relationship between itself and the and the audio products",
    "start": "3285560",
    "end": "3292670"
  },
  {
    "text": "and so these guys were out there trying to figure out that a lot of downstream and upstream consumers had 20 access",
    "start": "3292670",
    "end": "3297710"
  },
  {
    "start": "3295000",
    "end": "3318000"
  },
  {
    "text": "patterns they're trying to figure out how to deal with all of this with five sighs right select by ebooks key you",
    "start": "3297710",
    "end": "3303050"
  },
  {
    "text": "select by a since like you know all kinds of different access patterns engine support ACR info a CRS and and so",
    "start": "3303050",
    "end": "3309980"
  },
  {
    "text": "they're having a terrible time trying to map the data into a single table implementation and they're trying and",
    "start": "3309980",
    "end": "3315859"
  },
  {
    "text": "he's thinking about going down the relational approach when we came in we gave him a pretty simple table structure as they insert the audio books into the",
    "start": "3315859",
    "end": "3323750"
  },
  {
    "start": "3318000",
    "end": "3391000"
  },
  {
    "text": "table one of the things they were interested in was the audit trail when the a book a CR file change they want to",
    "start": "3323750",
    "end": "3329630"
  },
  {
    "text": "know who changed it and why so we gave him that v-0 design pattern so they can implement and the other current item has",
    "start": "3329630",
    "end": "3334730"
  },
  {
    "text": "always be zero on the a book a CR we you know we have two partitions on the table",
    "start": "3334730",
    "end": "3340130"
  },
  {
    "text": "we have the abled partition we have an e book partition and then there's an item that we insert into the a book a CR",
    "start": "3340130",
    "end": "3345350"
  },
  {
    "text": "partition that associates the a book a CR to the e-book so once we have all",
    "start": "3345350",
    "end": "3350660"
  },
  {
    "text": "this data laid out then what we've done is created the GS is there's three GS is on this table if you notice that the GSI",
    "start": "3350660",
    "end": "3356540"
  },
  {
    "text": "1 GS i2 and GSI 3 don't always contain the same data type and this is because",
    "start": "3356540",
    "end": "3362510"
  },
  {
    "text": "again there's so many different access patterns and what ends up happening is on the table on the GS is that looks",
    "start": "3362510",
    "end": "3367850"
  },
  {
    "text": "like nonsense it's just a bunch of items sorted by all kinds of arbitrary dimensions I mean one particular GSI is",
    "start": "3367850",
    "end": "3374210"
  },
  {
    "text": "totally you know who knows why I mean I might query buy a bookcase in a book SKU across multiple GS eyes by pulling",
    "start": "3374210",
    "end": "3380690"
  },
  {
    "text": "different items out what ends up happening here is that the computer is what's reading it thus or key is what",
    "start": "3380690",
    "end": "3385760"
  },
  {
    "text": "defines what comes back off to the GSI and we ended up doing was just of taking their 20 access patterns and extending",
    "start": "3385760",
    "end": "3392810"
  },
  {
    "start": "3391000",
    "end": "3456000"
  },
  {
    "text": "the table so to speak again big eye chart here but it's not terribly difficult if you look at the first three columns that's what they gave us then",
    "start": "3392810",
    "end": "3399530"
  },
  {
    "text": "what we said is ok you query this table or this index with this sort key condition and these filter conditions",
    "start": "3399530",
    "end": "3405260"
  },
  {
    "text": "and that will satisfy your access pattern so these guys basically we did three indexes one table 20 different",
    "start": "3405260",
    "end": "3413180"
  },
  {
    "text": "access patterns I have satisfied I've done single table designs for",
    "start": "3413180",
    "end": "3418390"
  },
  {
    "text": "applications that need to satisfy up to 30 or 40 different access patterns okay with extremely complex",
    "start": "3418390",
    "end": "3425290"
  },
  {
    "text": "yu-er DS as a matter of fact we have a really good chunk of information up there on the website for you it's the",
    "start": "3425290",
    "end": "3431460"
  },
  {
    "text": "the best practices for Amazon's DynamoDB was just updated about six months ago brand new content and it has a really",
    "start": "3431460",
    "end": "3439680"
  },
  {
    "text": "complex schema in there these 27 tables 30 different access patterns that shows you how to map the whole thing into a",
    "start": "3439680",
    "end": "3446280"
  },
  {
    "text": "single table so I would definitely recommend that people take a look at that it talks about an extended design",
    "start": "3446280",
    "end": "3451410"
  },
  {
    "text": "patterns a lot more than what I've talked about today and I'm totally running out of time but I have one more",
    "start": "3451410",
    "end": "3456930"
  },
  {
    "start": "3456000",
    "end": "3470000"
  },
  {
    "text": "thing to talk about just gonna take a minute it's a serverless paradigm and if it's you know one of the things about I",
    "start": "3456930",
    "end": "3462780"
  },
  {
    "text": "like this quote because it's a you know Linda's Torvalds told us right it was cheap home computing that changed his",
    "start": "3462780",
    "end": "3468300"
  },
  {
    "text": "life well think about cheap data center infrastructure because that's what service is this is a really good example of application we built for Amazon CTO",
    "start": "3468300",
    "end": "3474950"
  },
  {
    "start": "3470000",
    "end": "3565000"
  },
  {
    "text": "or for I'm sorry Amazon's essay organization the they wanted to be able to get customer feedback anytime",
    "start": "3474950",
    "end": "3481290"
  },
  {
    "text": "feedback so if you get an email from an Amazon essay it's going to have a link in the signature it says you know rate",
    "start": "3481290",
    "end": "3487560"
  },
  {
    "text": "my interaction when you click that link you're actually interacting with this application it has a pull down an HTML",
    "start": "3487560",
    "end": "3495030"
  },
  {
    "text": "form from a secure s3 bucket when you hit the post button on that form it interacts with the API gateway API",
    "start": "3495030",
    "end": "3501210"
  },
  {
    "text": "gateway calls the lambda function to process that data when we wrote the application it was we didn't have",
    "start": "3501210",
    "end": "3506850"
  },
  {
    "text": "encryption at rest so we actually had to push the personally identifiable information up into us into an encrypted",
    "start": "3506850",
    "end": "3511920"
  },
  {
    "text": "s3 bucket now we can I'm sure they've actually changed the application to store at all on the Dynamo table and",
    "start": "3511920",
    "end": "3517080"
  },
  {
    "text": "that unencrypted searchable meta data was stored on dynamodb originally and then we would email the manager and let",
    "start": "3517080",
    "end": "3523530"
  },
  {
    "text": "them know that feedback had come in really neat application we built very quickly it just took us about a day or",
    "start": "3523530",
    "end": "3529020"
  },
  {
    "text": "two to actually design and deploy it deploys for pennies a month is the support cost on this right and and the",
    "start": "3529020",
    "end": "3536280"
  },
  {
    "text": "nice thing about this applications if you could scale to a mutant a million users if it had to all I need to do is",
    "start": "3536280",
    "end": "3541320"
  },
  {
    "text": "turn auto-scaling on on that dynamodb table and it goes so that's a really neat aspect of service is that you can",
    "start": "3541320",
    "end": "3547590"
  },
  {
    "text": "really get things out there you can deploy it it's cheap that code just sits there until people actually need it you can prove the application before you pay",
    "start": "3547590",
    "end": "3554310"
  },
  {
    "text": "for it it's not just fail fast its fail cheap now right this is the cheapest data center infrastructure you're ever going",
    "start": "3554310",
    "end": "3560370"
  },
  {
    "text": "to get your hands on for launching new application services so I def I recommend you explore that surrealist framework so conclusions no SQL is not",
    "start": "3560370",
    "end": "3569060"
  },
  {
    "start": "3565000",
    "end": "3595000"
  },
  {
    "text": "non-relational don't use that word it's a bad description ok the ER D still matters relational database is not",
    "start": "3569060",
    "end": "3576020"
  },
  {
    "text": "deprecated but we want to use no SQL for oil TB database the royalty P or DSS at",
    "start": "3576020",
    "end": "3581420"
  },
  {
    "text": "scale that's the sweet spot and then use that our DBMS for your OLAP or oil DP",
    "start": "3581420",
    "end": "3586730"
  },
  {
    "text": "when scales not so important generally speaking the common case is the big data case today so thank you very much that's",
    "start": "3586730",
    "end": "3592970"
  },
  {
    "text": "why I have for you today [Applause]",
    "start": "3592970",
    "end": "3597550"
  }
]