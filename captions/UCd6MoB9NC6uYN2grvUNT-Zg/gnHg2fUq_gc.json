[
  {
    "start": "0",
    "end": "20000"
  },
  {
    "text": "- [Matt] Hello, and welcome to the \"Microsoft on AWS\nModernization\" series, Part 3: Serverless and Container Best Practices.\"",
    "start": "1210",
    "end": "9420"
  },
  {
    "text": "This video builds on Part 1 and Part 2 of the \"Microsoft on AWS\nModernization\" series.",
    "start": "9420",
    "end": "15400"
  },
  {
    "text": "So check those out if you haven't already. Let's get started!",
    "start": "15400",
    "end": "19093"
  },
  {
    "start": "20000",
    "end": "126000"
  },
  {
    "text": "In the first video in this series, we can covered the\nbenefits of modernizing. We explored how modernizing\ncan reduce operational costs",
    "start": "21020",
    "end": "29849"
  },
  {
    "text": "while improving productivity. Modernizing can drive unnecessary cost",
    "start": "29850",
    "end": "35090"
  },
  {
    "text": "out of the architecture while improving operational resilience, using best practices in\nthe cloud for failover,",
    "start": "35090",
    "end": "41910"
  },
  {
    "text": "high availability and disaster recovery. Modernizing will also\nimprove business agility,",
    "start": "41910",
    "end": "48960"
  },
  {
    "text": "the ability to react quickly\nto changing market conditions.",
    "start": "48960",
    "end": "52633"
  },
  {
    "text": "In the second video in this series, we discussed breaking a\nmonolithic application into microservices.",
    "start": "54290",
    "end": "61020"
  },
  {
    "text": "We covered some of the\nbenefits of microservices and how teams can adapt to a\nmicroservices architecture.",
    "start": "61020",
    "end": "67173"
  },
  {
    "text": "Because a microservices\narchitecture is loosely coupled, we can change one service",
    "start": "68070",
    "end": "73400"
  },
  {
    "text": "without making changes to anything else. We'll discuss some\nservice-specific deployments",
    "start": "73400",
    "end": "79930"
  },
  {
    "text": "in detail in this video. In order to get the\nbenefits of microservices",
    "start": "79930",
    "end": "85340"
  },
  {
    "text": "without having to completely rewrite the entire application all at once, we decided to use the\nStrangler Fig pattern.",
    "start": "85340",
    "end": "93360"
  },
  {
    "text": "The name of this pattern\nis based on a type of vine that gradually wraps around a tree",
    "start": "93360",
    "end": "99509"
  },
  {
    "text": "and eventually replaces that tree with, you could say, a new architecture.",
    "start": "99510",
    "end": "104323"
  },
  {
    "text": "So instead of modernizing\nthe entire monolith all at once in a Big\nBang sort of deployment,",
    "start": "105210",
    "end": "111649"
  },
  {
    "text": "we'll use the Strangler Fig pattern to incrementally replace the\nfunctionality of the monolith",
    "start": "111650",
    "end": "117500"
  },
  {
    "text": "with new microservices. Eventually, the new microservices will completely replace the monolith.",
    "start": "117500",
    "end": "124473"
  },
  {
    "text": "Further videos in this series cover additional modernization topics. Part 4 covers migrating and\nmodernizing database workloads,",
    "start": "127390",
    "end": "136580"
  },
  {
    "text": "going from a single one size\nfits all relational approach, to using a variety of\npurpose-built database engines",
    "start": "136580",
    "end": "143070"
  },
  {
    "text": "optimized for each microservice. Part 5 covers setting up a data lake",
    "start": "143070",
    "end": "149200"
  },
  {
    "text": "to drive analytics and insights across all current and\nfuture microservices.",
    "start": "149200",
    "end": "154002"
  },
  {
    "text": "And Part 6 covers a\nmodernized DevOps workflow that lets us deploy updates\nto microservices code",
    "start": "155435",
    "end": "162049"
  },
  {
    "text": "in a predictable automated way. So, check those out once\nyou finish this video.",
    "start": "162050",
    "end": "167853"
  },
  {
    "text": "In addition to this series, AWS has a variety of content covering optimization\nof Microsoft workloads.",
    "start": "168950",
    "end": "176400"
  },
  {
    "text": "I want to highlight two in particular. First, the optimization\nseries Part 1 video",
    "start": "176400",
    "end": "183129"
  },
  {
    "text": "covers optimizing infrastructure\nand licensing costs on AWS, including the AWS optimization\nand licensing assessment.",
    "start": "183130",
    "end": "191770"
  },
  {
    "text": "Microsoft's licensing\nterms can be complex. And this video covers\nsome of the considerations",
    "start": "191770",
    "end": "197640"
  },
  {
    "text": "for optimizing your workloads\nand estimating costs. Also, Part 4 of the optimization series",
    "start": "197640",
    "end": "205340"
  },
  {
    "text": "covers Amazon FSX, which is a fully managed\nWindows-compatible network file share.",
    "start": "205340",
    "end": "212010"
  },
  {
    "text": "You can set up an Elastic network share without having to manage\nany server infrastructure.",
    "start": "212010",
    "end": "217593"
  },
  {
    "text": "As a reminder, in this webinar series, we are centering on a fictional company,",
    "start": "219880",
    "end": "225250"
  },
  {
    "text": "Acme Financial Data Services, or AFDS, to demonstrate key\nmodernization practices.",
    "start": "225250",
    "end": "231583"
  },
  {
    "text": "The practices we'll\ncover have been applied to real AWS customers. We are reproducing those practices here",
    "start": "232630",
    "end": "239520"
  },
  {
    "text": "and applying them to AFDS. In Phase 1 of their cloud journey,",
    "start": "239520",
    "end": "245670"
  },
  {
    "text": "AFDS completed a lift-and-shift to AWS. This has replicated their\non-premises infrastructure",
    "start": "245670",
    "end": "253010"
  },
  {
    "text": "in the AWS cloud. In Phase 2, AFDS performed\na number of optimizations",
    "start": "253010",
    "end": "260239"
  },
  {
    "text": "on their AWS infrastructure. You can find some examples\nof these practices",
    "start": "260240",
    "end": "265599"
  },
  {
    "text": "in the \"Windows on AWS\nOptimization\" video series.",
    "start": "265600",
    "end": "269653"
  },
  {
    "text": "Even though these\noptimizations did produce some cost savings and\nperformance benefits,",
    "start": "271290",
    "end": "276620"
  },
  {
    "text": "AFDS wants to take the next step and modernize their legacy\n.NET Framework applications.",
    "start": "276620",
    "end": "282772"
  },
  {
    "text": "This modernization will transform\nthese legacy applications so they take full advantage\nof running in the cloud.",
    "start": "283990",
    "end": "290563"
  },
  {
    "text": "Specifically, we are modernizing\nAFDS' One Vision platform.",
    "start": "291860",
    "end": "296732"
  },
  {
    "text": "This is a monolithic platform designed to manage customer accounts, customer invoices,",
    "start": "297570",
    "end": "303389"
  },
  {
    "text": "and the associated inventory. To start on this modernization journey,",
    "start": "303390",
    "end": "309230"
  },
  {
    "text": "we looked for microservices that were both easy to extract out of the monolith and provided significant business value",
    "start": "309230",
    "end": "316100"
  },
  {
    "text": "to run independently. We selected three services to extract,",
    "start": "316100",
    "end": "321590"
  },
  {
    "text": "account management,\ninvoicing, and inventory. We encapsulated those services",
    "start": "321590",
    "end": "327490"
  },
  {
    "text": "into their own .NET Framework projects. And now we want to\nmodernize our deployment",
    "start": "327490",
    "end": "332850"
  },
  {
    "text": "of those microservices on AWS. In this video, we'll\ncover some of the benefits",
    "start": "332850",
    "end": "339650"
  },
  {
    "text": "of converting these\nmicroservices to .NET Core and how to move forward with\nservices we can't convert.",
    "start": "339650",
    "end": "345853"
  },
  {
    "text": "We'll decide whether to use serverless or containers for each microservice.",
    "start": "346890",
    "end": "350590"
  },
  {
    "text": "And for the microservices that\nwe deploy using containers, we'll discuss how to choose\nan orchestration platform",
    "start": "352000",
    "end": "358350"
  },
  {
    "text": "and a compute platform to\nrun those containers on AWS.",
    "start": "358350",
    "end": "361927"
  },
  {
    "start": "364000",
    "end": "496000"
  },
  {
    "text": "Let's start with containers. Why would we want to run microservices in containers in the first place?",
    "start": "365370",
    "end": "371650"
  },
  {
    "text": "Although you can run\nmicroservices on EC2 instances, a microservice architecture is a great fit",
    "start": "371650",
    "end": "378260"
  },
  {
    "text": "for running in containers. Typically in this architecture, each microservice is running\nin its own container.",
    "start": "378260",
    "end": "385563"
  },
  {
    "text": "This has a number of benefits. First, just like each microservice",
    "start": "386410",
    "end": "391850"
  },
  {
    "text": "is independent from other microservices, each container is isolated\nfrom other containers.",
    "start": "391850",
    "end": "398053"
  },
  {
    "text": "Containers manage dependencies and abstract away the underlying platform, which creates a consistent,\nportable environment",
    "start": "399350",
    "end": "407159"
  },
  {
    "text": "from developer machines, all the way up to test\nand production servers. Developers using containers",
    "start": "407160",
    "end": "413740"
  },
  {
    "text": "have a lot fewer Works\non My Machine problems.",
    "start": "413740",
    "end": "417393"
  },
  {
    "text": "Containers are easy to scale up and down based on the needs of each microservice.",
    "start": "419270",
    "end": "424210"
  },
  {
    "text": "If a service receives a\nsudden spike of traffic, it's fast and easy to\nlaunch additional containers",
    "start": "425240",
    "end": "431300"
  },
  {
    "text": "to take up the load. Once the traffic spike is over, you can quickly stop the extra containers",
    "start": "431300",
    "end": "437650"
  },
  {
    "text": "to free up resources. And that scalability also\nmakes containers reliable.",
    "start": "437650",
    "end": "444120"
  },
  {
    "text": "You can achieve fault tolerance by running multiple containers across a cluster of servers.",
    "start": "444120",
    "end": "449823"
  },
  {
    "text": "If one of those containers\nfails for whatever reason, it's fast and easy to\nlaunch a replacement.",
    "start": "450940",
    "end": "456683"
  },
  {
    "text": "Container orchestration platforms, like Amazon Elastic Container Service and Elastic Kubernetes Service",
    "start": "457630",
    "end": "464460"
  },
  {
    "text": "automate tasks like\nrelaunching failed containers to minimize downtime.",
    "start": "464460",
    "end": "468623"
  },
  {
    "text": "Finally, containers let you make better use of your infrastructure. On AWS, the orchestration services",
    "start": "470340",
    "end": "477409"
  },
  {
    "text": "place containers on EC2 instances to achieve both fault tolerance and efficient utilization\nof the available resources.",
    "start": "477410",
    "end": "485303"
  },
  {
    "text": "So containers are a great\nfit for microservices, but there are some challenges running a .NET Framework\napplication in a container.",
    "start": "487040",
    "end": "495393"
  },
  {
    "start": "496000",
    "end": "639000"
  },
  {
    "text": "Whenever feasible, update your microservices\nto use .NET Core, soon to be called .NET 5\ninstead of .NET Framework.",
    "start": "496890",
    "end": "505462"
  },
  {
    "text": "Updating to .NET Core\ngives you more flexibility in how you deploy your microservices and typically reduces your costs",
    "start": "506640",
    "end": "513890"
  },
  {
    "text": "by running more efficiently. Let's go over three major\nadvantages of .NET Core.",
    "start": "513890",
    "end": "520133"
  },
  {
    "text": "In 2019, Microsoft announced that the current version of the\n.NET Framework, version 4.8,",
    "start": "522450",
    "end": "528730"
  },
  {
    "text": "would be the final major release. The .NET Framework is still receiving critical security and reliability updates",
    "start": "528730",
    "end": "536519"
  },
  {
    "text": "but it won't receive new\nfeatures or improvements. All new development is\nshifting to .NET Core.",
    "start": "536520",
    "end": "542823"
  },
  {
    "text": ".NET Core is more modular, flexible, and lightweight than .NET Framework. So it's easy to include\nonly the libraries you need",
    "start": "545087",
    "end": "553190"
  },
  {
    "text": "inside each microservice. This results in smaller services that are faster to start",
    "start": "553190",
    "end": "559470"
  },
  {
    "text": "and run more efficiently. The .NET Framework is\nlimited to Windows only,",
    "start": "559470",
    "end": "565370"
  },
  {
    "text": "but .NET Core is cross-platform. .NET Core microservices\nrun on Windows or Linux.",
    "start": "565370",
    "end": "572720"
  },
  {
    "text": "In many cases, running .NET Core on Linux provides better performance\nat a lower cost.",
    "start": "572720",
    "end": "578593"
  },
  {
    "text": "All of these benefits of .NET Core are especially relevant to microservices. One advantage of the Strangler Fig pattern",
    "start": "581360",
    "end": "589080"
  },
  {
    "text": "is that you don't have to port your entire code base all at once. Different microservices can\nuse different languages.",
    "start": "589080",
    "end": "596770"
  },
  {
    "text": "That's part of the power of\nthe microservices architecture. So once you've to each microservice,",
    "start": "596770",
    "end": "603360"
  },
  {
    "text": "you can evaluate whether\nthat particular service is a good candidate to be ported.",
    "start": "603360",
    "end": "607962"
  },
  {
    "text": "To help you along this journey, in July, 2020, AWS released\nthe porting assistant for .NET,",
    "start": "609780",
    "end": "616490"
  },
  {
    "text": "which scans .NET Framework assemblies and generates a compatibility assessment.",
    "start": "616570",
    "end": "621333"
  },
  {
    "text": "This tool identifies .NET\nFramework dependencies and APIs that are incompatible with .NET Core",
    "start": "622460",
    "end": "629450"
  },
  {
    "text": "and finds known replacements\nwhere applicable. This helps reduce the manual effort needed",
    "start": "629450",
    "end": "636000"
  },
  {
    "text": "to port your code. When you can update your\ncode to .NET Core, great.",
    "start": "636000",
    "end": "644210"
  },
  {
    "start": "639000",
    "end": "740000"
  },
  {
    "text": "Doing that conversion\nwill expand your options in some significant and valuable ways.",
    "start": "644210",
    "end": "649473"
  },
  {
    "text": "But we heard from customers\nthat had applications that they weren't able to update. Maybe the application\ndepends on a legacy library",
    "start": "650650",
    "end": "658470"
  },
  {
    "text": "that is .NET Framework only. Or maybe the application\nis using some APIs",
    "start": "658470",
    "end": "663680"
  },
  {
    "text": "that are specific to the\n.NET Framework or to Windows. In these cases,",
    "start": "663680",
    "end": "669510"
  },
  {
    "text": "you can use AWS App2Container, or A2C, to package up these .NET\nFramework applications",
    "start": "669510",
    "end": "676360"
  },
  {
    "text": "into containers so you can deploy them on\na modernized infrastructure even when you can't update the code.",
    "start": "676360",
    "end": "682923"
  },
  {
    "text": "A2C is a new command line tool that helps transform existing\napplications into containers",
    "start": "684230",
    "end": "690660"
  },
  {
    "text": "without needing any code changes. A2C discovers applications\nrunning on a server,",
    "start": "690660",
    "end": "697080"
  },
  {
    "text": "identifies dependencies, and generates artifacts so that you can seamlessly\ndeploy the application",
    "start": "697080",
    "end": "703100"
  },
  {
    "text": "as a container on AWS. On the .NET side,",
    "start": "703100",
    "end": "708589"
  },
  {
    "text": "A2C supports ASP.NET web applications using .NET Framework 3.5 or later,",
    "start": "708590",
    "end": "714839"
  },
  {
    "text": "running an IIS 7.5 and up. A2C packages these applications\ninto Windows containers.",
    "start": "714840",
    "end": "722162"
  },
  {
    "text": "We'll cover some deployment scenarios for these Windows containers\nlater in this video.",
    "start": "723190",
    "end": "727573"
  },
  {
    "text": "Now let's shift back to microservices that can be ported to .NET Core. Containers are not the only option",
    "start": "729330",
    "end": "736380"
  },
  {
    "text": "for running these microservices on AWS.",
    "start": "736380",
    "end": "738647"
  },
  {
    "start": "740000",
    "end": "838000"
  },
  {
    "text": "For microservices that can\nbe ported to .NET Core, consider running them in AWS Lambda.",
    "start": "742340",
    "end": "748193"
  },
  {
    "text": "Lambda is serverless. It lets you run code without provisioning or managing any infrastructure.",
    "start": "749090",
    "end": "756040"
  },
  {
    "text": "You only pay for the resources used while your code is running. Lambda supports a variety",
    "start": "756040",
    "end": "762510"
  },
  {
    "text": "of programming languages and run times including .NET Core\nbut not .NET Framework.",
    "start": "762510",
    "end": "768233"
  },
  {
    "text": "Lambda is a great choice for microservices that can easily be expressed\nas a single function",
    "start": "770560",
    "end": "775940"
  },
  {
    "text": "with few dependencies and use a consistent predictable\namount of CPU and memory.",
    "start": "775940",
    "end": "781493"
  },
  {
    "text": "Lambda is also a great\nchoice for microservices that need to run in response to an event.",
    "start": "782600",
    "end": "787693"
  },
  {
    "text": "Lambda integrates with a wide\nvariety of other AWS services. So you can respond to events",
    "start": "788790",
    "end": "794519"
  },
  {
    "text": "such as an object being\nuploaded to an Amazon S3 bucket or a record written to\nan Amazon DynamoDB table.",
    "start": "794520",
    "end": "801472"
  },
  {
    "text": "You and also execute Lambda\nfunctions in response to events thrown by\nyour own microservices.",
    "start": "802500",
    "end": "807883"
  },
  {
    "text": "On the other hand, microservices are probably\nnot a good fit for Lambda if they include multiple\nfunctions working together",
    "start": "809580",
    "end": "817199"
  },
  {
    "text": "or contain operations that\ntake an unpredictable amount of CPU time and/or memory,",
    "start": "817200",
    "end": "822360"
  },
  {
    "text": "incorporate many external\nlibraries and dependencies, retain persistent connections\nto other resources",
    "start": "822360",
    "end": "828440"
  },
  {
    "text": "such as databases or web sockets, or require reading from\nor writing to a disc.",
    "start": "828440",
    "end": "834740"
  },
  {
    "text": "In these cases, use containers. In the previous videos in this series,",
    "start": "834740",
    "end": "841830"
  },
  {
    "start": "838000",
    "end": "933000"
  },
  {
    "text": "we extracted three\nmicroservices from the monolith. With .NET Core containers, Lambda,",
    "start": "841830",
    "end": "848420"
  },
  {
    "text": "and .NET Framework containers\npackaged by App2Container, we can now make a plan for how to deploy",
    "start": "848420",
    "end": "854639"
  },
  {
    "text": "each of these services on AWS. The account service performs\nfour standard CRUD operations.",
    "start": "854640",
    "end": "863680"
  },
  {
    "text": "That's create, read, update, and delete. These operations are\nself-contained and lightweight.",
    "start": "863680",
    "end": "870480"
  },
  {
    "text": "And the microservice code\ncan be ported to .NET Core. So this microservice is a\ngood candidate for Lambda.",
    "start": "870480",
    "end": "877373"
  },
  {
    "text": "The Invoicing microservice can\nalso be ported to .NET Core using the porting assistant for .NET",
    "start": "879480",
    "end": "885580"
  },
  {
    "text": "to identify areas to work on. But it uses a variable amount of memory",
    "start": "885580",
    "end": "890660"
  },
  {
    "text": "and includes multiple functions. That makes this microservice\na good candidate",
    "start": "890660",
    "end": "895960"
  },
  {
    "text": "to run in a Linux container. Finally, the Inventory microservice",
    "start": "895960",
    "end": "902470"
  },
  {
    "text": "has an important dependency\non a legacy library that uses the .NET Framework.",
    "start": "902470",
    "end": "907623"
  },
  {
    "text": "It isn't currently possible to replace or rewrite this legacy library, so the Inventory microservice\nis a good candidate",
    "start": "908580",
    "end": "915680"
  },
  {
    "text": "to be packaged into a Windows\ncontainer using App2Container.",
    "start": "915680",
    "end": "919912"
  },
  {
    "text": "Now we have our three microservices and we've identified which ones are good candidates for containers.",
    "start": "923360",
    "end": "929770"
  },
  {
    "text": "How can we run those containers on AWS?",
    "start": "929770",
    "end": "932207"
  },
  {
    "start": "933000",
    "end": "1024000"
  },
  {
    "text": "You can run containers on EC2 instances by installing Docker onto an instance",
    "start": "935470",
    "end": "941069"
  },
  {
    "text": "and manually running your containers. This can work if you only have a handful",
    "start": "941070",
    "end": "946570"
  },
  {
    "text": "of containers and services. But this manual approach quickly creates operational challenges as you scale.",
    "start": "946570",
    "end": "953493"
  },
  {
    "text": "For example, if you have\na cluster of instances, you'll need to manage which containers",
    "start": "954620",
    "end": "959850"
  },
  {
    "text": "are running on which instances. You'll want to distribute your containers with an eye to availability.",
    "start": "959850",
    "end": "966880"
  },
  {
    "text": "Typically, you'd want\nto deploy a microservice on multiple instances so that if one instance fails,",
    "start": "966880",
    "end": "973150"
  },
  {
    "text": "the other can take up the load. You'd want to monitor the\nstatus of all of your containers",
    "start": "973150",
    "end": "979200"
  },
  {
    "text": "and replace any containers that fail, ideally in an automated\nway to minimize downtime.",
    "start": "979200",
    "end": "984623"
  },
  {
    "text": "You'd want to deploy additional containers for services that are\nexperiencing high load. Then stop those containers\nonce the load subsides.",
    "start": "986510",
    "end": "994683"
  },
  {
    "text": "And when you deploy a new\nversion of a container, you typically want to make\nsure that the new containers",
    "start": "996320",
    "end": "1001810"
  },
  {
    "text": "are up and running before\nyou stop the old containers. You might even want to do a\nfull blue/green deployment",
    "start": "1001810",
    "end": "1009300"
  },
  {
    "text": "where you keep the old containers running until you switch over to the new version.",
    "start": "1009300",
    "end": "1013963"
  },
  {
    "text": "These operational tasks\nquickly become very complex if you try and do them manually.",
    "start": "1016180",
    "end": "1021540"
  },
  {
    "text": "Fortunately, there's\nan automated solution. To perform all of these\nmanagement operations and more,",
    "start": "1021540",
    "end": "1029150"
  },
  {
    "start": "1024000",
    "end": "1076000"
  },
  {
    "text": "a typical container deployment includes an orchestrator layer. Sometimes this is called a control plane.",
    "start": "1029150",
    "end": "1034740"
  },
  {
    "text": "The orchestrator is a service that runs separately from the containers themselves and handles container\nplacement, monitoring,",
    "start": "1035920",
    "end": "1043370"
  },
  {
    "text": "scaling, configuration, and deployments. You can even set up a private\nnetwork among your containers",
    "start": "1043370",
    "end": "1051070"
  },
  {
    "text": "so they can communicate with each other without going over a public network.",
    "start": "1051070",
    "end": "1055112"
  },
  {
    "text": "The containers themselves\nrun on a compute layer, which is managed by the orchestrator.",
    "start": "1056680",
    "end": "1062670"
  },
  {
    "text": "In this diagram, the compute layer is composed of a cluster\nof three EC2 instances.",
    "start": "1062670",
    "end": "1068860"
  },
  {
    "text": "Each instance has three\ncontainers running on it, placed there by the orchestrator.",
    "start": "1068860",
    "end": "1073573"
  },
  {
    "start": "1076000",
    "end": "1172000"
  },
  {
    "text": "You can run a container orchestrator like Kubernetes or Docker Swarm on EC2.",
    "start": "1078640",
    "end": "1083813"
  },
  {
    "text": "If you do that, you are responsible for setting up and running\nall of the infrastructure.",
    "start": "1085040",
    "end": "1090420"
  },
  {
    "text": "This can be a significant amount of maintenance and operational work. At AWS, we call this kind of work",
    "start": "1090420",
    "end": "1098420"
  },
  {
    "text": "undifferentiated heavy lifting. These are the complex IT processes",
    "start": "1098420",
    "end": "1103770"
  },
  {
    "text": "that are needed in the\nnormal course of business just to keep the lights on. Undifferentiated heavy lifting",
    "start": "1103770",
    "end": "1110530"
  },
  {
    "text": "doesn't provide you with\na competitive advantage.",
    "start": "1110530",
    "end": "1112980"
  },
  {
    "text": "Undifferentiated heavy lifting doesn't provide you with\na competitive advantage, doesn't help you meet your business goals,",
    "start": "1116960",
    "end": "1123510"
  },
  {
    "text": "and, ultimately, doesn't add value to the mission of your company.",
    "start": "1123510",
    "end": "1127350"
  },
  {
    "text": "One of our goals at AWS\nis to reduce or eliminate undifferentiated heavy\nlifting for our customers.",
    "start": "1128520",
    "end": "1135372"
  },
  {
    "text": "To do this for containers, AWS offers two fully managed container orchestration services,",
    "start": "1136740",
    "end": "1143600"
  },
  {
    "text": "Amazon Elastic Kubernetes Service or EKS, and Amazon Elastic\nContainer Service or ECS.",
    "start": "1143600",
    "end": "1151333"
  },
  {
    "text": "Both EKS and ECS provide container\norchestration capabilities,",
    "start": "1153200",
    "end": "1158559"
  },
  {
    "text": "helping you deploy, scale and manage containerized applications.",
    "start": "1158560",
    "end": "1163150"
  },
  {
    "text": "Both of these services are\nused by many AWS customers for enterprise-scale production workloads.",
    "start": "1163990",
    "end": "1170893"
  },
  {
    "start": "1172000",
    "end": "1220000"
  },
  {
    "text": "Let's discuss the Elastic\nKubernetes Service first. Kubernetes is a leading open source",
    "start": "1173910",
    "end": "1180659"
  },
  {
    "text": "container orchestration platform. Again, you can run a Kubernetes cluster",
    "start": "1180660",
    "end": "1185830"
  },
  {
    "text": "on your own EC2 instances, but EKS provides a fully\nmanaged Kubernetes environment",
    "start": "1185830",
    "end": "1192110"
  },
  {
    "text": "that lets you focus on your containers while AWS runs the\nKubernetes control plane.",
    "start": "1192110",
    "end": "1197323"
  },
  {
    "text": "EKS delivers full compatibility.",
    "start": "1198830",
    "end": "1201163"
  },
  {
    "text": "EKS delivers full compatibility\nwith upstream Kubernetes while integrating with AWS services",
    "start": "1206040",
    "end": "1212120"
  },
  {
    "text": "such as Amazon CloudWatch, Amazon EC2 Auto Scaling groups, and Amazon Virtual Private Cloud.",
    "start": "1212120",
    "end": "1218943"
  },
  {
    "start": "1220000",
    "end": "1277000"
  },
  {
    "text": "As an alternative to Kubernetes, Amazon Elastic Container Service, or ECS,",
    "start": "1221420",
    "end": "1227750"
  },
  {
    "text": "is a fully managed container\norchestration platform developed by Amazon.",
    "start": "1227750",
    "end": "1232492"
  },
  {
    "text": "ECS is built on technologies developed from many years of experience running highly scalable services.",
    "start": "1233960",
    "end": "1239763"
  },
  {
    "text": "ECS is built on technologies\nthat have been developed over many years of experience running highly scalable services",
    "start": "1245360",
    "end": "1252320"
  },
  {
    "text": "and is used extensively within Amazon to power services such\nas Amazon SageMaker,",
    "start": "1252320",
    "end": "1258019"
  },
  {
    "text": "AWS Batch, and the recommendation\nengine for amazon.com.",
    "start": "1258019",
    "end": "1262083"
  },
  {
    "text": "ECS natively integrates with AWS services, including Amazon Route 53,",
    "start": "1263280",
    "end": "1268957"
  },
  {
    "text": "AWS Secrets Manager, Amazon CloudWatch, Elastic Load Balancing, AWS App Mesh and more.",
    "start": "1268957",
    "end": "1275903"
  },
  {
    "start": "1277000",
    "end": "1349000"
  },
  {
    "text": "So how do you choose between EKS and ECS?",
    "start": "1278880",
    "end": "1282870"
  },
  {
    "text": "So how do you choose between EKS and ECS? If you've already chosen Kubernetes",
    "start": "1296380",
    "end": "1302500"
  },
  {
    "text": "as your orchestrator of choice, for example, if you already\nhave a Kubernetes cluster running on-premises,",
    "start": "1302500",
    "end": "1309060"
  },
  {
    "text": "consider EKS first. EKS is upstream Kubernetes.",
    "start": "1309060",
    "end": "1314480"
  },
  {
    "text": "It's fully compatible. So Kubernetes clusters\nthat you run anywhere else are easy to pick up and move into EKS.",
    "start": "1314480",
    "end": "1321653"
  },
  {
    "text": "However, Kubernetes has a\npretty steep learning curve. So if you're just starting\nout with containers",
    "start": "1323150",
    "end": "1329070"
  },
  {
    "text": "or if you aren't committed to\none particular orchestrator, consider ECS first.",
    "start": "1329070",
    "end": "1334203"
  },
  {
    "text": "ECS makes it easier to get up\nand running with containers and natively integrates with\nthe rest of the AWS platform.",
    "start": "1335130",
    "end": "1341722"
  },
  {
    "text": "That covers the orchestrator layer. Now let's talk about options\nfor the compute layer.",
    "start": "1343230",
    "end": "1348143"
  },
  {
    "start": "1349000",
    "end": "1522000"
  },
  {
    "text": "In addition to a choice of two fully managed orchestrator services, you also have multiple options",
    "start": "1351010",
    "end": "1356929"
  },
  {
    "text": "for how to run your compute layer. As a reminder, this layer provides",
    "start": "1356930",
    "end": "1362070"
  },
  {
    "text": "the actual computing resources, CPU, memory, et cetera, that actually run your containers.",
    "start": "1362070",
    "end": "1368242"
  },
  {
    "text": "For your compute layer, you can use a cluster\nof Amazon EC2 instances.",
    "start": "1369840",
    "end": "1374763"
  },
  {
    "text": "If you're running containers\non an EC2 cluster, the orchestrator creates an Auto Scaling group of EC2 instances",
    "start": "1376020",
    "end": "1383020"
  },
  {
    "text": "and manages the scale out and\nscale in actions of the group. So if one of your\ncontainers needs to scale up",
    "start": "1383020",
    "end": "1390529"
  },
  {
    "text": "but your existing instances\nhave used all of their capacity, the orchestrator will\nadd a new EC2 instance",
    "start": "1390530",
    "end": "1397250"
  },
  {
    "text": "to the cluster. Likewise, if enough containers stop to free up an entire instance,",
    "start": "1397250",
    "end": "1404090"
  },
  {
    "text": "the orchestrator will\nterminate that instance. This way, you only pay\nfor the compute capacity",
    "start": "1404090",
    "end": "1410800"
  },
  {
    "text": "that you're using. The orchestrator automatically\nplaces containers on instances to maximize resource usage.",
    "start": "1410800",
    "end": "1418122"
  },
  {
    "text": "If you're using ECS, all of this EC2 cluster management is automatic and built in.",
    "start": "1420320",
    "end": "1425972"
  },
  {
    "text": "If you're running EKS, you can deploy the Kubernetes\nCluster Autoscaler service",
    "start": "1426940",
    "end": "1432340"
  },
  {
    "text": "into your EKS cluster. This integrates with Auto Scaling groups to provide similar functionality.",
    "start": "1432340",
    "end": "1438993"
  },
  {
    "text": "Alternatively, you can use AWS Fargate, a serverless compute\nengine for containers.",
    "start": "1441100",
    "end": "1447513"
  },
  {
    "text": "Because Fargate, like\nLambda, is serverless, you don't have to provision,\nconfigure or maintain",
    "start": "1448660",
    "end": "1455279"
  },
  {
    "text": "clusters of EC2 instances. You just specify how much CPU and memory",
    "start": "1455280",
    "end": "1460340"
  },
  {
    "text": "each container needs.",
    "start": "1460340",
    "end": "1461583"
  },
  {
    "text": "Because Fargate, like\nLambda, is serverless, you don't have to provision,\nconfigure or manage",
    "start": "1466140",
    "end": "1472370"
  },
  {
    "text": "clusters of EC2 instances. You just specify how much CPU and memory each container needs.",
    "start": "1472370",
    "end": "1478603"
  },
  {
    "text": "Fargate allocates those resources when each container starts up, and reclaims them when\nthe container stops.",
    "start": "1479680",
    "end": "1486252"
  },
  {
    "text": "Each container running on Fargate has its own isolation boundary and doesn't share an OS\nkernel, CPU, or memory",
    "start": "1487500",
    "end": "1495030"
  },
  {
    "text": "with any other container. You can actually mix and\nmatch EC2 and Fargate compute",
    "start": "1495030",
    "end": "1501660"
  },
  {
    "text": "in a single EKS or ECS cluster. So you can specify that some\ncontainer should run on Fargate",
    "start": "1501660",
    "end": "1507730"
  },
  {
    "text": "and some should run on EC2.",
    "start": "1507730",
    "end": "1510122"
  },
  {
    "text": "Just like we discussed how to\ndecide between EKS and ECS, let's now cover how to choose\nbetween EC2 and Fargate.",
    "start": "1513020",
    "end": "1520633"
  },
  {
    "text": "Both EC2 and Fargate are\nused by many AWS customers for scalable, reliable,\nproduction-ready deployments.",
    "start": "1523730",
    "end": "1531742"
  },
  {
    "text": "If your workload has a consistent demand for many CPU cores and\nmany gigabytes of memory,",
    "start": "1533350",
    "end": "1539240"
  },
  {
    "text": "an EC2 cluster may be the\nmost cost-effective option. An EC2 cluster is built based on the cost",
    "start": "1539240",
    "end": "1546500"
  },
  {
    "text": "of the underlying EC2 instances. So you'll want to densely\npack your containers onto your instances",
    "start": "1546500",
    "end": "1552750"
  },
  {
    "text": "or else you'll be paying for\ncapacity you aren't using. An EC2 cluster is also the\nbest option for containers",
    "start": "1552750",
    "end": "1559840"
  },
  {
    "text": "that benefit from a\nspecialized instance type such as GPU or machine learning instances.",
    "start": "1559840",
    "end": "1565283"
  },
  {
    "text": "To optimize your cost on EC2, consider using spot\nand/or reserved instances.",
    "start": "1567970",
    "end": "1573563"
  },
  {
    "text": "Reserved instances are\na great savings option when you have a consistent workload.",
    "start": "1574490",
    "end": "1579570"
  },
  {
    "text": "And spot instances can provide\nan even greater discount for containers that can\ntolerate interruption.",
    "start": "1579570",
    "end": "1585200"
  },
  {
    "text": "The flexibility of EC2 does\ncome with an operational cost.",
    "start": "1587050",
    "end": "1592050"
  },
  {
    "text": "The maintenance and updates of the EC2 instances in the cluster are your responsibility.",
    "start": "1592290",
    "end": "1597403"
  },
  {
    "text": "AWS periodically publishes\nnew machine images with the latest security updates.",
    "start": "1598772",
    "end": "1604090"
  },
  {
    "text": "But even if you use those images, you are still responsible\nfor updating the instances",
    "start": "1604090",
    "end": "1609309"
  },
  {
    "text": "in your cluster to run the latest version. One final note on EC2.",
    "start": "1609310",
    "end": "1615650"
  },
  {
    "text": "As of October, 2020, EC2 is the only compute option that supports Windows containers.",
    "start": "1615650",
    "end": "1622033"
  },
  {
    "text": "Windows containers can run on Linux instances and vice versa. To ensure that containers are placed",
    "start": "1623100",
    "end": "1629760"
  },
  {
    "text": "on the correct operating system, we recommend that you run\nWindows and Linux containers",
    "start": "1629760",
    "end": "1635020"
  },
  {
    "text": "in separate clusters. On the other hand, if your\nworkload is highly variable,",
    "start": "1635020",
    "end": "1642840"
  },
  {
    "text": "look at Fargate first. With Fargate, you don't need to allocate CPU or memory capacity ahead of time.",
    "start": "1642840",
    "end": "1650670"
  },
  {
    "text": "When you start a container, Fargate allocates the\nCPU and memory resources that the container needs.",
    "start": "1650670",
    "end": "1657809"
  },
  {
    "text": "This makes Fargate the\noptimal choice for workloads that have variable or\nunpredictable resource usage.",
    "start": "1657810",
    "end": "1663693"
  },
  {
    "text": "For example, if a microservice sees a lot of usage during business hours but very little usage overnight,",
    "start": "1666080",
    "end": "1673370"
  },
  {
    "text": "then deploying that\nmicroservice on Fargate will let the service scale down to one tiny container during off hours",
    "start": "1673370",
    "end": "1680280"
  },
  {
    "text": "and scale back up during the day. You'll only pay for the resources used",
    "start": "1680280",
    "end": "1685970"
  },
  {
    "text": "while your containers are running. No more paying for EC2\ncapacity that might go unused.",
    "start": "1685970",
    "end": "1691783"
  },
  {
    "text": "Batch workloads and periodic tasks such as crime jobs and\noccasional jobs from a queue",
    "start": "1694100",
    "end": "1699870"
  },
  {
    "text": "are other examples of\nvariable resource usage. These workloads are a\ngreat fit for Fargate.",
    "start": "1699870",
    "end": "1705923"
  },
  {
    "text": "Even for large workloads, Fargate provides benefits in\nmanageability and overhead.",
    "start": "1709130",
    "end": "1714053"
  },
  {
    "text": "Customers running Fargate\ndon't have to deal with any server updates or maintenance. For example, when the Spectre/Meltdown",
    "start": "1715090",
    "end": "1722510"
  },
  {
    "text": "vulnerability was discovered, customers running EC2 clusters had to patch and upgrade those instances,",
    "start": "1722510",
    "end": "1729409"
  },
  {
    "text": "but customers running Fargate\nwere protected automatically because AWS engineers patched\nthe underlying infrastructure",
    "start": "1729410",
    "end": "1736590"
  },
  {
    "text": "behind the scenes. Fargate only supports Linux containers.",
    "start": "1736590",
    "end": "1742440"
  },
  {
    "text": "So Windows containers must run on EC2. As I mentioned earlier,",
    "start": "1742440",
    "end": "1748330"
  },
  {
    "text": "converting your microservices to .NET Core expands your deployment options",
    "start": "1748330",
    "end": "1753580"
  },
  {
    "text": "because .NET Core containers\ncan run on Linux or Windows. .NET Core containers work great Fargate.",
    "start": "1753580",
    "end": "1761273"
  },
  {
    "text": "As you're considering\nwhich compute model to use, keep in mind that you can mix and match EC2 and Fargate within a single cluster.",
    "start": "1764210",
    "end": "1771913"
  },
  {
    "text": "So you can have consistent\nworkloads running on EC2 and batch or unpredictable\njobs running on Fargate.",
    "start": "1772830",
    "end": "1779283"
  },
  {
    "start": "1784000",
    "end": "1865000"
  },
  {
    "text": "Let's revisit our three microservices to decide which compute layer to use.",
    "start": "1785020",
    "end": "1789633"
  },
  {
    "text": "The account service is running on Lambda. So all of this infrastructure is handled automatically by AWS.",
    "start": "1791140",
    "end": "1797400"
  },
  {
    "text": "There's no decision to make here. For the Invoicing microservice,",
    "start": "1797400",
    "end": "1802880"
  },
  {
    "text": "this service can be ported to .NET Core so it can run on Linux.",
    "start": "1802880",
    "end": "1807093"
  },
  {
    "text": "As we look at the usage logs, the Invoicing microservice sees a lot of variability in traffic.",
    "start": "1808140",
    "end": "1814840"
  },
  {
    "text": "It experiences periodic\nunpredictable spikes during business hours and low load during the evening.",
    "start": "1814840",
    "end": "1821403"
  },
  {
    "text": "With this usage pattern, it would be difficult to\nfully utilize EC2 instances.",
    "start": "1822530",
    "end": "1827860"
  },
  {
    "text": "So Fargate is the best choice. Finally, the Inventory microservice\nwill need to run on EC2.",
    "start": "1827860",
    "end": "1835893"
  },
  {
    "text": "Because this service is\nrunning on the .NET Framework, it's limited to Windows.",
    "start": "1836990",
    "end": "1841763"
  },
  {
    "text": "As of October, 2020, EC2 is the only compute layer that supports Windows containers.",
    "start": "1842610",
    "end": "1848793"
  },
  {
    "text": "Even if we were able to do a\nmore significant refactoring and update this microservice\nto use .NET Core,",
    "start": "1850150",
    "end": "1856090"
  },
  {
    "text": "we still might want to use EC2 for compute if the service has a consistent,\npredictable load pattern.",
    "start": "1856090",
    "end": "1862033"
  },
  {
    "text": "Now we can see how the\nextracted microservices will work with the remaining\ncode in the monolith.",
    "start": "1866700",
    "end": "1871933"
  },
  {
    "text": "Remember, because we're using\nthe Strangler Fig pattern, we want to incrementally\nreplace the monolith",
    "start": "1872940",
    "end": "1878620"
  },
  {
    "text": "with microservices, one section at a time.",
    "start": "1878620",
    "end": "1881253"
  },
  {
    "text": "Our monolith is deployed inside our Virtual Private Cloud, or VPC, with an Elastic load balancer",
    "start": "1883870",
    "end": "1890110"
  },
  {
    "text": "in front of an Auto Scaling\ngroup of EC2 instances. All of these resources are deployed",
    "start": "1890110",
    "end": "1896630"
  },
  {
    "text": "across multiple availability zones to provide high availability.",
    "start": "1896630",
    "end": "1900963"
  },
  {
    "text": "We also have an API gateway with routes defined for\neach of the services.",
    "start": "1902480",
    "end": "1907770"
  },
  {
    "text": "Initially, all of those routes\nare pointing to the monolith.",
    "start": "1907770",
    "end": "1911363"
  },
  {
    "text": "We're going to keep this architecture and add the AWS services we need to run the extracted microservices.",
    "start": "1913630",
    "end": "1920730"
  },
  {
    "text": "First, we'll add an ECS cluster using Windows EC2 for compute.",
    "start": "1923330",
    "end": "1928933"
  },
  {
    "text": "This cluster will run the\nInventory microservice in Windows containers.",
    "start": "1929980",
    "end": "1934293"
  },
  {
    "text": "As we continue with our\nStrangler Fig pattern, any services that are .NET Framework only",
    "start": "1935590",
    "end": "1941170"
  },
  {
    "text": "can also run in this cluster. We'll include a load balancer",
    "start": "1941170",
    "end": "1946360"
  },
  {
    "text": "to distribute traffic\namong the containers. ECS makes this really easy to set up.",
    "start": "1946360",
    "end": "1950903"
  },
  {
    "text": "Finally, we'll update the API gateway to send the inventory\nroute to the microservice.",
    "start": "1952210",
    "end": "1959670"
  },
  {
    "text": "This way, we maintain API compatibility. The API clients don't\nneed to update their code",
    "start": "1959670",
    "end": "1965840"
  },
  {
    "text": "to start using the microservice. Next, we'll add an ECS cluster\nfor our Linux containers.",
    "start": "1965840",
    "end": "1975000"
  },
  {
    "text": "In this case, it's the invoicing service, which is running in Fargate.",
    "start": "1975000",
    "end": "1979000"
  },
  {
    "text": "Just as with the Inventory service, we'll add a load balancer to distribute traffic\namong the containers,",
    "start": "1980860",
    "end": "1987559"
  },
  {
    "text": "then update the API\ngateway's invoicing route to point to the microservices\ninstead of the monolith.",
    "start": "1987560",
    "end": "1993923"
  },
  {
    "text": "Finally, we'll add the\nAccount microservice to the architecture. This microservice is using Lambda,",
    "start": "1996100",
    "end": "2002780"
  },
  {
    "text": "so we don't have any\ninfrastructure to manage. We will update the API gateway",
    "start": "2002780",
    "end": "2008340"
  },
  {
    "text": "to point to the Account microservice instead of the monolith.",
    "start": "2008340",
    "end": "2011683"
  },
  {
    "text": "Now we can see the Strangler Fig pattern really starting to emerge. We have three new modern microservices",
    "start": "2013750",
    "end": "2021070"
  },
  {
    "text": "that have each replaced\na portion of the monolith without having to make any\nchanges to the monolith itself.",
    "start": "2021070",
    "end": "2026783"
  },
  {
    "text": "Now I'll demonstrate a number\nof the practices and services that we covered so far.",
    "start": "2029220",
    "end": "2033713"
  },
  {
    "start": "2034000",
    "end": "2066000"
  },
  {
    "text": "Let's start our demo with\nthe Invoicing microservice. As a reminder, this is the microservice",
    "start": "2035400",
    "end": "2042000"
  },
  {
    "text": "we ported to .NET Core. So we're going to run this microservice",
    "start": "2042000",
    "end": "2047060"
  },
  {
    "text": "in a Linux container to\nsave on licensing costs. And we'll run that Linux\ncontainer in Fargate",
    "start": "2047060",
    "end": "2053860"
  },
  {
    "text": "because the service has\na variable traffic load. I'm here on my Windows desktop,",
    "start": "2053860",
    "end": "2060460"
  },
  {
    "text": "but in order to build a\nLinux container image, I need to be on a Linux machine.",
    "start": "2060460",
    "end": "2065323"
  },
  {
    "start": "2066000",
    "end": "2158000"
  },
  {
    "text": "So I have an EC2 instance\nrunning Linux and Docker that I've connected to over SSH.",
    "start": "2066610",
    "end": "2072423"
  },
  {
    "text": "This will be the build\nmachine for the Linux image. I've uploaded the code for\nthe Invoicing microservice",
    "start": "2074040",
    "end": "2081520"
  },
  {
    "text": "onto this instance, so now we can build and push the image. First, we'll build the image",
    "start": "2081520",
    "end": "2088470"
  },
  {
    "text": "and tag it with the name\nof the microservice.",
    "start": "2088470",
    "end": "2090952"
  },
  {
    "text": "The Docker build process just\ncompiled the .NET Core code and it inside a container image.",
    "start": "2093610",
    "end": "2100403"
  },
  {
    "text": "This is the exact same code\nfrom my Windows desktop. Again, because .NET\nCore is cross-platform,",
    "start": "2101280",
    "end": "2107970"
  },
  {
    "text": "the same code compiles on\nboth Windows and Linux.",
    "start": "2107970",
    "end": "2111922"
  },
  {
    "text": "Now we need to push this\nDocker image up to AWS so that AWS services can use it.",
    "start": "2113550",
    "end": "2119743"
  },
  {
    "text": "I've already created an\nElastic container repository for this image.",
    "start": "2120850",
    "end": "2125870"
  },
  {
    "text": "So now, we'll log in to that repository and push the image up to AWS.",
    "start": "2125870",
    "end": "2131437"
  },
  {
    "text": "The commands to do this are\ndisplayed in the AWS Console.",
    "start": "2133240",
    "end": "2136783"
  },
  {
    "text": "Now the invoicing image has\nbeen uploaded to its repository. The next step is to create an ECS task",
    "start": "2142980",
    "end": "2150740"
  },
  {
    "text": "to describe the resources\nthat the container needs. Let's go back to our\nWindows desktop to do that.",
    "start": "2150740",
    "end": "2157223"
  },
  {
    "start": "2158000",
    "end": "2451000"
  },
  {
    "text": "We can define our task\nparameters in a JSON file. This is how helpful in a number of ways.",
    "start": "2158960",
    "end": "2165609"
  },
  {
    "text": "One of them is that we can\nput our task definition under a version control so we can track revisions over time.",
    "start": "2165610",
    "end": "2171963"
  },
  {
    "text": "Using a JSON file also makes it easier to use the AWS CLI to deploy the task.",
    "start": "2173120",
    "end": "2179353"
  },
  {
    "text": "So let's open up our task definition JSON. The family defines a name for the task.",
    "start": "2180400",
    "end": "2188560"
  },
  {
    "text": "Each task can have one or more containers. This task only has one.",
    "start": "2188560",
    "end": "2193950"
  },
  {
    "text": "It's defined in the\ncontainer definition section. We're using the image from our\nElastic container repository",
    "start": "2193950",
    "end": "2201410"
  },
  {
    "text": "for the Invoicing microservice. So when this task is created,",
    "start": "2201410",
    "end": "2206880"
  },
  {
    "text": "it will get the image\nthat we just pushed up and use that image to create a container.",
    "start": "2206880",
    "end": "2212163"
  },
  {
    "text": "We're indicating that this task requires a certain\namount of CPU and memory.",
    "start": "2213950",
    "end": "2219349"
  },
  {
    "text": "This helps Fargate allocate\nthe necessary resources. For EC2, this will help the orchestrator",
    "start": "2219350",
    "end": "2225770"
  },
  {
    "text": "figure out how to most\nefficiently deploy containers onto EC2 instances.",
    "start": "2225770",
    "end": "2230853"
  },
  {
    "text": "Now that we have our task definition, let's go to PowerShell and use the AWS CLI",
    "start": "2233540",
    "end": "2239190"
  },
  {
    "text": "to register this task. I'm going to use the PowerShell that's inside Visual Studio itself.",
    "start": "2239190",
    "end": "2244953"
  },
  {
    "text": "The output of this command is a JSON block that describes the task definition.",
    "start": "2249690",
    "end": "2254810"
  },
  {
    "text": "Now that we have a task, we need to create a service in ECS to run that task on an ongoing basis.",
    "start": "2254810",
    "end": "2262820"
  },
  {
    "text": "Again, we can use the AWS\nCLI to create that service based on a JSON specification.",
    "start": "2262820",
    "end": "2269513"
  },
  {
    "text": "Let's pull up that service\ndefinition JSON now. We can see that the service is based",
    "start": "2270770",
    "end": "2277120"
  },
  {
    "text": "around the task definition\nthat we just created. We're launching it in Fargate",
    "start": "2277120",
    "end": "2281800"
  },
  {
    "text": "onto an ECS cluster that\nI've already created. The desired count of tasks is three.",
    "start": "2282720",
    "end": "2289980"
  },
  {
    "text": "So the orchestrator will try to make sure there are always three\nidentical tasks running as part of this service.",
    "start": "2289980",
    "end": "2296223"
  },
  {
    "text": "Those three tasks will be deployed across three private subnets",
    "start": "2297510",
    "end": "2302569"
  },
  {
    "text": "which means the containers won't have direct access to the internet.",
    "start": "2302570",
    "end": "2306662"
  },
  {
    "text": "The tasks are also behind a load balancer, which I've already created.",
    "start": "2308100",
    "end": "2312500"
  },
  {
    "text": "That load balancer is also internal to the Virtual Private Cloud.",
    "start": "2313540",
    "end": "2317433"
  },
  {
    "text": "This means that none of these tasks can be directly accessed\nfrom the internet.",
    "start": "2318600",
    "end": "2323940"
  },
  {
    "text": "This is helpful from a\nsecurity perspective. Because ECS integrates with\nElastic load balancing,",
    "start": "2323940",
    "end": "2331740"
  },
  {
    "text": "the ECS orchestrator will\nautomatically register the containers into the load\nbalancer's target group.",
    "start": "2331740",
    "end": "2337682"
  },
  {
    "text": "This configuration looks good. So let's deploy this\nservice using the AWS CLI.",
    "start": "2339410",
    "end": "2345323"
  },
  {
    "text": "Now, let's pull up the ECS\ncluster in the AWS Console. We see that we now have a service",
    "start": "2351540",
    "end": "2357910"
  },
  {
    "text": "and our tasks are in the\nprocess of deployment.",
    "start": "2359807",
    "end": "2362882"
  },
  {
    "text": "If we go to the load\nbalancer target group, we'll see that the load\nbalancer is in the process",
    "start": "2365160",
    "end": "2371500"
  },
  {
    "text": "of checking the health of each container. Once they pass their health check,",
    "start": "2371500",
    "end": "2377940"
  },
  {
    "text": "they'll be added as active\ntargets for the load balancer.",
    "start": "2377940",
    "end": "2381483"
  },
  {
    "text": "This may take a few\nseconds to a minute or two, depending on the health check. So let's fast-forward until\neverything's up and running.",
    "start": "2384030",
    "end": "2391660"
  },
  {
    "text": "The tasks have all spun up and have been registered\nwith our load balancer.",
    "start": "2392550",
    "end": "2396710"
  },
  {
    "text": "Let's run a smoke test to make sure the containers are working. We can't connect to this\nmicroservice over the internet",
    "start": "2397820",
    "end": "2405570"
  },
  {
    "text": "because the tasks are in private subnets and the load balancer is internal only.",
    "start": "2405570",
    "end": "2410192"
  },
  {
    "text": "So to test the microservice, we'll go back to our Linux EC2 instance",
    "start": "2411150",
    "end": "2416870"
  },
  {
    "text": "which is inside the same\nVPC as the ECS cluster.",
    "start": "2416870",
    "end": "2421273"
  },
  {
    "text": "Because we're now inside the VPC, we can connect to the load\nbalancer using its DNS name.",
    "start": "2422950",
    "end": "2430400"
  },
  {
    "text": "If everything is working, we should see some JSON\noutput from the invoicing API.",
    "start": "2430400",
    "end": "2435883"
  },
  {
    "text": "Okay, great. There's that JSON output\nfrom the invoicing API.",
    "start": "2438180",
    "end": "2443172"
  },
  {
    "text": "This means the containers\nare doing what we expect. They're running the\nInvoicing microservice.",
    "start": "2444050",
    "end": "2448980"
  },
  {
    "start": "2451000",
    "end": "2475000"
  },
  {
    "text": "Now let's deploy the\nInventory microservice. You remember, the Inventory microservice",
    "start": "2453410",
    "end": "2458760"
  },
  {
    "text": "was not able to be converted to .NET Core. So it's still running on .NET Framework.",
    "start": "2458760",
    "end": "2464470"
  },
  {
    "text": "This means the Inventory\nmicroservice will need to run on a Windows container,\nnot a Linux container.",
    "start": "2464470",
    "end": "2470412"
  },
  {
    "text": "Let's use App2Container to\npackage this microservice. To do this, we'll switch over",
    "start": "2471470",
    "end": "2477960"
  },
  {
    "start": "2475000",
    "end": "2629000"
  },
  {
    "text": "to our Windows server EC2 instance. This is a development server",
    "start": "2477960",
    "end": "2483109"
  },
  {
    "text": "running the Inventory microservice as the default website in IIS.",
    "start": "2483110",
    "end": "2487913"
  },
  {
    "text": "This is the microservice\nthat we want to package using App2Container.",
    "start": "2489070",
    "end": "2493069"
  },
  {
    "text": "To run App2Container, we'll start with a PowerShell window since App2Container is\na command line tool.",
    "start": "2494320",
    "end": "2500313"
  },
  {
    "text": "I've already set up and\ninitialized App2Container on this instance as per the documentation.",
    "start": "2501530",
    "end": "2507260"
  },
  {
    "text": "So we can get started by\nrunning App2Container inventory. The output of this command",
    "start": "2507260",
    "end": "2512570"
  },
  {
    "text": "is all of the running ASP.NET\napplications on this server. In this case, it's just\nthe default website,",
    "start": "2512570",
    "end": "2519420"
  },
  {
    "text": "which is what we'd expect. Now we'll copy the name of\nthe IIS root application",
    "start": "2519420",
    "end": "2525490"
  },
  {
    "text": "and use that to run App2Container analyze. This may take a few minutes to run,",
    "start": "2526680",
    "end": "2532359"
  },
  {
    "text": "so we'll fast-forward until it completes. The analyze step has now completed.",
    "start": "2532360",
    "end": "2538833"
  },
  {
    "text": "The output of this step is a JSON file. Let's take a look at that file.",
    "start": "2539800",
    "end": "2544110"
  },
  {
    "text": "You can see the JSON\nfile contains the image that the container will be based on.",
    "start": "2547100",
    "end": "2552333"
  },
  {
    "text": "In this case, it's\nWindows Server Core 2019, which makes sense because this is a Windows Server 2019 instance.",
    "start": "2553170",
    "end": "2560803"
  },
  {
    "text": "Now we do want to update the base image to use the .NET Framework version 4.8",
    "start": "2561980",
    "end": "2567660"
  },
  {
    "text": "instead of version 4.7.2.",
    "start": "2567660",
    "end": "2569513"
  },
  {
    "text": "So we'll update the base\nimage to ASP.NET 4.8. This is using the official Microsoft image",
    "start": "2573230",
    "end": "2580130"
  },
  {
    "text": "which you can find on Docker Hub. The other thing I want to change here",
    "start": "2580130",
    "end": "2585819"
  },
  {
    "text": "is the repository name. A2C has generated a\ndefault repository name",
    "start": "2585820",
    "end": "2592119"
  },
  {
    "text": "based on the IIS application name. But this name isn't very descriptive",
    "start": "2592120",
    "end": "2597440"
  },
  {
    "text": "and I've already created an\nECR repository for this image.",
    "start": "2597440",
    "end": "2602440"
  },
  {
    "text": "So we'll change the image repository name to the name of the ECR repository.",
    "start": "2602600",
    "end": "2607853"
  },
  {
    "text": "Everything else in this\nJSON file looks good. So we can save and close it.",
    "start": "2610460",
    "end": "2615942"
  },
  {
    "text": "Now let's actually\ncontainerize the application by running App2Container, containerized.",
    "start": "2622830",
    "end": "2627760"
  },
  {
    "start": "2629000",
    "end": "2748000"
  },
  {
    "text": "This command may also take a few minutes, so we'll fast-forward until it finishes.",
    "start": "2630790",
    "end": "2634890"
  },
  {
    "text": "The containerized command has finished. Let's look at the outputs.",
    "start": "2636030",
    "end": "2640173"
  },
  {
    "text": "First, we'll run Docker images to make sure that the\nimage has been built.",
    "start": "2641110",
    "end": "2645993"
  },
  {
    "text": "Okay. You can see at the top of the list is our AFDS Inventory microservice image.",
    "start": "2647340",
    "end": "2654079"
  },
  {
    "text": "Great. Now, let's test our container before we push it up to the repository.",
    "start": "2654080",
    "end": "2661000"
  },
  {
    "text": "We'll run the container\non the build machine. Once the container is running,",
    "start": "2661000",
    "end": "2666980"
  },
  {
    "text": "we can test it by sending a request to the health check endpoint.",
    "start": "2666980",
    "end": "2671063"
  },
  {
    "text": "Healthy is what we want to see, so this test passes. Now we can stop and\nremove our test container.",
    "start": "2674730",
    "end": "2681113"
  },
  {
    "text": "Now we know that the container works, so we can use App2Container to generate deployment artifacts.",
    "start": "2686910",
    "end": "2692692"
  },
  {
    "text": "The deployment artifact\ncommand has succeeded. This command creates a\ncloud formation template",
    "start": "2695000",
    "end": "2700503"
  },
  {
    "text": "that will deploy the container. These deployment artifacts are great if you're starting from scratch.",
    "start": "2700503",
    "end": "2706720"
  },
  {
    "text": "But in this case, I've already created the AWS infrastructure\nto run this microservice.",
    "start": "2706720",
    "end": "2712770"
  },
  {
    "text": "So I won't use the generated\ndeployment artifacts. Let's just push the image\nup to its ECR repository,",
    "start": "2712770",
    "end": "2720240"
  },
  {
    "text": "and then we can use a\nworkflow that's a lot like what we did for the\ninvoicing microservice.",
    "start": "2720240",
    "end": "2724917"
  },
  {
    "text": "Just like we pushed the invoicing image up from the Linux instance, we'll push the inventory image up",
    "start": "2726830",
    "end": "2732690"
  },
  {
    "text": "from this Windows instance. Again, the commands to do this are available in the AWS Console.",
    "start": "2732690",
    "end": "2738453"
  },
  {
    "text": "We've now pushed the\nDocker image up to AWS. Now let's go back to our Windows desktop",
    "start": "2744200",
    "end": "2751180"
  },
  {
    "text": "and set up an ECS task and service. Like the Invoicing microservice,",
    "start": "2751180",
    "end": "2756930"
  },
  {
    "text": "we'll define the task parameters in JSON. The parameters here have\nchanged a little bit",
    "start": "2756930",
    "end": "2763210"
  },
  {
    "text": "to be compatible with Windows containers. We've also changed our compatibilities",
    "start": "2763210",
    "end": "2768550"
  },
  {
    "text": "to indicate that this\ntask can only run on EC2, not on Fargate,",
    "start": "2768550",
    "end": "2773569"
  },
  {
    "text": "because Fargate doesn't\nsupport Windows containers. Now let's switch over to\nour service definition.",
    "start": "2773570",
    "end": "2780513"
  },
  {
    "text": "The desired count is still three. So the orchestrator will run three tasks across our EC2 cluster.",
    "start": "2782640",
    "end": "2788932"
  },
  {
    "text": "The EC2 instances that\nmake up the compute layer are configured to span the\nsame three private subnets",
    "start": "2789940",
    "end": "2796430"
  },
  {
    "text": "as the Invoicing microservice. Just like the invoicing service, we're integrating this\nwith a load balancer.",
    "start": "2796430",
    "end": "2804010"
  },
  {
    "text": "I've already created the load\nbalancer and its target group. So let's go back to PowerShell\nand create the task,",
    "start": "2804010",
    "end": "2811310"
  },
  {
    "text": "and then the service.",
    "start": "2811310",
    "end": "2812933"
  },
  {
    "text": "Now, let's go to the AWS Console and double-check the deployment. You can see that our\nservice is starting up",
    "start": "2819330",
    "end": "2826120"
  },
  {
    "text": "and it's placing tasks on EC2 instances in our cluster. If we go to the load balancer,",
    "start": "2826120",
    "end": "2832760"
  },
  {
    "text": "you can see that the service\nis registering the containers as targets with the load balancer.",
    "start": "2832760",
    "end": "2839480"
  },
  {
    "text": "Now, just like with the\nInvoicing microservice, we can't reach these\ncontainers from the internet.",
    "start": "2839480",
    "end": "2845150"
  },
  {
    "text": "So let's go back to our\nLinux machine inside the VPC and run a smoke test against\nthe inventory load balancer.",
    "start": "2845150",
    "end": "2852123"
  },
  {
    "text": "Now we have our Inventory microservice running in Windows containers on EC2.",
    "start": "2855040",
    "end": "2861040"
  },
  {
    "start": "2860000",
    "end": "2924000"
  },
  {
    "text": "The last microservice we want to deploy is the Account microservice. We're using Lambda for this microservice.",
    "start": "2861040",
    "end": "2867610"
  },
  {
    "text": "The account service has\nfour CRUD operations; create, read, update, and delete.",
    "start": "2868910",
    "end": "2874823"
  },
  {
    "text": "We've converted each\none of those operations into its own Lambda function.",
    "start": "2875850",
    "end": "2880503"
  },
  {
    "text": "Here in Visual Studio, we've included each of these functions in a project under the\nmicroservice solution.",
    "start": "2881690",
    "end": "2887723"
  },
  {
    "text": "We've published each\nmicroservice to Lambda using the AWS toolkit for Visual Studio.",
    "start": "2888980",
    "end": "2894503"
  },
  {
    "text": "Just right-click on the project, click Publish to AWS Lambda,",
    "start": "2896720",
    "end": "2901583"
  },
  {
    "text": "then click Upload.",
    "start": "2903570",
    "end": "2904873"
  },
  {
    "text": "Once the publish has completed, let's switch over to the AWS Console where we can see all\nfour Lambda functions.",
    "start": "2915020",
    "end": "2922003"
  },
  {
    "start": "2924000",
    "end": "3145000"
  },
  {
    "text": "Now we have all of the parts we need to start implementing the\nStrangler Fig pattern.",
    "start": "2925300",
    "end": "2929563"
  },
  {
    "text": "We've defined and an API gateway for the One Vision platform. If we go into the integrations\nfor the API gateway,",
    "start": "2930570",
    "end": "2937423"
  },
  {
    "text": "we can see that it's only integrating with the monolith right now.",
    "start": "2938290",
    "end": "2943182"
  },
  {
    "text": "This means the monolith will\nhandle every API request. Unlike the monolith and the microservices,",
    "start": "2944360",
    "end": "2951580"
  },
  {
    "text": "the API gateway is\naccessible over the internet. So we can test it in PowerShell\non our Windows desktop.",
    "start": "2951580",
    "end": "2958233"
  },
  {
    "text": "So this is the invoicing route. And even though we have our\nnew Invoicing microservice,",
    "start": "2960920",
    "end": "2966400"
  },
  {
    "text": "requests to the invoicing API are still being handled by the monolith.",
    "start": "2966400",
    "end": "2972980"
  },
  {
    "text": "We want to change the invoicing API so that it's handled the microservice",
    "start": "2972980",
    "end": "2978030"
  },
  {
    "text": "and not the monolith. To do that, we'll go to the\nAPI gateway integrations",
    "start": "2978030",
    "end": "2985000"
  },
  {
    "text": "in the AWS Console. Here is the root API route,",
    "start": "2985000",
    "end": "2991140"
  },
  {
    "text": "which is pointing to a load balancer that sits in front of the monolith. This is a catch-all route,",
    "start": "2991140",
    "end": "2997410"
  },
  {
    "text": "so everything flows through it. You can see that we've defined routes",
    "start": "2997410",
    "end": "3002730"
  },
  {
    "text": "for invoicing, inventory, and account, but because those routes aren't\nintegrated with anything,",
    "start": "3002730",
    "end": "3009030"
  },
  {
    "text": "the API gateway falls back\nto the catch-all route that points to the monolith.",
    "start": "3009030",
    "end": "3013832"
  },
  {
    "text": "Now, let's go to the invoicing route and set it up to point\nto the microservice.",
    "start": "3015760",
    "end": "3020640"
  },
  {
    "text": "I've already created an\nAPI gateway integration for the Invoicing microservice.",
    "start": "3022410",
    "end": "3027950"
  },
  {
    "text": "This is like a pointer to the Invoicing\nmicroservice load balancer. Now we need to link that load balancer",
    "start": "3027950",
    "end": "3035279"
  },
  {
    "text": "to the invoicing route. So we select the integration with the invoicing load balancer",
    "start": "3035280",
    "end": "3041490"
  },
  {
    "text": "and click Attach Integration. Now, if we go back to our PowerShell",
    "start": "3043576",
    "end": "3049210"
  },
  {
    "text": "and execute the invoicing API again, let's see what happens. You can see that the source\nfield in the JSON has changed",
    "start": "3049210",
    "end": "3057160"
  },
  {
    "text": "indicating that this API request is now being handled by the microservice.",
    "start": "3057160",
    "end": "3063670"
  },
  {
    "text": "Now let's switch the inventory route to be handled by the\nInventory microservice.",
    "start": "3063670",
    "end": "3067900"
  },
  {
    "text": "First, let's double-check\nthat the inventory route is still being handled by the monolith.",
    "start": "3069790",
    "end": "3074563"
  },
  {
    "text": "As long as we're already in PowerShell, let's update the inventory\nroute using the AWS CLI.",
    "start": "3076350",
    "end": "3083043"
  },
  {
    "text": "Now let's check the inventory route again and make sure it's being\nhandled by the microservice.",
    "start": "3087660",
    "end": "3092817"
  },
  {
    "text": "Again, you can see the source\nfield has changed in the JSON. So we know that the API\nrequest, the same URL,",
    "start": "3095000",
    "end": "3102330"
  },
  {
    "text": "is now being handled by the microservice instead of the monolith. To update the account service,",
    "start": "3102330",
    "end": "3109490"
  },
  {
    "text": "we'll use a different kind\nof API gateway integration that points to a Lambda function.",
    "start": "3109490",
    "end": "3114563"
  },
  {
    "text": "Each of our Lambda function\nhandles one HTTP verb. GET for read operations,",
    "start": "3115460",
    "end": "3122220"
  },
  {
    "text": "POST for create, PUT for update, and DELETE for delete.",
    "start": "3122220",
    "end": "3128010"
  },
  {
    "text": "I'll set up the integrations for each verb to its corresponding Lambda function.",
    "start": "3128010",
    "end": "3133850"
  },
  {
    "text": "Now that I've set up each HTTP\nverb under the account route,",
    "start": "3133850",
    "end": "3138850"
  },
  {
    "text": "to integrate with its\ncorresponding Lambda function, let's test the API in PowerShell.",
    "start": "3139040",
    "end": "3144530"
  },
  {
    "start": "3145000",
    "end": "3237000"
  },
  {
    "text": "This test shows that the account route is being handled by the Lambda function.",
    "start": "3146670",
    "end": "3151603"
  },
  {
    "text": "Our Strangler Fig pattern is\nstarting to come together. We've been able to extract\nmicroservices from the monolith",
    "start": "3153510",
    "end": "3160710"
  },
  {
    "text": "without changing the monolith code. We've updated one of those\nmicroservices to .NET Core,",
    "start": "3160710",
    "end": "3166630"
  },
  {
    "text": "and deployed it on Linux\ncontainers with Fargate. We've kept another microservice\non the .NET Framework",
    "start": "3166630",
    "end": "3173580"
  },
  {
    "text": "and deployed it on\nWindows containers on EC2 using App2Container.",
    "start": "3173580",
    "end": "3178710"
  },
  {
    "text": "And we've converted a third\nmicroservice to use AWS Lambda so it's fully serverless with\nno infrastructure to manage.",
    "start": "3178710",
    "end": "3186463"
  },
  {
    "text": "Finally, we switched the public API to point to the new microservices. So all of our end users\nare seamlessly connected",
    "start": "3187410",
    "end": "3195670"
  },
  {
    "text": "to the new architecture. Now we have all of the benefits\nof a modernized architecture",
    "start": "3195670",
    "end": "3201559"
  },
  {
    "text": "for these microservices. This concludes our demo of serverless",
    "start": "3201560",
    "end": "3207190"
  },
  {
    "text": "and container best practices for modernizing .NET applications. As a reminder, this video is one part",
    "start": "3207190",
    "end": "3214470"
  },
  {
    "text": "of an entire series\ncovering best practices for modernizing .NET applications on AWS.",
    "start": "3214470",
    "end": "3220217"
  },
  {
    "text": "The next video in the series covers choosing databases\nfor your microservices using AWS' suite of\npurpose-built databases.",
    "start": "3221700",
    "end": "3229393"
  },
  {
    "text": "Thank you for watching this video and good luck on your\nmodernization journey.",
    "start": "3230570",
    "end": "3234343"
  }
]