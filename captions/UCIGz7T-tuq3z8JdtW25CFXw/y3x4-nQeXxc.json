[
  {
    "text": "[Music]",
    "start": "0",
    "end": "5040"
  },
  {
    "text": "[Applause] hello everyone thanks for having me",
    "start": "5040",
    "end": "12880"
  },
  {
    "text": "sorry for the let's see wait for it to come up all right sorry for the terrible pun",
    "start": "12880",
    "end": "19840"
  },
  {
    "text": "in the title but I just couldn't help myself so on our path to wazzy 1.0 we",
    "start": "19840",
    "end": "28679"
  },
  {
    "text": "started with Wazi preview one which contains a monolithic subset of posix",
    "start": "28679",
    "end": "34000"
  },
  {
    "text": "based on cloud ABI and then we did a whole bunch of work to release wazzy Preview 2 this January and uh in the",
    "start": "34000",
    "end": "41280"
  },
  {
    "text": "spirit of sver we've taken to calling that wazzy 0.2 and it contains two independent",
    "start": "41280",
    "end": "47199"
  },
  {
    "text": "worlds a CLI command World which you can think of as preview one plus sockets and",
    "start": "47199",
    "end": "53800"
  },
  {
    "text": "an HB proxy worlds 02 also contains the component model which defines for us a",
    "start": "53800",
    "end": "59199"
  },
  {
    "text": "unit of code that we call a components and an IDL called wits and we Define these worlds in terms of the component",
    "start": "59199",
    "end": "66320"
  },
  {
    "text": "model so what is a component well for uh a full longer answer uh I gave a talk at",
    "start": "66320",
    "end": "72240"
  },
  {
    "text": "WMC con last year called what is the component and why and you can find that on YouTube so just to give a a one-side",
    "start": "72240",
    "end": "77920"
  },
  {
    "text": "summary of it a component is an emerging standard portable lightweight finely sandbox cross language compositional",
    "start": "77920",
    "end": "85560"
  },
  {
    "text": "module being developed in the w3c uh W3 web assmbly community group layered over",
    "start": "85560",
    "end": "92520"
  },
  {
    "text": "core web assembly 1.0 kind of like how TCP is layered over IP we want",
    "start": "92520",
    "end": "97560"
  },
  {
    "text": "components to be portable running the same component binary on multiple WM run times so that means filling in the gaps",
    "start": "97560",
    "end": "103720"
  },
  {
    "text": "left by not always having a native JS engine we want components to be lightweight just like core web assembly",
    "start": "103720",
    "end": "110880"
  },
  {
    "text": "which means super fast cold starts and having a small runtime we want components to be finely sandboxed so",
    "start": "110880",
    "end": "117600"
  },
  {
    "text": "that they encapsulate their own uh core memory and uh table States preventing access from other component instances",
    "start": "117600",
    "end": "124560"
  },
  {
    "text": "which we usually refer to by saying that components are shared nothing and we want components to be",
    "start": "124560",
    "end": "130160"
  },
  {
    "text": "cross language so we compile them from different languages and have them interoperate and then we want to be able to compose components and that to",
    "start": "130160",
    "end": "136400"
  },
  {
    "text": "produce a component so we can compose them again and on and on and lastly components are modules",
    "start": "136400",
    "end": "142000"
  },
  {
    "text": "meaning that their public interfac is defined in terms of the familiar concepts of imports and",
    "start": "142000",
    "end": "147640"
  },
  {
    "text": "exports so that's what's in wazzy 0.2 what's next well there's two",
    "start": "147640",
    "end": "153840"
  },
  {
    "text": "parallel tracks of work we want to undergo the first is a sequence of minor releases extending",
    "start": "153840",
    "end": "159760"
  },
  {
    "text": "0.2 the idea here is to have more of a train model with regular releases say like",
    "start": "159760",
    "end": "164800"
  },
  {
    "text": "quarterly where we're only making backwards compatible additions say like adding a time zone interface to the Wazi",
    "start": "164800",
    "end": "170440"
  },
  {
    "text": "clocks proposal or defining whole new worlds like in the wazzy Cloud Core proposal and then in parallel to that we",
    "start": "170440",
    "end": "177120"
  },
  {
    "text": "want to do more of a major release for called wazzy 0.3 which previously I",
    "start": "177120",
    "end": "182200"
  },
  {
    "text": "called Wazi preview 3 and uh we want this as soon as possible of course but you know likely",
    "start": "182200",
    "end": "187319"
  },
  {
    "text": "this is going to take more than a year and the uh the big feature here is adding native async in the component",
    "start": "187319",
    "end": "193200"
  },
  {
    "text": "model and then rebasing our 0.2 interfaces to take advantage of these features so just to see what this might",
    "start": "193200",
    "end": "200560"
  },
  {
    "text": "look like let's uh zoom in and talk about wazzy h2p so first let me start with a simple",
    "start": "200560",
    "end": "206440"
  },
  {
    "text": "very composable But ultimately fatally flawed design which I'm going to call simple HTP so in simple HTTP we Define",
    "start": "206440",
    "end": "213360"
  },
  {
    "text": "our proxy world to Import and Export a Handler interface and the Handler interface contains a single function",
    "start": "213360",
    "end": "218760"
  },
  {
    "text": "that you can pass a request and get back a response or an error and so when proxy World Imports the Handler interface it's",
    "start": "218760",
    "end": "223920"
  },
  {
    "text": "importing a function that you can call to make an outgoing request and when the proxy World exports a Handler that",
    "start": "223920",
    "end": "230239"
  },
  {
    "text": "component is exporting a function that's called by the outside world so the component can receive an incoming request and then request is a resource",
    "start": "230239",
    "end": "237200"
  },
  {
    "text": "type that could be passed a body as a list byes and return its body as a list of byes and similarly for",
    "start": "237200",
    "end": "243560"
  },
  {
    "text": "response and we can Define and implement this today in 0.2 say I could write a",
    "start": "243560",
    "end": "249079"
  },
  {
    "text": "component that targets this world in JavaScript by using a JavaScript import to import the handle function and the",
    "start": "249079",
    "end": "254200"
  },
  {
    "text": "response Constructor and then I could export a handle function that takes a request and constructs and returns a",
    "start": "254200",
    "end": "259680"
  },
  {
    "text": "response so I could implement this today in javascripts or rust or python or C and an increasing number of languages",
    "start": "259680",
    "end": "265840"
  },
  {
    "text": "that are adding 0.2 bindings so what makes this simple HP",
    "start": "265840",
    "end": "271280"
  },
  {
    "text": "proxy world composable it's that it's importing and exporting the same interface what that means is if I have a",
    "start": "271280",
    "end": "278120"
  },
  {
    "text": "proxy component say that implements rate limiting and another proxy component that does call tracing I can just simply",
    "start": "278120",
    "end": "284840"
  },
  {
    "text": "link them together because it's like the same interface on both sides I can keep going linking in a component that say",
    "start": "284840",
    "end": "290199"
  },
  {
    "text": "caches HP gets or does authentication and when I compose all these I get a compound parent component which still",
    "start": "290199",
    "end": "297000"
  },
  {
    "text": "targets that proxy world so I can keep going linking more and more and so you can see this kind of works",
    "start": "297000",
    "end": "302639"
  },
  {
    "text": "like a traditional middleware except we're just using direct component linking and then control flow is just synchronous call stack you know if I",
    "start": "302639",
    "end": "309199"
  },
  {
    "text": "call through all four components to get to the hpapi in proxying it kind of looks like this or maybe I hit the rate",
    "start": "309199",
    "end": "314800"
  },
  {
    "text": "limiter or maybe I get a cache hits or maybe authentication fails and in addition to this sort of like linear",
    "start": "314800",
    "end": "320960"
  },
  {
    "text": "control flow we can express more complex control flow say I could have a component that does path-based routing",
    "start": "320960",
    "end": "327880"
  },
  {
    "text": "and it Imports three handlers and then I can snap on these individual proxy components on all the sides of it and",
    "start": "327880",
    "end": "333880"
  },
  {
    "text": "when I compose that I get a compound component that still Targets this proxy world so I can run this compound",
    "start": "333880",
    "end": "339120"
  },
  {
    "text": "component anywhere I can run a proxy component which is pretty cool and maybe",
    "start": "339120",
    "end": "344520"
  },
  {
    "text": "the control flow based on the path goes this way through the rate limiter or maybe a different path gets a goes to the caching and maybe another path kind",
    "start": "344520",
    "end": "350880"
  },
  {
    "text": "of passes through and this is kind of starts to look like microservice chaining or what you can express with microservices",
    "start": "350880",
    "end": "357560"
  },
  {
    "text": "except there's no network stack here it's just Fast Fun function calls but there's just one little",
    "start": "357560",
    "end": "363800"
  },
  {
    "text": "problem with this whole beautiful Lego blocky design which is",
    "start": "363800",
    "end": "369160"
  },
  {
    "text": "concurrency because alas simple hgp is is not very concurrent um compared to",
    "start": "369160",
    "end": "375360"
  },
  {
    "text": "any sort of modern HTP server and kind of going down the checklist of what we might want we would want concurrent",
    "start": "375360",
    "end": "381199"
  },
  {
    "text": "outgoing requests where while I'm making one outgoing request and waiting for response I can issue another one that runs at the same time we want current",
    "start": "381199",
    "end": "388400"
  },
  {
    "text": "incoming requests so while I'm handling one incoming request and making those outgoing requests I can concurrently handle another incoming request in the",
    "start": "388400",
    "end": "394639"
  },
  {
    "text": "same components which can have its own outgoing requests then lastly we want streaming bodies of these requests and responses",
    "start": "394639",
    "end": "401120"
  },
  {
    "text": "so that as different chunks of data arrive I get them as they come in and we need to be able to do all this",
    "start": "401120",
    "end": "407120"
  },
  {
    "text": "so instead of this simple HTTP in Wy 0.2 W HTP is defined like this the proxy",
    "start": "407120",
    "end": "414160"
  },
  {
    "text": "World Imports an outgoing Handler and exports an incoming Handler which are different interfaces",
    "start": "414160",
    "end": "420199"
  },
  {
    "text": "the outgoing Handler will take an outgoing request and return an incoming response and incoming Handler is similar",
    "start": "420199",
    "end": "425879"
  },
  {
    "text": "but similar with just reverse directions and then instead of two request uh and response resources we now",
    "start": "425879",
    "end": "432599"
  },
  {
    "text": "have four Crossing request and response with incoming and outgoing and all four of them have a body method that would",
    "start": "432599",
    "end": "439120"
  },
  {
    "text": "return an input and output stream and we factor out these input and output stream resource types into wzi",
    "start": "439120",
    "end": "445120"
  },
  {
    "text": "iio so they can be shared with all the proposals that want to do streaming ofes like wazzy file system",
    "start": "445120",
    "end": "450599"
  },
  {
    "text": "and the pattern here is that when I do a reader wres and it's not ready either because the there's back pressure on the",
    "start": "450599",
    "end": "455840"
  },
  {
    "text": "rights or there there's no Bites available for the read then they return a sentinel value like zero or the empty list when that happens I need to call",
    "start": "455840",
    "end": "462800"
  },
  {
    "text": "the Subscribe method which returns a pullable and then when I have all the pobles for all the things that I want to wait on I can call this synchronous",
    "start": "462800",
    "end": "468960"
  },
  {
    "text": "blocking pole function passing all the pobles that I'm waiting on and it'll block until one of them's ready or one or more of them ready and then it'll",
    "start": "468960",
    "end": "475039"
  },
  {
    "text": "return which ones are ready and then I can call there read and write and make progress so we can see this is",
    "start": "475039",
    "end": "480400"
  },
  {
    "text": "significantly more complex than that simple HTP but achieves a lot of the concurrency we want so you know that's",
    "start": "480400",
    "end": "486199"
  },
  {
    "text": "you know what we did in 0.2 it's great but it does leave some room for improvement in wazzy 0.3 so first if",
    "start": "486199",
    "end": "494599"
  },
  {
    "text": "you're familiar with select uh you'll have noticed pole is o n and so that means it'll have the same scalability problems if you have a lot of",
    "start": "494599",
    "end": "500960"
  },
  {
    "text": "pobles and this is an easy enough to fix thing we just need to add some sort of eole like resource to azi",
    "start": "500960",
    "end": "506440"
  },
  {
    "text": "iio more significantly though the generated binding for 0.2 end up just being too ra ver boasts in low level cuz",
    "start": "506440",
    "end": "513839"
  },
  {
    "text": "no one wants to manage like a bunch of pobl you want to use our native language Native concurrency features like you",
    "start": "513839",
    "end": "519120"
  },
  {
    "text": "know a syn8 promises Futures go routines go routines actors and lastly uh we've lost that",
    "start": "519120",
    "end": "525480"
  },
  {
    "text": "kind of nice Lego block composability that I we saw with simple HTP because simply because the interfaces are just",
    "start": "525480",
    "end": "531640"
  },
  {
    "text": "different and they're not like trivially adaptable so what happens in in uh in practice if folks want to do this and",
    "start": "531640",
    "end": "537800"
  },
  {
    "text": "folks are doing this is you have to do some sort of like host specific middleware service chaining framework that you use to link the compounds",
    "start": "537800",
    "end": "543720"
  },
  {
    "text": "together in some other way so how do we actually improve this and do some of",
    "start": "543720",
    "end": "548920"
  },
  {
    "text": "these things or fix some of these well first let me take a step back and let's walk through how a cross component call",
    "start": "548920",
    "end": "554320"
  },
  {
    "text": "Works in 0.2 today so let's say I am defining a component that exports a transform",
    "start": "554320",
    "end": "560040"
  },
  {
    "text": "function and this is something I could Implement in just a few lines of JavaScript using jco componenti today",
    "start": "560040",
    "end": "565480"
  },
  {
    "text": "it's all like uppercase of string so componenti will spit out a compon containing a core module that core",
    "start": "565480",
    "end": "571079"
  },
  {
    "text": "module will export a core function that takes that string as a pointer length pair which are Pointers into the linear",
    "start": "571079",
    "end": "577120"
  },
  {
    "text": "memory of WM because that's how WM takes all compound values so that raises the question how specifically do we go from",
    "start": "577120",
    "end": "583480"
  },
  {
    "text": "this highle string type and the low level low-level layout of you know bits in memory and i32",
    "start": "583480",
    "end": "589480"
  },
  {
    "text": "pointers and to answer this the component model provides a let's called a lifting definition which lifts a core",
    "start": "589480",
    "end": "595640"
  },
  {
    "text": "function into a component level function and in this lifting definition we get to specify a bunch of different options",
    "start": "595640",
    "end": "601040"
  },
  {
    "text": "like which memory to use because there can be multiple which allocation function to use that's somewhere in the core module and what string encoding to",
    "start": "601040",
    "end": "607959"
  },
  {
    "text": "use and the point is I can have another component that Imports this transform function and it has its own core module",
    "start": "607959",
    "end": "614399"
  },
  {
    "text": "and its own linear memory and it can lower this imported transform function which is kind of the opposite of LT",
    "start": "614399",
    "end": "620800"
  },
  {
    "text": "lowering a component level function into a core function getting to specify the same sort of options like this memory",
    "start": "620800",
    "end": "626720"
  },
  {
    "text": "this allocation function and maybe I want to use utf16 in this comp component and it's the component model's job to make this call kind of just work so how",
    "start": "626720",
    "end": "633640"
  },
  {
    "text": "does it just work so let's say control flow enters the caller corm function somehow and the caller writes their",
    "start": "633640",
    "end": "640079"
  },
  {
    "text": "utf16 arguments into memory that they want to pass to the collie so the caller",
    "start": "640079",
    "end": "645399"
  },
  {
    "text": "then calls the imported transform function but we can't call the transform function of the collie directly because first of all it has literally a",
    "start": "645399",
    "end": "651279"
  },
  {
    "text": "different signature but also it's like relative to different memories so the I 32s are you know offsets into different",
    "start": "651279",
    "end": "656519"
  },
  {
    "text": "memories so instead the call goes into a cross component adapter that's defined by the component model which is",
    "start": "656519",
    "end": "662320"
  },
  {
    "text": "generated at compil Time by aead of time Fusion of the lifting and lowering to do one kind of optimized Fusion of them and",
    "start": "662320",
    "end": "668800"
  },
  {
    "text": "so this adapter starts by calling the allocation function of the collie to allocate a buffer and then do a fused",
    "start": "668800",
    "end": "675959"
  },
  {
    "text": "copy and transcode of the utf16 into the utf8 arguments and given this the",
    "start": "675959",
    "end": "681480"
  },
  {
    "text": "adapter now calls the transform function passing a pointer to this now utf8 argument the trans transform function",
    "start": "681480",
    "end": "687800"
  },
  {
    "text": "runs produces the utf8 results and returns a pointer to the adapter the adapter now calls the allocation",
    "start": "687800",
    "end": "693279"
  },
  {
    "text": "function of the caller getting a buffer in the caller's memory and now does a fused copy and trans code of utf8 back",
    "start": "693279",
    "end": "699720"
  },
  {
    "text": "into utf16 and Returns the resulting string to the collar now in the expected memory and the expected",
    "start": "699720",
    "end": "706240"
  },
  {
    "text": "encoding and so what we can see is that the component model like kind of cover",
    "start": "706240",
    "end": "711600"
  },
  {
    "text": "you know uh covers these differences in lifting and lowering options and what's cool is we can spec more of these",
    "start": "711600",
    "end": "716920"
  },
  {
    "text": "lifting and lowering options over time as long as they compose with all the other lifting lowering options because",
    "start": "716920",
    "end": "723279"
  },
  {
    "text": "the point is that these are an implementation detail the only thing we see in the signature is the component type we don't have to shouldn't have to",
    "start": "723279",
    "end": "729160"
  },
  {
    "text": "care about what the lifting and lowering option of the other side is",
    "start": "729160",
    "end": "733880"
  },
  {
    "text": "doing so for example now that wmgc is at stage four it's just a matter of time until we add a GC option actually",
    "start": "734199",
    "end": "739760"
  },
  {
    "text": "there's a PR proposing this like in progress today and this GC option would be able to say instead of the linear",
    "start": "739760",
    "end": "745920"
  },
  {
    "text": "memory and allocation function uh you can use WM GC array types and then use the GC to allocate the memory and the",
    "start": "745920",
    "end": "751560"
  },
  {
    "text": "other side's still doing linear memory and so the component M can make this just work and compose so back getting back to our 0.3",
    "start": "751560",
    "end": "759480"
  },
  {
    "text": "question of what we can do to improve the concurrency situation what if we added an async lift in lower option then",
    "start": "759480",
    "end": "768560"
  },
  {
    "text": "a sync would not be part of the public interface and instead each component could choose whether to do a sync as an",
    "start": "768560",
    "end": "774199"
  },
  {
    "text": "implementation detail of that components which is important because not all components can or should be a sync and",
    "start": "774199",
    "end": "781560"
  },
  {
    "text": "we don't want to partition the ecosystem based on this synness we don't want to have to say what color is your components and by reference to what",
    "start": "781560",
    "end": "787800"
  },
  {
    "text": "colors your function blog post um but the question we have to ask is you know would it compose and",
    "start": "787800",
    "end": "794639"
  },
  {
    "text": "historically this has uh been tricky to achieve you know getting syn and async to compose but by the power of",
    "start": "794639",
    "end": "801079"
  },
  {
    "text": "components particularly their uh shared nothingness uh I think yeah I think perhaps you can so let's let's see how",
    "start": "801079",
    "end": "808839"
  },
  {
    "text": "but first a disclaimer uh this is a sketch not a complete design the goal is to communicate early thinking to solicit",
    "start": "808839",
    "end": "814440"
  },
  {
    "text": "feedback it may all be totally wrong but with that disclaimer out of the way let's start by seeing how a single async",
    "start": "814440",
    "end": "819560"
  },
  {
    "text": "component could work say a component that Imports a fetch function and uses that to implement an exported lookup",
    "start": "819560",
    "end": "825440"
  },
  {
    "text": "function so our control flow starts in the host event Loop calls into the lookup function which we've lifted with",
    "start": "825440",
    "end": "832240"
  },
  {
    "text": "this new async option and so the core exported signature is totally different the first weird thing we'll notice is that the parameters are empty and in",
    "start": "832240",
    "end": "839079"
  },
  {
    "text": "instead we have to import this uh built-in called call. start which returns our arguments so what's the",
    "start": "839079",
    "end": "845759"
  },
  {
    "text": "reason for all this runaround well now that we're in the async world it's possible to have too many active calls which are each using",
    "start": "845759",
    "end": "852240"
  },
  {
    "text": "up memory and if another call happens which allocates further into our address space we can o so we need to be able to",
    "start": "852240",
    "end": "857560"
  },
  {
    "text": "exert back pressure and back pressure we exert by waiting to delay the call of",
    "start": "857560",
    "end": "862800"
  },
  {
    "text": "call. start until more pre uh currently in progress calls finish so this is like",
    "start": "862800",
    "end": "867959"
  },
  {
    "text": "useful here in general but also it's going to be super useful in just a little bit so this back pressure will become back but no back pressure here so",
    "start": "867959",
    "end": "875240"
  },
  {
    "text": "we just start the call that returns our arguments and now we call fetch fetch can block and we don't want to block the",
    "start": "875240",
    "end": "881120"
  },
  {
    "text": "CER but since we've lowered with this new async Option the imported core signature of fetch is different also it",
    "start": "881120",
    "end": "887680"
  },
  {
    "text": "takes the results as an out parameter that get filled in asynchronously and returns a status of this call which can",
    "start": "887680",
    "end": "893399"
  },
  {
    "text": "be that this call is not done it's blocked and then when that happens we get back an index into an async call",
    "start": "893399",
    "end": "899320"
  },
  {
    "text": "table of calls that are in progress which is maintained by the component model so now we have an async fetch in progress and lookup gets to keep running",
    "start": "899320",
    "end": "907000"
  },
  {
    "text": "so it can do another Fetch and that can block and that can return that it's not done and now we have two async fetches",
    "start": "907000",
    "end": "912399"
  },
  {
    "text": "in progress and now to actually make some progress or wait for one of these to finish lookup can return to the",
    "start": "912399",
    "end": "918079"
  },
  {
    "text": "host's event Loop saying that it's not done when it does this it also gets to return a context parameter which is just",
    "start": "918079",
    "end": "924639"
  },
  {
    "text": "some arbitrary i32 that it makes up or gets to choose and the idea is that this lifting definition also has a call back",
    "start": "924639",
    "end": "931519"
  },
  {
    "text": "immediate which is a second function that gets called back by the host when an event has happened threading through",
    "start": "931519",
    "end": "937319"
  },
  {
    "text": "this context that maintains the async call State so let's say the time passes",
    "start": "937319",
    "end": "942680"
  },
  {
    "text": "the fetch finishes and so the host calls our call back and says hey that call zero is done now so we make some",
    "start": "942680",
    "end": "948720"
  },
  {
    "text": "progress and then return back to the event Loop saying I need to wait for the second to finish more time passes the second fetch finishes and the host calls",
    "start": "948720",
    "end": "955319"
  },
  {
    "text": "us back again says hey your second Call's done now so now the sync lookup function can compute its final results",
    "start": "955319",
    "end": "961160"
  },
  {
    "text": "and pass it out with call. return which is kind of the opposite of call. start and now the whole a sync call is done",
    "start": "961160",
    "end": "968279"
  },
  {
    "text": "and the important thing is that all this lowlevel ABI stuff is not what I have to write this is what the compiler does for me what I want to write is ultimately",
    "start": "968279",
    "end": "974360"
  },
  {
    "text": "some async JavaScript that exports an async function that calls a weight of Fetch and that can just work because we",
    "start": "974360",
    "end": "981800"
  },
  {
    "text": "have these lifting and lowering definitions that connect the highle type which is what the bindings need to generate the idiomatic async functions",
    "start": "981800",
    "end": "989279"
  },
  {
    "text": "with the low-level concurrent ABI that the uh runtime the concurrency runtime of the language actually needs to",
    "start": "989279",
    "end": "995279"
  },
  {
    "text": "integrate with but we always have to ask does it compose so let's now consider two",
    "start": "995279",
    "end": "1001920"
  },
  {
    "text": "components in the case where they're both async so this is a compon you know we'll",
    "start": "1001920",
    "end": "1006959"
  },
  {
    "text": "start with a component the same shape as the last one and we'll Link in another component that Imports that lookup and",
    "start": "1006959",
    "end": "1012560"
  },
  {
    "text": "exports a transform function and it's all lifted and lowered with a sync so control flow start in the",
    "start": "1012560",
    "end": "1019120"
  },
  {
    "text": "host event Loop calls into the transform function which calls through an adapter into the lookup function the lookup",
    "start": "1019120",
    "end": "1024400"
  },
  {
    "text": "function calls fetch it blocks returns that it's not done and now we have an async fetch in progress lookup wants to",
    "start": "1024400",
    "end": "1030319"
  },
  {
    "text": "wait for that result so it returns to the event Loop which is the adapter in this case the adapter knows that the",
    "start": "1030319",
    "end": "1035438"
  },
  {
    "text": "caller is also async so it just takes that context bottles it up into an async lookup function and returns back to the",
    "start": "1035439",
    "end": "1040918"
  },
  {
    "text": "transform saying the Call's not done so now transform can keep running and it can do lots of stuff including making",
    "start": "1040919",
    "end": "1047160"
  },
  {
    "text": "another async call to look up and if that happens the same sequence happens and now we have two aing fetches and",
    "start": "1047160",
    "end": "1052520"
  },
  {
    "text": "lookups in progress transform can now return to the host event Loop to wait wait for uh one of them to make progress",
    "start": "1052520",
    "end": "1059280"
  },
  {
    "text": "so time passes a fetch finishes and the host calls the call back of the first components to say your fetch is done now",
    "start": "1059280",
    "end": "1066440"
  },
  {
    "text": "call back one can now complete this async lookup Call by producing a results and return back to the event Loop the",
    "start": "1066440",
    "end": "1072360"
  },
  {
    "text": "host knows that component 2 is waiting on that lookup so it calls call back two saying your First Call to lookup",
    "start": "1072360",
    "end": "1078440"
  },
  {
    "text": "finished make progress it needs to go back it returns to the event Loop to wait for the second one to finish time",
    "start": "1078440",
    "end": "1084280"
  },
  {
    "text": "passes the second fetch finishes CB1 is called again saying uh your second fetch",
    "start": "1084280",
    "end": "1089760"
  },
  {
    "text": "is done it computes a result completing the second look a call and then CB2 is called again saying your second lookup",
    "start": "1089760",
    "end": "1095320"
  },
  {
    "text": "Call is done it gets to compute its results and that's the result of the whole async lookup call or transform",
    "start": "1095320",
    "end": "1101320"
  },
  {
    "text": "call excuse me and then the whole async call stack is done so this is kind of noisy But ultimately this is like normal",
    "start": "1101320",
    "end": "1107919"
  },
  {
    "text": "lowlevel event Loop currency and the point is you know we're we're not writing this manually and we're we're",
    "start": "1107919",
    "end": "1113120"
  },
  {
    "text": "writing highle languages and we're doing this in a cross- language manner so component one can be written in Asing JavaScript and component two can be an",
    "start": "1113120",
    "end": "1119280"
  },
  {
    "text": "Asing crust for example all right well now let's switch to the case where the calling component",
    "start": "1119280",
    "end": "1125200"
  },
  {
    "text": "is sync say it's some python code that does a synchronous lookup Call and concretely this is when the call E uses",
    "start": "1125200",
    "end": "1132559"
  },
  {
    "text": "a sync but the caller component doesn't and the default is synchronous that's what we have in 0.2 so so control FL starts in the host",
    "start": "1132559",
    "end": "1140159"
  },
  {
    "text": "event Loop calls the synchronous transform function which calls through the adapter into the async lookup function let's say it kicks off two",
    "start": "1140159",
    "end": "1146320"
  },
  {
    "text": "concurrent fetches and now returns to the adapter the adapter knows the CER is sync and waiting so the adapter just",
    "start": "1146320",
    "end": "1152520"
  },
  {
    "text": "spins the event Loop in place and waits for a fetch to finish and then delivers all the results and keeps going until",
    "start": "1152520",
    "end": "1158200"
  },
  {
    "text": "eventually the whole async hup call is finished and then the adapter Returns the synchronous result to the transform",
    "start": "1158200",
    "end": "1164039"
  },
  {
    "text": "function as expected and the whole call completes so this case kind of falls out in the obvious way and so we call it the",
    "start": "1164039",
    "end": "1170520"
  },
  {
    "text": "easy case now if we reverse the cases where the calling component is async and",
    "start": "1170520",
    "end": "1175600"
  },
  {
    "text": "the call E is sync this ends up being the hard case so let's make some space and see how this case works out because",
    "start": "1175600",
    "end": "1181960"
  },
  {
    "text": "it's fun so we start in the host event Loop we call into our async transform function which calls through the adapter",
    "start": "1181960",
    "end": "1188080"
  },
  {
    "text": "into the synchronous lookup function which now synchronously calls fetch fetch can block now we don't want to",
    "start": "1188080",
    "end": "1193960"
  },
  {
    "text": "suspend or block the entire call stack because we need to get back somehow to this a synchronous transform function so",
    "start": "1193960",
    "end": "1200240"
  },
  {
    "text": "it can make progress cuz it's that's what it wants to do so we use low-l VM",
    "start": "1200240",
    "end": "1205520"
  },
  {
    "text": "trickery to suspend this the synchronous col stack up to the adapter and this technique is variously called fibers or",
    "start": "1205520",
    "end": "1212240"
  },
  {
    "text": "stack full Co routines or delimited continuations but whatever you call it the stack gets bottled up by the adapter",
    "start": "1212240",
    "end": "1218000"
  },
  {
    "text": "and then returned as a normal async call to the async caller who can keep running",
    "start": "1218000",
    "end": "1223159"
  },
  {
    "text": "so is that it is you know job's done well not quite we have to consider what happens if the async collar now tries to",
    "start": "1223159",
    "end": "1230080"
  },
  {
    "text": "re-enter that synchronous and now suspended call E which it can totally do like we saw that in the previous example",
    "start": "1230080",
    "end": "1235840"
  },
  {
    "text": "async callers can rein call any call E so it's not wrong for transform to want to do this but we have to say like what",
    "start": "1235840",
    "end": "1242080"
  },
  {
    "text": "actually happens because if we simply re-enter the components like it's suspended it's",
    "start": "1242080",
    "end": "1248200"
  },
  {
    "text": "doing like a synchronous read call and we just suspended it so if we just run arbitrary code that's just like totally",
    "start": "1248200",
    "end": "1253240"
  },
  {
    "text": "going to blow things up it's going to like break all the assumptions nobody expects to be red when they do some",
    "start": "1253240",
    "end": "1258360"
  },
  {
    "text": "random ROM you know blocking synchronous CIS call so we can't do that and we also",
    "start": "1258360",
    "end": "1264480"
  },
  {
    "text": "can't uh just trap because it's nothing wrong for the caller to want to do this so instead to fix this hole in the plan",
    "start": "1264480",
    "end": "1271600"
  },
  {
    "text": "we apply our friendly good old friend back pressure we can just say the adapter says I see the col is suspended",
    "start": "1271600",
    "end": "1278520"
  },
  {
    "text": "so I'm just going to return that the call hasn't started which is totally a thing that can happen with an acing call it's just like we're saying we apply",
    "start": "1278520",
    "end": "1285080"
  },
  {
    "text": "back pressure as soon as we have more than one we would have more than one call in progress so now we have two async lookup calls",
    "start": "1285080",
    "end": "1291480"
  },
  {
    "text": "going and the transform function can keep running and eventually it's done and it or needs to wait for Progress so",
    "start": "1291480",
    "end": "1298120"
  },
  {
    "text": "it turns to the host event Loop and's see how this plays out so time passes the fetch call makes progress so that",
    "start": "1298120",
    "end": "1304840"
  },
  {
    "text": "fiber is resumed now the fetch can return its synchronous result or its results synchronously to the lookup",
    "start": "1304840",
    "end": "1310080"
  },
  {
    "text": "function which returns its results the host knows that there's an inced or a waiting lookup function so it",
    "start": "1310080",
    "end": "1316600"
  },
  {
    "text": "immediately kicks that off so now that's second lookup Call starts it can call fetch that can block we suspend the",
    "start": "1316600",
    "end": "1322840"
  },
  {
    "text": "fiber and now the host can know that knows that the uh second component was waiting for the first lookup Call and",
    "start": "1322840",
    "end": "1328960"
  },
  {
    "text": "the first look lookup Call is done so the host calls CB2 and says your first",
    "start": "1328960",
    "end": "1334000"
  },
  {
    "text": "fetch is done so that makes progress and goes back to wait to the event Loop now the second fetch call finishes which",
    "start": "1334000",
    "end": "1340360"
  },
  {
    "text": "returns its result to lookup which returns its results and now CB2 is called again and the transform function",
    "start": "1340360",
    "end": "1346000"
  },
  {
    "text": "can return its final async results so that kind of explains you know how the hard case would work and it you know",
    "start": "1346000",
    "end": "1352600"
  },
  {
    "text": "seems like it would compose and work so that's awesome and what I think is cool about this is that it uniquely leverages",
    "start": "1352600",
    "end": "1358799"
  },
  {
    "text": "this power of components and to kind of illustrate why let's consider trying to apply the same technique without the",
    "start": "1358799",
    "end": "1364120"
  },
  {
    "text": "benefit of components where we just have a SE of functions some async and sync so control flow enters the async functions",
    "start": "1364120",
    "end": "1370279"
  },
  {
    "text": "they call into the sync functions they block we suspend them and so if we call those functions again yeah they should",
    "start": "1370279",
    "end": "1375440"
  },
  {
    "text": "exert back pressure but what about all the other functions what can I call any of them well let's say that in the",
    "start": "1375440",
    "end": "1381919"
  },
  {
    "text": "middle of being suspended these synchronous functions were modifying some state that state could be in sort of a corrupted sort of intermediate",
    "start": "1381919",
    "end": "1388840"
  },
  {
    "text": "state so we need to consider that state suspended and therefore any function that accesses that suspended State",
    "start": "1388840",
    "end": "1394600"
  },
  {
    "text": "should also be considered function uh suspended transitively but if we have some State",
    "start": "1394600",
    "end": "1400159"
  },
  {
    "text": "over here that was not being modified it's fine so any functions that only access that state are fine and",
    "start": "1400159",
    "end": "1405200"
  },
  {
    "text": "transitively access them are fine so we have some functions that are fine a call but others that aren't so how do we",
    "start": "1405200",
    "end": "1410960"
  },
  {
    "text": "actually partition State and code like this uh practically and concretely because we have to be very precise about",
    "start": "1410960",
    "end": "1416400"
  },
  {
    "text": "this well this is hard to do in most languages using normal language features",
    "start": "1416400",
    "end": "1421840"
  },
  {
    "text": "like probably hle can do a thing with monads but I think all other languages are going to have trouble but by the power components we",
    "start": "1421840",
    "end": "1428919"
  },
  {
    "text": "basically got it for free because components naturally partition code and States so you know shared nothing for",
    "start": "1428919",
    "end": "1434880"
  },
  {
    "text": "the win so then going back back to our question of would async as a lifting and",
    "start": "1434880",
    "end": "1440400"
  },
  {
    "text": "lowering option compos you know we enumerated the four cases and they all seem to do a sensible thing so it seems",
    "start": "1440400",
    "end": "1446880"
  },
  {
    "text": "like yes they could then applying that back to the wazy HTP question in 0.3",
    "start": "1446880",
    "end": "1454120"
  },
  {
    "text": "then our proxy world can Import and Export the same Handler interface which could look this uh which means we can",
    "start": "1454120",
    "end": "1460279"
  },
  {
    "text": "compose proxy components again like we were in the simple HTTP they can just snap together so that's great and our",
    "start": "1460279",
    "end": "1467399"
  },
  {
    "text": "Handler interface can BAS Al look the same as it did in simple HB Handler because now when we go down our concurrency checklist we can get",
    "start": "1467399",
    "end": "1474520"
  },
  {
    "text": "concurrent outgoing requests by lower async and we can get concurrent incoming requests if we lift async and that just",
    "start": "1474520",
    "end": "1482240"
  },
  {
    "text": "leaves the question of how to do the streaming bodies of requests and responses and to do that we need to add",
    "start": "1482240",
    "end": "1488039"
  },
  {
    "text": "a stream type and with that stream type we can tweak our original simple HTP",
    "start": "1488039",
    "end": "1493320"
  },
  {
    "text": "request to instead of taking a list of u8s as his body to take a stream of u8 as the body and similarly the body",
    "start": "1493320",
    "end": "1499320"
  },
  {
    "text": "method to return a stream of u8 and thus stream is part of the wit interface unlike a sync which is an",
    "start": "1499320",
    "end": "1506480"
  },
  {
    "text": "implementation detail and that's because all code needs to care about streams if for no other reason than to avoid o",
    "start": "1506480",
    "end": "1513240"
  },
  {
    "text": "because streams are meant for cases where you have large potentially very large amounts of byes that don't all fit into",
    "start": "1513240",
    "end": "1519120"
  },
  {
    "text": "memory so then just to kind of give a sample of how streaming can actually work in practice say we have a component",
    "start": "1519120",
    "end": "1525200"
  },
  {
    "text": "that exports a transform function from you know bytes to bytes from streames to streames I mean the core export looks the same as",
    "start": "1525200",
    "end": "1532960"
  },
  {
    "text": "before so this is the not difference and our control flow starts in the host event Loop which calls into the",
    "start": "1532960",
    "end": "1538799"
  },
  {
    "text": "transform function and now it starts the call based on the parameter type the return value of call. start is an index",
    "start": "1538799",
    "end": "1544919"
  },
  {
    "text": "into a readable streams table maintained by the component model that holds this stream of bytes that's coming",
    "start": "1544919",
    "end": "1550520"
  },
  {
    "text": "in so start call. start Returns the index index of that stream which is",
    "start": "1550520",
    "end": "1555559"
  },
  {
    "text": "zero now we want to create our return values we call stream. new which returns two indices the readable and writable",
    "start": "1555559",
    "end": "1562840"
  },
  {
    "text": "end of the same new Stream So streams have two ends the readable and writable ends and now we have handles to both of",
    "start": "1562840",
    "end": "1568120"
  },
  {
    "text": "them but it's the same stream so we have those two indices now we do call. return to return",
    "start": "1568120",
    "end": "1574440"
  },
  {
    "text": "the readable end of this new stream we just created which transfers ownership of it to the calling component or the",
    "start": "1574440",
    "end": "1580320"
  },
  {
    "text": "host because these readable and writable ends are uniquely owned by only one component so now we have the readable",
    "start": "1580320",
    "end": "1586200"
  },
  {
    "text": "end of our parameter and the writable ends of our return value which is what we want so now we can actually do some",
    "start": "1586200",
    "end": "1591679"
  },
  {
    "text": "streaming so we allocate a buffer in our in our memory and we call stream. read",
    "start": "1591679",
    "end": "1596799"
  },
  {
    "text": "passing the pointer to that buffer and saying which stream we want to read from which installs a pointer from the readable stream to our buffer now if",
    "start": "1596799",
    "end": "1603520"
  },
  {
    "text": "bytes are already available they can be immediately copied in but in general we'll have to wait so stream. read returns that it's not done and then to",
    "start": "1603520",
    "end": "1610480"
  },
  {
    "text": "wait for that transform returns to the host event Loop saying it's not done time passes bites get written into the",
    "start": "1610480",
    "end": "1616159"
  },
  {
    "text": "buffer that came from wherever and now our call back gets called saying you read let's say two bytes at the readable",
    "start": "1616159",
    "end": "1622559"
  },
  {
    "text": "stream at index zero and oh by the way the stream is closed now so that's all the bytes you're all ever going to get from the stream so we now have our",
    "start": "1622559",
    "end": "1628720"
  },
  {
    "text": "inputs and we want to write our output so we transform it to an output buffer say we capitalize it now we call stream.",
    "start": "1628720",
    "end": "1635320"
  },
  {
    "text": "WR stream. right in uh now points to or the rable stream now points to our output buffer and then this is a chance",
    "start": "1635320",
    "end": "1642840"
  },
  {
    "text": "for there to be back pressure if we're writing too much and we need to slow down the stream. write can return that",
    "start": "1642840",
    "end": "1647960"
  },
  {
    "text": "it's not done and then we have to return to the event Loop to wait for the right to complete and then our call back gets",
    "start": "1647960",
    "end": "1654080"
  },
  {
    "text": "called again saying hey we wrote two bytes and if that's all we wanted to write we can now close the stream removing it from a writable streams",
    "start": "1654080",
    "end": "1660600"
  },
  {
    "text": "table and now the whole async call can be done so one thing we can notice from",
    "start": "1660600",
    "end": "1666120"
  },
  {
    "text": "this is this is more of a completion based uh API ABI kind of like iur ring and in fact iur ring would be uh able to",
    "start": "1666120",
    "end": "1672720"
  },
  {
    "text": "do a really good job optimizing this when we're doing host streaming and the other thing is that",
    "start": "1672720",
    "end": "1678760"
  },
  {
    "text": "this is designed for language integration so what I actually get to write in my source code would be say in JavaScript an async transform function",
    "start": "1678760",
    "end": "1684919"
  },
  {
    "text": "that takes a readable stream and given a readable stream I can say pipe it through a decompression stream and get a readable stream that I return and that",
    "start": "1684919",
    "end": "1690960"
  },
  {
    "text": "should just work and it's the job of the compiler and VM to integrate with all these low-level ABI as enabled by the",
    "start": "1690960",
    "end": "1697760"
  },
  {
    "text": "lifting lowering definition that connects the highle stream type to the low-l concurrency",
    "start": "1697760",
    "end": "1703518"
  },
  {
    "text": "ABI and there's a whole bunch more to say about this than time allows because One does not simply",
    "start": "1703760",
    "end": "1710240"
  },
  {
    "text": "async but briefly we'll also likely need a future type which will be rare since",
    "start": "1710240",
    "end": "1715559"
  },
  {
    "text": "we can lower a sync any import so effectively any function may can have a future return type if you want it uh but",
    "start": "1715559",
    "end": "1721840"
  },
  {
    "text": "occasionally it's still useful for advanced concurrency scenarios we would need a probably a non-blocking attributes to say this",
    "start": "1721840",
    "end": "1728519"
  },
  {
    "text": "function will never transitively make a blocking call so don't even bother with lower async or async bindings for this",
    "start": "1728519",
    "end": "1734240"
  },
  {
    "text": "function a cancellation to say I don't care about the results anymore please wrap it up but cooperatively not",
    "start": "1734240",
    "end": "1740480"
  },
  {
    "text": "brutally like P thread kill flushing to say nothing is coming for a while so",
    "start": "1740480",
    "end": "1745640"
  },
  {
    "text": "flush all the buffers splicing to efficiently zero copy from readable to ridable streams and to allow us to tear",
    "start": "1745640",
    "end": "1752399"
  },
  {
    "text": "down WM Ines once all that's left is host to host splices and structure concurrency to",
    "start": "1752399",
    "end": "1758399"
  },
  {
    "text": "provide cross component call Stacks and also get open Telemetry spans for free which we can enforce via trapping rules",
    "start": "1758399",
    "end": "1764799"
  },
  {
    "text": "just by saying that import calls are not allowed to outlive their parent EXP calls so where are threads all this you",
    "start": "1764799",
    "end": "1771960"
  },
  {
    "text": "might be asking well threads importantly are an orthogonal feature so you can be",
    "start": "1771960",
    "end": "1777440"
  },
  {
    "text": "a sync without multi-threading and you can do multi-threading without being a sync so how do you multi-thread well",
    "start": "1777440",
    "end": "1782919"
  },
  {
    "text": "that's a whole separate topic but there is a thread. new built-in proposed in the component model that you can see right now in the component model",
    "start": "1782919",
    "end": "1788440"
  },
  {
    "text": "explainer and it is layered on top of a new core web assembly proposal that's receiving a lot of active work by the",
    "start": "1788440",
    "end": "1793799"
  },
  {
    "text": "browsers right now called shared everything threads which introduces a shared attribute that's critically used",
    "start": "1793799",
    "end": "1798960"
  },
  {
    "text": "by thread. new and can I use both together well yes in theory the feature should compose but",
    "start": "1798960",
    "end": "1805760"
  },
  {
    "text": "we're still figuring out those details so I won't attempt to sketch them here so as next steps well good news is",
    "start": "1805760",
    "end": "1813519"
  },
  {
    "text": "that experimental work is well underway and you know all credit going to Joel dice at firon for doing this he's got a",
    "start": "1813519",
    "end": "1819760"
  },
  {
    "text": "project called Isis Wasa which stands for isyn you sync we all syn for iyn which is really cool worth checking out",
    "start": "1819760",
    "end": "1825880"
  },
  {
    "text": "just for the name it's an experimental polyfill of 0.3 features on top of 0.2",
    "start": "1825880",
    "end": "1831559"
  },
  {
    "text": "runtimes exploring guest bindings in the full async developer experience and it's using a draft of Wy",
    "start": "1831559",
    "end": "1839120"
  },
  {
    "text": "hgp that's currently also in the Wy HP proposal and it being implemented by the Isis Wasa so you can check out what this",
    "start": "1839120",
    "end": "1846279"
  },
  {
    "text": "wazzy uh HP could actually look like with these features I'll be working on component",
    "start": "1846279",
    "end": "1852039"
  },
  {
    "text": "model spec PRS to hash out the precise details and get like full review of the details and again all of this will",
    "start": "1852039",
    "end": "1858760"
  },
  {
    "text": "happen in parallel with the incremental wazy 0.2 releases that I talked about at the",
    "start": "1858760",
    "end": "1864200"
  },
  {
    "text": "beginning so in conclusion components in 0.2 give us fabulous secret",
    "start": "1864200",
    "end": "1869880"
  },
  {
    "text": "powers but once we do serious concurrency we start to lose a few of them with 0.3 we want to fix that by",
    "start": "1869880",
    "end": "1877200"
  },
  {
    "text": "adding a new stream and future types for use and function types and a new async",
    "start": "1877200",
    "end": "1882279"
  },
  {
    "text": "ABI option that applies to all function types and for this the shared nothing design of components is is crucial",
    "start": "1882279",
    "end": "1888960"
  },
  {
    "text": "allowing synchronous and asynchronous components to compose by circumscribing suspended synchronous State and code and",
    "start": "1888960",
    "end": "1896039"
  },
  {
    "text": "if this is exciting to you if you want to get involved with wazzy or components or acing specifically check out the component model spec",
    "start": "1896039",
    "end": "1902200"
  },
  {
    "text": "REO uh there's a you can attend wazzy subgroup meetings attend component model implementation meetings hosted by the",
    "start": "1902200",
    "end": "1908559"
  },
  {
    "text": "bite code Alliance and talk to B code Alliance folks in zulip chat and that's it thanks a",
    "start": "1908559",
    "end": "1915360"
  },
  {
    "text": "lot",
    "start": "1916840",
    "end": "1919840"
  },
  {
    "text": "yeah",
    "start": "1933159",
    "end": "1936159"
  },
  {
    "text": "should have a question that was a great talk uh I'm curious about the lifting",
    "start": "1938600",
    "end": "1943960"
  },
  {
    "text": "and lowering functions um I'm worried that on a hot path potentially might be slow to be continuously lifting and",
    "start": "1943960",
    "end": "1950600"
  },
  {
    "text": "lowering uh data between two uh components is there a way to uh uh get",
    "start": "1950600",
    "end": "1956760"
  },
  {
    "text": "around that uh potentially for um components that are WR in the same language or maybe",
    "start": "1956760",
    "end": "1962000"
  },
  {
    "text": "otherwise yeah there's there's a whole Space of options one thing when you're using different Blobs of code written",
    "start": "1962000",
    "end": "1968360"
  },
  {
    "text": "the same language is you can link them into the same component either statically or as Dynamic core modules that are linked inside of a single",
    "start": "1968360",
    "end": "1974120"
  },
  {
    "text": "component and therefore they can share same memory so in the limit you can do that and when you're using like lots of packages from the same like you know",
    "start": "1974120",
    "end": "1979720"
  },
  {
    "text": "language registry like a bunch of crates that is by default what will happen so same language tends to go into the same",
    "start": "1979720",
    "end": "1985440"
  },
  {
    "text": "component um when we're in when we want actually two different components you know streams can help you know really",
    "start": "1985440",
    "end": "1992080"
  },
  {
    "text": "optimize the transfer data especially with small trunks you get a bunch of like temporal locality so cash hits so that helps things if you have large",
    "start": "1992080",
    "end": "1998320"
  },
  {
    "text": "amounts of btes resources are the thing you put the btes in the resource and transfer a handle to the resource so",
    "start": "1998320",
    "end": "2003559"
  },
  {
    "text": "you're not actually copying all the bites you're just passing around handles to the resource um and yeah there's uh",
    "start": "2003559",
    "end": "2009360"
  },
  {
    "text": "and lastly inlining is a thing we have a lot of aot knowledge of of what's linking to what so ahead of time we can",
    "start": "2009360",
    "end": "2014639"
  },
  {
    "text": "do inlining which can also reduce the cost of the lifting and lowering so these are all things that can cool thank",
    "start": "2014639",
    "end": "2020519"
  },
  {
    "text": "you so",
    "start": "2020519",
    "end": "2022799"
  },
  {
    "text": "much hi uh you you didn't mention anything about like foreign functions and um the complexities that they may",
    "start": "2032080",
    "end": "2039080"
  },
  {
    "text": "introduce with like maybe re-entrancy or um with you know bringing in effectively",
    "start": "2039080",
    "end": "2045039"
  },
  {
    "text": "the world of shared State um is that is that because there's they don't introduce complexity or we just don't",
    "start": "2045039",
    "end": "2051040"
  },
  {
    "text": "want to get into that uh what do you mean by by Foreign functions I guess uh sorry like imported",
    "start": "2051040",
    "end": "2057679"
  },
  {
    "text": "functions from host defined functions okay um sorry I I kind of",
    "start": "2057679",
    "end": "2063599"
  },
  {
    "text": "missed the the question is um the uh",
    "start": "2063599",
    "end": "2069079"
  },
  {
    "text": "imported like host defined functions can you know have their own State effectively effectively the whole world",
    "start": "2069079",
    "end": "2075398"
  },
  {
    "text": "um you you were talking about like in with back pressure you were you were depending on the fact that you can uh",
    "start": "2075399",
    "end": "2081398"
  },
  {
    "text": "analyze these data dependencies um uh and you also didn't have the ability to",
    "start": "2081399",
    "end": "2088520"
  },
  {
    "text": "like re-enter um as you would with with host defined functions um so like are are there complexities there",
    "start": "2088520",
    "end": "2095599"
  },
  {
    "text": "that we just didn't cover that you know the forign that host defined functions introduced or or um are those just",
    "start": "2095599",
    "end": "2102800"
  },
  {
    "text": "treated the same as every other yeah yeah I guess yeah they're supposed to work the same way the like one of the high level goals of the component model",
    "start": "2102800",
    "end": "2108680"
  },
  {
    "text": "is this kind of virtualization principle which is any wit interface should be implementable either by the host or a",
    "start": "2108680",
    "end": "2114920"
  },
  {
    "text": "component and you kind of don't know as the other side of the interface which you're getting and this preserves the",
    "start": "2114920",
    "end": "2120160"
  },
  {
    "text": "ability when I have a given component that I want to run I can either run a component that natively implements its Imports or if I have different Imports",
    "start": "2120160",
    "end": "2126800"
  },
  {
    "text": "you know maybe lower level ones or just something else I can have another component adapting from what I do have into what the component I want to run is",
    "start": "2126800",
    "end": "2133640"
  },
  {
    "text": "importing so this virtual virtualis ability principle is pretty important and it ends up meaning that host",
    "start": "2133640",
    "end": "2138920"
  },
  {
    "text": "functions don't act differently than what would happen with when the other side is another component thank",
    "start": "2138920",
    "end": "2147240"
  },
  {
    "text": "you so oh I go first thanks for voke amazing",
    "start": "2150359",
    "end": "2157440"
  },
  {
    "text": "uh but you said that the components should share nothing but you can",
    "start": "2157440",
    "end": "2163560"
  },
  {
    "text": "actually share memory for example or share other things like function with a",
    "start": "2163560",
    "end": "2168680"
  },
  {
    "text": "state and whatever um how are you considering to to solve this problem",
    "start": "2168680",
    "end": "2174760"
  },
  {
    "text": "within a single component you can share a lot of memory by importing or nesting",
    "start": "2174760",
    "end": "2179839"
  },
  {
    "text": "different core modules and then inside the component you can say how they all link together so that's one form of sharing that is allowed um and then I",
    "start": "2179839",
    "end": "2188079"
  },
  {
    "text": "guess another thing is if I have a component that I import and multiple components import the same Mutual shared",
    "start": "2188079",
    "end": "2194480"
  },
  {
    "text": "instance of a component it can have States and they can kind of communicate through that but it's going through an",
    "start": "2194480",
    "end": "2199760"
  },
  {
    "text": "interface in some sense that's unavoidable like as soon as you can talk to the outside world and have IO you can",
    "start": "2199760",
    "end": "2205040"
  },
  {
    "text": "indirectly have shared state so this fact that you can have this kind of high level shared state is why sometimes we",
    "start": "2205040",
    "end": "2211839"
  },
  {
    "text": "don't say shared nothing right because we're like well you do sort of share State like in this indirect way so shared nothing really means we're not",
    "start": "2211839",
    "end": "2217720"
  },
  {
    "text": "sharing the low-level bite array or like the low-level memory which we go through this interface and so there's at least",
    "start": "2217720",
    "end": "2225079"
  },
  {
    "text": "you know a separation between this like kind of more explicit sharing which now you can see in the linkage graph of oh",
    "start": "2225079",
    "end": "2231040"
  },
  {
    "text": "these two components import the same Mutual you know shared store of some sort as opposed to everything shared by",
    "start": "2231040",
    "end": "2238079"
  },
  {
    "text": "default we're all sharing in living one big bite array you know that's so it's it's sort of a difference in kind even though technically yes there's always",
    "start": "2238079",
    "end": "2244359"
  },
  {
    "text": "some probably some shared State unless you're like a pure function are you going to to to specify those kind of",
    "start": "2244359",
    "end": "2250960"
  },
  {
    "text": "sharing um well are we going to specify the yes Define formally I mean uh what a",
    "start": "2250960",
    "end": "2258319"
  },
  {
    "text": "module can export or import or what can share with other modules or yeah I I",
    "start": "2258319",
    "end": "2263480"
  },
  {
    "text": "guess you'd say the components declare very explicitly as part of the binary as part of their declared interface these are my imports and then when you",
    "start": "2263480",
    "end": "2270319"
  },
  {
    "text": "instantiate that component either as the host or some parent component you choose how those Imports get satisfied so you",
    "start": "2270319",
    "end": "2276720"
  },
  {
    "text": "know what they're connected to there's not this ambient Global state that everybody kind of gets to pull from so",
    "start": "2276720",
    "end": "2282359"
  },
  {
    "text": "that's I guess a part I didn't get to go into that's more of the other component model talk but it's Imports are",
    "start": "2282359",
    "end": "2288720"
  },
  {
    "text": "parameters when you instantiate component you are providing arguments to those parameters there's no ambient",
    "start": "2288720",
    "end": "2294240"
  },
  {
    "text": "Global shared name space of all the data stores and stuff so yeah there's a",
    "start": "2294240",
    "end": "2299359"
  },
  {
    "text": "that's a whole topic to go into separately I guess okay thanks yeah I love this idea that",
    "start": "2299359",
    "end": "2308200"
  },
  {
    "text": "I don't know they have colors of components it's funny is I work with Bob so he'll be very happy that you mentioned the color of components um I",
    "start": "2308200",
    "end": "2314680"
  },
  {
    "text": "love the idea that you can you know mix async and sync and Magic will happen I'm wondering just to make sure I understand though will I if I'm defining a",
    "start": "2314680",
    "end": "2321800"
  },
  {
    "text": "component will I always Define every function as sync or do I hint that it it",
    "start": "2321800",
    "end": "2327040"
  },
  {
    "text": "it works well asynchronously like how does that work yeah well the the signature kind of doesn't say it it's",
    "start": "2327040",
    "end": "2333839"
  },
  {
    "text": "sort of like a quality of implementation of how concurrent is this component which is kind of the case in any ways",
    "start": "2333839",
    "end": "2339720"
  },
  {
    "text": "when you implement even in a sync thing you can take lots of locks and actually in practice not be very component or you",
    "start": "2339720",
    "end": "2345200"
  },
  {
    "text": "can do a lot of optimizations and actually be very component so you could think of a sync components that lifts everything sync as just being very low",
    "start": "2345200",
    "end": "2352200"
  },
  {
    "text": "concurrency as a caller of a components yeah you can yeah uh I guess",
    "start": "2352200",
    "end": "2358240"
  },
  {
    "text": "there's a whole separate topic of what if I would like to run a bunch of comp I have there's a synchronous component I",
    "start": "2358240",
    "end": "2363960"
  },
  {
    "text": "want to do a bunch of concurrent jobs uh I can make lots of instances of this",
    "start": "2363960",
    "end": "2369000"
  },
  {
    "text": "child components and each one can do a different synchronous block and call but I'm making multiple instances so they're",
    "start": "2369000",
    "end": "2374839"
  },
  {
    "text": "separately suspended so there's a whole direction of ways that you can kind of get around synchronicity if you want to",
    "start": "2374839",
    "end": "2381520"
  },
  {
    "text": "reuse a component that's not very concurrent but you would like more concurrency so is the takeaway there that if I'm authoring a component I",
    "start": "2381520",
    "end": "2388920"
  },
  {
    "text": "Imagining the net days where I'm clear in the function definition this function is safe to call concurrently or not or",
    "start": "2388920",
    "end": "2395079"
  },
  {
    "text": "safe to call multi-thread or not in the short term it's going to be documentation like I would be very clear if I Define a component how I want to be",
    "start": "2395079",
    "end": "2402480"
  },
  {
    "text": "called if I'm thread safe or allow multiple invocations well the cool thing about",
    "start": "2402480",
    "end": "2407920"
  },
  {
    "text": "this design is you kind of don't need that right because when I call a function I know for sure if I'm call if",
    "start": "2407920",
    "end": "2413599"
  },
  {
    "text": "I lower it async it's not going to block me if it tries to block I'm going to get control flow so the worst that call can",
    "start": "2413599",
    "end": "2420040"
  },
  {
    "text": "do is itself be blocked but I don't get blocked I get to keep running I get to do other async work now if all my calls",
    "start": "2420040",
    "end": "2426800"
  },
  {
    "text": "are to the same component and it's blocked and yeah they'll they'll serialize but in some sense there was no",
    "start": "2426800",
    "end": "2431920"
  },
  {
    "text": "way around that one but that's not the same problem as in say like you know net or R like where if an async function",
    "start": "2431920",
    "end": "2438920"
  },
  {
    "text": "calls a synchronous function that blocks you're just blocked like you're you're stuck on the call stack so that's the",
    "start": "2438920",
    "end": "2444359"
  },
  {
    "text": "kind of trick we can do with the component boundary with thec the suspend and back pressure thing I guess I should probably stop now",
    "start": "2444359",
    "end": "2452400"
  },
  {
    "text": "but happy to talk more about this with everyone over the next uh year right",
    "start": "2452400",
    "end": "2459240"
  },
  {
    "text": "see",
    "start": "2463400",
    "end": "2466400"
  }
]