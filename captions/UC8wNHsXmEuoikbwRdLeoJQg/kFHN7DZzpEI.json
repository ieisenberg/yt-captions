[
  {
    "text": "Okay. So, let's start by seeing what I did off stream. As always off stream, I did some cleanup.",
    "start": "4800",
    "end": "14716"
  },
  {
    "text": "Nothing too much exciting. Mostly I've changed something in our",
    "start": "14716",
    "end": "21849"
  },
  {
    "text": "event source aggregate. Mostly on instead of having a flat",
    "start": "21849",
    "end": "30333"
  },
  {
    "text": "structure with tons of interfaces like event source aggregate, args, event source",
    "start": "30333",
    "end": "36816"
  },
  {
    "text": "aggregate, or reducer, every source aggregate, whatever.",
    "start": "36816",
    "end": "42615"
  },
  {
    "text": "I opted out for having just exported x interface, event source aggregate.",
    "start": "43199",
    "end": "48416"
  },
  {
    "text": "And then I have a namespace which has it.",
    "start": "48716",
    "end": "52433"
  },
  {
    "text": "args, either producer, draft, reducer, whatever.",
    "start": "53933",
    "end": "58433"
  },
  {
    "text": "And that helped me like clean up my typings. and that",
    "start": "59599",
    "end": "65032"
  },
  {
    "text": "was really, really great. On to the stream. I want to fix some things that I thought",
    "start": "65033",
    "end": "71983"
  },
  {
    "text": "in between streams about the implementation we did last time.",
    "start": "71983",
    "end": "77033"
  },
  {
    "text": "If you remember correctly last time we implemented an event journal storage that",
    "start": "77383",
    "end": "83416"
  },
  {
    "text": "uses SQLite as baking strategy and as you can see, creates",
    "start": "83416",
    "end": "92183"
  },
  {
    "text": "table allows the table to have any name we want and then",
    "start": "92183",
    "end": "97000"
  },
  {
    "text": "performs basically insertion, whatever we want to persist",
    "start": "97316",
    "end": "103132"
  },
  {
    "text": "something into the event journal. And if there are some error, we cast the",
    "start": "103133",
    "end": "108983"
  },
  {
    "text": "SQL Error and if we fail with an event journal, append entry failed, or we die.",
    "start": "108983",
    "end": "114099"
  },
  {
    "text": "And when we read, we just perform a select over the table for the aggregate root and ID we want to look by sequence.",
    "start": "115233",
    "end": "122533"
  },
  {
    "text": "Okay. So the only thing that I thought that maybe I want to do a little differently,",
    "start": "124316",
    "end": "131283"
  },
  {
    "text": "not too much, is the actual insertion query.",
    "start": "131900",
    "end": "135933"
  },
  {
    "text": "The thing is that right now the way I do it is basically I try to insert and if I",
    "start": "137400",
    "end": "144250"
  },
  {
    "text": "get any SQLite error, like an insertion error, like a primary",
    "start": "144250",
    "end": "150133"
  },
  {
    "text": "key that has been violated. That's the problem.",
    "start": "150133",
    "end": "153233"
  },
  {
    "text": "So that's not great because maybe if I type something like",
    "start": "155983",
    "end": "161150"
  },
  {
    "text": "name of field that will trigger as well an event journal append entry failed error,",
    "start": "161150",
    "end": "166616"
  },
  {
    "text": "but they would like this domain error to be just in the exact case where",
    "start": "166933",
    "end": "172316"
  },
  {
    "text": "basically you are trying to append an entry with a sequence and an entry with that sequence already exists.",
    "start": "172633",
    "end": "178133"
  },
  {
    "text": "So we could do that in two ways. We could open the transaction and check",
    "start": "178883",
    "end": "184033"
  },
  {
    "text": "if the entry already exists and if fixed. If it already exists, we throw them an",
    "start": "184033",
    "end": "190050"
  },
  {
    "text": "error and if not, we've performed the insertion in the same transaction,",
    "start": "190050",
    "end": "195500"
  },
  {
    "text": "but that would require a transaction and two query arrays And I think we can do that in a single",
    "start": "195783",
    "end": "200849"
  },
  {
    "text": "query by using something like insert it into our table,",
    "start": "200849",
    "end": "206550"
  },
  {
    "text": "name of fields and then instead of using values, we do select",
    "start": "206883",
    "end": "210816"
  },
  {
    "text": "and we just select the row values we want to append like that.",
    "start": "213483",
    "end": "219300"
  },
  {
    "text": "And we also add a sub query where not exists.",
    "start": "220150",
    "end": "226683"
  },
  {
    "text": "And then we do something like select one from our table, SQL.literal,",
    "start": "227866",
    "end": "242533"
  },
  {
    "text": "args.journalTableName where and here we have",
    "start": "243916",
    "end": "251983"
  },
  {
    "text": "aggregate root equals,",
    "start": "251983",
    "end": "255633"
  },
  {
    "text": "aggregate root name and aggregate id",
    "start": "257333",
    "end": "262583"
  },
  {
    "text": "equals and we have",
    "start": "262583",
    "end": "267066"
  },
  {
    "text": "and sequence greater or equal the one we want",
    "start": "267699",
    "end": "277050"
  },
  {
    "text": "to journal entry, dot sequence, the one we want to append.",
    "start": "277050",
    "end": "283216"
  },
  {
    "text": "So that means that when we perform the query, we won't append anything if",
    "start": "284500",
    "end": "293050"
  },
  {
    "text": "an entry with the same aggregate root, same aggregate ID and a sequence that",
    "start": "293116",
    "end": "299715"
  },
  {
    "text": "after the one we are trying to insert already exists. That's not the most optimized way to do",
    "start": "299716",
    "end": "307033"
  },
  {
    "text": "that, but it's still better than opening another transaction and then performing the queries.",
    "start": "307033",
    "end": "312800"
  },
  {
    "text": "So now the thing is that these roots silently fail if we have, for example, an",
    "start": "313483",
    "end": "321300"
  },
  {
    "text": "entry that already exists. These will basically just don't perform the append, but that's",
    "start": "321300",
    "end": "327816"
  },
  {
    "text": "not what we want to do. So we need to basically have a look at",
    "start": "327816",
    "end": "333383"
  },
  {
    "text": "const results equals and see what this return. just a row. And maybe we have SQL dot, let's see what",
    "start": "333383",
    "end": "342583"
  },
  {
    "text": "the methods we have. Is there a method that looks like?",
    "start": "342583",
    "end": "349583"
  },
  {
    "text": "Let me see. We need to basically see which are the options allowed by SQL.",
    "start": "349916",
    "end": "360083"
  },
  {
    "text": "Sorry, we need to have a look at effect SQL documentation or either",
    "start": "360383",
    "end": "366233"
  },
  {
    "text": "the source and see how we can retrieve the amount of affected rows for",
    "start": "366233",
    "end": "374182"
  },
  {
    "text": "that query. So let me check. We can do something like",
    "start": "374183",
    "end": "378432"
  },
  {
    "text": "effect-ts, github, we can open here. On sources, we can go to",
    "start": "380433",
    "end": "386733"
  },
  {
    "text": "packages. Let's see SQL, Lite node, for example, test client.",
    "start": "386733",
    "end": "396783"
  },
  {
    "text": "Inserting to, that's just an SQL rows, maybe.",
    "start": "399216",
    "end": "406900"
  },
  {
    "text": "Let me see, is there a way to tell the number of affected rows, packages, SQL,",
    "start": "408800",
    "end": "417816"
  },
  {
    "text": "SQL, SQL, SQL, SRC, oh, maybe, yeah. Got,",
    "start": "418083",
    "end": "430883"
  },
  {
    "text": "let's see, affected rows. No, insert.",
    "start": "433550",
    "end": "441133"
  },
  {
    "text": "User interpolation, mixed migrations, no,",
    "start": "441449",
    "end": "448916"
  },
  {
    "text": "let me check. SQL client.",
    "start": "449383",
    "end": "454116"
  },
  {
    "text": "All right, make, make with transaction. And then we have our SQL client, which comes from",
    "start": "457866",
    "end": "465500"
  },
  {
    "text": "SRC internal client. Okay, and here we",
    "start": "466233",
    "end": "472199"
  },
  {
    "text": "can see if we have method for",
    "start": "472199",
    "end": "477616"
  },
  {
    "text": "affected. We don't have that. Let's see,",
    "start": "481916",
    "end": "491133"
  },
  {
    "text": "how can we do deal with that?",
    "start": "491400",
    "end": "493916"
  },
  {
    "text": "So maybe, oh, it's something that it's database provider",
    "start": "498183",
    "end": "503433"
  },
  {
    "text": "specific, because I could see some database provider not providing the",
    "start": "503433",
    "end": "509133"
  },
  {
    "text": "amount of, the amount of affected rows.",
    "start": "509133",
    "end": "518783"
  },
  {
    "text": "Let's see.",
    "start": "518816",
    "end": "524583"
  },
  {
    "text": "Let me check in here as well, because I I think that ideally, we could take a look at",
    "start": "530716",
    "end": "543833"
  },
  {
    "text": "here, if we do dot raw,",
    "start": "543833",
    "end": "548250"
  },
  {
    "text": "I think that this returns unknown and that's it, because result",
    "start": "550666",
    "end": "557733"
  },
  {
    "text": "equals, if we try to put a breakpoint in here, I think that we",
    "start": "557733",
    "end": "565216"
  },
  {
    "text": "will see a different result.",
    "start": "565216",
    "end": "568516"
  },
  {
    "text": "Let me run our tests, maybe that one in debug mode.",
    "start": "570783",
    "end": "577282"
  },
  {
    "text": "Okay, we are hitting our previous breakpoint. Okay, let me",
    "start": "580433",
    "end": "586383"
  },
  {
    "text": "check. Here we have result. Let's just step one in. Okay.",
    "start": "586383",
    "end": "595800"
  },
  {
    "text": "Changes, here it is. Changes, we have changes one. Okay, so",
    "start": "599850",
    "end": "605500"
  },
  {
    "text": "we can do something like changes, or even better dot raw as",
    "start": "605500",
    "end": "620516"
  },
  {
    "text": "effect dot effect. And",
    "start": "620516",
    "end": "625733"
  },
  {
    "text": "here we will have changes would be a number, and then we have a",
    "start": "625733",
    "end": "633033"
  },
  {
    "text": "possible error that could be as SQL error, and nothing, as a requirement, I think.",
    "start": "633033",
    "end": "640383"
  },
  {
    "text": "Yeah, SQL error dot SQL error.",
    "start": "640649",
    "end": "644016"
  },
  {
    "text": "There it is. Here our changes is a number, okay, and now we",
    "start": "646283",
    "end": "651316"
  },
  {
    "text": "could say something like, if changes equals zero, if we didn't",
    "start": "651316",
    "end": "659582"
  },
  {
    "text": "append anything, then we can say yield star effect dot fail, and we can",
    "start": "659583",
    "end": "670532"
  },
  {
    "text": "fail basically with this. And we fail with this. Now, we don't care",
    "start": "670533",
    "end": "682500"
  },
  {
    "text": "about that. We can save that perfectly. And let our tests complete. Let's try",
    "start": "682500",
    "end": "690300"
  },
  {
    "text": "rerun them. They should be, they should run a fine changes is one. So that's fine.",
    "start": "690300",
    "end": "700800"
  },
  {
    "text": "Perfect. On-large test is okay. And so maybe we can also",
    "start": "701483",
    "end": "707000"
  },
  {
    "text": "add another tests, maybe that says, let's",
    "start": "707333",
    "end": "714300"
  },
  {
    "text": "go to the code and say this creates SQLite events. And then we can also duplicate this test",
    "start": "714300",
    "end": "722916"
  },
  {
    "text": "and say fails SQLite",
    "start": "722916",
    "end": "731550"
  },
  {
    "text": "append if already exsists. Okay, and fail.",
    "start": "734149",
    "end": "741199"
  },
  {
    "text": "We provide a different name for the table that acts as journal.",
    "start": "744783",
    "end": "750233"
  },
  {
    "text": "And then what we try to do is try to append this one two times, the",
    "start": "751399",
    "end": "762183"
  },
  {
    "text": "same event two times. And then what we would expect",
    "start": "762183",
    "end": "766600"
  },
  {
    "text": "is that if we take a look at the effect",
    "start": "767649",
    "end": "776383"
  },
  {
    "text": "dot exit of this one,",
    "start": "776383",
    "end": "781233"
  },
  {
    "text": "append result, we expect",
    "start": "783483",
    "end": "788483"
  },
  {
    "text": "Exit is failure of append result to equal two.",
    "start": "790933",
    "end": "801733"
  },
  {
    "text": "So basically, we expect to fail if we try to append the same event twice. And",
    "start": "804216",
    "end": "811250"
  },
  {
    "text": "it seems that the test was successful.",
    "start": "811333",
    "end": "815733"
  },
  {
    "text": "Let's try to run again that in debug mode and see",
    "start": "817083",
    "end": "822883"
  },
  {
    "text": "the way the break point will not need anymore. Append result",
    "start": "822883",
    "end": "828016"
  },
  {
    "text": "is a failure and we have a die defect.",
    "start": "828016",
    "end": "835149"
  },
  {
    "text": "It's a defect. Oh, I know why it's the defect. Yeah, it's right.",
    "start": "839933",
    "end": "846050"
  },
  {
    "text": "Because we said effect or die.",
    "start": "847149",
    "end": "849816"
  },
  {
    "text": "And that's not what we wanted. Because we yelled down an event and",
    "start": "852350",
    "end": "858216"
  },
  {
    "text": "then we say or die. Yeah, that's not what we want. So we could say",
    "start": "858216",
    "end": "865000"
  },
  {
    "text": "something like when we do that, we return the changes.",
    "start": "865000",
    "end": "868750"
  },
  {
    "text": "And then instead of failing early, we do",
    "start": "871383",
    "end": "877933"
  },
  {
    "text": "effect or die. And then we say effect dot",
    "start": "877933",
    "end": "883633"
  },
  {
    "text": "flat map and say if the amount of changes is",
    "start": "884616",
    "end": "890816"
  },
  {
    "text": "changes is zero. So we didn't write any",
    "start": "891583",
    "end": "896850"
  },
  {
    "text": "row. If we didn't write any row, then we won't fail.",
    "start": "896850",
    "end": "901583"
  },
  {
    "text": "Otherwise, we would just want to say that sign do nothing. So this will say,",
    "start": "902333",
    "end": "909000"
  },
  {
    "text": "shallow any error you will have and then",
    "start": "909649",
    "end": "915333"
  },
  {
    "text": "any change you will have. If it without that didn't change any rule, we fail because we",
    "start": "915333",
    "end": "921600"
  },
  {
    "text": "expected. So otherwise, if we change the list to one row, that's fine. That's exactly what we",
    "start": "921600",
    "end": "927250"
  },
  {
    "text": "wanted to perform. So let's try to run again our test in here. Again, we run the test in debug",
    "start": "927250",
    "end": "935333"
  },
  {
    "text": "mode and see, okay, append result. Now expect a failure.",
    "start": "935333",
    "end": "941000"
  },
  {
    "text": "Perfect. And it's a fail. It's not a tag and is exactly the failure we expected.",
    "start": "941500",
    "end": "948399"
  },
  {
    "text": "Perfect. So maybe let's write the test in something like more",
    "start": "949383",
    "end": "954916"
  },
  {
    "text": "interesting, more useful. Like say, expect exit dot fail",
    "start": "954916",
    "end": "963850"
  },
  {
    "text": "I think that was failure",
    "start": "968000",
    "end": "972283"
  },
  {
    "text": "cause option. Yeah. Oh, yeah. I would expect that is a failure. Yeah. Yeah. Yeah. Yeah. Yeah.",
    "start": "974933",
    "end": "980183"
  },
  {
    "text": "And then we need to say that cause",
    "start": "980550",
    "end": "984483"
  },
  {
    "text": "dot we need to import obviously the failure module from effect.",
    "start": "986533",
    "end": "991983"
  },
  {
    "text": "That's failure option of append result dot",
    "start": "994000",
    "end": "1003083"
  },
  {
    "text": "Oh, well, if append result tag is failure,",
    "start": "1007533",
    "end": "1015316"
  },
  {
    "text": "then we expect",
    "start": "1017583",
    "end": "1021050"
  },
  {
    "text": "cause to equal some.",
    "start": "1024616",
    "end": "1033799"
  },
  {
    "text": "This can be some or none. Yeah. We want that to be some",
    "start": "1036966",
    "end": "1040350"
  },
  {
    "text": "or call true even better. So option is some",
    "start": "1042533",
    "end": "1049083"
  },
  {
    "text": "so that we will tell that we expect to",
    "start": "1049899",
    "end": "1054933"
  },
  {
    "text": "have some kind of failure. We need to import option from effect. Okay.",
    "start": "1054933",
    "end": "1065250"
  },
  {
    "text": "And if we try to run again the test, that passes. Perfect. So that's one thing",
    "start": "1069233",
    "end": "1076600"
  },
  {
    "text": "that I wanted to fix. It's nothing huge, but",
    "start": "1076600",
    "end": "1082583"
  },
  {
    "text": "it's still something. And now that we have fixed that, we need",
    "start": "1082583",
    "end": "1092250"
  },
  {
    "text": "to go back. And now the thing that I wanted to do is that",
    "start": "1092250",
    "end": "1097500"
  },
  {
    "text": "we have written last time this interface that is an event source aggregate that allows you",
    "start": "1097649",
    "end": "1103315"
  },
  {
    "text": "to read the state of one domain aggregate",
    "start": "1103350",
    "end": "1108833"
  },
  {
    "text": "based on the events that have happened on that aggregate or to update the state of the domain",
    "start": "1108833",
    "end": "1116816"
  },
  {
    "text": "aggregate based on a function, a reducer basically.",
    "start": "1116816",
    "end": "1121016"
  },
  {
    "text": "And so what we need to do is provide some test to ensure that it",
    "start": "1121850",
    "end": "1127183"
  },
  {
    "text": "works as we expect. So let's buy some tests for that. So here",
    "start": "1127183",
    "end": "1136233"
  },
  {
    "text": "we'll say a clear new file event sourced",
    "start": "1136233",
    "end": "1143433"
  },
  {
    "text": "aggregate dot test dot ts. We will obviously",
    "start": "1144533",
    "end": "1150482"
  },
  {
    "text": "need some things in order to do the tests like",
    "start": "1150483",
    "end": "1155949"
  },
  {
    "text": "change aggregate, change product name, read product name. And here",
    "start": "1156699",
    "end": "1161916"
  },
  {
    "text": "we have some things that we can reuse like product being changed. Okay.",
    "start": "1161916",
    "end": "1167600"
  },
  {
    "text": "So again, here, okay. We'll import",
    "start": "1168433",
    "end": "1175483"
  },
  {
    "text": "something that we are missing like import everything as a",
    "start": "1175483",
    "end": "1182699"
  },
  {
    "text": "aggregate root from our SRC. We need to import effect",
    "start": "1182699",
    "end": "1194033"
  },
  {
    "text": "schema. Effect, sorry, from effect",
    "start": "1194083",
    "end": "1200816"
  },
  {
    "text": "schema. Then schema, schema obviously.",
    "start": "1200816",
    "end": "1207716"
  },
  {
    "text": "Okay. I don't see any other missing imports. Perfectly. I don't",
    "start": "1209216",
    "end": "1217016"
  },
  {
    "text": "care about queries for now. For now, I am focusing just on comments and events. Even not",
    "start": "1217016",
    "end": "1227850"
  },
  {
    "text": "comments, to be honest. The event source aggregate is more about just events that happens on something",
    "start": "1227850",
    "end": "1235183"
  },
  {
    "text": "like a product can have its product name changed, or maybe we will have indeed like a",
    "start": "1235183",
    "end": "1244250"
  },
  {
    "text": "product created that will",
    "start": "1244250",
    "end": "1249500"
  },
  {
    "text": "happen the first time say that I want to create any product, a product aggregate, and we",
    "start": "1249500",
    "end": "1256333"
  },
  {
    "text": "will require a name and maybe also you need a unit of measure just to create",
    "start": "1256333",
    "end": "1264733"
  },
  {
    "text": "some test that it's more like what will happen in the real world. And then we have basically created",
    "start": "1264733",
    "end": "1273683"
  },
  {
    "text": "our events and our aggregate. And now we need to import",
    "start": "1273683",
    "end": "1280148"
  },
  {
    "text": "the actual model that we want test event",
    "start": "1280233",
    "end": "1285416"
  },
  {
    "text": "source aggregate from SRC event source aggregate.",
    "start": "1285416",
    "end": "1296116"
  },
  {
    "text": "Okay. And then we will see something like",
    "start": "1297100",
    "end": "1302683"
  },
  {
    "text": "const product event journal equals events",
    "start": "1302683",
    "end": "1310500"
  },
  {
    "text": "aggregate.make and this requires you arguments like aggregate root which is",
    "start": "1313416",
    "end": "1320416"
  },
  {
    "text": "our product aggregate. aggregate. And I think that is event",
    "start": "1320416",
    "end": "1328299"
  },
  {
    "text": "types that are the possible events that can happen on that specific aggregate root. For example, we",
    "start": "1328300",
    "end": "1335500"
  },
  {
    "text": "say just like we can have a product created or a product name changed. And then we'll have things",
    "start": "1335500",
    "end": "1345399"
  },
  {
    "text": "like reduce and reduce what we'll do. Oh, sorry. Before",
    "start": "1345399",
    "end": "1352033"
  },
  {
    "text": "reduce we need the actual state shape, which is the state of the",
    "start": "1352383",
    "end": "1358399"
  },
  {
    "text": "product. And for now we could say something like schema dot option and",
    "start": "1358399",
    "end": "1367533"
  },
  {
    "text": "we will keep track schema struct maybe of product name.",
    "start": "1367533",
    "end": "1378116"
  },
  {
    "text": "schema dot schema non-empty string and",
    "start": "1379933",
    "end": "1386382"
  },
  {
    "text": "also we'll have like here the measure schema non-empty string.",
    "start": "1386383",
    "end": "1391916"
  },
  {
    "text": "And that's it. And our final thing reduce that will take state and our event that",
    "start": "1392733",
    "end": "1402283"
  },
  {
    "text": "has incoming or maybe a journal entry.",
    "start": "1403016",
    "end": "1407250"
  },
  {
    "text": "So here we'll have few things that I have changed off stream. You will see immediately. You can see",
    "start": "1411350",
    "end": "1417533"
  },
  {
    "text": "that here we have specified that the state for these domain entity of a",
    "start": "1417533",
    "end": "1423516"
  },
  {
    "text": "product is an option. And as I said, the option means that if it's none the product",
    "start": "1423516",
    "end": "1429183"
  },
  {
    "text": "doesn't exist. If it's some, then there is the product data and that allows to create an",
    "start": "1429183",
    "end": "1436433"
  },
  {
    "text": "impossible state that we cannot be represented. And then we have the",
    "start": "1436433",
    "end": "1442350"
  },
  {
    "text": "product name and unit of measure. And you see that here we have an option of an option. Okay. And that's it because",
    "start": "1442350",
    "end": "1450283"
  },
  {
    "text": "I decided that instead of having to provide an initial state argument, what we'll do",
    "start": "1450283",
    "end": "1457416"
  },
  {
    "text": "is something like if there wasn't any previous event,",
    "start": "1457416",
    "end": "1463648"
  },
  {
    "text": "that state will be known. And if something has happened before, that state will be a some",
    "start": "1464283",
    "end": "1471916"
  },
  {
    "text": "and the value will be the result of applying the previous events that have happened. So that means",
    "start": "1472133",
    "end": "1480649"
  },
  {
    "text": "that, for example, in our case, we expect",
    "start": "1481250",
    "end": "1487816"
  },
  {
    "text": "the product to have a first event of",
    "start": "1487816",
    "end": "1493199"
  },
  {
    "text": "create product. Okay. And then after we create product, then we",
    "start": "1493199",
    "end": "1500399"
  },
  {
    "text": "go and we update data on the product. So we can do something like const product equals option dot",
    "start": "1500399",
    "end": "1511216"
  },
  {
    "text": "flatten state. So that way we just get an",
    "start": "1511216",
    "end": "1519100"
  },
  {
    "text": "option instead of an optional of options. And now we can actually switch on the journal entry dot",
    "start": "1519100",
    "end": "1528516"
  },
  {
    "text": "event tag we have. And we can see things like case the product has",
    "start": "1528516",
    "end": "1535600"
  },
  {
    "text": "been created. When the product will be created, now the state will be option dot some because",
    "start": "1535600",
    "end": "1544800"
  },
  {
    "text": "now we have that journal entry some and we need to provide",
    "start": "1544800",
    "end": "1550600"
  },
  {
    "text": "the product name, go on the journal entry dot event dot name. And then instead of",
    "start": "1550633",
    "end": "1564733"
  },
  {
    "text": "your name, just name. return name and unit of measure will be",
    "start": "1564733",
    "end": "1573382"
  },
  {
    "text": "journal entry dot event dot the unit of measure. Okay, so it's",
    "start": "1573383",
    "end": "1580333"
  },
  {
    "text": "just basically copying the data over from the event into the actual state. And then the other thing",
    "start": "1580333",
    "end": "1589600"
  },
  {
    "text": "that we need to do in here is handle the case when we rename the product. So case",
    "start": "1589750",
    "end": "1599133"
  },
  {
    "text": "product name changed. And here we need to switch and say basically that return",
    "start": "1601016",
    "end": "1609149"
  },
  {
    "text": "option dot map our current product. And",
    "start": "1609816",
    "end": "1615300"
  },
  {
    "text": "if there isn't a product, we cannot change the name. If there is, then we will basically old",
    "start": "1615300",
    "end": "1622816"
  },
  {
    "text": "product and say things like we'll copy over all of the old",
    "start": "1622816",
    "end": "1628350"
  },
  {
    "text": "product but change the product name to journal entry dot event",
    "start": "1628366",
    "end": "1634550"
  },
  {
    "text": "dot. Did we forget to provide",
    "start": "1634550",
    "end": "1640233"
  },
  {
    "text": "the product name changed? Yeah, yeah.",
    "start": "1640850",
    "end": "1647632"
  },
  {
    "text": "Why are you not happy with that? Let me check. Okay, that you know what it is. Okay,",
    "start": "1655583",
    "end": "1672683"
  },
  {
    "text": "that you know what it is. Product name, that's fine.",
    "start": "1673033",
    "end": "1677949"
  },
  {
    "text": "Is it just?",
    "start": "1679633",
    "end": "1680600"
  },
  {
    "text": "New name does not exist on type product created. Yeah. And well,",
    "start": "1689550",
    "end": "1695733"
  },
  {
    "text": "this may be a TypeScript bug, I think.",
    "start": "1698300",
    "end": "1700916"
  },
  {
    "text": "Cost product named equals. That is fine.",
    "start": "1703433",
    "end": "1708233"
  },
  {
    "text": "Okay, that is indeed a type not a wind bug, I think.",
    "start": "1709399",
    "end": "1713783"
  },
  {
    "text": "Oh, oh, did I miss something in here? Case this const. Product say declaration return this.",
    "start": "1718550",
    "end": "1733850"
  },
  {
    "text": "Why did you ask an expected lexical definition in case, oh, is that?",
    "start": "1736250",
    "end": "1742033"
  },
  {
    "text": "Oh, yeah, that's it. I didn't notice it.",
    "start": "1742083",
    "end": "1751149"
  },
  {
    "text": "Sorry, sorry, sorry. So maybe that will make you happy also about that. No, that's still a",
    "start": "1752316",
    "end": "1760199"
  },
  {
    "text": "TypeScript bug. Okay, funny. Now we know. Okay, so still,",
    "start": "1760199",
    "end": "1765883"
  },
  {
    "text": "we now have basically the logic that handles that. You can",
    "start": "1765916",
    "end": "1771600"
  },
  {
    "text": "see that our typings now are nice. We see that we have an event",
    "start": "1771600",
    "end": "1776933"
  },
  {
    "text": "source aggregate for the product aggregate. And the state for that is an option which has the",
    "start": "1776933",
    "end": "1783050"
  },
  {
    "text": "unit of measure, the product name, and then has product created and product name changed. Okay,",
    "start": "1783050",
    "end": "1789433"
  },
  {
    "text": "so the other things that we get for free with this",
    "start": "1789800",
    "end": "1795716"
  },
  {
    "text": "event journal based approach is things like created at schema.date and",
    "start": "1795899",
    "end": "1805133"
  },
  {
    "text": "updated at schema.date. And",
    "start": "1805133",
    "end": "1811949"
  },
  {
    "text": "that is because now we can say created at and instead of passing",
    "start": "1812483",
    "end": "1819716"
  },
  {
    "text": "into the event the explicit date time, we can use now the journal entry dot created at and",
    "start": "1819716",
    "end": "1826583"
  },
  {
    "text": "updated at as journal entry dot created at. So now we also get for free",
    "start": "1826583",
    "end": "1834533"
  },
  {
    "text": "the ability to track things about that. So here as well,",
    "start": "1834533",
    "end": "1839549"
  },
  {
    "text": "we need to do update at journal entry dot created at. Perfect. Okay,",
    "start": "1839600",
    "end": "1848800"
  },
  {
    "text": "so now we have our basically event source aggregate. And now we want",
    "start": "1848800",
    "end": "1854350"
  },
  {
    "text": "to create some tests in order to ensure that everything is exactly how we expect it to be. So let's",
    "start": "1854350",
    "end": "1865183"
  },
  {
    "text": "just copy from here because you know, I'm silly,",
    "start": "1865183",
    "end": "1869799"
  },
  {
    "text": "and it's easier to copy paste than remember everything. Okay,",
    "start": "1870916",
    "end": "1876183"
  },
  {
    "text": "here, we need to close that, close that, and then to close that and then to close that. And",
    "start": "1876333",
    "end": "1882250"
  },
  {
    "text": "then we need to import utils from effect vitest. Okay.",
    "start": "1882250",
    "end": "1891149"
  },
  {
    "text": "Okay. We are just leaning into import effect.",
    "start": "1892199",
    "end": "1896083"
  },
  {
    "text": "And there is effect And now we also need to",
    "start": "1902583",
    "end": "1913399"
  },
  {
    "text": "provide an actual test. So let's see.",
    "start": "1915333",
    "end": "1919116"
  },
  {
    "text": "Here, we are missing one curly bracket. And there is okay.",
    "start": "1920383",
    "end": "1925733"
  },
  {
    "text": "So let's say that we have defined our product event journal. So",
    "start": "1927366",
    "end": "1932483"
  },
  {
    "text": "one test can be something like, let's say that we want to update that. So",
    "start": "1932483",
    "end": "1938816"
  },
  {
    "text": "things like yield star product event journal dot produce,",
    "start": "1938816",
    "end": "1944882"
  },
  {
    "text": "we want to change the product one. And the thing we want to",
    "start": "1945433",
    "end": "1952148"
  },
  {
    "text": "perform, we have here a draft object that has append. If I remember correctly, yeah,",
    "start": "1952149",
    "end": "1963600"
  },
  {
    "text": "we should have Event Sourced Aggregate draft. Yeah. Then the draft is basically something",
    "start": "1963816",
    "end": "1970649"
  },
  {
    "text": "that takes a function or returns an effect like append",
    "start": "1970649",
    "end": "1977549"
  },
  {
    "text": "here. And we can just say, append product",
    "start": "1978383",
    "end": "1984483"
  },
  {
    "text": "created dot make. And",
    "start": "1984483",
    "end": "1989500"
  },
  {
    "text": "here we now have to create our actual event. So let's make these",
    "start": "1989500",
    "end": "1997583"
  },
  {
    "text": "more readable, maybe. append.",
    "start": "1997583",
    "end": "2001399"
  },
  {
    "text": "Maybe we'll have something like product created event equals",
    "start": "2014500",
    "end": "2021148"
  },
  {
    "text": "yield star equals product created dot make here. And you can see",
    "start": "2021816",
    "end": "2029050"
  },
  {
    "text": "that here, we have things like our actual needed data. And we need to",
    "start": "2029050",
    "end": "2038883"
  },
  {
    "text": "provide in here as well the aggregate ID, which should be our product one. We need",
    "start": "2038883",
    "end": "2048300"
  },
  {
    "text": "to provide also the unit of measure like pieces.",
    "start": "2048300",
    "end": "2053583"
  },
  {
    "text": "And the name of the product we want to create and the product. And",
    "start": "2054833",
    "end": "2062632"
  },
  {
    "text": "any product you want to create, chat is something you want to create",
    "start": "2062633",
    "end": "2070232"
  },
  {
    "text": "something like, I don't know, I want pizzas.",
    "start": "2070233",
    "end": "2074500"
  },
  {
    "text": "You know, as Italian and still here. That's fine. That's fine.",
    "start": "2078566",
    "end": "2084932"
  },
  {
    "text": "Here. And you can see that it's screaming at me because it wants an event journal storage.",
    "start": "2085183",
    "end": "2091232"
  },
  {
    "text": "And we need to provide that dependency. So let's say that pipe",
    "start": "2091983",
    "end": "2098250"
  },
  {
    "text": "effect dot provide. And here we have to import",
    "start": "2098250",
    "end": "2104632"
  },
  {
    "text": "our import everything as event journal",
    "start": "2104716",
    "end": "2112833"
  },
  {
    "text": "storage from our",
    "start": "2112833",
    "end": "2118800"
  },
  {
    "text": "implementation we did last time. Even journal storage here. And now we can",
    "start": "2118800",
    "end": "2128100"
  },
  {
    "text": "do event journal storage dot in memory. So now, that's fine. That's happy here.",
    "start": "2128100",
    "end": "2136383"
  },
  {
    "text": "Yeah, here is screaming because we created a variable that we actually never used. So we will",
    "start": "2137550",
    "end": "2143883"
  },
  {
    "text": "just call append products created event.",
    "start": "2143883",
    "end": "2148750"
  },
  {
    "text": "Okay. And then while you're screaming for this, the original function does not have a yield.",
    "start": "2150250",
    "end": "2156433"
  },
  {
    "text": "Why? It doesn't have a yield. The thing is that in the here in the arguments, I",
    "start": "2157416",
    "end": "2162916"
  },
  {
    "text": "am missing these headers field. And this headers field is one of the",
    "start": "2163183",
    "end": "2169899"
  },
  {
    "text": "fields that we have designed altogether in the first episode of the",
    "start": "2169899",
    "end": "2175633"
  },
  {
    "text": "stream, if you remember correctly, and this as things like",
    "start": "2175633",
    "end": "2178816"
  },
  {
    "text": "so maybe for test we can just",
    "start": "2183866",
    "end": "2189533"
  },
  {
    "text": "manually type that in and say things like we need to import",
    "start": "2189533",
    "end": "2196733"
  },
  {
    "text": "everything as message headers from SRC",
    "start": "2196833",
    "end": "2208783"
  },
  {
    "text": "message headers, and then we will create a const message headers",
    "start": "2208783",
    "end": "2219449"
  },
  {
    "text": "equals message headers dot make.",
    "start": "2219449",
    "end": "2227300"
  },
  {
    "text": "And here we'll see that the only actual required field is the actual message ID. Message ID. So here are our message",
    "start": "2233516",
    "end": "2243500"
  },
  {
    "text": "headers, then we can just rename maybe to headers. And then we can say in here, headers",
    "start": "2243500",
    "end": "2251516"
  },
  {
    "text": "aggregate ID. Okay. And now that we have done that, these",
    "start": "2251516",
    "end": "2258283"
  },
  {
    "text": "appends need to be yielded because that's an effect. Now, TypeScript isn't",
    "start": "2258283",
    "end": "2264750"
  },
  {
    "text": "screaming at us anymore. And but it's right, we imported expect,",
    "start": "2264750",
    "end": "2270416"
  },
  {
    "text": "but we are not expecting anything from this test right now. And what do we expect? Well, we have a",
    "start": "2270850",
    "end": "2278750"
  },
  {
    "text": "few things to expect. And we expect first that here we append something into the",
    "start": "2278750",
    "end": "2286216"
  },
  {
    "text": "journal. And then we expect that",
    "start": "2286216",
    "end": "2291233"
  },
  {
    "text": "if we const journal entries, if we do",
    "start": "2291583",
    "end": "2299433"
  },
  {
    "text": "something like event, if we call maybe from",
    "start": "2299433",
    "end": "2307899"
  },
  {
    "text": "const event journal, equals yield star",
    "start": "2307899",
    "end": "2314116"
  },
  {
    "text": "And that will actually get the instance of the journal,",
    "start": "2318850",
    "end": "2323083"
  },
  {
    "text": "And we will read the entire journal, event journal dot read for the product or maybe",
    "start": "2331016",
    "end": "2340116"
  },
  {
    "text": "a product.",
    "start": "2340133",
    "end": "2342699"
  },
  {
    "text": "Product aggregate dot aggregate name on",
    "start": "2345500",
    "end": "2352300"
  },
  {
    "text": "the product one. And the events we're going to have",
    "start": "2352300",
    "end": "2358783"
  },
  {
    "text": "are as we said, two that are product created. And product name",
    "start": "2358933",
    "end": "2367000"
  },
  {
    "text": "change. And we start from sequence zero. Okay, that is a list of a",
    "start": "2367000",
    "end": "2374899"
  },
  {
    "text": "stream of journal events, ideally, if I remember correctly.",
    "start": "2374899",
    "end": "2379216"
  },
  {
    "text": "Did I forget to pass in something? Let me check. Read.",
    "start": "2384083",
    "end": "2393000"
  },
  {
    "text": "Oh yeah, I'm yielding a stream. Yeah, I cannot yield a stream. Yeah, I can do things like",
    "start": "2403733",
    "end": "2411233"
  },
  {
    "text": "yield start stream. And we need to import",
    "start": "2411899",
    "end": "2417132"
  },
  {
    "text": "the stream from effect. Import everything as",
    "start": "2417133",
    "end": "2422433"
  },
  {
    "text": "stream from effect stream.",
    "start": "2422433",
    "end": "2426149"
  },
  {
    "text": "Stream dot run count. And that journal events count. And we can",
    "start": "2430616",
    "end": "2444149"
  },
  {
    "text": "expect journal events count to equal one.",
    "start": "2444149",
    "end": "2452500"
  },
  {
    "text": "Okay. So now if we try to run this test, it passes. Right. Perfect.",
    "start": "2454616",
    "end": "2460916"
  },
  {
    "text": "So that means that we have written that perfectly the first time. Let me run that in",
    "start": "2462050",
    "end": "2468316"
  },
  {
    "text": "debug mode. So we should actually get something. Yeah. Yeah.",
    "start": "2468316",
    "end": "2472600"
  },
  {
    "text": "That's perfectly working. Okay. So here we have a test that we changed the product one and we",
    "start": "2473699",
    "end": "2481500"
  },
  {
    "text": "append a new message of product created. And then we are",
    "start": "2481500",
    "end": "2487199"
  },
  {
    "text": "successfully exerting that now we have did that. And then we",
    "start": "2487283",
    "end": "2492699"
  },
  {
    "text": "can do other things like",
    "start": "2492699",
    "end": "2494383"
  },
  {
    "text": "Okay. And now that we can read the current state for product one, we can see that,",
    "start": "2514699",
    "end": "2519432"
  },
  {
    "text": "as again, as I said before, can be an option of an option. And now the thing is that since we",
    "start": "2520149",
    "end": "2527583"
  },
  {
    "text": "have appended our product created event, I'm expecting that this",
    "start": "2527583",
    "end": "2533250"
  },
  {
    "text": "option will be basically an option of some and that inner option",
    "start": "2533250",
    "end": "2541899"
  },
  {
    "text": "will be a some as well. Because the outer option says that",
    "start": "2541899",
    "end": "2546783"
  },
  {
    "text": "no events has ever been received for these products. And the inner one says it",
    "start": "2547250",
    "end": "2556583"
  },
  {
    "text": "has been created or not. So,",
    "start": "2556583",
    "end": "2564000"
  },
  {
    "text": "we could say things like, expect",
    "start": "2568216",
    "end": "2574833"
  },
  {
    "text": "option dot",
    "start": "2574883",
    "end": "2579449"
  },
  {
    "text": "Let us try to run in the bug mode",
    "start": "2593583",
    "end": "2603633"
  },
  {
    "text": "this test as well. Let's see what happens. Okay. Yeah, that should pass. Okay. And",
    "start": "2603633",
    "end": "2612199"
  },
  {
    "text": "the current state is an option of an option. Nice. And we have",
    "start": "2612199",
    "end": "2620333"
  },
  {
    "text": "our product, which is a pizza. And we have also our created at and our updated at. And",
    "start": "2620333",
    "end": "2627600"
  },
  {
    "text": "you'll see that the time is 00 zero. And that is",
    "start": "2627600",
    "end": "2632800"
  },
  {
    "text": "because the test service will basically adjust the time to be",
    "start": "2634616",
    "end": "2643983"
  },
  {
    "text": "generally 00 zero. Nice. Nice. Nice. Nice. And we can also try to",
    "start": "2643983",
    "end": "2654850"
  },
  {
    "text": "do other things about that. Like now we can add an additional change",
    "start": "2654850",
    "end": "2663399"
  },
  {
    "text": "over the product and say things like, here,",
    "start": "2663399",
    "end": "2669716"
  },
  {
    "text": "message ID two, and we want a product",
    "start": "2670616",
    "end": "2676550"
  },
  {
    "text": "name change event, and say something like a new name",
    "start": "2676550",
    "end": "2683549"
  },
  {
    "text": "will be, will be like fancy pizza.",
    "start": "2684850",
    "end": "2691316"
  },
  {
    "text": "And the old name will be something that",
    "start": "2691350",
    "end": "2698483"
  },
  {
    "text": "instead we will read from the current state.",
    "start": "2698483",
    "end": "2702800"
  },
  {
    "text": "So here we can say cost product state",
    "start": "2703583",
    "end": "2707633"
  },
  {
    "text": "Yeah, that's nice. Yeah. Because that read will return an effect of option option. And then we",
    "start": "2725100",
    "end": "2731316"
  },
  {
    "text": "have data and yeah, we have our option. Perfect. And we can say that",
    "start": "2731333",
    "end": "2742215"
  },
  {
    "text": "option dot get or else product or maybe",
    "start": "2745683",
    "end": "2752983"
  },
  {
    "text": "even better option, product dot pipe option, we need to take the product name.",
    "start": "2752983",
    "end": "2763833"
  },
  {
    "text": "Okay. And if we don't get that",
    "start": "2765399",
    "end": "2768882"
  },
  {
    "text": "we can do something like do not provide any name. Okay. And here,",
    "start": "2774166",
    "end": "2779632"
  },
  {
    "text": "okay. And here, basings. Okay. Perfect. Okay. So here we are seeing",
    "start": "2779816",
    "end": "2785800"
  },
  {
    "text": "that we want to read the current state of the product. And if we have",
    "start": "2785800",
    "end": "2793649"
  },
  {
    "text": "things like our message headers we get for our second message.",
    "start": "2793649",
    "end": "2798550"
  },
  {
    "text": "And this is not a product created by event, but a product name changed event.",
    "start": "2798899",
    "end": "2805149"
  },
  {
    "text": "Okay. And now if we expect, if we do the",
    "start": "2811683",
    "end": "2816883"
  },
  {
    "text": "same thing as before,",
    "start": "2816883",
    "end": "2819216"
  },
  {
    "text": "we expect our count to be two because we have pushed a new event into the",
    "start": "2822333",
    "end": "2829199"
  },
  {
    "text": "journal. So we expect that to be two right now. And then we",
    "start": "2829199",
    "end": "2834750"
  },
  {
    "text": "could also say that if we read again the state",
    "start": "2834750",
    "end": "2840599"
  },
  {
    "text": "I mean the option dot flatten here.",
    "start": "2840600",
    "end": "2847383"
  },
  {
    "text": "current state, current state two because we have updated that",
    "start": "2880783",
    "end": "2884199"
  },
  {
    "text": "Let us check again that all of our tests passes here. Okay.",
    "start": "2900033",
    "end": "2908300"
  },
  {
    "text": "This should pass again. Okay. Here we have fancy pizza. Right. Nice.",
    "start": "2910399",
    "end": "2919916"
  },
  {
    "text": "Yes. All the tests are passing. So here you can see that",
    "start": "2923133",
    "end": "2928033"
  },
  {
    "text": "this kind of produce will be the fact of way for our application to perform",
    "start": "2929283",
    "end": "2937600"
  },
  {
    "text": "changes over the state. And here when we will use produce, we",
    "start": "2937600",
    "end": "2946432"
  },
  {
    "text": "will do things like basically if we can check the state",
    "start": "2946433",
    "end": "2954883"
  },
  {
    "text": "or the current state of the aggregate. And then if we are trying to perform something that is not",
    "start": "2954883",
    "end": "2962233"
  },
  {
    "text": "permitted in this moment, for example, changing the name of product that does not exist.",
    "start": "2962233",
    "end": "2969000"
  },
  {
    "text": "We can, for example, go to the failure channel and what will happen",
    "start": "2969149",
    "end": "2974449"
  },
  {
    "text": "that failure will be bumped on the top level of this produce. So we",
    "start": "2974449",
    "end": "2980699"
  },
  {
    "text": "will get that failure and we won't write anything. Yeah.",
    "start": "2980699",
    "end": "2985616"
  },
  {
    "text": "Yeah. Yeah. Yeah. So that is really nice. And that really works. Okay.",
    "start": "2989016",
    "end": "2995733"
  },
  {
    "text": "Let's go back into having a look at various things. So we have seen that our",
    "start": "2999033",
    "end": "3010733"
  },
  {
    "text": "event sourced aggregate work exactly as we expect. We have also improved our",
    "start": "3010783",
    "end": "3018483"
  },
  {
    "text": "event journal storage so that we use select the inserting",
    "start": "3018883",
    "end": "3025483"
  },
  {
    "text": "to, inserting to select where not exsist instead of performing other",
    "start": "3025483",
    "end": "3032000"
  },
  {
    "text": "things. And then I think that for the",
    "start": "3032000",
    "end": "3039316"
  },
  {
    "text": "core of the infrastructure that is mostly what we would like to have I think.",
    "start": "3039983",
    "end": "3048449"
  },
  {
    "text": "That way we have a way to persist the event. And now we have also",
    "start": "3051266",
    "end": "3058216"
  },
  {
    "text": "a way for that to be handled perfectly. Okay. So what can be the next",
    "start": "3058216",
    "end": "3066233"
  },
  {
    "text": "thing that we can work on?",
    "start": "3066233",
    "end": "3069199"
  },
  {
    "text": "There is another thing that I would like to tackle. And the thing is quite simple.",
    "start": "3071433",
    "end": "3082916"
  },
  {
    "text": "Maybe it's worth exploring today because",
    "start": "3083899",
    "end": "3089750"
  },
  {
    "text": "it feels something that I would like to handle in my system. So the thing is that if you",
    "start": "3089750",
    "end": "3098583"
  },
  {
    "text": "remember correctly in our message headers we have all",
    "start": "3098583",
    "end": "3104649"
  },
  {
    "text": "of these fields like message ID, causation ID, correlation ID",
    "start": "3104649",
    "end": "3109899"
  },
  {
    "text": "and expires in. So those three are fields will be used later for various",
    "start": "3109899",
    "end": "3115850"
  },
  {
    "text": "functionalities. So let's start by speaking about them and then",
    "start": "3115850",
    "end": "3121449"
  },
  {
    "text": "maybe we can start trying to do something that handles them in a",
    "start": "3121449",
    "end": "3128349"
  },
  {
    "text": "more fancy way than manually handle them every time. So we have first",
    "start": "3128350",
    "end": "3136849"
  },
  {
    "text": "a message ID. So a message ID is",
    "start": "3136850",
    "end": "3144133"
  },
  {
    "text": "basically for now just a non-empty string. But to be honest I",
    "start": "3144133",
    "end": "3150449"
  },
  {
    "text": "want to use something like a UUID v5 or v7. V4 or v7.",
    "start": "3150449",
    "end": "3157000"
  },
  {
    "text": "So one that has a timestamp built in. And",
    "start": "3157649",
    "end": "3162733"
  },
  {
    "text": "then what will be used",
    "start": "3162733",
    "end": "3168833"
  },
  {
    "text": "that message ID for? Well it will be used basically to deduce message that are",
    "start": "3169899",
    "end": "3175750"
  },
  {
    "text": "incoming into our APIs. So that way if we try to perform for",
    "start": "3175750",
    "end": "3181850"
  },
  {
    "text": "example the deletion of the same product twice",
    "start": "3181850",
    "end": "3187649"
  },
  {
    "text": "because you know the connection may go down while you send a request to the server. So you retry",
    "start": "3189016",
    "end": "3196133"
  },
  {
    "text": "sending again that request. But the server now need to know if that request has already been",
    "start": "3196216",
    "end": "3202116"
  },
  {
    "text": "performed or not. And if the request doesn't have an idempotency key it won't be able to",
    "start": "3202216",
    "end": "3210216"
  },
  {
    "text": "know if that has already been handled or not. And so that is related to the thing",
    "start": "3210699",
    "end": "3222033"
  },
  {
    "text": "of having idempotency keys. And that means that how can we",
    "start": "3222033",
    "end": "3228050"
  },
  {
    "text": "handle the most simple way would be to have a table",
    "start": "3228050",
    "end": "3236800"
  },
  {
    "text": "or any storage that basically persists the result on any incoming request.",
    "start": "3237733",
    "end": "3247800"
  },
  {
    "text": "And if it sees that has already been performed in x amount of time then he",
    "start": "3248783",
    "end": "3260132"
  },
  {
    "text": "will return the previous execution results instead of executing",
    "start": "3260133",
    "end": "3266099"
  },
  {
    "text": "that again. So that is",
    "start": "3266100",
    "end": "3271149"
  },
  {
    "text": "basically just trying to read into that base if we already have processed that specific message. And if",
    "start": "3271149",
    "end": "3278233"
  },
  {
    "text": "we have we return what we have stored in the storage and if we haven't we perform the thing and then",
    "start": "3278233",
    "end": "3286283"
  },
  {
    "text": "upon getting a result we actually persist that result into the",
    "start": "3286283",
    "end": "3294133"
  },
  {
    "text": "storage. Okay so let's start maybe to",
    "start": "3294133",
    "end": "3300516"
  },
  {
    "text": "tackle that aspect I think. Yeah that is one thing that I would like to implement. So",
    "start": "3300699",
    "end": "3308199"
  },
  {
    "text": "how can we how can we call this trait? I",
    "start": "3311649",
    "end": "3319833"
  },
  {
    "text": "can think that we will have basically two things. We will have something like idempotency",
    "start": "3319833",
    "end": "3329733"
  },
  {
    "text": "storage maybe. okay and I",
    "start": "3329733",
    "end": "3337983"
  },
  {
    "text": "think that idempotency storage",
    "start": "3337983",
    "end": "3342399"
  },
  {
    "text": "will be API",
    "start": "3345649",
    "end": "3349000"
  },
  {
    "text": "will be an API that will have something like export interface idempotency storage",
    "start": "3353199",
    "end": "3363483"
  },
  {
    "text": "and then he'll have things like",
    "start": "3365649",
    "end": "3369733"
  },
  {
    "text": "handle",
    "start": "3373916",
    "end": "3374250"
  },
  {
    "text": "or maybe let me see",
    "start": "3379366",
    "end": "3383916"
  },
  {
    "text": "it can either go the way of check if already processed",
    "start": "3386616",
    "end": "3394916"
  },
  {
    "text": "and then pass in the idempotency key or we could go the way of and then having",
    "start": "3397100",
    "end": "3409916"
  },
  {
    "text": "a second function that persists the result and that I think that for now would be",
    "start": "3409916",
    "end": "3416750"
  },
  {
    "text": "the simplest solution yeah yeah yeah yeah yeah so let's go like check and check will",
    "start": "3416750",
    "end": "3426783"
  },
  {
    "text": "take like idempotency key of type string that's fine by",
    "start": "3426783",
    "end": "3434916"
  },
  {
    "text": "the storage and maybe we will have also like",
    "start": "3435016",
    "end": "3442016"
  },
  {
    "text": "consumer id and the customer id will be",
    "start": "3443366",
    "end": "3450099"
  },
  {
    "text": "the id of the consumer that is checking if already has performed and worked over",
    "start": "3450100",
    "end": "3458382"
  },
  {
    "text": "that message and finally we need to know to have",
    "start": "3458383",
    "end": "3464616"
  },
  {
    "text": "idempotency key the actual the actual",
    "start": "3465500",
    "end": "3471300"
  },
  {
    "text": "schema for the result that can or or will be persisted into the",
    "start": "3471300",
    "end": "3480899"
  },
  {
    "text": "storage so we need to import effect schema as always",
    "start": "3480899",
    "end": "3487132"
  },
  {
    "text": "effect schema sorry it's the effect schema schema",
    "start": "3489566",
    "end": "3495549"
  },
  {
    "text": "schema and then we will have like exit",
    "start": "3495600",
    "end": "3503716"
  },
  {
    "text": "schema something like",
    "start": "3503716",
    "end": "3507616"
  },
  {
    "text": "of a",
    "start": "3527899",
    "end": "3531182"
  },
  {
    "text": "any and no environment required yes",
    "start": "3536616",
    "end": "3542300"
  },
  {
    "text": "so we will have a consumer id which is maybe the product that is",
    "start": "3544800",
    "end": "3549833"
  },
  {
    "text": "trying to consume the message the idempotency key and then the schema",
    "start": "3549833",
    "end": "3557699"
  },
  {
    "text": "that will be used in order to decode the",
    "start": "3557699",
    "end": "3563300"
  },
  {
    "text": "result that has been persisted eventually into the storage and",
    "start": "3564449",
    "end": "3571616"
  },
  {
    "text": "then we also need to save for consumer id string idempotency key of",
    "start": "3571616",
    "end": "3582500"
  },
  {
    "text": "string we're going to need the exit schema",
    "start": "3582500",
    "end": "3586083"
  },
  {
    "text": "and we obviously need to define that",
    "start": "3595500",
    "end": "3602100"
  },
  {
    "text": "later okay and we obviously say that a and e can be",
    "start": "3602100",
    "end": "3608399"
  },
  {
    "text": "whatever we want a e can be whatever we want and that will be and",
    "start": "3608399",
    "end": "3615816"
  },
  {
    "text": "the check will be basically an effect and we can have maybe an",
    "start": "3615816",
    "end": "3624616"
  },
  {
    "text": "option and the option will return",
    "start": "3624616",
    "end": "3633000"
  },
  {
    "text": "some if we have the exit already persisted on a e or none if we don't have that and",
    "start": "3635250",
    "end": "3647983"
  },
  {
    "text": "for receiving side is that i think that we will go on with just",
    "start": "3647983",
    "end": "3654116"
  },
  {
    "text": "first okay obviously we need later on to handle some",
    "start": "3658050",
    "end": "3665183"
  },
  {
    "text": "kind of errors when the idempotency storage goes on failure but",
    "start": "3665183",
    "end": "3670250"
  },
  {
    "text": "yeah we will tackle that later i think yeah we will tackle that later",
    "start": "3670250",
    "end": "3677516"
  },
  {
    "text": "okay so a quick recap we have a check method that",
    "start": "3677516",
    "end": "3685416"
  },
  {
    "text": "checks if the given idempotency key has",
    "start": "3687350",
    "end": "3696166"
  },
  {
    "text": "already been processed for a specific",
    "start": "3696166",
    "end": "3703183"
  },
  {
    "text": "consumer and we have the consumer id the",
    "start": "3705416",
    "end": "3711783"
  },
  {
    "text": "idempotency key and the exit schema if it has it will return some with the",
    "start": "3711783",
    "end": "3723932"
  },
  {
    "text": "previous execution exit and",
    "start": "3723933",
    "end": "3730716"
  },
  {
    "text": "then we also have save method that will take the consumer idempotency",
    "start": "3730716",
    "end": "3735783"
  },
  {
    "text": "key the exit schema and the exit as well exit exit dot exit a e and this will do the",
    "start": "3735783",
    "end": "3748083"
  },
  {
    "text": "job of this will persist into the storage",
    "start": "3748083",
    "end": "3754550"
  },
  {
    "text": "the result of the execution of the",
    "start": "3755116",
    "end": "3763466"
  },
  {
    "text": "result the execute field of the command because we will",
    "start": "3763466",
    "end": "3770616"
  },
  {
    "text": "mostly use that for commands we will also use that for sagas and consuming",
    "start": "3770616",
    "end": "3777516"
  },
  {
    "text": "events i think but yeah mostly for that and now that we have",
    "start": "3777516",
    "end": "3784466"
  },
  {
    "text": "defined the interface i think that we can actually implement those okay so again as always",
    "start": "3784466",
    "end": "3794350"
  },
  {
    "text": "we can start with the in-memory version",
    "start": "3794350",
    "end": "3801449"
  },
  {
    "text": "uh which means something like",
    "start": "3803199",
    "end": "3805566"
  },
  {
    "text": "and then what we expect to do from the in memory version well the in memory version since we",
    "start": "3812899",
    "end": "3819666"
  },
  {
    "text": "need to have something that given a consumer id and an idempotency key will return an",
    "start": "3819666",
    "end": "3826983"
  },
  {
    "text": "eventually already existing exit i think that again we can use",
    "start": "3826983",
    "end": "3832783"
  },
  {
    "text": "nested hash maps in memory to ensure that we already processed that",
    "start": "3832783",
    "end": "3839583"
  },
  {
    "text": "value so first maybe we import the ref module and say things like",
    "start": "3839583",
    "end": "3851466"
  },
  {
    "text": "and we want to start from an empty state so hash map and have things like",
    "start": "3854416",
    "end": "3867449"
  },
  {
    "text": "hash map dot empty and that is the",
    "start": "3870716",
    "end": "3876066"
  },
  {
    "text": "default state because by default we won't have anything in memory and one thing that we can do",
    "start": "3876066",
    "end": "3884449"
  },
  {
    "text": "instead of explicitly using strings is that hash map actually",
    "start": "3884449",
    "end": "3891250"
  },
  {
    "text": "allows to index by hashable things and in",
    "start": "3891583",
    "end": "3898683"
  },
  {
    "text": "fact we can use for example the data module to define hashable things so we can say",
    "start": "3898683",
    "end": "3909366"
  },
  {
    "text": "something like class in memory idempotency index extends",
    "start": "3909366",
    "end": "3920550"
  },
  {
    "text": "the data dot class and we need to provide",
    "start": "3921266",
    "end": "3927166"
  },
  {
    "text": "the shape for that and we will have like consumer id which is a string and",
    "start": "3927166",
    "end": "3934683"
  },
  {
    "text": "idempotency key of type string",
    "start": "3934683",
    "end": "3940216"
  },
  {
    "text": "okay and now this can be an hash map",
    "start": "3940466",
    "end": "3949850"
  },
  {
    "text": "that's empty and the hash map will have as key",
    "start": "3949850",
    "end": "3954966"
  },
  {
    "text": "on memory idempotency index and as values you will use exit dot exit or any any",
    "start": "3955750",
    "end": "3964716"
  },
  {
    "text": "and that will be the storage memory",
    "start": "3965666",
    "end": "3970966"
  },
  {
    "text": "we will use so just a ref and yeah why did you want to",
    "start": "3970966",
    "end": "3978716"
  },
  {
    "text": "import that as type i don't know but yeah now we have created that now we need to implement",
    "start": "3978716",
    "end": "3984016"
  },
  {
    "text": "the check and the save method so let's start by the check method",
    "start": "3984383",
    "end": "3989866"
  },
  {
    "text": "so const check that will be really easy we can just say something",
    "start": "3989866",
    "end": "3995833"
  },
  {
    "text": "like ref dot get state",
    "start": "3995833",
    "end": "4002449"
  },
  {
    "text": "and that will be an effect and then effect dot map hash map dot get",
    "start": "4002449",
    "end": "4011666"
  },
  {
    "text": "and this check method will be of type idempotency storage",
    "start": "4011666",
    "end": "4021133"
  },
  {
    "text": "so we'll have as parameters consumer id",
    "start": "4024816",
    "end": "4030015"
  },
  {
    "text": "idempotency key and this schema we don't",
    "start": "4030016",
    "end": "4037566"
  },
  {
    "text": "care because this is an in-memory version so we don't care about the schema but again again new in memory idempotency",
    "start": "4037566",
    "end": "4044933"
  },
  {
    "text": "index and then we can say consumer id and idempotency key and",
    "start": "4045050",
    "end": "4050166"
  },
  {
    "text": "that will get us back with",
    "start": "4050166",
    "end": "4054850"
  },
  {
    "text": "our effect of option exit a that's perfect that's exactly what we wanted and",
    "start": "4055516",
    "end": "4062550"
  },
  {
    "text": "so let's try to do the const save method which will be",
    "start": "4062550",
    "end": "4069750"
  },
  {
    "text": "idempotency storage save equals consumer",
    "start": "4069750",
    "end": "4075649"
  },
  {
    "text": "id and then idempotency key",
    "start": "4075649",
    "end": "4081666"
  },
  {
    "text": "and then we the schema we don't care again because this is an in-memory",
    "start": "4083183",
    "end": "4088983"
  },
  {
    "text": "version so we don't need the schema to persist that but then we need the exit value okay and",
    "start": "4088983",
    "end": "4095883"
  },
  {
    "text": "so we need to do ref dot update state and the state and then we need",
    "start": "4095883",
    "end": "4107983"
  },
  {
    "text": "to provide a function that given the old hash map produces a new one and guess what it's hash",
    "start": "4107983",
    "end": "4113766"
  },
  {
    "text": "map dot set on the key new in memory idempotency key consumer id idempotency",
    "start": "4113766",
    "end": "4125032"
  },
  {
    "text": "key and the value will be just our exit",
    "start": "4125033",
    "end": "4129816"
  },
  {
    "text": "and this should conform to the signature we want effect void",
    "start": "4131516",
    "end": "4137782"
  },
  {
    "text": "nice and then we return check and save okay and finally we",
    "start": "4137783",
    "end": "4149265"
  },
  {
    "text": "need to convert those into a layer and guess how we can do that",
    "start": "4149266",
    "end": "4155083"
  },
  {
    "text": "pipe layer dot effect and we need to provide in a tag for our idempotency",
    "start": "4155516",
    "end": "4164115"
  },
  {
    "text": "storage and let's go back because if I remember correctly last time",
    "start": "4164116",
    "end": "4169632"
  },
  {
    "text": "we used yeah the class syntax that allows you to define",
    "start": "4169633",
    "end": "4175215"
  },
  {
    "text": "in the same line tag and also the shape so let's do that again and",
    "start": "4175433",
    "end": "4182049"
  },
  {
    "text": "so instead of export interface we'll do export class and we need to",
    "start": "4182050",
    "end": "4188566"
  },
  {
    "text": "import the context from effect I will say extends",
    "start": "4188566",
    "end": "4194233"
  },
  {
    "text": "context dot tag and we need to provide that tag idempotency",
    "start": "4194733",
    "end": "4202516"
  },
  {
    "text": "storage again do not use tag like that in production in your",
    "start": "4202516",
    "end": "4209149"
  },
  {
    "text": "application you really scope them by prefixing them with something like sorry",
    "start": "4209149",
    "end": "4214432"
  },
  {
    "text": "something like the name of your application so something like add my app storage whatever but since we",
    "start": "4214433",
    "end": "4226483"
  },
  {
    "text": "are just starting our application we can care about that later and go with that for now so we need to provide",
    "start": "4226483",
    "end": "4233416"
  },
  {
    "text": "then the idempotency storage and the shape and I think that we need",
    "start": "4233416",
    "end": "4243633"
  },
  {
    "text": "to close the tag for that call that function and that yep okay and back to our layer dot effect",
    "start": "4243633",
    "end": "4254448"
  },
  {
    "text": "idempotency storage and that's it here we need to change a little because now it's on type",
    "start": "4254449",
    "end": "4261350"
  },
  {
    "text": "instead of directly accessing them",
    "start": "4261350",
    "end": "4265616"
  },
  {
    "text": "and this works okay",
    "start": "4269100",
    "end": "4272216"
  },
  {
    "text": "okay so now we have our in memory idempotency storage so",
    "start": "4276783",
    "end": "4283183"
  },
  {
    "text": "now we need to actual create the actual idempotency utils that",
    "start": "4283183",
    "end": "4290349"
  },
  {
    "text": "will use the idempotency storage in order to perform the business logic of idempotency so",
    "start": "4290350",
    "end": "4296666"
  },
  {
    "text": "again idempotency will first check if already exists something for that specific key and then we'll save if",
    "start": "4296666",
    "end": "4304616"
  },
  {
    "text": "doesn't so we will call that idempotency.ts",
    "start": "4304616",
    "end": "4313615"
  },
  {
    "text": "and we need to import everything as idempotency",
    "start": "4313750",
    "end": "4323015"
  },
  {
    "text": "storage from idempotency storage",
    "start": "4323500",
    "end": "4329066"
  },
  {
    "text": "how do we want our idempotency to work?",
    "start": "4334833",
    "end": "4342966"
  },
  {
    "text": "well I think that the simple API we could have is something like a function that ensure idempotency",
    "start": "4343783",
    "end": "4359850"
  },
  {
    "text": "again if you have better names you are more than welcome and that will take anything",
    "start": "4361216",
    "end": "4366666"
  },
  {
    "text": "and will provide our consumer id",
    "start": "4367550",
    "end": "4374416"
  },
  {
    "text": "string and also idempotency key string",
    "start": "4374416",
    "end": "4380866"
  },
  {
    "text": "and then we'll have also a function or",
    "start": "4382266",
    "end": "4391383"
  },
  {
    "text": "maybe it's better to have an effect",
    "start": "4391383",
    "end": "4394416"
  },
  {
    "text": "we can provide an effect that will run only if idempotency",
    "start": "4398050",
    "end": "4403149"
  },
  {
    "text": "hasn't been run already so we need the consumer id the",
    "start": "4403149",
    "end": "4411000"
  },
  {
    "text": "idempotency key or and also the exit schemas",
    "start": "4411000",
    "end": "4414966"
  },
  {
    "text": "again we need to import schema everything as schema",
    "start": "4417699",
    "end": "4423316"
  },
  {
    "text": "from effect schema schema will be",
    "start": "4423316",
    "end": "4429983"
  },
  {
    "text": "again something like schema",
    "start": "4429983",
    "end": "4433115"
  },
  {
    "text": "I'm not sure if we want to provide the entire exit schema or just",
    "start": "4449683",
    "end": "4458050"
  },
  {
    "text": "failure and success schema let's start for now maybe we have the",
    "start": "4458050",
    "end": "4463399"
  },
  {
    "text": "entire exit schema and then we can move from that let's see how it works in our",
    "start": "4463399",
    "end": "4470083"
  },
  {
    "text": "own and then we'll eventually move that",
    "start": "4470083",
    "end": "4475500"
  },
  {
    "text": "to something more sensible for our use case exit a e are any and no environment",
    "start": "4476183",
    "end": "4484483"
  },
  {
    "text": "because I don't want to handle that at the moment and then we'll return",
    "start": "4484666",
    "end": "4490166"
  },
  {
    "text": "return something that takes in our text eventually and then effect the effect dot",
    "start": "4494316",
    "end": "4502199"
  },
  {
    "text": "effect import everything as",
    "start": "4502750",
    "end": "4508866"
  },
  {
    "text": "effect from effect effect of a e r and we'll",
    "start": "4508866",
    "end": "4518300"
  },
  {
    "text": "resolve effect dot effect a e r",
    "start": "4518300",
    "end": "4525399"
  },
  {
    "text": "okay so this is kind of the type signature that I am working towards and the final",
    "start": "4532833",
    "end": "4540100"
  },
  {
    "text": "value will actually require r but also",
    "start": "4541316",
    "end": "4546583"
  },
  {
    "text": "idempotency storage.idempotency storage because in order to make this behavior",
    "start": "4546583",
    "end": "4552350"
  },
  {
    "text": "work we need to use the actual idempotency storage",
    "start": "4552350",
    "end": "4557216"
  },
  {
    "text": "so these will be real real real simple like two lines of code",
    "start": "4558266",
    "end": "4564666"
  },
  {
    "text": "and be something like the effect.gen function star and say",
    "start": "4564666",
    "end": "4573849"
  },
  {
    "text": "const previous exit",
    "start": "4573850",
    "end": "4580116"
  },
  {
    "text": "equals and then we need to",
    "start": "4580116",
    "end": "4584716"
  },
  {
    "text": "we need to first access the idempotency storage",
    "start": "4589533",
    "end": "4593700"
  },
  {
    "text": "and I think that if we use service",
    "start": "4594750",
    "end": "4602765"
  },
  {
    "text": "ideally this should allows us to directly have APIs that calls that method",
    "start": "4605950",
    "end": "4614583"
  },
  {
    "text": "but yeah storage.check and we'll check for the consumer id and",
    "start": "4614583",
    "end": "4625782"
  },
  {
    "text": "consumer id and then we have also",
    "start": "4625783",
    "end": "4630566"
  },
  {
    "text": "the idempotency key we need to provide in and our exit schema",
    "start": "4631700",
    "end": "4637066"
  },
  {
    "text": "and this will return our effect of option perfect bit and then we",
    "start": "4637066",
    "end": "4642950"
  },
  {
    "text": "need to yield that in order to get the option nice and",
    "start": "4642950",
    "end": "4648850"
  },
  {
    "text": "then we will say if previous exit.tag is",
    "start": "4648983",
    "end": "4656500"
  },
  {
    "text": "some for even better we can import",
    "start": "4656500",
    "end": "4661883"
  },
  {
    "text": "everything as option from from effect option and say if option is",
    "start": "4661883",
    "end": "4673700"
  },
  {
    "text": "some that previous exit will return",
    "start": "4673700",
    "end": "4679416"
  },
  {
    "text": "the previous exit.value and that is one",
    "start": "4680666",
    "end": "4686850"
  },
  {
    "text": "exit but I think we can yield star an exit",
    "start": "4686850",
    "end": "4691766"
  },
  {
    "text": "if I remember correctly yeah",
    "start": "4691883",
    "end": "4696949"
  },
  {
    "text": "effect a or undefined why are you putting undefined oh undefined because yeah we need indeed",
    "start": "4700200",
    "end": "4707916"
  },
  {
    "text": "to return and in case that didn't work we need to actually run the",
    "start": "4707916",
    "end": "4713149"
  },
  {
    "text": "effect okay so this should be like yield star we need to actually run",
    "start": "4713149",
    "end": "4719899"
  },
  {
    "text": "the effect okay so let me",
    "start": "4719899",
    "end": "4725199"
  },
  {
    "text": "check we're still missing one thing in the behavior we want so in the function ensure",
    "start": "4725200",
    "end": "4730883"
  },
  {
    "text": "idempotency for the people that has the chance to join in what we'll do is that given a consumer id and idempotency key",
    "start": "4730883",
    "end": "4738116"
  },
  {
    "text": "and the schema of the exit and what we will do is basically conditionally run",
    "start": "4738450",
    "end": "4744583"
  },
  {
    "text": "an effect by checking if idempotency storage has already",
    "start": "4745216",
    "end": "4750316"
  },
  {
    "text": "resolved for the effect or not so",
    "start": "4750316",
    "end": "4756449"
  },
  {
    "text": "let me just add",
    "start": "4759700",
    "end": "4762649"
  },
  {
    "text": "yield effect",
    "start": "4764866",
    "end": "4765716"
  },
  {
    "text": "yeah we need basically to add the persistence of that so pipe effect dot",
    "start": "4770016",
    "end": "4777850"
  },
  {
    "text": "on exit I think yeah on exit and I should",
    "start": "4779216",
    "end": "4784500"
  },
  {
    "text": "perfect and on exit this will be the exit and we need to journal",
    "start": "4786816",
    "end": "4792649"
  },
  {
    "text": "storage sorry dot save",
    "start": "4792649",
    "end": "4796500"
  },
  {
    "text": "for our consumer id we need and our idempotency key we need and our exit",
    "start": "4797700",
    "end": "4805383"
  },
  {
    "text": "schema we need to save our exit okay and we are golden I think the",
    "start": "4805383",
    "end": "4816699"
  },
  {
    "text": "exit will type a or e exit schema idempotency key consumer key whatever okay so that will",
    "start": "4816700",
    "end": "4824166"
  },
  {
    "text": "work and we'll ensure idempotency for our computations but right now we",
    "start": "4824166",
    "end": "4836316"
  },
  {
    "text": "have only one in memory storage and I think that any memory",
    "start": "4836316",
    "end": "4841899"
  },
  {
    "text": "storage won't be enough at least we need to provide a persistent",
    "start": "4841899",
    "end": "4847966"
  },
  {
    "text": "one because upon restarting our application we will need to make sure",
    "start": "4847966",
    "end": "4855783"
  },
  {
    "text": "that our idempotency is still valid",
    "start": "4855783",
    "end": "4861750"
  },
  {
    "text": "so again we can maybe start with sqlite based one",
    "start": "4865299",
    "end": "4870316"
  },
  {
    "text": "and that could be based a table as well and the table will have keys with",
    "start": "4872216",
    "end": "4880266"
  },
  {
    "text": "number the consumer id the idempotency",
    "start": "4881233",
    "end": "4887483"
  },
  {
    "text": "key and then eventually return the value and so let's maybe",
    "start": "4887483",
    "end": "4895816"
  },
  {
    "text": " we can try to just copy the one we did for our",
    "start": "4902100",
    "end": "4912216"
  },
  {
    "text": "event journal storage one for sqlite we had we are basically",
    "start": "4912216",
    "end": "4918966"
  },
  {
    "text": "looking to build something really similar to this this only depends and reads and that one",
    "start": "4918966",
    "end": "4926316"
  },
  {
    "text": "will read just the first record so maybe",
    "start": "4926316",
    "end": "4930649"
  },
  {
    "text": "let's start by copying this one and see what we are able to",
    "start": "4931383",
    "end": "4937016"
  },
  {
    "text": "accomplish okay so a few things okay",
    "start": "4937016",
    "end": "4943600"
  },
  {
    "text": "and it maybe this one will have something",
    "start": "4943600",
    "end": "4951450"
  },
  {
    "text": "like export namespace",
    "start": "4951450",
    "end": "4956466"
  },
  {
    "text": "idempotency storage and then export interface",
    "start": "4956816",
    "end": "4962466"
  },
  {
    "text": "args will have just the idempotency table name",
    "start": "4963616",
    "end": "4969883"
  },
  {
    "text": "idempotency table name perfect we don't need to do that our idempotency",
    "start": "4973133",
    "end": "4981699"
  },
  {
    "text": "table will be something like idempotency storage sqlite",
    "start": "4981700",
    "end": "4988416"
  },
  {
    "text": "row will be something like how did i call that consumer id and then",
    "start": "4988416",
    "end": "4996683"
  },
  {
    "text": "we'll be idempotency key and then we will have the",
    "start": "4996683",
    "end": "5004849"
  },
  {
    "text": "exit payload exit payload okay we need to import",
    "start": "5005466",
    "end": "5015683"
  },
  {
    "text": "everything as sql client from effect sql",
    "start": "5015950",
    "end": "5021783"
  },
  {
    "text": "client okay and this will be",
    "start": "5021783",
    "end": "5027683"
  },
  {
    "text": "our args will be idempotency storage.args you can see why i really",
    "start": "5027683",
    "end": "5034399"
  },
  {
    "text": "like using nine the namespace and then create table if not",
    "start": "5034399",
    "end": "5040666"
  },
  {
    "text": "exist create the idempotency table with not exist createable not exist",
    "start": "5041033",
    "end": "5046666"
  },
  {
    "text": "idempotency table name we said that we have consumer id",
    "start": "5046666",
    "end": "5053716"
  },
  {
    "text": "idempotency key and then",
    "start": "5053716",
    "end": "5058750"
  },
  {
    "text": "we have the exit payload exit payload and our primary key will be",
    "start": "5058750",
    "end": "5067682"
  },
  {
    "text": "the consumer id and the idempotency key",
    "start": "5067683",
    "end": "5071100"
  },
  {
    "text": "perfect okay and then we have our",
    "start": "5072783",
    "end": "5080666"
  },
  {
    "text": "methods and we will start with the save one and will be idempotency",
    "start": "5080666",
    "end": "5085916"
  },
  {
    "text": "idempotency storage type save okay and we",
    "start": "5086583",
    "end": "5092399"
  },
  {
    "text": "will have our consumer id and then our in here",
    "start": "5092399",
    "end": "5104649"
  },
  {
    "text": "rename symbol our idempotency key and our exit schema",
    "start": "5109616",
    "end": "5119116"
  },
  {
    "text": "and our actual exit okay so first of all we need to know to",
    "start": "5123950",
    "end": "5134266"
  },
  {
    "text": "create the exit payload which we'll do again what we'll",
    "start": "5134266",
    "end": "5141850"
  },
  {
    "text": "do is take our exit and encode that into",
    "start": "5141866",
    "end": "5149483"
  },
  {
    "text": "a string so this will be like a string perfectly because",
    "start": "5149483",
    "end": "5156350"
  },
  {
    "text": "we used this is our schema which is a schema of an exit and then we used the",
    "start": "5156350",
    "end": "5162883"
  },
  {
    "text": "parse json combinator that combines a schema in a way that it",
    "start": "5162883",
    "end": "5169500"
  },
  {
    "text": "changes the encoded side to be a string and basically json decodes the string and transforms",
    "start": "5169500",
    "end": "5176899"
  },
  {
    "text": "that into the encoded shape of an exit and then we encode the value so with that get that and then",
    "start": "5176899",
    "end": "5184966"
  },
  {
    "text": "we perform the actual insert and i think that here",
    "start": "5184966",
    "end": "5193799"
  },
  {
    "text": "i don't know if i want a domain error from that maybe we can",
    "start": "5195066",
    "end": "5201015"
  },
  {
    "text": "start with that and maybe change later so we're searching to journal table name and we'll have our",
    "start": "5201016",
    "end": "5208416"
  },
  {
    "text": "consumer id idempotency key",
    "start": "5208416",
    "end": "5216016"
  },
  {
    "text": "and exit payload so select consumer id",
    "start": "5216566",
    "end": "5223416"
  },
  {
    "text": "and exit payload where not exist sent up one from not journal table but it's called",
    "start": "5223416",
    "end": "5232283"
  },
  {
    "text": "idempotency table idempotency table name",
    "start": "5232283",
    "end": "5237100"
  },
  {
    "text": "where consumer id and idempotency key and",
    "start": "5237866",
    "end": "5247299"
  },
  {
    "text": "we do not need to perform a check over the sequence okay and we expect to get a changes or",
    "start": "5247299",
    "end": "5254816"
  },
  {
    "text": "number number of records changed that will be a number okay and then we do effect or die and if",
    "start": "5254816",
    "end": "5262566"
  },
  {
    "text": "we fail we have idempotency",
    "start": "5262566",
    "end": "5268799"
  },
  {
    "text": "for now maybe we can just say or die and",
    "start": "5268799",
    "end": "5275483"
  },
  {
    "text": "that's it for now yeah and let me better change that later yeah let's start with or die yeah",
    "start": "5275483",
    "end": "5281583"
  },
  {
    "text": "we are missing uh we need to remove the type from import",
    "start": "5281583",
    "end": "5288316"
  },
  {
    "text": "schema okay and we need to change also",
    "start": "5288316",
    "end": "5294299"
  },
  {
    "text": "that okay so our save method should be okay i think",
    "start": "5294299",
    "end": "5303766"
  },
  {
    "text": "SQL error like need to import SQL error import everything as",
    "start": "5303783",
    "end": "5309549"
  },
  {
    "text": "SQL error from effect SQL",
    "start": "5309549",
    "end": "5314483"
  },
  {
    "text": "and that's the save method save instead of",
    "start": "5317450",
    "end": "5323115"
  },
  {
    "text": "append and then we also need to create a check method idempotency",
    "start": "5323116",
    "end": "5330350"
  },
  {
    "text": "storage check again we have not",
    "start": "5330350",
    "end": "5335049"
  },
  {
    "text": "aggregate root but we have our consumer id we have idempotency key i think yeah",
    "start": "5336100",
    "end": "5345850"
  },
  {
    "text": "idempotency key and we have i need",
    "start": "5346750",
    "end": "5354350"
  },
  {
    "text": "to remember initial shortcut for renaming symbols uh f2 yeah to change that key binding",
    "start": "5354350",
    "end": "5360983"
  },
  {
    "text": "access schema because yeah okay set everything from",
    "start": "5360983",
    "end": "5367516"
  },
  {
    "text": "idempotency table name where",
    "start": "5367600",
    "end": "5373316"
  },
  {
    "text": "consumer id id equals that",
    "start": "5373316",
    "end": "5377899"
  },
  {
    "text": "and idempotency key is the one we want",
    "start": "5380100",
    "end": "5385216"
  },
  {
    "text": "and i don't care about the order by because we expect only one record to exist in that table",
    "start": "5385216",
    "end": "5391699"
  },
  {
    "text": "and i don't remember if there is utils for",
    "start": "5391700",
    "end": "5396799"
  },
  {
    "text": "the row is fine and then yeah we had stream dot from",
    "start": "5409750",
    "end": "5418066"
  },
  {
    "text": "iterable yeah that's not what we want what we want to do",
    "start": "5418066",
    "end": "5424116"
  },
  {
    "text": "here is something else if row data dot",
    "start": "5424183",
    "end": "5430299"
  },
  {
    "text": "length is less than one return",
    "start": "5430299",
    "end": "5437782"
  },
  {
    "text": "option that none we don't want nothing",
    "start": "5437883",
    "end": "5443166"
  },
  {
    "text": "and otherwise we want to decode our row",
    "start": "5443166",
    "end": "5450316"
  },
  {
    "text": "we need to provide the actual value we want to decode which will be raw data dot raw zero dot exit payload",
    "start": "5462516",
    "end": "5472383"
  },
  {
    "text": "okay and that will be our exit of type a yeah perfect and",
    "start": "5472383",
    "end": "5479683"
  },
  {
    "text": "then the only thing that we need to do is i think we want to even yield",
    "start": "5480350",
    "end": "5492416"
  },
  {
    "text": "exit and that should return as the thing",
    "start": "5494100",
    "end": "5499816"
  },
  {
    "text": "well uh we want actually to return an option of the",
    "start": "5499816",
    "end": "5506000"
  },
  {
    "text": "exit option some of the exit yeah okay",
    "start": "5506100",
    "end": "5513766"
  },
  {
    "text": "why are you complaining",
    "start": "5513766",
    "end": "5516166"
  },
  {
    "text": "because we said that the way we have defined those interfaces",
    "start": "5520000",
    "end": "5525333"
  },
  {
    "text": "and we don't want domain errors so i think that for now we can just say",
    "start": "5525383",
    "end": "5530483"
  },
  {
    "text": "nice and then that will be our check",
    "start": "5533399",
    "end": "5539466"
  },
  {
    "text": "method and that will provide the item potency storage",
    "start": "5539466",
    "end": "5544849"
  },
  {
    "text": "layer nice okay",
    "start": "5546149",
    "end": "5550216"
  },
  {
    "text": "so i think that we are ready to uh write some tests that will",
    "start": "5552816",
    "end": "5558616"
  },
  {
    "text": "check that this is working exactly how we expect",
    "start": "5558616",
    "end": "5562600"
  },
  {
    "text": "and then i think that after that we can close our stream and let's see let's see let's see",
    "start": "5569066",
    "end": "5576850"
  },
  {
    "text": "so let's write some tests",
    "start": "5577616",
    "end": "5582016"
  },
  {
    "text": "okay those are very similar to this one i think yeah so",
    "start": "5591350",
    "end": "5599533"
  },
  {
    "text": "this one yeah we can just we can just copy that one",
    "start": "5599533",
    "end": "5603816"
  },
  {
    "text": "again those services are very similar but they do quite different things we could do that",
    "start": "5605783",
    "end": "5612833"
  },
  {
    "text": "both for the in memory one and",
    "start": "5613116",
    "end": "5616600"
  },
  {
    "text": "yeah okay that and then we need to close that and close that okay so",
    "start": "5619116",
    "end": "5625615"
  },
  {
    "text": "those are the tests for the idempotency storage okay",
    "start": "5625616",
    "end": "5634199"
  },
  {
    "text": "she persists then read result",
    "start": "5634200",
    "end": "5638766"
  },
  {
    "text": "okay and here instead of importing event",
    "start": "5641200",
    "end": "5646500"
  },
  {
    "text": "journal storage we need idempotency storage rename symbol idempotency storage",
    "start": "5646500",
    "end": "5656533"
  },
  {
    "text": "idempotency storage and that is storage",
    "start": "5658000",
    "end": "5664350"
  },
  {
    "text": "and then we need to call storage",
    "start": "5664350",
    "end": "5667966"
  },
  {
    "text": "storage dot save and consumer is",
    "start": "5669833",
    "end": "5675316"
  },
  {
    "text": "will be let's say products again or message one and it will be more",
    "start": "5675316",
    "end": "5684149"
  },
  {
    "text": "like something like products products one in a real world scenario and the schema",
    "start": "5684149",
    "end": "5691333"
  },
  {
    "text": "will be like schema dot exit of let's say we have success of",
    "start": "5691333",
    "end": "5701299"
  },
  {
    "text": "type schema dot number and a failure of",
    "start": "5701299",
    "end": "5708633"
  },
  {
    "text": "type schema dot string okay and we finally need to provide the",
    "start": "5708633",
    "end": "5715849"
  },
  {
    "text": "actual exit exit dot succeed 42",
    "start": "5715850",
    "end": "5721299"
  },
  {
    "text": "okay and here why are you complaining for",
    "start": "5722716",
    "end": "5732166"
  },
  {
    "text": "you're complaining because you think that yeah events we don't want to do that",
    "start": "5734083",
    "end": "5740966"
  },
  {
    "text": "and we just want to say something like previews result equals",
    "start": "5741433",
    "end": "5750533"
  },
  {
    "text": "and then we will do just like storage dot check for products",
    "start": "5750533",
    "end": "5760066"
  },
  {
    "text": "product one and message one",
    "start": "5760066",
    "end": "5765100"
  },
  {
    "text": "again we should maybe put that into something like more const exit schema",
    "start": "5767500",
    "end": "5775216"
  },
  {
    "text": "so we can reuse that defect is",
    "start": "5775366",
    "end": "5781233"
  },
  {
    "text": "missing yeah you're right defect schema dot three unknowns",
    "start": "5781233",
    "end": "5788966"
  },
  {
    "text": "we don't expect defect but because they happen you know exit schema",
    "start": "5791116",
    "end": "5796416"
  },
  {
    "text": "here we need to then read by exit schema and then we expect",
    "start": "5796416",
    "end": "5806716"
  },
  {
    "text": "okay and that should work for the in memory",
    "start": "5816399",
    "end": "5824032"
  },
  {
    "text": "one but if we copy that one",
    "start": "5824033",
    "end": "5828316"
  },
  {
    "text": "and do the same thing for",
    "start": "5831116",
    "end": "5833633"
  },
  {
    "text": "this one and differentiate different consumers",
    "start": "5836716",
    "end": "5844616"
  },
  {
    "text": "okay so let's say that we're persisting to products one but then we read products two",
    "start": "5847433",
    "end": "5852365"
  },
  {
    "text": "i expect two equals false to this none",
    "start": "5853350",
    "end": "5859916"
  },
  {
    "text": "okay finally we have the one that",
    "start": "5859916",
    "end": "5865200"
  },
  {
    "text": "actually uses SQLite so this will be like idempotency",
    "start": "5865200",
    "end": "5870316"
  },
  {
    "text": "storage dot SQLite here",
    "start": "5873350",
    "end": "5878299"
  },
  {
    "text": "idempotency table name",
    "start": "5880850",
    "end": "5885933"
  },
  {
    "text": "idempotency and we need to provide SQLite note yeah",
    "start": "5887433",
    "end": "5895949"
  },
  {
    "text": "we have perfectly okay and finally i think that",
    "start": "5895950",
    "end": "5902733"
  },
  {
    "text": "we are almost golden what are you missing oh yeah it's calling things that doesn't",
    "start": "5902733",
    "end": "5912416"
  },
  {
    "text": "exist yeah here we need to call that",
    "start": "5912416",
    "end": "5916850"
  },
  {
    "text": "and then we expect in this case we expect",
    "start": "5921649",
    "end": "5927250"
  },
  {
    "text": "previous result to be",
    "start": "5927250",
    "end": "5930566"
  },
  {
    "text": "let us work all together into what we expect those three those tests to do let's clean up some",
    "start": "5944399",
    "end": "5954100"
  },
  {
    "text": "code and then we can go through them to see if we have written everything correctly so should",
    "start": "5954100",
    "end": "5961733"
  },
  {
    "text": "persist then read results so we expect that",
    "start": "5961733",
    "end": "5966049"
  },
  {
    "text": "and given the idempotency storage we have an idempotency key",
    "start": "5966799",
    "end": "5972633"
  },
  {
    "text": "access schema and we expect to have the ability of saving for a consumer",
    "start": "5972633",
    "end": "5978966"
  },
  {
    "text": "products products one message one say the exit schema say the exit has",
    "start": "5978966",
    "end": "5984366"
  },
  {
    "text": "succeeded with the value 42 and then if i try to read the value then",
    "start": "5984399",
    "end": "5989833"
  },
  {
    "text": "we have just persisted now which i expect that to be true and that also i should have that",
    "start": "5989833",
    "end": "5995899"
  },
  {
    "text": "if we have a previous result and that is some i also expect that",
    "start": "5995899",
    "end": "6005733"
  },
  {
    "text": "exit is success uh previous results dot value",
    "start": "6005733",
    "end": "6012532"
  },
  {
    "text": "to be true",
    "start": "6015750",
    "end": "6016549"
  },
  {
    "text": "and the same goes if we try to save with",
    "start": "6022333",
    "end": "6027716"
  },
  {
    "text": "a different for example consumer id so we save with the products one but then we",
    "start": "6027716",
    "end": "6034149"
  },
  {
    "text": "read from products two i expect that to be known because we are reading a different",
    "start": "6034149",
    "end": "6040399"
  },
  {
    "text": "consumer so the idempotency key is consumer based you know the message has an id but the consumer",
    "start": "6040399",
    "end": "6049399"
  },
  {
    "text": "Mattia may already have seen that message another consumer may have not seen that message so we need",
    "start": "6049399",
    "end": "6056149"
  },
  {
    "text": "to keep that storage based by the consumer then the message id and then persist the result and",
    "start": "6056149",
    "end": "6063466"
  },
  {
    "text": "finally we do basically the same thing but with an SQLite file",
    "start": "6063466",
    "end": "6070700"
  },
  {
    "text": "uh so we start by clearing up the table name the table so we don't",
    "start": "6071516",
    "end": "6077433"
  },
  {
    "text": "have records from previous execution and then we perform a",
    "start": "6077433",
    "end": "6082799"
  },
  {
    "text": "persistence we read and we expect to read so let's try to run them first one succeeded second one succeeded",
    "start": "6082799",
    "end": "6091566"
  },
  {
    "text": "and last one oh failed idempotency storage dot",
    "start": "6091566",
    "end": "6097166"
  },
  {
    "text": "parse JSON is not a function uh oh yeah we have some errors schema",
    "start": "6097600",
    "end": "6104500"
  },
  {
    "text": "why did you decided to rename things i don't know but yeah i will",
    "start": "6104500",
    "end": "6112532"
  },
  {
    "text": "try to make you more happy well man it changed",
    "start": "6112533",
    "end": "6118066"
  },
  {
    "text": "name everywhere schema i don't know",
    "start": "6118333",
    "end": "6124566"
  },
  {
    "text": "why he decided uh to change names well i can quickly",
    "start": "6124566",
    "end": "6131649"
  },
  {
    "text": "go through and fix them here schema i",
    "start": "6131649",
    "end": "6139199"
  },
  {
    "text": "don't know why it happens sometimes with the rename feature",
    "start": "6139200",
    "end": "6143799"
  },
  {
    "text": "oh yeah i i get that getting corrected the function in typescript is odd yeah the test worked",
    "start": "6144549",
    "end": "6152916"
  },
  {
    "text": "so let's try to run that in debug mode to see that the values are what we expect",
    "start": "6153350",
    "end": "6159350"
  },
  {
    "text": "okay here we have a delete we storage we persist we have the",
    "start": "6160633",
    "end": "6166399"
  },
  {
    "text": "previous result as an option and the value success and the value is 42",
    "start": "6166399",
    "end": "6175833"
  },
  {
    "text": "yeah nice nice nice nice really nice okay and let's",
    "start": "6175833",
    "end": "6183066"
  },
  {
    "text": "try to have a look at our database now we should have yeah you will",
    "start": "6183066",
    "end": "6189616"
  },
  {
    "text": "have multiple tables as you can and if we do things like showing the",
    "start": "6189616",
    "end": "6195299"
  },
  {
    "text": "record for this one yeah you should see that we have that nice",
    "start": "6195299",
    "end": "6200733"
  },
  {
    "text": "and even journal fill we are the data for that and you also have the",
    "start": "6202866",
    "end": "6208533"
  },
  {
    "text": "data for the other one nice okay so we have seen that our",
    "start": "6208533",
    "end": "6217432"
  },
  {
    "text": "idempotency storage works the way we expected and so i think that the last thing that",
    "start": "6217433",
    "end": "6224600"
  },
  {
    "text": "i'll do before closing the stream is performing tests",
    "start": "6224600",
    "end": "6230333"
  },
  {
    "text": "over the actual idempotency feature that",
    "start": "6230799",
    "end": "6235966"
  },
  {
    "text": "we have just built so this one basically",
    "start": "6235966",
    "end": "6239699"
  },
  {
    "text": "and i am not happy with the name but",
    "start": "6242149",
    "end": "6247316"
  },
  {
    "text": "maybe we can try to write some tests and then find out if we find out we have a value name we will",
    "start": "6247316",
    "end": "6257032"
  },
  {
    "text": "just ensure since this counts from the idempotency module calling that ensure idempotency is",
    "start": "6257033",
    "end": "6265950"
  },
  {
    "text": "redundant okay so let's try to write some",
    "start": "6265950",
    "end": "6271566"
  },
  {
    "text": "tests just for the idempotency module here idempotency.test.ts",
    "start": "6271616",
    "end": "6284516"
  },
  {
    "text": "and then we will start by grabbing everything from the previous test and",
    "start": "6285833",
    "end": "6292566"
  },
  {
    "text": "here we will remove that one okay and keep just the sqlite ones",
    "start": "6292566",
    "end": "6302466"
  },
  {
    "text": "really we can yeah we can just we can just use the in memory one",
    "start": "6303333",
    "end": "6308816"
  },
  {
    "text": "yeah we already have tests for the sql storage i don't need i don't",
    "start": "6308816",
    "end": "6314100"
  },
  {
    "text": "see the need of over testing those so we can so we can have simpler tests so we need",
    "start": "6314100",
    "end": "6322516"
  },
  {
    "text": "to import everything as idempotency from",
    "start": "6322516",
    "end": "6328049"
  },
  {
    "text": "src idempotency",
    "start": "6329666",
    "end": "6332266"
  },
  {
    "text": "okay and then should run if never happened before",
    "start": "6335033",
    "end": "6347649"
  },
  {
    "text": "okay and we can use a ref in",
    "start": "6347649",
    "end": "6353299"
  },
  {
    "text": "order to see how many times our competition has been run so let's say",
    "start": "6353299",
    "end": "6359733"
  },
  {
    "text": "that we have our effect schema number string",
    "start": "6359733",
    "end": "6366433"
  },
  {
    "text": "effect is okay we will keep that but now we will see something like",
    "start": "6367016",
    "end": "6373733"
  },
  {
    "text": "const test one will be something like",
    "start": "6373733",
    "end": "6380115"
  },
  {
    "text": "ref dot update and get we first",
    "start": "6380850",
    "end": "6386950"
  },
  {
    "text": "need to create a ref cost state ref equals yield star ref dot make will start",
    "start": "6386950",
    "end": "6396766"
  },
  {
    "text": "with zero and now i will delete all of these just to make typescript let me live with the",
    "start": "6396766",
    "end": "6405816"
  },
  {
    "text": "wiggle things okay we create a state ref the schema of the exit will be a success in a number",
    "start": "6405816",
    "end": "6412916"
  },
  {
    "text": "or a failure in a string or defect unknown and we'll start by using say something like our",
    "start": "6412916",
    "end": "6423766"
  },
  {
    "text": "computation will be like ref dot update and get state",
    "start": "6423766",
    "end": "6432266"
  },
  {
    "text": "ref and we'll do something like increment by one and then getting the",
    "start": "6432266",
    "end": "6437299"
  },
  {
    "text": "value so this is an effect we won't yield this effect okay we just",
    "start": "6437299",
    "end": "6444333"
  },
  {
    "text": "we'll use that effect for those tests and we'll say something like const run",
    "start": "6444333",
    "end": "6453516"
  },
  {
    "text": "one will be like pipe computation",
    "start": "6453516",
    "end": "6459216"
  },
  {
    "text": "and then idempotency dot ensure for",
    "start": "6461033",
    "end": "6467600"
  },
  {
    "text": "consumer message one",
    "start": "6467600",
    "end": "6471216"
  },
  {
    "text": "and exit schema okay we would need to",
    "start": "6472950",
    "end": "6478616"
  },
  {
    "text": "import i think pipe yeah okay this is a effect that",
    "start": "6478616",
    "end": "6483016"
  },
  {
    "text": "returns a number may fail with a string and has an idempotency",
    "start": "6483916",
    "end": "6489549"
  },
  {
    "text": "storage as a requirement and now i expect that",
    "start": "6489549",
    "end": "6496100"
  },
  {
    "text": "and maybe this computation can be reused multiple times but yeah like that okay",
    "start": "6498399",
    "end": "6504700"
  },
  {
    "text": "i expect const first run i expect that if",
    "start": "6507433",
    "end": "6513016"
  },
  {
    "text": "we yield this one another one okay i expect",
    "start": "6513016",
    "end": "6519799"
  },
  {
    "text": "first run to be one and i expect that",
    "start": "6523266",
    "end": "6529850"
  },
  {
    "text": "because on the first run what will happen is that these are the importance key for this",
    "start": "6529850",
    "end": "6536816"
  },
  {
    "text": "consumer has never been seen so from zero we'll increment to one and then get the",
    "start": "6536816",
    "end": "6543299"
  },
  {
    "text": "value so only on value one and then second run",
    "start": "6543299",
    "end": "6548850"
  },
  {
    "text": "i'll start run one and inspect again the first run",
    "start": "6551833",
    "end": "6558216"
  },
  {
    "text": "to be",
    "start": "6558466",
    "end": "6561265"
  },
  {
    "text": "one again second run sorry okay",
    "start": "6564316",
    "end": "6569199"
  },
  {
    "text": "and it seems that our tests are functioning so let's run",
    "start": "6570549",
    "end": "6576333"
  },
  {
    "text": "them in the back here first run we run our computation it's one perfectly",
    "start": "6576333",
    "end": "6583299"
  },
  {
    "text": "we can also try to put here a breakpoint like there and run again and see that",
    "start": "6583299",
    "end": "6593133"
  },
  {
    "text": "won't be run nice but if we try to run again our test we",
    "start": "6593133",
    "end": "6598399"
  },
  {
    "text": "will see that if we still have yeah it moved away my my",
    "start": "6598399",
    "end": "6604733"
  },
  {
    "text": "breakpoint but yeah what i wanted to show you is yeah that on the first run",
    "start": "6604733",
    "end": "6611049"
  },
  {
    "text": "we get into the breakpoint and then we won't get into the breakpoint again nice that is exactly",
    "start": "6611049",
    "end": "6618649"
  },
  {
    "text": "what we wanted so let me just clean up by removing that",
    "start": "6618649",
    "end": "6623433"
  },
  {
    "text": "don't send out and do not run again twice",
    "start": "6624799",
    "end": "6630500"
  },
  {
    "text": "okay but then if i do",
    "start": "6630500",
    "end": "6635566"
  },
  {
    "text": "something like run two and use a different idempotency key i",
    "start": "6635566",
    "end": "6645433"
  },
  {
    "text": "expect that third run",
    "start": "6645433",
    "end": "6651000"
  },
  {
    "text": "to be 2 because now when we run again with the second",
    "start": "6653850",
    "end": "6659666"
  },
  {
    "text": "idempotency key will be different so we'll actually run our effect so yeah",
    "start": "6659666",
    "end": "6666299"
  },
  {
    "text": "it works nice nice nice nice okay",
    "start": "6666299",
    "end": "6673049"
  },
  {
    "text": "so okay what can we do now",
    "start": "6674933",
    "end": "6682100"
  },
  {
    "text": "we have our event sourced aggregate we have our idempotency",
    "start": "6683483",
    "end": "6689866"
  },
  {
    "text": "i think that next stream we can finally look into actually having api's finally",
    "start": "6691483",
    "end": "6698765"
  },
  {
    "text": "i understand that maybe what we did into the streams up to now are",
    "start": "6699483",
    "end": "6704932"
  },
  {
    "text": "maybe more architectural things functional things that will be",
    "start": "6704933",
    "end": "6710416"
  },
  {
    "text": "used by the platform but yeah next time we can move definitely more leaning to use those",
    "start": "6710416",
    "end": "6718033"
  },
  {
    "text": "api's and i think that maybe since we have some time",
    "start": "6718033",
    "end": "6723450"
  },
  {
    "text": "right now and we can start doing some",
    "start": "6723899",
    "end": "6729766"
  },
  {
    "text": "cleanup of features but yeah",
    "start": "6729766",
    "end": "6734483"
  },
  {
    "text": "for example one thing that i would like to change a little",
    "start": "6738366",
    "end": "6744500"
  },
  {
    "text": "is that in our",
    "start": "6744683",
    "end": "6749866"
  },
  {
    "text": "idempotency storage right now",
    "start": "6749866",
    "end": "6755233"
  },
  {
    "text": "in the sql version",
    "start": "6756566",
    "end": "6759850"
  },
  {
    "text": "we do a select and then we do an insert",
    "start": "6761649",
    "end": "6769433"
  },
  {
    "text": "when we actually perform the insert",
    "start": "6769433",
    "end": "6775250"
  },
  {
    "text": "but what we will change the rendering into is something like inserting the record anyway",
    "start": "6775250",
    "end": "6780883"
  },
  {
    "text": "and then locking it by updating for example",
    "start": "6781333",
    "end": "6784433"
  },
  {
    "text": "that way we can for example",
    "start": "6787533",
    "end": "6790750"
  },
  {
    "text": "perform this logic of idempotency in a transaction and ensure",
    "start": "6793483",
    "end": "6798733"
  },
  {
    "text": "that that idempotency check will update one field into the table in a",
    "start": "6798733",
    "end": "6807100"
  },
  {
    "text": "way that will lock the record and we cannot then have",
    "start": "6807100",
    "end": "6812483"
  },
  {
    "text": "two different idempotency being run on the same entry if we're on a",
    "start": "6813083",
    "end": "6820633"
  },
  {
    "text": "transaction obviously because checking we update that and then",
    "start": "6820633",
    "end": "6826600"
  },
  {
    "text": "we update this count field for example",
    "start": "6826600",
    "end": "6832200"
  },
  {
    "text": "and then when we actually save we just",
    "start": "6832983",
    "end": "6838133"
  },
  {
    "text": "update one record yeah",
    "start": "6838133",
    "end": "6839799"
  },
  {
    "text": "that would be one thing that we'll do maybe next time indeed yeah",
    "start": "6844450",
    "end": "6848266"
  },
  {
    "text": "okay so i think that the only last thing that i would like to",
    "start": "6851149",
    "end": "6857633"
  },
  {
    "text": "tackle maybe is first of all run all of our tests and see",
    "start": "6858133",
    "end": "6866933"
  },
  {
    "text": "okay we are still running everything perfect and we also have tests for the server which",
    "start": "6866933",
    "end": "6876200"
  },
  {
    "text": "we are not actually not using for right now because right now we have only worked on the",
    "start": "6876200",
    "end": "6884133"
  },
  {
    "text": "domain part but yeah we will eventually also work next time as i said on our server part",
    "start": "6884133",
    "end": "6891149"
  },
  {
    "text": "you can see that we have errors in here because the APIs have changed a little the HTTP APIs of",
    "start": "6891149",
    "end": "6899750"
  },
  {
    "text": "effect are still something that is quite in the beta phase",
    "start": "6899750",
    "end": "6905000"
  },
  {
    "text": "and they are on a small reworking on how",
    "start": "6905000",
    "end": "6910466"
  },
  {
    "text": "they works but yeah i think that could be interesting for our obligations since this is a green field application it's a",
    "start": "6910466",
    "end": "6917283"
  },
  {
    "text": "an application that i won't be paid for there is something that i will use in one association that i am part of",
    "start": "6917283",
    "end": "6924049"
  },
  {
    "text": "as i described in the first episode of our streamings and then i",
    "start": "6924049",
    "end": "6930283"
  },
  {
    "text": "think that using something that is unstable is fine by me right now",
    "start": "6930283",
    "end": "6935266"
  },
  {
    "text": "but still we can we can open some discussion on how we want",
    "start": "6940333",
    "end": "6947449"
  },
  {
    "text": "our APIs to work for next time so um let's switch yeah maybe we can",
    "start": "6947450",
    "end": "6960466"
  },
  {
    "text": "leave this as an opening for next time stream",
    "start": "6960466",
    "end": "6965083"
  },
  {
    "text": "and it's better yeah. okay i think",
    "start": "6965483",
    "end": "6970699"
  },
  {
    "text": "that with this we have done quite a few things today",
    "start": "6970700",
    "end": "6975899"
  },
  {
    "text": "we have implemented our tests for our event sourced aggregate and we have seen",
    "start": "6976933",
    "end": "6983266"
  },
  {
    "text": "that it is working the way we expect and we have also implemented an",
    "start": "6983266",
    "end": "6991933"
  },
  {
    "text": "idempotency storage and an idempotency trade and we have",
    "start": "6991933",
    "end": "6998266"
  },
  {
    "text": "provided features for the trade so i think that for now i am",
    "start": "6998383",
    "end": "7004649"
  },
  {
    "text": "really pleased on what we have done so i will thank you you all for whatever",
    "start": "7004649",
    "end": "7012799"
  },
  {
    "text": "we have did today and for taking the stream again thanks again for the awesome feedback on the",
    "start": "7012799",
    "end": "7020666"
  },
  {
    "text": "first recording that has been published on the effect",
    "start": "7020666",
    "end": "7025133"
  },
  {
    "text": "video channel again please subscribe to the effect channel on",
    "start": "7025799",
    "end": "7031750"
  },
  {
    "text": "youtube to get notified whenever a new video gets published and well with",
    "start": "7031750",
    "end": "7037883"
  },
  {
    "text": "that thank you again for your time and hope to see you next week on thursday i think yeah okay",
    "start": "7037883",
    "end": "7046799"
  },
  {
    "text": "thank you very much again see you next time bye bye",
    "start": "7046799",
    "end": "7050583"
  }
]